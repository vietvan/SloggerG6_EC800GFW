/* Copyright (C) 2018 RDA Technologies Limited and/or its affiliates("RDA").
 * All rights reserved.
 *
 * This software is supplied "AS IS" without any warranties.
 * RDA assumes no responsibility or liability for the use of the software,
 * conveys no license or title under any patent, copyright, or mask work
 * right to the product. RDA reserves the right to make changes in the
 * software without notification.  RDA also make no representation or
 * warranty that such application will be suitable for the specified use
 * without further testing or modification.
 */

#ifndef _EMMC_H_
#define _EMMC_H_

// Auto generated by dtools(see dtools.txt for its version).
// Don't edit it manually!

#define REG_EMMC_BASE (0x04006000)

typedef volatile struct
{
    uint32_t blk_cnt;          // 0x00000000
    uint32_t blk_size;         // 0x00000004
    uint32_t argumnet;         // 0x00000008
    uint32_t tr_mode;          // 0x0000000c
    uint32_t resp0;            // 0x00000010
    uint32_t resp1;            // 0x00000014
    uint32_t resp2;            // 0x00000018
    uint32_t resp3;            // 0x0000001c
    uint32_t __32[1];          // 0x00000020
    uint32_t pres_state;       // 0x00000024
    uint32_t host_ctrl1;       // 0x00000028
    uint32_t clk_ctrl;         // 0x0000002c
    uint32_t int_st;           // 0x00000030
    uint32_t int_st_en;        // 0x00000034
    uint32_t int_sig_en;       // 0x00000038
    uint32_t host_ctrl2;       // 0x0000003c
    uint32_t cap1;             // 0x00000040
    uint32_t cap2;             // 0x00000044
    uint32_t __72[2];          // 0x00000048
    uint32_t frc_evt;          // 0x00000050
    uint32_t adma_err_sts;     // 0x00000054
    uint32_t adma2_addr_l;     // 0x00000058
    uint32_t adma2_addr_h;     // 0x0000005c
    uint32_t __96[6];          // 0x00000060
    uint32_t adma3_addr_l;     // 0x00000078
    uint32_t adma3_addr_h;     // 0x0000007c
    uint32_t __128[31];        // 0x00000080
    uint32_t host_ver;         // 0x000000fc
    uint32_t __256[64];        // 0x00000100
    uint32_t dll_cfg;          // 0x00000200
    uint32_t dll_dly;          // 0x00000204
    uint32_t dll_dly_offset;   // 0x00000208
    uint32_t __524[1];         // 0x0000020c
    uint32_t dll_sts0;         // 0x00000210
    uint32_t dll_sts1;         // 0x00000214
    uint32_t __536[2];         // 0x00000218
    uint32_t ram_addr_buf_l;   // 0x00000220
    uint32_t ram_addr_buf_h;   // 0x00000224
    uint32_t blk_cnt_buf;      // 0x00000228
    uint32_t blk_cnt_io;       // 0x0000022c
    uint32_t __560[4];         // 0x00000230
    uint32_t adma2_addr_ing_l; // 0x00000240
    uint32_t adma2_addr_ing_h; // 0x00000244
    uint32_t adma3_addr_ing_l; // 0x00000248
    uint32_t adma3_addr_ing_h; // 0x0000024c
    uint32_t busy_posi;        // 0x00000250
    uint32_t fsm_crcerr_sts;   // 0x00000254
    uint32_t __600[2];         // 0x00000258
    uint32_t fsm_debug0;       // 0x00000260
    uint32_t fsm_debug1;       // 0x00000264
    uint32_t fsm_debug2;       // 0x00000268
    uint32_t __620[8];         // 0x0000026c
    uint32_t dll_backup;       // 0x0000028c
} HWP_EMMC_T;

#define hwp_emmc ((HWP_EMMC_T *)REG_ACCESS_ADDRESS(REG_EMMC_BASE))

// blk_size
typedef union {
    uint32_t v;
    struct
    {
        uint32_t blk_size : 12; // [11:0]
        uint32_t __31_12 : 20;  // [31:12]
    } b;
} REG_EMMC_BLK_SIZE_T;

// tr_mode
typedef union {
    uint32_t v;
    struct
    {
        uint32_t dma_en : 1;          // [0]
        uint32_t blk_cnt_en : 1;      // [1]
        uint32_t auto_cmd_en : 2;     // [3:2]
        uint32_t data_dir_sel : 1;    // [4]
        uint32_t mult_blk_sel : 1;    // [5]
        uint32_t resp_type : 1;       // [6]
        uint32_t resp_err_chk_en : 1; // [7]
        uint32_t resp_int_dis : 1;    // [8]
        uint32_t __15_9 : 7;          // [15:9]
        uint32_t resp_type_sel : 2;   // [17:16]
        uint32_t sub_cmd_flag : 1;    // [18]
        uint32_t cmd_crc_chk_en : 1;  // [19]
        uint32_t cmd_ind_chk_en : 1;  // [20]
        uint32_t data_pre_sel : 1;    // [21]
        uint32_t cmd_type : 2;        // [23:22]
        uint32_t cmd_index : 6;       // [29:24]
        uint32_t cmd_line_boot : 1;   // [30]
        uint32_t boot_ack : 1;        // [31]
    } b;
} REG_EMMC_TR_MODE_T;

// pres_state
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cmd_inh_cmd : 1;     // [0], read only
        uint32_t cmd_inh_dat : 1;     // [1], read only
        uint32_t dat_line_active : 1; // [2], read only
        uint32_t __3_3 : 1;           // [3]
        uint32_t dat_line7_4 : 4;     // [7:4], read only
        uint32_t write_acitve : 1;    // [8], read only
        uint32_t read_active : 1;     // [9]
        uint32_t __19_10 : 10;        // [19:10]
        uint32_t dat_line3_0 : 4;     // [23:20], read only
        uint32_t cmd_line : 1;        // [24], read only
        uint32_t __27_25 : 3;         // [27:25]
        uint32_t sub_cmd_flag : 1;    // [28], read only
        uint32_t __31_29 : 3;         // [31:29]
    } b;
} REG_EMMC_PRES_STATE_T;

// host_ctrl1
typedef union {
    uint32_t v;
    struct
    {
        uint32_t __0_0 : 1;          // [0]
        uint32_t sd4b_mode : 1;      // [1]
        uint32_t __2_2 : 1;          // [2]
        uint32_t dma_sel : 2;        // [4:3]
        uint32_t sd8_mode : 1;       // [5]
        uint32_t __17_6 : 12;        // [17:6]
        uint32_t rd_wait_ctrl : 1;   // [18]
        uint32_t int_at_blk_gap : 1; // [19]
        uint32_t __31_20 : 12;       // [31:20]
    } b;
} REG_EMMC_HOST_CTRL1_T;

// clk_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t int_clk_en : 1;       // [0]
        uint32_t int_clk_stable : 1;   // [1], read only
        uint32_t sdclk_en : 1;         // [2]
        uint32_t __5_3 : 3;            // [5:3]
        uint32_t freq_div_8_9 : 2;     // [7:6]
        uint32_t freq_div_0_7 : 8;     // [15:8]
        uint32_t data_timeout_cnt : 4; // [19:16]
        uint32_t __23_20 : 4;          // [23:20]
        uint32_t sw_rst_all : 1;       // [24]
        uint32_t sw_rst_cmd : 1;       // [25]
        uint32_t sw_rst_dat : 1;       // [26]
        uint32_t hw_rst_card : 1;      // [27]
        uint32_t __31_28 : 4;          // [31:28]
    } b;
} REG_EMMC_CLK_CTRL_T;

// int_st
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cmd_complete : 1;     // [0], write clear
        uint32_t tr_complete : 1;      // [1], write clear
        uint32_t __2_2 : 1;            // [2]
        uint32_t dma_int : 1;          // [3], write clear
        uint32_t __7_4 : 4;            // [7:4]
        uint32_t card_int : 1;         // [8], write clear
        uint32_t __13_9 : 5;           // [13:9]
        uint32_t adma3_complete : 1;   // [14], write clear
        uint32_t err_int : 1;          // [15], write clear
        uint32_t cmd_timeout_err : 1;  // [16], write clear
        uint32_t cmd_crc_error : 1;    // [17], write clear
        uint32_t cmd_end_bit_err : 1;  // [18], write clear
        uint32_t cmd_ind_err : 1;      // [19], write clear
        uint32_t data_timeout_err : 1; // [20], write clear
        uint32_t data_crc_err : 1;     // [21], write clear
        uint32_t data_end_bit_err : 1; // [22], write clear
        uint32_t __23_23 : 1;          // [23]
        uint32_t auto_cmd12_err : 1;   // [24], write clear
        uint32_t adma_error : 1;       // [25], write clear
        uint32_t __26_26 : 1;          // [26]
        uint32_t resp_error : 1;       // [27], write clear
        uint32_t axi_resp_err : 1;     // [28], write clear
        uint32_t __31_29 : 3;          // [31:29]
    } b;
} REG_EMMC_INT_ST_T;

// int_st_en
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cmd_complete_en : 1;     // [0]
        uint32_t tr_complete_en : 1;      // [1]
        uint32_t __2_2 : 1;               // [2]
        uint32_t dma_int_en : 1;          // [3]
        uint32_t __7_4 : 4;               // [7:4]
        uint32_t card_int_en : 1;         // [8]
        uint32_t __13_9 : 5;              // [13:9]
        uint32_t adma3_complete_en : 1;   // [14]
        uint32_t __15_15 : 1;             // [15]
        uint32_t cmd_timeout_err_en : 1;  // [16]
        uint32_t cmd_crc_error_en : 1;    // [17]
        uint32_t cmd_end_bit_err_en : 1;  // [18]
        uint32_t cmd_ind_err_en : 1;      // [19]
        uint32_t data_timeout_err_en : 1; // [20]
        uint32_t data_crc_err_en : 1;     // [21]
        uint32_t data_end_bit_err_en : 1; // [22]
        uint32_t __23_23 : 1;             // [23]
        uint32_t auto_cmd12_err_en : 1;   // [24]
        uint32_t adma_error_en : 1;       // [25]
        uint32_t __26_26 : 1;             // [26]
        uint32_t resp_error_en : 1;       // [27]
        uint32_t axi_resp_err_en : 1;     // [28]
        uint32_t __31_29 : 3;             // [31:29]
    } b;
} REG_EMMC_INT_ST_EN_T;

// int_sig_en
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cmd_complete_en : 1;     // [0]
        uint32_t tr_complete_en : 1;      // [1]
        uint32_t __2_2 : 1;               // [2]
        uint32_t dma_int_en : 1;          // [3]
        uint32_t __7_4 : 4;               // [7:4]
        uint32_t card_int_en : 1;         // [8]
        uint32_t __13_9 : 5;              // [13:9]
        uint32_t adma3_complete_en : 1;   // [14]
        uint32_t __15_15 : 1;             // [15]
        uint32_t cmd_timeout_err_en : 1;  // [16]
        uint32_t cmd_crc_error_en : 1;    // [17]
        uint32_t cmd_end_bit_err_en : 1;  // [18]
        uint32_t cmd_ind_err_en : 1;      // [19]
        uint32_t data_timeout_err_en : 1; // [20]
        uint32_t data_crc_err_en : 1;     // [21]
        uint32_t data_end_bit_err_en : 1; // [22]
        uint32_t cur_lmt_err_en : 1;      // [23]
        uint32_t auto_cmd12_err_en : 1;   // [24]
        uint32_t adma_error_en : 1;       // [25]
        uint32_t __26_26 : 1;             // [26]
        uint32_t resp_error_en : 1;       // [27]
        uint32_t axi_resp_err_en : 1;     // [28]
        uint32_t __31_29 : 3;             // [31:29]
    } b;
} REG_EMMC_INT_SIG_EN_T;

// host_ctrl2
typedef union {
    uint32_t v;
    struct
    {
        uint32_t acmd12_not_exec : 1;  // [0], read only
        uint32_t acmd_timeout_err : 1; // [1], read only
        uint32_t acmd_crc_err : 1;     // [2], read only
        uint32_t acmd_end_bit_err : 1; // [3], read only
        uint32_t acmd_idx_err : 1;     // [4], read only
        uint32_t __6_5 : 2;            // [6:5]
        uint32_t cmd_not_iss_err : 1;  // [7], read only
        uint32_t __15_8 : 8;           // [15:8]
        uint32_t uhs_mode : 4;         // [19:16]
        uint32_t __25_20 : 6;          // [25:20]
        uint32_t adma2_len_mode : 1;   // [26]
        uint32_t cmd23_enable : 1;     // [27]
        uint32_t host_ver_4_en : 1;    // [28], read only
        uint32_t addr_64bit_en : 1;    // [29]
        uint32_t __31_30 : 2;          // [31:30]
    } b;
} REG_EMMC_HOST_CTRL2_T;

// cap1
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timeout_clk_frq : 6;   // [5:0], read only
        uint32_t __6_6 : 1;             // [6]
        uint32_t timeout_clk_unit : 1;  // [7], read only
        uint32_t base_clk_frq : 8;      // [15:8], read only
        uint32_t max_blk_size : 2;      // [17:16], read only
        uint32_t sup_8bit : 1;          // [18], read only
        uint32_t adma2_support : 1;     // [19], read only
        uint32_t __20_20 : 1;           // [20]
        uint32_t high_speed : 1;        // [21], read only
        uint32_t dma : 1;               // [22], read only
        uint32_t susp_res : 1;          // [23], read only
        uint32_t v33 : 1;               // [24], read only
        uint32_t v30 : 1;               // [25], read only
        uint32_t v18 : 1;               // [26], read only
        uint32_t addr_64bit_sup_v4 : 1; // [27], read only
        uint32_t addr_64bit_sup_v3 : 1; // [28], read only
        uint32_t async_int : 1;         // [29], read only
        uint32_t slot_type : 2;         // [31:30], read only
    } b;
} REG_EMMC_CAP1_T;

// cap2
typedef union {
    uint32_t v;
    struct
    {
        uint32_t sdr50_sup : 1;     // [0], read only
        uint32_t sdr104_sup : 1;    // [1], read only
        uint32_t ddr50_sup : 1;     // [2], read only
        uint32_t __26_3 : 24;       // [26:3]
        uint32_t adma3_support : 1; // [27], read only
        uint32_t __31_28 : 4;       // [31:28]
    } b;
} REG_EMMC_CAP2_T;

// frc_evt
typedef union {
    uint32_t v;
    struct
    {
        uint32_t frc_evt_acmd_nexec : 1;   // [0]
        uint32_t frc_evt_acmd_tout : 1;    // [1]
        uint32_t frc_evt_acmd_crc : 1;     // [2]
        uint32_t frc_evt_acmd_end : 1;     // [3]
        uint32_t frc_evt_acmd_ind : 1;     // [4]
        uint32_t __6_5 : 2;                // [6:5]
        uint32_t frc_evt_acmd12 : 1;       // [7]
        uint32_t __15_8 : 8;               // [15:8]
        uint32_t frc_evt_cmd_tout : 1;     // [16]
        uint32_t frc_evt_cmd_crc : 1;      // [17]
        uint32_t frc_evt_cmd_end : 1;      // [18]
        uint32_t frc_evt_cmd_ind : 1;      // [19]
        uint32_t frc_evt_cmd_dat_tout : 1; // [20]
        uint32_t frc_evt_cmd_dat_crc : 1;  // [21]
        uint32_t frc_evt_cmd_dat_end : 1;  // [22]
        uint32_t __23_23 : 1;              // [23]
        uint32_t frc_evt_resp_err : 1;     // [24]
        uint32_t frc_evt_tun_err : 1;      // [25]
        uint32_t __26_26 : 1;              // [26]
        uint32_t frc_evt_acmd_err : 1;     // [27]
        uint32_t __31_28 : 4;              // [31:28]
    } b;
} REG_EMMC_FRC_EVT_T;

// adma_err_sts
typedef union {
    uint32_t v;
    struct
    {
        uint32_t adma_err_state : 2;       // [1:0], read only
        uint32_t adma_length_mismatch : 1; // [2], read only
        uint32_t __15_3 : 13;              // [15:3]
        uint32_t rresp_err : 2;            // [17:16], read only
        uint32_t bresp_err : 2;            // [19:18], read only
        uint32_t __31_20 : 12;             // [31:20]
    } b;
} REG_EMMC_ADMA_ERR_STS_T;

// host_ver
typedef union {
    uint32_t v;
    struct
    {
        uint32_t slt1_int : 1; // [0], read only
        uint32_t __15_1 : 15;  // [15:1]
        uint32_t host_ver : 8; // [23:16], read only
        uint32_t __31_24 : 8;  // [31:24]
    } b;
} REG_EMMC_HOST_VER_T;

// dll_cfg
typedef union {
    uint32_t v;
    struct
    {
        uint32_t clk_phase_sel : 1;      // [0]
        uint32_t dll_phase_interval : 2; // [2:1]
        uint32_t __3_3 : 1;              // [3]
        uint32_t dll_cpst_threshold : 4; // [7:4]
        uint32_t dll_init : 7;           // [14:8]
        uint32_t __15_15 : 1;            // [15]
        uint32_t dll_half_mode : 1;      // [16]
        uint32_t dll_cpst_start : 1;     // [17]
        uint32_t dll_cpst_en : 1;        // [18]
        uint32_t dll_auto_clr_en : 1;    // [19]
        uint32_t dll_clr : 1;            // [20]
        uint32_t dll_en : 1;             // [21]
        uint32_t dll_clk_sel : 1;        // [22]
        uint32_t __23_23 : 1;            // [23]
        uint32_t dll_datwr_cpst_en : 1;  // [24]
        uint32_t dll_rdcmd_cpst_en : 1;  // [25]
        uint32_t dll_rdpos_cpst_en : 1;  // [26]
        uint32_t dll_rdneg_cpst_en : 1;  // [27]
        uint32_t dll_wait_cnt : 4;       // [31:28], read only
    } b;
} REG_EMMC_DLL_CFG_T;

// dll_dly
typedef union {
    uint32_t v;
    struct
    {
        uint32_t clkdatwr_dly_val : 8; // [7:0]
        uint32_t clkcmdrd_dly_val : 8; // [15:8]
        uint32_t clkposrd_dly_val : 8; // [23:16]
        uint32_t clknegrd_dly_val : 8; // [31:24]
    } b;
} REG_EMMC_DLL_DLY_T;

// dll_dly_offset
typedef union {
    uint32_t v;
    struct
    {
        uint32_t clkdatwr_dly_offset : 5; // [4:0]
        uint32_t clkdatwr_dly_inv : 1;    // [5]
        uint32_t __7_6 : 2;               // [7:6]
        uint32_t clkcmdrd_dly_offset : 5; // [12:8]
        uint32_t clkcmdrd_dly_inv : 1;    // [13]
        uint32_t __15_14 : 2;             // [15:14]
        uint32_t clkposrd_dly_offset : 5; // [20:16]
        uint32_t clkposrd_dly_inv : 1;    // [21]
        uint32_t __23_22 : 2;             // [23:22]
        uint32_t clknegrd_dly_offset : 5; // [28:24]
        uint32_t clknegrd_dly_inv : 1;    // [29]
        uint32_t __31_30 : 2;             // [31:30]
    } b;
} REG_EMMC_DLL_DLY_OFFSET_T;

// dll_sts0
typedef union {
    uint32_t v;
    struct
    {
        uint32_t dll_cnt : 8;     // [7:0], read only
        uint32_t dll_st : 4;      // [11:8], read only
        uint32_t __15_12 : 4;     // [15:12]
        uint32_t dll_cpst_st : 1; // [16], read only
        uint32_t dll_error : 1;   // [17], read only
        uint32_t dll_locked : 1;  // [18], read only
        uint32_t dll_phase2 : 1;  // [19], read only
        uint32_t dll_phase1 : 1;  // [20], read only
        uint32_t __31_21 : 11;    // [31:21]
    } b;
} REG_EMMC_DLL_STS0_T;

// dll_sts1
typedef union {
    uint32_t v;
    struct
    {
        uint32_t clkdatwr_dly_cnt : 8; // [7:0], read only
        uint32_t clkcmdrd_dly_cnt : 8; // [15:8], read only
        uint32_t clkposrd_dly_cnt : 8; // [23:16], read only
        uint32_t clknegrd_dly_cnt : 8; // [31:24], read only
    } b;
} REG_EMMC_DLL_STS1_T;

// busy_posi
typedef union {
    uint32_t v;
    struct
    {
        uint32_t read_busy_posi_set : 4;   // [3:0]
        uint32_t crcsts_posi_set : 4;      // [7:4]
        uint32_t read_busy_posi_force : 1; // [8]
        uint32_t crcsts_posi_force : 1;    // [9]
        uint32_t sdcard_clk_ie : 1;        // [10]
        uint32_t sdcard_clk_oe : 1;        // [11]
        uint32_t mstrs_prot : 3;           // [14:12]
        uint32_t abort_bug_option : 1;     // [15]
        uint32_t read_busy_posi_sts : 4;   // [19:16]
        uint32_t crcsts_posi_sts : 4;      // [23:20]
        uint32_t innr_clk_auto_en : 1;     // [24]
        uint32_t outr_clk_auto_en : 1;     // [25]
        uint32_t __31_26 : 6;              // [31:26]
    } b;
} REG_EMMC_BUSY_POSI_T;

// fsm_crcerr_sts
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rdata_crc_error : 16; // [15:0], read only
        uint32_t __31_16 : 16;         // [31:16]
    } b;
} REG_EMMC_FSM_CRCERR_STS_T;

// fsm_debug0
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cmd_fsm : 5;         // [4:0], read only
        uint32_t __7_5 : 3;           // [7:5]
        uint32_t trans_fsm : 6;       // [13:8], read only
        uint32_t __15_14 : 2;         // [15:14]
        uint32_t recv_fsm : 4;        // [19:16], read only
        uint32_t __30_20 : 11;        // [30:20]
        uint32_t clk_pad_out_ind : 1; // [31], read only
    } b;
} REG_EMMC_FSM_DEBUG0_T;

// fsm_debug1
typedef union {
    uint32_t v;
    struct
    {
        uint32_t io_fsm : 4;    // [3:0], read only
        uint32_t mst_fsm : 4;   // [7:4], read only
        uint32_t __8_8 : 1;     // [8]
        uint32_t adma2_fsm : 3; // [11:9], read only
        uint32_t adma3_fsm : 4; // [15:12], read only
        uint32_t __31_16 : 16;  // [31:16]
    } b;
} REG_EMMC_FSM_DEBUG1_T;

// fsm_debug2
typedef union {
    uint32_t v;
    struct
    {
        uint32_t addr_fsm : 4; // [3:0], read only
        uint32_t data_fsm : 4; // [7:4], read only
        uint32_t __31_8 : 24;  // [31:8]
    } b;
} REG_EMMC_FSM_DEBUG2_T;

// dll_backup
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_dll_backup : 1;         // [0]
        uint32_t rf_dll_backup_value : 1;   // [1]
        uint32_t rf_dll_slice_en_force : 1; // [2]
        uint32_t rf_dll_slice_en_value : 1; // [3]
        uint32_t oe_ext_optional : 1;       // [4]
        uint32_t __31_5 : 27;               // [31:5]
    } b;
} REG_EMMC_DLL_BACKUP_T;

// blk_size
#define EMMC_BLK_SIZE(n) (((n)&0xfff) << 0)

// tr_mode
#define EMMC_DMA_EN (1 << 0)
#define EMMC_BLK_CNT_EN (1 << 1)
#define EMMC_AUTO_CMD_EN(n) (((n)&0x3) << 2)
#define EMMC_DATA_DIR_SEL (1 << 4)
#define EMMC_MULT_BLK_SEL (1 << 5)
#define EMMC_RESP_TYPE (1 << 6)
#define EMMC_RESP_ERR_CHK_EN (1 << 7)
#define EMMC_RESP_INT_DIS (1 << 8)
#define EMMC_RESP_TYPE_SEL(n) (((n)&0x3) << 16)
#define EMMC_TR_MODE_SUB_CMD_FLAG (1 << 18)
#define EMMC_CMD_CRC_CHK_EN (1 << 19)
#define EMMC_CMD_IND_CHK_EN (1 << 20)
#define EMMC_DATA_PRE_SEL (1 << 21)
#define EMMC_CMD_TYPE(n) (((n)&0x3) << 22)
#define EMMC_CMD_INDEX(n) (((n)&0x3f) << 24)
#define EMMC_CMD_LINE_BOOT (1 << 30)
#define EMMC_BOOT_ACK (1 << 31)

// pres_state
#define EMMC_CMD_INH_CMD (1 << 0)
#define EMMC_CMD_INH_DAT (1 << 1)
#define EMMC_DAT_LINE_ACTIVE (1 << 2)
#define EMMC_DAT_LINE7_4(n) (((n)&0xf) << 4)
#define EMMC_WRITE_ACITVE (1 << 8)
#define EMMC_READ_ACTIVE (1 << 9)
#define EMMC_DAT_LINE3_0(n) (((n)&0xf) << 20)
#define EMMC_CMD_LINE (1 << 24)
#define EMMC_PRES_STATE_SUB_CMD_FLAG (1 << 28)

// host_ctrl1
#define EMMC_SD4B_MODE (1 << 1)
#define EMMC_DMA_SEL(n) (((n)&0x3) << 3)
#define EMMC_SD8_MODE (1 << 5)
#define EMMC_RD_WAIT_CTRL (1 << 18)
#define EMMC_INT_AT_BLK_GAP (1 << 19)

// clk_ctrl
#define EMMC_INT_CLK_EN (1 << 0)
#define EMMC_INT_CLK_STABLE (1 << 1)
#define EMMC_SDCLK_EN (1 << 2)
#define EMMC_FREQ_DIV_8_9(n) (((n)&0x3) << 6)
#define EMMC_FREQ_DIV_0_7(n) (((n)&0xff) << 8)
#define EMMC_DATA_TIMEOUT_CNT(n) (((n)&0xf) << 16)
#define EMMC_SW_RST_ALL (1 << 24)
#define EMMC_SW_RST_CMD (1 << 25)
#define EMMC_SW_RST_DAT (1 << 26)
#define EMMC_HW_RST_CARD (1 << 27)

// int_st
#define EMMC_CMD_COMPLETE (1 << 0)
#define EMMC_TR_COMPLETE (1 << 1)
#define EMMC_DMA_INT (1 << 3)
#define EMMC_CARD_INT (1 << 8)
#define EMMC_ADMA3_COMPLETE (1 << 14)
#define EMMC_ERR_INT (1 << 15)
#define EMMC_CMD_TIMEOUT_ERR (1 << 16)
#define EMMC_CMD_CRC_ERROR (1 << 17)
#define EMMC_CMD_END_BIT_ERR (1 << 18)
#define EMMC_CMD_IND_ERR (1 << 19)
#define EMMC_DATA_TIMEOUT_ERR (1 << 20)
#define EMMC_DATA_CRC_ERR (1 << 21)
#define EMMC_DATA_END_BIT_ERR (1 << 22)
#define EMMC_AUTO_CMD12_ERR (1 << 24)
#define EMMC_ADMA_ERROR (1 << 25)
#define EMMC_RESP_ERROR (1 << 27)
#define EMMC_AXI_RESP_ERR (1 << 28)

// int_st_en
#define EMMC_CMD_COMPLETE_EN (1 << 0)
#define EMMC_TR_COMPLETE_EN (1 << 1)
#define EMMC_DMA_INT_EN (1 << 3)
#define EMMC_CARD_INT_EN (1 << 8)
#define EMMC_ADMA3_COMPLETE_EN (1 << 14)
#define EMMC_CMD_TIMEOUT_ERR_EN (1 << 16)
#define EMMC_CMD_CRC_ERROR_EN (1 << 17)
#define EMMC_CMD_END_BIT_ERR_EN (1 << 18)
#define EMMC_CMD_IND_ERR_EN (1 << 19)
#define EMMC_DATA_TIMEOUT_ERR_EN (1 << 20)
#define EMMC_DATA_CRC_ERR_EN (1 << 21)
#define EMMC_DATA_END_BIT_ERR_EN (1 << 22)
#define EMMC_AUTO_CMD12_ERR_EN (1 << 24)
#define EMMC_ADMA_ERROR_EN (1 << 25)
#define EMMC_RESP_ERROR_EN (1 << 27)
#define EMMC_AXI_RESP_ERR_EN (1 << 28)

// int_sig_en
#define EMMC_CMD_COMPLETE_EN (1 << 0)
#define EMMC_TR_COMPLETE_EN (1 << 1)
#define EMMC_DMA_INT_EN (1 << 3)
#define EMMC_CARD_INT_EN (1 << 8)
#define EMMC_ADMA3_COMPLETE_EN (1 << 14)
#define EMMC_CMD_TIMEOUT_ERR_EN (1 << 16)
#define EMMC_CMD_CRC_ERROR_EN (1 << 17)
#define EMMC_CMD_END_BIT_ERR_EN (1 << 18)
#define EMMC_CMD_IND_ERR_EN (1 << 19)
#define EMMC_DATA_TIMEOUT_ERR_EN (1 << 20)
#define EMMC_DATA_CRC_ERR_EN (1 << 21)
#define EMMC_DATA_END_BIT_ERR_EN (1 << 22)
#define EMMC_CUR_LMT_ERR_EN (1 << 23)
#define EMMC_AUTO_CMD12_ERR_EN (1 << 24)
#define EMMC_ADMA_ERROR_EN (1 << 25)
#define EMMC_RESP_ERROR_EN (1 << 27)
#define EMMC_AXI_RESP_ERR_EN (1 << 28)

// host_ctrl2
#define EMMC_ACMD12_NOT_EXEC (1 << 0)
#define EMMC_ACMD_TIMEOUT_ERR (1 << 1)
#define EMMC_ACMD_CRC_ERR (1 << 2)
#define EMMC_ACMD_END_BIT_ERR (1 << 3)
#define EMMC_ACMD_IDX_ERR (1 << 4)
#define EMMC_CMD_NOT_ISS_ERR (1 << 7)
#define EMMC_UHS_MODE(n) (((n)&0xf) << 16)
#define EMMC_ADMA2_LEN_MODE (1 << 26)
#define EMMC_CMD23_ENABLE (1 << 27)
#define EMMC_HOST_VER_4_EN (1 << 28)
#define EMMC_ADDR_64BIT_EN (1 << 29)

// cap1
#define EMMC_TIMEOUT_CLK_FRQ(n) (((n)&0x3f) << 0)
#define EMMC_TIMEOUT_CLK_UNIT (1 << 7)
#define EMMC_BASE_CLK_FRQ(n) (((n)&0xff) << 8)
#define EMMC_MAX_BLK_SIZE(n) (((n)&0x3) << 16)
#define EMMC_SUP_8BIT (1 << 18)
#define EMMC_ADMA2_SUPPORT (1 << 19)
#define EMMC_HIGH_SPEED (1 << 21)
#define EMMC_DMA (1 << 22)
#define EMMC_SUSP_RES (1 << 23)
#define EMMC_V33 (1 << 24)
#define EMMC_V30 (1 << 25)
#define EMMC_V18 (1 << 26)
#define EMMC_ADDR_64BIT_SUP_V4 (1 << 27)
#define EMMC_ADDR_64BIT_SUP_V3 (1 << 28)
#define EMMC_ASYNC_INT (1 << 29)
#define EMMC_SLOT_TYPE(n) (((n)&0x3) << 30)

// cap2
#define EMMC_SDR50_SUP (1 << 0)
#define EMMC_SDR104_SUP (1 << 1)
#define EMMC_DDR50_SUP (1 << 2)
#define EMMC_ADMA3_SUPPORT (1 << 27)

// frc_evt
#define EMMC_FRC_EVT_ACMD_NEXEC (1 << 0)
#define EMMC_FRC_EVT_ACMD_TOUT (1 << 1)
#define EMMC_FRC_EVT_ACMD_CRC (1 << 2)
#define EMMC_FRC_EVT_ACMD_END (1 << 3)
#define EMMC_FRC_EVT_ACMD_IND (1 << 4)
#define EMMC_FRC_EVT_ACMD12 (1 << 7)
#define EMMC_FRC_EVT_CMD_TOUT (1 << 16)
#define EMMC_FRC_EVT_CMD_CRC (1 << 17)
#define EMMC_FRC_EVT_CMD_END (1 << 18)
#define EMMC_FRC_EVT_CMD_IND (1 << 19)
#define EMMC_FRC_EVT_CMD_DAT_TOUT (1 << 20)
#define EMMC_FRC_EVT_CMD_DAT_CRC (1 << 21)
#define EMMC_FRC_EVT_CMD_DAT_END (1 << 22)
#define EMMC_FRC_EVT_RESP_ERR (1 << 24)
#define EMMC_FRC_EVT_TUN_ERR (1 << 25)
#define EMMC_FRC_EVT_ACMD_ERR (1 << 27)

// adma_err_sts
#define EMMC_ADMA_ERR_STATE(n) (((n)&0x3) << 0)
#define EMMC_ADMA_LENGTH_MISMATCH (1 << 2)
#define EMMC_RRESP_ERR(n) (((n)&0x3) << 16)
#define EMMC_BRESP_ERR(n) (((n)&0x3) << 18)

// host_ver
#define EMMC_SLT1_INT (1 << 0)
#define EMMC_HOST_VER(n) (((n)&0xff) << 16)

// dll_cfg
#define EMMC_CLK_PHASE_SEL (1 << 0)
#define EMMC_DLL_PHASE_INTERVAL(n) (((n)&0x3) << 1)
#define EMMC_DLL_CPST_THRESHOLD(n) (((n)&0xf) << 4)
#define EMMC_DLL_INIT(n) (((n)&0x7f) << 8)
#define EMMC_DLL_HALF_MODE (1 << 16)
#define EMMC_DLL_CPST_START (1 << 17)
#define EMMC_DLL_CPST_EN (1 << 18)
#define EMMC_DLL_AUTO_CLR_EN (1 << 19)
#define EMMC_DLL_CLR (1 << 20)
#define EMMC_DLL_EN (1 << 21)
#define EMMC_DLL_CLK_SEL (1 << 22)
#define EMMC_DLL_DATWR_CPST_EN (1 << 24)
#define EMMC_DLL_RDCMD_CPST_EN (1 << 25)
#define EMMC_DLL_RDPOS_CPST_EN (1 << 26)
#define EMMC_DLL_RDNEG_CPST_EN (1 << 27)
#define EMMC_DLL_WAIT_CNT(n) (((n)&0xf) << 28)

// dll_dly
#define EMMC_CLKDATWR_DLY_VAL(n) (((n)&0xff) << 0)
#define EMMC_CLKCMDRD_DLY_VAL(n) (((n)&0xff) << 8)
#define EMMC_CLKPOSRD_DLY_VAL(n) (((n)&0xff) << 16)
#define EMMC_CLKNEGRD_DLY_VAL(n) (((n)&0xff) << 24)

// dll_dly_offset
#define EMMC_CLKDATWR_DLY_OFFSET(n) (((n)&0x1f) << 0)
#define EMMC_CLKDATWR_DLY_INV (1 << 5)
#define EMMC_CLKCMDRD_DLY_OFFSET(n) (((n)&0x1f) << 8)
#define EMMC_CLKCMDRD_DLY_INV (1 << 13)
#define EMMC_CLKPOSRD_DLY_OFFSET(n) (((n)&0x1f) << 16)
#define EMMC_CLKPOSRD_DLY_INV (1 << 21)
#define EMMC_CLKNEGRD_DLY_OFFSET(n) (((n)&0x1f) << 24)
#define EMMC_CLKNEGRD_DLY_INV (1 << 29)

// dll_sts0
#define EMMC_DLL_CNT(n) (((n)&0xff) << 0)
#define EMMC_DLL_ST(n) (((n)&0xf) << 8)
#define EMMC_DLL_CPST_ST (1 << 16)
#define EMMC_DLL_ERROR (1 << 17)
#define EMMC_DLL_LOCKED (1 << 18)
#define EMMC_DLL_PHASE2 (1 << 19)
#define EMMC_DLL_PHASE1 (1 << 20)

// dll_sts1
#define EMMC_CLKDATWR_DLY_CNT(n) (((n)&0xff) << 0)
#define EMMC_CLKCMDRD_DLY_CNT(n) (((n)&0xff) << 8)
#define EMMC_CLKPOSRD_DLY_CNT(n) (((n)&0xff) << 16)
#define EMMC_CLKNEGRD_DLY_CNT(n) (((n)&0xff) << 24)

// busy_posi
#define EMMC_READ_BUSY_POSI_SET(n) (((n)&0xf) << 0)
#define EMMC_CRCSTS_POSI_SET(n) (((n)&0xf) << 4)
#define EMMC_READ_BUSY_POSI_FORCE (1 << 8)
#define EMMC_CRCSTS_POSI_FORCE (1 << 9)
#define EMMC_SDCARD_CLK_IE (1 << 10)
#define EMMC_SDCARD_CLK_OE (1 << 11)
#define EMMC_MSTRS_PROT(n) (((n)&0x7) << 12)
#define EMMC_ABORT_BUG_OPTION (1 << 15)
#define EMMC_READ_BUSY_POSI_STS(n) (((n)&0xf) << 16)
#define EMMC_CRCSTS_POSI_STS(n) (((n)&0xf) << 20)
#define EMMC_INNR_CLK_AUTO_EN (1 << 24)
#define EMMC_OUTR_CLK_AUTO_EN (1 << 25)

// fsm_crcerr_sts
#define EMMC_RDATA_CRC_ERROR(n) (((n)&0xffff) << 0)

// fsm_debug0
#define EMMC_CMD_FSM(n) (((n)&0x1f) << 0)
#define EMMC_TRANS_FSM(n) (((n)&0x3f) << 8)
#define EMMC_RECV_FSM(n) (((n)&0xf) << 16)
#define EMMC_CLK_PAD_OUT_IND (1 << 31)

// fsm_debug1
#define EMMC_IO_FSM(n) (((n)&0xf) << 0)
#define EMMC_MST_FSM(n) (((n)&0xf) << 4)
#define EMMC_ADMA2_FSM(n) (((n)&0x7) << 9)
#define EMMC_ADMA3_FSM(n) (((n)&0xf) << 12)

// fsm_debug2
#define EMMC_ADDR_FSM(n) (((n)&0xf) << 0)
#define EMMC_DATA_FSM(n) (((n)&0xf) << 4)

// dll_backup
#define EMMC_RF_DLL_BACKUP (1 << 0)
#define EMMC_RF_DLL_BACKUP_VALUE (1 << 1)
#define EMMC_RF_DLL_SLICE_EN_FORCE (1 << 2)
#define EMMC_RF_DLL_SLICE_EN_VALUE (1 << 3)
#define EMMC_OE_EXT_OPTIONAL (1 << 4)

#endif // _EMMC_H_
