/* Copyright (C) 2018 RDA Technologies Limited and/or its affiliates("RDA").
 * All rights reserved.
 *
 * This software is supplied "AS IS" without any warranties.
 * RDA assumes no responsibility or liability for the use of the software,
 * conveys no license or title under any patent, copyright, or mask work
 * right to the product. RDA reserves the right to make changes in the
 * software without notification.  RDA also make no representation or
 * warranty that such application will be suitable for the specified use
 * without further testing or modification.
 */

#ifndef _GNSS_SYS_H_
#define _GNSS_SYS_H_

// Auto generated by dtools(see dtools.txt for its version).
// Don't edit it manually!

#define REG_GNSS_SYS_SET_OFFSET (0x1000)
#define REG_GNSS_SYS_CLR_OFFSET (0x2000)

#define REG_GNSS_SYS_BASE (0x1c000000)

typedef volatile struct
{
    uint32_t ahb_eb0;                        // 0x00000000
    uint32_t gnss_bb_en;                     // 0x00000004
    uint32_t fun_test_mode;                  // 0x00000008
    uint32_t __12[53];                       // 0x0000000c
    uint32_t ahb_sys_ctl6;                   // 0x000000e0
    uint32_t __228[135];                     // 0x000000e4
    uint32_t platform_id;                    // 0x00000300
    uint32_t project_id;                     // 0x00000304
    uint32_t derived_id;                     // 0x00000308
    uint32_t manufacture_id;                 // 0x0000030c
    uint32_t implementation_id;              // 0x00000310
    uint32_t __788[56];                      // 0x00000314
    uint32_t cgm_en_ctrl;                    // 0x000003f4
    uint32_t __1016[11];                     // 0x000003f8
    uint32_t gnss2psram_lpc_cfg;             // 0x00000424
    uint32_t gnss2psram_lpc_status;          // 0x00000428
    uint32_t gnss2psram_lpc_force;           // 0x0000042c
    uint32_t __1072[756];                    // 0x00000430
    uint32_t ahb_eb0_set;                    // 0x00001000
    uint32_t gnss_bb_en_set;                 // 0x00001004
    uint32_t __4104[251];                    // 0x00001008
    uint32_t cgm_en_ctrl_set;                // 0x000013f4
    uint32_t __5112[11];                     // 0x000013f8
    uint32_t gnss2psram_lpc_cfg_set;         // 0x00001424
    uint32_t __5160[758];                    // 0x00001428
    uint32_t ahb_eb0_clr;                    // 0x00002000
    uint32_t gnss_bb_en_clr;                 // 0x00002004
    uint32_t __8200[251];                    // 0x00002008
    uint32_t cgm_en_ctrl_clr;                // 0x000023f4
    uint32_t __9208[11];                     // 0x000023f8
    uint32_t gnss2psram_lpc_cfg_clr;         // 0x00002424
    uint32_t __9256[758];                    // 0x00002428
    uint32_t soft_rst;                       // 0x00003000
    uint32_t __12292[1];                     // 0x00003004
    uint32_t pwr_on_rstn_index;              // 0x00003008
    uint32_t __12300[1];                     // 0x0000300c
    uint32_t ram_ema;                        // 0x00003010
    uint32_t __12308[13];                    // 0x00003014
    uint32_t fpgadebug;                      // 0x00003048
    uint32_t __12364[118];                   // 0x0000304c
    uint32_t sleep_status;                   // 0x00003224
    uint32_t __12840[32];                    // 0x00003228
    uint32_t auto_gate_ctrl0;                // 0x000032a8
    uint32_t auto_gate_ctrl1;                // 0x000032ac
    uint32_t auto_gate_ctrl2;                // 0x000032b0
    uint32_t auto_gate_ctrl3;                // 0x000032b4
    uint32_t auto_gate_status0;              // 0x000032b8
    uint32_t auto_gate_status1;              // 0x000032bc
    uint32_t auto_gate_status2;              // 0x000032c0
    uint32_t auto_gate_status3;              // 0x000032c4
    uint32_t __13000[7];                     // 0x000032c8
    uint32_t latch_pulse_num;                // 0x000032e4
    uint32_t adc_iq_hold_sel;                // 0x000032e8
    uint32_t async_bridge_dbg_singal_w;      // 0x000032ec
    uint32_t async_bridge_detector_overflow; // 0x000032f0
    uint32_t gps_coexist_in;                 // 0x000032f4
    uint32_t axi_reg_slice_ds_force;         // 0x000032f8
    uint32_t gnss_axi_qos;                   // 0x000032fc
    uint32_t gnss_ahb_err_resp_en;           // 0x00003300
    uint32_t __13060[831];                   // 0x00003304
    uint32_t soft_rst_set;                   // 0x00004000
    uint32_t __16388[184];                   // 0x00004004
    uint32_t latch_pulse_num_set;            // 0x000042e4
    uint32_t adc_iq_hold_sel_set;            // 0x000042e8
    uint32_t __17132[2];                     // 0x000042ec
    uint32_t gps_coexist_in_set;             // 0x000042f4
    uint32_t axi_reg_slice_ds_force_set;     // 0x000042f8
    uint32_t gnss_axi_qos_set;               // 0x000042fc
    uint32_t gnss_ahb_err_resp_en_set;       // 0x00004300
    uint32_t __17156[831];                   // 0x00004304
    uint32_t soft_rst_clr;                   // 0x00005000
    uint32_t __20484[184];                   // 0x00005004
    uint32_t latch_pulse_num_clr;            // 0x000052e4
    uint32_t adc_iq_hold_sel_clr;            // 0x000052e8
    uint32_t __21228[2];                     // 0x000052ec
    uint32_t gps_coexist_in_clr;             // 0x000052f4
    uint32_t axi_reg_slice_ds_force_clr;     // 0x000052f8
    uint32_t gnss_axi_qos_clr;               // 0x000052fc
    uint32_t gnss_ahb_err_resp_en_clr;       // 0x00005300
} HWP_GNSS_SYS_T;

#define hwp_gnssSys ((HWP_GNSS_SYS_T *)REG_ACCESS_ADDRESS(REG_GNSS_SYS_BASE))

// ahb_eb0
typedef union {
    uint32_t v;
    struct
    {
        uint32_t clk_reg_eb : 1;       // [0]
        uint32_t lpc_eb : 1;           // [1]
        uint32_t rft_hclk_eb : 1;      // [2]
        uint32_t rft_wclk_eb : 1;      // [3]
        uint32_t pps_hclk_eb : 1;      // [4]
        uint32_t pps_wclk_eb : 1;      // [5]
        uint32_t rfad_spi_hclk_eb : 1; // [6]
        uint32_t rfad_spi_wclk_eb : 1; // [7]
        uint32_t gnss_mtx_eb : 1;      // [8]
        uint32_t mtx_dump_eb : 1;      // [9]
        uint32_t __31_10 : 22;         // [31:10]
    } b;
} REG_GNSS_SYS_AHB_EB0_T;

// gnss_bb_en
typedef union {
    uint32_t v;
    struct
    {
        uint32_t gnss_hclk_en : 1;        // [0]
        uint32_t gnss_pp_clk_en : 1;      // [1]
        uint32_t gnss_ae_clk_en : 1;      // [2]
        uint32_t gnss_te_clk_en : 1;      // [3]
        uint32_t gnss_ae_fifo_clk_en : 1; // [4]
        uint32_t gnss_cof_mem_clk_en : 1; // [5]
        uint32_t gnss_te_mem_clk_en : 1;  // [6]
        uint32_t gnss_te_fifo_clk_en : 1; // [7]
        uint32_t gnss_viterbi_clk_en : 1; // [8]
        uint32_t gnss_pps_clk_en : 1;     // [9]
        uint32_t gnss_bb_67m_en : 1;      // [10]
        uint32_t __31_11 : 21;            // [31:11]
    } b;
} REG_GNSS_SYS_GNSS_BB_EN_T;

// fun_test_mode
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ptest_func_mode : 1; // [0], read only
        uint32_t __31_1 : 31;         // [31:1]
    } b;
} REG_GNSS_SYS_FUN_TEST_MODE_T;

// ahb_sys_ctl6
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ptest : 1;   // [0], read only
        uint32_t __31_1 : 31; // [31:1]
    } b;
} REG_GNSS_SYS_AHB_SYS_CTL6_T;

// derived_id
typedef union {
    uint32_t v;
    struct
    {
        uint32_t metal_fix_id : 8; // [7:0], read only
        uint32_t derived_id : 8;   // [15:8], read only
        uint32_t __31_16 : 16;     // [31:16]
    } b;
} REG_GNSS_SYS_DERIVED_ID_T;

// manufacture_id
typedef union {
    uint32_t v;
    struct
    {
        uint32_t foundry_id : 8; // [7:0], read only
        uint32_t process_id : 8; // [15:8], read only
        uint32_t __31_16 : 16;   // [31:16]
    } b;
} REG_GNSS_SYS_MANUFACTURE_ID_T;

// implementation_id
typedef union {
    uint32_t v;
    struct
    {
        uint32_t std_cell : 8;     // [7:0], read only
        uint32_t mem_compiler : 8; // [15:8], read only
        uint32_t __31_16 : 16;     // [31:16]
    } b;
} REG_GNSS_SYS_IMPLEMENTATION_ID_T;

// cgm_en_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t gnss_ip_en : 1;       // [0]
        uint32_t gnss_ip_ae_en : 1;    // [1]
        uint32_t gnss_ip_bb_pp_en : 1; // [2]
        uint32_t gnss_ip_adc_en : 1;   // [3]
        uint32_t gnss_ip_rtc_en : 1;   // [4]
        uint32_t __31_5 : 27;          // [31:5]
    } b;
} REG_GNSS_SYS_CGM_EN_CTRL_T;

// gnss2psram_lpc_cfg
typedef union {
    uint32_t v;
    struct
    {
        uint32_t gnss2psram_lp_num : 16;   // [15:0]
        uint32_t gnss2psram_lp_pu_num : 8; // [23:16]
        uint32_t gnss2psram_lp_eb : 1;     // [24]
        uint32_t __31_25 : 7;              // [31:25]
    } b;
} REG_GNSS_SYS_GNSS2PSRAM_LPC_CFG_T;

// gnss2psram_lpc_status
typedef union {
    uint32_t v;
    struct
    {
        uint32_t gnss2psram_lp_status : 1; // [0], read only
        uint32_t __31_1 : 31;              // [31:1]
    } b;
} REG_GNSS_SYS_GNSS2PSRAM_LPC_STATUS_T;

// gnss2psram_lpc_force
typedef union {
    uint32_t v;
    struct
    {
        uint32_t gnss2psram_lp_force_ack : 1; // [0], read only
        uint32_t gnss2psram_lp_force : 1;     // [1]
        uint32_t __31_2 : 30;                 // [31:2]
    } b;
} REG_GNSS_SYS_GNSS2PSRAM_LPC_FORCE_T;

// soft_rst
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rfad_spi_soft : 1; // [0]
        uint32_t lpc_soft_rst : 1;  // [1]
        uint32_t pps_soft_rst : 1;  // [2]
        uint32_t rft_soft_rst : 1;  // [3]
        uint32_t gnss_soft_rst : 1; // [4]
        uint32_t dump_soft_rst : 1; // [5]
        uint32_t __31_6 : 26;       // [31:6]
    } b;
} REG_GNSS_SYS_SOFT_RST_T;

// pwr_on_rstn_index
typedef union {
    uint32_t v;
    struct
    {
        uint32_t __0_0 : 1;   // [0]
        uint32_t lna_en : 1;  // [1]
        uint32_t __31_2 : 30; // [31:2]
    } b;
} REG_GNSS_SYS_PWR_ON_RSTN_INDEX_T;

// ram_ema
typedef union {
    uint32_t v;
    struct
    {
        uint32_t __9_0 : 10;            // [9:0]
        uint32_t gnss_ram_rm_ctrl : 4;  // [13:10]
        uint32_t gnss_ram_rme_ctrl : 1; // [14]
        uint32_t __31_15 : 17;          // [31:15]
    } b;
} REG_GNSS_SYS_RAM_EMA_T;

// sleep_status
typedef union {
    uint32_t v;
    struct
    {
        uint32_t chip_deep_sleep : 1; // [0], read only
        uint32_t __31_1 : 31;         // [31:1]
    } b;
} REG_GNSS_SYS_SLEEP_STATUS_T;

// latch_pulse_num
typedef union {
    uint32_t v;
    struct
    {
        uint32_t latch_pulse_num : 4; // [3:0]
        uint32_t __31_4 : 28;         // [31:4]
    } b;
} REG_GNSS_SYS_LATCH_PULSE_NUM_T;

// adc_iq_hold_sel
typedef union {
    uint32_t v;
    struct
    {
        uint32_t adc_iq_hold_sel : 1; // [0]
        uint32_t __31_1 : 31;         // [31:1]
    } b;
} REG_GNSS_SYS_ADC_IQ_HOLD_SEL_T;

// async_bridge_detector_overflow
typedef union {
    uint32_t v;
    struct
    {
        uint32_t axi_detector_overflow : 1; // [0], read only
        uint32_t __31_1 : 31;               // [31:1]
    } b;
} REG_GNSS_SYS_ASYNC_BRIDGE_DETECTOR_OVERFLOW_T;

// gps_coexist_in
typedef union {
    uint32_t v;
    struct
    {
        uint32_t gps_coexist_in : 1; // [0]
        uint32_t __31_1 : 31;        // [31:1]
    } b;
} REG_GNSS_SYS_GPS_COEXIST_IN_T;

// axi_reg_slice_ds_force
typedef union {
    uint32_t v;
    struct
    {
        uint32_t dowm_sream_disable_force_sel : 1; // [0]
        uint32_t dowm_sream_disable_force : 1;     // [1]
        uint32_t __31_2 : 30;                      // [31:2]
    } b;
} REG_GNSS_SYS_AXI_REG_SLICE_DS_FORCE_T;

// gnss_axi_qos
typedef union {
    uint32_t v;
    struct
    {
        uint32_t gnss_arqos : 4; // [3:0]
        uint32_t gnss_awqos : 4; // [7:4]
        uint32_t __31_8 : 24;    // [31:8]
    } b;
} REG_GNSS_SYS_GNSS_AXI_QOS_T;

// gnss_ahb_err_resp_en
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ahb_err_resp_en : 1; // [0]
        uint32_t __31_1 : 31;         // [31:1]
    } b;
} REG_GNSS_SYS_GNSS_AHB_ERR_RESP_EN_T;

// ahb_eb0
#define GNSS_SYS_CLK_REG_EB (1 << 0)
#define GNSS_SYS_LPC_EB (1 << 1)
#define GNSS_SYS_RFT_HCLK_EB (1 << 2)
#define GNSS_SYS_RFT_WCLK_EB (1 << 3)
#define GNSS_SYS_PPS_HCLK_EB (1 << 4)
#define GNSS_SYS_PPS_WCLK_EB (1 << 5)
#define GNSS_SYS_RFAD_SPI_HCLK_EB (1 << 6)
#define GNSS_SYS_RFAD_SPI_WCLK_EB (1 << 7)
#define GNSS_SYS_GNSS_MTX_EB (1 << 8)
#define GNSS_SYS_MTX_DUMP_EB (1 << 9)

// gnss_bb_en
#define GNSS_SYS_GNSS_HCLK_EN (1 << 0)
#define GNSS_SYS_GNSS_PP_CLK_EN (1 << 1)
#define GNSS_SYS_GNSS_AE_CLK_EN (1 << 2)
#define GNSS_SYS_GNSS_TE_CLK_EN (1 << 3)
#define GNSS_SYS_GNSS_AE_FIFO_CLK_EN (1 << 4)
#define GNSS_SYS_GNSS_COF_MEM_CLK_EN (1 << 5)
#define GNSS_SYS_GNSS_TE_MEM_CLK_EN (1 << 6)
#define GNSS_SYS_GNSS_TE_FIFO_CLK_EN (1 << 7)
#define GNSS_SYS_GNSS_VITERBI_CLK_EN (1 << 8)
#define GNSS_SYS_GNSS_PPS_CLK_EN (1 << 9)
#define GNSS_SYS_GNSS_BB_67M_EN (1 << 10)

// fun_test_mode
#define GNSS_SYS_PTEST_FUNC_MODE (1 << 0)

// ahb_sys_ctl6
#define GNSS_SYS_PTEST (1 << 0)

// derived_id
#define GNSS_SYS_METAL_FIX_ID(n) (((n)&0xff) << 0)
#define GNSS_SYS_DERIVED_ID(n) (((n)&0xff) << 8)

// manufacture_id
#define GNSS_SYS_FOUNDRY_ID(n) (((n)&0xff) << 0)
#define GNSS_SYS_PROCESS_ID(n) (((n)&0xff) << 8)

// implementation_id
#define GNSS_SYS_STD_CELL(n) (((n)&0xff) << 0)
#define GNSS_SYS_MEM_COMPILER(n) (((n)&0xff) << 8)

// cgm_en_ctrl
#define GNSS_SYS_GNSS_IP_EN (1 << 0)
#define GNSS_SYS_GNSS_IP_AE_EN (1 << 1)
#define GNSS_SYS_GNSS_IP_BB_PP_EN (1 << 2)
#define GNSS_SYS_GNSS_IP_ADC_EN (1 << 3)
#define GNSS_SYS_GNSS_IP_RTC_EN (1 << 4)

// gnss2psram_lpc_cfg
#define GNSS_SYS_GNSS2PSRAM_LP_NUM(n) (((n)&0xffff) << 0)
#define GNSS_SYS_GNSS2PSRAM_LP_PU_NUM(n) (((n)&0xff) << 16)
#define GNSS_SYS_GNSS2PSRAM_LP_EB (1 << 24)

// gnss2psram_lpc_status
#define GNSS_SYS_GNSS2PSRAM_LP_STATUS (1 << 0)

// gnss2psram_lpc_force
#define GNSS_SYS_GNSS2PSRAM_LP_FORCE_ACK (1 << 0)
#define GNSS_SYS_GNSS2PSRAM_LP_FORCE (1 << 1)

// soft_rst
#define GNSS_SYS_RFAD_SPI_SOFT (1 << 0)
#define GNSS_SYS_LPC_SOFT_RST (1 << 1)
#define GNSS_SYS_PPS_SOFT_RST (1 << 2)
#define GNSS_SYS_RFT_SOFT_RST (1 << 3)
#define GNSS_SYS_GNSS_SOFT_RST (1 << 4)
#define GNSS_SYS_DUMP_SOFT_RST (1 << 5)

// pwr_on_rstn_index
#define GNSS_SYS_LNA_EN (1 << 1)

// ram_ema
#define GNSS_SYS_GNSS_RAM_RM_CTRL(n) (((n)&0xf) << 10)
#define GNSS_SYS_GNSS_RAM_RME_CTRL (1 << 14)

// sleep_status
#define GNSS_SYS_CHIP_DEEP_SLEEP (1 << 0)

// latch_pulse_num
#define GNSS_SYS_LATCH_PULSE_NUM(n) (((n)&0xf) << 0)

// adc_iq_hold_sel
#define GNSS_SYS_ADC_IQ_HOLD_SEL (1 << 0)

// async_bridge_detector_overflow
#define GNSS_SYS_AXI_DETECTOR_OVERFLOW (1 << 0)

// gps_coexist_in
#define GNSS_SYS_GPS_COEXIST_IN (1 << 0)

// axi_reg_slice_ds_force
#define GNSS_SYS_DOWM_SREAM_DISABLE_FORCE_SEL (1 << 0)
#define GNSS_SYS_DOWM_SREAM_DISABLE_FORCE (1 << 1)

// gnss_axi_qos
#define GNSS_SYS_GNSS_ARQOS(n) (((n)&0xf) << 0)
#define GNSS_SYS_GNSS_AWQOS(n) (((n)&0xf) << 4)

// gnss_ahb_err_resp_en
#define GNSS_SYS_AHB_ERR_RESP_EN (1 << 0)

#endif // _GNSS_SYS_H_
