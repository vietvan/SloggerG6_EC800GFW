/* Copyright (C) 2018 RDA Technologies Limited and/or its affiliates("RDA").
 * All rights reserved.
 *
 * This software is supplied "AS IS" without any warranties.
 * RDA assumes no responsibility or liability for the use of the software,
 * conveys no license or title under any patent, copyright, or mask work
 * right to the product. RDA reserves the right to make changes in the
 * software without notification.  RDA also make no representation or
 * warranty that such application will be suitable for the specified use
 * without further testing or modification.
 */

#ifndef _LPS_CLK_H_
#define _LPS_CLK_H_

// Auto generated by dtools(see dtools.txt for its version).
// Don't edit it manually!

#define REG_LPS_CLK_SET_OFFSET (256)
#define REG_LPS_CLK_CLR_OFFSET (512)

#define REG_LPS_CLK_BASE (0x51701000)

typedef volatile struct
{
    uint32_t user_gate_force_off;        // 0x00000000
    uint32_t user_gate_auto_gate_en;     // 0x00000004
    uint32_t __8[8];                     // 0x00000008
    uint32_t cgm_uart1_bf_div_sel_cfg;   // 0x00000028
    uint32_t __44[5];                    // 0x0000002c
    uint32_t cgm_lps_ahb_sel_cfg;        // 0x00000040
    uint32_t cgm_busy_src_monitor_cfg0;  // 0x00000044
    uint32_t __72[46];                   // 0x00000048
    uint32_t user_gate_force_off_set;    // 0x00000100
    uint32_t user_gate_auto_gate_en_set; // 0x00000104
    uint32_t __264[62];                  // 0x00000108
    uint32_t user_gate_force_off_clr;    // 0x00000200
    uint32_t user_gate_auto_gate_en_clr; // 0x00000204
} HWP_LPS_CLK_T;

#define hwp_lpsClk ((HWP_LPS_CLK_T *)REG_ACCESS_ADDRESS(REG_LPS_CLK_BASE))

// user_gate_force_off
typedef union {
    uint32_t v;
    struct
    {
        uint32_t uart1_bf_div_uart1_force_off : 1;        // [0]
        uint32_t uart1_bf_div_uart1_always_force_off : 1; // [1]
        uint32_t lps_32k_fr_force_off : 1;                // [2]
        uint32_t lps_ahb_to_aon_force_off : 1;            // [3]
        uint32_t lps_ahb_uart1_mod_force_off : 1;         // [4]
        uint32_t lps_ahb_uart1_always_force_off : 1;      // [5]
        uint32_t lps_ahb_uart1_force_off : 1;             // [6]
        uint32_t lps_ahb_gpio1_force_off : 1;             // [7]
        uint32_t lps_ahb_gpio_mod_force_off : 1;          // [8]
        uint32_t lps_ahb_gpt1_force_off : 1;              // [9]
        uint32_t lps_ahb_apb_reg_force_off : 1;           // [10]
        uint32_t lps_ahb_keypad_force_off : 1;            // [11]
        uint32_t lps_ahb_keypad_always_force_off : 1;     // [12]
        uint32_t lps_ahb_keypad_osc_force_off : 1;        // [13]
        uint32_t lps_ahb_pwrctrl_intf_force_off : 1;      // [14]
        uint32_t lps_ahb_pwrctrl_func_force_off : 1;      // [15]
        uint32_t lps_ahb_idle_lps_force_off : 1;          // [16]
        uint32_t lps_ahb_ana_wrap3_force_off : 1;         // [17]
        uint32_t __31_18 : 14;                            // [31:18]
    } b;
} REG_LPS_CLK_USER_GATE_FORCE_OFF_T;

// user_gate_auto_gate_en
typedef union {
    uint32_t v;
    struct
    {
        uint32_t uart1_bf_div_uart1_auto_gate_en : 1;        // [0]
        uint32_t uart1_bf_div_uart1_always_auto_gate_en : 1; // [1]
        uint32_t lps_32k_fr_auto_gate_en : 1;                // [2]
        uint32_t lps_ahb_to_aon_auto_gate_en : 1;            // [3]
        uint32_t lps_ahb_uart1_mod_auto_gate_en : 1;         // [4]
        uint32_t lps_ahb_uart1_always_auto_gate_en : 1;      // [5]
        uint32_t lps_ahb_uart1_auto_gate_en : 1;             // [6]
        uint32_t lps_ahb_gpio1_auto_gate_en : 1;             // [7]
        uint32_t lps_ahb_gpio_mod_auto_gate_en : 1;          // [8]
        uint32_t lps_ahb_gpt1_auto_gate_en : 1;              // [9]
        uint32_t lps_ahb_apb_reg_auto_gate_en : 1;           // [10]
        uint32_t lps_ahb_keypad_auto_gate_en : 1;            // [11]
        uint32_t lps_ahb_keypad_always_auto_gate_en : 1;     // [12]
        uint32_t lps_ahb_keypad_osc_auto_gate_en : 1;        // [13]
        uint32_t lps_ahb_pwrctrl_intf_auto_gate_en : 1;      // [14]
        uint32_t lps_ahb_pwrctrl_func_auto_gate_en : 1;      // [15]
        uint32_t lps_ahb_idle_lps_auto_gate_en : 1;          // [16]
        uint32_t lps_ahb_ana_wrap3_auto_gate_en : 1;         // [17]
        uint32_t __31_18 : 14;                               // [31:18]
    } b;
} REG_LPS_CLK_USER_GATE_AUTO_GATE_EN_T;

// cgm_uart1_bf_div_sel_cfg
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cgm_uart1_bf_div_sel : 2; // [1:0]
        uint32_t __31_2 : 30;              // [31:2]
    } b;
} REG_LPS_CLK_CGM_UART1_BF_DIV_SEL_CFG_T;

// cgm_lps_ahb_sel_cfg
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cgm_lps_ahb_sel : 2; // [1:0]
        uint32_t __31_2 : 30;         // [31:2]
    } b;
} REG_LPS_CLK_CGM_LPS_AHB_SEL_CFG_T;

// cgm_busy_src_monitor_cfg0
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cgm_busy_src_monitor0 : 9; // [8:0], read only
        uint32_t __31_9 : 23;               // [31:9]
    } b;
} REG_LPS_CLK_CGM_BUSY_SRC_MONITOR_CFG0_T;

// user_gate_force_off
#define LPS_CLK_UART1_BF_DIV_UART1_FORCE_OFF (1 << 0)
#define LPS_CLK_UART1_BF_DIV_UART1_ALWAYS_FORCE_OFF (1 << 1)
#define LPS_CLK_LPS_32K_FR_FORCE_OFF (1 << 2)
#define LPS_CLK_LPS_AHB_TO_AON_FORCE_OFF (1 << 3)
#define LPS_CLK_LPS_AHB_UART1_MOD_FORCE_OFF (1 << 4)
#define LPS_CLK_LPS_AHB_UART1_ALWAYS_FORCE_OFF (1 << 5)
#define LPS_CLK_LPS_AHB_UART1_FORCE_OFF (1 << 6)
#define LPS_CLK_LPS_AHB_GPIO1_FORCE_OFF (1 << 7)
#define LPS_CLK_LPS_AHB_GPIO_MOD_FORCE_OFF (1 << 8)
#define LPS_CLK_LPS_AHB_GPT1_FORCE_OFF (1 << 9)
#define LPS_CLK_LPS_AHB_APB_REG_FORCE_OFF (1 << 10)
#define LPS_CLK_LPS_AHB_KEYPAD_FORCE_OFF (1 << 11)
#define LPS_CLK_LPS_AHB_KEYPAD_ALWAYS_FORCE_OFF (1 << 12)
#define LPS_CLK_LPS_AHB_KEYPAD_OSC_FORCE_OFF (1 << 13)
#define LPS_CLK_LPS_AHB_PWRCTRL_INTF_FORCE_OFF (1 << 14)
#define LPS_CLK_LPS_AHB_PWRCTRL_FUNC_FORCE_OFF (1 << 15)
#define LPS_CLK_LPS_AHB_IDLE_LPS_FORCE_OFF (1 << 16)
#define LPS_CLK_LPS_AHB_ANA_WRAP3_FORCE_OFF (1 << 17)

// user_gate_auto_gate_en
#define LPS_CLK_UART1_BF_DIV_UART1_AUTO_GATE_EN (1 << 0)
#define LPS_CLK_UART1_BF_DIV_UART1_ALWAYS_AUTO_GATE_EN (1 << 1)
#define LPS_CLK_LPS_32K_FR_AUTO_GATE_EN (1 << 2)
#define LPS_CLK_LPS_AHB_TO_AON_AUTO_GATE_EN (1 << 3)
#define LPS_CLK_LPS_AHB_UART1_MOD_AUTO_GATE_EN (1 << 4)
#define LPS_CLK_LPS_AHB_UART1_ALWAYS_AUTO_GATE_EN (1 << 5)
#define LPS_CLK_LPS_AHB_UART1_AUTO_GATE_EN (1 << 6)
#define LPS_CLK_LPS_AHB_GPIO1_AUTO_GATE_EN (1 << 7)
#define LPS_CLK_LPS_AHB_GPIO_MOD_AUTO_GATE_EN (1 << 8)
#define LPS_CLK_LPS_AHB_GPT1_AUTO_GATE_EN (1 << 9)
#define LPS_CLK_LPS_AHB_APB_REG_AUTO_GATE_EN (1 << 10)
#define LPS_CLK_LPS_AHB_KEYPAD_AUTO_GATE_EN (1 << 11)
#define LPS_CLK_LPS_AHB_KEYPAD_ALWAYS_AUTO_GATE_EN (1 << 12)
#define LPS_CLK_LPS_AHB_KEYPAD_OSC_AUTO_GATE_EN (1 << 13)
#define LPS_CLK_LPS_AHB_PWRCTRL_INTF_AUTO_GATE_EN (1 << 14)
#define LPS_CLK_LPS_AHB_PWRCTRL_FUNC_AUTO_GATE_EN (1 << 15)
#define LPS_CLK_LPS_AHB_IDLE_LPS_AUTO_GATE_EN (1 << 16)
#define LPS_CLK_LPS_AHB_ANA_WRAP3_AUTO_GATE_EN (1 << 17)

// cgm_uart1_bf_div_sel_cfg
#define LPS_CLK_CGM_UART1_BF_DIV_SEL(n) (((n)&0x3) << 0)

// cgm_lps_ahb_sel_cfg
#define LPS_CLK_CGM_LPS_AHB_SEL(n) (((n)&0x3) << 0)

// cgm_busy_src_monitor_cfg0
#define LPS_CLK_CGM_BUSY_SRC_MONITOR0(n) (((n)&0x1ff) << 0)

#endif // _LPS_CLK_H_
