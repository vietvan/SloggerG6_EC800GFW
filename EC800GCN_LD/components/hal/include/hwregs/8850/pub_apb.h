/* Copyright (C) 2018 RDA Technologies Limited and/or its affiliates("RDA").
 * All rights reserved.
 *
 * This software is supplied "AS IS" without any warranties.
 * RDA assumes no responsibility or liability for the use of the software,
 * conveys no license or title under any patent, copyright, or mask work
 * right to the product. RDA reserves the right to make changes in the
 * software without notification.  RDA also make no representation or
 * warranty that such application will be suitable for the specified use
 * without further testing or modification.
 */

#ifndef _PUB_APB_H_
#define _PUB_APB_H_

// Auto generated by dtools(see dtools.txt for its version).
// Don't edit it manually!

#define REG_PUB_APB_SET_OFFSET (256)
#define REG_PUB_APB_CLR_OFFSET (512)

#define REG_PUB_APB_BASE (0x51603000)

typedef volatile struct
{
    uint32_t apb_eb;             // 0x00000000
    uint32_t apb_soft_rst;       // 0x00000004
    uint32_t debug_ctrl;         // 0x00000008
    uint32_t slp_ctrl;           // 0x0000000c
    uint32_t lps_gate_sel;       // 0x00000010
    uint32_t lps_gate_force;     // 0x00000014
    uint32_t cgm_psram;          // 0x00000018
    uint32_t lpc_ctrl0;          // 0x0000001c
    uint32_t lpc_ctrl1;          // 0x00000020
    uint32_t pub_anti_hang;      // 0x00000024
    uint32_t __40[2];            // 0x00000028
    uint32_t monitor_clk;        // 0x00000030
    uint32_t debug_status;       // 0x00000034
    uint32_t __56[50];           // 0x00000038
    uint32_t apb_eb_set;         // 0x00000100
    uint32_t apb_soft_rst_set;   // 0x00000104
    uint32_t __264[2];           // 0x00000108
    uint32_t lps_gate_sel_set;   // 0x00000110
    uint32_t lps_gate_force_set; // 0x00000114
    uint32_t __280[2];           // 0x00000118
    uint32_t lpc_ctrl1_set;      // 0x00000120
    uint32_t pub_anti_hang_set;  // 0x00000124
    uint32_t __296[54];          // 0x00000128
    uint32_t apb_eb_clr;         // 0x00000200
    uint32_t apb_soft_rst_clr;   // 0x00000204
    uint32_t __520[2];           // 0x00000208
    uint32_t lps_gate_sel_clr;   // 0x00000210
    uint32_t lps_gate_force_clr; // 0x00000214
    uint32_t __536[2];           // 0x00000218
    uint32_t lpc_ctrl1_clr;      // 0x00000220
    uint32_t pub_anti_hang_clr;  // 0x00000224
} HWP_PUB_APB_T;

#define hwp_pubApb ((HWP_PUB_APB_T *)REG_ACCESS_ADDRESS(REG_PUB_APB_BASE))

// apb_eb
typedef union {
    uint32_t v;
    struct
    {
        uint32_t pagespy_eb : 1;  // [0]
        uint32_t mtx_cfg_eb : 1;  // [1]
        uint32_t reserved_eb : 1; // [2]
        uint32_t __31_3 : 29;     // [31:3]
    } b;
} REG_PUB_APB_APB_EB_T;

// apb_soft_rst
typedef union {
    uint32_t v;
    struct
    {
        uint32_t pagespy_soft_rst : 1;  // [0]
        uint32_t dmc400_soft_rst : 1;   // [1]
        uint32_t mtx_cfg_rst : 1;       // [2]
        uint32_t reserved_soft_rst : 1; // [3]
        uint32_t __31_4 : 28;           // [31:4]
    } b;
} REG_PUB_APB_APB_SOFT_RST_T;

// slp_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t wait_num : 16;    // [15:0]
        uint32_t force_en : 1;     // [16]
        uint32_t force_reg : 1;    // [17]
        uint32_t enable : 1;       // [18]
        uint32_t half_slp_reg : 1; // [19]
        uint32_t __31_20 : 12;     // [31:20]
    } b;
} REG_PUB_APB_SLP_CTRL_T;

// lps_gate_sel
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cgm_gate_auto_sel : 10; // [9:0]
        uint32_t __31_10 : 22;           // [31:10]
    } b;
} REG_PUB_APB_LPS_GATE_SEL_T;

// lps_gate_force
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cgm_gate_force_en : 10; // [9:0]
        uint32_t __31_10 : 22;           // [31:10]
    } b;
} REG_PUB_APB_LPS_GATE_FORCE_T;

// cgm_psram
typedef union {
    uint32_t v;
    struct
    {
        uint32_t __0_0 : 1;   // [0]
        uint32_t div_1x : 1;  // [1]
        uint32_t __2_2 : 1;   // [2]
        uint32_t div_2x : 2;  // [4:3]
        uint32_t sel_2x : 3;  // [7:5]
        uint32_t __31_8 : 24; // [31:8]
    } b;
} REG_PUB_APB_CGM_PSRAM_T;

// lpc_ctrl0
typedef union {
    uint32_t v;
    struct
    {
        uint32_t lp_num : 16; // [15:0]
        uint32_t pu_num : 8;  // [23:16]
        uint32_t __31_24 : 8; // [31:24]
    } b;
} REG_PUB_APB_LPC_CTRL0_T;

// lpc_ctrl1
typedef union {
    uint32_t v;
    struct
    {
        uint32_t lp_eb : 1;    // [0]
        uint32_t lp_force : 1; // [1]
        uint32_t __31_2 : 30;  // [31:2]
    } b;
} REG_PUB_APB_LPC_CTRL1_T;

// pub_anti_hang
typedef union {
    uint32_t v;
    struct
    {
        uint32_t pagespy_id_sel : 1; // [0]
        uint32_t reserved1_en : 1;   // [1]
        uint32_t reserved2_en : 1;   // [2]
        uint32_t __3_3 : 1;          // [3]
        uint32_t error_resp_en : 1;  // [4]
        uint32_t __31_5 : 27;        // [31:5]
    } b;
} REG_PUB_APB_PUB_ANTI_HANG_T;

// monitor_clk
typedef union {
    uint32_t v;
    struct
    {
        uint32_t gate_en_status : 10;  // [9:0], read only
        uint32_t __11_10 : 2;          // [11:10]
        uint32_t cgm_busy_status : 10; // [21:12], read only
        uint32_t __31_22 : 10;         // [31:22]
    } b;
} REG_PUB_APB_MONITOR_CLK_T;

// apb_eb
#define PUB_APB_PAGESPY_EB (1 << 0)
#define PUB_APB_MTX_CFG_EB (1 << 1)
#define PUB_APB_RESERVED_EB (1 << 2)

// apb_soft_rst
#define PUB_APB_PAGESPY_SOFT_RST (1 << 0)
#define PUB_APB_DMC400_SOFT_RST (1 << 1)
#define PUB_APB_MTX_CFG_RST (1 << 2)
#define PUB_APB_RESERVED_SOFT_RST (1 << 3)

// slp_ctrl
#define PUB_APB_WAIT_NUM(n) (((n)&0xffff) << 0)
#define PUB_APB_FORCE_EN (1 << 16)
#define PUB_APB_FORCE_REG (1 << 17)
#define PUB_APB_ENABLE (1 << 18)
#define PUB_APB_HALF_SLP_REG (1 << 19)

// lps_gate_sel
#define PUB_APB_CGM_GATE_AUTO_SEL(n) (((n)&0x3ff) << 0)

// lps_gate_force
#define PUB_APB_CGM_GATE_FORCE_EN(n) (((n)&0x3ff) << 0)

// cgm_psram
#define PUB_APB_DIV_1X (1 << 1)
#define PUB_APB_DIV_2X(n) (((n)&0x3) << 3)
#define PUB_APB_SEL_2X(n) (((n)&0x7) << 5)

// lpc_ctrl0
#define PUB_APB_LP_NUM(n) (((n)&0xffff) << 0)
#define PUB_APB_PU_NUM(n) (((n)&0xff) << 16)

// lpc_ctrl1
#define PUB_APB_LP_EB (1 << 0)
#define PUB_APB_LP_FORCE (1 << 1)

// pub_anti_hang
#define PUB_APB_PAGESPY_ID_SEL (1 << 0)
#define PUB_APB_RESERVED1_EN (1 << 1)
#define PUB_APB_RESERVED2_EN (1 << 2)
#define PUB_APB_ERROR_RESP_EN (1 << 4)

// monitor_clk
#define PUB_APB_GATE_EN_STATUS(n) (((n)&0x3ff) << 0)
#define PUB_APB_CGM_BUSY_STATUS(n) (((n)&0x3ff) << 12)

#endif // _PUB_APB_H_
