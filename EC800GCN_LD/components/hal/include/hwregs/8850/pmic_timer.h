/* Copyright (C) 2018 RDA Technologies Limited and/or its affiliates("RDA").
 * All rights reserved.
 *
 * This software is supplied "AS IS" without any warranties.
 * RDA assumes no responsibility or liability for the use of the software,
 * conveys no license or title under any patent, copyright, or mask work
 * right to the product. RDA reserves the right to make changes in the
 * software without notification.  RDA also make no representation or
 * warranty that such application will be suitable for the specified use
 * without further testing or modification.
 */

#ifndef _PMIC_TIMER_H_
#define _PMIC_TIMER_H_

// Auto generated by dtools(see dtools.txt for its version).
// Don't edit it manually!

#define REG_PMIC_TIMER_BASE (0x51108000)

typedef volatile struct
{
    uint32_t timer_version;       // 0x00000000
    uint32_t timer_load_lo;       // 0x00000004
    uint32_t timer_load_hi;       // 0x00000008
    uint32_t timer_ctl;           // 0x0000000c
    uint32_t timer_int;           // 0x00000010
    uint32_t timer_value_shdw_lo; // 0x00000014
    uint32_t timer_value_shdw_hi; // 0x00000018
} HWP_PMIC_TIMER_T;

#define hwp_pmicTimer ((HWP_PMIC_TIMER_T *)REG_ACCESS_ADDRESS(REG_PMIC_TIMER_BASE))

// timer_version
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ip_patch_version : 4; // [3:0], read only
        uint32_t ip_version : 12;      // [15:4], read only
        uint32_t __31_16 : 16;         // [31:16]
    } b;
} REG_PMIC_TIMER_TIMER_VERSION_T;

// timer_load_lo
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_load_lo : 16; // [15:0]
        uint32_t __31_16 : 16;       // [31:16]
    } b;
} REG_PMIC_TIMER_TIMER_LOAD_LO_T;

// timer_load_hi
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_load_hi : 16; // [15:0]
        uint32_t __31_16 : 16;       // [31:16]
    } b;
} REG_PMIC_TIMER_TIMER_LOAD_HI_T;

// timer_ctl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_mode : 1; // [0]
        uint32_t timer_run : 1;  // [1]
        uint32_t __31_2 : 30;    // [31:2]
    } b;
} REG_PMIC_TIMER_TIMER_CTL_T;

// timer_int
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_int_en : 1;       // [0]
        uint32_t timer_int_raw_sts : 1;  // [1], read only
        uint32_t timer_int_mask_sts : 1; // [2], read only
        uint32_t timer_int_clr : 1;      // [3], write clear
        uint32_t __31_4 : 28;            // [31:4]
    } b;
} REG_PMIC_TIMER_TIMER_INT_T;

// timer_value_shdw_lo
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_value_shdw_lo : 16; // [15:0], read only
        uint32_t __31_16 : 16;             // [31:16]
    } b;
} REG_PMIC_TIMER_TIMER_VALUE_SHDW_LO_T;

// timer_value_shdw_hi
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_value_shdw_hi : 16; // [15:0], read only
        uint32_t __31_16 : 16;             // [31:16]
    } b;
} REG_PMIC_TIMER_TIMER_VALUE_SHDW_HI_T;

// timer_version
#define PMIC_TIMER_IP_PATCH_VERSION(n) (((n)&0xf) << 0)
#define PMIC_TIMER_IP_VERSION(n) (((n)&0xfff) << 4)

// timer_load_lo
#define PMIC_TIMER_TIMER_LOAD_LO(n) (((n)&0xffff) << 0)

// timer_load_hi
#define PMIC_TIMER_TIMER_LOAD_HI(n) (((n)&0xffff) << 0)

// timer_ctl
#define PMIC_TIMER_TIMER_MODE (1 << 0)
#define PMIC_TIMER_TIMER_RUN (1 << 1)

// timer_int
#define PMIC_TIMER_TIMER_INT_EN (1 << 0)
#define PMIC_TIMER_TIMER_INT_RAW_STS (1 << 1)
#define PMIC_TIMER_TIMER_INT_MASK_STS (1 << 2)
#define PMIC_TIMER_TIMER_INT_CLR (1 << 3)

// timer_value_shdw_lo
#define PMIC_TIMER_TIMER_VALUE_SHDW_LO(n) (((n)&0xffff) << 0)

// timer_value_shdw_hi
#define PMIC_TIMER_TIMER_VALUE_SHDW_HI(n) (((n)&0xffff) << 0)

#endif // _PMIC_TIMER_H_
