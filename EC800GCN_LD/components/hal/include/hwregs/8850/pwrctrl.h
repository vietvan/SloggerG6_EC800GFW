/* Copyright (C) 2018 RDA Technologies Limited and/or its affiliates("RDA").
 * All rights reserved.
 *
 * This software is supplied "AS IS" without any warranties.
 * RDA assumes no responsibility or liability for the use of the software,
 * conveys no license or title under any patent, copyright, or mask work
 * right to the product. RDA reserves the right to make changes in the
 * software without notification.  RDA also make no representation or
 * warranty that such application will be suitable for the specified use
 * without further testing or modification.
 */

#ifndef _PWRCTRL_H_
#define _PWRCTRL_H_

// Auto generated by dtools(see dtools.txt for its version).
// Don't edit it manually!

#define REG_PWRCTRL_SET_OFFSET (1024)
#define REG_PWRCTRL_CLR_OFFSET (2048)

#define REG_PWRCTRL_BASE (0x51707000)

typedef volatile struct
{
    uint32_t pwrctrl_hwen;          // 0x00000000
    uint32_t ap_pwr_ctrl;           // 0x00000004
    uint32_t cp_pwr_ctrl;           // 0x00000008
    uint32_t pub_pwr_ctrl;          // 0x0000000c
    uint32_t rf_pwr_ctrl;           // 0x00000010
    uint32_t usb_pwr_ctrl;          // 0x00000014
    uint32_t lte_pwr_ctrl;          // 0x00000018
    uint32_t gnss_pwr_ctrl;         // 0x0000001c
    uint32_t ap_pwr_stat;           // 0x00000020
    uint32_t cp_pwr_stat;           // 0x00000024
    uint32_t pub_pwr_stat;          // 0x00000028
    uint32_t rf_pwr_stat;           // 0x0000002c
    uint32_t usb_pwr_stat;          // 0x00000030
    uint32_t lte_pwr_stat;          // 0x00000034
    uint32_t gnss_pwr_stat;         // 0x00000038
    uint32_t state_delay;           // 0x0000003c
    uint32_t pd_m_delay;            // 0x00000040
    uint32_t pd_d_delay;            // 0x00000044
    uint32_t psram_hold_ctrl;       // 0x00000048
    uint32_t slp_bypass;            // 0x0000004c
    uint32_t slp_timeout_flag;      // 0x00000050
    uint32_t pwrctrl_int_en_ap;     // 0x00000054
    uint32_t pwrctrl_int_en_cp;     // 0x00000058
    uint32_t pwrctrl_sm_state;      // 0x0000005c
    uint32_t __96[232];             // 0x00000060
    uint32_t pwrctrl_hwen_set;      // 0x00000400
    uint32_t __1028[2];             // 0x00000404
    uint32_t pub_pwr_ctrl_set;      // 0x0000040c
    uint32_t __1040[15];            // 0x00000410
    uint32_t slp_bypass_set;        // 0x0000044c
    uint32_t slp_timeout_flag_set;  // 0x00000450
    uint32_t pwrctrl_int_en_ap_set; // 0x00000454
    uint32_t pwrctrl_int_en_cp_set; // 0x00000458
    uint32_t __1116[233];           // 0x0000045c
    uint32_t pwrctrl_hwen_clr;      // 0x00000800
    uint32_t __2052[2];             // 0x00000804
    uint32_t pub_pwr_ctrl_clr;      // 0x0000080c
    uint32_t __2064[15];            // 0x00000810
    uint32_t slp_bypass_clr;        // 0x0000084c
    uint32_t slp_timeout_flag_clr;  // 0x00000850
    uint32_t pwrctrl_int_en_ap_clr; // 0x00000854
    uint32_t pwrctrl_int_en_cp_clr; // 0x00000858
} HWP_PWRCTRL_T;

#define hwp_pwrctrl ((HWP_PWRCTRL_T *)REG_ACCESS_ADDRESS(REG_PWRCTRL_BASE))

// pwrctrl_hwen
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ap_pwr_hwen : 1; // [0]
        uint32_t cp_pwr_hwen : 1; // [1]
        uint32_t __31_2 : 30;     // [31:2]
    } b;
} REG_PWRCTRL_PWRCTRL_HWEN_T;

// ap_pwr_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ap_pwr_ctrl : 1; // [0]
        uint32_t __31_1 : 31;     // [31:1]
    } b;
} REG_PWRCTRL_AP_PWR_CTRL_T;

// cp_pwr_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cp_pwr_ctrl : 1; // [0]
        uint32_t __31_1 : 31;     // [31:1]
    } b;
} REG_PWRCTRL_CP_PWR_CTRL_T;

// pub_pwr_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ap_pol : 1;  // [0]
        uint32_t cp_pol : 1;  // [1]
        uint32_t __31_2 : 30; // [31:2]
    } b;
} REG_PWRCTRL_PUB_PWR_CTRL_T;

// rf_pwr_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_pwr_ctrl : 1; // [0]
        uint32_t __31_1 : 31;     // [31:1]
    } b;
} REG_PWRCTRL_RF_PWR_CTRL_T;

// usb_pwr_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t usb_pwr_ctrl : 1; // [0]
        uint32_t __31_1 : 31;      // [31:1]
    } b;
} REG_PWRCTRL_USB_PWR_CTRL_T;

// lte_pwr_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t lte_pwr_ctrl : 1; // [0]
        uint32_t __31_1 : 31;      // [31:1]
    } b;
} REG_PWRCTRL_LTE_PWR_CTRL_T;

// gnss_pwr_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t gnss_pwr_ctrl : 1; // [0]
        uint32_t __31_1 : 31;       // [31:1]
    } b;
} REG_PWRCTRL_GNSS_PWR_CTRL_T;

// ap_pwr_stat
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ap_pwr_state : 1;  // [0], read only
        uint32_t ap_pwr_stable : 1; // [1], read only
        uint32_t __31_2 : 30;       // [31:2]
    } b;
} REG_PWRCTRL_AP_PWR_STAT_T;

// cp_pwr_stat
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cp_pwr_state : 1;  // [0], read only
        uint32_t cp_pwr_stable : 1; // [1], read only
        uint32_t __31_2 : 30;       // [31:2]
    } b;
} REG_PWRCTRL_CP_PWR_STAT_T;

// pub_pwr_stat
typedef union {
    uint32_t v;
    struct
    {
        uint32_t pub_pwr_state : 1;  // [0], read only
        uint32_t pub_pwr_stable : 1; // [1], read only
        uint32_t __31_2 : 30;        // [31:2]
    } b;
} REG_PWRCTRL_PUB_PWR_STAT_T;

// rf_pwr_stat
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_pwr_state : 1;  // [0], read only
        uint32_t rf_pwr_stable : 1; // [1], read only
        uint32_t __31_2 : 30;       // [31:2]
    } b;
} REG_PWRCTRL_RF_PWR_STAT_T;

// usb_pwr_stat
typedef union {
    uint32_t v;
    struct
    {
        uint32_t usb_pwr_state : 1;  // [0], read only
        uint32_t usb_pwr_stable : 1; // [1], read only
        uint32_t __31_2 : 30;        // [31:2]
    } b;
} REG_PWRCTRL_USB_PWR_STAT_T;

// lte_pwr_stat
typedef union {
    uint32_t v;
    struct
    {
        uint32_t lte_pwr_state : 1;  // [0], read only
        uint32_t lte_pwr_stable : 1; // [1], read only
        uint32_t __31_2 : 30;        // [31:2]
    } b;
} REG_PWRCTRL_LTE_PWR_STAT_T;

// gnss_pwr_stat
typedef union {
    uint32_t v;
    struct
    {
        uint32_t gnss_pwr_state : 1;  // [0], read only
        uint32_t gnss_pwr_stable : 1; // [1], read only
        uint32_t __31_2 : 30;         // [31:2]
    } b;
} REG_PWRCTRL_GNSS_PWR_STAT_T;

// state_delay
typedef union {
    uint32_t v;
    struct
    {
        uint32_t delay_value : 16; // [15:0]
        uint32_t __31_16 : 16;     // [31:16]
    } b;
} REG_PWRCTRL_STATE_DELAY_T;

// pd_m_delay
typedef union {
    uint32_t v;
    struct
    {
        uint32_t delay_value : 16; // [15:0]
        uint32_t __31_16 : 16;     // [31:16]
    } b;
} REG_PWRCTRL_PD_M_DELAY_T;

// pd_d_delay
typedef union {
    uint32_t v;
    struct
    {
        uint32_t delay_value : 16; // [15:0]
        uint32_t __31_16 : 16;     // [31:16]
    } b;
} REG_PWRCTRL_PD_D_DELAY_T;

// psram_hold_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t latch_en : 1; // [0]
        uint32_t __31_1 : 31;  // [31:1]
    } b;
} REG_PWRCTRL_PSRAM_HOLD_CTRL_T;

// slp_bypass
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ap_slp_bypass : 1;   // [0]
        uint32_t cp_slp_bypass : 1;   // [1]
        uint32_t pub_slp_bypass : 1;  // [2]
        uint32_t rf_slp_bypass : 1;   // [3]
        uint32_t usb_slp_bypass : 1;  // [4]
        uint32_t lte_slp_bypass : 1;  // [5]
        uint32_t gnss_slp_bypass : 1; // [6]
        uint32_t __31_7 : 25;         // [31:7]
    } b;
} REG_PWRCTRL_SLP_BYPASS_T;

// slp_timeout_flag
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ap_slp_timeout : 1;   // [0]
        uint32_t cp_slp_timeout : 1;   // [1]
        uint32_t pub_slp_timeout : 1;  // [2]
        uint32_t rf_slp_timeout : 1;   // [3]
        uint32_t usb_slp_timeout : 1;  // [4]
        uint32_t lte_slp_timeout : 1;  // [5]
        uint32_t gnss_slp_timeout : 1; // [6]
        uint32_t __31_7 : 25;          // [31:7]
    } b;
} REG_PWRCTRL_SLP_TIMEOUT_FLAG_T;

// pwrctrl_int_en_ap
typedef union {
    uint32_t v;
    struct
    {
        uint32_t pwrctrl_int_en_ap_sys : 1;   // [0]
        uint32_t pwrctrl_int_en_cp_sys : 1;   // [1]
        uint32_t pwrctrl_int_en_pub_sys : 1;  // [2]
        uint32_t pwrctrl_int_en_rf_sys : 1;   // [3]
        uint32_t pwrctrl_int_en_usb_sys : 1;  // [4]
        uint32_t pwrctrl_int_en_lte_sys : 1;  // [5]
        uint32_t pwrctrl_int_en_gnss_sys : 1; // [6]
        uint32_t __31_7 : 25;                 // [31:7]
    } b;
} REG_PWRCTRL_PWRCTRL_INT_EN_AP_T;

// pwrctrl_int_en_cp
typedef union {
    uint32_t v;
    struct
    {
        uint32_t pwrctrl_int_en_ap_sys : 1;   // [0]
        uint32_t pwrctrl_int_en_cp_sys : 1;   // [1]
        uint32_t pwrctrl_int_en_pub_sys : 1;  // [2]
        uint32_t pwrctrl_int_en_rf_sys : 1;   // [3]
        uint32_t pwrctrl_int_en_usb_sys : 1;  // [4]
        uint32_t pwrctrl_int_en_lte_sys : 1;  // [5]
        uint32_t pwrctrl_int_en_gnss_sys : 1; // [6]
        uint32_t __31_7 : 25;                 // [31:7]
    } b;
} REG_PWRCTRL_PWRCTRL_INT_EN_CP_T;

// pwrctrl_sm_state
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ap_sm_state : 4;   // [3:0], read only
        uint32_t cp_sm_state : 4;   // [7:4], read only
        uint32_t pub_sm_state : 4;  // [11:8], read only
        uint32_t rf_sm_state : 4;   // [15:12], read only
        uint32_t usb_sm_state : 4;  // [19:16], read only
        uint32_t lte_sm_state : 4;  // [23:20], read only
        uint32_t gnss_sm_state : 4; // [27:24], read only
        uint32_t __31_28 : 4;       // [31:28]
    } b;
} REG_PWRCTRL_PWRCTRL_SM_STATE_T;

// pwrctrl_hwen
#define PWRCTRL_AP_PWR_HWEN (1 << 0)
#define PWRCTRL_CP_PWR_HWEN (1 << 1)

// ap_pwr_ctrl
#define PWRCTRL_AP_PWR_CTRL (1 << 0)

// cp_pwr_ctrl
#define PWRCTRL_CP_PWR_CTRL (1 << 0)

// pub_pwr_ctrl
#define PWRCTRL_AP_POL (1 << 0)
#define PWRCTRL_CP_POL (1 << 1)

// rf_pwr_ctrl
#define PWRCTRL_RF_PWR_CTRL (1 << 0)

// usb_pwr_ctrl
#define PWRCTRL_USB_PWR_CTRL (1 << 0)

// lte_pwr_ctrl
#define PWRCTRL_LTE_PWR_CTRL (1 << 0)

// gnss_pwr_ctrl
#define PWRCTRL_GNSS_PWR_CTRL (1 << 0)

// ap_pwr_stat
#define PWRCTRL_AP_PWR_STATE (1 << 0)
#define PWRCTRL_AP_PWR_STABLE (1 << 1)

// cp_pwr_stat
#define PWRCTRL_CP_PWR_STATE (1 << 0)
#define PWRCTRL_CP_PWR_STABLE (1 << 1)

// pub_pwr_stat
#define PWRCTRL_PUB_PWR_STATE (1 << 0)
#define PWRCTRL_PUB_PWR_STABLE (1 << 1)

// rf_pwr_stat
#define PWRCTRL_RF_PWR_STATE (1 << 0)
#define PWRCTRL_RF_PWR_STABLE (1 << 1)

// usb_pwr_stat
#define PWRCTRL_USB_PWR_STATE (1 << 0)
#define PWRCTRL_USB_PWR_STABLE (1 << 1)

// lte_pwr_stat
#define PWRCTRL_LTE_PWR_STATE (1 << 0)
#define PWRCTRL_LTE_PWR_STABLE (1 << 1)

// gnss_pwr_stat
#define PWRCTRL_GNSS_PWR_STATE (1 << 0)
#define PWRCTRL_GNSS_PWR_STABLE (1 << 1)

// state_delay
#define PWRCTRL_DELAY_VALUE(n) (((n)&0xffff) << 0)

// pd_m_delay
#define PWRCTRL_DELAY_VALUE(n) (((n)&0xffff) << 0)

// pd_d_delay
#define PWRCTRL_DELAY_VALUE(n) (((n)&0xffff) << 0)

// psram_hold_ctrl
#define PWRCTRL_LATCH_EN (1 << 0)

// slp_bypass
#define PWRCTRL_AP_SLP_BYPASS (1 << 0)
#define PWRCTRL_CP_SLP_BYPASS (1 << 1)
#define PWRCTRL_PUB_SLP_BYPASS (1 << 2)
#define PWRCTRL_RF_SLP_BYPASS (1 << 3)
#define PWRCTRL_USB_SLP_BYPASS (1 << 4)
#define PWRCTRL_LTE_SLP_BYPASS (1 << 5)
#define PWRCTRL_GNSS_SLP_BYPASS (1 << 6)

// slp_timeout_flag
#define PWRCTRL_AP_SLP_TIMEOUT (1 << 0)
#define PWRCTRL_CP_SLP_TIMEOUT (1 << 1)
#define PWRCTRL_PUB_SLP_TIMEOUT (1 << 2)
#define PWRCTRL_RF_SLP_TIMEOUT (1 << 3)
#define PWRCTRL_USB_SLP_TIMEOUT (1 << 4)
#define PWRCTRL_LTE_SLP_TIMEOUT (1 << 5)
#define PWRCTRL_GNSS_SLP_TIMEOUT (1 << 6)

// pwrctrl_int_en_ap
#define PWRCTRL_PWRCTRL_INT_EN_AP_SYS (1 << 0)
#define PWRCTRL_PWRCTRL_INT_EN_CP_SYS (1 << 1)
#define PWRCTRL_PWRCTRL_INT_EN_PUB_SYS (1 << 2)
#define PWRCTRL_PWRCTRL_INT_EN_RF_SYS (1 << 3)
#define PWRCTRL_PWRCTRL_INT_EN_USB_SYS (1 << 4)
#define PWRCTRL_PWRCTRL_INT_EN_LTE_SYS (1 << 5)
#define PWRCTRL_PWRCTRL_INT_EN_GNSS_SYS (1 << 6)

// pwrctrl_int_en_cp
#define PWRCTRL_PWRCTRL_INT_EN_AP_SYS (1 << 0)
#define PWRCTRL_PWRCTRL_INT_EN_CP_SYS (1 << 1)
#define PWRCTRL_PWRCTRL_INT_EN_PUB_SYS (1 << 2)
#define PWRCTRL_PWRCTRL_INT_EN_RF_SYS (1 << 3)
#define PWRCTRL_PWRCTRL_INT_EN_USB_SYS (1 << 4)
#define PWRCTRL_PWRCTRL_INT_EN_LTE_SYS (1 << 5)
#define PWRCTRL_PWRCTRL_INT_EN_GNSS_SYS (1 << 6)

// pwrctrl_sm_state
#define PWRCTRL_AP_SM_STATE(n) (((n)&0xf) << 0)
#define PWRCTRL_CP_SM_STATE(n) (((n)&0xf) << 4)
#define PWRCTRL_PUB_SM_STATE(n) (((n)&0xf) << 8)
#define PWRCTRL_RF_SM_STATE(n) (((n)&0xf) << 12)
#define PWRCTRL_USB_SM_STATE(n) (((n)&0xf) << 16)
#define PWRCTRL_LTE_SM_STATE(n) (((n)&0xf) << 20)
#define PWRCTRL_GNSS_SM_STATE(n) (((n)&0xf) << 24)

#endif // _PWRCTRL_H_
