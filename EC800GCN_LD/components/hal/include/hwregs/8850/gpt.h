/* Copyright (C) 2018 RDA Technologies Limited and/or its affiliates("RDA").
 * All rights reserved.
 *
 * This software is supplied "AS IS" without any warranties.
 * RDA assumes no responsibility or liability for the use of the software,
 * conveys no license or title under any patent, copyright, or mask work
 * right to the product. RDA reserves the right to make changes in the
 * software without notification.  RDA also make no representation or
 * warranty that such application will be suitable for the specified use
 * without further testing or modification.
 */

#ifndef _GPT_H_
#define _GPT_H_

// Auto generated by dtools(see dtools.txt for its version).
// Don't edit it manually!

#define REG_AON_GPT1_BASE (0x5150b000)
#define REG_AON_GPT2_BASE (0x5150b400)
#define REG_AON_GPT3_BASE (0x5150b800)
#define REG_AP_GPT1_BASE (0x04809200)
#define REG_AP_GPT2_BASE (0x04809400)
#define REG_AP_GPT3_BASE (0x04809600)
#define REG_AP_GPT4_BASE (0x04809800)
#define REG_AP_GPT5_BASE (0x04809a00)
#define REG_AP_GPT6_BASE (0x04809c00)

typedef volatile struct
{
    uint32_t cr;            // 0x00000000
    uint32_t smcr;          // 0x00000004
    uint32_t egr;           // 0x00000008
    uint32_t ccmr_oc1;      // 0x0000000c
    uint32_t ccmr_ic1;      // 0x00000010
    uint32_t ccer;          // 0x00000014
    uint32_t cnt;           // 0x00000018
    uint32_t psc;           // 0x0000001c
    uint32_t arr;           // 0x00000020
    uint32_t timer_ccr1_ic; // 0x00000024
    uint32_t timer_ccr2_ic; // 0x00000028
    uint32_t timer_ccr3_ic; // 0x0000002c
    uint32_t timer_ccr4_ic; // 0x00000030
    uint32_t timer_ccr1_oc; // 0x00000034
    uint32_t timer_ccr2_oc; // 0x00000038
    uint32_t timer_ccr3_oc; // 0x0000003c
    uint32_t timer_ccr4_oc; // 0x00000040
    uint32_t isr;           // 0x00000044
    uint32_t irsr;          // 0x00000048
    uint32_t mask;          // 0x0000004c
    uint32_t clr;           // 0x00000050
} HWP_GPT_T;

#define hwp_aonGpt1 ((HWP_GPT_T *)REG_ACCESS_ADDRESS(REG_AON_GPT1_BASE))
#define hwp_aonGpt2 ((HWP_GPT_T *)REG_ACCESS_ADDRESS(REG_AON_GPT2_BASE))
#define hwp_aonGpt3 ((HWP_GPT_T *)REG_ACCESS_ADDRESS(REG_AON_GPT3_BASE))
#define hwp_apGpt1 ((HWP_GPT_T *)REG_ACCESS_ADDRESS(REG_AP_GPT1_BASE))
#define hwp_apGpt2 ((HWP_GPT_T *)REG_ACCESS_ADDRESS(REG_AP_GPT2_BASE))
#define hwp_apGpt3 ((HWP_GPT_T *)REG_ACCESS_ADDRESS(REG_AP_GPT3_BASE))
#define hwp_apGpt4 ((HWP_GPT_T *)REG_ACCESS_ADDRESS(REG_AP_GPT4_BASE))
#define hwp_apGpt5 ((HWP_GPT_T *)REG_ACCESS_ADDRESS(REG_AP_GPT5_BASE))
#define hwp_apGpt6 ((HWP_GPT_T *)REG_ACCESS_ADDRESS(REG_AP_GPT6_BASE))

// cr
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cen : 1;        // [0]
        uint32_t ckd : 2;        // [2:1]
        uint32_t udis : 1;       // [3]
        uint32_t opm : 1;        // [4]
        uint32_t dir : 1;        // [5]
        uint32_t cms : 2;        // [7:6]
        uint32_t arpe : 1;       // [8]
        uint32_t tri : 3;        // [11:9]
        uint32_t tri_cnt_en : 1; // [12]
        uint32_t __30_13 : 18;   // [30:13]
        uint32_t refclk_sel : 1; // [31]
    } b;
} REG_GPT_CR_T;

// smcr
typedef union {
    uint32_t v;
    struct
    {
        uint32_t sms : 3;     // [2:0]
        uint32_t __31_3 : 29; // [31:3]
    } b;
} REG_GPT_SMCR_T;

// egr
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ug : 1;      // [0], read only
        uint32_t __31_1 : 31; // [31:1]
    } b;
} REG_GPT_EGR_T;

// ccmr_oc1
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cc1s : 2;  // [1:0]
        uint32_t oc1fe : 1; // [2]
        uint32_t oc1pe : 1; // [3]
        uint32_t oc1m : 3;  // [6:4]
        uint32_t oc1ce : 1; // [7]
        uint32_t cc2s : 2;  // [9:8]
        uint32_t oc2fe : 1; // [10]
        uint32_t oc2pe : 1; // [11]
        uint32_t oc2m : 3;  // [14:12]
        uint32_t oc2ce : 1; // [15]
        uint32_t cc3s : 2;  // [17:16]
        uint32_t oc3fe : 1; // [18]
        uint32_t oc3pe : 1; // [19]
        uint32_t oc3m : 3;  // [22:20]
        uint32_t oc3ce : 1; // [23]
        uint32_t cc4s : 2;  // [25:24]
        uint32_t oc4fe : 1; // [26]
        uint32_t oc4pe : 1; // [27]
        uint32_t oc4m : 3;  // [30:28]
        uint32_t oc4ce : 1; // [31]
    } b;
} REG_GPT_CCMR_OC1_T;

// ccmr_ic1
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ic1psc : 2;  // [1:0]
        uint32_t ic1f : 4;    // [5:2]
        uint32_t __7_6 : 2;   // [7:6]
        uint32_t ic2psc : 2;  // [9:8]
        uint32_t ic2f : 4;    // [13:10]
        uint32_t __15_14 : 2; // [15:14]
        uint32_t ic3psc : 2;  // [17:16]
        uint32_t ic3f : 4;    // [21:18]
        uint32_t __23_22 : 2; // [23:22]
        uint32_t ic4psc : 2;  // [25:24]
        uint32_t ic4f : 4;    // [29:26]
        uint32_t __31_30 : 2; // [31:30]
    } b;
} REG_GPT_CCMR_IC1_T;

// ccer
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cc1e : 1;    // [0]
        uint32_t cc1p : 1;    // [1]
        uint32_t cc2e : 1;    // [2]
        uint32_t cc2p : 1;    // [3]
        uint32_t cc3e : 1;    // [4]
        uint32_t cc3p : 1;    // [5]
        uint32_t cc4e : 1;    // [6]
        uint32_t cc4p : 1;    // [7]
        uint32_t __31_8 : 24; // [31:8]
    } b;
} REG_GPT_CCER_T;

// cnt
typedef union {
    uint32_t v;
    struct
    {
        uint32_t cnt_value : 16; // [15:0], read only
        uint32_t __31_16 : 16;   // [31:16]
    } b;
} REG_GPT_CNT_T;

// psc
typedef union {
    uint32_t v;
    struct
    {
        uint32_t psc_value : 16; // [15:0]
        uint32_t __31_16 : 16;   // [31:16]
    } b;
} REG_GPT_PSC_T;

// arr
typedef union {
    uint32_t v;
    struct
    {
        uint32_t arr_value : 16; // [15:0]
        uint32_t __31_16 : 16;   // [31:16]
    } b;
} REG_GPT_ARR_T;

// timer_ccr1_ic
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_ccr1_capture : 16; // [15:0], read only
        uint32_t __31_16 : 16;            // [31:16]
    } b;
} REG_GPT_TIMER_CCR1_IC_T;

// timer_ccr2_ic
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_ccr2_capture : 16; // [15:0], read only
        uint32_t __31_16 : 16;            // [31:16]
    } b;
} REG_GPT_TIMER_CCR2_IC_T;

// timer_ccr3_ic
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_ccr3_capture : 16; // [15:0], read only
        uint32_t __31_16 : 16;            // [31:16]
    } b;
} REG_GPT_TIMER_CCR3_IC_T;

// timer_ccr4_ic
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_ccr4_capture : 16; // [15:0], read only
        uint32_t __31_16 : 16;            // [31:16]
    } b;
} REG_GPT_TIMER_CCR4_IC_T;

// timer_ccr1_oc
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_ccr1_compare : 16; // [15:0]
        uint32_t __31_16 : 16;            // [31:16]
    } b;
} REG_GPT_TIMER_CCR1_OC_T;

// timer_ccr2_oc
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_ccr2_compare : 16; // [15:0]
        uint32_t __31_16 : 16;            // [31:16]
    } b;
} REG_GPT_TIMER_CCR2_OC_T;

// timer_ccr3_oc
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_ccr3_compare : 16; // [15:0]
        uint32_t __31_16 : 16;            // [31:16]
    } b;
} REG_GPT_TIMER_CCR3_OC_T;

// timer_ccr4_oc
typedef union {
    uint32_t v;
    struct
    {
        uint32_t timer_ccr4_compare : 16; // [15:0]
        uint32_t __31_16 : 16;            // [31:16]
    } b;
} REG_GPT_TIMER_CCR4_OC_T;

// isr
typedef union {
    uint32_t v;
    struct
    {
        uint32_t compare_int : 4;  // [3:0], read only
        uint32_t __11_4 : 8;       // [11:4]
        uint32_t capture_int : 4;  // [15:12], read only
        uint32_t __29_16 : 14;     // [29:16]
        uint32_t slave_trig : 1;   // [30], read only
        uint32_t event_update : 1; // [31], read only
    } b;
} REG_GPT_ISR_T;

// irsr
typedef union {
    uint32_t v;
    struct
    {
        uint32_t compare_int : 4;  // [3:0], read only
        uint32_t __11_4 : 8;       // [11:4]
        uint32_t capture_int : 4;  // [15:12], read only
        uint32_t __29_16 : 14;     // [29:16]
        uint32_t slave_trig : 1;   // [30], read only
        uint32_t event_update : 1; // [31], read only
    } b;
} REG_GPT_IRSR_T;

// mask
typedef union {
    uint32_t v;
    struct
    {
        uint32_t compare_int : 4;  // [3:0]
        uint32_t __11_4 : 8;       // [11:4]
        uint32_t capture_int : 4;  // [15:12]
        uint32_t __29_16 : 14;     // [29:16]
        uint32_t slave_trig : 1;   // [30]
        uint32_t event_update : 1; // [31]
    } b;
} REG_GPT_MASK_T;

// clr
typedef union {
    uint32_t v;
    struct
    {
        uint32_t compare_int : 4;  // [3:0], read only
        uint32_t __11_4 : 8;       // [11:4]
        uint32_t capture_int : 4;  // [15:12], read only
        uint32_t __29_16 : 14;     // [29:16]
        uint32_t slave_trig : 1;   // [30], read only
        uint32_t event_update : 1; // [31], read only
    } b;
} REG_GPT_CLR_T;

// cr
#define GPT_CEN (1 << 0)
#define GPT_CKD(n) (((n)&0x3) << 1)
#define GPT_UDIS (1 << 3)
#define GPT_OPM (1 << 4)
#define GPT_DIR (1 << 5)
#define GPT_CMS(n) (((n)&0x3) << 6)
#define GPT_ARPE (1 << 8)
#define GPT_TRI(n) (((n)&0x7) << 9)
#define GPT_TRI_CNT_EN (1 << 12)
#define GPT_REFCLK_SEL (1 << 31)

// smcr
#define GPT_SMS(n) (((n)&0x7) << 0)

// egr
#define GPT_UG (1 << 0)

// ccmr_oc1
#define GPT_CC1S(n) (((n)&0x3) << 0)
#define GPT_OC1FE (1 << 2)
#define GPT_OC1PE (1 << 3)
#define GPT_OC1M(n) (((n)&0x7) << 4)
#define GPT_OC1CE (1 << 7)
#define GPT_CC2S(n) (((n)&0x3) << 8)
#define GPT_OC2FE (1 << 10)
#define GPT_OC2PE (1 << 11)
#define GPT_OC2M(n) (((n)&0x7) << 12)
#define GPT_OC2CE (1 << 15)
#define GPT_CC3S(n) (((n)&0x3) << 16)
#define GPT_OC3FE (1 << 18)
#define GPT_OC3PE (1 << 19)
#define GPT_OC3M(n) (((n)&0x7) << 20)
#define GPT_OC3CE (1 << 23)
#define GPT_CC4S(n) (((n)&0x3) << 24)
#define GPT_OC4FE (1 << 26)
#define GPT_OC4PE (1 << 27)
#define GPT_OC4M(n) (((n)&0x7) << 28)
#define GPT_OC4CE (1 << 31)

// ccmr_ic1
#define GPT_IC1PSC(n) (((n)&0x3) << 0)
#define GPT_IC1F(n) (((n)&0xf) << 2)
#define GPT_IC2PSC(n) (((n)&0x3) << 8)
#define GPT_IC2F(n) (((n)&0xf) << 10)
#define GPT_IC3PSC(n) (((n)&0x3) << 16)
#define GPT_IC3F(n) (((n)&0xf) << 18)
#define GPT_IC4PSC(n) (((n)&0x3) << 24)
#define GPT_IC4F(n) (((n)&0xf) << 26)

// ccer
#define GPT_CC1E (1 << 0)
#define GPT_CC1P (1 << 1)
#define GPT_CC2E (1 << 2)
#define GPT_CC2P (1 << 3)
#define GPT_CC3E (1 << 4)
#define GPT_CC3P (1 << 5)
#define GPT_CC4E (1 << 6)
#define GPT_CC4P (1 << 7)

// cnt
#define GPT_CNT_VALUE(n) (((n)&0xffff) << 0)

// psc
#define GPT_PSC_VALUE(n) (((n)&0xffff) << 0)

// arr
#define GPT_ARR_VALUE(n) (((n)&0xffff) << 0)

// timer_ccr1_ic
#define GPT_TIMER_CCR1_CAPTURE(n) (((n)&0xffff) << 0)

// timer_ccr2_ic
#define GPT_TIMER_CCR2_CAPTURE(n) (((n)&0xffff) << 0)

// timer_ccr3_ic
#define GPT_TIMER_CCR3_CAPTURE(n) (((n)&0xffff) << 0)

// timer_ccr4_ic
#define GPT_TIMER_CCR4_CAPTURE(n) (((n)&0xffff) << 0)

// timer_ccr1_oc
#define GPT_TIMER_CCR1_COMPARE(n) (((n)&0xffff) << 0)

// timer_ccr2_oc
#define GPT_TIMER_CCR2_COMPARE(n) (((n)&0xffff) << 0)

// timer_ccr3_oc
#define GPT_TIMER_CCR3_COMPARE(n) (((n)&0xffff) << 0)

// timer_ccr4_oc
#define GPT_TIMER_CCR4_COMPARE(n) (((n)&0xffff) << 0)

// isr
#define GPT_COMPARE_INT(n) (((n)&0xf) << 0)
#define GPT_CAPTURE_INT(n) (((n)&0xf) << 12)
#define GPT_SLAVE_TRIG (1 << 30)
#define GPT_EVENT_UPDATE (1 << 31)

// irsr
#define GPT_COMPARE_INT(n) (((n)&0xf) << 0)
#define GPT_CAPTURE_INT(n) (((n)&0xf) << 12)
#define GPT_SLAVE_TRIG (1 << 30)
#define GPT_EVENT_UPDATE (1 << 31)

// mask
#define GPT_COMPARE_INT(n) (((n)&0xf) << 0)
#define GPT_CAPTURE_INT(n) (((n)&0xf) << 12)
#define GPT_SLAVE_TRIG (1 << 30)
#define GPT_EVENT_UPDATE (1 << 31)

// clr
#define GPT_COMPARE_INT(n) (((n)&0xf) << 0)
#define GPT_CAPTURE_INT(n) (((n)&0xf) << 12)
#define GPT_SLAVE_TRIG (1 << 30)
#define GPT_EVENT_UPDATE (1 << 31)

#endif // _GPT_H_
