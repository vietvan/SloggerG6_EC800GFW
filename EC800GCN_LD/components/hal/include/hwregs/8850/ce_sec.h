/* Copyright (C) 2018 RDA Technologies Limited and/or its affiliates("RDA").
 * All rights reserved.
 *
 * This software is supplied "AS IS" without any warranties.
 * RDA assumes no responsibility or liability for the use of the software,
 * conveys no license or title under any patent, copyright, or mask work
 * right to the product. RDA reserves the right to make changes in the
 * software without notification.  RDA also make no representation or
 * warranty that such application will be suitable for the specified use
 * without further testing or modification.
 */

#ifndef _CE_SEC_H_
#define _CE_SEC_H_

// Auto generated by dtools(see dtools.txt for its version).
// Don't edit it manually!

#define REG_CE_SEC_BASE (0x04004000)

typedef volatile struct
{
    uint32_t ce_debug_dma_status;                // 0x00000000
    uint32_t ce_debug_aes_status;                // 0x00000004
    uint32_t ce_debug_tdes_status;               // 0x00000008
    uint32_t ce_debug_hash_status0;              // 0x0000000c
    uint32_t ce_debug_hash_status1;              // 0x00000010
    uint32_t __20[1];                            // 0x00000014
    uint32_t ce_clk_en;                          // 0x00000018
    uint32_t ce_int_en;                          // 0x0000001c
    uint32_t ce_int_status;                      // 0x00000020
    uint32_t ce_int_clear;                       // 0x00000024
    uint32_t ce_start;                           // 0x00000028
    uint32_t ce_clear;                           // 0x0000002c
    uint32_t ce_aes_mode;                        // 0x00000030
    uint32_t ce_tdes_mode;                       // 0x00000034
    uint32_t ce_hash_mode;                       // 0x00000038
    uint32_t ce_chacha_poly_mode;                // 0x0000003c
    uint32_t ce_simon_speck_mode;                // 0x00000040
    uint32_t ce_cfg;                             // 0x00000044
    uint32_t ce_src_frag_length;                 // 0x00000048
    uint32_t ce_dst_frag_length;                 // 0x0000004c
    uint32_t ce_src_addr;                        // 0x00000050
    uint32_t ce_dst_addr;                        // 0x00000054
    uint32_t ce_list_length;                     // 0x00000058
    uint32_t ce_list_ptr;                        // 0x0000005c
    uint32_t ce_aes_tdes_rsa_key_length;         // 0x00000060
    uint32_t ce_aes_tdes_rsa_key_address;        // 0x00000064
    uint32_t ce_aes_tag_length;                  // 0x00000068
    uint32_t ce_aes_tag_address;                 // 0x0000006c
    uint32_t ce_iv_sec_cnt0;                     // 0x00000070
    uint32_t ce_iv_sec_cnt1;                     // 0x00000074
    uint32_t ce_iv_sec_cnt2;                     // 0x00000078
    uint32_t ce_iv_sec_cnt3;                     // 0x0000007c
    uint32_t ce_aes_des_key10;                   // 0x00000080
    uint32_t ce_aes_des_key11;                   // 0x00000084
    uint32_t ce_aes_des_key12;                   // 0x00000088
    uint32_t ce_aes_des_key13;                   // 0x0000008c
    uint32_t ce_aes_des_key14;                   // 0x00000090
    uint32_t ce_aes_des_key15;                   // 0x00000094
    uint32_t ce_aes_des_key16;                   // 0x00000098
    uint32_t ce_aes_des_key17;                   // 0x0000009c
    uint32_t ce_aes_des_key20;                   // 0x000000a0
    uint32_t ce_aes_des_key21;                   // 0x000000a4
    uint32_t ce_aes_des_key22;                   // 0x000000a8
    uint32_t ce_aes_des_key23;                   // 0x000000ac
    uint32_t ce_aes_des_key24;                   // 0x000000b0
    uint32_t ce_aes_des_key25;                   // 0x000000b4
    uint32_t ce_aes_des_key26;                   // 0x000000b8
    uint32_t ce_aes_des_key27;                   // 0x000000bc
    uint32_t ce_sm4_mode;                        // 0x000000c0
    uint32_t __196[1];                           // 0x000000c4
    uint32_t ce_ip_version;                      // 0x000000c8
    uint32_t ce_pka_mode;                        // 0x000000cc
    uint32_t ce_pka_reg_length01;                // 0x000000d0
    uint32_t ce_pka_reg_length23;                // 0x000000d4
    uint32_t __216[22];                          // 0x000000d8
    uint32_t ce_pka_inst_pc;                     // 0x00000130
    uint32_t ce_pka_debug0;                      // 0x00000134
    uint32_t ce_pka_debug1;                      // 0x00000138
    uint32_t ce_pka_debug2;                      // 0x0000013c
    uint32_t ce_pka_debug3;                      // 0x00000140
    uint32_t __324[3];                           // 0x00000144
    uint32_t ce_pf_calc;                         // 0x00000150
    uint32_t ce_user_flag;                       // 0x00000154
    uint32_t ce_axi_axcache;                     // 0x00000158
    uint32_t ce_cmd_stop_ctrl;                   // 0x0000015c
    uint32_t ce_axi_protect_sel;                 // 0x00000160
    uint32_t ce_pf_calc_high;                    // 0x00000164
    uint32_t __360[38];                          // 0x00000168
    uint32_t ce_rng_en;                          // 0x00000200
    uint32_t ce_rng_config;                      // 0x00000204
    uint32_t ce_rng_data;                        // 0x00000208
    uint32_t ce_rng_sample_period;               // 0x0000020c
    uint32_t ce_rng_post_process_en;             // 0x00000210
    uint32_t ce_rng_work_status;                 // 0x00000214
    uint32_t ce_rng_timeout_cnt;                 // 0x00000218
    uint32_t ce_rng_int_en;                      // 0x0000021c
    uint32_t ce_rng_sts;                         // 0x00000220
    uint32_t ce_rng_int_clr;                     // 0x00000224
    uint32_t ce_rng_mode;                        // 0x00000228
    uint32_t ce_prng_seed_update;                // 0x0000022c
    uint32_t ce_prng_seed_config;                // 0x00000230
    uint32_t ce_rng_bit_rate;                    // 0x00000234
    uint32_t ce_rng_sram_data_threshhold;        // 0x00000238
    uint32_t ce_rng_sram_data_residue_num;       // 0x0000023c
    uint32_t ce_rng_exotic_fault_counter_config; // 0x00000240
    uint32_t ce_rng_drbg_seed_cnt;               // 0x00000244
    uint32_t ce_rng_ring_num_cfg_l;              // 0x00000248
    uint32_t ce_rng_ring_num_cfg_h;              // 0x0000024c
    uint32_t ce_rng_health_test_config;          // 0x00000250
    uint32_t ce_rng_drbg_test_pattern_l;         // 0x00000254
    uint32_t ce_rng_drbg_test_pattern_h;         // 0x00000258
    uint32_t ce_rng_raw_data_to_cpu;             // 0x0000025c
    uint32_t ce_rng_drbg_test_result;            // 0x00000260
    uint32_t __612[39];                          // 0x00000264
    uint32_t ce_session_key0;                    // 0x00000300
    uint32_t ce_session_key1;                    // 0x00000304
    uint32_t ce_session_key2;                    // 0x00000308
    uint32_t ce_session_key3;                    // 0x0000030c
    uint32_t ce_session_key4;                    // 0x00000310
    uint32_t ce_session_key5;                    // 0x00000314
    uint32_t ce_session_key6;                    // 0x00000318
    uint32_t ce_session_key7;                    // 0x0000031c
    uint32_t ce_iram_key0;                       // 0x00000320
    uint32_t ce_iram_key1;                       // 0x00000324
    uint32_t ce_iram_key2;                       // 0x00000328
    uint32_t ce_iram_key3;                       // 0x0000032c
    uint32_t ce_iram_key4;                       // 0x00000330
    uint32_t ce_iram_key5;                       // 0x00000334
    uint32_t ce_iram_key6;                       // 0x00000338
    uint32_t ce_iram_key7;                       // 0x0000033c
    uint32_t ce_secure_key_use_way;              // 0x00000340
    uint32_t ce_huk_key_config;                  // 0x00000344
    uint32_t ce_pka_key_config;                  // 0x00000348
    uint32_t __844[109];                         // 0x0000034c
    uint32_t ce_cmd_fifo_entry;                  // 0x00000500
    uint32_t ce_cmd_fifo_status;                 // 0x00000504
    uint32_t ce_rcv_addr_lo;                     // 0x00000508
    uint32_t ce_dump_addr_lo;                    // 0x0000050c
    uint32_t ce_dump_addr_hi;                    // 0x00000510
    uint32_t ce_finish_cmd_cnt;                  // 0x00000514
    uint32_t __1304[58];                         // 0x00000518
    uint32_t ce_pka_cmd_fifo_entry;              // 0x00000600
    uint32_t ce_pka_cmd_fifo_status;             // 0x00000604
    uint32_t ce_pka_cmd_addr;                    // 0x00000608
    uint32_t ce_pka_store_addr_hi;               // 0x0000060c
    uint32_t ce_pka_load_addr_hi;                // 0x00000610
    uint32_t ce_pka_finish_cmd_cnt;              // 0x00000614
    uint32_t ce_pka_start;                       // 0x00000618
    uint32_t ce_pka_clear;                       // 0x0000061c
    uint32_t __1568[1];                          // 0x00000620
    uint32_t ce_pka_rng_force_ssb_bit;           // 0x00000624
    uint32_t ce_pka_ctrl_operate_bit;            // 0x00000628
    uint32_t ce_pka_efs_debug_status;            // 0x0000062c
} HWP_CE_SEC_T;

#define hwp_ceSec ((HWP_CE_SEC_T *)REG_ACCESS_ADDRESS(REG_CE_SEC_BASE))

// ce_debug_dma_status
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_dma_main_read_state : 5;     // [4:0], read only
        uint32_t rf_ce_dma_pka_main_read_state : 3; // [7:5], read only
        uint32_t rf_ce_dma_main_write_state : 5;    // [12:8], read only
        uint32_t rf_ce_dma_err : 1;                 // [13], read only
        uint32_t rf_ce_int_raw_status_vld : 1;      // [14], read only
        uint32_t rf_ce_cmd_fifo_non_empty : 1;      // [15], read only
        uint32_t rf_ce_pka_cmd_fifo_non_empty : 1;  // [16], read only
        uint32_t rf_ce_dma_src_state : 5;           // [21:17], read only
        uint32_t rf_ce_dma_dst_state : 5;           // [26:22], read only
        uint32_t __27_27 : 1;                       // [27]
        uint32_t rf_ce_busy : 1;                    // [28], read only
        uint32_t rf_ce_arready : 1;                 // [29], read only
        uint32_t rf_ce_awready : 1;                 // [30], read only
        uint32_t rf_ce_wready : 1;                  // [31], read only
    } b;
} REG_CE_SEC_CE_DEBUG_DMA_STATUS_T;

// ce_debug_aes_status
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_aes_status : 8;              // [7:0], read only
        uint32_t __9_8 : 2;                         // [9:8]
        uint32_t rf_ce_wdma_data_status : 2;        // [11:10], read only
        uint32_t rf_ce_sm4_status : 3;              // [14:12], read only
        uint32_t rf_ce_rdma_data_status : 3;        // [17:15], read only
        uint32_t __19_18 : 2;                       // [19:18]
        uint32_t rf_ce_fde_dma_main_read_state : 5; // [24:20], read only
        uint32_t rf_ce_fde_wdma_data_status : 2;    // [26:25], read only
        uint32_t rf_ce_fde_rdma_data_status : 2;    // [28:27], read only
        uint32_t __31_29 : 3;                       // [31:29]
    } b;
} REG_CE_SEC_CE_DEBUG_AES_STATUS_T;

// ce_debug_tdes_status
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_fde_aes_status : 8;           // [7:0], read only
        uint32_t rf_ce_fde_dma_main_write_state : 5; // [12:8], read only
        uint32_t rf_ce_pka_dma_main_write_state : 3; // [15:13], read only
        uint32_t rf_ce_efuse_access_status : 5;      // [20:16], read only
        uint32_t rf_ce_dma_wvalid_state : 4;         // [24:21], read only
        uint32_t rf_ce_tdes_status : 5;              // [29:25], read only
        uint32_t __31_30 : 2;                        // [31:30]
    } b;
} REG_CE_SEC_CE_DEBUG_TDES_STATUS_T;

// ce_debug_hash_status1
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_hash_status1 : 10; // [9:0], read only
        uint32_t __31_10 : 22;            // [31:10]
    } b;
} REG_CE_SEC_CE_DEBUG_HASH_STATUS1_T;

// ce_clk_en
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_dma_ck_en : 1;         // [0]
        uint32_t rf_ce_aes_ck_en : 1;         // [1]
        uint32_t rf_ce_fde_aes_ck_en : 1;     // [2]
        uint32_t rf_ce_hash_ck_en : 1;        // [3]
        uint32_t rf_ce_des_ck_en : 1;         // [4]
        uint32_t rf_ce_trng_ck_en : 1;        // [5]
        uint32_t rf_ce_sm4_ck_en : 1;         // [6]
        uint32_t rf_ce_chacah_poly_ck_en : 1; // [7]
        uint32_t rf_ce_pka_ck_en : 1;         // [8]
        uint32_t rf_ce_simon_speck_ck_en : 1; // [9]
        uint32_t __15_10 : 6;                 // [15:10]
        uint32_t rf_ce_apb_rf_clk_en : 1;     // [16]
        uint32_t rf_ce_dma_ctrl_clk_en : 1;   // [17]
        uint32_t rf_ce_dma_axi_clk_en : 1;    // [18]
        uint32_t __19_19 : 1;                 // [19]
        uint32_t rf_ce_aes_clk_en : 1;        // [20]
        uint32_t rf_ce_rng_clk_en : 1;        // [21]
        uint32_t rf_ce_poly_clk_en : 1;       // [22]
        uint32_t rf_ce_chacha_clk_en : 1;     // [23]
        uint32_t rf_ce_trng_pub_clk_en : 1;   // [24]
        uint32_t rf_ce_rng_pub_clk_en : 1;    // [25]
        uint32_t __27_26 : 2;                 // [27:26]
        uint32_t rf_ce_fde_aes_clk_en : 1;    // [28]
        uint32_t __31_29 : 3;                 // [31:29]
    } b;
} REG_CE_SEC_CE_CLK_EN_T;

// ce_int_en
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_en_cmd_done_int : 1;              // [0]
        uint32_t rf_ce_en_efs_huk_unstable_int : 1;      // [1]
        uint32_t rf_ce_en_efs_all_zero_int : 1;          // [2]
        uint32_t __3_3 : 1;                              // [3]
        uint32_t rf_ce_en_len_err_int : 1;               // [4]
        uint32_t rf_ce_en_tdes_key_err_int : 1;          // [5]
        uint32_t __6_6 : 1;                              // [6]
        uint32_t rf_ce_en_rng_int : 1;                   // [7]
        uint32_t rf_ce_en_pka_store_done_int : 1;        // [8]
        uint32_t rf_ce_en_pka_one_cmd_done_int : 1;      // [9]
        uint32_t rf_ce_en_use_efuse_err_int : 1;         // [10]
        uint32_t rf_ce_en_pka_div_zero_err_int : 1;      // [11]
        uint32_t rf_ce_en_pka_find_prime_err_int : 1;    // [12]
        uint32_t rf_ce_en_pka_cmd_done_done_int : 1;     // [13]
        uint32_t rf_ce_en_pka_len_err_int : 1;           // [14]
        uint32_t rf_ce_en_pka_wr_efuse_key_addr_int : 1; // [15]
        uint32_t rf_ce_en_pka_rd_efuse_key_addr_int : 1; // [16]
        uint32_t __31_17 : 15;                           // [31:17]
    } b;
} REG_CE_SEC_CE_INT_EN_T;

// ce_int_status
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_cmd_done_int_status : 1;              // [0], read only
        uint32_t rf_ce_efs_huk_unstable_int_status : 1;      // [1], read only
        uint32_t rf_ce_efs_all_zero_int_status : 1;          // [2], read only
        uint32_t __3_3 : 1;                                  // [3]
        uint32_t rf_ce_len_err_int_status : 1;               // [4], read only
        uint32_t rf_ce_tdes_key_err_int_status : 1;          // [5], read only
        uint32_t __6_6 : 1;                                  // [6]
        uint32_t rf_ce_rng_int_status : 1;                   // [7], read only
        uint32_t rf_ce_pka_store_done_flag : 1;              // [8], read only
        uint32_t rf_ce_pka_one_cmd_done_flag : 1;            // [9], read only
        uint32_t rf_ce_use_efuse_err_flag : 1;               // [10], read only
        uint32_t rf_ce_pka_div_zero_err_flag : 1;            // [11], read only
        uint32_t rf_ce_pka_find_prime_err_flag : 1;          // [12], read only
        uint32_t rf_ce_pka_cmd_done_done_int_status : 1;     // [13], read only
        uint32_t rf_ce_pka_len_err_int_status : 1;           // [14], read only
        uint32_t rf_ce_pka_wr_efuse_key_addr_int_status : 1; // [15], read only
        uint32_t rf_ce_pka_rd_efuse_key_addr_int_status : 1; // [16], read only
        uint32_t __31_17 : 15;                               // [31:17]
    } b;
} REG_CE_SEC_CE_INT_STATUS_T;

// ce_int_clear
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_clear_cmd_done_int : 1;              // [0], write clear
        uint32_t rf_ce_clear_efs_huk_unstable_int : 1;      // [1], write clear
        uint32_t rf_ce_clear_efs_all_zero_int : 1;          // [2], write clear
        uint32_t __3_3 : 1;                                 // [3]
        uint32_t rf_ce_clear_len_err_int : 1;               // [4], write clear
        uint32_t rf_ce_clear_tdes_key_err_int : 1;          // [5], write clear
        uint32_t __7_6 : 2;                                 // [7:6]
        uint32_t rf_ce_clear_pka_store_done_int : 1;        // [8], write clear
        uint32_t rf_ce_clear_pka_one_cmd_done_int : 1;      // [9], write clear
        uint32_t rf_ce_clear_use_efuse_err_int : 1;         // [10], write clear
        uint32_t rf_ce_clear_pka_div_zero_err_int : 1;      // [11], write clear
        uint32_t rf_ce_clear_pka_find_prime_err_int : 1;    // [12], write clear
        uint32_t rf_ce_clear_pka_cmd_done_done_int : 1;     // [13], write clear
        uint32_t rf_ce_clear_pka_len_err_int : 1;           // [14], write clear
        uint32_t rf_ce_clear_pka_wr_efuse_key_addr_int : 1; // [15], write clear
        uint32_t rf_ce_clear_pka_rd_efuse_key_addr_int : 1; // [16], write clear
        uint32_t __31_17 : 15;                              // [31:17]
    } b;
} REG_CE_SEC_CE_INT_CLEAR_T;

// ce_start
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_start : 1; // [0], write clear
        uint32_t __31_1 : 31;     // [31:1]
    } b;
} REG_CE_SEC_CE_START_T;

// ce_clear
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_clear : 1; // [0], write clear
        uint32_t __31_1 : 31;     // [31:1]
    } b;
} REG_CE_SEC_CE_CLEAR_T;

// ce_aes_mode
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_aes_en : 1;               // [0]
        uint32_t __3_1 : 3;                      // [3:1]
        uint32_t rf_ce_aes_enc_dec_sel : 1;      // [4]
        uint32_t rf_ce_aes_mac_ctr_inc_mode : 2; // [6:5]
        uint32_t __7_7 : 1;                      // [7]
        uint32_t rf_ce_aes_work_mode : 4;        // [11:8]
        uint32_t rf_ce_aes_key_len_sel : 2;      // [13:12]
        uint32_t rf_ce_aes_xts_iv_rotation : 1;  // [14]
        uint32_t rf_ce_aes_key_update_n : 1;     // [15]
        uint32_t __31_16 : 16;                   // [31:16]
    } b;
} REG_CE_SEC_CE_AES_MODE_T;

// ce_tdes_mode
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_tdes_en : 1;                   // [0]
        uint32_t __3_1 : 3;                           // [3:1]
        uint32_t rf_ce_tdes_enc_dec_sel : 1;          // [4]
        uint32_t __7_5 : 3;                           // [7:5]
        uint32_t rf_ce_tdes_work_mode : 2;            // [9:8]
        uint32_t __11_10 : 2;                         // [11:10]
        uint32_t rf_ce_tdes_key_even_sel : 1;         // [12]
        uint32_t rf_ce_tdes_key_evenodd_check_on : 1; // [13]
        uint32_t __31_14 : 18;                        // [31:14]
    } b;
} REG_CE_SEC_CE_TDES_MODE_T;

// ce_hash_mode
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_hash_en : 1;              // [0]
        uint32_t __3_1 : 3;                      // [3:1]
        uint32_t rf_ce_hash_mode : 5;            // [8:4]
        uint32_t __11_9 : 3;                     // [11:9]
        uint32_t rf_hash_hmac_pad_sel : 2;       // [13:12]
        uint32_t __15_14 : 2;                    // [15:14]
        uint32_t rf_hash_sha3_shake_out_len : 8; // [23:16]
        uint32_t __31_24 : 8;                    // [31:24]
    } b;
} REG_CE_SEC_CE_HASH_MODE_T;

// ce_chacha_poly_mode
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_chacha_poly_en : 1;          // [0]
        uint32_t __3_1 : 3;                         // [3:1]
        uint32_t rf_ce_chacha_poly_enc_dec_sel : 1; // [4]
        uint32_t __7_5 : 3;                         // [7:5]
        uint32_t rf_ce_chacha_poly_mode : 2;        // [9:8]
        uint32_t __31_10 : 22;                      // [31:10]
    } b;
} REG_CE_SEC_CE_CHACHA_POLY_MODE_T;

// ce_simon_speck_mode
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_simon_speck_en : 1;           // [0]
        uint32_t __3_1 : 3;                          // [3:1]
        uint32_t rf_ce_simon_speck_enc_dec_sel : 1;  // [4]
        uint32_t __7_5 : 3;                          // [7:5]
        uint32_t rf_ce_simon_speck_sel : 1;          // [8]
        uint32_t rf_ce_simon_speck_work_mode : 3;    // [11:9]
        uint32_t __12_12 : 1;                        // [12]
        uint32_t rf_ce_simon_speck_key_len_sel : 2;  // [14:13]
        uint32_t rf_ce_simon_speck_key_update_n : 1; // [15]
        uint32_t __31_16 : 16;                       // [31:16]
    } b;
} REG_CE_SEC_CE_SIMON_SPECK_MODE_T;

// ce_cfg
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_link_mode_flag : 1;          // [0]
        uint32_t rf_ce_dont_rcv_ddr : 1;            // [1]
        uint32_t rf_ce_dont_dump_ddr : 1;           // [2]
        uint32_t rf_ce_cmd_ioc : 1;                 // [3]
        uint32_t rf_ce_std_mode_end_flag : 1;       // [4]
        uint32_t rf_ce_std_mode_aad_end_flag : 1;   // [5]
        uint32_t rf_ce_std_mode_aad_flag : 1;       // [6]
        uint32_t rf_ce_dma_bypass : 1;              // [7]
        uint32_t rf_ce_key_in_ddr_flag : 1;         // [8]
        uint32_t rf_ce_key_in_efuse_flag : 1;       // [9]
        uint32_t rf_ce_key_in_session_key_flag : 1; // [10]
        uint32_t rf_ce_key_in_iram_flag : 1;        // [11]
        uint32_t rf_ce_do_wait_bdone : 1;           // [12]
        uint32_t rf_ce_list_aad_end_flag : 1;       // [13], read only
        uint32_t rf_ce_list_aad_flag : 1;           // [14], read only
        uint32_t rf_ce_list_end_flag : 1;           // [15], read only
        uint32_t rf_ce_list_data_end_flag : 1;      // [16], read only
        uint32_t rf_ce_list_update_iv_sec_cnt : 1;  // [17], read only
        uint32_t rf_ce_key_hdcp_en : 1;             // [18], read only
        uint32_t __19_19 : 1;                       // [19]
        uint32_t rf_ce_dst_byte_switch : 1;         // [20]
        uint32_t rf_ce_src_byte_switch : 1;         // [21]
        uint32_t rf_ce_dst_word_switch : 1;         // [22]
        uint32_t rf_ce_src_word_switch : 1;         // [23]
        uint32_t __31_24 : 8;                       // [31:24]
    } b;
} REG_CE_SEC_CE_CFG_T;

// ce_src_frag_length
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_src_frag_len : 24; // [23:0]
        uint32_t rf_ce_src_addr_hi : 4;   // [27:24]
        uint32_t __31_28 : 4;             // [31:28]
    } b;
} REG_CE_SEC_CE_SRC_FRAG_LENGTH_T;

// ce_dst_frag_length
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_dst_frag_len : 24; // [23:0]
        uint32_t rf_ce_dst_addr_hi : 4;   // [27:24]
        uint32_t __31_28 : 4;             // [31:28]
    } b;
} REG_CE_SEC_CE_DST_FRAG_LENGTH_T;

// ce_list_length
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_list_len : 12;   // [11:0]
        uint32_t __15_12 : 4;           // [15:12]
        uint32_t rf_ce_list_ptr_hi : 4; // [19:16]
        uint32_t __31_20 : 12;          // [31:20]
    } b;
} REG_CE_SEC_CE_LIST_LENGTH_T;

// ce_aes_tdes_rsa_key_length
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_aes_tdes_rsa_key_len : 24;    // [23:0]
        uint32_t rf_ce_aes_tdes_rsa_key_addr_hi : 4; // [27:24]
        uint32_t __31_28 : 4;                        // [31:28]
    } b;
} REG_CE_SEC_CE_AES_TDES_RSA_KEY_LENGTH_T;

// ce_aes_tag_length
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_aes_tag_len : 8;     // [7:0]
        uint32_t rf_ce_aes_tag_addr_hi : 4; // [11:8]
        uint32_t __31_12 : 20;              // [31:12]
    } b;
} REG_CE_SEC_CE_AES_TAG_LENGTH_T;

// ce_sm4_mode
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_sm4_en : 1;               // [0]
        uint32_t __3_1 : 3;                      // [3:1]
        uint32_t rf_ce_sm4_enc_dec_sel : 1;      // [4]
        uint32_t __7_5 : 3;                      // [7:5]
        uint32_t rf_ce_sm4_work_mode : 3;        // [10:8]
        uint32_t rf_ce_sm4_xts_inv_rotation : 1; // [11]
        uint32_t rf_ce_sm4_key_update_n : 1;     // [12]
        uint32_t __31_13 : 19;                   // [31:13]
    } b;
} REG_CE_SEC_CE_SM4_MODE_T;

// ce_ip_version
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_ip_version_lo : 4;  // [3:0]
        uint32_t rf_ce_ip_version_hi : 28; // [31:4], read only
    } b;
} REG_CE_SEC_CE_IP_VERSION_T;

// ce_pka_mode
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_pka_en : 1;              // [0]
        uint32_t rf_ce_pka_reg_num_sel : 1;     // [1]
        uint32_t __15_2 : 14;                   // [15:2]
        uint32_t rf_ce_pka_find_prime_num : 8;  // [23:16]
        uint32_t rf_ce_pka_dst_byte_switch : 1; // [24]
        uint32_t rf_ce_pka_src_byte_switch : 1; // [25]
        uint32_t rf_ce_pka_dst_word_switch : 1; // [26]
        uint32_t rf_ce_pka_src_word_switch : 1; // [27]
        uint32_t rf_ce_pka_cmd_addr_hi : 4;     // [31:28]
    } b;
} REG_CE_SEC_CE_PKA_MODE_T;

// ce_pka_reg_length01
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_pka_reg_length0 : 10; // [9:0]
        uint32_t __15_10 : 6;                // [15:10]
        uint32_t rf_ce_pka_reg_length1 : 10; // [25:16]
        uint32_t __31_26 : 6;                // [31:26]
    } b;
} REG_CE_SEC_CE_PKA_REG_LENGTH01_T;

// ce_pka_reg_length23
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_pka_reg_length2 : 10; // [9:0]
        uint32_t __15_10 : 6;                // [15:10]
        uint32_t rf_ce_pka_reg_length3 : 10; // [25:16]
        uint32_t __31_26 : 6;                // [31:26]
    } b;
} REG_CE_SEC_CE_PKA_REG_LENGTH23_T;

// ce_pka_inst_pc
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_pka_inst_pc : 17;            // [16:0], read only
        uint32_t __23_17 : 7;                       // [23:17]
        uint32_t rf_ce_pka_store_done : 1;          // [24], read only
        uint32_t rf_ce_pka_one_cmd_done : 1;        // [25], read only
        uint32_t __26_26 : 1;                       // [26]
        uint32_t rf_ce_pka_find_prime_err_flag : 1; // [27], read only
        uint32_t rf_ce_pka_addsub_co : 1;           // [28], read only
        uint32_t rf_ce_pka_modinv_err : 1;          // [29], read only
        uint32_t rf_ce_pka_infinity_point_flag : 1; // [30], read only
        uint32_t rf_ce_pka_div_zero_err_flag : 1;   // [31], read only
    } b;
} REG_CE_SEC_CE_PKA_INST_PC_T;

// ce_user_flag
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_use_flag : 1;            // [0]
        uint32_t __3_1 : 3;                     // [3:1]
        uint32_t rf_ce_sec_priority_vld : 1;    // [4], read only
        uint32_t __7_5 : 3;                     // [7:5]
        uint32_t rf_ce_pub_priority_vld : 1;    // [8], read only
        uint32_t __15_9 : 7;                    // [15:9]
        uint32_t rf_ce_efuse_double_bit_en : 1; // [16]
        uint32_t __31_17 : 15;                  // [31:17]
    } b;
} REG_CE_SEC_CE_USER_FLAG_T;

// ce_axi_axcache
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_axi_arcache : 4;         // [3:0]
        uint32_t rf_ce_axi_awcache : 4;         // [7:4]
        uint32_t rf_ce_dst_outstanding_num : 4; // [11:8]
        uint32_t rf_ce_src_outstanding_num : 4; // [15:12]
        uint32_t __31_16 : 16;                  // [31:16]
    } b;
} REG_CE_SEC_CE_AXI_AXCACHE_T;

// ce_cmd_stop_ctrl
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_cmd_stop : 1;            // [0]
        uint32_t rf_ce_cmd_stop_status : 1;     // [1], read only
        uint32_t __3_2 : 2;                     // [3:2]
        uint32_t rf_ce_cmd_stop_clear : 1;      // [4], write clear
        uint32_t __7_5 : 3;                     // [7:5]
        uint32_t rf_ce_pka_cmd_stop : 1;        // [8]
        uint32_t rf_ce_pka_cmd_stop_status : 1; // [9], read only
        uint32_t __11_10 : 2;                   // [11:10]
        uint32_t rf_ce_pka_cmd_stop_clear : 1;  // [12], write clear
        uint32_t __31_13 : 19;                  // [31:13]
    } b;
} REG_CE_SEC_CE_CMD_STOP_CTRL_T;

// ce_axi_protect_sel
typedef union {
    uint32_t v;
    struct
    {
        uint32_t sec_axi_prot_sel_en : 1;    // [0]
        uint32_t sec_axi_prot_sel_rkey : 1;  // [1]
        uint32_t sec_axi_prot_sel_rlist : 1; // [2]
        uint32_t sec_axi_prot_sel_rtxt : 1;  // [3]
        uint32_t sec_axi_prot_sel_wtxt : 1;  // [4]
        uint32_t sec_dummy : 3;              // [7:5]
        uint32_t pka_axi_prot_sel_en : 1;    // [8]
        uint32_t pka_axi_prot_sel_cmd : 1;   // [9]
        uint32_t pka_axi_prot_sel_ld : 1;    // [10]
        uint32_t pka_axi_prot_sel_st : 1;    // [11]
        uint32_t pka_dummy : 4;              // [15:12]
        uint32_t __31_16 : 16;               // [31:16]
    } b;
} REG_CE_SEC_CE_AXI_PROTECT_SEL_T;

// ce_rng_en
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_en : 1;                  // [0]
        uint32_t rf_ce_trng_src_en : 1;             // [1], write clear
        uint32_t rf_ce_rng_src_from_cpu_enable : 1; // [2]
        uint32_t rf_ce_rng_rst_from_cpu : 1;        // [3], write clear
        uint32_t rf_ce_trng_ptest_mode_en : 1;      // [4]
        uint32_t __7_5 : 3;                         // [7:5]
        uint32_t rf_rng_src_sel_enable : 8;         // [15:8]
        uint32_t rf_rng_auto_enable : 1;            // [16]
        uint32_t rf_ce_rng_mux_ring_enable : 1;     // [17]
        uint32_t rf_ce_rng_data_mux_enable : 1;     // [18]
        uint32_t __31_19 : 13;                      // [31:19]
    } b;
} REG_CE_SEC_CE_RNG_EN_T;

// ce_rng_config
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_ring_sel : 3;             // [2:0]
        uint32_t rf_ce_rng_trng_sel : 1;             // [3]
        uint32_t rf_ce_rng_data_len_sel : 1;         // [4]
        uint32_t rf_ce_rng_source_sel : 2;           // [6:5]
        uint32_t rf_ce_rng_exotic_fault_rst_sel : 1; // [7]
        uint32_t rf_ce_rng_data_valid_threshold : 4; // [11:8]
        uint32_t __15_12 : 4;                        // [15:12]
        uint32_t rf_ce_rng_ptest_data_in : 1;        // [16]
        uint32_t __19_17 : 3;                        // [19:17]
        uint32_t number_of_samples_threshold : 12;   // [31:20]
    } b;
} REG_CE_SEC_CE_RNG_CONFIG_T;

// ce_rng_sample_period
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_second_sample_period : 16; // [15:0]
        uint32_t rf_ce_rng_first_sample_period : 15;  // [30:16]
        uint32_t rf_ce_rng_first_sample_en : 1;       // [31]
    } b;
} REG_CE_SEC_CE_RNG_SAMPLE_PERIOD_T;

// ce_rng_post_process_en
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_post_first_en : 1;  // [0]
        uint32_t rf_ce_rng_post_second_en : 1; // [1]
        uint32_t rf_ce_rng_post_three_en : 1;  // [2]
        uint32_t rf_ce_rng_post_four_en : 1;   // [3]
        uint32_t rf_ce_rng_post_five_en : 1;   // [4]
        uint32_t rf_ce_rng_post_six_en : 1;    // [5]
        uint32_t rf_ce_rng_post_seven_en : 1;  // [6]
        uint32_t rf_ce_rng_post_eight_en : 1;  // [7]
        uint32_t __31_8 : 24;                  // [31:8]
    } b;
} REG_CE_SEC_CE_RNG_POST_PROCESS_EN_T;

// ce_rng_work_status
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_auto_mode_ongoing : 1;     // [0], read only
        uint32_t rf_ce_rng_data_valid : 1;            // [1], read only
        uint32_t rf_rng_rsa_pka_busy : 1;             // [2], read only
        uint32_t rf_ce_rng_error_fault : 1;           // [3], read only
        uint32_t rf_ce_rng_fifo_empty : 1;            // [4], read only
        uint32_t rf_ce_rng_drbg_test_data_type : 2;   // [6:5], read only
        uint32_t rf_ce_rng_drbg_test_result_vld : 1;  // [7], read only
        uint32_t rf_ce_rng_test_result : 1;           // [8], read only
        uint32_t rf_ce_rng_es_test_done : 1;          // [9], read only
        uint32_t rf_ce_rng_es_test_fail : 1;          // [10], read only
        uint32_t rf_ce_rng_drbg_test_done : 1;        // [11], read only
        uint32_t rf_ce_rng_drbg_test_fail : 1;        // [12], read only
        uint32_t rf_ce_rng_drbg_pattern_req : 1;      // [13], read only
        uint32_t rf_ce_rng_drbg_test_process : 2;     // [15:14], read only
        uint32_t rf_ce_rng_rsa_key_gen_rand_num : 16; // [31:16], read only
    } b;
} REG_CE_SEC_CE_RNG_WORK_STATUS_T;

// ce_rng_int_en
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_process0_int_en : 1;   // [0]
        uint32_t rf_ce_rng_process1_int_en : 1;   // [1]
        uint32_t rf_ce_rng_process2_int_en : 1;   // [2]
        uint32_t rf_ce_rng_timeout_int_en : 1;    // [3]
        uint32_t rf_ce_rng_sram_short_int_en : 1; // [4]
        uint32_t rf_ce_rng_cont_htest_int_en : 1; // [5]
        uint32_t __31_6 : 26;                     // [31:6]
    } b;
} REG_CE_SEC_CE_RNG_INT_EN_T;

// ce_rng_sts
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_process0_int_sts : 1;   // [0], read only
        uint32_t rf_ce_rng_process1_int_sts : 1;   // [1], read only
        uint32_t rf_ce_rng_process2_int_sts : 1;   // [2], read only
        uint32_t rf_ce_rng_timeout_int_sts : 1;    // [3], read only
        uint32_t rf_ce_rng_sram_short_int_sts : 1; // [4], read only
        uint32_t rf_ce_rng_con_htest_int_sts : 1;  // [5], read only
        uint32_t __31_6 : 26;                      // [31:6]
    } b;
} REG_CE_SEC_CE_RNG_STS_T;

// ce_rng_int_clr
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_clear_process0_int : 1;   // [0], write clear
        uint32_t rf_ce_rng_clear_process1_int : 1;   // [1], write clear
        uint32_t rf_ce_rng_clear_process2_int : 1;   // [2], write clear
        uint32_t rf_ce_rng_clear_timeout_int : 1;    // [3], write clear
        uint32_t rf_ce_rng_clear_sram_short_int : 1; // [4], write clear
        uint32_t rf_ce_rng_clear_con_htest_int : 1;  // [5], write clear
        uint32_t __31_6 : 26;                        // [31:6]
    } b;
} REG_CE_SEC_CE_RNG_INT_CLR_T;

// ce_rng_mode
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_mode : 2;  // [1:0]
        uint32_t __7_2 : 6;           // [7:2]
        uint32_t rf_ce_prng_mode : 1; // [8]
        uint32_t __31_9 : 23;         // [31:9]
    } b;
} REG_CE_SEC_CE_RNG_MODE_T;

// ce_prng_seed_update
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_prng_seed_update : 1; // [0], write clear
        uint32_t __31_1 : 31;                // [31:1]
    } b;
} REG_CE_SEC_CE_PRNG_SEED_UPDATE_T;

// ce_rng_bit_rate
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_rng_bit_rate : 16;    // [15:0], read only
        uint32_t rf_rng_gen_bit_cnt : 16; // [31:16], read only
    } b;
} REG_CE_SEC_CE_RNG_BIT_RATE_T;

// ce_rng_sram_data_threshhold
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_sram_valid_threshholdd : 4; // [3:0]
        uint32_t __31_4 : 28;                          // [31:4]
    } b;
} REG_CE_SEC_CE_RNG_SRAM_DATA_THRESHHOLD_T;

// ce_rng_sram_data_residue_num
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_sram_data_residue_num : 4; // [3:0], read only
        uint32_t __31_4 : 28;                         // [31:4]
    } b;
} REG_CE_SEC_CE_RNG_SRAM_DATA_RESIDUE_NUM_T;

// ce_rng_exotic_fault_counter_config
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_exotic_fault_counter_config : 16; // [15:0]
        uint32_t __31_16 : 16;                           // [31:16]
    } b;
} REG_CE_SEC_CE_RNG_EXOTIC_FAULT_COUNTER_CONFIG_T;

// ce_rng_drbg_seed_cnt
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_drbg_seed_cnt : 16; // [15:0]
        uint32_t __31_16 : 16;                 // [31:16]
    } b;
} REG_CE_SEC_CE_RNG_DRBG_SEED_CNT_T;

// ce_rng_health_test_config
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rng_es_test_en : 1;        // [0]
        uint32_t rf_ce_rng_drbg_test_en : 1;      // [1]
        uint32_t rf_ce_rng_long_term_bit_max : 6; // [7:2]
        uint32_t rf_ce_rng_ones_freq_max : 11;    // [18:8]
        uint32_t __31_19 : 13;                    // [31:19]
    } b;
} REG_CE_SEC_CE_RNG_HEALTH_TEST_CONFIG_T;

// ce_secure_key_use_way
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_secure_key2_en : 1;           // [0]
        uint32_t rf_ce_secure_key1_start_raddr : 10; // [10:1]
        uint32_t rf_ce_secure_key2_start_raddr : 10; // [20:11]
        uint32_t rf_ce_secure_key_len : 9;           // [29:21]
        uint32_t rf_ce_secure_key_cpu_access : 1;    // [30]
        uint32_t rf_ce_secure_key_trng_write : 1;    // [31]
    } b;
} REG_CE_SEC_CE_SECURE_KEY_USE_WAY_T;

// ce_huk_key_config
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_write_efs_length : 8; // [7:0]
        uint32_t __15_8 : 8;                 // [15:8]
        uint32_t rf_ce_write_efs_addr : 16;  // [31:16]
    } b;
} REG_CE_SEC_CE_HUK_KEY_CONFIG_T;

// ce_pka_key_config
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_pka_write_efs_start_addr : 10; // [9:0]
        uint32_t __15_10 : 6;                      // [15:10]
        uint32_t rf_pka_write_efs_end_addr : 10;   // [25:16]
        uint32_t __31_26 : 6;                      // [31:26]
    } b;
} REG_CE_SEC_CE_PKA_KEY_CONFIG_T;

// ce_dump_addr_hi
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_rcv_addr_hi : 4;  // [3:0]
        uint32_t rf_ce_dump_addr_hi : 4; // [7:4]
        uint32_t __31_8 : 24;            // [31:8]
    } b;
} REG_CE_SEC_CE_DUMP_ADDR_HI_T;

// ce_pka_store_addr_hi
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_pka_store_addr_hi : 19; // [18:0]
        uint32_t __31_19 : 13;                 // [31:19]
    } b;
} REG_CE_SEC_CE_PKA_STORE_ADDR_HI_T;

// ce_pka_load_addr_hi
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_pka_load_addr_hi : 19; // [18:0]
        uint32_t __31_19 : 13;                // [31:19]
    } b;
} REG_CE_SEC_CE_PKA_LOAD_ADDR_HI_T;

// ce_pka_start
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_pka_start : 1; // [0], write clear
        uint32_t __31_1 : 31;         // [31:1]
    } b;
} REG_CE_SEC_CE_PKA_START_T;

// ce_pka_clear
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_pka_clear : 1; // [0], write clear
        uint32_t __31_1 : 31;         // [31:1]
    } b;
} REG_CE_SEC_CE_PKA_CLEAR_T;

// ce_pka_rng_force_ssb_bit
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_ce_pka_rng_force_ssb_bit : 1; // [0]
        uint32_t __31_1 : 31;                     // [31:1]
    } b;
} REG_CE_SEC_CE_PKA_RNG_FORCE_SSB_BIT_T;

// ce_pka_ctrl_operate_bit
typedef union {
    uint32_t v;
    struct
    {
        uint32_t ce_pka_store_limit_cfg_disable : 1; // [0]
        uint32_t __31_1 : 31;                        // [31:1]
    } b;
} REG_CE_SEC_CE_PKA_CTRL_OPERATE_BIT_T;

// ce_pka_efs_debug_status
typedef union {
    uint32_t v;
    struct
    {
        uint32_t rf_pka_write_efuse_count : 8;           // [7:0], read only
        uint32_t rf_pka_read_efuse_count : 8;            // [15:8], read only
        uint32_t rf_pka_and_huk_access_efuse_status : 4; // [19:16], read only
        uint32_t rf_pka_access_efuse_flag : 4;           // [23:20], read only
        uint32_t __31_24 : 8;                            // [31:24]
    } b;
} REG_CE_SEC_CE_PKA_EFS_DEBUG_STATUS_T;

// ce_debug_dma_status
#define CE_SEC_RF_CE_DMA_MAIN_READ_STATE(n) (((n)&0x1f) << 0)
#define CE_SEC_RF_CE_DMA_PKA_MAIN_READ_STATE(n) (((n)&0x7) << 5)
#define CE_SEC_RF_CE_DMA_MAIN_WRITE_STATE(n) (((n)&0x1f) << 8)
#define CE_SEC_RF_CE_DMA_ERR (1 << 13)
#define CE_SEC_RF_CE_INT_RAW_STATUS_VLD (1 << 14)
#define CE_SEC_RF_CE_CMD_FIFO_NON_EMPTY (1 << 15)
#define CE_SEC_RF_CE_PKA_CMD_FIFO_NON_EMPTY (1 << 16)
#define CE_SEC_RF_CE_DMA_SRC_STATE(n) (((n)&0x1f) << 17)
#define CE_SEC_RF_CE_DMA_DST_STATE(n) (((n)&0x1f) << 22)
#define CE_SEC_RF_CE_BUSY (1 << 28)
#define CE_SEC_RF_CE_ARREADY (1 << 29)
#define CE_SEC_RF_CE_AWREADY (1 << 30)
#define CE_SEC_RF_CE_WREADY (1 << 31)

// ce_debug_aes_status
#define CE_SEC_RF_CE_AES_STATUS(n) (((n)&0xff) << 0)
#define CE_SEC_RF_CE_WDMA_DATA_STATUS(n) (((n)&0x3) << 10)
#define CE_SEC_RF_CE_SM4_STATUS(n) (((n)&0x7) << 12)
#define CE_SEC_RF_CE_RDMA_DATA_STATUS(n) (((n)&0x7) << 15)
#define CE_SEC_RF_CE_FDE_DMA_MAIN_READ_STATE(n) (((n)&0x1f) << 20)
#define CE_SEC_RF_CE_FDE_WDMA_DATA_STATUS(n) (((n)&0x3) << 25)
#define CE_SEC_RF_CE_FDE_RDMA_DATA_STATUS(n) (((n)&0x3) << 27)

// ce_debug_tdes_status
#define CE_SEC_RF_CE_FDE_AES_STATUS(n) (((n)&0xff) << 0)
#define CE_SEC_RF_CE_FDE_DMA_MAIN_WRITE_STATE(n) (((n)&0x1f) << 8)
#define CE_SEC_RF_CE_PKA_DMA_MAIN_WRITE_STATE(n) (((n)&0x7) << 13)
#define CE_SEC_RF_CE_EFUSE_ACCESS_STATUS(n) (((n)&0x1f) << 16)
#define CE_SEC_RF_CE_DMA_WVALID_STATE(n) (((n)&0xf) << 21)
#define CE_SEC_RF_CE_TDES_STATUS(n) (((n)&0x1f) << 25)

// ce_debug_hash_status1
#define CE_SEC_RF_CE_HASH_STATUS1(n) (((n)&0x3ff) << 0)

// ce_clk_en
#define CE_SEC_RF_CE_DMA_CK_EN (1 << 0)
#define CE_SEC_RF_CE_AES_CK_EN (1 << 1)
#define CE_SEC_RF_CE_FDE_AES_CK_EN (1 << 2)
#define CE_SEC_RF_CE_HASH_CK_EN (1 << 3)
#define CE_SEC_RF_CE_DES_CK_EN (1 << 4)
#define CE_SEC_RF_CE_TRNG_CK_EN (1 << 5)
#define CE_SEC_RF_CE_SM4_CK_EN (1 << 6)
#define CE_SEC_RF_CE_CHACAH_POLY_CK_EN (1 << 7)
#define CE_SEC_RF_CE_PKA_CK_EN (1 << 8)
#define CE_SEC_RF_CE_SIMON_SPECK_CK_EN (1 << 9)
#define CE_SEC_RF_CE_APB_RF_CLK_EN (1 << 16)
#define CE_SEC_RF_CE_DMA_CTRL_CLK_EN (1 << 17)
#define CE_SEC_RF_CE_DMA_AXI_CLK_EN (1 << 18)
#define CE_SEC_RF_CE_AES_CLK_EN (1 << 20)
#define CE_SEC_RF_CE_RNG_CLK_EN (1 << 21)
#define CE_SEC_RF_CE_POLY_CLK_EN (1 << 22)
#define CE_SEC_RF_CE_CHACHA_CLK_EN (1 << 23)
#define CE_SEC_RF_CE_TRNG_PUB_CLK_EN (1 << 24)
#define CE_SEC_RF_CE_RNG_PUB_CLK_EN (1 << 25)
#define CE_SEC_RF_CE_FDE_AES_CLK_EN (1 << 28)

// ce_int_en
#define CE_SEC_RF_CE_EN_CMD_DONE_INT (1 << 0)
#define CE_SEC_RF_CE_EN_EFS_HUK_UNSTABLE_INT (1 << 1)
#define CE_SEC_RF_CE_EN_EFS_ALL_ZERO_INT (1 << 2)
#define CE_SEC_RF_CE_EN_LEN_ERR_INT (1 << 4)
#define CE_SEC_RF_CE_EN_TDES_KEY_ERR_INT (1 << 5)
#define CE_SEC_RF_CE_EN_RNG_INT (1 << 7)
#define CE_SEC_RF_CE_EN_PKA_STORE_DONE_INT (1 << 8)
#define CE_SEC_RF_CE_EN_PKA_ONE_CMD_DONE_INT (1 << 9)
#define CE_SEC_RF_CE_EN_USE_EFUSE_ERR_INT (1 << 10)
#define CE_SEC_RF_CE_EN_PKA_DIV_ZERO_ERR_INT (1 << 11)
#define CE_SEC_RF_CE_EN_PKA_FIND_PRIME_ERR_INT (1 << 12)
#define CE_SEC_RF_CE_EN_PKA_CMD_DONE_DONE_INT (1 << 13)
#define CE_SEC_RF_CE_EN_PKA_LEN_ERR_INT (1 << 14)
#define CE_SEC_RF_CE_EN_PKA_WR_EFUSE_KEY_ADDR_INT (1 << 15)
#define CE_SEC_RF_CE_EN_PKA_RD_EFUSE_KEY_ADDR_INT (1 << 16)

// ce_int_status
#define CE_SEC_RF_CE_CMD_DONE_INT_STATUS (1 << 0)
#define CE_SEC_RF_CE_EFS_HUK_UNSTABLE_INT_STATUS (1 << 1)
#define CE_SEC_RF_CE_EFS_ALL_ZERO_INT_STATUS (1 << 2)
#define CE_SEC_RF_CE_LEN_ERR_INT_STATUS (1 << 4)
#define CE_SEC_RF_CE_TDES_KEY_ERR_INT_STATUS (1 << 5)
#define CE_SEC_RF_CE_RNG_INT_STATUS (1 << 7)
#define CE_SEC_RF_CE_PKA_STORE_DONE_FLAG (1 << 8)
#define CE_SEC_RF_CE_PKA_ONE_CMD_DONE_FLAG (1 << 9)
#define CE_SEC_RF_CE_USE_EFUSE_ERR_FLAG (1 << 10)
#define CE_SEC_CE_INT_STATUS_RF_CE_PKA_DIV_ZERO_ERR_FLAG (1 << 11)
#define CE_SEC_CE_INT_STATUS_RF_CE_PKA_FIND_PRIME_ERR_FLAG (1 << 12)
#define CE_SEC_RF_CE_PKA_CMD_DONE_DONE_INT_STATUS (1 << 13)
#define CE_SEC_RF_CE_PKA_LEN_ERR_INT_STATUS (1 << 14)
#define CE_SEC_RF_CE_PKA_WR_EFUSE_KEY_ADDR_INT_STATUS (1 << 15)
#define CE_SEC_RF_CE_PKA_RD_EFUSE_KEY_ADDR_INT_STATUS (1 << 16)

// ce_int_clear
#define CE_SEC_RF_CE_CLEAR_CMD_DONE_INT (1 << 0)
#define CE_SEC_RF_CE_CLEAR_EFS_HUK_UNSTABLE_INT (1 << 1)
#define CE_SEC_RF_CE_CLEAR_EFS_ALL_ZERO_INT (1 << 2)
#define CE_SEC_RF_CE_CLEAR_LEN_ERR_INT (1 << 4)
#define CE_SEC_RF_CE_CLEAR_TDES_KEY_ERR_INT (1 << 5)
#define CE_SEC_RF_CE_CLEAR_PKA_STORE_DONE_INT (1 << 8)
#define CE_SEC_RF_CE_CLEAR_PKA_ONE_CMD_DONE_INT (1 << 9)
#define CE_SEC_RF_CE_CLEAR_USE_EFUSE_ERR_INT (1 << 10)
#define CE_SEC_RF_CE_CLEAR_PKA_DIV_ZERO_ERR_INT (1 << 11)
#define CE_SEC_RF_CE_CLEAR_PKA_FIND_PRIME_ERR_INT (1 << 12)
#define CE_SEC_RF_CE_CLEAR_PKA_CMD_DONE_DONE_INT (1 << 13)
#define CE_SEC_RF_CE_CLEAR_PKA_LEN_ERR_INT (1 << 14)
#define CE_SEC_RF_CE_CLEAR_PKA_WR_EFUSE_KEY_ADDR_INT (1 << 15)
#define CE_SEC_RF_CE_CLEAR_PKA_RD_EFUSE_KEY_ADDR_INT (1 << 16)

// ce_start
#define CE_SEC_RF_CE_START (1 << 0)

// ce_clear
#define CE_SEC_RF_CE_CLEAR (1 << 0)

// ce_aes_mode
#define CE_SEC_RF_CE_AES_EN (1 << 0)
#define CE_SEC_RF_CE_AES_ENC_DEC_SEL (1 << 4)
#define CE_SEC_RF_CE_AES_MAC_CTR_INC_MODE(n) (((n)&0x3) << 5)
#define CE_SEC_RF_CE_AES_WORK_MODE(n) (((n)&0xf) << 8)
#define CE_SEC_RF_CE_AES_KEY_LEN_SEL(n) (((n)&0x3) << 12)
#define CE_SEC_RF_CE_AES_XTS_IV_ROTATION (1 << 14)
#define CE_SEC_RF_CE_AES_KEY_UPDATE_N (1 << 15)

// ce_tdes_mode
#define CE_SEC_RF_CE_TDES_EN (1 << 0)
#define CE_SEC_RF_CE_TDES_ENC_DEC_SEL (1 << 4)
#define CE_SEC_RF_CE_TDES_WORK_MODE(n) (((n)&0x3) << 8)
#define CE_SEC_RF_CE_TDES_KEY_EVEN_SEL (1 << 12)
#define CE_SEC_RF_CE_TDES_KEY_EVENODD_CHECK_ON (1 << 13)

// ce_hash_mode
#define CE_SEC_RF_CE_HASH_EN (1 << 0)
#define CE_SEC_RF_CE_HASH_MODE(n) (((n)&0x1f) << 4)
#define CE_SEC_RF_HASH_HMAC_PAD_SEL(n) (((n)&0x3) << 12)
#define CE_SEC_RF_HASH_SHA3_SHAKE_OUT_LEN(n) (((n)&0xff) << 16)

// ce_chacha_poly_mode
#define CE_SEC_RF_CE_CHACHA_POLY_EN (1 << 0)
#define CE_SEC_RF_CE_CHACHA_POLY_ENC_DEC_SEL (1 << 4)
#define CE_SEC_RF_CE_CHACHA_POLY_MODE(n) (((n)&0x3) << 8)

// ce_simon_speck_mode
#define CE_SEC_RF_CE_SIMON_SPECK_EN (1 << 0)
#define CE_SEC_RF_CE_SIMON_SPECK_ENC_DEC_SEL (1 << 4)
#define CE_SEC_RF_CE_SIMON_SPECK_SEL (1 << 8)
#define CE_SEC_RF_CE_SIMON_SPECK_WORK_MODE(n) (((n)&0x7) << 9)
#define CE_SEC_RF_CE_SIMON_SPECK_KEY_LEN_SEL(n) (((n)&0x3) << 13)
#define CE_SEC_RF_CE_SIMON_SPECK_KEY_UPDATE_N (1 << 15)

// ce_cfg
#define CE_SEC_RF_CE_LINK_MODE_FLAG (1 << 0)
#define CE_SEC_RF_CE_DONT_RCV_DDR (1 << 1)
#define CE_SEC_RF_CE_DONT_DUMP_DDR (1 << 2)
#define CE_SEC_RF_CE_CMD_IOC (1 << 3)
#define CE_SEC_RF_CE_STD_MODE_END_FLAG (1 << 4)
#define CE_SEC_RF_CE_STD_MODE_AAD_END_FLAG (1 << 5)
#define CE_SEC_RF_CE_STD_MODE_AAD_FLAG (1 << 6)
#define CE_SEC_RF_CE_DMA_BYPASS (1 << 7)
#define CE_SEC_RF_CE_KEY_IN_DDR_FLAG (1 << 8)
#define CE_SEC_RF_CE_KEY_IN_EFUSE_FLAG (1 << 9)
#define CE_SEC_RF_CE_KEY_IN_SESSION_KEY_FLAG (1 << 10)
#define CE_SEC_RF_CE_KEY_IN_IRAM_FLAG (1 << 11)
#define CE_SEC_RF_CE_DO_WAIT_BDONE (1 << 12)
#define CE_SEC_RF_CE_LIST_AAD_END_FLAG (1 << 13)
#define CE_SEC_RF_CE_LIST_AAD_FLAG (1 << 14)
#define CE_SEC_RF_CE_LIST_END_FLAG (1 << 15)
#define CE_SEC_RF_CE_LIST_DATA_END_FLAG (1 << 16)
#define CE_SEC_RF_CE_LIST_UPDATE_IV_SEC_CNT (1 << 17)
#define CE_SEC_RF_CE_KEY_HDCP_EN (1 << 18)
#define CE_SEC_RF_CE_DST_BYTE_SWITCH (1 << 20)
#define CE_SEC_RF_CE_SRC_BYTE_SWITCH (1 << 21)
#define CE_SEC_RF_CE_DST_WORD_SWITCH (1 << 22)
#define CE_SEC_RF_CE_SRC_WORD_SWITCH (1 << 23)

// ce_src_frag_length
#define CE_SEC_RF_CE_SRC_FRAG_LEN(n) (((n)&0xffffff) << 0)
#define CE_SEC_RF_CE_SRC_ADDR_HI(n) (((n)&0xf) << 24)

// ce_dst_frag_length
#define CE_SEC_RF_CE_DST_FRAG_LEN(n) (((n)&0xffffff) << 0)
#define CE_SEC_RF_CE_DST_ADDR_HI(n) (((n)&0xf) << 24)

// ce_list_length
#define CE_SEC_RF_CE_LIST_LEN(n) (((n)&0xfff) << 0)
#define CE_SEC_RF_CE_LIST_PTR_HI(n) (((n)&0xf) << 16)

// ce_aes_tdes_rsa_key_length
#define CE_SEC_RF_CE_AES_TDES_RSA_KEY_LEN(n) (((n)&0xffffff) << 0)
#define CE_SEC_RF_CE_AES_TDES_RSA_KEY_ADDR_HI(n) (((n)&0xf) << 24)

// ce_aes_tag_length
#define CE_SEC_RF_CE_AES_TAG_LEN(n) (((n)&0xff) << 0)
#define CE_SEC_RF_CE_AES_TAG_ADDR_HI(n) (((n)&0xf) << 8)

// ce_sm4_mode
#define CE_SEC_RF_CE_SM4_EN (1 << 0)
#define CE_SEC_RF_CE_SM4_ENC_DEC_SEL (1 << 4)
#define CE_SEC_RF_CE_SM4_WORK_MODE(n) (((n)&0x7) << 8)
#define CE_SEC_RF_CE_SM4_XTS_INV_ROTATION (1 << 11)
#define CE_SEC_RF_CE_SM4_KEY_UPDATE_N (1 << 12)

// ce_ip_version
#define CE_SEC_RF_CE_IP_VERSION_LO(n) (((n)&0xf) << 0)
#define CE_SEC_RF_CE_IP_VERSION_HI(n) (((n)&0xfffffff) << 4)

// ce_pka_mode
#define CE_SEC_RF_CE_PKA_EN (1 << 0)
#define CE_SEC_RF_CE_PKA_REG_NUM_SEL (1 << 1)
#define CE_SEC_RF_CE_PKA_FIND_PRIME_NUM(n) (((n)&0xff) << 16)
#define CE_SEC_RF_CE_PKA_DST_BYTE_SWITCH (1 << 24)
#define CE_SEC_RF_CE_PKA_SRC_BYTE_SWITCH (1 << 25)
#define CE_SEC_RF_CE_PKA_DST_WORD_SWITCH (1 << 26)
#define CE_SEC_RF_CE_PKA_SRC_WORD_SWITCH (1 << 27)
#define CE_SEC_RF_CE_PKA_CMD_ADDR_HI(n) (((n)&0xf) << 28)

// ce_pka_reg_length01
#define CE_SEC_RF_CE_PKA_REG_LENGTH0(n) (((n)&0x3ff) << 0)
#define CE_SEC_RF_CE_PKA_REG_LENGTH1(n) (((n)&0x3ff) << 16)

// ce_pka_reg_length23
#define CE_SEC_RF_CE_PKA_REG_LENGTH2(n) (((n)&0x3ff) << 0)
#define CE_SEC_RF_CE_PKA_REG_LENGTH3(n) (((n)&0x3ff) << 16)

// ce_pka_inst_pc
#define CE_SEC_RF_CE_PKA_INST_PC(n) (((n)&0x1ffff) << 0)
#define CE_SEC_RF_CE_PKA_STORE_DONE (1 << 24)
#define CE_SEC_RF_CE_PKA_ONE_CMD_DONE (1 << 25)
#define CE_SEC_CE_PKA_INST_PC_RF_CE_PKA_FIND_PRIME_ERR_FLAG (1 << 27)
#define CE_SEC_RF_CE_PKA_ADDSUB_CO (1 << 28)
#define CE_SEC_RF_CE_PKA_MODINV_ERR (1 << 29)
#define CE_SEC_RF_CE_PKA_INFINITY_POINT_FLAG (1 << 30)
#define CE_SEC_CE_PKA_INST_PC_RF_CE_PKA_DIV_ZERO_ERR_FLAG (1 << 31)

// ce_user_flag
#define CE_SEC_RF_CE_USE_FLAG (1 << 0)
#define CE_SEC_RF_CE_SEC_PRIORITY_VLD (1 << 4)
#define CE_SEC_RF_CE_PUB_PRIORITY_VLD (1 << 8)
#define CE_SEC_RF_CE_EFUSE_DOUBLE_BIT_EN (1 << 16)

// ce_axi_axcache
#define CE_SEC_RF_CE_AXI_ARCACHE(n) (((n)&0xf) << 0)
#define CE_SEC_RF_CE_AXI_AWCACHE(n) (((n)&0xf) << 4)
#define CE_SEC_RF_CE_DST_OUTSTANDING_NUM(n) (((n)&0xf) << 8)
#define CE_SEC_RF_CE_SRC_OUTSTANDING_NUM(n) (((n)&0xf) << 12)

// ce_cmd_stop_ctrl
#define CE_SEC_RF_CE_CMD_STOP (1 << 0)
#define CE_SEC_RF_CE_CMD_STOP_STATUS (1 << 1)
#define CE_SEC_RF_CE_CMD_STOP_CLEAR (1 << 4)
#define CE_SEC_RF_CE_PKA_CMD_STOP (1 << 8)
#define CE_SEC_RF_CE_PKA_CMD_STOP_STATUS (1 << 9)
#define CE_SEC_RF_CE_PKA_CMD_STOP_CLEAR (1 << 12)

// ce_axi_protect_sel
#define CE_SEC_SEC_AXI_PROT_SEL_EN (1 << 0)
#define CE_SEC_SEC_AXI_PROT_SEL_RKEY (1 << 1)
#define CE_SEC_SEC_AXI_PROT_SEL_RLIST (1 << 2)
#define CE_SEC_SEC_AXI_PROT_SEL_RTXT (1 << 3)
#define CE_SEC_SEC_AXI_PROT_SEL_WTXT (1 << 4)
#define CE_SEC_SEC_DUMMY(n) (((n)&0x7) << 5)
#define CE_SEC_PKA_AXI_PROT_SEL_EN (1 << 8)
#define CE_SEC_PKA_AXI_PROT_SEL_CMD (1 << 9)
#define CE_SEC_PKA_AXI_PROT_SEL_LD (1 << 10)
#define CE_SEC_PKA_AXI_PROT_SEL_ST (1 << 11)
#define CE_SEC_PKA_DUMMY(n) (((n)&0xf) << 12)

// ce_rng_en
#define CE_SEC_RF_CE_RNG_EN (1 << 0)
#define CE_SEC_RF_CE_TRNG_SRC_EN (1 << 1)
#define CE_SEC_RF_CE_RNG_SRC_FROM_CPU_ENABLE (1 << 2)
#define CE_SEC_RF_CE_RNG_RST_FROM_CPU (1 << 3)
#define CE_SEC_RF_CE_TRNG_PTEST_MODE_EN (1 << 4)
#define CE_SEC_RF_RNG_SRC_SEL_ENABLE(n) (((n)&0xff) << 8)
#define CE_SEC_RF_RNG_AUTO_ENABLE (1 << 16)
#define CE_SEC_RF_CE_RNG_MUX_RING_ENABLE (1 << 17)
#define CE_SEC_RF_CE_RNG_DATA_MUX_ENABLE (1 << 18)

// ce_rng_config
#define CE_SEC_RF_CE_RNG_RING_SEL(n) (((n)&0x7) << 0)
#define CE_SEC_RF_CE_RNG_TRNG_SEL (1 << 3)
#define CE_SEC_RF_CE_RNG_DATA_LEN_SEL (1 << 4)
#define CE_SEC_RF_CE_RNG_SOURCE_SEL(n) (((n)&0x3) << 5)
#define CE_SEC_RF_CE_RNG_EXOTIC_FAULT_RST_SEL (1 << 7)
#define CE_SEC_RF_CE_RNG_DATA_VALID_THRESHOLD(n) (((n)&0xf) << 8)
#define CE_SEC_RF_CE_RNG_PTEST_DATA_IN (1 << 16)
#define CE_SEC_NUMBER_OF_SAMPLES_THRESHOLD(n) (((n)&0xfff) << 20)

// ce_rng_sample_period
#define CE_SEC_RF_CE_RNG_SECOND_SAMPLE_PERIOD(n) (((n)&0xffff) << 0)
#define CE_SEC_RF_CE_RNG_FIRST_SAMPLE_PERIOD(n) (((n)&0x7fff) << 16)
#define CE_SEC_RF_CE_RNG_FIRST_SAMPLE_EN (1 << 31)

// ce_rng_post_process_en
#define CE_SEC_RF_CE_RNG_POST_FIRST_EN (1 << 0)
#define CE_SEC_RF_CE_RNG_POST_SECOND_EN (1 << 1)
#define CE_SEC_RF_CE_RNG_POST_THREE_EN (1 << 2)
#define CE_SEC_RF_CE_RNG_POST_FOUR_EN (1 << 3)
#define CE_SEC_RF_CE_RNG_POST_FIVE_EN (1 << 4)
#define CE_SEC_RF_CE_RNG_POST_SIX_EN (1 << 5)
#define CE_SEC_RF_CE_RNG_POST_SEVEN_EN (1 << 6)
#define CE_SEC_RF_CE_RNG_POST_EIGHT_EN (1 << 7)

// ce_rng_work_status
#define CE_SEC_RF_CE_RNG_AUTO_MODE_ONGOING (1 << 0)
#define CE_SEC_RF_CE_RNG_DATA_VALID (1 << 1)
#define CE_SEC_RF_RNG_RSA_PKA_BUSY (1 << 2)
#define CE_SEC_RF_CE_RNG_ERROR_FAULT (1 << 3)
#define CE_SEC_RF_CE_RNG_FIFO_EMPTY (1 << 4)
#define CE_SEC_RF_CE_RNG_DRBG_TEST_DATA_TYPE(n) (((n)&0x3) << 5)
#define CE_SEC_RF_CE_RNG_DRBG_TEST_RESULT_VLD (1 << 7)
#define CE_SEC_RF_CE_RNG_TEST_RESULT (1 << 8)
#define CE_SEC_RF_CE_RNG_ES_TEST_DONE (1 << 9)
#define CE_SEC_RF_CE_RNG_ES_TEST_FAIL (1 << 10)
#define CE_SEC_RF_CE_RNG_DRBG_TEST_DONE (1 << 11)
#define CE_SEC_RF_CE_RNG_DRBG_TEST_FAIL (1 << 12)
#define CE_SEC_RF_CE_RNG_DRBG_PATTERN_REQ (1 << 13)
#define CE_SEC_RF_CE_RNG_DRBG_TEST_PROCESS(n) (((n)&0x3) << 14)
#define CE_SEC_RF_CE_RNG_RSA_KEY_GEN_RAND_NUM(n) (((n)&0xffff) << 16)

// ce_rng_int_en
#define CE_SEC_RF_CE_RNG_PROCESS0_INT_EN (1 << 0)
#define CE_SEC_RF_CE_RNG_PROCESS1_INT_EN (1 << 1)
#define CE_SEC_RF_CE_RNG_PROCESS2_INT_EN (1 << 2)
#define CE_SEC_RF_CE_RNG_TIMEOUT_INT_EN (1 << 3)
#define CE_SEC_RF_CE_RNG_SRAM_SHORT_INT_EN (1 << 4)
#define CE_SEC_RF_CE_RNG_CONT_HTEST_INT_EN (1 << 5)

// ce_rng_sts
#define CE_SEC_RF_CE_RNG_PROCESS0_INT_STS (1 << 0)
#define CE_SEC_RF_CE_RNG_PROCESS1_INT_STS (1 << 1)
#define CE_SEC_RF_CE_RNG_PROCESS2_INT_STS (1 << 2)
#define CE_SEC_RF_CE_RNG_TIMEOUT_INT_STS (1 << 3)
#define CE_SEC_RF_CE_RNG_SRAM_SHORT_INT_STS (1 << 4)
#define CE_SEC_RF_CE_RNG_CON_HTEST_INT_STS (1 << 5)

// ce_rng_int_clr
#define CE_SEC_RF_CE_RNG_CLEAR_PROCESS0_INT (1 << 0)
#define CE_SEC_RF_CE_RNG_CLEAR_PROCESS1_INT (1 << 1)
#define CE_SEC_RF_CE_RNG_CLEAR_PROCESS2_INT (1 << 2)
#define CE_SEC_RF_CE_RNG_CLEAR_TIMEOUT_INT (1 << 3)
#define CE_SEC_RF_CE_RNG_CLEAR_SRAM_SHORT_INT (1 << 4)
#define CE_SEC_RF_CE_RNG_CLEAR_CON_HTEST_INT (1 << 5)

// ce_rng_mode
#define CE_SEC_RF_CE_RNG_MODE(n) (((n)&0x3) << 0)
#define CE_SEC_RF_CE_PRNG_MODE (1 << 8)

// ce_prng_seed_update
#define CE_SEC_RF_CE_PRNG_SEED_UPDATE (1 << 0)

// ce_rng_bit_rate
#define CE_SEC_RF_RNG_BIT_RATE(n) (((n)&0xffff) << 0)
#define CE_SEC_RF_RNG_GEN_BIT_CNT(n) (((n)&0xffff) << 16)

// ce_rng_sram_data_threshhold
#define CE_SEC_RF_CE_RNG_SRAM_VALID_THRESHHOLDD(n) (((n)&0xf) << 0)

// ce_rng_sram_data_residue_num
#define CE_SEC_RF_CE_RNG_SRAM_DATA_RESIDUE_NUM(n) (((n)&0xf) << 0)

// ce_rng_exotic_fault_counter_config
#define CE_SEC_RF_CE_EXOTIC_FAULT_COUNTER_CONFIG(n) (((n)&0xffff) << 0)

// ce_rng_drbg_seed_cnt
#define CE_SEC_RF_CE_RNG_DRBG_SEED_CNT(n) (((n)&0xffff) << 0)

// ce_rng_health_test_config
#define CE_SEC_RF_CE_RNG_ES_TEST_EN (1 << 0)
#define CE_SEC_RF_CE_RNG_DRBG_TEST_EN (1 << 1)
#define CE_SEC_RF_CE_RNG_LONG_TERM_BIT_MAX(n) (((n)&0x3f) << 2)
#define CE_SEC_RF_CE_RNG_ONES_FREQ_MAX(n) (((n)&0x7ff) << 8)

// ce_secure_key_use_way
#define CE_SEC_RF_CE_SECURE_KEY2_EN (1 << 0)
#define CE_SEC_RF_CE_SECURE_KEY1_START_RADDR(n) (((n)&0x3ff) << 1)
#define CE_SEC_RF_CE_SECURE_KEY2_START_RADDR(n) (((n)&0x3ff) << 11)
#define CE_SEC_RF_CE_SECURE_KEY_LEN(n) (((n)&0x1ff) << 21)
#define CE_SEC_RF_CE_SECURE_KEY_CPU_ACCESS (1 << 30)
#define CE_SEC_RF_CE_SECURE_KEY_TRNG_WRITE (1 << 31)

// ce_huk_key_config
#define CE_SEC_RF_CE_WRITE_EFS_LENGTH(n) (((n)&0xff) << 0)
#define CE_SEC_RF_CE_WRITE_EFS_ADDR(n) (((n)&0xffff) << 16)

// ce_pka_key_config
#define CE_SEC_RF_PKA_WRITE_EFS_START_ADDR(n) (((n)&0x3ff) << 0)
#define CE_SEC_RF_PKA_WRITE_EFS_END_ADDR(n) (((n)&0x3ff) << 16)

// ce_dump_addr_hi
#define CE_SEC_RF_CE_RCV_ADDR_HI(n) (((n)&0xf) << 0)
#define CE_SEC_RF_CE_DUMP_ADDR_HI(n) (((n)&0xf) << 4)

// ce_pka_store_addr_hi
#define CE_SEC_RF_CE_PKA_STORE_ADDR_HI(n) (((n)&0x7ffff) << 0)

// ce_pka_load_addr_hi
#define CE_SEC_RF_CE_PKA_LOAD_ADDR_HI(n) (((n)&0x7ffff) << 0)

// ce_pka_start
#define CE_SEC_RF_CE_PKA_START (1 << 0)

// ce_pka_clear
#define CE_SEC_RF_CE_PKA_CLEAR (1 << 0)

// ce_pka_rng_force_ssb_bit
#define CE_SEC_RF_CE_PKA_RNG_FORCE_SSB_BIT (1 << 0)

// ce_pka_ctrl_operate_bit
#define CE_SEC_CE_PKA_STORE_LIMIT_CFG_DISABLE (1 << 0)

// ce_pka_efs_debug_status
#define CE_SEC_RF_PKA_WRITE_EFUSE_COUNT(n) (((n)&0xff) << 0)
#define CE_SEC_RF_PKA_READ_EFUSE_COUNT(n) (((n)&0xff) << 8)
#define CE_SEC_RF_PKA_AND_HUK_ACCESS_EFUSE_STATUS(n) (((n)&0xf) << 16)
#define CE_SEC_RF_PKA_ACCESS_EFUSE_FLAG(n) (((n)&0xf) << 20)

#endif // _CE_SEC_H_
