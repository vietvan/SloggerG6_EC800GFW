<?xml version="1.0" ?>
<bigarchive>
  <archive relative="globals.xml">
    <var name="SYS_IRQ_ID_AP_IMEM" value="0"/>
    <var name="SYS_IRQ_ID_SPIFLASH1" value="1"/>
    <var name="SYS_IRQ_ID_SPIFLASH2" value="2"/>
    <var name="SYS_IRQ_ID_GOUDA" value="3"/>
    <var name="SYS_IRQ_ID_AP_AXIDMA" value="4"/>
    <var name="SYS_IRQ_ID_AP_AXIDMA_SECURITY" value="5"/>
    <var name="SYS_IRQ_ID_AP_AXIDMA_UNSECURITY" value="6"/>
    <var name="SYS_IRQ_ID_USBC" value="7"/>
    <var name="SYS_IRQ_ID_MED" value="8"/>
    <var name="SYS_IRQ_ID_CE_PUB" value="9"/>
    <var name="SYS_IRQ_ID_CE_SEC" value="10"/>
    <var name="SYS_IRQ_ID_UART4" value="11"/>
    <var name="SYS_IRQ_ID_UART5" value="12"/>
    <var name="SYS_IRQ_ID_UART6" value="13"/>
    <var name="SYS_IRQ_ID_SPI1" value="14"/>
    <var name="SYS_IRQ_ID_SDMMC" value="15"/>
    <var name="SYS_IRQ_ID_CAMERA" value="16"/>
    <var name="SYS_IRQ_ID_LZMA" value="17"/>
    <var name="SYS_IRQ_ID_AP_BUSMON" value="18"/>
    <var name="SYS_IRQ_ID_EMMC" value="19"/>
    <var name="SYS_IRQ_ID_TIMER1" value="20"/>
    <var name="SYS_IRQ_ID_TIMER1_OS" value="21"/>
    <var name="SYS_IRQ_ID_TIMER2" value="22"/>
    <var name="SYS_IRQ_ID_TIMER2_OS" value="23"/>
    <var name="SYS_IRQ_ID_I2C1" value="24"/>
    <var name="SYS_IRQ_ID_I2C2" value="25"/>
    <var name="SYS_IRQ_ID_GPT3_0" value="26"/>
    <var name="SYS_IRQ_ID_GPT3_1" value="27"/>
    <var name="SYS_IRQ_ID_GPT3_2" value="28"/>
    <var name="SYS_IRQ_ID_GPT3_3" value="29"/>
    <var name="SYS_IRQ_ID_GPT3_4" value="30"/>
    <var name="SYS_IRQ_ID_GPT3_5" value="31"/>
    <var name="SYS_IRQ_ID_GPT3_6" value="32"/>
    <var name="SYS_IRQ_ID_PMU_APCPU" value="33"/>
    <var name="SYS_IRQ_ID_CLK_MNT32K" value="34"/>
    <var name="SYS_IRQ_ID_CLK_MNT26M" value="35"/>
    <var name="SYS_IRQ_ID_SFW_AP_IFC" value="36"/>
    <var name="SYS_IRQ_ID_SFW_AP_AHB" value="37"/>
    <var name="SYS_IRQ_ID_MFW_AP_IMEM" value="38"/>
    <var name="SYS_IRQ_ID_MFW_SPIFLASH1" value="39"/>
    <var name="SYS_IRQ_ID_MFW_SPIFLASH2" value="40"/>
    <var name="SYS_IRQ_ID_AP_WD_RST" value="41"/>
    <var name="SYS_IRQ_ID_AP_TZPC_RST" value="42"/>
    <var name="SYS_IRQ_ID_ADIMST" value="43"/>
    <var name="SYS_IRQ_ID_IDLE_LPS" value="44"/>
    <var name="SYS_IRQ_ID_GPIO1" value="45"/>
    <var name="SYS_IRQ_ID_KEYPAD" value="46"/>
    <var name="SYS_IRQ_ID_GPT1" value="47"/>
    <var name="SYS_IRQ_ID_GPIO2" value="48"/>
    <var name="SYS_IRQ_ID_I2C3" value="49"/>
    <var name="SYS_IRQ_ID_MAILBOX_ARM_AP" value="50"/>
    <var name="SYS_IRQ_ID_AUD_2AD" value="51"/>
    <var name="SYS_IRQ_ID_GPT2_0" value="52"/>
    <var name="SYS_IRQ_ID_GPT2_1" value="53"/>
    <var name="SYS_IRQ_ID_GPT2_2" value="54"/>
    <var name="SYS_IRQ_ID_UART1" value="55"/>
    <var name="SYS_IRQ_ID_UART2" value="56"/>
    <var name="SYS_IRQ_ID_UART3" value="57"/>
    <var name="SYS_IRQ_ID_SPI2" value="58"/>
    <var name="SYS_IRQ_ID_DEBUG_UART" value="59"/>
    <var name="SYS_IRQ_ID_DEBUG_HOST" value="60"/>
    <var name="SYS_IRQ_ID_AIF_IFC0" value="61"/>
    <var name="SYS_IRQ_ID_AIF_IFC1" value="62"/>
    <var name="SYS_IRQ_ID_SFW_LPS_IFC" value="63"/>
    <var name="SYS_IRQ_ID_SFW_AON_IFC" value="64"/>
    <var name="SYS_IRQ_ID_SFW_AON_AHB" value="65"/>
    <var name="SYS_IRQ_ID_MFW_AON_IMEM_INT" value="66"/>
    <var name="SYS_IRQ_ID_MSTFLT_AON_CP" value="67"/>
    <var name="SYS_IRQ_ID_MSTFLT_AON_RF" value="68"/>
    <var name="SYS_IRQ_ID_CP_IDLE_H" value="69"/>
    <var name="SYS_IRQ_ID_CP_IDLE2_H" value="70"/>
    <var name="SYS_IRQ_ID_LTEM1_FRAME" value="71"/>
    <var name="SYS_IRQ_ID_LTEM2_FRAME" value="72"/>
    <var name="SYS_IRQ_ID_LTEM3_FRAME" value="73"/>
    <var name="SYS_IRQ_ID_RC26M_CALIB" value="74"/>
    <var name="SYS_IRQ_ID_PWRCTRL" value="75"/>
    <var name="SYS_IRQ_ID_PMIC" value="76"/>
    <var name="SYS_IRQ_ID_MFW_AON_IMEM_RST" value="77"/>
    <var name="SYS_IRQ_ID_RTC_TIMER" value="78"/>
    <var name="SYS_IRQ_ID_CP_IRQ" value="79"/>
    <var name="SYS_IRQ_ID_CP_FIQ" value="80"/>
    <var name="SYS_IRQ_ID_CP_BUSMON" value="81"/>
    <var name="SYS_IRQ_ID_CP_WD_RST" value="82"/>
    <var name="SYS_IRQ_ID_FREQ_BIAS" value="83"/>
    <var name="SYS_IRQ_ID_CP_WIFI" value="84"/>
    <var name="SYS_IRQ_ID_PPS" value="85"/>
    <var name="SYS_IRQ_ID_RFT_TOP" value="86"/>
    <var name="SYS_IRQ_ID_GNSS_BB" value="87"/>
    <var name="SYS_IRQ_ID_GNSS_BB_EXCEPT" value="88"/>
    <var name="SYS_IRQ_ID_GNSS_NOMASK_NEXT_MEASINT" value="89"/>
    <var name="SYS_IRQ_ID_RF_WD_RST" value="90"/>
    <var name="SYS_IRQ_ID_DMC" value="91"/>
    <var name="SYS_IRQ_ID_PAGE_SPY" value="92"/>
    <var name="SYS_IRQ_ID_MFW_PUB_INT" value="93"/>
    <var name="SYS_IRQ_ID_MFW_PUB_RST" value="94"/>
    <var name="SYS_IRQ_ID_TIMER5" value="95"/>
    <var name="SYS_IRQ_ID_TIMER5_OS" value="96"/>
    <var name="NB_SYS_IRQ" value="97"/>
    <var name="NB_BITS_ADDR" value="32"/>
  </archive>
  <archive relative="sys_ctrl.xml">
    <module category="System" name="SYS_CTRL">
      <reg name="aon_soft_rst_ctrl0" protect="rw">
        <comment>AON_SOFT_RST_CTRL0</comment>
        <bits access="rw" name="scc_soft_rst" pos="29" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="usbphy_soft_rst" pos="28" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="ana_wrap2_soft_rst" pos="27" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="ana_wrap1_soft_rst" pos="26" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aon_imem_soft_rst" pos="25" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="iomux_soft_rst" pos="24" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="spi2_soft_rst" pos="23" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="sysmail_soft_rst" pos="22" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="mon_ctrl_soft_rst" pos="21" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="i2c3_soft_rst" pos="20" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="gpt2_soft_rst" pos="19" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="gpio2_soft_rst" pos="18" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aud_2ad_soft_rst" pos="17" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="idle_timer_soft_rst" pos="16" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="uart3_soft_rst" pos="15" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="uart2_soft_rst" pos="14" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aif_soft_rst" pos="13" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="dbg_host_soft_rst" pos="12" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aon_ifc_soft_rst" pos="11" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="spinlock_soft_rst" pos="10" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="adimst_soft_rst" pos="9" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="lps2aon_soft_rst" pos="8" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aon2lps_soft_rst" pos="7" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="lps_ifc_soft_rst" pos="6" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="efuse_soft_rst" pos="5" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="djtag_ctrl_soft_rst" pos="4" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="dap_soft_rst" pos="3" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="async_bridge_soft_rst" pos="2" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="ahb2axi_soft_rst" pos="1" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="ahbmux_soft_rst" pos="0" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
      </reg>
      <reg name="clken_lte" protect="rw">
        <comment>CLKEN_LTE</comment>
        <bits access="rw" name="dbgio_func_en" pos="14" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="hsdl_func_en" pos="13" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="rxcapt_func_en" pos="12" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="rfad_func_en" pos="11" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="dlfft_func_en" pos="10" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="csirs_func_en" pos="9" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="pusch_func_en" pos="8" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="uldft_func_en" pos="7" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="otdoa_func_en" pos="6" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="iddet_func_en" pos="5" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="measpwr_func_en" pos="4" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="ldtc1_func_en" pos="3" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="ldtc_func_en" pos="2" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="coeff_func_en" pos="1" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="txrx_func_en" pos="0" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="clken_lte_intf" protect="rw">
        <comment>CLKEN_LTE_INTF</comment>
        <bits access="rw" name="dbgio_intf_en" pos="14" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="hsdl_intf_en" pos="13" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="rxcapt_intf_en" pos="12" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="rfad_intf_en" pos="11" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="dlfft_intf_en" pos="10" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="csirs_intf_en" pos="9" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="pusch_intf_en" pos="8" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="uldft_intf_en" pos="7" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="otdoa_intf_en" pos="6" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="iddet_intf_en" pos="5" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="measpwr_intf_en" pos="4" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="ldtc1_intf_en" pos="3" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="ldtc_intf_en" pos="2" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="coeff_intf_en" pos="1" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="txrx_intf_en" pos="0" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="rstctrl_lte" protect="rw">
        <comment>RSTCTRL_LTE</comment>
        <bits access="rw" name="dbgio_soft_rst" pos="15" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="hsdl_soft_rst" pos="14" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="rxcapt_soft_rst" pos="13" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="rfad_soft_rst" pos="12" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="dlfft_soft_rst" pos="11" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="csirs_soft_rst" pos="10" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="pusch_soft_rst" pos="9" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="uldft_soft_rst" pos="8" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="otdoa_soft_rst" pos="7" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="iddet_soft_rst" pos="6" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="measpwr_soft_rst" pos="5" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="ldtc1_soft_rst" pos="4" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="ldtc_soft_rst" pos="3" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="coeff_soft_rst" pos="2" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="txrx_rx_soft_rst" pos="1" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="txrx_tx_soft_rst" pos="0" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
      </reg>
      <reg name="lte_autogate_mode" protect="rw">
        <comment>LTE_AUTOGATE_MODE</comment>
        <bits access="rw" name="lte_autogate_mode" pos="0" rst="0x0">
          <comment>0: LTE module clock auto gating individual
1: LTE modules invide into two parties : &quot;uplink&quot; and &quot;downlink&quot;, and auto gating individual</comment>
        </bits>
      </reg>
      <reg name="lte_autogate_en" protect="rw">
        <comment>LTE_AUTOGATE_EN</comment>
        <bits access="rw" name="uplink_intf_autogate_en" pos="27" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="downlink_intf_autogate_en" pos="26" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uplink_func_autogate_en" pos="25" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="downlink_func_autogate_en" pos="24" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dlfft_intf_autogate_en" pos="21" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="csirs_intf_autogate_en" pos="20" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pusch_intf_autogate_en" pos="19" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uldft_intf_autogate_en" pos="18" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="otdoa_intf_autogate_en" pos="17" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="iddet_intf_autogate_en" pos="16" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="measpwr_intf_autogate_en" pos="15" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ldtc1_intf_autogate_en" pos="14" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ldtc_intf_autogate_en" pos="13" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="coeff_intf_autogate_en" pos="12" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="txrx_intf_autogate_en" pos="11" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dlfft_func_autogate_en" pos="10" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="csirs_func_autogate_en" pos="9" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pusch_func_autogate_en" pos="8" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uldft_func_autogate_en" pos="7" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="otdoa_func_autogate_en" pos="6" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="iddet_func_autogate_en" pos="5" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="measpwr_func_autogate_en" pos="4" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ldtc1_func_autogate_en" pos="3" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ldtc_func_autogate_en" pos="2" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="coeff_func_autogate_en" pos="1" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="txrx_func_autogate_en" pos="0" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="lte_autogate_delay_num" protect="rw">
        <comment>LTE_AUTOGATE_DELAY_NUM</comment>
        <bits access="rw" name="lte_autogate_delay_number" pos="7:0" rst="0x10">
          <comment>When LTE autogating function enable, After module &quot;running&quot; signal was pull down, a counter begin to count from zero.LTE modules clock will be gated when the counter counts to this number value.</comment>
        </bits>
      </reg>
      <reg name="aon_lpc_ctrl" protect="rw">
        <comment>AON_LPC_CTRL</comment>
        <bits access="rw" name="lpc_pd_num" pos="31:16" rst="0x0">
          <comment>waiting time of bus entered low power mode,calculated by bus clock</comment>
        </bits>
        <bits access="rw" name="lpc_pu_num" pos="15:8" rst="0x0">
          <comment>waiting time of bus entered normal power mode,calculated by bus clock</comment>
        </bits>
        <bits access="rw" name="lpc_frc_en" pos="1" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="lpc_en" pos="0" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="aon_clock_en0" protect="rw">
        <comment>AON_CLOCK_EN0</comment>
        <bits access="rw" name="tsx_cal_en" pos="31" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="clock_out_dbg_en" pos="30" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="codec_mclock_en" pos="29" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="djtag_cfg_en" pos="28" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sdio_aon_en" pos="27" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sdio_1x_lte_en" pos="26" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sdio_1x_ap_en" pos="25" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="usb_32k_en" pos="24" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gnss_32k_en" pos="23" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dap_en" pos="22" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="funcdma_en" pos="21" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dbg_host_en" pos="20" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uart3_en" pos="19" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uart2_en" pos="18" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="idle_timer_en" pos="17" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aif_en" pos="16" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="mon_ctrl_en" pos="15" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gpio2_en" pos="14" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="spi2_en" pos="13" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aud2ad_en" pos="12" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gpt2_en" pos="11" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="lpsifc_en" pos="10" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aonifc_en" pos="9" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon2pub_en" pos="8" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="adimst_en" pos="7" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="efuse_ctrl_en" pos="6" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="spinlock_en" pos="5" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_imem_en" pos="4" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="lps2aon_en" pos="3" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon2lps_en" pos="2" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahbmux_en" pos="1" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahb_matrix_en" pos="0" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="aon_clock_en1" protect="rw">
        <comment>AON_CLOCK_EN1</comment>
        <bits access="rw" name="usb_ahb_ap_en" pos="11" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="usb_ahb_usb_en" pos="10" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="scc_en" pos="9" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="fw_aon_en" pos="8" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="calib_rc_en" pos="7" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahb_rf_en" pos="6" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahb_pub_en" pos="5" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahb_cp_en" pos="4" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahb_ap_en" pos="3" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="psram_en" pos="2" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="usb_ref_en" pos="1" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="djtag_tck_en" pos="0" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="aon_clock_auto_sel0" protect="rw">
        <comment>AON_CLOCK_AUTO_SEL0</comment>
      </reg>
      <reg name="aon_clock_auto_sel1" protect="rw">
        <comment>AON_CLOCK_AUTO_SEL1</comment>
      </reg>
      <reg name="aon_clock_auto_sel2" protect="rw">
        <comment>AON_CLOCK_AUTO_SEL2</comment>
      </reg>
      <reg name="aon_clock_auto_sel3" protect="rw">
        <comment>AON_CLOCK_AUTO_SEL3</comment>
      </reg>
      <reg name="aon_clock_force_en0" protect="rw">
        <comment>AON_CLOCK_FORCE_EN0</comment>
      </reg>
      <reg name="aon_clock_force_en1" protect="rw">
        <comment>AON_CLOCK_FORCE_EN1</comment>
      </reg>
      <reg name="aon_clock_force_en2" protect="rw">
        <comment>AON_CLOCK_FORCE_EN2</comment>
      </reg>
      <reg name="aon_clock_force_en3" protect="rw">
        <comment>AON_CLOCK_FORCE_EN3</comment>
      </reg>
      <reg name="aon_soft_rst_ctrl1" protect="rw">
        <comment>AON_SOFT_RST_CTRL1</comment>
        <bits access="rw" name="rc_calib_soft_rst" pos="9" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="emmc_phy_soft_rst" pos="8" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="usb_djtag_soft_rst" pos="7" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="lte_djtag_soft_rst" pos="6" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="pub_djtag_soft_rst" pos="5" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="gnss_djtag_soft_rst" pos="4" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="rf_djtag_soft_rst" pos="3" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="cp_djtag_soft_rst" pos="2" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="ap_djtag_soft_rst" pos="1" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aon_djtag_soft_rst" pos="0" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
      </reg>
      <reg name="mipi_csi_cfg_reg" protect="rw">
        <comment>MIPI_CSI_CFG_REG</comment>
        <bits access="rw" name="lvds_rx_terminal_enable" pos="1" rst="0x0"/>
        <bits access="rw" name="csi_lvds_mode_sel" pos="0" rst="0x0"/>
      </reg>
      <reg name="cfg_clk_uart2" protect="rw">
        <comment>CFG_CLK_UART2</comment>
        <bits access="rw" name="cfg_clk_uart2_update" pos="31" rst="0x0"/>
        <bits access="rw" name="cfg_clk_uart2_demod" pos="29:16" rst="0x7"/>
        <bits access="rw" name="cfg_clk_uart2_num" pos="9:0" rst="0x1"/>
      </reg>
      <reg name="cfg_clk_uart3" protect="rw">
        <comment>CFG_CLK_UART3</comment>
        <bits access="rw" name="cfg_clk_uart3_update" pos="31" rst="0x0"/>
        <bits access="rw" name="cfg_clk_uart3_demod" pos="29:16" rst="0x7"/>
        <bits access="rw" name="cfg_clk_uart3_num" pos="9:0" rst="0x1"/>
      </reg>
      <reg name="cfg_clk_debug_host" protect="rw">
        <comment>CFG_CLK_DEBUG_HOST</comment>
        <bits access="rw" name="cfg_clk_debug_host_update" pos="31" rst="0x0"/>
        <bits access="rw" name="cfg_clk_debug_host_demod" pos="29:16" rst="0x7"/>
        <bits access="rw" name="cfg_clk_debug_host_num" pos="9:0" rst="0x1"/>
      </reg>
      <hole size="32"/>
      <reg name="rc_calib_ctrl" protect="rw">
        <comment>RC_CALIB_CTRL</comment>
        <bits access="rw" name="rc_calib_int_clr" pos="2" rst="0x0">
          <comment>write 1 to clear interrupt. Read data always be &quot;0&quot;.</comment>
        </bits>
        <bits access="rw" name="rc_calib_int_en" pos="1" rst="0x0">
          <comment>0:disable interrupt
1:enable interrupt</comment>
        </bits>
        <bits access="rw" name="rc_calib_en" pos="0" rst="0x0">
          <comment>0:disable
1:enable
write 1 to enable RC caliberation, clear to 0 automatically when caliberation done.</comment>
        </bits>
      </reg>
      <reg name="rc_calib_th_val" protect="rw">
        <comment>RC_CALIB_TH_VAL</comment>
      </reg>
      <reg name="rc_calib_out_val" protect="rw">
        <comment>RC_CALIB_OUT_VAL</comment>
      </reg>
      <reg name="emmc_slice_phy_ctrl" protect="rw">
        <comment>EMMC_SLICE_PHY_CTRL</comment>
        <bits access="rw" name="emmc_lte_slice_en" pos="1" rst="0x0">
          <comment>1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="emmc_module_sel" pos="0" rst="0x0">
          <comment>1:sel lte dbgio
0:sel emmc</comment>
        </bits>
      </reg>
      <reg name="dma_req_ctrl" protect="rw">
        <comment>DMA_REQ_CTRL</comment>
        <bits access="rw" name="spi2_dma_sel" pos="1" rst="0x0">
          <comment>1:sel cp axidma
0:sel ap axidma</comment>
        </bits>
        <bits access="rw" name="busmon_dma_sel" pos="0" rst="0x0">
          <comment>1:sel cp axidma
0:sel ap axidma</comment>
        </bits>
      </reg>
      <reg name="apt_trigger_sel" protect="rw">
        <comment>APT_TRIGGER_SEL</comment>
        <bits access="rw" name="apt_trig_sel" pos="0" rst="0x0">
          <comment>1:sel lte_up_rfctrl[3]
0:sel rf_gpio[9]</comment>
        </bits>
      </reg>
      <reg name="ahb2ahb_ab_funcdma_ctrl" protect="rw">
        <comment>AHB2AHB_AB_FUNCDMA_CTRL</comment>
        <bits access="rw" name="funcdma_bridge_m_endian_sel" pos="14" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_s_endian_sel" pos="13" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_s_valid" pos="12" rst="0x1"/>
        <bits access="rw" name="funcdma_bridge_en" pos="11" rst="0x1"/>
        <bits access="rw" name="funcdma_bridge_bypass" pos="10" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_mode" pos="9" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_timeout_en" pos="8" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_sleep_req" pos="7" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_pause_req" pos="6" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_incr_r_word" pos="5:4" rst="0x3"/>
        <bits access="rw" name="funcdma_bridge_incr_r_half" pos="3:2" rst="0x3"/>
        <bits access="rw" name="funcdma_bridge_incr_r_byte" pos="1:0" rst="0x3"/>
      </reg>
      <reg name="ahb2ahb_ab_funcdma_sts" protect="rw">
        <comment>AHB2AHB_AB_FUNCDMA_STS</comment>
        <bits access="r" name="funcdma_bridge_sts_s_cmdfifo_full" pos="13" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_s_cmdfifo_empty" pos="12" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_s_rfifo_full" pos="11" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_s_rfifo_empty" pos="10" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_s_idle" pos="9" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_cmdfifo_full" pos="8" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_cmdfifo_empty" pos="7" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_rfifo_full" pos="6" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_rfifo_empty" pos="5" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_idle" pos="4" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sleep_ready" pos="3" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_pause_ready" pos="2" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_st" pos="1:0" rst="0x0"/>
      </reg>
      <reg name="ahb2ahb_ab_dap_ctrl" protect="rw">
        <comment>AHB2AHB_AB_DAP_CTRL</comment>
        <bits access="rw" name="dap_bridge_m_endian_sel" pos="14" rst="0x0"/>
        <bits access="rw" name="dap_bridge_s_endian_sel" pos="13" rst="0x0"/>
        <bits access="rw" name="dap_bridge_s_valid" pos="12" rst="0x1"/>
        <bits access="rw" name="dap_bridge_en" pos="11" rst="0x1"/>
        <bits access="rw" name="dap_bridge_bypass" pos="10" rst="0x0"/>
        <bits access="rw" name="dap_bridge_mode" pos="9" rst="0x0"/>
        <bits access="rw" name="dap_bridge_timeout_en" pos="8" rst="0x0"/>
        <bits access="rw" name="dap_bridge_sleep_req" pos="7" rst="0x0"/>
        <bits access="rw" name="dap_bridge_pause_req" pos="6" rst="0x0"/>
        <bits access="rw" name="dap_bridge_incr_r_word" pos="5:4" rst="0x3"/>
        <bits access="rw" name="dap_bridge_incr_r_half" pos="3:2" rst="0x3"/>
        <bits access="rw" name="dap_bridge_incr_r_byte" pos="1:0" rst="0x3"/>
      </reg>
      <reg name="ahb2ahb_ab_dap_sts" protect="rw">
        <comment>AHB2AHB_AB_DAP_STS</comment>
        <bits access="r" name="dap_bridge_sts_s_cmdfifo_full" pos="13" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_s_cmdfifo_empty" pos="12" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_s_rfifo_full" pos="11" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_s_rfifo_empty" pos="10" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_s_idle" pos="9" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_cmdfifo_full" pos="8" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_cmdfifo_empty" pos="7" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_rfifo_full" pos="6" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_rfifo_empty" pos="5" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_idle" pos="4" rst="0x0"/>
        <bits access="r" name="dap_bridge_sleep_ready" pos="3" rst="0x0"/>
        <bits access="r" name="dap_bridge_pause_ready" pos="2" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_st" pos="1:0" rst="0x0"/>
      </reg>
      <reg name="ahb2axi_pub_ctrl" protect="rw">
        <comment>AHB2AXI_PUB_CTRL</comment>
        <bits access="rw" name="ahb2axi_pub_trans_fencing_req" pos="5" rst="0x0"/>
        <bits access="rw" name="ahb2axi_pub_nonbuf_early_reqp_en" pos="4" rst="0x0"/>
        <bits access="rw" name="ahb2axi_pub_slv_disable_req" pos="3" rst="0x0"/>
        <bits access="rw" name="ahb2axi_pub_clk_auto_gate_en" pos="2" rst="0x0"/>
        <bits access="rw" name="ahb2axi_pub_sclk_next_on" pos="1" rst="0x1"/>
        <bits access="rw" name="ahb2axi_pub_mclk_next_on" pos="0" rst="0x1"/>
      </reg>
      <reg name="ahb2axi_pub_sts" protect="rw">
        <comment>AHB2AXI_PUB_STS</comment>
        <bits access="r" name="ahb2axi_pub_mclk_req" pos="3" rst="0x0"/>
        <bits access="r" name="ahb2axi_pub_trans_fencing_ack" pos="2" rst="0x0"/>
        <bits access="r" name="ahb2axi_pub_bus_busy" pos="1" rst="0x0"/>
        <bits access="r" name="ahb2axi_pub_slv_disable_ack" pos="0" rst="0x0"/>
      </reg>
      <reg name="axi2axi_pub_sts_0" protect="rw">
        <comment>AXI2AXI_PUB_STS_0</comment>
        <bits access="r" name="axi2axi_pub_bridge_trans_idle" pos="2" rst="0x0"/>
        <bits access="r" name="axi2axi_pub_pwr_handshk_clk_req" pos="1" rst="0x0"/>
        <bits access="r" name="axi2axi_pub_axi_detector_overflow" pos="0" rst="0x0"/>
      </reg>
      <reg name="axi2axi_pub_sts_1" protect="rw">
        <comment>AXI2AXI_PUB_STS_1</comment>
      </reg>
      <reg name="ahb2ahb_ab_aon2lps_ctrl" protect="rw">
        <comment>AHB2AHB_AB_AON2LPS_CTRL</comment>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_trans_fencing_req" pos="6" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_sclk_auto_gate_en" pos="5" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_mclk_auto_gate_en" pos="4" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_fifo_clr" pos="3" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_sync_mode" pos="2" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_nonbuf_early_resp_en" pos="1" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_slv_disable_req" pos="0" rst="0x0"/>
      </reg>
      <reg name="ahb2ahb_ab_aon2lps_sts" protect="rw">
        <comment>AHB2AHB_AB_AON2LPS_STS</comment>
        <bits access="r" name="ahb2ahb_ab_aon2lps_trans_fencing_ack" pos="5" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_aon2lps_s_bus_busy" pos="4" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_aon2lps_sclk_req" pos="3" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_aon2lps_mclk_req" pos="2" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_aon2lps_m_bus_busy" pos="1" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_aon2lps_slv_disable_ack" pos="0" rst="0x0"/>
      </reg>
      <reg name="ahb2ahb_ab_lps2aon_ctrl" protect="rw">
        <comment>AHB2AHB_AB_LPS2AON_CTRL</comment>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_trans_fencing_req" pos="6" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_sclk_auto_gate_en" pos="5" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_mclk_auto_gate_en" pos="4" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_fifo_clr" pos="3" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_sync_mode" pos="2" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_nonbuf_early_resp_en" pos="1" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_slv_disable_req" pos="0" rst="0x0"/>
      </reg>
      <reg name="ahb2ahb_ab_lps2aon_sts" protect="rw">
        <comment>AHB2AHB_AB_LPS2AON_STS</comment>
        <bits access="r" name="ahb2ahb_ab_lps2aon_trans_fencing_ack" pos="5" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_lps2aon_s_bus_busy" pos="4" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_lps2aon_sclk_req" pos="3" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_lps2aon_mclk_req" pos="2" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_lps2aon_m_bus_busy" pos="1" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_lps2aon_slv_disable_ack" pos="0" rst="0x0"/>
      </reg>
      <reg name="sysctrl_reg0" protect="rw">
        <comment>SYSCTRL_REG0</comment>
        <bits access="rw" name="rf_idle_enable" pos="13" rst="0x0">
          <comment>1: enable rf_dig clock
0: disable rf_dig clock</comment>
        </bits>
        <bits access="rw" name="pmic_26m_en" pos="12" rst="0x0">
          <comment>1: output to PMIC 26M clock enable
0: output to PMIC 26M clock disable</comment>
        </bits>
        <bits access="rw" name="iis_pll_ref_en" pos="11" rst="0x1">
          <comment>1: IIS_PLL reference clock enable
0: IIS_PLL reference clock disable</comment>
        </bits>
        <bits access="rw" name="mpll_ref_en" pos="10" rst="0x1">
          <comment>1: MPLL reference clock enable
0: MPLL reference clock disable</comment>
        </bits>
        <bits access="rw" name="apll_ref_en" pos="9" rst="0x1">
          <comment>1: APLL reference clock enable
0: APLL reference clock disable</comment>
        </bits>
        <bits access="rw" name="aud_sclk_o_pn_sel" pos="8" rst="0x0">
          <comment>1: aud_sclk clock output invert(source from clk_audio)
0: aud_sclk clock output do not invert(source from clk_audio)</comment>
        </bits>
        <bits access="rw" name="usb20_utmi_width_sel" pos="7" rst="0x0">
          <comment>usb20 utmi_width_sel value</comment>
        </bits>
        <bits access="rw" name="usb20_con_testmode" pos="6" rst="0x0">
          <comment>usb20 con testmode value</comment>
        </bits>
        <bits access="rw" name="usb20_iddig" pos="5" rst="0x1">
          <comment>usb20 iddig value</comment>
        </bits>
        <bits access="rw" name="usb20_vbus_valid_sel" pos="4" rst="0x0">
          <comment>1: sel usbphy signal to controller;
0: sel sysctrl register signal(usb20_vbus_valid_sw) to controller.</comment>
        </bits>
        <bits access="rw" name="usb20_vbus_valid_sw" pos="3" rst="0x0">
          <comment>1:valid
0:not valid</comment>
        </bits>
        <bits access="rw" name="exit_suspend_wait_xtal26m" pos="2" rst="0x0">
          <comment>1: USB exit suspend mode after xtal 26m stable
0: USB exit suspend mode not rely on the status of xtal 26m</comment>
        </bits>
        <bits access="rw" name="ptest_func_atspeed_sel" pos="1" rst="0x0">
          <comment>0: sel ptest_func_clk to instead pll output clock in ptest mode
1: use pll output clock in ptest mode</comment>
        </bits>
        <bits access="rw" name="spiflash2_nand_sel" pos="0" rst="0x0">
          <comment>1:nandflash
0:norflash</comment>
        </bits>
      </reg>
      <reg name="plls_sts" protect="rw">
        <comment>PLLS_STS</comment>
        <bits access="r" name="iispll_state" pos="10:8" rst="0x0"/>
        <bits access="r" name="mpll_state" pos="6:4" rst="0x0"/>
        <bits access="r" name="apll_state" pos="2:0" rst="0x0"/>
      </reg>
      <reg name="cfg_aon_anti_hang" protect="rw">
        <comment>CFG_AON_ANTI_HANG</comment>
        <bits access="rw" name="aon2rf_slv_disable_req_sel" pos="15" rst="0x0">
          <comment>1: sel software force register bit
0: sel hardware signal</comment>
        </bits>
        <bits access="rw" name="aon2rf_slv_disable_req_force" pos="14" rst="0x0">
          <comment>1:  disable downstream path of aon to rf
0: no disable downstream path of aon to rf</comment>
        </bits>
        <bits access="rw" name="aon2cp_slv_disable_req_sel" pos="13" rst="0x0">
          <comment>1: sel software force register bit
0: sel hardware signal</comment>
        </bits>
        <bits access="rw" name="aon2cp_slv_disable_req_force" pos="12" rst="0x0">
          <comment>1:  disable downstream path of aon to cp
0: no disable downstream path of aon to cp</comment>
        </bits>
        <bits access="rw" name="aon2ap_slv_disable_req_sel" pos="11" rst="0x0">
          <comment>1: sel software force register bit
0: sel hardware signal</comment>
        </bits>
        <bits access="rw" name="aon2ap_slv_disable_req_force" pos="10" rst="0x0">
          <comment>1:  disable downstream path of aon to ap
0: no disable downstream path of aon to ap</comment>
        </bits>
        <bits access="rw" name="aon2rf_err_resp_en" pos="9" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aon2cp_err_resp_en" pos="8" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aon2ap_err_resp_en" pos="7" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="lte_err_resp_en" pos="6" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aon2pub_slv_disable_req_sel" pos="5" rst="0x0">
          <comment>1: sel software force register bit
0: sel hardware signal</comment>
        </bits>
        <bits access="rw" name="aon2pub_slv_disable_req_force" pos="4" rst="0x0">
          <comment>1:  disable downstream path of aon to psram
0: no disable downstream path of aon to psram</comment>
        </bits>
        <bits access="rw" name="lpsifc_err_resp_en" pos="3" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aonifc_err_resp_en" pos="2" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aon_apbmux_err_resp_en" pos="1" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aon_ahbmux_err_resp_en" pos="0" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
      </reg>
      <reg name="cfg_aon_qos" protect="rw">
        <comment>CFG_AON_QOS</comment>
        <bits access="rw" name="arqos_aon" pos="7:4" rst="0x0">
          <comment>R-channel QOS value of AON</comment>
        </bits>
        <bits access="rw" name="awqos_aon" pos="3:0" rst="0x0">
          <comment>W-channel QOS value of AON</comment>
        </bits>
      </reg>
      <reg name="aon_ahb_mtx_slice_autogate_en" protect="rw">
        <comment>AON_AHB_MTX_SLICE_AUTOGATE_EN</comment>
        <bits access="rw" name="aon_ahb_mtx_slice_m5_auto_gate_en" pos="11" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_m4_auto_gate_en" pos="10" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_m3_auto_gate_en" pos="9" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_m2_auto_gate_en" pos="8" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_m1_auto_gate_en" pos="7" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_m0_auto_gate_en" pos="6" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s5_auto_gate_en" pos="5" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s4_auto_gate_en" pos="4" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s3_auto_gate_en" pos="3" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s2_auto_gate_en" pos="2" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s1_auto_gate_en" pos="1" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s0_auto_gate_en" pos="0" rst="0x0">
          <comment>“1”: clock auto gating enable.
“0”: clock auto gating disable.</comment>
        </bits>
      </reg>
      <reg name="dap_djtag_en_cfg" protect="rw">
        <comment>DAP_DJTAG_EN_CFG</comment>
        <bits access="rw" name="dap_djtag_en" pos="0" rst="0x0">
          <comment>“1”: enable dap djtag.
“0”: dap djtag enable by dap jtag chain.</comment>
        </bits>
      </reg>
      <reg name="lte_ahb2ahb_sync_cfg" protect="rw">
        <comment>LTE_AHB2AHB_SYNC_CFG</comment>
        <bits access="rw" name="cpu2phy_auto_gating_en" pos="3" rst="0x0">
          <comment>“1”: enable cpu2phy通路ahb2ahb_sync auto clock gating.
“0”: disable cpu2phy通路ahb2ahb_sync auto clock gating.</comment>
        </bits>
        <bits access="rw" name="cpu2phy_wr_early_resp_en" pos="2" rst="0x0">
          <comment>“1”: enable cpu2phy通路ahb2ahb_sync write early_resp_en.
“0”: disable cpu2phy通路ahb2ahb_sync write early_resp_en..</comment>
        </bits>
        <bits access="rw" name="dma2phy_auto_gating_en" pos="1" rst="0x0">
          <comment>“1”: enable dma2phy通路ahb2ahb_sync auto clock gating.
“0”: disable dma2phy通路ahb2ahb_sync auto clock gating.</comment>
        </bits>
        <bits access="rw" name="dma2phy_wr_early_resp_en" pos="0" rst="0x0">
          <comment>“1”: enable dma2phy通路ahb2ahb_sync write early_resp_en.
“0”: disable dma2phy通路ahb2ahb_sync write early_resp_en..</comment>
        </bits>
      </reg>
      <reg name="cfg_aon_io_core_ie_0" protect="rw">
        <comment>CFG_AON_IO_CORE_IE_0</comment>
      </reg>
      <reg name="cfg_aon_io_core_ie_1" protect="rw">
        <comment>CFG_AON_IO_CORE_IE_1</comment>
      </reg>
      <reg name="cfg_aon_io_core_ie_2" protect="rw">
        <comment>CFG_AON_IO_CORE_IE_2</comment>
      </reg>
      <reg name="cfg_aon_io_core_ie_3" protect="rw">
        <comment>CFG_AON_IO_CORE_IE_3</comment>
      </reg>
      <hole size="6496"/>
      <reg name="aon_soft_rst_ctrl0_set" protect="rw"/>
      <reg name="clken_lte_set" protect="rw"/>
      <reg name="clken_lte_intf_set" protect="rw"/>
      <reg name="rstctrl_lte_set" protect="rw"/>
      <hole size="32"/>
      <reg name="lte_autogate_en_set" protect="rw"/>
      <hole size="32"/>
      <reg name="aon_lpc_ctrl_set" protect="rw"/>
      <reg name="aon_clock_en0_set" protect="rw"/>
      <reg name="aon_clock_en1_set" protect="rw"/>
      <reg name="aon_clock_auto_sel0_set" protect="rw"/>
      <reg name="aon_clock_auto_sel1_set" protect="rw"/>
      <reg name="aon_clock_auto_sel2_set" protect="rw"/>
      <reg name="aon_clock_auto_sel3_set" protect="rw"/>
      <reg name="aon_clock_force_en0_set" protect="rw"/>
      <reg name="aon_clock_force_en1_set" protect="rw"/>
      <reg name="aon_clock_force_en2_set" protect="rw"/>
      <reg name="aon_clock_force_en3_set" protect="rw"/>
      <reg name="aon_soft_rst_ctrl1_set" protect="rw"/>
      <reg name="mipi_csi_cfg_reg_set" protect="rw"/>
      <reg name="cfg_clk_uart2_set" protect="rw"/>
      <reg name="cfg_clk_uart3_set" protect="rw"/>
      <reg name="cfg_clk_debug_host_set" protect="rw"/>
      <hole size="32"/>
      <reg name="rc_calib_ctrl_set" protect="rw"/>
      <hole size="64"/>
      <reg name="emmc_slice_phy_ctrl_set" protect="rw"/>
      <reg name="dma_req_ctrl_set" protect="rw"/>
      <reg name="apt_trigger_sel_set" protect="rw"/>
      <reg name="ahb2ahb_ab_funcdma_ctrl_set" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2ahb_ab_dap_ctrl_set" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2axi_pub_ctrl_set" protect="rw"/>
      <hole size="96"/>
      <reg name="ahb2ahb_ab_aon2lps_ctrl_set" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2ahb_ab_lps2aon_ctrl_set" protect="rw"/>
      <hole size="32"/>
      <reg name="sysctrl_reg0_set" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_aon_anti_hang_set" protect="rw"/>
      <hole size="32"/>
      <reg name="aon_ahb_mtx_slice_autogate_en_set" protect="rw"/>
      <reg name="dap_djtag_en_cfg_set" protect="rw"/>
      <reg name="lte_ahb2ahb_sync_cfg_set" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_0_set" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_1_set" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_2_set" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_3_set" protect="rw"/>
      <hole size="6496"/>
      <reg name="aon_soft_rst_ctrl0_clr" protect="rw"/>
      <reg name="clken_lte_clr" protect="rw"/>
      <reg name="clken_lte_intf_clr" protect="rw"/>
      <reg name="rstctrl_lte_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="lte_autogate_en_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="aon_lpc_ctrl_clr" protect="rw"/>
      <reg name="aon_clock_en0_clr" protect="rw"/>
      <reg name="aon_clock_en1_clr" protect="rw"/>
      <reg name="aon_clock_auto_sel0_clr" protect="rw"/>
      <reg name="aon_clock_auto_sel1_clr" protect="rw"/>
      <reg name="aon_clock_auto_sel2_clr" protect="rw"/>
      <reg name="aon_clock_auto_sel3_clr" protect="rw"/>
      <reg name="aon_clock_force_en0_clr" protect="rw"/>
      <reg name="aon_clock_force_en1_clr" protect="rw"/>
      <reg name="aon_clock_force_en2_clr" protect="rw"/>
      <reg name="aon_clock_force_en3_clr" protect="rw"/>
      <reg name="aon_soft_rst_ctrl1_clr" protect="rw"/>
      <reg name="mipi_csi_cfg_reg_clr" protect="rw"/>
      <reg name="cfg_clk_uart2_clr" protect="rw"/>
      <reg name="cfg_clk_uart3_clr" protect="rw"/>
      <reg name="cfg_clk_debug_host_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="rc_calib_ctrl_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="emmc_slice_phy_ctrl_clr" protect="rw"/>
      <reg name="dma_req_ctrl_clr" protect="rw"/>
      <reg name="apt_trigger_sel_clr" protect="rw"/>
      <reg name="ahb2ahb_ab_funcdma_ctrl_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2ahb_ab_dap_ctrl_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2axi_pub_ctrl_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="ahb2ahb_ab_aon2lps_ctrl_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2ahb_ab_lps2aon_ctrl_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="sysctrl_reg0_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_aon_anti_hang_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="aon_ahb_mtx_slice_autogate_en_clr" protect="rw"/>
      <reg name="dap_djtag_en_cfg_clr" protect="rw"/>
      <reg name="lte_ahb2ahb_sync_cfg_clr" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_0_clr" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_1_clr" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_2_clr" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_3_clr" protect="rw"/>
    </module>
    <var name="REG_SYS_CTRL_SET_OFFSET" value="0x400"/>
    <var name="REG_SYS_CTRL_CLR_OFFSET" value="0x800"/>
    <instance address="0x51500000" name="SYS_CTRL" type="SYS_CTRL"/>
  </archive>
  <archive relative="scc.xml">
    <module category="System" name="SCC">
      <reg name="scc_tune_lmt_cfg" protect="rw">
        <comment>SCC_TUNE_LMT_CFG</comment>
        <bits access="rw" name="volt_tune_val_max" pos="15:8" rst="0xff">
          <comment>VOLT_TUNE_VAL_MAX[7:5]:
3'b000 : DCDC 0.6V
3'b001 : DCDC 0.7V
3'b010 : DCDC 0.8V
3'b011 : DCDC 0.9V
3'b100 : DCDC 1.0V
3'b101 : DCDC 1.1V
3'b110 : DCDC 1.2V
3'b111 : DCDC 1.3V
VOLT_TUNE_VAL_MAX[4:0] represent 0.1V/32.
The result voltage = VOLT_TUNE_VAL_MAX[7:5] + VOLT_TUNE_VAL_MAX[4:0]*3mV</comment>
        </bits>
        <bits access="rw" name="volt_tune_val_min" pos="7:0" rst="0x0">
          <comment>Same to VOLT_TUNE_VAL_MAX</comment>
        </bits>
      </reg>
      <reg name="scc_tune_status" protect="rw">
        <comment>SCC_TUNE_STATUS</comment>
        <bits access="r" name="volt_tune_val" pos="15:8" rst="0x0">
          <comment>the voltage give to A_DIE for voltage setting:
VOLT_TUNE_VAL[7:5]:change the voltage 100mv for each step;
VOLT_TUNE_VAL[4:0]:change the voltage about 3mv each step</comment>
        </bits>
        <bits access="r" name="volt_obs_val" pos="7:0" rst="0x0">
          <comment>the current voltage of A_DIE,observed through ADI bus:
3'b000 : DCDC 0.6V
3'b001 : DCDC 0.7V
3'b010 : DCDC 0.8V
3'b011 : DCDC 0.9V
3'b100 : DCDC 1.0V
3'b101 : DCDC 1.1V
3'b110 : DCDC 1.2V
3'b111 : DCDC 1.3V</comment>
        </bits>
      </reg>
      <reg name="scc_cfg" protect="rw">
        <comment>SCC_CFG</comment>
        <bits access="rw" name="volt0_select_override" pos="31" rst="0x0">
          <comment>Voltage Tune/Obs 0 Interface Select</comment>
        </bits>
        <bits access="rw" name="volt1_select_override" pos="30" rst="0x0">
          <comment>Voltage Tune/Obs 1 Interface Select</comment>
        </bits>
        <bits access="rw" name="pause_occur_err_en" pos="8" rst="0x0">
          <comment>not used in Whale</comment>
        </bits>
        <bits access="rw" name="volt_tune_forbid_en" pos="4" rst="0x0">
          <comment>stop tuning the voltage</comment>
        </bits>
        <bits access="rw" name="volt_obs_forbid_en" pos="0" rst="0x0">
          <comment>stop observating of voltage</comment>
        </bits>
      </reg>
      <reg name="scc_tune_step_cfg" protect="rw">
        <comment>SCC_TUNE_STEP_CFG</comment>
        <bits access="rw" name="volt_tune_down_step" pos="24:16" rst="0x101">
          <comment>voltage set down step,fine tuning</comment>
        </bits>
        <bits access="rw" name="volt_tune_up_step" pos="8:0" rst="0x1">
          <comment>voltage set up step,fine tuning</comment>
        </bits>
      </reg>
      <reg name="scc_wait_cfg" protect="rw">
        <comment>SCC_WAIT_CFG</comment>
        <bits access="rw" name="rnd_intval_wait_num" pos="31:16" rst="0x7">
          <comment>the time that SCC state_machine remain RND_INTVAL_WAIT</comment>
        </bits>
        <bits access="rw" name="volt_stb_wait_num" pos="15:0" rst="0xf">
          <comment>the time that SCC state_machine remain VOLT_STB_WAIT</comment>
        </bits>
      </reg>
      <reg name="scc_int_cfg" protect="rw">
        <comment>SCC_INT_CFG</comment>
        <bits access="r" name="scc_tune_done_int_mask_status" pos="13" rst="0x0">
          <comment>mask status of interrupt caused by tune over</comment>
        </bits>
        <bits access="r" name="scc_tune_err_int_mask_status" pos="12" rst="0x0">
          <comment>mask status of interrupt caused by tune voltage over flow or under flow</comment>
        </bits>
        <bits access="r" name="scc_tune_done_int_raw_status" pos="9" rst="0x0">
          <comment>raw status of interrupt caused by tune over</comment>
        </bits>
        <bits access="r" name="scc_tune_err_int_raw_status" pos="8" rst="0x0">
          <comment>raw status of interrupt caused by tune voltage over flow or under flow</comment>
        </bits>
        <bits access="w" name="scc_tune_done_int_clr" pos="5" rst="0x0">
          <comment>clear the interrupt caused by SCC done interrupt</comment>
        </bits>
        <bits access="w" name="scc_tune_err_int_clr" pos="4" rst="0x0">
          <comment>clear the interrupt caused by SCC tune error interrupt</comment>
        </bits>
        <bits access="rw" name="scc_tune_done_int_en" pos="1" rst="0x0">
          <comment>software configuration to enable the  interrupt of SCC</comment>
        </bits>
        <bits access="rw" name="scc_tune_err_int_en" pos="0" rst="0x0">
          <comment>software configuration to enable the  error interrupt</comment>
        </bits>
      </reg>
      <reg name="scc_tune_mark" protect="rw">
        <comment>SCC_TUNE_MARK</comment>
        <bits access="rw" name="scc_tune_dwn_mark" pos="31:16" rst="0x1388">
          <comment>the boundary that need to tune down voltage</comment>
        </bits>
        <bits access="rw" name="scc_tune_up_mark" pos="15:0" rst="0xbb8">
          <comment>the boundary that need to tune up voltage</comment>
        </bits>
      </reg>
      <reg name="scc_fsm_sts" protect="rw">
        <comment>SCC_FSM_STS</comment>
        <bits access="r" name="scc_fsm_sts" pos="4:0" rst="0x10">
          <comment>SCC Finite State Machine current state</comment>
        </bits>
      </reg>
      <reg name="scc_rosc_mode" protect="rw">
        <comment>SCC_ROSC_MODE</comment>
        <bits access="rw" name="scc_idle_mode" pos="31" rst="0x0">
          <comment>SCC IDEL CTRL</comment>
        </bits>
        <bits access="rw" name="scc_tune_bypass" pos="30" rst="0x1">
          <comment>SCC Voltage Tuning Bypass</comment>
        </bits>
        <bits access="rw" name="scc_init_halt_bypass" pos="29" rst="0x1">
          <comment>SCC Initialization Pattern Fail Halt Bypass</comment>
        </bits>
        <bits access="rw" name="scc_rpt_read_ctrl" pos="12" rst="0x0">
          <comment>SCC ROSC Report Read Control</comment>
        </bits>
        <bits access="rw" name="scc_all_rosc_chain" pos="2" rst="0x0">
          <comment>OSC through all the chain in preselected sequence</comment>
        </bits>
        <bits access="rw" name="scc_all_rosc_seq" pos="1" rst="0x0">
          <comment>OSC through a sequence in preselected chain</comment>
        </bits>
        <bits access="rw" name="scc_rosc_repeat_mode" pos="0" rst="0x0">
          <comment>REPEAT The RUN Operation</comment>
        </bits>
      </reg>
      <reg name="scc_rosc_cfg" protect="rw">
        <comment>SCC_ROSC_CFG</comment>
        <bits access="rw" name="scc_rosc_duration" pos="31:12" rst="0x0">
          <comment>SCC ROSC Oscillation duration</comment>
        </bits>
        <bits access="rw" name="scc_rosc_sel_z" pos="11:8" rst="0x0">
          <comment>SCC ROSC Ring Select</comment>
        </bits>
        <bits access="rw" name="scc_rosc_sel_y" pos="7:4" rst="0x0">
          <comment>SCC ROSC Sequence Select</comment>
        </bits>
        <bits access="rw" name="scc_rosc_sel_x" pos="3:0" rst="0x0">
          <comment>SCC ROSC Chain Select</comment>
        </bits>
      </reg>
      <reg name="scc_rosc_ctrl" protect="rw">
        <comment>SCC_ROSC_CTRL</comment>
        <bits access="rw" name="scc_rpt_read_nxt" pos="31" rst="0x0">
          <comment>SCC ROSC Report To Read</comment>
        </bits>
        <bits access="rw" name="scc_rosc_gr_enable" pos="1" rst="0x0">
          <comment>ROSC Gross Ring Enable</comment>
        </bits>
        <bits access="rw" name="scc_rosc_run" pos="0" rst="0x0">
          <comment>ROSC RUN</comment>
        </bits>
      </reg>
      <reg name="scc_rosc_rpt" protect="rw">
        <comment>SCC_ROSC_RPT</comment>
        <bits access="r" name="scc_init_pat_fail" pos="31" rst="0x0">
          <comment>Initialization Pattern Fail</comment>
        </bits>
        <bits access="r" name="scc_rosc_rpt_valid" pos="30" rst="0x0">
          <comment>SCC ROSC REPORT VALID</comment>
        </bits>
        <bits access="r" name="scc_rosc_setting" pos="24:20" rst="0x0">
          <comment>Selected ROSC Setting: GRE + RING number</comment>
        </bits>
        <bits access="r" name="scc_rosc_cnt" pos="19:0" rst="0x0">
          <comment>rosc</comment>
        </bits>
      </reg>
      <reg name="scc_rosc_sw_rst" protect="rw">
        <comment>SCC_ROSC_SW_RST</comment>
        <bits access="rw" name="scc_rosc_sw_rst" pos="1:0" rst="0x0">
          <comment>SCC ROSC Chain Reset, Active Low</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51505000" name="SCC" type="SCC"/>
  </archive>
  <archive relative="djtag_ctrl.xml">
    <module category="System" name="DJTAG_CTRL">
      <reg name="djtag_ir_len" protect="rw">
        <comment>DJTAG_IR_LEN</comment>
        <bits access="rw" name="djtag_ir_len" pos="5:0" rst="0x0">
          <comment>the instruction register length</comment>
        </bits>
      </reg>
      <reg name="ap_pwr_ctrl" protect="rw">
        <comment>DJTAG_DR_LEN</comment>
        <bits access="rw" name="djtag_dr_len" pos="15:0" rst="0x0">
          <comment>the data register length</comment>
        </bits>
      </reg>
      <reg name="djtag_ir" protect="rw">
        <comment>DJTAG_IR</comment>
      </reg>
      <reg name="djtag_dr" protect="rw">
        <comment>DJTAG_DR</comment>
      </reg>
      <reg name="dr_pause_recov" protect="rw">
        <comment>DR_PAUSE_RECOV</comment>
        <bits access="rw" name="djtag_dr_pause_recov" pos="0" rst="0x0">
          <comment>the signal to recover from PAUSE state</comment>
        </bits>
      </reg>
      <reg name="djtag_rnd_en" protect="rw">
        <comment>DJTAG_RND_EN</comment>
        <bits access="rw" name="djtag_rnd_en" pos="0" rst="0x0">
          <comment>the signal to start DJTAG scan</comment>
        </bits>
      </reg>
      <reg name="djtag_upd_dr" protect="rw">
        <comment>DJTAG_UPD_DR</comment>
      </reg>
      <reg name="djtag_dap_mux_ctrl_soft_rst" protect="rw">
        <comment>DJTAG_DAP_MUX_CTRL_SOFT_RST</comment>
        <bits access="rw" name="djtag_dap_mux_ctrl_soft_rst" pos="0" rst="0x0">
          <comment>reset of dap mux control chain</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x5150e000" name="DJTAG_CTRL" type="DJTAG_CTRL"/>
  </archive>
  <archive relative="aon_clk_gen.xml">
    <module category="System" name="AON_CLK_GEN">
      <hole size="256"/>
      <reg name="soft_cnt_done0_cfg" protect="rw">
        <comment>soft_cnt_done0_cfg</comment>
        <bits access="rw" name="apll_1000m_soft_cnt_done" pos="5" rst="0x1">
          <comment>apll_1000m_soft_cnt_done counter wait for source stable</comment>
        </bits>
        <bits access="rw" name="mempll_1000m_soft_cnt_done" pos="4" rst="0x1">
          <comment>mempll_1000m_soft_cnt_done counter wait for source stable</comment>
        </bits>
        <bits access="rw" name="audio_pll_122m_soft_cnt_done" pos="3" rst="0x1">
          <comment>audio_pll_122m_soft_cnt_done counter wait for source stable</comment>
        </bits>
        <bits access="rw" name="xtal_26m_soft_cnt_done" pos="2" rst="0x1">
          <comment>xtal_26m_soft_cnt_done counter wait for source stable</comment>
        </bits>
        <bits access="rw" name="xtal_lp_26m_soft_cnt_done" pos="1" rst="0x1">
          <comment>xtal_lp_26m_soft_cnt_done counter wait for source stable</comment>
        </bits>
        <bits access="rw" name="rc26m_78m_soft_cnt_done" pos="0" rst="0x1">
          <comment>rc26m_78m_soft_cnt_done counter wait for source stable</comment>
        </bits>
      </reg>
      <reg name="pll_wait_sel0_cfg" protect="rw">
        <comment>pll_wait_sel0_cfg</comment>
        <bits access="rw" name="apll_1000m_wait_auto_gate_sel" pos="5" rst="0x1">
          <comment>apll_1000m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="mempll_1000m_wait_auto_gate_sel" pos="4" rst="0x1">
          <comment>mempll_1000m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="audio_pll_122m_wait_auto_gate_sel" pos="3" rst="0x1">
          <comment>audio_pll_122m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="xtal_26m_wait_auto_gate_sel" pos="2" rst="0x1">
          <comment>xtal_26m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="xtal_lp_26m_wait_auto_gate_sel" pos="1" rst="0x1">
          <comment>xtal_lp_26m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="rc26m_78m_wait_auto_gate_sel" pos="0" rst="0x1">
          <comment>rc26m_78m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
      </reg>
      <reg name="pll_wait_sw_ctl0_cfg" protect="rw">
        <comment>pll_wait_sw_ctl0_cfg</comment>
        <bits access="rw" name="apll_1000m_wait_force_en" pos="5" rst="0x1">
          <comment>apll_1000m_wait_force_en pll wait's enable sw control</comment>
        </bits>
        <bits access="rw" name="mempll_1000m_wait_force_en" pos="4" rst="0x1">
          <comment>mempll_1000m_wait_force_en pll wait's enable sw control</comment>
        </bits>
        <bits access="rw" name="audio_pll_122m_wait_force_en" pos="3" rst="0x1">
          <comment>audio_pll_122m_wait_force_en pll wait's enable sw control</comment>
        </bits>
        <bits access="rw" name="xtal_26m_wait_force_en" pos="2" rst="0x1">
          <comment>xtal_26m_wait_force_en pll wait's enable sw control</comment>
        </bits>
        <bits access="rw" name="xtal_lp_26m_wait_force_en" pos="1" rst="0x1">
          <comment>xtal_lp_26m_wait_force_en pll wait's enable sw control</comment>
        </bits>
        <bits access="rw" name="rc26m_78m_wait_force_en" pos="0" rst="0x1">
          <comment>rc26m_78m_wait_force_en pll wait's enable sw control</comment>
        </bits>
      </reg>
      <reg name="div_en_sel0_cfg" protect="rw">
        <comment>div_en_sel0_cfg</comment>
        <bits access="rw" name="apll_div_1000m_90m9_auto_gate_sel" pos="11" rst="0x1">
          <comment>apll_div_1000m_90m9_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_500m_auto_gate_sel" pos="10" rst="0x1">
          <comment>apll_div_1000m_500m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_250m_auto_gate_sel" pos="9" rst="0x1">
          <comment>apll_div_1000m_250m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_125m_auto_gate_sel" pos="8" rst="0x1">
          <comment>apll_div_1000m_125m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_62m5_auto_gate_sel" pos="7" rst="0x1">
          <comment>apll_div_1000m_62m5_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_31m2_auto_gate_sel" pos="6" rst="0x1">
          <comment>apll_div_1000m_31m2_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_333m3_auto_gate_sel" pos="5" rst="0x1">
          <comment>apll_div_1000m_333m3_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_166m7_auto_gate_sel" pos="4" rst="0x1">
          <comment>apll_div_1000m_166m7_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_200m_auto_gate_sel" pos="3" rst="0x1">
          <comment>apll_div_1000m_200m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_100m_auto_gate_sel" pos="2" rst="0x1">
          <comment>apll_div_1000m_100m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="audio_div_pll_122m_30m7_auto_gate_sel" pos="1" rst="0x1">
          <comment>audio_div_pll_122m_30m7_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="mempll_div_1000m_500m_auto_gate_sel" pos="0" rst="0x1">
          <comment>mempll_div_1000m_500m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
      </reg>
      <reg name="div_en_sw_ctl0_cfg" protect="rw">
        <comment>div_en_sw_ctl0_cfg</comment>
        <bits access="rw" name="apll_div_1000m_90m9_force_en" pos="11" rst="0x1">
          <comment>apll_div_1000m_90m9_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_500m_force_en" pos="10" rst="0x1">
          <comment>apll_div_1000m_500m_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_250m_force_en" pos="9" rst="0x1">
          <comment>apll_div_1000m_250m_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_125m_force_en" pos="8" rst="0x1">
          <comment>apll_div_1000m_125m_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_62m5_force_en" pos="7" rst="0x1">
          <comment>apll_div_1000m_62m5_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_31m2_force_en" pos="6" rst="0x1">
          <comment>apll_div_1000m_31m2_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_333m3_force_en" pos="5" rst="0x1">
          <comment>apll_div_1000m_333m3_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_166m7_force_en" pos="4" rst="0x1">
          <comment>apll_div_1000m_166m7_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_200m_force_en" pos="3" rst="0x1">
          <comment>apll_div_1000m_200m_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_100m_force_en" pos="2" rst="0x1">
          <comment>apll_div_1000m_100m_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="audio_div_pll_122m_30m7_force_en" pos="1" rst="0x1">
          <comment>audio_div_pll_122m_30m7_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="mempll_div_1000m_500m_force_en" pos="0" rst="0x1">
          <comment>mempll_div_1000m_500m_force_en pre div clock's enable sw control</comment>
        </bits>
      </reg>
      <reg name="gate_en_sel0_cfg" protect="rw">
        <comment>gate_en_sel0_cfg</comment>
        <bits access="rw" name="cgm_rtc_32k_ap_auto_gate_sel" pos="31" rst="0x1">
          <comment>cgm_rtc_32k_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_ap_auto_gate_sel" pos="30" rst="0x1">
          <comment>cgm_rc_26m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_ap_auto_gate_sel" pos="29" rst="0x1">
          <comment>cgm_xtal_26m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_500m_ap_auto_gate_sel" pos="28" rst="0x1">
          <comment>cgm_apll_500m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_ap_auto_gate_sel" pos="27" rst="0x1">
          <comment>cgm_apll_400m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_ap_auto_gate_sel" pos="26" rst="0x1">
          <comment>cgm_apll_250m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_ap_auto_gate_sel" pos="25" rst="0x1">
          <comment>cgm_apll_167m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_ap_auto_gate_sel" pos="24" rst="0x1">
          <comment>cgm_apll_125m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_100m_ap_auto_gate_sel" pos="23" rst="0x1">
          <comment>cgm_apll_100m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_ap_auto_gate_sel" pos="22" rst="0x1">
          <comment>cgm_apll_62_5m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_31_25m_ap_auto_gate_sel" pos="21" rst="0x1">
          <comment>cgm_apll_31_25m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_cp_auto_gate_sel" pos="20" rst="0x1">
          <comment>cgm_rtc_32k_cp_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_cp_auto_gate_sel" pos="19" rst="0x1">
          <comment>cgm_xtal_26m_cp_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_cp_auto_gate_sel" pos="18" rst="0x1">
          <comment>cgm_apll_400m_cp_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_200m_cp_auto_gate_sel" pos="17" rst="0x1">
          <comment>cgm_apll_200m_cp_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_aon_auto_gate_sel" pos="16" rst="0x1">
          <comment>cgm_rc_26m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_aon_auto_gate_sel" pos="15" rst="0x1">
          <comment>cgm_xtal_26m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_lp_26m_aon_auto_gate_sel" pos="14" rst="0x1">
          <comment>cgm_xtal_lp_26m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_aon_auto_gate_sel" pos="13" rst="0x1">
          <comment>cgm_apll_400m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_333m_aon_auto_gate_sel" pos="12" rst="0x1">
          <comment>cgm_apll_333m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_aon_auto_gate_sel" pos="11" rst="0x1">
          <comment>cgm_apll_250m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_200m_aon_auto_gate_sel" pos="10" rst="0x1">
          <comment>cgm_apll_200m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_aon_auto_gate_sel" pos="9" rst="0x1">
          <comment>cgm_apll_167m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_aon_auto_gate_sel" pos="8" rst="0x1">
          <comment>cgm_apll_125m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_100m_aon_auto_gate_sel" pos="7" rst="0x1">
          <comment>cgm_apll_100m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_aon_auto_gate_sel" pos="6" rst="0x1">
          <comment>cgm_apll_62_5m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_31_25m_aon_auto_gate_sel" pos="5" rst="0x1">
          <comment>cgm_apll_31_25m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_audiopll_122_88m_aon_auto_gate_sel" pos="4" rst="0x1">
          <comment>cgm_audiopll_122_88m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_audiopll_30_72m_aon_auto_gate_sel" pos="3" rst="0x1">
          <comment>cgm_audiopll_30_72m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_pub_auto_gate_sel" pos="2" rst="0x1">
          <comment>cgm_rc_26m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_pub_auto_gate_sel" pos="1" rst="0x1">
          <comment>cgm_xtal_26m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_mempll_500m_pub_auto_gate_sel" pos="0" rst="0x1">
          <comment>cgm_mempll_500m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
      </reg>
      <reg name="gate_en_sel1_cfg" protect="rw">
        <comment>gate_en_sel1_cfg</comment>
        <bits access="rw" name="cgm_apll_500m_pub_auto_gate_sel" pos="7" rst="0x1">
          <comment>cgm_apll_500m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_pub_auto_gate_sel" pos="6" rst="0x1">
          <comment>cgm_apll_400m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_pub_auto_gate_sel" pos="5" rst="0x1">
          <comment>cgm_apll_250m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_gnss_auto_gate_sel" pos="4" rst="0x1">
          <comment>cgm_xtal_26m_gnss_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_gnss_auto_gate_sel" pos="3" rst="0x1">
          <comment>cgm_apll_167m_gnss_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_gnss_auto_gate_sel" pos="2" rst="0x1">
          <comment>cgm_apll_125m_gnss_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_gnss_auto_gate_sel" pos="1" rst="0x1">
          <comment>cgm_apll_62_5m_gnss_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_rf_auto_gate_sel" pos="0" rst="0x1">
          <comment>cgm_xtal_26m_rf_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
      </reg>
      <reg name="gate_en_sw_ctl0_cfg" protect="rw">
        <comment>gate_en_sw_ctl0_cfg</comment>
        <bits access="rw" name="cgm_rtc_32k_ap_force_en" pos="31" rst="0x1">
          <comment>cgm_rtc_32k_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_ap_force_en" pos="30" rst="0x1">
          <comment>cgm_rc_26m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_ap_force_en" pos="29" rst="0x1">
          <comment>cgm_xtal_26m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_500m_ap_force_en" pos="28" rst="0x1">
          <comment>cgm_apll_500m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_ap_force_en" pos="27" rst="0x1">
          <comment>cgm_apll_400m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_ap_force_en" pos="26" rst="0x1">
          <comment>cgm_apll_250m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_ap_force_en" pos="25" rst="0x1">
          <comment>cgm_apll_167m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_ap_force_en" pos="24" rst="0x1">
          <comment>cgm_apll_125m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_100m_ap_force_en" pos="23" rst="0x1">
          <comment>cgm_apll_100m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_ap_force_en" pos="22" rst="0x1">
          <comment>cgm_apll_62_5m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_31_25m_ap_force_en" pos="21" rst="0x1">
          <comment>cgm_apll_31_25m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_cp_force_en" pos="20" rst="0x1">
          <comment>cgm_rtc_32k_cp_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_cp_force_en" pos="19" rst="0x1">
          <comment>cgm_xtal_26m_cp_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_cp_force_en" pos="18" rst="0x1">
          <comment>cgm_apll_400m_cp_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_200m_cp_force_en" pos="17" rst="0x1">
          <comment>cgm_apll_200m_cp_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_aon_force_en" pos="16" rst="0x1">
          <comment>cgm_rc_26m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_aon_force_en" pos="15" rst="0x1">
          <comment>cgm_xtal_26m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_lp_26m_aon_force_en" pos="14" rst="0x1">
          <comment>cgm_xtal_lp_26m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_aon_force_en" pos="13" rst="0x1">
          <comment>cgm_apll_400m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_333m_aon_force_en" pos="12" rst="0x1">
          <comment>cgm_apll_333m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_aon_force_en" pos="11" rst="0x1">
          <comment>cgm_apll_250m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_200m_aon_force_en" pos="10" rst="0x1">
          <comment>cgm_apll_200m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_aon_force_en" pos="9" rst="0x1">
          <comment>cgm_apll_167m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_aon_force_en" pos="8" rst="0x1">
          <comment>cgm_apll_125m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_100m_aon_force_en" pos="7" rst="0x1">
          <comment>cgm_apll_100m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_aon_force_en" pos="6" rst="0x1">
          <comment>cgm_apll_62_5m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_31_25m_aon_force_en" pos="5" rst="0x1">
          <comment>cgm_apll_31_25m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_audiopll_122_88m_aon_force_en" pos="4" rst="0x1">
          <comment>cgm_audiopll_122_88m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_audiopll_30_72m_aon_force_en" pos="3" rst="0x1">
          <comment>cgm_audiopll_30_72m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_pub_force_en" pos="2" rst="0x1">
          <comment>cgm_rc_26m_pub_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_pub_force_en" pos="1" rst="0x1">
          <comment>cgm_xtal_26m_pub_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_mempll_500m_pub_force_en" pos="0" rst="0x1">
          <comment>cgm_mempll_500m_pub_force_en clock gating enable sw control</comment>
        </bits>
      </reg>
      <reg name="gate_en_sw_ctl1_cfg" protect="rw">
        <comment>gate_en_sw_ctl1_cfg</comment>
        <bits access="rw" name="cgm_apll_500m_pub_force_en" pos="7" rst="0x1">
          <comment>cgm_apll_500m_pub_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_pub_force_en" pos="6" rst="0x1">
          <comment>cgm_apll_400m_pub_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_pub_force_en" pos="5" rst="0x1">
          <comment>cgm_apll_250m_pub_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_gnss_force_en" pos="4" rst="0x1">
          <comment>cgm_xtal_26m_gnss_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_gnss_force_en" pos="3" rst="0x1">
          <comment>cgm_apll_167m_gnss_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_gnss_force_en" pos="2" rst="0x1">
          <comment>cgm_apll_125m_gnss_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_gnss_force_en" pos="1" rst="0x1">
          <comment>cgm_apll_62_5m_gnss_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_rf_force_en" pos="0" rst="0x1">
          <comment>cgm_xtal_26m_rf_force_en clock gating enable sw control</comment>
        </bits>
      </reg>
      <reg name="monitor_wait_en_status0_cfg" protect="rw">
        <comment>monitor_wait_en_status0_cfg</comment>
        <bits access="r" name="monitor_wait_en_status" pos="5:0" rst="0x0">
          <comment>monitor_wait_en_status , 0:apll_1000m, 1:mempll_1000m, 2:audio_pll_122m, 3:xtal_26m, 4:xtal_lp_26m, 5:rc26m_78m</comment>
        </bits>
      </reg>
      <reg name="monitor_div_auto_en_status0_cfg" protect="rw">
        <comment>monitor_div_auto_en_status0_cfg</comment>
        <bits access="r" name="monitor_div_auto_en_status" pos="11:0" rst="0x0">
          <comment>monitor_div_auto_en_status , 0:apll_div_1000m_90m9, 1:apll_div_1000m_500m, 2:apll_div_1000m_250m, 3:apll_div_1000m_125m, 4:apll_div_1000m_62m5, 5:apll_div_1000m_31m2, 6:apll_div_1000m_333m3, 7:apll_div_1000m_166m7, 8:apll_div_1000m_200m, 9:apll_div_1000m_100m, 10:audio_div_pll_122m_30m7, 11:mempll_div_1000m_500m</comment>
        </bits>
      </reg>
      <reg name="monitor_gate_auto_en_status00_cfg" protect="rw">
        <comment>monitor_gate_auto_en_status00_cfg</comment>
      </reg>
      <reg name="monitor_gate_auto_en_status10_cfg" protect="rw">
        <comment>monitor_gate_auto_en_status10_cfg</comment>
        <bits access="r" name="monitor_gate_auto_en_status1" pos="7:0" rst="0x0">
          <comment>monitor_gate_auto_en_status1 , 32:cgm_apll_500m_pub, 33:cgm_apll_400m_pub, 34:cgm_apll_250m_pub, 35:cgm_xtal_26m_gnss, 36:cgm_apll_167m_gnss, 37:cgm_apll_125m_gnss, 38:cgm_apll_62_5m_gnss, 39:cgm_xtal_26m_rf</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51508000" name="AON_CLK_GEN" type="AON_CLK_GEN"/>
  </archive>
  <archive relative="analog_g1.xml">
    <module category="System" name="ANALOG_G1">
      <reg name="analog_apll_apll_ctrl1" protect="rw">
        <comment>analog_apll_APLL_CTRL1</comment>
        <bits access="rw" name="analog_apll_apll_clkout_en" pos="18" rst="0x1"/>
        <bits access="rw" name="analog_apll_apll_ibias" pos="17:16" rst="0x1"/>
        <bits access="rw" name="analog_apll_apll_lpf" pos="15:13" rst="0x4"/>
        <bits access="rw" name="analog_apll_apll_ref_sel" pos="12" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_n" pos="11:1" rst="0x1e"/>
        <bits access="rw" name="analog_apll_apll_il_div2" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_apll_apll_ctrl2" protect="rw">
        <comment>analog_apll_APLL_CTRL2</comment>
        <bits access="rw" name="analog_apll_apll_ol_div2" pos="13:11" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_div_s" pos="10" rst="0x1"/>
        <bits access="rw" name="analog_apll_apll_sdm_en" pos="9" rst="0x1"/>
        <bits access="rw" name="analog_apll_apll_mod_en" pos="8" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_divn" pos="7:5" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_hop_en" pos="4" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_hop_trig" pos="3" rst="0x0"/>
        <bits access="r" name="analog_apll_apll_lock_done" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_rst" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_pd" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_apll_apll_int_value" protect="rw">
        <comment>analog_apll_APLL_INT_Value</comment>
        <bits access="rw" name="analog_apll_apll_nint" pos="26:20" rst="0x26"/>
        <bits access="rw" name="analog_apll_apll_kint" pos="19:0" rst="0x76276"/>
      </reg>
      <reg name="analog_apll_apll_ccs_ctrl" protect="rw">
        <comment>analog_apll_APLL_CCS_CTRL</comment>
        <bits access="rw" name="analog_apll_apll_ccs_ctrl" pos="15:0" rst="0x92d"/>
      </reg>
      <reg name="analog_apll_apll_kstep" protect="rw">
        <comment>analog_apll_APLL_KSTEP</comment>
        <bits access="rw" name="analog_apll_apll_kstep" pos="18:0" rst="0x19c"/>
      </reg>
      <reg name="analog_apll_ana_bias" protect="rw">
        <comment>analog_apll_ANA_BIAS</comment>
        <bits access="rw" name="analog_apll_apll_bias_top" pos="16:12" rst="0x9"/>
        <bits access="rw" name="analog_apll_apll_bist_ctrl" pos="11:2" rst="0x3ff"/>
        <bits access="rw" name="analog_apll_apll_bist_en" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_test_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_apll_ana_bias1" protect="rw">
        <comment>analog_apll_ANA_BIAS1</comment>
        <bits access="r" name="analog_apll_apll_bist_cnt" pos="18:3" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_dutyfix" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_apll_reg_sel_cfg_0" protect="rw">
        <comment>analog_apll_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_apll_apll_clkout_en" pos="4" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_apll_apll_rst" pos="3" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_apll_apll_pd" pos="2" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_apll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_apll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_mpll_apll_ctrl1" protect="rw">
        <comment>analog_mpll_APLL_CTRL1</comment>
        <bits access="rw" name="analog_mpll_apll_clkout_en" pos="18" rst="0x1"/>
        <bits access="rw" name="analog_mpll_apll_ibias" pos="17:16" rst="0x1"/>
        <bits access="rw" name="analog_mpll_apll_lpf" pos="15:13" rst="0x4"/>
        <bits access="rw" name="analog_mpll_apll_ref_sel" pos="12" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_n" pos="11:1" rst="0x1e"/>
        <bits access="rw" name="analog_mpll_apll_il_div2" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_mpll_apll_ctrl2" protect="rw">
        <comment>analog_mpll_APLL_CTRL2</comment>
        <bits access="rw" name="analog_mpll_apll_ol_div2" pos="13:11" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_div_s" pos="10" rst="0x1"/>
        <bits access="rw" name="analog_mpll_apll_sdm_en" pos="9" rst="0x1"/>
        <bits access="rw" name="analog_mpll_apll_mod_en" pos="8" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_divn" pos="7:5" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_hop_en" pos="4" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_hop_trig" pos="3" rst="0x0"/>
        <bits access="r" name="analog_mpll_apll_lock_done" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_rst" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_pd" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_mpll_apll_int_value" protect="rw">
        <comment>analog_mpll_APLL_INT_Value</comment>
        <bits access="rw" name="analog_mpll_apll_nint" pos="26:20" rst="0x1e"/>
        <bits access="rw" name="analog_mpll_apll_kint" pos="19:0" rst="0xc4ec5"/>
      </reg>
      <reg name="analog_mpll_apll_ccs_ctrl" protect="rw">
        <comment>analog_mpll_APLL_CCS_CTRL</comment>
        <bits access="rw" name="analog_mpll_apll_ccs_ctrl" pos="15:0" rst="0x92d"/>
      </reg>
      <reg name="analog_mpll_apll_kstep" protect="rw">
        <comment>analog_mpll_APLL_KSTEP</comment>
        <bits access="rw" name="analog_mpll_apll_kstep" pos="18:0" rst="0x19c"/>
      </reg>
      <reg name="analog_mpll_ana_bias" protect="rw">
        <comment>analog_mpll_ANA_BIAS</comment>
        <bits access="rw" name="analog_mpll_apll_bias_top" pos="16:12" rst="0x9"/>
        <bits access="rw" name="analog_mpll_apll_bist_ctrl" pos="11:2" rst="0x3ff"/>
        <bits access="rw" name="analog_mpll_apll_bist_en" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_test_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_mpll_ana_bias1" protect="rw">
        <comment>analog_mpll_ANA_BIAS1</comment>
        <bits access="r" name="analog_mpll_apll_bist_cnt" pos="18:3" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_dutyfix" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_mpll_reg_sel_cfg_0" protect="rw">
        <comment>analog_mpll_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_mpll_apll_clkout_en" pos="4" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_mpll_apll_rst" pos="3" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_mpll_apll_pd" pos="2" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_mpll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_mpll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_iis_pll_apll_ctrl1" protect="rw">
        <comment>analog_iis_pll_APLL_CTRL1</comment>
        <bits access="rw" name="analog_iis_pll_apll_clkout_en" pos="18" rst="0x1"/>
        <bits access="rw" name="analog_iis_pll_apll_ibias" pos="17:16" rst="0x1"/>
        <bits access="rw" name="analog_iis_pll_apll_lpf" pos="15:13" rst="0x4"/>
        <bits access="rw" name="analog_iis_pll_apll_ref_sel" pos="12" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_n" pos="11:1" rst="0x1e"/>
        <bits access="rw" name="analog_iis_pll_apll_il_div2" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_iis_pll_apll_ctrl2" protect="rw">
        <comment>analog_iis_pll_APLL_CTRL2</comment>
        <bits access="rw" name="analog_iis_pll_apll_ol_div2" pos="13:11" rst="0x7"/>
        <bits access="rw" name="analog_iis_pll_apll_div_s" pos="10" rst="0x1"/>
        <bits access="rw" name="analog_iis_pll_apll_sdm_en" pos="9" rst="0x1"/>
        <bits access="rw" name="analog_iis_pll_apll_mod_en" pos="8" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_divn" pos="7:5" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_hop_en" pos="4" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_hop_trig" pos="3" rst="0x0"/>
        <bits access="r" name="analog_iis_pll_apll_lock_done" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_rst" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_pd" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_iis_pll_apll_int_value" protect="rw">
        <comment>analog_iis_pll_APLL_INT_Value</comment>
        <bits access="rw" name="analog_iis_pll_apll_nint" pos="26:20" rst="0x25"/>
        <bits access="rw" name="analog_iis_pll_apll_kint" pos="19:0" rst="0xcf29c"/>
      </reg>
      <reg name="analog_iis_pll_apll_ccs_ctrl" protect="rw">
        <comment>analog_iis_pll_APLL_CCS_CTRL</comment>
        <bits access="rw" name="analog_iis_pll_apll_ccs_ctrl" pos="15:0" rst="0x92d"/>
      </reg>
      <reg name="analog_iis_pll_apll_kstep" protect="rw">
        <comment>analog_iis_pll_APLL_KSTEP</comment>
        <bits access="rw" name="analog_iis_pll_apll_kstep" pos="18:0" rst="0x19c"/>
      </reg>
      <reg name="analog_iis_pll_ana_bias" protect="rw">
        <comment>analog_iis_pll_ANA_BIAS</comment>
        <bits access="rw" name="analog_iis_pll_apll_bias_top" pos="16:12" rst="0x9"/>
        <bits access="rw" name="analog_iis_pll_apll_bist_ctrl" pos="11:2" rst="0x3ff"/>
        <bits access="rw" name="analog_iis_pll_apll_bist_en" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_test_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_iis_pll_ana_bias1" protect="rw">
        <comment>analog_iis_pll_ANA_BIAS1</comment>
        <bits access="r" name="analog_iis_pll_apll_bist_cnt" pos="18:3" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_dutyfix" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_iis_pll_reg_sel_cfg_0" protect="rw">
        <comment>analog_iis_pll_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_iis_pll_apll_clkout_en" pos="4" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_iis_pll_apll_rst" pos="3" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_iis_pll_apll_pd" pos="2" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_iis_pll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_iis_pll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_efuse4k_efuse_pin_pw_ctl" protect="rw">
        <comment>analog_efuse4k_EFUSE_PIN_PW_CTL</comment>
        <bits access="rw" name="analog_efuse4k_efs_enk1" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_efuse4k_efs_enk2" pos="0" rst="0x1"/>
      </reg>
      <reg name="analog_efuse4k_reg_sel_cfg_0" protect="rw">
        <comment>analog_efuse4k_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_efuse4k_efs_enk1" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_efuse4k_efs_enk2" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_efuse2k_efuse_pin_pw_ctl" protect="rw">
        <comment>analog_efuse2k_EFUSE_PIN_PW_CTL</comment>
        <bits access="rw" name="analog_efuse2k_efs_enk1" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_efuse2k_efs_enk2" pos="0" rst="0x1"/>
      </reg>
      <reg name="analog_efuse2k_reg_sel_cfg_0" protect="rw">
        <comment>analog_efuse2k_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_efuse2k_efs_enk1" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_efuse2k_efs_enk2" pos="0" rst="0x0"/>
      </reg>
      <hole size="7296"/>
      <reg name="analog_apll_apll_ctrl1_set" protect="rw"/>
      <reg name="analog_apll_apll_ctrl2_set" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_apll_ana_bias_set" protect="rw"/>
      <reg name="analog_apll_ana_bias1_set" protect="rw"/>
      <reg name="analog_apll_reg_sel_cfg_0_set" protect="rw"/>
      <reg name="analog_mpll_apll_ctrl1_set" protect="rw"/>
      <reg name="analog_mpll_apll_ctrl2_set" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_mpll_ana_bias_set" protect="rw"/>
      <reg name="analog_mpll_ana_bias1_set" protect="rw"/>
      <reg name="analog_mpll_reg_sel_cfg_0_set" protect="rw"/>
      <reg name="analog_iis_pll_apll_ctrl1_set" protect="rw"/>
      <reg name="analog_iis_pll_apll_ctrl2_set" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_iis_pll_ana_bias_set" protect="rw"/>
      <reg name="analog_iis_pll_ana_bias1_set" protect="rw"/>
      <reg name="analog_iis_pll_reg_sel_cfg_0_set" protect="rw"/>
      <reg name="analog_efuse4k_efuse_pin_pw_ctl_set" protect="rw"/>
      <reg name="analog_efuse4k_reg_sel_cfg_0_set" protect="rw"/>
      <reg name="analog_efuse2k_efuse_pin_pw_ctl_set" protect="rw"/>
      <reg name="analog_efuse2k_reg_sel_cfg_0_set" protect="rw"/>
      <hole size="7296"/>
      <reg name="analog_apll_apll_ctrl1_clr" protect="rw"/>
      <reg name="analog_apll_apll_ctrl2_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_apll_ana_bias_clr" protect="rw"/>
      <reg name="analog_apll_ana_bias1_clr" protect="rw"/>
      <reg name="analog_apll_reg_sel_cfg_0_clr" protect="rw"/>
      <reg name="analog_mpll_apll_ctrl1_clr" protect="rw"/>
      <reg name="analog_mpll_apll_ctrl2_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_mpll_ana_bias_clr" protect="rw"/>
      <reg name="analog_mpll_ana_bias1_clr" protect="rw"/>
      <reg name="analog_mpll_reg_sel_cfg_0_clr" protect="rw"/>
      <reg name="analog_iis_pll_apll_ctrl1_clr" protect="rw"/>
      <reg name="analog_iis_pll_apll_ctrl2_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_iis_pll_ana_bias_clr" protect="rw"/>
      <reg name="analog_iis_pll_ana_bias1_clr" protect="rw"/>
      <reg name="analog_iis_pll_reg_sel_cfg_0_clr" protect="rw"/>
      <reg name="analog_efuse4k_efuse_pin_pw_ctl_clr" protect="rw"/>
      <reg name="analog_efuse4k_reg_sel_cfg_0_clr" protect="rw"/>
      <reg name="analog_efuse2k_efuse_pin_pw_ctl_clr" protect="rw"/>
      <reg name="analog_efuse2k_reg_sel_cfg_0_clr" protect="rw"/>
    </module>
    <var name="REG_ANALOG_G1_SET_OFFSET" value="0x400"/>
    <var name="REG_ANALOG_G1_CLR_OFFSET" value="0x800"/>
    <instance address="0x51501000" name="ANALOG_G1" type="ANALOG_G1"/>
  </archive>
  <archive relative="analog_g2.xml">
    <module category="System" name="ANALOG_G2">
      <reg name="analog_usb20_usb20_test_pin" protect="rw">
        <comment>analog_usb20_USB20_TEST_PIN</comment>
        <bits access="rw" name="analog_usb20_usb20_testclk" pos="24" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_testdatain" pos="23:16" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_testaddr" pos="15:12" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_testdataoutsel" pos="11" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_testdataout" pos="10:7" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bist_mode" pos="6:2" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_t2rcomp" pos="1" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_lpbk_end" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_usb20_usb20_utmi_ctl1" protect="rw">
        <comment>analog_usb20_USB20_UTMI_CTL1</comment>
        <bits access="rw" name="analog_usb20_usb20_databus16_8" pos="28" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_suspendm" pos="27" rst="0x1"/>
        <bits access="rw" name="analog_usb20_usb20_porn" pos="26" rst="0x1"/>
        <bits access="rw" name="analog_usb20_usb20_reset" pos="25" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_rxerror" pos="24" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bypass_drv_dp" pos="23" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bypass_drv_dm" pos="22" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bypass_fs" pos="21" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bypass_in_dp" pos="20" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bypass_in_dm" pos="19" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_bypass_out_dp" pos="18" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_bypass_out_dm" pos="17" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_vbusvldext" pos="16" rst="0x1"/>
      </reg>
      <reg name="analog_usb20_usb20_batter_pll" protect="rw">
        <comment>analog_usb20_USB20_BATTER_PLL</comment>
        <bits access="rw" name="analog_usb20_usb20_rextenable" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_dmpullup" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_sampler_sel" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_usb20_usb20_utmi_ctl2" protect="rw">
        <comment>analog_usb20_USB20_UTMI_CTL2</comment>
        <bits access="rw" name="analog_usb20_usb20_dppulldown" pos="4" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_dmpulldown" pos="3" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_txbitstuffenable" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_txbitstuffenableh" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_sleepm" pos="0" rst="0x1"/>
      </reg>
      <reg name="analog_usb20_usb20_trimming" protect="rw">
        <comment>analog_usb20_USB20_TRIMMING</comment>
        <bits access="rw" name="analog_usb20_usb20_tunehsamp" pos="28:27" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_tfregres" pos="26:21" rst="0x1f"/>
        <bits access="rw" name="analog_usb20_usb20_tfhsres" pos="20:16" rst="0xf"/>
        <bits access="rw" name="analog_usb20_usb20_tunerise" pos="15:14" rst="0x1"/>
        <bits access="rw" name="analog_usb20_usb20_tuneotg" pos="13:11" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_tunedsc" pos="10:9" rst="0x1"/>
        <bits access="rw" name="analog_usb20_usb20_tunesq" pos="8:5" rst="0x8"/>
        <bits access="rw" name="analog_usb20_usb20_tuneeq" pos="4:2" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_tuneplls" pos="1:0" rst="0x1"/>
      </reg>
      <reg name="analog_usb20_reg_sel_cfg_0" protect="rw">
        <comment>analog_usb20_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_suspendm" pos="11" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_porn" pos="10" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_reset" pos="9" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_bypass_drv_dm" pos="8" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_bypass_fs" pos="7" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_bypass_in_dm" pos="6" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_rextenable" pos="5" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_dmpullup" pos="4" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_sampler_sel" pos="3" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_dppulldown" pos="2" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_dmpulldown" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_sleepm" pos="0" rst="0x0"/>
      </reg>
      <hole size="8000"/>
      <reg name="analog_usb20_usb20_test_pin_set" protect="rw"/>
      <reg name="analog_usb20_usb20_utmi_ctl1_set" protect="rw"/>
      <reg name="analog_usb20_usb20_batter_pll_set" protect="rw"/>
      <reg name="analog_usb20_usb20_utmi_ctl2_set" protect="rw"/>
      <hole size="32"/>
      <reg name="analog_usb20_reg_sel_cfg_0_set" protect="rw"/>
      <hole size="8000"/>
      <reg name="analog_usb20_usb20_test_pin_clr" protect="rw"/>
      <reg name="analog_usb20_usb20_utmi_ctl1_clr" protect="rw"/>
      <reg name="analog_usb20_usb20_batter_pll_clr" protect="rw"/>
      <reg name="analog_usb20_usb20_utmi_ctl2_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="analog_usb20_reg_sel_cfg_0_clr" protect="rw"/>
    </module>
    <var name="REG_ANALOG_G2_SET_OFFSET" value="0x400"/>
    <var name="REG_ANALOG_G2_CLR_OFFSET" value="0x800"/>
    <instance address="0x5150f000" name="ANALOG_G2" type="ANALOG_G2"/>
  </archive>
  <archive relative="analog_g3.xml">
    <module category="System" name="ANALOG_G3">
      <reg name="analog_osc_26m_apll_ctrl" protect="rw">
        <comment>analog_osc_26m_APLL_CTRL</comment>
        <bits access="rw" name="analog_osc_26m_osc26m_pu" pos="8" rst="0x0"/>
        <bits access="rw" name="analog_osc_26m_osc26m_r_tune" pos="7:4" rst="0x8"/>
        <bits access="rw" name="analog_osc_26m_osc26m_c_tune" pos="3:1" rst="0x4"/>
        <bits access="rw" name="analog_osc_26m_osc26m_ibas_ctrl" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_osc_26m_reg_sel_cfg_0" protect="rw">
        <comment>analog_osc_26m_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_osc_26m_osc26m_pu" pos="0" rst="0x0"/>
      </reg>
      <hole size="8128"/>
      <reg name="analog_osc_26m_apll_ctrl_set" protect="rw"/>
      <reg name="analog_osc_26m_reg_sel_cfg_0_set" protect="rw"/>
      <hole size="8128"/>
      <reg name="analog_osc_26m_apll_ctrl_clr" protect="rw"/>
      <reg name="analog_osc_26m_reg_sel_cfg_0_clr" protect="rw"/>
    </module>
    <var name="REG_ANALOG_G3_SET_OFFSET" value="0x400"/>
    <var name="REG_ANALOG_G3_CLR_OFFSET" value="0x800"/>
    <instance address="0x51709000" name="ANALOG_G3" type="ANALOG_G3"/>
  </archive>
  <archive relative="aon_clk.xml">
    <module category="System" name="AON_CLK">
      <hole size="288"/>
      <reg name="cgm_aon_ahb_div_cfg" protect="rw">
        <comment>cgm_aon_ahb_div_cfg</comment>
        <bits access="rw" name="cgm_aon_ahb_div" pos="1:0" rst="0x0">
          <comment>cgm_aon_ahb_div: clk_aon_ahb = clk_src/(div +1), default value = 2'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_aon_ahb_sel_cfg" protect="rw">
        <comment>cgm_aon_ahb_sel_cfg</comment>
        <bits access="rw" name="cgm_aon_ahb_sel" pos="2:0" rst="0x1">
          <comment>cgm_aon_ahb_sel: clk_aon_ahb source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: apll_100m, 4: gnss_pll_133m, 5: apll_167m, 6: gnss_pll_198m, 7: apll_200m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_uart2_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart2_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart2_bf_div_sel" pos="2:0" rst="0x1">
          <comment>cgm_uart2_bf_div_sel: clk_uart2_bf_div source , 0: rtc_32k, 1: xtal_lp_26m, 2: xtal_26m, 3: rc26m_78m, 4: apll_31_25m, 5: apll_125m, 6: gnss_pll_133m, 7: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_uart3_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart3_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart3_bf_div_sel" pos="2:0" rst="0x1">
          <comment>cgm_uart3_bf_div_sel: clk_uart3_bf_div source , 0: rtc_32k, 1: xtal_lp_26m, 2: xtal_26m, 3: rc26m_78m, 4: apll_31_25m, 5: apll_125m, 6: gnss_pll_133m, 7: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_debug_host_bf_div_sel_cfg" protect="rw">
        <comment>cgm_debug_host_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_debug_host_bf_div_sel" pos="1:0" rst="0x1">
          <comment>cgm_debug_host_bf_div_sel: clk_debug_host_bf_div source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, default: 2'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_audio_div_cfg" protect="rw">
        <comment>cgm_audio_div_cfg</comment>
        <bits access="rw" name="cgm_audio_div" pos="3:0" rst="0x0">
          <comment>cgm_audio_div: clk_audio = clk_src/(div +1), default value = 4'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_audio_sel_cfg" protect="rw">
        <comment>cgm_audio_sel_cfg</comment>
        <bits access="rw" name="cgm_audio_sel" pos="2:0" rst="0x0">
          <comment>cgm_audio_sel: clk_audio source , 0: xtal_26m, 1: rc26m_78m, 2: audio_pll_30_72m, 3: apll_31_25m, 4: gnss_pll_33_25m, 5: apll_62_5m, default: 3'h0</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_codec_mclock_div_cfg" protect="rw">
        <comment>cgm_codec_mclock_div_cfg</comment>
        <bits access="rw" name="cgm_codec_mclock_div" pos="3:0" rst="0x0">
          <comment>cgm_codec_mclock_div: clk_codec_mclock = clk_src/(div +1), default value = 4'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_codec_mclock_sel_cfg" protect="rw">
        <comment>cgm_codec_mclock_sel_cfg</comment>
        <bits access="rw" name="cgm_codec_mclock_sel" pos="2:0" rst="0x0">
          <comment>cgm_codec_mclock_sel: clk_codec_mclock source , 0: xtal_26m, 1: rc26m_78m, 2: audio_pll_30_72m, 3: apll_31_25m, 4: gnss_pll_33_25m, 5: apll_62_5m, default: 3'h0</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_i2s_bck_bf_div_div_cfg" protect="rw">
        <comment>cgm_i2s_bck_bf_div_div_cfg</comment>
        <bits access="rw" name="cgm_i2s_bck_bf_div_div" pos="11:0" rst="0xf">
          <comment>cgm_i2s_bck_bf_div_div: clk_i2s_bck_bf_div = clk_src/(div +1), default value = 12'hf</comment>
        </bits>
      </reg>
      <reg name="cgm_i2s_bck_bf_div_sel_cfg" protect="rw">
        <comment>cgm_i2s_bck_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_i2s_bck_bf_div_pad_sel" pos="16" rst="0x0">
          <comment>cgm_i2s_bck_bf_div_pad_sel: reserved, no use.</comment>
        </bits>
        <bits access="rw" name="cgm_i2s_bck_bf_div_sel" pos="2:0" rst="0x0">
          <comment>cgm_i2s_bck_bf_div_sel: clk_i2s_bck_bf_div source , 0: xtal_26m, 1: rc26m_78m, 2: gnss_pll_133m, 3: audio_pll_122_88m, 4: apll_167m, default: 3'h0</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_out_div_cfg" protect="rw">
        <comment>cgm_out_div_cfg</comment>
        <bits access="rw" name="cgm_out_div" pos="7:0" rst="0x0">
          <comment>cgm_out_div: clk_out = clk_src/(div +1), default value = 8'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_out_sel_cfg" protect="rw">
        <comment>cgm_out_sel_cfg</comment>
        <bits access="rw" name="cgm_out_sel" pos="2:0" rst="0x1">
          <comment>cgm_out_sel: clk_out source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: audio_pll_122_88m, 4: gnss_pll_133m, 5: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_efuse_sel_cfg" protect="rw">
        <comment>cgm_efuse_sel_cfg</comment>
        <bits access="rw" name="cgm_efuse_sel" pos="1:0" rst="0x1">
          <comment>cgm_efuse_sel: clk_efuse source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, default: 2'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_adi_sel_cfg" protect="rw">
        <comment>cgm_adi_sel_cfg</comment>
        <bits access="rw" name="cgm_adi_sel" pos="1:0" rst="0x1">
          <comment>cgm_adi_sel: clk_adi source , 0: rtc_32k, 1: xtal_lp_26m, 2: xtal_26m, 3: rc26m_78m, default: 2'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_dap_sel_cfg" protect="rw">
        <comment>cgm_dap_sel_cfg</comment>
        <bits access="rw" name="cgm_dap_sel" pos="2:0" rst="0x1">
          <comment>cgm_dap_sel: clk_dap source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: gnss_pll_133m, 4: apll_200m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="352"/>
      <reg name="cgm_djtag_tck_sel_cfg" protect="rw">
        <comment>cgm_djtag_tck_sel_cfg</comment>
        <bits access="rw" name="cgm_djtag_tck_pad_sel" pos="16" rst="0x0">
          <comment>cgm_djtag_tck_pad_sel: clock source from pad, high active, default: 1'h0</comment>
        </bits>
        <bits access="rw" name="cgm_djtag_tck_sel" pos="0" rst="0x0">
          <comment>cgm_djtag_tck_sel: clk_djtag_tck source , 0: rtc_32k, 1: xtal_26m, default: 1'h0</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_swcgm_hw_sel_cfg" protect="rw">
        <comment>cgm_swcgm_hw_sel_cfg</comment>
        <bits access="rw" name="cgm_swcgm_hw_pad_sel" pos="16" rst="0x0">
          <comment>cgm_swcgm_hw_pad_sel: clock source from pad, high active, default: 1'h0</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_gpt2_sel_cfg" protect="rw">
        <comment>cgm_gpt2_sel_cfg</comment>
        <bits access="rw" name="cgm_gpt2_sel" pos="2:0" rst="0x1">
          <comment>cgm_gpt2_sel: clk_gpt2 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: gnss_pll_133m, 4: apll_200m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_i2c3_sel_cfg" protect="rw">
        <comment>cgm_i2c3_sel_cfg</comment>
        <bits access="rw" name="cgm_i2c3_sel" pos="2:0" rst="0x1">
          <comment>cgm_i2c3_sel: clk_i2c3 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: gnss_pll_133m, 4: apll_200m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="cgm_usb_ref_sel_cfg" protect="rw">
        <comment>cgm_usb_ref_sel_cfg</comment>
        <bits access="rw" name="cgm_usb_ref_sel" pos="0" rst="0x1">
          <comment>cgm_usb_ref_sel: clk_usb_ref source , 0: rtc_32k, 1: xtal_26m, default: 1'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_usb_ahb_div_cfg" protect="rw">
        <comment>cgm_usb_ahb_div_cfg</comment>
        <bits access="rw" name="cgm_usb_ahb_div" pos="1:0" rst="0x0">
          <comment>cgm_usb_ahb_div: clk_usb_ahb = clk_src/(div +1), default value = 2'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_usb_ahb_sel_cfg" protect="rw">
        <comment>cgm_usb_ahb_sel_cfg</comment>
        <bits access="rw" name="cgm_usb_ahb_sel" pos="2:0" rst="0x1">
          <comment>cgm_usb_ahb_sel: clk_usb_ahb source , 0: rtc_32k, 1: xtal_26m, 2: apll_125m, 3: gnss_pll_133m, 4: apll_167m, 5: apll_200m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_spi2_div_cfg" protect="rw">
        <comment>cgm_spi2_div_cfg</comment>
        <bits access="rw" name="cgm_spi2_div" pos="2:0" rst="0x0">
          <comment>cgm_spi2_div: clk_spi2 = clk_src/(div +1), default value = 3'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_spi2_sel_cfg" protect="rw">
        <comment>cgm_spi2_sel_cfg</comment>
        <bits access="rw" name="cgm_spi2_pad_sel" pos="16" rst="0x0">
          <comment>cgm_spi2_pad_sel: clock source from pad, high active, default: 1'h0</comment>
        </bits>
        <bits access="rw" name="cgm_spi2_sel" pos="2:0" rst="0x1">
          <comment>cgm_spi2_sel: clk_spi2 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: gnss_pll_133m, 4: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_scc_sel_cfg" protect="rw">
        <comment>cgm_scc_sel_cfg</comment>
        <bits access="rw" name="cgm_scc_pad_sel" pos="16" rst="0x1">
          <comment>cgm_scc_pad_sel: clock source from pad, high active, default: 1'h0</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_sdio_2x_div_cfg" protect="rw">
        <comment>cgm_sdio_2x_div_cfg</comment>
        <bits access="rw" name="cgm_sdio_2x_div" pos="10:0" rst="0x0">
          <comment>cgm_sdio_2x_div: reserved, no use.</comment>
        </bits>
      </reg>
      <reg name="cgm_sdio_2x_sel_cfg" protect="rw">
        <comment>cgm_sdio_2x_sel_cfg</comment>
        <bits access="rw" name="cgm_sdio_2x_sel" pos="2:0" rst="0x0">
          <comment>cgm_sdio_2x_sel: clk_sdio_2x source , 0: xtal_26m, 1: rc26m_78m, 2: apll_333m, 3: gnss_pll_397m, 4: apll_400m, default: 3'h0</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_sdio_1x_div_cfg" protect="rw">
        <comment>cgm_sdio_1x_div_cfg</comment>
        <bits access="rw" name="cgm_sdio_1x_div" pos="0" rst="0x1">
          <comment>cgm_sdio_1x_div: clk_sdio_1x = clk_src/(div +1), default value = 1'h1</comment>
        </bits>
      </reg>
      <hole size="608"/>
      <reg name="cgm_busy_src_monitor_cfg0" protect="rw">
        <comment>cgm_busy_src_monitor_cfg0</comment>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg1" protect="rw">
        <comment>cgm_busy_src_monitor_cfg1</comment>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg2" protect="rw">
        <comment>cgm_busy_src_monitor_cfg2</comment>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg3" protect="rw">
        <comment>cgm_busy_src_monitor_cfg3</comment>
      </reg>
    </module>
    <instance address="0x51508800" name="AON_CLK" type="AON_CLK"/>
  </archive>
  <archive relative="aon_spi.xml">
    <module category="System" name="AON_SPI">
      <reg name="spi_txd" protect="rw">
        <comment>Transmit word or Receive word Write data to this address initiates a character transmission through TX FIFO
Read this address retrieve data from RX fifo</comment>
      </reg>
      <reg name="spi_clkd" protect="rw">
        <comment>Clock divisor  Clock divisor bit 0 to 15</comment>
        <bits access="rw" name="spi_clkd" pos="15:0" rst="0x3">
          <comment>Specify the clock ratio between spi_sck and clk_spi.
If clk_spi runs at 48 MHz, and spi_sck runs at 12MHz, SPI_CLKD should be 1,
spi_sck = clk_spi/2(n+1).
If IS_FST bit is assert, the valid SPI_CLKD is 0, 1, 2 and 3.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl0" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="sync_3wrd_pol" pos="15" rst="0x0">
          <comment>Sync_polarity, positive or negative pulse for SPI or 3-wire mode ,read command polarity</comment>
        </bits>
        <bits access="rw" name="sync_md" pos="14" rst="0x0">
          <comment>“1” : sync mode</comment>
        </bits>
        <bits access="rw" name="is_sck_rev" pos="13" rst="0x0">
          <comment>“1” : spi_sck reverse</comment>
        </bits>
        <bits access="rw" name="spi_csn_pre" pos="11:8" rst="0xf">
          <comment>1 bit chip select.
“0”: cs0 is valid
“1”: cs0 is invalid</comment>
        </bits>
        <bits access="rw" name="lsb" pos="7" rst="0x0">
          <comment>In default, The input data is shifted high order first into the chip; the output data is shifted out high order first from the Most Significant Bit (MSB) on SO. When this bit is set, the data will be shift out or in from the LSB</comment>
        </bits>
        <bits access="rw" name="chnl_len" pos="6:2" rst="0x0">
          <comment>Transmit data bit number.
“0” : 32 bits per word
“1” : 1 bits per word
…
“31”: 31 bits per word</comment>
        </bits>
        <bits access="rw" name="ng_tx" pos="1" rst="0x1">
          <comment>“1” enable TX data shift out at clock neg-edge</comment>
        </bits>
        <bits access="rw" name="ng_rx" pos="0" rst="0x0">
          <comment>“1” enable RX data shift in at clock neg-edge</comment>
        </bits>
      </reg>
      <reg name="spi_ctl1" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="do_hold_en" pos="15:14" rst="0x0">
          <comment>“00” : default(follow before version)
“01” : spi do stay 0 value when in idle
“10” : spi do stay 1 value when in idle
“11” : spi do stay last-bit value when in idle</comment>
        </bits>
        <bits access="rw" name="is_txmd" pos="13" rst="0x1">
          <comment>1:is tx mode 0:not tx mode</comment>
        </bits>
        <bits access="rw" name="is_rxmd" pos="12" rst="0x1">
          <comment>1:is rx mode 0:not rx mode</comment>
        </bits>
        <bits access="rw" name="sync_csn_sel" pos="11:8" rst="0x0">
          <comment>S8 CD or SYNC signal maps to csn number
“0x0001” selects csn0 as cd signal
“0x0010” selects csn1 as cd signal
In SPI_HS it must be 0x0000 and disable sync and s8 mode</comment>
        </bits>
        <bits access="rw" name="s8_md" pos="7" rst="0x0">
          <comment>“1” : enable S8 mode</comment>
        </bits>
        <bits access="rw" name="cs_h_md" pos="6" rst="0x0">
          <comment>3-wire Melody timing 1, csn high mode enable</comment>
        </bits>
        <bits access="rw" name="s3w_md" pos="5" rst="0x0">
          <comment>“1” : enable 3-wire mode</comment>
        </bits>
        <bits access="rw" name="s3w_pos" pos="4:0" rst="0x0">
          <comment>3-wire mode, w/r control position
or the sync pulse position(the pulse will
locates on top of bit N)</comment>
        </bits>
      </reg>
      <reg name="spi_ctl2" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="dma_req_seq_sel" pos="10" rst="0x0">
          <comment>0:DMA TX and RX REQ independent
1:DMA TX REQ are depended on RX REQ status</comment>
        </bits>
        <bits access="rw" name="tx_dma_sel" pos="9" rst="0x0">
          <comment>0: tx_dma_req keep 1 until receiving the tx_dma_ack
1: tx_dma_req is “1” when tx_empty is “1”,else “0”</comment>
        </bits>
        <bits access="rw" name="rx_dma_sel" pos="8" rst="0x0">
          <comment>0: rx_dma_req keep 1 until receiving the rx_dma_ack
1: rx_dma_req is “1” when rx_full is “1”,else “0”</comment>
        </bits>
        <bits access="rw" name="rx_only_nhd" pos="7" rst="0x0">
          <comment>“0” : working on only receive
mode, when rxf_realfull is high, SPI will be held until rxf_realfull is low
“1” : no holding</comment>
        </bits>
        <bits access="rw" name="dma_en" pos="6" rst="0x0">
          <comment>“1” enable DMA mode</comment>
        </bits>
        <bits access="rw" name="is_slvd" pos="5" rst="0x0">
          <comment>“0” : master
“1” : slave, only support microplus mode</comment>
        </bits>
        <bits access="rw" name="s3w_rd_strt" pos="4:0" rst="0x0">
          <comment>Read data start bit, used for 3 wire mode and 3 wire 9bit RW mode.
The 3 wire 9bit RW mode reuse this config registers, it indicated read data start position.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl3" protect="rw">
        <comment>RXF watermark  SPI RX FIFO FULL/EMPTY watermark</comment>
        <bits access="rw" name="rxf_empty_thrhld" pos="12:8" rst="0x10">
          <comment>Receive FIFO data empty threshold. Relative with rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="rw" name="rxf_full_thrhld" pos="4:0" rst="0x10">
          <comment>Receive FIFO data full threshold. Relative with rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_ctl4" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="rx_only_do" pos="15" rst="0x0">
          <comment>working in only receive mode,
“0” : SPI send all 0 to slave
“1” : SPI send all 1 to slave</comment>
        </bits>
        <bits access="rw" name="is_fst" pos="14" rst="0x0">
          <comment>working in only receive mode,
“0” : SPI send all 0 to slave
“1” : SPI send all 1 to slave</comment>
        </bits>
        <bits access="rw" name="phs_dly" pos="13:12" rst="0x0">
          <comment>“0” : normal mode
“1” : fast mode
Both for matser mode and slave mode,and in master mode SPI_SCK must be quicker  than 1/8 spi_clk</comment>
        </bits>
        <bits access="rw" name="sync_clkmask_en" pos="11" rst="0x0">
          <comment>Phase delay. Relate to fast mode.
When in normal mode, this bit is not used . Only used for slave mode</comment>
        </bits>
        <bits access="rw" name="sync_half" pos="10" rst="0x0">
          <comment>“1” Mask out the first clock pulse in SPI mode</comment>
        </bits>
        <bits access="rw" name="is_rx_only" pos="9" rst="0x0">
          <comment>Sync_half, sync width is half  spi_sck cycle</comment>
        </bits>
        <bits access="rw" name="block_num" pos="8:0" rst="0x0">
          <comment>Number of data words ready to receive in “receive only” mode. Only used for master mode.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl5" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="itvl_num_sam" pos="15:0" rst="0x0">
          <comment>For master, transmit data interval, programmable n from 0 to 65535, delay is (n*4+3) clock cycle.
For slave, max receive data interval. If the slave has not sampled the edge of spi_clk in the interval(n*4+3), slave will stop the receive process and send timout interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_int_en" protect="rw">
        <comment>Interrupt enable  SPI interrupt enable register</comment>
        <bits access="rw" name="rx_end_int_en" pos="9" rst="0x0">
          <comment>Rx end interrupt enable</comment>
        </bits>
        <bits access="rw" name="tx_end_int_en" pos="8" rst="0x0">
          <comment>Tx end interrupt enable</comment>
        </bits>
        <bits access="rw" name="txf_w_empty_int_en" pos="7" rst="0x0">
          <comment>txf_empty interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_r_full_int_en" pos="6" rst="0x0">
          <comment>Rxf_full interrupt enable</comment>
        </bits>
        <bits access="rw" name="time_out_int_en" pos="5" rst="0x0">
          <comment>Slave mode timeout interrupt enable</comment>
        </bits>
        <bits access="rw" name="rx_ovf_int_en" pos="4" rst="0x0">
          <comment>Rx_overrun_reg interrupt enable</comment>
        </bits>
        <bits access="rw" name="txf_empty_en" pos="3" rst="0x0"/>
        <bits access="rw" name="txf_full_int_en" pos="2" rst="0x0">
          <comment>Tx_fifo_full interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_empty_int_en" pos="1" rst="0x0">
          <comment>Rx_fifo_empty interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_full_int_en" pos="0" rst="0x0">
          <comment>Rx_fifo_full interrupt enable</comment>
        </bits>
      </reg>
      <reg name="spi_int_clr" protect="rw">
        <comment>Interrupt clear SPI interrupt clear register</comment>
        <bits access="w" name="rx_end_int_clr" pos="9" rst="0x0">
          <comment>Rx data end interrupt clear</comment>
        </bits>
        <bits access="w" name="tx_end_int_clr" pos="8" rst="0x0">
          <comment>Tx data end interrupt clear</comment>
        </bits>
        <bits access="w" name="time_out_int_clr" pos="5" rst="0x0">
          <comment>Write “1” clear slave mode timeout interrupt</comment>
        </bits>
        <bits access="w" name="rx_ovf_int_clr" pos="4" rst="0x0">
          <comment>Write “1” clear Rx_overrun_reg interrupt</comment>
        </bits>
        <bits access="w" name="txf_empty_int_clr" pos="3" rst="0x0">
          <comment>Write “1” clear Tx_fifo_empty interrupt</comment>
        </bits>
        <bits access="w" name="txf_full_int_clr" pos="2" rst="0x0">
          <comment>Write “1” clear Tx_fifo_full interrupt</comment>
        </bits>
        <bits access="w" name="rxf_empty_int_clr" pos="1" rst="0x0">
          <comment>Write “1” clear Rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="w" name="rxf_full_int_clr" pos="0" rst="0x0">
          <comment>Write “1” clear Rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_int_raw_sts" protect="rw">
        <comment>Raw status  SPI interrupt raw status</comment>
        <bits access="r" name="rx_end_irq" pos="9" rst="0x0">
          <comment>Raw rx data end interrupt, this bit is set when spi controller received RX_DATA_LEN data from slave.</comment>
        </bits>
        <bits access="r" name="tx_end_irq" pos="8" rst="0x0">
          <comment>Raw tx data end interrupt,this bit is set when spi controller send TX_DATA_LEN data.</comment>
        </bits>
        <bits access="r" name="txf_empty_w" pos="7" rst="0x1">
          <comment>Raw txf_empty interrupt, This bit is set when the number of tx fifo data byte is less than the tx empty watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_full_r" pos="6" rst="0x0">
          <comment>Raw rxf_full interrupt.This bit is set when the number of rx fifo data byte is larger than the rx full watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="time_out_raw_sts" pos="5" rst="0x0">
          <comment>Raw slave mode time out interrupt</comment>
        </bits>
        <bits access="r" name="rx_ovf_raw_sts" pos="4" rst="0x0">
          <comment>Raw Rx_overrun_reg interrupt</comment>
        </bits>
        <bits access="r" name="tx_fifo_empty_w" pos="3" rst="0x1">
          <comment>Txf_empty_w(for debug)</comment>
        </bits>
        <bits access="r" name="txf_full_raw_sts" pos="2" rst="0x0">
          <comment>Raw Tx_fifo_full interrupt</comment>
        </bits>
        <bits access="r" name="rxf_empty_raw_sts" pos="1" rst="0x1">
          <comment>Raw rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="r" name="rx_full_raw_sts" pos="0" rst="0x0">
          <comment>Rxf_full_r(for debug)</comment>
        </bits>
      </reg>
      <reg name="spi_int_mask_sts" protect="rw">
        <comment>Mask status  SPI interrupt mask status</comment>
        <bits access="r" name="rx_end_irq_mask_sts" pos="9" rst="0x0">
          <comment>Raw rx data end interrupt, this bit is set when spi controller received RX_DATA_LEN data from slave.</comment>
        </bits>
        <bits access="r" name="tx_end_irq_mask_sts" pos="8" rst="0x0">
          <comment>Raw tx data end interrupt,this bit is set when spi controller send TX_DATA_LEN data.</comment>
        </bits>
        <bits access="r" name="txf_empty_mask_sts" pos="7" rst="0x1">
          <comment>Txf_empty interrupt mask status.</comment>
        </bits>
        <bits access="r" name="rxf_full_mask_sts" pos="6" rst="0x0">
          <comment>Rxf_full interrupt mask status.</comment>
        </bits>
        <bits access="r" name="time_out_mask_sts" pos="5" rst="0x0">
          <comment>Slave mode time out interrupt mask status</comment>
        </bits>
        <bits access="r" name="rx_ovf_mask_sts" pos="4" rst="0x0">
          <comment>Rx_overrun_reg interrupt mask status</comment>
        </bits>
        <bits access="r" name="txf_full_mask_sts" pos="2" rst="0x0">
          <comment>Tx_fifo_full interrupt mask status</comment>
        </bits>
        <bits access="r" name="rxf_empty_mask_sts" pos="1" rst="0x1">
          <comment>Rx_fifo_empty interrupt mask status</comment>
        </bits>
      </reg>
      <reg name="spi_sts1" protect="rw">
        <comment>RXF address  SPI RX FIFO write address and read address</comment>
        <bits access="r" name="rxf_waddr" pos="12:8" rst="0x0">
          <comment>RX FIFO write address</comment>
        </bits>
        <bits access="r" name="rxf_raddr" pos="4:0" rst="0x0">
          <comment>RX FIFO read address</comment>
        </bits>
      </reg>
      <reg name="spi_sts2" protect="rw">
        <comment>latch SPI status  SPI status register</comment>
        <bits access="r" name="spi_cs" pos="12" rst="0x0">
          <comment>Spi_cs(for debug)</comment>
        </bits>
        <bits access="r" name="spi_sck" pos="11" rst="0x0">
          <comment>Spi_sck(for debug)</comment>
        </bits>
        <bits access="r" name="spi_txd" pos="10" rst="0x0">
          <comment>Spi_txd(for debug)</comment>
        </bits>
        <bits access="r" name="spi_rxd" pos="9" rst="0x0">
          <comment>Spi_rxd(for debug)</comment>
        </bits>
        <bits access="r" name="busy" pos="8" rst="0x0">
          <comment>“1” transmit process
“0” idle state</comment>
        </bits>
        <bits access="r" name="txf_real_empty" pos="7" rst="0x1">
          <comment>TX FIFO has no data</comment>
        </bits>
        <bits access="r" name="txf_real_full" pos="6" rst="0x0">
          <comment>TX FIFO is real full. (not relates to TX full threshold)</comment>
        </bits>
        <bits access="r" name="rxf_real_empty" pos="5" rst="0x1">
          <comment>RX FIFO has no data</comment>
        </bits>
        <bits access="r" name="rxf_real_full" pos="4" rst="0x0">
          <comment>RX FIFO is real full. (not relates to TX full threshold)</comment>
        </bits>
        <bits access="r" name="txf_empty" pos="3" rst="0x1">
          <comment>This bit is set when the number of TX FIFO data byte is less than the TX empty interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="txf_full" pos="2" rst="0x0">
          <comment>This bit is set when the number of TX FIFO data byte is larger than the TX full interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_empty" pos="1" rst="0x1">
          <comment>This bit is set when the number of RX FIFO data byte is less than the RX empty interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_full" pos="0" rst="0x0">
          <comment>This bit is set when the number of RX FIFO data byte is larger than the RX full interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
      </reg>
      <reg name="spi_dspwait" protect="rw">
        <comment>DSP Register This register is used for DSP control</comment>
        <bits access="rw" name="tx_data_swt" pos="7:6" rst="0x0">
          <comment>Write data switch.
2’b0: WDATA=PDATA;
2’b1: WDATA={PDATA[7:0], PDATA[15:8], PDATA[23:16], PDATA[31:24]};
2’b2: WDATA={PDATA[15:0],PDATA[31:16]};
2’b3: WDATA={PDATA[23:16], PDATA[31:24], PDATA[7:0], PDATA[15:8]};</comment>
        </bits>
        <bits access="rw" name="rx_data_swt" pos="5:4" rst="0x0">
          <comment>Read data switch.
2’b0: RDATA=PDATA;
2’b1: RDATA={PDATA[7:0], PDATA[15:8], PDATA[23:16], PDATA[31:24]};
2’b2: RDATA={PDATA[15:0],PDATA[31:16]};</comment>
        </bits>
        <bits access="rw" name="spi_dspwait" pos="3:0" rst="0x1">
          <comment>This register is used for DSP control</comment>
        </bits>
      </reg>
      <reg name="spi_sts3" protect="rw">
        <comment>RX conunter monitor This register is used to observe the status</comment>
        <bits access="r" name="rx_cnt" pos="8:0" rst="0x0">
          <comment>working in only receive mode
as master</comment>
        </bits>
      </reg>
      <reg name="spi_ctl6" protect="rw">
        <comment>TXF configuration This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="txf_empty_thrhld" pos="12:8" rst="0x10">
          <comment>TX FIFO data empty threshold. Relative with rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="rw" name="txf_full_thrhld" pos="4:0" rst="0x10">
          <comment>TX FIFO data full threshold. Relative with rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_sts4" protect="rw">
        <comment>TXF address This register is used to configuration of the SPI interface</comment>
        <bits access="r" name="txf_waddr" pos="12:8" rst="0x0">
          <comment>TX FIFO write address</comment>
        </bits>
        <bits access="r" name="txf_raddr" pos="4:0" rst="0x0">
          <comment>TX FIFO read address</comment>
        </bits>
      </reg>
      <reg name="spi_fifo_rst" protect="rw">
        <comment>FIFO reset configuration Used to reset TX/RX FIFO</comment>
        <bits access="rw" name="spi_fifo_rst" pos="0" rst="0x0">
          <comment>“1” : reset all FIFOs. FIFO address will changed to 0</comment>
        </bits>
      </reg>
      <reg name="spi_ctl7" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="data_line2_en" pos="15" rst="0x0">
          <comment>1: two data line function enable
0: two data line function disable</comment>
        </bits>
        <bits access="rw" name="rgb565_en" pos="14" rst="0x0">
          <comment>1: enable RGB565 data format
0: disable RGB565 data format</comment>
        </bits>
        <bits access="rw" name="rgb666_en" pos="13" rst="0x0">
          <comment>1: enable RGB666 data format
0: disable RGB666 data format</comment>
        </bits>
        <bits access="rw" name="rgb888_en" pos="12" rst="0x0">
          <comment>1: enable RGB888 data format
0: disable RGB888 data format</comment>
        </bits>
        <bits access="rw" name="spi_slv_sel" pos="11" rst="0x0">
          <comment>1: SPI slave in Low speed mode
0: SPI slave in High speed mode</comment>
        </bits>
        <bits access="rw" name="spi_slv_en" pos="10" rst="0x0">
          <comment>Used when SPI slave in High speed mode.
1: enable spi slave rtx
0: disable spi slave rtx</comment>
        </bits>
        <bits access="rw" name="data_in_mode" pos="9" rst="0x0">
          <comment>Use for 3 wire 9bit RW mode and 4 wire 8bit RW mode (SPI_MODE=5 or SPI_MODE=6).
0: Data in and data out of SPI share one IO (SDA).
1: Data in and data out of SPI use separated IO (SDI, SDO).</comment>
        </bits>
        <bits access="rw" name="spi_rx_hld_en" pos="8" rst="0x0">
          <comment>1: enable ahb2apb bridge read hold when rx fifo empty
0: disable ahb2apb bridge read hold</comment>
        </bits>
        <bits access="rw" name="spi_tx_hld_en" pos="7" rst="0x0">
          <comment>1: enable ahb2apb bridge write hold when tx fifo full
0: disable ahb2apb bridge write hold</comment>
        </bits>
        <bits access="rw" name="tx_cmd_set" pos="6" rst="0x0">
          <comment>1: select fmark as the dma request
0: select software dma request</comment>
        </bits>
        <bits access="rw" name="spi_mode" pos="5:3" rst="0x0">
          <comment>Used for master only
0: SPI_MODE disable
1: 3 wire 9 bit, cd bit, SDI/SDO share  one IO
2: 3 wire 9 bit, cd bit, SDI, SDO
3: 4 wire 8 bit, cd pin, SDI/SDO share one IO
4: 4 wire 8 bit, cd pin, SDI, SDO
5: 3 wire 9bit RW mode, 9 bit command and 8 bit read data, cd bit is enable. Design for LCD driver.
6: 4 wire 8bit RW mode, 8bit command and 8 bit read data. Use CD PAD indicates command or data. Design for LCD driver.</comment>
        </bits>
        <bits access="rw" name="csn_i_sel" pos="2:1" rst="0x0">
          <comment>CSN select control:
0: CSN 0
1: CSN 1
2: CSN 2
3: CSN 3</comment>
        </bits>
        <bits access="rw" name="csn_ie_ctl" pos="0" rst="0x0">
          <comment>CSN IE output set(only slave)
0: not support csn input
1: support csn intput</comment>
        </bits>
      </reg>
      <reg name="spi_sts5" protect="rw">
        <comment>Statue Register Used to observe csn error</comment>
        <bits access="r" name="csn_in_err_sync2" pos="4" rst="0x0">
          <comment>1: indicates csn occurring a exception</comment>
        </bits>
        <bits access="r" name="csn_in_sync2" pos="0" rst="0x0">
          <comment>csn for slave</comment>
        </bits>
      </reg>
      <reg name="spi_ctl8" protect="rw">
        <comment>Configure Register Used for configure SPI interface</comment>
        <bits access="rw" name="spi_cd_bit" pos="15" rst="0x0">
          <comment>Spi tx cd bit:
0: indicates command
1: indicates data</comment>
        </bits>
        <bits access="rw" name="spi_cd_bit2" pos="14" rst="0x0">
          <comment>Use for 4 wire 8bit RW mode. Determine CD PAD high or low in read data phase.</comment>
        </bits>
        <bits access="rw" name="cd_data2_sel" pos="13" rst="0x0">
          <comment>Second data line of two data line function select bit:
0: CD PAD as second data line
1: DI PAD as second data line</comment>
        </bits>
        <bits access="rw" name="rgb_pix_mode" pos="12" rst="0x0">
          <comment>Two data line RGB data format mode:
0: 1pixel mode
1: 2/3 pixel mode</comment>
        </bits>
        <bits access="rw" name="data_line2_sw" pos="11" rst="0x0">
          <comment>2-data-line switch. Only valid in 2-data-line mode(DATA_LINE2_EN set to 1):
0: use spi_do as first data line,spi_di as second data line.
1: use spi_di as first data line, spi_do as second data line.</comment>
        </bits>
        <bits access="rw" name="spi_tx_dumy_len" pos="9:4" rst="0x0">
          <comment>Spi tx dummy clock length</comment>
        </bits>
        <bits access="rw" name="spi_tx_data_len_h" pos="3:0" rst="0x0">
          <comment>Indicates tx data length from tx fifo, High 4 bits of spi tx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl9" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="spi_tx_data_len_l" pos="15:0" rst="0x0">
          <comment>Indicates: spi tx data length from tx fifo, Low 16bit of tx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl10" protect="rw">
        <comment>Configure register SPI status register</comment>
        <bits access="rw" name="spi_rx_dumy_len" pos="9:4" rst="0x0">
          <comment>Spi rx dummy clock length</comment>
        </bits>
        <bits access="rw" name="spi_rx_data_len_h" pos="3:0" rst="0x0">
          <comment>Indicates receives data length from slave, high 4 bits of spi rx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl11" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="spi_rx_data_len_l" pos="15:0" rst="0x0">
          <comment>Indicates: spi receives data length from slave, Low 16bit of rx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl12" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="sw_tx_req" pos="1" rst="0x0">
          <comment>Software TX data request, for write LCD</comment>
        </bits>
        <bits access="rw" name="sw_rx_req" pos="0" rst="0x0">
          <comment>Software RX data request, for read LCD</comment>
        </bits>
      </reg>
      <reg name="spi_sts6" protect="rw">
        <comment>Statue Register Used to observe TX data counter</comment>
        <bits access="r" name="tx_data_cnt" pos="15:0" rst="0x0">
          <comment>Tx data cnt</comment>
        </bits>
      </reg>
      <reg name="spi_sts7" protect="rw">
        <comment>Statue Register Used to observe TX statue</comment>
        <bits access="r" name="tx_dummy_cnt" pos="15:10" rst="0x0">
          <comment>tx dummy counter</comment>
        </bits>
        <bits access="r" name="tx_data_cnt" pos="3:0" rst="0x0">
          <comment>tx data counter</comment>
        </bits>
      </reg>
      <reg name="spi_sts8" protect="rw">
        <comment>Statue Register Used to observe RX data counter</comment>
        <bits access="r" name="rx_data_cnt" pos="15:0" rst="0x0">
          <comment>Rx data cnt</comment>
        </bits>
      </reg>
      <reg name="spi_sts9" protect="rw">
        <comment>Statue Register Used to observe RX statue</comment>
        <bits access="r" name="rx_dummy_cnt" pos="15:10" rst="0x0">
          <comment>rx dummy counter</comment>
        </bits>
        <bits access="r" name="rx_data_cnt" pos="3:0" rst="0x0">
          <comment>rx data counter</comment>
        </bits>
      </reg>
      <reg name="spi_version" protect="rw">
        <comment>Statue Register Used to observe spi version</comment>
        <bits access="rw" name="spi_version" pos="15:0" rst="0x205">
          <comment>Spi version</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x5150c000" name="AON_SPI" type="AON_SPI"/>
  </archive>
  <archive relative="gpt.xml">
    <module category="System" name="GPT">
      <reg name="cr" protect="rw">
        <comment/>
        <bits access="rw" name="refclk_sel" pos="31" rst="0x1">
          <comment>refclk_sel</comment>
        </bits>
        <bits access="rw" name="tri_cnt_en" pos="12" rst="0x0">
          <comment>Input triger number count enable</comment>
        </bits>
        <bits access="rw" name="tri" pos="11:9" rst="0x0">
          <comment>slave_mode trigger select</comment>
        </bits>
        <bits access="rw" name="arpe" pos="8" rst="0x1">
          <comment>auto preload value</comment>
        </bits>
        <bits access="rw" name="cms" pos="7:6" rst="0x0">
          <comment>Center-aligned mode select 00: disable , other:enable</comment>
        </bits>
        <bits access="rw" name="dir" pos="5" rst="0x0">
          <comment>counter dir , 0: cnt ++ , 1: cnt --</comment>
        </bits>
        <bits access="rw" name="opm" pos="4" rst="0x0">
          <comment>one pulse mode,  0:disable 1:enable</comment>
        </bits>
        <bits access="rw" name="udis" pos="3" rst="0x0">
          <comment>update disable, 0:disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="ckd" pos="2:1" rst="0x0">
          <comment>clock fdts didiver, 01: divided by 2 10:divided by 4, other:bypass</comment>
        </bits>
        <bits access="rw" name="cen" pos="0" rst="0x0">
          <comment>counter enable, 0: disbale, 1:enable</comment>
        </bits>
      </reg>
      <reg name="smcr" protect="rw">
        <comment/>
        <bits access="rw" name="sms" pos="2:0" rst="0x0">
          <comment>slave mode select: 100: slave mode, 101:gate mode, 110:trig mode, others disable</comment>
        </bits>
      </reg>
      <reg name="egr" protect="rw">
        <comment/>
        <bits access="r" name="ug" pos="0" rst="0x0">
          <comment>bit type is changed from w1c to rc. user trigger gen</comment>
        </bits>
      </reg>
      <reg name="ccmr_oc1" protect="rw">
        <comment/>
        <bits access="rw" name="oc4ce" pos="31" rst="0x1">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc4m" pos="30:28" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc4pe" pos="27" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc4fe" pos="26" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc4s" pos="25:24" rst="0x1">
          <comment>channel source sel, bit[24] 0: output enable, 1 output disable bit[25] 0: use ti4, 1: use ti3</comment>
        </bits>
        <bits access="rw" name="oc3ce" pos="23" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc3m" pos="22:20" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc3pe" pos="19" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc3fe" pos="18" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc3s" pos="17:16" rst="0x0">
          <comment>channel source sel, bit[17] 0: output enable, 1 output disable bit[16] 0: use ti3, 1: use ti4</comment>
        </bits>
        <bits access="rw" name="oc2ce" pos="15" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc2m" pos="14:12" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc2pe" pos="11" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc2fe" pos="10" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc2s" pos="9:8" rst="0x0">
          <comment>channel source sel, bit[9] 0: output enable, 1 output disable bit[8] 0: use ti2, 1: use ti1</comment>
        </bits>
        <bits access="rw" name="oc1ce" pos="7" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc1m" pos="6:4" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc1pe" pos="3" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc1fe" pos="2" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc1s" pos="1:0" rst="0x0">
          <comment>channel source sel, bit[0] 0: output enable, 1 output disable bit[1] 0: use ti2, 1: use ti1</comment>
        </bits>
      </reg>
      <reg name="ccmr_ic1" protect="rw">
        <comment/>
        <bits access="rw" name="ic4f" pos="29:26" rst="0x0">
          <comment>ti4 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic4psc" pos="25:24" rst="0x0">
          <comment>ti4 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
        <bits access="rw" name="ic3f" pos="21:18" rst="0x0">
          <comment>ti3 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic3psc" pos="17:16" rst="0x0">
          <comment>ti3 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
        <bits access="rw" name="ic2f" pos="13:10" rst="0x0">
          <comment>ti2 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic2psc" pos="9:8" rst="0x0">
          <comment>ti2 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
        <bits access="rw" name="ic1f" pos="5:2" rst="0x0">
          <comment>ti1 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic1psc" pos="1:0" rst="0x0">
          <comment>ti1 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
      </reg>
      <reg name="ccer" protect="rw">
        <comment/>
        <bits access="rw" name="cc4p" pos="7" rst="0x0">
          <comment>ti4 polarity</comment>
        </bits>
        <bits access="rw" name="cc4e" pos="6" rst="0x0">
          <comment>ti4 enable</comment>
        </bits>
        <bits access="rw" name="cc3p" pos="5" rst="0x0">
          <comment>ti3 polarity</comment>
        </bits>
        <bits access="rw" name="cc3e" pos="4" rst="0x0">
          <comment>ti3 enable</comment>
        </bits>
        <bits access="rw" name="cc2p" pos="3" rst="0x0">
          <comment>ti2 polarity</comment>
        </bits>
        <bits access="rw" name="cc2e" pos="2" rst="0x0">
          <comment>ti2 enable</comment>
        </bits>
        <bits access="rw" name="cc1p" pos="1" rst="0x0">
          <comment>ti1 polarity</comment>
        </bits>
        <bits access="rw" name="cc1e" pos="0" rst="0x0">
          <comment>ti1 enable</comment>
        </bits>
      </reg>
      <reg name="cnt" protect="rw">
        <comment/>
        <bits access="r" name="cnt_value" pos="15:0" rst="0x0">
          <comment>cnt_value</comment>
        </bits>
      </reg>
      <reg name="psc" protect="rw">
        <comment/>
        <bits access="rw" name="psc_value" pos="15:0" rst="0x0">
          <comment>cnt prescale value</comment>
        </bits>
      </reg>
      <reg name="arr" protect="rw">
        <comment/>
        <bits access="rw" name="arr_value" pos="15:0" rst="0xffff">
          <comment>cnt max value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr1_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr1_capture" pos="15:0" rst="0xffff">
          <comment>ic1 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr2_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr2_capture" pos="15:0" rst="0xffff">
          <comment>ic2 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr3_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr3_capture" pos="15:0" rst="0xffff">
          <comment>ic3 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr4_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr4_capture" pos="15:0" rst="0xffff">
          <comment>ic4 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr1_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr1_compare" pos="15:0" rst="0xffff">
          <comment>ic1 compare value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr2_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr2_compare" pos="15:0" rst="0xffff">
          <comment>ic2 compare value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr3_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr3_compare" pos="15:0" rst="0xffff">
          <comment>ic3 compare value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr4_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr4_compare" pos="15:0" rst="0xffff">
          <comment>ic4 compare value</comment>
        </bits>
      </reg>
      <reg name="isr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="irsr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="mask" protect="rw">
        <comment/>
        <bits access="rw" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="rw" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="rw" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="rw" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="clr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>bit type is changed from w1c to rc. cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>bit type is changed from w1c to rc. trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x5150b000" name="AON_GPT1" type="GPT"/>
    <instance address="0x5150b400" name="AON_GPT2" type="GPT"/>
    <instance address="0x5150b800" name="AON_GPT3" type="GPT"/>
    <instance address="0x04809200" name="AP_GPT1" type="GPT"/>
    <instance address="0x04809400" name="AP_GPT2" type="GPT"/>
    <instance address="0x04809600" name="AP_GPT3" type="GPT"/>
    <instance address="0x04809800" name="AP_GPT4" type="GPT"/>
    <instance address="0x04809a00" name="AP_GPT5" type="GPT"/>
    <instance address="0x04809c00" name="AP_GPT6" type="GPT"/>
  </archive>
  <archive relative="spinlock.xml">
    <module category="System" name="SPINLOCK">
      <hole size="64"/>
      <reg name="spinlockttlsts" protect="rw">
        <comment>Spinlock Total Status Register</comment>
      </reg>
      <hole size="928"/>
      <reg name="spinlockmstid_i" protect="rw">
        <comment>Spinlock Master ID Registers</comment>
      </reg>
      <hole size="15328"/>
      <reg name="spinlocksts_i" protect="rw">
        <comment>Spinlock Individual Status Registers</comment>
        <bits access="r" name="taken" pos="0" rst="0x0">
          <comment>Read 0x0000_0000, Request and get the lock.
Read 0x0000_0001, Request but does not get the lock.
Write Unlock Token, Unlock the lock.
Write not Unlock Token, takes no effect.</comment>
        </bits>
      </reg>
      <hole size="16320"/>
      <reg name="spinlockverid" protect="rw">
        <comment>Spinlock Version ID Register</comment>
      </reg>
    </module>
    <instance address="0x51000000" name="SPINLOCK" type="SPINLOCK"/>
  </archive>
  <archive relative="ap_clk.xml">
    <module category="System" name="AP_CLK">
      <hole size="288"/>
      <reg name="cgm_ap_a5_div_cfg" protect="rw">
        <comment>cgm_ap_a5_div_cfg</comment>
        <bits access="rw" name="cgm_ap_a5_div" pos="1:0" rst="0x0">
          <comment>cgm_ap_a5_div: clk_ap_a5 = clk_src/(div +1), default value = 2'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_ap_a5_sel_cfg" protect="rw">
        <comment>cgm_ap_a5_sel_cfg</comment>
        <bits access="rw" name="cgm_ap_a5_sel" pos="2:0" rst="0x1">
          <comment>cgm_ap_a5_sel: clk_ap_a5 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_397m, 4: apll_400m, 5: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_ap_bus_div_cfg" protect="rw">
        <comment>cgm_ap_bus_div_cfg</comment>
        <bits access="rw" name="cgm_ap_bus_div" pos="1:0" rst="0x1">
          <comment>cgm_ap_bus_div: clk_ap_bus = clk_src/(div +1), default value = 2'h1</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="cgm_uart4_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart4_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart4_bf_div_sel" pos="2:0" rst="0x1">
          <comment>cgm_uart4_bf_div_sel: clk_uart4_bf_div source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: apll_31_25m, 4: apll_125m, 5: gnss_pll_133m, 6: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_uart5_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart5_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart5_bf_div_sel" pos="2:0" rst="0x1">
          <comment>cgm_uart5_bf_div_sel: clk_uart5_bf_div source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: apll_31_25m, 4: apll_125m, 5: gnss_pll_133m, 6: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_uart6_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart6_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart6_bf_div_sel" pos="2:0" rst="0x1">
          <comment>cgm_uart6_bf_div_sel: clk_uart6_bf_div source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: apll_31_25m, 4: apll_125m, 5: gnss_pll_133m, 6: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_spiflash1_sel_cfg" protect="rw">
        <comment>cgm_spiflash1_sel_cfg</comment>
        <bits access="rw" name="cgm_spiflash1_sel" pos="2:0" rst="0x1">
          <comment>cgm_spiflash1_sel: clk_spiflash1 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_397m, 4: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_spiflash2_sel_cfg" protect="rw">
        <comment>cgm_spiflash2_sel_cfg</comment>
        <bits access="rw" name="cgm_spiflash2_sel" pos="2:0" rst="0x1">
          <comment>cgm_spiflash2_sel: clk_spiflash2 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_397m, 4: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_camera_pix_div_cfg" protect="rw">
        <comment>cgm_camera_pix_div_cfg</comment>
        <bits access="rw" name="cgm_camera_pix_div" pos="10:0" rst="0x7">
          <comment>cgm_camera_pix_div: clk_camera_pix = clk_src/(div +1), default value = 11'h7</comment>
        </bits>
      </reg>
      <reg name="cgm_camera_pix_sel_cfg" protect="rw">
        <comment>cgm_camera_pix_sel_cfg</comment>
        <bits access="rw" name="cgm_camera_pix_sel" pos="2:0" rst="0x1">
          <comment>cgm_camera_pix_sel: clk_camera_pix source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_57m, 4: apll_62_5m, 5: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_camera_ref_div_cfg" protect="rw">
        <comment>cgm_camera_ref_div_cfg</comment>
        <bits access="rw" name="cgm_camera_ref_div" pos="10:0" rst="0x7">
          <comment>cgm_camera_ref_div: clk_camera_ref = clk_src/(div +1), default value = 11'h7</comment>
        </bits>
      </reg>
      <reg name="cgm_camera_ref_sel_cfg" protect="rw">
        <comment>cgm_camera_ref_sel_cfg</comment>
        <bits access="rw" name="cgm_camera_ref_sel" pos="2:0" rst="0x1">
          <comment>cgm_camera_ref_sel: clk_camera_ref source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_57m, 4: apll_62_5m, 5: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_camera_csi_div_cfg" protect="rw">
        <comment>cgm_camera_csi_div_cfg</comment>
        <bits access="rw" name="cgm_camera_csi_div" pos="10:0" rst="0x7">
          <comment>cgm_camera_csi_div: clk_camera_csi = clk_src/(div +1), default value = 11'h7</comment>
        </bits>
      </reg>
      <reg name="cgm_camera_csi_sel_cfg" protect="rw">
        <comment>cgm_camera_csi_sel_cfg</comment>
        <bits access="rw" name="cgm_camera_csi_sel" pos="2:0" rst="0x1">
          <comment>cgm_camera_csi_sel: clk_camera_csi source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_57m, 4: apll_62_5m, 5: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_camera_csi_data_hs_sel_cfg" protect="rw">
        <comment>cgm_camera_csi_data_hs_sel_cfg</comment>
        <bits access="rw" name="cgm_camera_csi_data_hs_pad_sel" pos="16" rst="0x0">
          <comment>cgm_camera_csi_data_hs_pad_sel: clock source from pad, high active, default: 1'h0</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_spi1_sel_cfg" protect="rw">
        <comment>cgm_spi1_sel_cfg</comment>
        <bits access="rw" name="cgm_spi1_sel" pos="2:0" rst="0x1">
          <comment>cgm_spi1_sel: clk_spi1 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_133m, 4: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_i2c1_sel_cfg" protect="rw">
        <comment>cgm_i2c1_sel_cfg</comment>
        <bits access="rw" name="cgm_i2c1_sel" pos="2:0" rst="0x1">
          <comment>cgm_i2c1_sel: clk_i2c1 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_198_5m, 4: apll_250m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_i2c2_sel_cfg" protect="rw">
        <comment>cgm_i2c2_sel_cfg</comment>
        <bits access="rw" name="cgm_i2c2_sel" pos="2:0" rst="0x1">
          <comment>cgm_i2c2_sel: clk_i2c2 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_198_5m, 4: apll_250m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_gpt3_sel_cfg" protect="rw">
        <comment>cgm_gpt3_sel_cfg</comment>
        <bits access="rw" name="cgm_gpt3_sel" pos="2:0" rst="0x1">
          <comment>cgm_gpt3_sel: clk_gpt3 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_198_5m, 4: apll_250m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="cgm_26m_sel_cfg" protect="rw">
        <comment>cgm_26m_sel_cfg</comment>
        <bits access="rw" name="cgm_26m_sel" pos="1:0" rst="0x1">
          <comment>cgm_26m_sel: clk_26m source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, default: 2'h1</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="cgm_busy_src_monitor_cfg0" protect="rw">
        <comment>cgm_busy_src_monitor_cfg0</comment>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg1" protect="rw">
        <comment>cgm_busy_src_monitor_cfg1</comment>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg2" protect="rw">
        <comment>cgm_busy_src_monitor_cfg2</comment>
        <bits access="r" name="cgm_busy_src_monitor2" pos="16:0" rst="0x8000">
          <comment>cgm_busy_src_monitor2, 64:(cgm_uart5_bf_div_sel_ac == 3) &amp; cgm_busy_uart5_bf_div 65:(cgm_uart6_bf_div_sel_ac == 3) &amp; cgm_busy_uart6_bf_div 66:cgm_busy_ap_a5_sel_0 &amp; cgm_busy_ap_a5_src 67:(cgm_uart4_bf_div_sel_ac == 0) &amp; cgm_busy_uart4_bf_div 68:(cgm_uart5_bf_div_sel_ac == 0) &amp; cgm_busy_uart5_bf_div 69:(cgm_uart6_bf_div_sel_ac == 0) &amp; cgm_busy_uart6_bf_div 70:cgm_busy_spiflash1_sel_0 &amp; cgm_busy_spiflash1 71:cgm_busy_spiflash2_sel_0 &amp; cgm_busy_spiflash2 72:(cgm_camera_pix_sel_ac == 0) &amp; cgm_busy_camera_pix 73:(cgm_camera_ref_sel_ac == 0) &amp; cgm_busy_camera_ref 74:(cgm_camera_csi_sel_ac == 0) &amp; cgm_busy_camera_csi 75:(cgm_spi1_sel_ac == 0) &amp; cgm_busy_spi1 76:(cgm_i2c1_sel_ac == 0) &amp; cgm_busy_i2c1 77:(cgm_i2c2_sel_ac == 0) &amp; cgm_busy_i2c2 78:(cgm_gpt3_sel_ac == 0) &amp; cgm_busy_gpt3 79:cgm_busy_32k 80:(cgm_26m_sel_ac == 0) &amp; cgm_busy_26m</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x0480a000" name="AP_CLK" type="AP_CLK"/>
  </archive>
  <archive relative="ap_apb.xml">
    <module category="System" name="AP_APB">
      <reg name="clk_ap_mode0" protect="rw">
        <comment>CLK_AP_MODE0</comment>
        <bits access="rw" name="clk_mode_rc26m_fr" pos="16" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_26m_fr" pos="15" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_32k_fr" pos="14" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_gpt3_fr" pos="13" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c2_fr" pos="12" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c1_fr" pos="11" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spi1_fr" pos="10" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_camera_csi_fr" pos="9" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_camera_ref_fr" pos="8" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_camera_pix_fr" pos="7" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash2_fr" pos="6" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash1_fr" pos="5" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart6_bf_div_fr" pos="4" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart5_bf_div_fr" pos="3" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart4_bf_div_fr" pos="2" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_bus_fr" pos="1" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_a5_fr" pos="0" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
      </reg>
      <reg name="clk_ap_en0" protect="rw">
        <comment>CLK_AP_EN0</comment>
        <bits access="rw" name="clk_en_rc26m_fr" pos="16" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_26m_fr" pos="15" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_32k_fr" pos="14" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_gpt3_fr" pos="13" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c2_fr" pos="12" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c1_fr" pos="11" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spi1_fr" pos="10" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_camera_csi_fr" pos="9" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_camera_ref_fr" pos="8" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_camera_pix_fr" pos="7" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash2_fr" pos="6" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash1_fr" pos="5" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart6_bf_div_fr" pos="4" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart5_bf_div_fr" pos="3" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart4_bf_div_fr" pos="2" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_bus_fr" pos="1" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_a5_fr" pos="0" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
      </reg>
      <reg name="clk_ap_mode1" protect="rw">
        <comment>CLK_AP_MODE1</comment>
        <bits access="rw" name="clk_mode_ap_ahb" pos="30" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_mnt26m" pos="28" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_mnt32k" pos="27" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_a5_dbg" pos="26" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_a5" pos="25" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_clk" pos="24" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_apb_reg" pos="23" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_gpt3" pos="22" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c2" pos="21" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c1" pos="20" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_timer2" pos="19" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_timer1" pos="18" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_emmc" pos="17" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_busmon" pos="16" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_lzma" pos="15" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_ifc" pos="14" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_camera" pos="13" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_sdmmc" pos="12" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spi1" pos="11" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart6" pos="10" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart5" pos="9" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart4" pos="8" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ce" pos="7" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_med" pos="6" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_axidma" pos="5" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_gouda" pos="4" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash2" pos="3" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash1" pos="2" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_gic400" pos="1" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_imem" pos="0" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
      </reg>
      <reg name="clk_ap_en1" protect="rw">
        <comment>CLK_AP_EN1</comment>
        <bits access="rw" name="clk_en_ap_ahb" pos="30" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_mnt26m" pos="28" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_mnt32k" pos="27" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_a5_dbg" pos="26" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_a5" pos="25" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_clk" pos="24" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_apb_reg" pos="23" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_gpt3" pos="22" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c2" pos="21" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c1" pos="20" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_timer2" pos="19" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_timer1" pos="18" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_emmc" pos="17" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_busmon" pos="16" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_lzma" pos="15" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_ifc" pos="14" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_camera" pos="13" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_sdmmc" pos="12" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spi1" pos="11" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart6" pos="10" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart5" pos="9" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart4" pos="8" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ce" pos="7" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_med" pos="6" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_axidma" pos="5" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_gouda" pos="4" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash2" pos="3" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash1" pos="2" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_gic400" pos="1" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_imem" pos="0" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
      </reg>
      <reg name="clk_ap_mode2" protect="rw">
        <comment>CLK_AP_MODE2</comment>
        <bits access="rw" name="clk_mode_gpt3_p2p_async" pos="13" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c2_p2p_async" pos="12" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c1_p2p_async" pos="11" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ce2efs_p2p_async" pos="10" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap2aon_x2h_sync" pos="9" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash2_x2h_sync" pos="8" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash1_x2h_sync" pos="7" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_ahb_x2h_sync" pos="6" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_med_h2x_sync" pos="5" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_ifc_h2x_sync" pos="4" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_gouda_h2x_sync" pos="3" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap2pub_x2x_async" pos="2" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_usb_h2h_async" pos="1" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_aon2ap_h2x_async" pos="0" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
      </reg>
      <reg name="clk_ap_en2" protect="rw">
        <comment>CLK_AP_EN2</comment>
        <bits access="rw" name="clk_en_gpt3_p2p_async" pos="13" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c2_p2p_async" pos="12" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c1_p2p_async" pos="11" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ce2efs_p2p_async" pos="10" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap2aon_x2h_sync" pos="9" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash2_x2h_sync" pos="8" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash1_x2h_sync" pos="7" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_ahb_x2h_sync" pos="6" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_med_h2x_sync" pos="5" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_ifc_h2x_sync" pos="4" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_gouda_h2x_sync" pos="3" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap2pub_x2x_async" pos="2" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_usb_h2h_async" pos="1" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_aon2ap_h2x_async" pos="0" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
      </reg>
      <reg name="ap_rst0" protect="rw">
        <comment>AP_RST0</comment>
        <bits access="rw" name="rst_ce_pub" pos="29" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_mnt26m" pos="27" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_mnt32k" pos="26" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_a5" pos="25" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_clk" pos="24" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_gpt3" pos="22" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_i2c2" pos="21" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_i2c1" pos="20" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_timer2" pos="19" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_timer1" pos="18" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_emmc" pos="17" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_busmon" pos="16" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_lzma" pos="15" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_ifc" pos="14" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_camera" pos="13" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_sdmmc" pos="12" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_spi1" pos="11" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_uart6" pos="10" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_uart5" pos="9" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_uart4" pos="8" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ce_sec" pos="7" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_med" pos="6" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_axidma" pos="5" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_gouda" pos="4" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_spiflash2" pos="3" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_spiflash1" pos="2" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_gic400" pos="1" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_imem" pos="0" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
      </reg>
      <reg name="ap_rst1" protect="rw">
        <comment>AP_RST1</comment>
        <bits access="rw" name="rst_gpt3_p2p_async" pos="16" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_i2c2_p2p_async" pos="15" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_i2c1_p2p_async" pos="14" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ce2efs_p2p_async" pos="13" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap2aon_x2h_sync" pos="12" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_spiflash2_x2h_sync" pos="11" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_spiflash1_x2h_sync" pos="10" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_med_h2x_sync" pos="8" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_ifc_h2x_sync" pos="7" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_gouda_h2x_sync" pos="6" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap2pub_x2x_async" pos="5" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_usb_h2h_async" pos="4" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_aon2ap_h2x_async" pos="3" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_a5_cs" pos="2" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_a5_dbg" pos="1" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
      </reg>
      <reg name="ap_rst2" protect="rw">
        <comment>AP_RST2</comment>
        <bits access="rw" name="rst_apb_reg" pos="0" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
      </reg>
      <reg name="m0_lpc" protect="rw">
        <comment>M0_LPC</comment>
        <bits access="rw" name="main_m0_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m0_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m0_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m1_lpc" protect="rw">
        <comment>M1_LPC</comment>
        <bits access="rw" name="main_m1_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m1_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m1_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m2_lpc" protect="rw">
        <comment>M2_LPC</comment>
        <bits access="rw" name="main_m2_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m2_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m2_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m3_lpc" protect="rw">
        <comment>M3_LPC</comment>
        <bits access="rw" name="main_m3_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m3_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m3_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m4_lpc" protect="rw">
        <comment>M4_LPC</comment>
        <bits access="rw" name="main_m4_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m4_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m4_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m5_lpc" protect="rw">
        <comment>M5_LPC</comment>
        <bits access="rw" name="main_m5_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m5_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m5_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m6_lpc" protect="rw">
        <comment>M6_LPC</comment>
        <bits access="rw" name="main_m6_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m6_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m6_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m7_lpc" protect="rw">
        <comment>M7_LPC</comment>
        <bits access="rw" name="main_m7_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m7_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m7_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m8_lpc" protect="rw">
        <comment>M8_LPC</comment>
        <bits access="rw" name="main_m8_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m8_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m8_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m9_lpc" protect="rw">
        <comment>M9_LPC</comment>
        <bits access="rw" name="main_m9_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m9_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m9_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s0_lpc" protect="rw">
        <comment>S0_LPC</comment>
        <bits access="rw" name="main_s0_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s0_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s0_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s1_lpc" protect="rw">
        <comment>S1_LPC</comment>
        <bits access="rw" name="main_s1_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s1_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s1_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s2_lpc" protect="rw">
        <comment>S2_LPC</comment>
        <bits access="rw" name="main_s2_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s2_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s2_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s3_lpc" protect="rw">
        <comment>S3_LPC</comment>
        <bits access="rw" name="main_s3_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s3_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s3_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s4_lpc" protect="rw">
        <comment>S4_LPC</comment>
        <bits access="rw" name="main_s4_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s4_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s4_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s5_lpc" protect="rw">
        <comment>S5_LPC</comment>
        <bits access="rw" name="main_s5_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s5_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s5_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s6_lpc" protect="rw">
        <comment>S6_LPC</comment>
        <bits access="rw" name="main_s6_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s6_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s6_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="main_lpc" protect="rw">
        <comment>MAIN_LPC</comment>
        <bits access="rw" name="main_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="cache_emmc_sdio" protect="rw">
        <comment>CACHE_EMMC_SDIO</comment>
        <bits access="rw" name="arcache_emmc" pos="7:4" rst="0x0">
          <comment>arcache of emmc</comment>
        </bits>
        <bits access="rw" name="awcache_emmc" pos="3:0" rst="0x0">
          <comment>awcache of emmc</comment>
        </bits>
      </reg>
      <reg name="misc_cfg" protect="rw">
        <comment>MISC_CFG</comment>
        <bits access="rw" name="camera_refclk_out_mode" pos="10" rst="0x0">
          <comment>1: If camera fifo is almost full, disable clk_camera_out</comment>
        </bits>
        <bits access="rw" name="camera_refclk_out_en" pos="9" rst="0x0">
          <comment>1: clk_camera_out enable</comment>
        </bits>
        <bits access="rw" name="camera_spiclk_pol" pos="8" rst="0x0">
          <comment>1: invert pix clk polarity.
0: keep pix clk polarity.</comment>
        </bits>
        <bits access="rw" name="ap_ifc_hresp_err_mask" pos="7" rst="0x1">
          <comment>ap ifc dma not operate error response from bus</comment>
        </bits>
        <bits access="rw" name="med_read_bus_sel" pos="6" rst="0x0">
          <comment>med read data from bus instead of flash</comment>
        </bits>
        <bits access="rw" name="cfgsdisable_gic400" pos="0" rst="0x0">
          <comment>gic400 cfgsdisable</comment>
        </bits>
      </reg>
      <reg name="chip_prod_id" protect="rw">
        <comment>CHIP_PROD_ID</comment>
        <bits access="r" name="prod_id" pos="31:16" rst="0x0">
          <comment>production id</comment>
        </bits>
        <bits access="r" name="bond_id" pos="15:12" rst="0x0">
          <comment>bond id</comment>
        </bits>
        <bits access="r" name="metal_id" pos="11:0" rst="0x0">
          <comment>metal id</comment>
        </bits>
      </reg>
      <reg name="cfg_qos0" protect="rw">
        <comment>CFG_QOS0</comment>
        <bits access="rw" name="lzma_awqos" pos="31:28" rst="0x0">
          <comment>lzma_awqos</comment>
        </bits>
        <bits access="rw" name="lzma_arqos" pos="27:24" rst="0x0">
          <comment>lzma_arqos</comment>
        </bits>
        <bits access="rw" name="emmc_awqos" pos="23:20" rst="0x0">
          <comment>emmc_awqos</comment>
        </bits>
        <bits access="rw" name="emmc_arqos" pos="19:16" rst="0x0">
          <comment>emmc_arqos</comment>
        </bits>
        <bits access="rw" name="ce_awqos" pos="15:12" rst="0x0">
          <comment>ce_awqos</comment>
        </bits>
        <bits access="rw" name="ce_arqos" pos="11:8" rst="0x0">
          <comment>ce_arqos</comment>
        </bits>
        <bits access="rw" name="ap_a5_awqos" pos="7:4" rst="0x0">
          <comment>ap_a5_awqos</comment>
        </bits>
        <bits access="rw" name="ap_a5_arqos" pos="3:0" rst="0x0">
          <comment>ap_a5_arqos</comment>
        </bits>
      </reg>
      <reg name="cfg_qos1" protect="rw">
        <comment>CFG_QOS1</comment>
        <bits access="rw" name="aon_awqos" pos="31:28" rst="0x0">
          <comment>aon_awqos</comment>
        </bits>
        <bits access="rw" name="aon_arqos" pos="27:24" rst="0x0">
          <comment>aon_arqos</comment>
        </bits>
        <bits access="rw" name="ap_ifc_awqos" pos="23:20" rst="0x0">
          <comment>ap_ifc_awqos</comment>
        </bits>
        <bits access="rw" name="ap_ifc_arqos" pos="19:16" rst="0x0">
          <comment>ap_ifc_arqos</comment>
        </bits>
        <bits access="rw" name="usb_awqos" pos="15:12" rst="0x0">
          <comment>usb_awqos</comment>
        </bits>
        <bits access="rw" name="usb_arqos" pos="11:8" rst="0x0">
          <comment>usb_arqos</comment>
        </bits>
        <bits access="rw" name="gouda_awqos" pos="7:4" rst="0x0">
          <comment>gouda_awqos</comment>
        </bits>
        <bits access="rw" name="gouda_arqos" pos="3:0" rst="0x0">
          <comment>gouda_arqos</comment>
        </bits>
      </reg>
      <reg name="cfg_qos2" protect="rw">
        <comment>CFG_QOS2</comment>
        <bits access="rw" name="ap_axidma_awqos" pos="15:12" rst="0x0">
          <comment>ap_axidma_awqos</comment>
        </bits>
        <bits access="rw" name="ap_axidma_arqos" pos="11:8" rst="0x0">
          <comment>ap_axidma_arqos</comment>
        </bits>
        <bits access="rw" name="med_awqos" pos="7:4" rst="0x0">
          <comment>med_awqos</comment>
        </bits>
        <bits access="rw" name="med_arqos" pos="3:0" rst="0x0">
          <comment>med_arqos</comment>
        </bits>
      </reg>
      <reg name="debug_monitor" protect="rw">
        <comment>DEBUG_MONITOR</comment>
        <bits access="rw" name="med_dbg_bus_sel" pos="4:0" rst="0x0">
          <comment>med dbg bus select</comment>
        </bits>
      </reg>
      <reg name="xhb_awsparse" protect="rw">
        <comment>XHB_AWSPARSE</comment>
        <bits access="rw" name="xhb_ap2aon_awsparse" pos="3" rst="0x1">
          <comment>ap2aon xhb400 awsparse</comment>
        </bits>
        <bits access="rw" name="xhb_spiflash2_awsparse" pos="2" rst="0x1">
          <comment>spiflash2 xhb400 awsparse</comment>
        </bits>
        <bits access="rw" name="xhb_spiflash1_awsparse" pos="1" rst="0x1">
          <comment>spiflash1 xhb400 awsparse</comment>
        </bits>
        <bits access="rw" name="xhb_ap_ahb_awsparse" pos="0" rst="0x1">
          <comment>ap_ahb xhb400 awsparse</comment>
        </bits>
      </reg>
      <reg name="clk_mnt26m_th0" protect="rw">
        <comment>CLK_MNT26M_TH0</comment>
        <bits access="rw" name="clk_mnt26m_th0" pos="7:0" rst="0x40">
          <comment>monitor counter number of rc26m</comment>
        </bits>
      </reg>
      <reg name="clk_mnt26m_th1" protect="rw">
        <comment>CLK_MNT26M_TH1</comment>
        <bits access="rw" name="clk_mnt26m_th1" pos="15:0" rst="0x3e8">
          <comment>monitor interval counter number of rc26m</comment>
        </bits>
      </reg>
      <reg name="clk_mnt26m_th2" protect="rw">
        <comment>CLK_MNT26M_TH2</comment>
        <bits access="rw" name="clk_mnt26m_th2" pos="6:0" rst="0x20">
          <comment>monitor counter number of xtal26m, low limited</comment>
        </bits>
      </reg>
      <reg name="clk_mnt26m_th3" protect="rw">
        <comment>CLK_MNT26M_TH3</comment>
        <bits access="rw" name="clk_mnt26m_th3" pos="8:0" rst="0x80">
          <comment>monitor counter number of xtal26m, high limited</comment>
        </bits>
      </reg>
      <reg name="clk_mnt32k_th0" protect="rw">
        <comment>CLK_MNT32K_TH0</comment>
        <bits access="rw" name="clk_mnt32k_th0" pos="11:0" rst="0x190">
          <comment>monitor counter number of 32k clock, low limited</comment>
        </bits>
      </reg>
      <reg name="clk_mnt32k_th1" protect="rw">
        <comment>CLK_MNT32K_TH1</comment>
        <bits access="rw" name="clk_mnt32k_th1" pos="11:0" rst="0x6a4">
          <comment>monitor counter number of 32k clock, high limited</comment>
        </bits>
      </reg>
      <reg name="clk_mnt_ctrl" protect="rw">
        <comment>CLK_MNT_CTRL</comment>
        <bits access="rw" name="st_clk_mnt26m" pos="5" rst="0x0"/>
        <bits access="rw" name="st_clk_mnt32k" pos="4" rst="0x0"/>
        <bits access="rw" name="en_int_clk_mnt26m" pos="3" rst="0x0"/>
        <bits access="rw" name="en_int_clk_mnt32k" pos="2" rst="0x0"/>
        <bits access="rw" name="clk_mnt26m_en" pos="1" rst="0x0"/>
        <bits access="rw" name="clk_mnt32k_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="cfg_bridge" protect="rw">
        <comment>CFG_BRIDGE</comment>
        <bits access="r" name="gpt3_p2p_async_fifo_clr_end" pos="31" rst="0x0"/>
        <bits access="rw" name="gpt3_p2p_async_fifo_clr" pos="30" rst="0x0"/>
        <bits access="rw" name="gpt3_p2p_async_sclk_auto_gate_en" pos="29" rst="0x0"/>
        <bits access="rw" name="gpt3_p2p_async_mclk_auto_gate_en" pos="28" rst="0x0"/>
        <bits access="r" name="i2c2_p2p_async_fifo_clr_end" pos="27" rst="0x0"/>
        <bits access="rw" name="i2c2_p2p_async_fifo_clr" pos="26" rst="0x0"/>
        <bits access="rw" name="i2c2_p2p_async_sclk_auto_gate_en" pos="25" rst="0x0"/>
        <bits access="rw" name="i2c2_p2p_async_mclk_auto_gate_en" pos="24" rst="0x0"/>
        <bits access="r" name="i2c1_p2p_async_fifo_clr_end" pos="23" rst="0x0"/>
        <bits access="rw" name="i2c1_p2p_async_fifo_clr" pos="22" rst="0x0"/>
        <bits access="rw" name="i2c1_p2p_async_sclk_auto_gate_en" pos="21" rst="0x0"/>
        <bits access="rw" name="i2c1_p2p_async_mclk_auto_gate_en" pos="20" rst="0x0"/>
        <bits access="r" name="ce2efs_p2p_async_fifo_clr_end" pos="19" rst="0x0"/>
        <bits access="rw" name="ce2efs_p2p_async_fifo_clr" pos="18" rst="0x0"/>
        <bits access="rw" name="ce2efs_p2p_async_sclk_auto_gate_en" pos="17" rst="0x0"/>
        <bits access="rw" name="ce2efs_p2p_async_mclk_auto_gate_en" pos="16" rst="0x0"/>
        <bits access="rw" name="med_h2x_sync_nonbuf_early_resp_en" pos="15" rst="0x0"/>
        <bits access="rw" name="med_h2x_sync_clk_auto_gate_en" pos="14" rst="0x0"/>
        <bits access="rw" name="ap_ifc_h2x_sync_nonbuf_early_resp_en" pos="13" rst="0x0"/>
        <bits access="rw" name="ap_ifc_h2x_sync_clk_auto_gate_en" pos="12" rst="0x0"/>
        <bits access="rw" name="gouda_h2x_sync_nonbuf_early_resp_en" pos="11" rst="0x0"/>
        <bits access="rw" name="gouda_h2x_sync_clk_auto_gate_en" pos="10" rst="0x0"/>
        <bits access="r" name="usb_h2h_async_fifo_clr_end" pos="9" rst="0x0"/>
        <bits access="rw" name="usb_h2h_async_fifo_clr" pos="8" rst="0x0"/>
        <bits access="rw" name="usb_h2h_async_nonbuf_early_resp_en" pos="7" rst="0x0"/>
        <bits access="rw" name="usb_h2h_async_sclk_auto_gate_en" pos="6" rst="0x0"/>
        <bits access="rw" name="usb_h2h_async_mclk_auto_gate_en" pos="5" rst="0x0"/>
        <bits access="r" name="aon2ap_h2x_async_fifo_clr_end" pos="4" rst="0x0"/>
        <bits access="rw" name="aon2ap_h2x_async_fifo_clr" pos="3" rst="0x0"/>
        <bits access="rw" name="aon2ap_h2x_async_nonbuf_early_resp_en" pos="2" rst="0x0"/>
        <bits access="rw" name="aon2ap_h2x_async_sclk_auto_gate_en" pos="1" rst="0x0"/>
        <bits access="rw" name="aon2ap_h2x_async_mclk_auto_gate_en" pos="0" rst="0x0"/>
      </reg>
      <hole size="32"/>
      <reg name="cgm_gate_auto_sel0" protect="rw">
        <comment>CGM_GATE_AUTO_SEL0</comment>
      </reg>
      <reg name="cgm_gate_auto_sel1" protect="rw">
        <comment>CGM_GATE_AUTO_SEL1</comment>
      </reg>
      <reg name="cgm_gate_auto_sel2" protect="rw">
        <comment>CGM_GATE_AUTO_SEL2</comment>
      </reg>
      <reg name="cgm_gate_auto_sel3" protect="rw">
        <comment>CGM_GATE_AUTO_SEL3</comment>
      </reg>
      <reg name="cgm_gate_force_en0" protect="rw">
        <comment>CGM_GATE_FORCE_EN0</comment>
      </reg>
      <reg name="cgm_gate_force_en1" protect="rw">
        <comment>CGM_GATE_FORCE_EN1</comment>
      </reg>
      <reg name="cgm_gate_force_en2" protect="rw">
        <comment>CGM_GATE_FORCE_EN2</comment>
      </reg>
      <reg name="cgm_gate_force_en3" protect="rw">
        <comment>CGM_GATE_FORCE_EN3</comment>
      </reg>
      <reg name="mnt_gate_en_status0" protect="rw">
        <comment>MNT_GATE_EN_STATUS0</comment>
      </reg>
      <reg name="mnt_gate_en_status1" protect="rw">
        <comment>MNT_GATE_EN_STATUS1</comment>
      </reg>
      <reg name="mnt_gate_en_status2" protect="rw">
        <comment>MNT_GATE_EN_STATUS2</comment>
      </reg>
      <reg name="mnt_gate_en_status3" protect="rw">
        <comment>MNT_GATE_EN_STATUS3</comment>
      </reg>
      <reg name="mnt_cgm_busy_status0" protect="rw">
        <comment>MNT_CGM_BUSY_STATUS0</comment>
      </reg>
      <reg name="mnt_cgm_busy_status1" protect="rw">
        <comment>MNT_CGM_BUSY_STATUS1</comment>
      </reg>
      <reg name="mnt_cgm_busy_status2" protect="rw">
        <comment>MNT_CGM_BUSY_STATUS2</comment>
      </reg>
      <reg name="mnt_cgm_busy_status3" protect="rw">
        <comment>MNT_CGM_BUSY_STATUS3</comment>
      </reg>
      <reg name="mnt_cgm_busy_status4" protect="rw">
        <comment>MNT_CGM_BUSY_STATUS4</comment>
      </reg>
      <hole size="96"/>
      <reg name="cfg_clk_uart4" protect="rw">
        <comment>CFG_CLK_UART4</comment>
        <bits access="rw" name="uart4_div_num" pos="29:17" rst="0x1">
          <comment>numerator</comment>
        </bits>
        <bits access="rw" name="uart4_div_denom" pos="16:0" rst="0x7">
          <comment>denominator</comment>
        </bits>
      </reg>
      <reg name="cfg_clk_uart5" protect="rw">
        <comment>CFG_CLK_UART5</comment>
        <bits access="rw" name="uart5_div_num" pos="29:17" rst="0x1">
          <comment>numerator</comment>
        </bits>
        <bits access="rw" name="uart5_div_denom" pos="16:0" rst="0x7">
          <comment>denominator</comment>
        </bits>
      </reg>
      <reg name="cfg_clk_uart6" protect="rw">
        <comment>CFG_CLK_UART6</comment>
        <bits access="rw" name="uart6_div_num" pos="29:17" rst="0x1">
          <comment>numerator</comment>
        </bits>
        <bits access="rw" name="uart6_div_denom" pos="16:0" rst="0x7">
          <comment>denominator</comment>
        </bits>
      </reg>
      <reg name="cfg_clk_spiflash1" protect="rw">
        <comment>CFG_CLK_SPIFLASH1</comment>
        <bits access="rw" name="spiflash1_freq" pos="3:0" rst="0xf">
          <comment>select spiflash1 controller clock frequency. default 26MHz</comment>
        </bits>
      </reg>
      <reg name="cfg_clk_spiflash2" protect="rw">
        <comment>CFG_CLK_SPIFLASH2</comment>
        <bits access="rw" name="spiflash2_freq" pos="3:0" rst="0xf">
          <comment>select spiflash2 controller clock frequency. default 26MHz</comment>
        </bits>
      </reg>
      <reg name="cfg_clk_apcpu_dbgen" protect="rw">
        <comment>CFG_CLK_APCPU_DBGEN</comment>
        <bits access="rw" name="div_disable" pos="3" rst="0x0">
          <comment>1: clock div disable;
0: clock div enable;</comment>
        </bits>
        <bits access="rw" name="div_num" pos="2:0" rst="0x0">
          <comment>0: no div;
1: 2div;
2: 3div;
3: 4div;
4: 5div;
5: 6div;
6: 7div;
7: 8div;</comment>
        </bits>
      </reg>
      <reg name="lp_force" protect="rw">
        <comment>LP_FORCE</comment>
        <bits access="rw" name="lp_force_main" pos="17" rst="0x0"/>
        <bits access="rw" name="lp_force_s6" pos="16" rst="0x0"/>
        <bits access="rw" name="lp_force_s5" pos="15" rst="0x0"/>
        <bits access="rw" name="lp_force_s4" pos="14" rst="0x0"/>
        <bits access="rw" name="lp_force_s3" pos="13" rst="0x0"/>
        <bits access="rw" name="lp_force_s2" pos="12" rst="0x0"/>
        <bits access="rw" name="lp_force_s1" pos="11" rst="0x0"/>
        <bits access="rw" name="lp_force_s0" pos="10" rst="0x0"/>
        <bits access="rw" name="lp_force_m9" pos="9" rst="0x0"/>
        <bits access="rw" name="lp_force_m8" pos="8" rst="0x0"/>
        <bits access="rw" name="lp_force_m7" pos="7" rst="0x0"/>
        <bits access="rw" name="lp_force_m6" pos="6" rst="0x0"/>
        <bits access="rw" name="lp_force_m5" pos="5" rst="0x0"/>
        <bits access="rw" name="lp_force_m4" pos="4" rst="0x0"/>
        <bits access="rw" name="lp_force_m3" pos="3" rst="0x0"/>
        <bits access="rw" name="lp_force_m2" pos="2" rst="0x0"/>
        <bits access="rw" name="lp_force_m1" pos="1" rst="0x0"/>
        <bits access="rw" name="lp_force_m0" pos="0" rst="0x0"/>
      </reg>
      <reg name="sleep_ctrl" protect="rw">
        <comment>SLEEP_CTRL</comment>
        <bits access="r" name="lp_force_ack_main" pos="22" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s6" pos="21" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s5" pos="20" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s4" pos="19" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s3" pos="18" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s2" pos="17" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s1" pos="16" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s0" pos="15" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m9" pos="14" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m8" pos="13" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m7" pos="12" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m6" pos="11" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m5" pos="10" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m4" pos="9" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m3" pos="8" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m2" pos="7" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m1" pos="6" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m0" pos="5" rst="0x0"/>
        <bits access="rw" name="deep_sleep_core_bypass" pos="4" rst="0x0">
          <comment>1: when ap_sys enter deepsleep, this bit can bypass ap_a5 wfi signal, only care about slp_req signal.</comment>
        </bits>
        <bits access="rw" name="light_sleep_rc26m_sel" pos="3" rst="0x0">
          <comment>1: when ap_a5 enter wfi, the ap_a5 clock will auto switch to rc26MHz and the bus clock will auto change along with the ap_a5 clock.</comment>
        </bits>
        <bits access="rw" name="ap_a5_clk_auto_gate" pos="2" rst="0x0">
          <comment>1: when ap_a5 enter wfi, ap_a5 clk will be stopped.</comment>
        </bits>
        <bits access="rw" name="light_sleep_enable" pos="1" rst="0x0">
          <comment>1: when ap_a5 enter wfi, the ap_a5 clock will auto switch to xtal26MHz and the bus clock will auto change along with the ap_a5 clock.</comment>
        </bits>
        <bits access="rw" name="deep_sleep_core_int_disable" pos="0" rst="0x0">
          <comment>1: when ap_sys enter deepsleep, this bit can prevent fiq/irq from waking up ap_a5 exit wfi.</comment>
        </bits>
      </reg>
      <reg name="light_sleep_bypass0" protect="rw">
        <comment>LIGHT_SLEEP_BYPASS0</comment>
        <bits access="rw" name="light_bypass_m9" pos="27" rst="0x0"/>
        <bits access="rw" name="light_bypass_m8" pos="26" rst="0x0"/>
        <bits access="rw" name="light_bypass_m7" pos="25" rst="0x0"/>
        <bits access="rw" name="light_bypass_m6" pos="24" rst="0x0"/>
        <bits access="rw" name="light_bypass_m5" pos="23" rst="0x0"/>
        <bits access="rw" name="light_bypass_m4" pos="22" rst="0x0"/>
        <bits access="rw" name="light_bypass_m3" pos="21" rst="0x0"/>
        <bits access="rw" name="light_bypass_m2" pos="20" rst="0x0"/>
        <bits access="rw" name="light_bypass_m1" pos="19" rst="0x0"/>
        <bits access="rw" name="light_bypass_m0" pos="18" rst="0x0"/>
        <bits access="rw" name="light_bypass_main_lpc" pos="17" rst="0x0"/>
        <bits access="rw" name="light_bypass_s6_lpc" pos="16" rst="0x0"/>
        <bits access="rw" name="light_bypass_s5_lpc" pos="15" rst="0x0"/>
        <bits access="rw" name="light_bypass_s4_lpc" pos="14" rst="0x0"/>
        <bits access="rw" name="light_bypass_s3_lpc" pos="13" rst="0x0"/>
        <bits access="rw" name="light_bypass_s2_lpc" pos="12" rst="0x0"/>
        <bits access="rw" name="light_bypass_s1_lpc" pos="11" rst="0x0"/>
        <bits access="rw" name="light_bypass_s0_lpc" pos="10" rst="0x0"/>
        <bits access="rw" name="light_bypass_m9_lpc" pos="9" rst="0x0"/>
        <bits access="rw" name="light_bypass_m8_lpc" pos="8" rst="0x0"/>
        <bits access="rw" name="light_bypass_m7_lpc" pos="7" rst="0x0"/>
        <bits access="rw" name="light_bypass_m6_lpc" pos="6" rst="0x0"/>
        <bits access="rw" name="light_bypass_m5_lpc" pos="5" rst="0x0"/>
        <bits access="rw" name="light_bypass_m4_lpc" pos="4" rst="0x0"/>
        <bits access="rw" name="light_bypass_m3_lpc" pos="3" rst="0x0"/>
        <bits access="rw" name="light_bypass_m2_lpc" pos="2" rst="0x0"/>
        <bits access="rw" name="light_bypass_m1_lpc" pos="1" rst="0x0"/>
        <bits access="rw" name="light_bypass_m0_lpc" pos="0" rst="0x0"/>
      </reg>
      <reg name="light_sleep_bypass1" protect="rw">
        <comment>LIGHT_SLEEP_BYPASS1</comment>
        <bits access="rw" name="light_bypass_usb_dma" pos="22" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch9" pos="21" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch8" pos="20" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch7" pos="19" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch6" pos="18" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch5" pos="17" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch4" pos="16" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch3" pos="15" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch2" pos="14" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch1" pos="13" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch0" pos="12" rst="0x0"/>
        <bits access="rw" name="light_bypass_timer2" pos="11" rst="0x0"/>
        <bits access="rw" name="light_bypass_timer1" pos="10" rst="0x0"/>
        <bits access="rw" name="light_bypass_med" pos="9" rst="0x0"/>
        <bits access="rw" name="light_bypass_spi1" pos="8" rst="0x0"/>
        <bits access="rw" name="light_bypass_gpt3" pos="7" rst="0x0"/>
        <bits access="rw" name="light_bypass_i2c2" pos="6" rst="0x0"/>
        <bits access="rw" name="light_bypass_i2c1" pos="5" rst="0x0"/>
        <bits access="rw" name="light_bypass_camera" pos="4" rst="0x0"/>
        <bits access="rw" name="light_bypass_sdmmc" pos="3" rst="0x0"/>
        <bits access="rw" name="light_bypass_uart6" pos="2" rst="0x0"/>
        <bits access="rw" name="light_bypass_uart5" pos="1" rst="0x0"/>
        <bits access="rw" name="light_bypass_uart4" pos="0" rst="0x0"/>
      </reg>
      <reg name="anti_hang" protect="rw">
        <comment>ANTI_HANG</comment>
        <bits access="rw" name="ap_a5_err_resp_en" pos="6" rst="0x1">
          <comment>1: ap a5 can receive error response from matrix;
0: error response from matrix to ap a5 will be masked;</comment>
        </bits>
        <bits access="rw" name="apb3_slave_err_resp_en" pos="5" rst="0x0">
          <comment>lzma/ap_imem/ap_busmon/apb_reg/gouda/tiimer1/timer2/i2c1/i2c2/gpt3/ap_clk</comment>
        </bits>
        <bits access="rw" name="apb2_slave_err_resp_en" pos="4" rst="0x0">
          <comment>uart4/uart5/uart6/sdmmc/camera/ap_ifc</comment>
        </bits>
        <bits access="rw" name="apb1_slave_err_resp_en" pos="3" rst="0x0">
          <comment>med/ce_pub/ce_sec/emmc/spi1</comment>
        </bits>
        <bits access="rw" name="ahb_slave_err_resp_en" pos="2" rst="0x0">
          <comment>spiflash1/spiflash2/ap_axidma/usb</comment>
        </bits>
        <bits access="rw" name="ap2pub_downstream_disable_force" pos="1" rst="0x0"/>
        <bits access="rw" name="ap2pub_downstream_disable_sel" pos="0" rst="0x0"/>
      </reg>
      <hole size="32"/>
      <reg name="ap_apb_rsd0" protect="rw">
        <comment>AP_APB_RSD0</comment>
      </reg>
      <reg name="ap_apb_rsd1" protect="rw">
        <comment>AP_APB_RSD1</comment>
      </reg>
      <reg name="ap_apb_rsd2" protect="rw">
        <comment>AP_APB_RSD2</comment>
      </reg>
      <reg name="ap_apb_rsd3" protect="rw">
        <comment>AP_APB_RSD3</comment>
      </reg>
      <reg name="ap2pub_bridge_status" protect="rw">
        <comment>AP2PUB_BRIDGE_STATUS</comment>
        <bits access="r" name="ap2pub_bridge_trans_idle" pos="2" rst="0x1"/>
        <bits access="r" name="ap2pub_pwr_handshk_clk_req" pos="1" rst="0x0"/>
        <bits access="r" name="ap2pub_axi_detector_overflow" pos="0" rst="0x0"/>
      </reg>
      <reg name="ap2pub_bridge_debug" protect="rw">
        <comment>AP2PUB_BRIDGE_DEBUG</comment>
      </reg>
      <hole size="5568"/>
      <reg name="clk_ap_mode0_set" protect="rw"/>
      <reg name="clk_ap_en0_set" protect="rw"/>
      <reg name="clk_ap_mode1_set" protect="rw"/>
      <reg name="clk_ap_en1_set" protect="rw"/>
      <reg name="clk_ap_mode2_set" protect="rw"/>
      <reg name="clk_ap_en2_set" protect="rw"/>
      <reg name="ap_rst0_set" protect="rw"/>
      <reg name="ap_rst1_set" protect="rw"/>
      <reg name="ap_rst2_set" protect="rw"/>
      <hole size="1952"/>
      <reg name="lp_force_set" protect="rw"/>
      <reg name="sleep_ctrl_set" protect="rw"/>
      <reg name="light_sleep_bypass0_set" protect="rw"/>
      <reg name="light_sleep_bypass1_set" protect="rw"/>
      <reg name="anti_hang_set" protect="rw"/>
      <hole size="5792"/>
      <reg name="clk_ap_mode0_clr" protect="rw"/>
      <reg name="clk_ap_en0_clr" protect="rw"/>
      <reg name="clk_ap_mode1_clr" protect="rw"/>
      <reg name="clk_ap_en1_clr" protect="rw"/>
      <reg name="clk_ap_mode2_clr" protect="rw"/>
      <reg name="clk_ap_en2_clr" protect="rw"/>
      <reg name="ap_rst0_clr" protect="rw"/>
      <reg name="ap_rst1_clr" protect="rw"/>
      <reg name="ap_rst2_clr" protect="rw"/>
      <hole size="1952"/>
      <reg name="lp_force_clr" protect="rw"/>
      <reg name="sleep_ctrl_clr" protect="rw"/>
      <reg name="light_sleep_bypass0_clr" protect="rw"/>
      <reg name="light_sleep_bypass1_clr" protect="rw"/>
      <reg name="anti_hang_clr" protect="rw"/>
    </module>
    <var name="REG_AP_APB_SET_OFFSET" value="0x400"/>
    <var name="REG_AP_APB_CLR_OFFSET" value="0x800"/>
    <instance address="0x04803000" name="AP_APB" type="AP_APB"/>
  </archive>
  <archive relative="ce_sec.xml">
    <module category="System" name="CE_SEC">
      <reg name="ce_debug_dma_status" protect="rw">
        <comment>axi bus status and dma work state status</comment>
        <bits access="r" name="rf_ce_wready" pos="31" rst="0x0">
          <comment>axi write data channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_awready" pos="30" rst="0x0">
          <comment>axi write address channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_arready" pos="29" rst="0x0">
          <comment>axi read address channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_busy" pos="28" rst="0x0">
          <comment>dma is working,and CPU can't access ce registers except ce_clear register.</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_dst_state" pos="26:22" rst="0x0">
          <comment>dma write port state:                                         4'd0: idle                                                           4'd1: write burst calculate                                   4'd2: write burst calculate data number              4'd3: write burst wait enough data                    4'd4: write burst start                                        4'd5: write burst execute                                   4'd6: write burst wait burst end                         4'd7: write burst end</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_src_state" pos="21:17" rst="0x0">
          <comment>dma read port state:                                         4'd0: idle                                                           4'd1: read burst wait enough buffer space        4'd2: read burst wait one cycle                         4'd3: read burst start                                        4'd4: read burst execute                                   4'd5: read burst wait burst end                         4'd6: read burst done</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_cmd_fifo_non_empty" pos="16" rst="0x0">
          <comment>pka cmd fifo is non-empty</comment>
        </bits>
        <bits access="r" name="rf_ce_cmd_fifo_non_empty" pos="15" rst="0x0">
          <comment>cmd fifo is non-empty</comment>
        </bits>
        <bits access="r" name="rf_ce_int_raw_status_vld" pos="14" rst="0x0">
          <comment>interrupt raw status is valid</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_err" pos="13" rst="0x0">
          <comment>ce in error status</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_main_write_state" pos="12:8" rst="0x0">
          <comment>dma control main write port state:                     5'd0: idle                                                           5'd1: STD hash start                                            5'd2: STD start                                                  5'd3: STD wait done                                          5'd4: STD send done                                        5'd5: STD next state judgement                        5'd6: STD pause                                               5'd7: STD done                                                 5'd8: LLIST check node buffer status               5'd9: LLIST load node                                       5'd10: LLIST load node wait                               5'd11: LLIST load node update parameter       5'd12: LLIST load node done                            5'd13: LLIST hash start                                     5'd14: LLIST start                                             5'd15: LLIST wait done                                     5'd16: LLIST send done                                    5'd17: LLIST next start judgement                    5'd18: LLIST pause                                           5'd19: LLIST done</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_pka_main_read_state" pos="7:5" rst="0x0">
          <comment>3'd0: idle                                                      3'd1: pka read instruction start                                                                         3'd2: pka load start                                                                                                    3'd3: pka wait done                                                                                                   3'd4: pka send done                                                                                                 3'd5: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_main_read_state" pos="4:0" rst="0x0">
          <comment>dma control main read port state:                     5'd0: idle                                                                                                                     5'd1: read key/hmac key/aad start                                                            5'd2: wait read key/hmac key/aad done                                                5'd3: read key/hmac key/aad, send done                                             5'd4: read key/hmac key/aad done                                                          5'd5: STD read start                                                                                                5'd6: STD wait done                                                                                           5'd7: STD send done                                                                                        5'd8: STD done,then judgement                                                               5'd9: STD pause                                                                                                     5'd10: STD done                                                                                                     5'd11: LLIST read list                                                                                                  5'd12: LLIST read list wait done                                                                 5'd13: LLIST read list send done                                                              5'd14: LLIST read list done                                                                            5'd15: LLIST read node                                                                                        5'd16: LLIST read node wait                                                                               5'd17: LLIST read node done                                                                      5'd18: LLIST node execution                                                                                    5'd19: LLIST node execution, wait done                                                   5'd20: LLIST node execution, send done                                             5'd21: LLIST node execution done                                                               5'd22: LLIST judge next state                                                                                    5'd23: LLIST pause                                                                                         5'd24: LLIST done                                                                                                        5'd25: read session key start                                                                                  5'd26: read session key done</comment>
        </bits>
      </reg>
      <reg name="ce_debug_aes_status" protect="rw">
        <comment>aes module state</comment>
        <bits access="r" name="rf_ce_fde_rdma_data_status" pos="28:27" rst="0x0">
          <comment>rdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_wdma_data_status" pos="26:25" rst="0x0">
          <comment>wdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_dma_main_read_state" pos="24:20" rst="0x0">
          <comment>dma control main read port state:                     5'd0: idle                                                                                                                     5'd1: read key/hmac key/aad start                                                            5'd2: wait read key/hmac key/aad done                                                5'd3: read key/hmac key/aad, send done                                             5'd4: read key/hmac key/aad done                                                          5'd5: STD read start                                                                                                5'd6: STD wait done                                                                                           5'd7: STD send done                                                                                        5'd8: STD done,then judgement                                                               5'd9: STD pause                                                                                                     5'd10: STD done                                                                                                     5'd11: LLIST read list                                                                                                  5'd12: LLIST read list wait done                                                                 5'd13: LLIST read list send done                                                              5'd14: LLIST read list done                                                                            5'd15: LLIST read node                                                                                        5'd16: LLIST read node wait                                                                               5'd17: LLIST read node done                                                                      5'd18: LLIST node execution                                                                                    5'd19: LLIST node execution, wait done                                                   5'd20: LLIST node execution, send done                                             5'd21: LLIST node execution done                                                               5'd22: LLIST judge next state                                                                                    5'd23: LLIST pause                                                                                         5'd24: LLIST done                                                                                                        5'd25: read session key start                                                                                  5'd26: read session key done</comment>
        </bits>
        <bits access="r" name="rf_ce_rdma_data_status" pos="17:15" rst="0x0">
          <comment>rdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_sm4_status" pos="14:12" rst="0x0">
          <comment>sm4 state:                                                         3'd0: idle                                                                 3'd1: generate key                                            3'd2: round start                                                3'd3: rounding                                                   3'd4: xts generate key                                       3'd5: xts round start                                          3'd6: xts rounding                                             3'd7: done</comment>
        </bits>
        <bits access="r" name="rf_ce_wdma_data_status" pos="11:10" rst="0x0">
          <comment>wdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_aes_status" pos="7:0" rst="0x0">
          <comment>[3:0]: aes read counter;                                    [7:4]: aes work state                                          4'd0: idle                                                           4'd1: key expand                                               4'd2: xts encrypto tweek                                    4'd3: enc/decrpto select                                    4'd4: wait                                                                 4'd5: one block done                                        4'd6: xts encrypto tweek post                            4'd7: xts encrypto tweek pre   '                          4'd8: zero encrypto                                           4'd9: aad ghash                                                4'd10: length ghash                                          4'd11: gcm wait</comment>
        </bits>
      </reg>
      <reg name="ce_debug_tdes_status" protect="rw">
        <comment>tdes module state</comment>
        <bits access="r" name="rf_ce_tdes_status" pos="29:25" rst="0x0">
          <comment>tdes module status:                                           [3:0]: des run cycle counter
[4]: des key check error</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_wvalid_state" pos="24:21" rst="0x0">
          <comment>generate wvalid state:                                       4'd0: idle                                                           4'd1: wait enough data                               4'd2: generate wvalid                                        4'd3: wait enough data when bursting               4'd4: wait wready for next burst data</comment>
        </bits>
        <bits access="r" name="rf_ce_efuse_access_status" pos="20:16" rst="0x0">
          <comment>efuse access status:                                         5'd0: idle                                                           5'd1: read selec between hmac and symmetric                                         5'd2: trng write start                                        5'd3: hmac session key read start                              5'd4: trng write                                                  5'd5: hmac read                                             5'd6: symmetric key1 read start                      5'd7: symmetric key2 read start                      5'd8: symmetric key1 read                              5'd9: symmetric key2 read                              5'd10: done                                                  5'd11: hmac session key read                             5'd12: read huk  after write err                                        5'd13: trng write next                                                   5'd15: iram key done                                                   5'd16: pka non-symmetric key read start                      5'd17: pka non-symmetric key read                      5'd18: pka non-symmetric key write start                             5'd19: pka non-symmetric key write           5'd20: pka non-symmetric key write next   5'd21: ce read non-symmetric key after write err</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_dma_main_write_state" pos="15:13" rst="0x0">
          <comment>3'd0: idle                                                          3'd1: pka store start                                        3'd2: pka wait done                                         3'd3: pka send done                                       3'd4: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_dma_main_write_state" pos="12:8" rst="0x0">
          <comment>dma control main write port state:                     5'd0: idle                                                           5'd1: STD hash start                                            5'd2: STD start                                                  5'd3: STD wait done                                          5'd4: STD send done                                        5'd5: STD next state judgement                        5'd6: STD pause                                               5'd7: STD done                                                 5'd8: LLIST check node buffer status               5'd9: LLIST load node                                       5'd10: LLIST load node wait                               5'd11: LLIST load node update parameter       5'd12: LLIST load node done                            5'd13: LLIST hash start                                     5'd14: LLIST start                                             5'd15: LLIST wait done                                     5'd16: LLIST send done                                    5'd17: LLIST next start judgement                    5'd18: LLIST pause                                           5'd19: LLIST done                                              5'd20: pka store start                                        5'd21: pka wait done                                         5'd22: pka send done                                       5'd23: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_aes_status" pos="7:0" rst="0x0">
          <comment>[3:0]: aes read counter;                                    [7:4]: aes work state                                          4'd0: idle                                                           4'd1: key expand                                               4'd2: xts encrypto tweek                                    4'd3: enc/decrpto select                                    4'd4: wait                                                                 4'd5: one block done                                        4'd6: xts encrypto tweek post                            4'd7: xts encrypto tweek pre   '                          4'd8: zero encrypto                                           4'd9: aad ghash                                                4'd10: length ghash                                          4'd11: gcm wait</comment>
        </bits>
      </reg>
      <reg name="ce_debug_hash_status0" protect="rw">
        <comment>hash module state 0</comment>
      </reg>
      <reg name="ce_debug_hash_status1" protect="rw">
        <comment>hash module state 1</comment>
        <bits access="r" name="rf_ce_hash_status1" pos="9:0" rst="0x0">
          <comment>hash module status:                                          [2:0]: hash state                                            3'd0: idle          3'd1: data request                        3'd2: no-hmac  3'd3: hmac key                           3'd4: first hmac message                                  3'd5: second hmac message                              3'd6: digest out                                                 [8:3]: hash run cycle</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_clk_en" protect="rw">
        <comment>ce module clock enable</comment>
        <bits access="rw" name="rf_ce_fde_aes_clk_en" pos="28" rst="0x0">
          <comment>force fde aes clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_pub_clk_en" pos="25" rst="0x0">
          <comment>force pub rng autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_pub_clk_en" pos="24" rst="0x0">
          <comment>pub trng clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_clk_en" pos="23" rst="0x0">
          <comment>force chacha engine clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_poly_clk_en" pos="22" rst="0x0">
          <comment>force poly engine clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_clk_en" pos="21" rst="0x0">
          <comment>force rng autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_clk_en" pos="20" rst="0x0">
          <comment>force aes key expan autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_axi_clk_en" pos="18" rst="0x0">
          <comment>force dma axi autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_ctrl_clk_en" pos="17" rst="0x0">
          <comment>force dma ctrl autogate  clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_apb_rf_clk_en" pos="16" rst="0x0">
          <comment>force apb regbank autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_ck_en" pos="9" rst="0x0">
          <comment>simon speck clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_ck_en" pos="8" rst="0x0">
          <comment>pka clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacah_poly_ck_en" pos="7" rst="0x0">
          <comment>chacha poly clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_ck_en" pos="6" rst="0x0">
          <comment>sm4 clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_ck_en" pos="5" rst="0x0">
          <comment>trng clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_des_ck_en" pos="4" rst="0x0">
          <comment>des clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_ck_en" pos="3" rst="0x0">
          <comment>hash clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_ck_en" pos="2" rst="0x0">
          <comment>fde aes clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_ck_en" pos="1" rst="0x0">
          <comment>aes clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_ck_en" pos="0" rst="0x0">
          <comment>dma_main clock enable</comment>
        </bits>
      </reg>
      <reg name="ce_int_en" protect="rw">
        <comment>ce interrupt enable</comment>
        <bits access="rw" name="rf_ce_en_pka_rd_efuse_key_addr_int" pos="16" rst="0x0">
          <comment>enable pka load efuse addr  is out of range int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_wr_efuse_key_addr_int" pos="15" rst="0x0">
          <comment>enable pka store efuse addr  is out of range int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_len_err_int" pos="14" rst="0x0">
          <comment>enable pka load or store length is zero int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_cmd_done_done_int" pos="13" rst="0x0">
          <comment>enable ce pka one task done flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_find_prime_err_int" pos="12" rst="0x0">
          <comment>enable can't fime prime int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_div_zero_err_int" pos="11" rst="0x0">
          <comment>enable divisor zero int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_use_efuse_err_int" pos="10" rst="0x0">
          <comment>enable ce use efuse error int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_one_cmd_done_int" pos="9" rst="0x0">
          <comment>enable ce pka one cmd done int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_store_done_int" pos="8" rst="0x0">
          <comment>enable ce pka store done int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_rng_int" pos="7" rst="0x0">
          <comment>enable rng/trng int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_tdes_key_err_int" pos="5" rst="0x0">
          <comment>enable tdes key check error int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_len_err_int" pos="4" rst="0x0">
          <comment>enable src/dst length error int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_efs_all_zero_int" pos="2" rst="0x0">
          <comment>enable the efuse huk check zero int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_efs_huk_unstable_int" pos="1" rst="0x0">
          <comment>enable the efuse huk check unstable int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_cmd_done_int" pos="0" rst="0x0">
          <comment>enable one command done int</comment>
        </bits>
      </reg>
      <reg name="ce_int_status" protect="rw">
        <comment>ce interrupt status</comment>
        <bits access="r" name="rf_ce_pka_rd_efuse_key_addr_int_status" pos="16" rst="0x0">
          <comment>pka load efuse addr  is out of range</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_wr_efuse_key_addr_int_status" pos="15" rst="0x0">
          <comment>pka store efuse addr  is out of range,when the int is valid , ap clear it ,and  then need reset the  ce</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_len_err_int_status" pos="14" rst="0x0">
          <comment>pka load or store length is zero</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_cmd_done_done_int_status" pos="13" rst="0x0">
          <comment>ce pka one task done flag</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_find_prime_err_flag" pos="12" rst="0x0">
          <comment>can't fime prime flag</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_div_zero_err_flag" pos="11" rst="0x0">
          <comment>divisor zero flag</comment>
        </bits>
        <bits access="r" name="rf_ce_use_efuse_err_flag" pos="10" rst="0x0">
          <comment>ce use efuse error flag</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_one_cmd_done_flag" pos="9" rst="0x0">
          <comment>ce pka one cmd done flag</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_store_done_flag" pos="8" rst="0x0">
          <comment>ce pka store done flag</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_int_status" pos="7" rst="0x0">
          <comment>ce rng/trng int status</comment>
        </bits>
        <bits access="r" name="rf_ce_tdes_key_err_int_status" pos="5" rst="0x0">
          <comment>ce tdes key check error int status</comment>
        </bits>
        <bits access="r" name="rf_ce_len_err_int_status" pos="4" rst="0x0">
          <comment>src/dst length error int status</comment>
        </bits>
        <bits access="r" name="rf_ce_efs_all_zero_int_status" pos="2" rst="0x0">
          <comment>when ce write the huk parameters, the efuse ctrl response the error, then ce will check the write huk parameters is 0 or not; if it is 0, then intrrupt</comment>
        </bits>
        <bits access="r" name="rf_ce_efs_huk_unstable_int_status" pos="1" rst="0x0">
          <comment>when ce write the huk parameters, the efuse ctrl response the error, then ce will check the write huk parameters is 0 or not; if it is not 0 &amp; is unstable, then intrrupt</comment>
        </bits>
        <bits access="r" name="rf_ce_cmd_done_int_status" pos="0" rst="0x0">
          <comment>one command done int status,</comment>
        </bits>
      </reg>
      <reg name="ce_int_clear" protect="rw">
        <comment>ce interrupt clear</comment>
        <bits access="rc" name="rf_ce_clear_pka_rd_efuse_key_addr_int" pos="16" rst="0x0">
          <comment>clear pka load efuse addr  is out of range int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_wr_efuse_key_addr_int" pos="15" rst="0x0">
          <comment>clear pka store efuse addr  is out of range int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_len_err_int" pos="14" rst="0x0">
          <comment>clear pka load or store length is zero int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_cmd_done_done_int" pos="13" rst="0x0">
          <comment>clear ce pka one task done flag</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_find_prime_err_int" pos="12" rst="0x0">
          <comment>clear can't fime prime int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_div_zero_err_int" pos="11" rst="0x0">
          <comment>clear divisor zero int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_use_efuse_err_int" pos="10" rst="0x0">
          <comment>clear ce use efuse error flag</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_one_cmd_done_int" pos="9" rst="0x0">
          <comment>clear ce pka one cmd done flag</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_store_done_int" pos="8" rst="0x0">
          <comment>clear ce pka store done flag</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_tdes_key_err_int" pos="5" rst="0x0">
          <comment>clear tdes key check error int status</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_len_err_int" pos="4" rst="0x0">
          <comment>clear error int status</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_efs_all_zero_int" pos="2" rst="0x0">
          <comment>clear the huk is zero int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_efs_huk_unstable_int" pos="1" rst="0x0">
          <comment>clear the huk is unstable int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_cmd_done_int" pos="0" rst="0x0">
          <comment>clear one command done int status,</comment>
        </bits>
      </reg>
      <reg name="ce_start" protect="rw">
        <comment>start ce</comment>
        <bits access="rc" name="rf_ce_start" pos="0" rst="0x0">
          <comment>start ce one fo the AES/SM4/HASH cipher module</comment>
        </bits>
      </reg>
      <reg name="ce_clear" protect="rw">
        <comment>clear ce</comment>
        <bits access="rc" name="rf_ce_clear" pos="0" rst="0x0">
          <comment>reset ce status one fo the AES/SM4/HASH cipher module</comment>
        </bits>
      </reg>
      <reg name="ce_aes_mode" protect="rw">
        <comment>aes work mode cfg</comment>
        <bits access="rw" name="rf_ce_aes_key_update_n" pos="15" rst="0x0">
          <comment>1: don’t update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_xts_iv_rotation" pos="14" rst="0x1">
          <comment>0: rtl rotation, 1: no-rotation</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_key_len_sel" pos="13:12" rst="0x0">
          <comment>00: key 128bits,01:192bits,10,11:256bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_work_mode" pos="11:8" rst="0x0">
          <comment>0000:ECB,0001:CBC,0010:CTR,0011:XTS,0100:CMAC,0101:GCM,0110:GMAC,0111:CCM,1000:CBCMAC,1001:CFB,1010:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_mac_ctr_inc_mode" pos="6:5" rst="0x0">
          <comment>aes mac ctr inc mode:  00: normal mode; 01: low 64bit is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_en" pos="0" rst="0x0">
          <comment>aes module enable</comment>
        </bits>
      </reg>
      <reg name="ce_tdes_mode" protect="rw">
        <comment>tdes work mode cfg</comment>
        <bits access="rw" name="rf_ce_tdes_key_evenodd_check_on" pos="13" rst="0x0">
          <comment>0: disable,  1: enable even/odd check</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_key_even_sel" pos="12" rst="0x0">
          <comment>0:odd check,1:even check</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_work_mode" pos="9:8" rst="0x0">
          <comment>00:ECB,01:CBC</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_en" pos="0" rst="0x0">
          <comment>tdes module enable</comment>
        </bits>
      </reg>
      <reg name="ce_hash_mode" protect="rw">
        <comment>hash work mode cfg</comment>
        <bits access="rw" name="rf_hash_sha3_shake_out_len" pos="23:16" rst="0x0">
          <comment>sha3 shake out length</comment>
        </bits>
        <bits access="rw" name="rf_hash_hmac_pad_sel" pos="13:12" rst="0x0">
          <comment>00: normal hash; 01: ipad ;10: opad; 11: reserved</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_mode" pos="8:4" rst="0x0">
          <comment>hash work module,
5’d0: Doesn’t work
5’d1: MD5
5’d2: SHA-1 mode
5’d3: SHA-224 mode
5’d4: SHA-256 mode
5’d5: SHA-384 mode
5’d6: SHA-512 mode
5’d7: SHA-512/224 mode
5’d8: SHA-512/256 mode
5’d9: SM3 mode
5’d10: SHA3-224
5’d11: SHA3-256
5’d12: SHA3-384
5’d13: SHA3-512
5’d14: SHA3-SHAKE128
5’d15: SHA3-SHAKE256</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_en" pos="0" rst="0x0">
          <comment>hash module enable</comment>
        </bits>
      </reg>
      <reg name="ce_chacha_poly_mode" protect="rw">
        <comment>chacha poly work mode cfg</comment>
        <bits access="rw" name="rf_ce_chacha_poly_mode" pos="9:8" rst="0x0">
          <comment>00:chacha20 ; 01:poly1305;
10:AEAD_CHACHA20_POLY1305</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_poly_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encrypt,1:decrypt</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_poly_en" pos="0" rst="0x0">
          <comment>chacha poly module enable</comment>
        </bits>
      </reg>
      <reg name="ce_simon_speck_mode" protect="rw">
        <comment>simon speck work mode cfg</comment>
        <bits access="rw" name="rf_ce_simon_speck_key_update_n" pos="15" rst="0x0">
          <comment>1: don’t update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_key_len_sel" pos="14:13" rst="0x0">
          <comment>00: key 128bits,01:192bits,10:256bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_work_mode" pos="11:9" rst="0x0">
          <comment>000:ECB,001:CBC,010:CTR,100:CFB,101:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_sel" pos="8" rst="0x0">
          <comment>0:speck; 1:simon</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encrypt,1:decrypt</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_en" pos="0" rst="0x0">
          <comment>chacha poly module enable</comment>
        </bits>
      </reg>
      <reg name="ce_cfg" protect="rw">
        <comment>ce basic configure</comment>
        <bits access="rw" name="rf_ce_src_word_switch" pos="23" rst="0x0">
          <comment>switch source high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_word_switch" pos="22" rst="0x0">
          <comment>switch destination high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_src_byte_switch" pos="21" rst="0x1">
          <comment>source data switch of one word</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_byte_switch" pos="20" rst="0x0">
          <comment>destination data switch of one word</comment>
        </bits>
        <bits access="r" name="rf_ce_key_hdcp_en" pos="18" rst="0x0">
          <comment>0:disable hdcp mode, 1: enable hdcp mode</comment>
        </bits>
        <bits access="r" name="rf_ce_list_update_iv_sec_cnt" pos="17" rst="0x0">
          <comment>list update iv/sec/cnt flag</comment>
        </bits>
        <bits access="r" name="rf_ce_list_data_end_flag" pos="16" rst="0x0">
          <comment>data end in link list mode</comment>
        </bits>
        <bits access="r" name="rf_ce_list_end_flag" pos="15" rst="0x0">
          <comment>list end flag</comment>
        </bits>
        <bits access="r" name="rf_ce_list_aad_flag" pos="14" rst="0x0">
          <comment>0: isn't aad list 1: is aad list</comment>
        </bits>
        <bits access="r" name="rf_ce_list_aad_end_flag" pos="13" rst="0x0">
          <comment>0: aad no-end list 1: aad end list</comment>
        </bits>
        <bits access="rw" name="rf_ce_do_wait_bdone" pos="12" rst="0x1">
          <comment>wait axi B channel bready</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_iram_flag" pos="11" rst="0x0">
          <comment>0:normal mode, 1: iram key or secure ddr key</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_session_key_flag" pos="10" rst="0x0">
          <comment>0: normal mode, 1: aes/sm4 key from session key</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_efuse_flag" pos="9" rst="0x0">
          <comment>0: normal mode, 1: aes/sm4 key from efuse</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_ddr_flag" pos="8" rst="0x0">
          <comment>1: all crypto key in ddr/iram; 0: from registers</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_bypass" pos="7" rst="0x0">
          <comment>0:normal mode, 1: bypass ce</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_aad_flag" pos="6" rst="0x0">
          <comment>0: std flag 1: std aad flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_aad_end_flag" pos="5" rst="0x0">
          <comment>0: std aad no-end flag 1: std aad end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_end_flag" pos="4" rst="0x0">
          <comment>std end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_cmd_ioc" pos="3" rst="0x0">
          <comment>0: enable cmd int output: 1: don't output int</comment>
        </bits>
        <bits access="rw" name="rf_ce_dont_dump_ddr" pos="2" rst="0x0">
          <comment>0: dump from ddr; 1: don't dump</comment>
        </bits>
        <bits access="rw" name="rf_ce_dont_rcv_ddr" pos="1" rst="0x0">
          <comment>0: rcv from ddr; 1: don't rcv</comment>
        </bits>
        <bits access="rw" name="rf_ce_link_mode_flag" pos="0" rst="0x0">
          <comment>0:std mode, 1: link mode</comment>
        </bits>
      </reg>
      <reg name="ce_src_frag_length" protect="rw">
        <comment>dma read port node data length</comment>
        <bits access="rw" name="rf_ce_src_addr_hi" pos="27:24" rst="0x0">
          <comment>source address high 4bits; or aes mac aad address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_src_frag_len" pos="23:0" rst="0x0">
          <comment>source fragment length of each node;  or aes mac aad length</comment>
        </bits>
      </reg>
      <reg name="ce_dst_frag_length" protect="rw">
        <comment>dma write port node data length</comment>
        <bits access="rw" name="rf_ce_dst_addr_hi" pos="27:24" rst="0x0">
          <comment>destination address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_frag_len" pos="23:0" rst="0x0">
          <comment>destination fragment length of each node</comment>
        </bits>
      </reg>
      <reg name="ce_src_addr" protect="rw">
        <comment>dma source address</comment>
      </reg>
      <reg name="ce_dst_addr" protect="rw">
        <comment>dma destination address</comment>
      </reg>
      <reg name="ce_list_length" protect="rw">
        <comment>dma one length</comment>
        <bits access="rw" name="rf_ce_list_ptr_hi" pos="19:16" rst="0x0">
          <comment>ce_list_ptr high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_list_len" pos="11:0" rst="0x0">
          <comment>first list length,support max 256 nodes</comment>
        </bits>
      </reg>
      <reg name="ce_list_ptr" protect="rw">
        <comment>dma list pointer</comment>
      </reg>
      <reg name="ce_aes_tdes_rsa_key_length" protect="rw">
        <comment>aes tdes rsa key length</comment>
        <bits access="rw" name="rf_ce_aes_tdes_rsa_key_addr_hi" pos="27:24" rst="0x0">
          <comment>aes hmac key address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_tdes_rsa_key_len" pos="23:0" rst="0x0">
          <comment>aes hmac key length</comment>
        </bits>
      </reg>
      <reg name="ce_aes_tdes_rsa_key_address" protect="rw">
        <comment>aes tdes rsa key address</comment>
      </reg>
      <reg name="ce_aes_tag_length" protect="rw">
        <comment>aes tag length</comment>
        <bits access="rw" name="rf_ce_aes_tag_addr_hi" pos="11:8" rst="0x0">
          <comment>aes tag address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_tag_len" pos="7:0" rst="0x10">
          <comment>aes tag length</comment>
        </bits>
      </reg>
      <reg name="ce_aes_tag_address" protect="rw">
        <comment>aes tag address</comment>
      </reg>
      <reg name="ce_iv_sec_cnt0" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt1" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt2" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt3" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_aes_des_key10" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key11" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key12" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key13" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key14" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key15" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key16" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key17" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key20" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key21" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key22" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key23" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key24" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key25" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key26" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key27" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_sm4_mode" protect="rw">
        <comment>sm4 work mode cfg</comment>
        <bits access="rw" name="rf_ce_sm4_key_update_n" pos="12" rst="0x0">
          <comment>1: don’t update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_xts_inv_rotation" pos="11" rst="0x1">
          <comment>0: rtl rotation, 1: no-rotation</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_work_mode" pos="10:8" rst="0x0">
          <comment>000:ECB,001:CBC,010:CTR,011:XTS,100:CFB,101:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_en" pos="0" rst="0x0">
          <comment>sm4 module enable</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_ip_version" protect="rw">
        <comment>IP version</comment>
        <bits access="r" name="rf_ce_ip_version_hi" pos="31:4" rst="0x40">
          <comment>r4</comment>
        </bits>
        <bits access="rw" name="rf_ce_ip_version_lo" pos="3:0" rst="0x0">
          <comment>px</comment>
        </bits>
      </reg>
      <reg name="ce_pka_mode" protect="rw">
        <comment>pka work mode cfg</comment>
        <bits access="rw" name="rf_ce_pka_cmd_addr_hi" pos="31:28" rst="0x0">
          <comment>pka instruction address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_src_word_switch" pos="27" rst="0x0">
          <comment>switch source high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_dst_word_switch" pos="26" rst="0x0">
          <comment>switch destination high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_src_byte_switch" pos="25" rst="0x1">
          <comment>source data switch of one word</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_dst_byte_switch" pos="24" rst="0x0">
          <comment>destination data switch of one word</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_find_prime_num" pos="23:16" rst="0xff">
          <comment>find prime counter threshold</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_reg_num_sel" pos="1" rst="0x0">
          <comment>pka register number select; 0: 32, 1:16</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_en" pos="0" rst="0x0">
          <comment>pka module enable</comment>
        </bits>
      </reg>
      <reg name="ce_pka_reg_length01" protect="rw">
        <comment>pka register length01</comment>
        <bits access="rw" name="rf_ce_pka_reg_length1" pos="25:16" rst="0x20">
          <comment>ce pka register length1</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_reg_length0" pos="9:0" rst="0x20">
          <comment>ce pka register length0</comment>
        </bits>
      </reg>
      <reg name="ce_pka_reg_length23" protect="rw">
        <comment>pka register length23</comment>
        <bits access="rw" name="rf_ce_pka_reg_length3" pos="25:16" rst="0x20">
          <comment>ce pka register length3</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_reg_length2" pos="9:0" rst="0x20">
          <comment>ce pka register length2</comment>
        </bits>
      </reg>
      <hole size="704"/>
      <reg name="ce_pka_inst_pc" protect="rw">
        <comment>pka instruction pointer</comment>
        <bits access="r" name="rf_ce_pka_div_zero_err_flag" pos="31" rst="0x0">
          <comment>divisor zero</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_infinity_point_flag" pos="30" rst="0x0">
          <comment>ce pka infinity point</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_modinv_err" pos="29" rst="0x0">
          <comment>ce pka mod inv error</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_addsub_co" pos="28" rst="0x0">
          <comment>ce pka add/sub carry</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_find_prime_err_flag" pos="27" rst="0x0">
          <comment>can't fime prime</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_one_cmd_done" pos="25" rst="0x0">
          <comment>1: pka one cmd instruction done</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_store_done" pos="24" rst="0x0">
          <comment>1: pka store instruction done</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_inst_pc" pos="16:0" rst="0x0">
          <comment>pka instruction pointer</comment>
        </bits>
      </reg>
      <reg name="ce_pka_debug0" protect="rw">
        <comment>pka debug info</comment>
      </reg>
      <reg name="ce_pka_debug1" protect="rw">
        <comment>pka debug info</comment>
      </reg>
      <reg name="ce_pka_debug2" protect="rw">
        <comment>pka debug info</comment>
      </reg>
      <reg name="ce_pka_debug3" protect="rw">
        <comment>pka debug info</comment>
      </reg>
      <hole size="96"/>
      <reg name="ce_pf_calc" protect="rw">
        <comment>ce performace counter</comment>
      </reg>
      <reg name="ce_user_flag" protect="rw">
        <comment>ce use flag</comment>
        <bits access="rw" name="rf_ce_efuse_double_bit_en" pos="16" rst="0x1">
          <comment>the signal only can be confgi in the security apb,when the ce write the huk parameter,the bit should be 1'b1;</comment>
        </bits>
        <bits access="r" name="rf_ce_pub_priority_vld" pos="8" rst="0x0">
          <comment>when the siganl is high ,then flag the pub aes/sm4/hash is catch the cmd from the pub cmd buf or the pub is working</comment>
        </bits>
        <bits access="r" name="rf_ce_sec_priority_vld" pos="4" rst="0x0">
          <comment>when the siganl is high ,then flag the sec aes/sm4/hash is catch the cmd from the sec cmd buf or the sec is working</comment>
        </bits>
        <bits access="rw" name="rf_ce_use_flag" pos="0" rst="0x0">
          <comment>ce sec or pub use the ce aes/sm4/hash cicpher module</comment>
        </bits>
      </reg>
      <reg name="ce_axi_axcache" protect="rw">
        <comment>axi bus cache</comment>
        <bits access="rw" name="rf_ce_src_outstanding_num" pos="15:12" rst="0x7">
          <comment>axi read port outstanding number</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_outstanding_num" pos="11:8" rst="0x7">
          <comment>axi write port outstanding number</comment>
        </bits>
        <bits access="rw" name="rf_ce_axi_awcache" pos="7:4" rst="0x0">
          <comment>axi bus wcache</comment>
        </bits>
        <bits access="rw" name="rf_ce_axi_arcache" pos="3:0" rst="0x0">
          <comment>axi bus rcache</comment>
        </bits>
      </reg>
      <reg name="ce_cmd_stop_ctrl" protect="rw">
        <comment>cmd stop ctrl</comment>
        <bits access="rc" name="rf_ce_pka_cmd_stop_clear" pos="12" rst="0x0">
          <comment>to restart</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_cmd_stop_status" pos="9" rst="0x0">
          <comment>1: stop command is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_cmd_stop" pos="8" rst="0x0">
          <comment>0: to execute next cmd; 1: finish current cmd,then stop</comment>
        </bits>
        <bits access="rc" name="rf_ce_cmd_stop_clear" pos="4" rst="0x0">
          <comment>to restart</comment>
        </bits>
        <bits access="r" name="rf_ce_cmd_stop_status" pos="1" rst="0x0">
          <comment>1: stop command is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_cmd_stop" pos="0" rst="0x0">
          <comment>0: to execute next cmd; 1: finish current cmd,then stop</comment>
        </bits>
      </reg>
      <reg name="ce_axi_protect_sel" protect="rw">
        <comment>axi prot sel</comment>
        <bits access="rw" name="pka_dummy" pos="15:12" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="pka_axi_prot_sel_st" pos="11" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pka_axi_prot_sel_ld" pos="10" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pka_axi_prot_sel_cmd" pos="9" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pka_axi_prot_sel_en" pos="8" rst="0x0">
          <comment>0: disable pka side sel; 1: enable pka side axi sel</comment>
        </bits>
        <bits access="rw" name="sec_dummy" pos="7:5" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="sec_axi_prot_sel_wtxt" pos="4" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="sec_axi_prot_sel_rtxt" pos="3" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="sec_axi_prot_sel_rlist" pos="2" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="sec_axi_prot_sel_rkey" pos="1" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="sec_axi_prot_sel_en" pos="0" rst="0x0">
          <comment>0: disable sec side sel; 1: enable sec side axi sel</comment>
        </bits>
      </reg>
      <reg name="ce_pf_calc_high" protect="rw">
        <comment>ce performace counter high 32 bit</comment>
      </reg>
      <hole size="1216"/>
      <reg name="ce_rng_en" protect="rw">
        <comment>RNG module enable RNG module enable</comment>
        <bits access="rw" name="rf_ce_rng_data_mux_enable" pos="18" rst="0x0">
          <comment>if the signal is high,then the rng data  come from cpu.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_mux_ring_enable" pos="17" rst="0x0">
          <comment>if the signal is high,then the osc rings sel signal come from rf_rng_src_sel_enable.</comment>
        </bits>
        <bits access="rw" name="rf_rng_auto_enable" pos="16" rst="0x1">
          <comment>if the signal is high,then the osc rings is auto choose to work</comment>
        </bits>
        <bits access="rw" name="rf_rng_src_sel_enable" pos="15:8" rst="0xff">
          <comment>the signal control which osc ring is work,when the least bit is high,then the first one osc ring is choose as the entropy.</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_ptest_mode_en" pos="4" rst="0x0">
          <comment>trng source test enable</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_rst_from_cpu" pos="3" rst="0x0">
          <comment>the rst signal to the exotic trng module</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_src_from_cpu_enable" pos="2" rst="0x0">
          <comment>the signal can change when the trng is work ,which can control the trng start or stop by cpu.</comment>
        </bits>
        <bits access="rc" name="rf_ce_trng_src_en" pos="1" rst="0x0">
          <comment>trng source enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_en" pos="0" rst="0x0">
          <comment>RNG module enable bit:
1:enbale RNG module to generate random number when auto mode is not enable</comment>
        </bits>
      </reg>
      <reg name="ce_rng_config" protect="rw">
        <comment>RNG module config RNG module config</comment>
        <bits access="rw" name="number_of_samples_threshold" pos="31:20" rst="0xfff">
          <comment>Threshold bit value for random data , indicates that the cycle of the src_en is high, the max value is 12'hFFF.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_ptest_data_in" pos="16" rst="0x0">
          <comment>when the data_in is 0,the test result should be 1,and the data_in is 1,the test result should be 0;</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_data_valid_threshold" pos="11:8" rst="0x3">
          <comment>Threshold value for rng_data_valid, indicates that when rng_data_valid high, there area at least number of rng_data_valid_threshold words in SRAM，the max value is 4'hf.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_exotic_fault_rst_sel" pos="7" rst="0x0">
          <comment>ce_rng_exotic_fault_rst_sel:                  1'b0:the rst generated by the fault signal,                 1'b1:don't generated the rst signal,the rst signal come from the cpu</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_source_sel" pos="6:5" rst="0x3">
          <comment>local RNG entropty source select</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_data_len_sel" pos="4" rst="0x0">
          <comment>when it's 1,the the post process module need data bitwith is 440bit,else is 256bit</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_trng_sel" pos="3" rst="0x0">
          <comment>the signal select the trng data come from exotic or local trng module 1:exotic 0:local</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_ring_sel" pos="2:0" rst="0x3">
          <comment>select entropy source,the range is 0x0 to 0x7</comment>
        </bits>
      </reg>
      <reg name="ce_rng_data" protect="rw">
        <comment>RNG data for cpu to read RNG data for cpu to read</comment>
      </reg>
      <reg name="ce_rng_sample_period" protect="rw">
        <comment>time interval between two samples time interval between two samples</comment>
        <bits access="rw" name="rf_ce_rng_first_sample_en" pos="31" rst="0x0">
          <comment>enable first level sample</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_first_sample_period" pos="30:16" rst="0x0">
          <comment>sample period between two samples, the value is from 0 to 255</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_second_sample_period" pos="15:0" rst="0x0">
          <comment>sample period between two samples, the value is from 0 to 255</comment>
        </bits>
      </reg>
      <reg name="ce_rng_post_process_en" protect="rw">
        <comment>post process functions select post process functions select</comment>
        <bits access="rw" name="rf_ce_rng_post_eight_en" pos="7" rst="0x0">
          <comment>when it's 1,the the PRNG data  xor with trng data</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_seven_en" pos="6" rst="0x1">
          <comment>when it's 1,the the final post process module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_six_en" pos="5" rst="0x0">
          <comment>when it's 1,the the xor process module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_five_en" pos="4" rst="0x0">
          <comment>when it's 1,the the cycle_code module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_four_en" pos="3" rst="0x0">
          <comment>when it's 1,the the lfsr module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_three_en" pos="2" rst="0x0"/>
        <bits access="rw" name="rf_ce_rng_post_second_en" pos="1" rst="0x0">
          <comment>post data path 1 enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_first_en" pos="0" rst="0x0">
          <comment>post data path 0 enable</comment>
        </bits>
      </reg>
      <reg name="ce_rng_work_status" protect="rw">
        <comment>rng work status rng work status</comment>
        <bits access="r" name="rf_ce_rng_rsa_key_gen_rand_num" pos="31:16" rst="0x0">
          <comment>rand data number when keygen done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_process" pos="15:14" rst="0x0">
          <comment>2'b01:Instantiate ;                                                     2'b10:Reseed ;                                                       2'b11:Genarate.</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_pattern_req" pos="13" rst="0x0">
          <comment>when it's 1,cpu can send next 64bit pattern</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_fail" pos="12" rst="0x0">
          <comment>when it's 1,the drbg KAT test fail</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_done" pos="11" rst="0x0">
          <comment>DRBG KAT test done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_es_test_fail" pos="10" rst="0x0">
          <comment>when it's 1,the start-up/on-demand test fail(1024 sample)</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_es_test_done" pos="9" rst="0x0">
          <comment>start-up/on-demand test done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_test_result" pos="8" rst="0x0">
          <comment>the result of test mode</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_result_vld" pos="7" rst="0x0">
          <comment>when it's 1,indicate that the drbg test result data in 0x260 register is valid (cpu can read to check)</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_data_type" pos="6:5" rst="0x0">
          <comment>2'b01: C [439:0] ;                                                    2'b10: V[439:0] ;                                                        2'b11: reseed_counter[31:0].                                  Corresponds to the data of each process in [15:14] .</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_fifo_empty" pos="4" rst="0x1">
          <comment>the fifo status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_error_fault" pos="3" rst="0x0">
          <comment>the exotic rng module status</comment>
        </bits>
        <bits access="r" name="rf_rng_rsa_pka_busy" pos="2" rst="0x0"/>
        <bits access="r" name="rf_ce_rng_data_valid" pos="1" rst="0x0">
          <comment>when high indicates that RNG module has generate 256 bits random data</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_auto_mode_ongoing" pos="0" rst="0x0">
          <comment>when high indicates that auto mode is ongoing, CPU can't access rng_data register</comment>
        </bits>
      </reg>
      <reg name="ce_rng_timeout_cnt" protect="rw">
        <comment>rng time out counter rng time out counter</comment>
      </reg>
      <reg name="ce_rng_int_en" protect="rw">
        <comment>rng interrupt enable rng interrupt enable</comment>
        <bits access="rw" name="rf_ce_rng_cont_htest_int_en" pos="5" rst="0x0">
          <comment>enable continuous health test interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_sram_short_int_en" pos="4" rst="0x0">
          <comment>enable sram short interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_timeout_int_en" pos="3" rst="0x0">
          <comment>enable timeout interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process2_int_en" pos="2" rst="0x0">
          <comment>enable process2 interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process1_int_en" pos="1" rst="0x0">
          <comment>enable process1 interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process0_int_en" pos="0" rst="0x0">
          <comment>enable process0 interrupt</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sts" protect="rw">
        <comment>rng interrupt status rng interrupt status</comment>
        <bits access="r" name="rf_ce_rng_con_htest_int_sts" pos="5" rst="0x0">
          <comment>continuous health test interrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_sram_short_int_sts" pos="4" rst="0x0">
          <comment>sram_short_interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_timeout_int_sts" pos="3" rst="0x0">
          <comment>timeout interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process2_int_sts" pos="2" rst="0x0">
          <comment>process2 interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process1_int_sts" pos="1" rst="0x0">
          <comment>process1 interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process0_int_sts" pos="0" rst="0x0">
          <comment>process0 interrrupt status</comment>
        </bits>
      </reg>
      <reg name="ce_rng_int_clr" protect="rw">
        <comment>rng interrupt clear rng interrupt clear</comment>
        <bits access="rc" name="rf_ce_rng_clear_con_htest_int" pos="5" rst="0x0">
          <comment>clear continuous health test interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_sram_short_int" pos="4" rst="0x0">
          <comment>clear sram short  interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_timeout_int" pos="3" rst="0x0">
          <comment>clear timeout interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process2_int" pos="2" rst="0x0">
          <comment>clear process2 interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process1_int" pos="1" rst="0x0">
          <comment>clear process1 interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process0_int" pos="0" rst="0x0">
          <comment>clear process0 interrupt</comment>
        </bits>
      </reg>
      <reg name="ce_rng_mode" protect="rw">
        <comment>RNG module work mode RNG module work mode</comment>
        <bits access="rw" name="rf_ce_prng_mode" pos="8" rst="0x0">
          <comment>PRNG work mode:
1: Auto Seed update Mode
0: Mannual seed update Mode</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_mode" pos="1:0" rst="0x0">
          <comment>RNG module work mode:
10: PRNG mode
01: TRNG mode                                           00：11: Mixed mode for TRNG</comment>
        </bits>
      </reg>
      <reg name="ce_prng_seed_update" protect="rw">
        <comment>PRNG mode seed update config PRNG mode seed update config</comment>
        <bits access="rc" name="rf_ce_prng_seed_update" pos="0" rst="0x0">
          <comment>When Write to 1, PRNG will update seed to PRNG_SEED_CONFIG register value</comment>
        </bits>
      </reg>
      <reg name="ce_prng_seed_config" protect="rw">
        <comment>PRNG mode seed update config PRNG mode seed update config</comment>
      </reg>
      <reg name="ce_rng_bit_rate" protect="rw">
        <comment>RNG Bit Rate RNG Bit Rate</comment>
        <bits access="r" name="rf_rng_gen_bit_cnt" pos="31:16" rst="0x0">
          <comment>RNG Bit Counter</comment>
        </bits>
        <bits access="r" name="rf_rng_bit_rate" pos="15:0" rst="0x0">
          <comment>RNG Bit number each 10000 clock cycle</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sram_data_threshhold" protect="rw">
        <comment>SRAM data numuber threshold SRAM data numuber threshold</comment>
        <bits access="rw" name="rf_ce_rng_sram_valid_threshholdd" pos="3:0" rst="0x0">
          <comment>SRAM data numuber threshold,</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sram_data_residue_num" protect="rw">
        <comment>rng_sram_data_residue_num rng_sram_data_residue_num</comment>
        <bits access="r" name="rf_ce_rng_sram_data_residue_num" pos="3:0" rst="0x0">
          <comment>rng_sram_data_residue_num</comment>
        </bits>
      </reg>
      <reg name="ce_rng_exotic_fault_counter_config" protect="rw">
        <comment>exotic fault counter rng exotic fault counter config</comment>
        <bits access="rw" name="rf_ce_exotic_fault_counter_config" pos="15:0" rst="0x0">
          <comment>config the fault counter and read the counter</comment>
        </bits>
      </reg>
      <reg name="ce_rng_drbg_seed_cnt" protect="rw">
        <comment>drbg seed count drbg seed count</comment>
        <bits access="rw" name="rf_ce_rng_drbg_seed_cnt" pos="15:0" rst="0xc">
          <comment>config the drbg seed after certain time</comment>
        </bits>
      </reg>
      <reg name="ce_rng_ring_num_cfg_l" protect="rw">
        <comment>config ring ring number config ring ring number</comment>
      </reg>
      <reg name="ce_rng_ring_num_cfg_h" protect="rw">
        <comment>config ring ring number config ring ring number</comment>
      </reg>
      <reg name="ce_rng_health_test_config" protect="rw">
        <comment>rng_health_test_config rng_health_test_config</comment>
        <bits access="rw" name="rf_ce_rng_ones_freq_max" pos="18:8" rst="0x25f">
          <comment>default:11'd607(freq 0/1 in 1024)</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_long_term_bit_max" pos="7:2" rst="0x2f">
          <comment>default:6'd47 (conse 48 0/1)   [23]</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_drbg_test_en" pos="1" rst="0x0">
          <comment>open drbg test(on-demand test)</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_es_test_en" pos="0" rst="0x0">
          <comment>open es test(on-demand test)</comment>
        </bits>
      </reg>
      <reg name="ce_rng_drbg_test_pattern_l" protect="rw">
        <comment>ce_rng_drbg_test_pattern_l ce_rng_drbg_test_pattern_l</comment>
      </reg>
      <reg name="ce_rng_drbg_test_pattern_h" protect="rw">
        <comment>ce_rng_drbg_test_pattern_h ce_rng_drbg_test_pattern_h</comment>
      </reg>
      <reg name="ce_rng_raw_data_to_cpu" protect="rw">
        <comment>raw_random_number raw_random_number</comment>
      </reg>
      <reg name="ce_rng_drbg_test_result" protect="rw">
        <comment>ce_rng_drbg_sha256_result ce_rng_drbg_sha256_result</comment>
      </reg>
      <hole size="1248"/>
      <reg name="ce_session_key0" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key1" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key2" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key3" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key4" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key5" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key6" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key7" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key0" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key1" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key2" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key3" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key4" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key5" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key6" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key7" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_secure_key_use_way" protect="rw">
        <comment>ce secure key work mode</comment>
        <bits access="rw" name="rf_ce_secure_key_trng_write" pos="31" rst="0x0">
          <comment>trng output random data for secure key flag;when 256bits HUK output into efuse,the bit will be zero.</comment>
        </bits>
        <bits access="rw" name="rf_ce_secure_key_cpu_access" pos="30" rst="0x0">
          <comment>cpu access secure key flag;the falling edge is to let efuse controller sync data into efuse memory</comment>
        </bits>
        <bits access="rw" name="rf_ce_secure_key_len" pos="29:21" rst="0x0">
          <comment>secure key length configure for key in efuse feature,when read key from efuse, need know this key length</comment>
        </bits>
        <bits access="rw" name="rf_ce_secure_key2_start_raddr" pos="20:11" rst="0x0">
          <comment>secure key2 start read address of efuse memory</comment>
        </bits>
        <bits access="rw" name="rf_ce_secure_key1_start_raddr" pos="10:1" rst="0x0">
          <comment>secure key1 start read address of efuse memory</comment>
        </bits>
        <bits access="rw" name="rf_ce_secure_key2_en" pos="0" rst="0x0">
          <comment>need to read secure key2 from efuse;when need two key(key1 and key2), this bit should be set.</comment>
        </bits>
      </reg>
      <reg name="ce_huk_key_config" protect="rw">
        <comment>ce huk key config</comment>
        <bits access="rw" name="rf_ce_write_efs_addr" pos="31:16" rst="0x0">
          <comment>HUK key initial address</comment>
        </bits>
        <bits access="rw" name="rf_ce_write_efs_length" pos="7:0" rst="0x20">
          <comment>HUK key length</comment>
        </bits>
      </reg>
      <reg name="ce_pka_key_config" protect="rw">
        <comment>ce pka key config</comment>
        <bits access="rw" name="rf_pka_write_efs_end_addr" pos="25:16" rst="0x3ff">
          <comment>PKA private key end address,default value depends on the parameter value passed by AP to CE top,this register writing funciton is standing off .</comment>
        </bits>
        <bits access="rw" name="rf_pka_write_efs_start_addr" pos="9:0" rst="0x0">
          <comment>PKA private key start address,default value depends on the parameter value passed by AP to CE top ,this register writing funciton is standing off .</comment>
        </bits>
      </reg>
      <hole size="3488"/>
      <reg name="ce_cmd_fifo_entry" protect="rw">
        <comment>ce_cmd_fifo_entry</comment>
      </reg>
      <reg name="ce_cmd_fifo_status" protect="rw">
        <comment>ce_cmd_fifo_status</comment>
      </reg>
      <reg name="ce_rcv_addr_lo" protect="rw">
        <comment>ce_rcv_addr_lo</comment>
      </reg>
      <reg name="ce_dump_addr_lo" protect="rw">
        <comment>ce_dump_addr_lo</comment>
      </reg>
      <reg name="ce_dump_addr_hi" protect="rw">
        <comment>ce_dump_addr_hi</comment>
        <bits access="rw" name="rf_ce_dump_addr_hi" pos="7:4" rst="0x0">
          <comment>ce dump address hi</comment>
        </bits>
        <bits access="rw" name="rf_ce_rcv_addr_hi" pos="3:0" rst="0x0">
          <comment>ce rcv address hi</comment>
        </bits>
      </reg>
      <reg name="ce_finish_cmd_cnt" protect="rw">
        <comment>ce_finish_cmd_cnt</comment>
      </reg>
      <hole size="1856"/>
      <reg name="ce_pka_cmd_fifo_entry" protect="rw">
        <comment>ce_pka_cmd_fifo_entry</comment>
      </reg>
      <reg name="ce_pka_cmd_fifo_status" protect="rw">
        <comment>ce_pka_cmd_fifo_status</comment>
      </reg>
      <reg name="ce_pka_cmd_addr" protect="rw">
        <comment>pka cmd dma source address</comment>
      </reg>
      <reg name="ce_pka_store_addr_hi" protect="rw">
        <comment>pka store dma destination address</comment>
        <bits access="rw" name="rf_ce_pka_store_addr_hi" pos="18:0" rst="0x0">
          <comment>pka store high 19bits addr</comment>
        </bits>
      </reg>
      <reg name="ce_pka_load_addr_hi" protect="rw">
        <comment>pka load address</comment>
        <bits access="rw" name="rf_ce_pka_load_addr_hi" pos="18:0" rst="0x0">
          <comment>pka load high 19bits addr</comment>
        </bits>
      </reg>
      <reg name="ce_pka_finish_cmd_cnt" protect="rw">
        <comment>ce_pka_finish_cmd_cnt</comment>
      </reg>
      <reg name="ce_pka_start" protect="rw">
        <comment>start ce pka</comment>
        <bits access="rc" name="rf_ce_pka_start" pos="0" rst="0x0">
          <comment>start ce pka</comment>
        </bits>
      </reg>
      <reg name="ce_pka_clear" protect="rw">
        <comment>clear ce pka</comment>
        <bits access="rc" name="rf_ce_pka_clear" pos="0" rst="0x0">
          <comment>reset ce pka status</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_pka_rng_force_ssb_bit" protect="rw">
        <comment>ce_pka_rng_force_ssb_bit</comment>
        <bits access="rw" name="rf_ce_pka_rng_force_ssb_bit" pos="0" rst="0x1">
          <comment>force the prime ssb bit is 1</comment>
        </bits>
      </reg>
      <reg name="ce_pka_ctrl_operate_bit" protect="rw">
        <comment>ce_pka_ctrl_operate_bit</comment>
        <bits access="rw" name="ce_pka_store_limit_cfg_disable" pos="0" rst="0x0">
          <comment>this bit control the store inst,
1:when the bit set 1, then the store data from pka ram to ddr don't have any limit;
when the bit set 0, then the store inst need judge the buf can store out or not, the store register index can config through the pka load_rng inst;</comment>
        </bits>
      </reg>
      <reg name="ce_pka_efs_debug_status" protect="rw">
        <comment>pka write efuse and read efuse work status</comment>
        <bits access="r" name="rf_pka_access_efuse_flag" pos="23:20" rst="0x0">
          <comment>bit[23]:reserved                                           bit[22]:pka read efuse cmd vaild;         bit[21]:pka write efuse cmd vaild;        bit[20]:used to control pka load FSM state jump;</comment>
        </bits>
        <bits access="r" name="rf_pka_and_huk_access_efuse_status" pos="19:16" rst="0x0">
          <comment>bit[19]:indicates pka would read efuse  when the huk is reading or writing  efuse;             bit[18]:indicates pka would write efuse  when the huk is reading or writing  efuse;            bit[17]:indicates huk would read efuse  when the  pka is reading or writing  efuse;             bit[16]:indicates huk would write efuse  when the pka is reading or writing  efuse;</comment>
        </bits>
        <bits access="r" name="rf_pka_read_efuse_count" pos="15:8" rst="0x0">
          <comment>depend on read pka private key length,ce top starts to count,when this count</comment>
        </bits>
        <bits access="r" name="rf_pka_write_efuse_count" pos="7:0" rst="0x0">
          <comment>depend on write pka private key length,ce top starts to count</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04004000" name="CE_SEC" type="CE_SEC"/>
  </archive>
  <archive relative="ce_pub.xml">
    <module category="System" name="CE_PUB">
      <reg name="ce_debug_dma_status" protect="rw">
        <comment>axi bus status and dma work state status</comment>
        <bits access="r" name="rf_ce_wready" pos="31" rst="0x0">
          <comment>axi write data channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_awready" pos="30" rst="0x0">
          <comment>axi write address channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_arready" pos="29" rst="0x0">
          <comment>axi read address channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_busy" pos="28" rst="0x0">
          <comment>dma is working,and CPU can't access ce registers except ce_clear register.</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_dst_state" pos="26:22" rst="0x0">
          <comment>dma write port state:                                         4'd0: idle                                                           4'd1: write burst calculate                                   4'd2: write burst calculate data number              4'd3: write burst wait enough data                    4'd4: write burst start                                        4'd5: write burst execute                                   4'd6: write burst wait burst end                         4'd7: write burst end</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_src_state" pos="21:17" rst="0x0">
          <comment>dma read port state:                                         4'd0: idle                                                           4'd1: read burst wait enough buffer space        4'd2: read burst wait one cycle                         4'd3: read burst start                                        4'd4: read burst execute                                   4'd5: read burst wait burst end                         4'd6: read burst done</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_cmd_fifo_non_empty" pos="16" rst="0x0">
          <comment>fde cmd fifo is non-empty</comment>
        </bits>
        <bits access="r" name="rf_ce_cmd_fifo_non_empty" pos="15" rst="0x0">
          <comment>cmd fifo is non-empty</comment>
        </bits>
        <bits access="r" name="rf_ce_int_raw_status_vld" pos="14" rst="0x0">
          <comment>interrupt raw status is valid</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_err" pos="13" rst="0x0">
          <comment>ce in error status</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_main_write_state" pos="12:8" rst="0x0">
          <comment>dma control main write port state:                     5'd0: idle                                                           5'd1: STD hash start                                            5'd2: STD start                                                  5'd3: STD wait done                                          5'd4: STD send done                                        5'd5: STD next state judgement                        5'd6: STD pause                                               5'd7: STD done                                                 5'd8: LLIST check node buffer status               5'd9: LLIST load node                                       5'd10: LLIST load node wait                               5'd11: LLIST load node update parameter       5'd12: LLIST load node done                            5'd13: LLIST hash start                                     5'd14: LLIST start                                             5'd15: LLIST wait done                                     5'd16: LLIST send done                                    5'd17: LLIST next start judgement                    5'd18: LLIST pause                                           5'd19: LLIST done</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_pka_main_read_state" pos="7:5" rst="0x0">
          <comment>3'd0: idle                                                      3'd1: pka read instruction start                                                                         3'd2: pka load start                                                                                                    3'd3: pka wait done                                                                                                   3'd4: pka send done                                                                                                 3'd5: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_main_read_state" pos="4:0" rst="0x0">
          <comment>dma control main read port state:                     5'd0: idle                                                                                                                     5'd1: read key/hmac key/aad start                                                            5'd2: wait read key/hmac key/aad done                                                5'd3: read key/hmac key/aad, send done                                             5'd4: read key/hmac key/aad done                                                          5'd5: STD read start                                                                                                5'd6: STD wait done                                                                                           5'd7: STD send done                                                                                        5'd8: STD done,then judgement                                                               5'd9: STD pause                                                                                                     5'd10: STD done                                                                                                     5'd11: LLIST read list                                                                                                  5'd12: LLIST read list wait done                                                                 5'd13: LLIST read list send done                                                              5'd14: LLIST read list done                                                                            5'd15: LLIST read node                                                                                        5'd16: LLIST read node wait                                                                               5'd17: LLIST read node done                                                                      5'd18: LLIST node execution                                                                                    5'd19: LLIST node execution, wait done                                                   5'd20: LLIST node execution, send done                                             5'd21: LLIST node execution done                                                               5'd22: LLIST judge next state                                                                                    5'd23: LLIST pause                                                                                         5'd24: LLIST done                                                                                                        5'd25: read session key start                                                                                  5'd26: read session key done</comment>
        </bits>
      </reg>
      <reg name="ce_debug_aes_status" protect="rw">
        <comment>aes module state</comment>
        <bits access="r" name="rf_ce_fde_rdma_data_status" pos="28:27" rst="0x0">
          <comment>rdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_wdma_data_status" pos="26:25" rst="0x0">
          <comment>wdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_dma_main_read_state" pos="24:20" rst="0x0">
          <comment>dma control main read port state:                     5'd0: idle                                                                                                                     5'd1: read key/hmac key/aad start                                                            5'd2: wait read key/hmac key/aad done                                                5'd3: read key/hmac key/aad, send done                                             5'd4: read key/hmac key/aad done                                                          5'd5: STD read start                                                                                                5'd6: STD wait done                                                                                           5'd7: STD send done                                                                                        5'd8: STD done,then judgement                                                               5'd9: STD pause                                                                                                     5'd10: STD done                                                                                                     5'd11: LLIST read list                                                                                                  5'd12: LLIST read list wait done                                                                 5'd13: LLIST read list send done                                                              5'd14: LLIST read list done                                                                            5'd15: LLIST read node                                                                                        5'd16: LLIST read node wait                                                                               5'd17: LLIST read node done                                                                      5'd18: LLIST node execution                                                                                    5'd19: LLIST node execution, wait done                                                   5'd20: LLIST node execution, send done                                             5'd21: LLIST node execution done                                                               5'd22: LLIST judge next state                                                                                    5'd23: LLIST pause                                                                                         5'd24: LLIST done                                                                                                        5'd25: read session key start                                                                                  5'd26: read session key done</comment>
        </bits>
        <bits access="r" name="rf_ce_rdma_data_status" pos="17:15" rst="0x0">
          <comment>rdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_sm4_status" pos="14:12" rst="0x0">
          <comment>sm4 state:                                                         3'd0: idle                                                                 3'd1: generate key                                            3'd2: round start                                                3'd3: rounding                                                   3'd4: xts generate key                                       3'd5: xts round start                                          3'd6: xts rounding                                             3'd7: done</comment>
        </bits>
        <bits access="r" name="rf_ce_wdma_data_status" pos="11:10" rst="0x0">
          <comment>wdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_aes_status" pos="7:0" rst="0x0">
          <comment>[3:0]: aes read counter;                                    [7:4]: aes work state                                          4'd0: idle                                                           4'd1: key expand                                               4'd2: xts encrypto tweek                                    4'd3: enc/decrpto select                                    4'd4: wait                                                                 4'd5: one block done                                        4'd6: xts encrypto tweek post                            4'd7: xts encrypto tweek pre   '                          4'd8: zero encrypto                                           4'd9: aad ghash                                                4'd10: length ghash                                          4'd11: gcm wait</comment>
        </bits>
      </reg>
      <reg name="ce_debug_tdes_status" protect="rw">
        <comment>tdes module state</comment>
        <bits access="r" name="rf_ce_tdes_status" pos="29:25" rst="0x0">
          <comment>tdes module status:                                           [3:0]: des run cycle counter
[4]: des key check error</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_wvalid_state" pos="24:21" rst="0x0">
          <comment>generate wvalid state:                                       4'd0: idle                                                           4'd1: wait enough data                               4'd2: generate wvalid                                        4'd3: wait enough data when bursting               4'd4: wait wready for next burst data</comment>
        </bits>
        <bits access="r" name="rf_ce_efuse_access_status" pos="20:16" rst="0x0">
          <comment>efuse access status:                                         5'd0: idle                                                           5'd1: read selec between hmac and symmetric                                         5'd2: trng write start                                        5'd3: hmac session key read start                              5'd4: trng write                                                  5'd5: hmac read                                             5'd6: symmetric key1 read start                      5'd7: symmetric key2 read start                      5'd8: symmetric key1 read                              5'd9: symmetric key2 read                              5'd10: done                                                  5'd11: hmac session key read                             5'd12: read huk  after write err                                        5'd13: trng write next                                                   5'd15: iram key done                                                   5'd16: pka non-symmetric key read start                      5'd17: pka non-symmetric key read                      5'd18: pka non-symmetric key write start                             5'd19: pka non-symmetric key write           5'd20: pka non-symmetric key write next   5'd21: ce read non-symmetric key after write err</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_dma_main_write_state" pos="15:13" rst="0x0">
          <comment>3'd0: idle                                                           3'd1: pka store start                                         3'd2: pka wait done                                          3'd3: pka send done                                         3'd4: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_dma_main_write_state" pos="12:8" rst="0x0">
          <comment>dma control main write port state:                     5'd0: idle                                                           5'd1: STD hash start                                            5'd2: STD start                                                  5'd3: STD wait done                                          5'd4: STD send done                                        5'd5: STD next state judgement                        5'd6: STD pause                                               5'd7: STD done                                                 5'd8: LLIST check node buffer status               5'd9: LLIST load node                                       5'd10: LLIST load node wait                               5'd11: LLIST load node update parameter       5'd12: LLIST load node done                            5'd13: LLIST hash start                                     5'd14: LLIST start                                             5'd15: LLIST wait done                                     5'd16: LLIST send done                                    5'd17: LLIST next start judgement                    5'd18: LLIST pause                                           5'd19: LLIST done                                              5'd20: pka store start                                        5'd21: pka wait done                                         5'd22: pka send done                                       5'd23: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_aes_status" pos="7:0" rst="0x0">
          <comment>[3:0]: aes read counter;                                    [7:4]: aes work state                                          4'd0: idle                                                           4'd1: key expand                                               4'd2: xts encrypto tweek                                    4'd3: enc/decrpto select                                    4'd4: wait                                                                 4'd5: one block done                                        4'd6: xts encrypto tweek post                            4'd7: xts encrypto tweek pre   '                          4'd8: zero encrypto                                           4'd9: aad ghash                                                4'd10: length ghash                                          4'd11: gcm wait</comment>
        </bits>
      </reg>
      <reg name="ce_debug_hash_status0" protect="rw">
        <comment>hash module state 0</comment>
      </reg>
      <reg name="ce_debug_hash_status1" protect="rw">
        <comment>hash module state 1</comment>
        <bits access="r" name="rf_ce_hash_status1" pos="9:0" rst="0x0">
          <comment>hash module status:                                          [2:0]: hash state                                            3'd0: idle          3'd1: data request                        3'd2: no-hmac  3'd3: hmac key                           3'd4: first hmac message                                  3'd5: second hmac message                              3'd6: digest out                                                 [8:3]: hash run cycle</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_clk_en" protect="rw">
        <comment>ce module clock enable</comment>
        <bits access="rw" name="rf_ce_fde_aes_clk_en" pos="28" rst="0x0">
          <comment>force fde aes clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_pub_clk_en" pos="25" rst="0x0">
          <comment>force pub rng autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_pub_ck_en" pos="24" rst="0x0">
          <comment>pub trng clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_clk_en" pos="23" rst="0x0">
          <comment>force chacha engine clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_poly_clk_en" pos="22" rst="0x0">
          <comment>force poly engine clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_clk_en" pos="21" rst="0x0">
          <comment>force rng autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_clk_en" pos="20" rst="0x0">
          <comment>force aes key expan autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_axi_clk_en" pos="18" rst="0x0">
          <comment>force dma axi autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_ctrl_clk_en" pos="17" rst="0x0">
          <comment>force dma ctrl autogate  clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_apb_rf_clk_en" pos="16" rst="0x0">
          <comment>force apb regbank autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_ck_en" pos="9" rst="0x0">
          <comment>simon speck clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_ck_en" pos="8" rst="0x0">
          <comment>pka clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacah_poly_ck_en" pos="7" rst="0x0">
          <comment>chacha poly clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_ck_en" pos="6" rst="0x0">
          <comment>sm4 clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_ck_en" pos="5" rst="0x0">
          <comment>trng clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_des_ck_en" pos="4" rst="0x0">
          <comment>des clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_ck_en" pos="3" rst="0x0">
          <comment>hash clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_ck_en" pos="2" rst="0x0">
          <comment>fde aes clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_ck_en" pos="1" rst="0x0">
          <comment>aes clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_ck_en" pos="0" rst="0x0">
          <comment>dma_main clock enable</comment>
        </bits>
      </reg>
      <reg name="ce_int_en" protect="rw">
        <comment>ce interrupt enable</comment>
        <bits access="rw" name="rf_ce_fde_en_len_err_int" pos="21" rst="0x0">
          <comment>enable src/dst length error int</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_en_cmd_done_int" pos="20" rst="0x0">
          <comment>enable one command done int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_len_err_int" pos="17" rst="0x0">
          <comment>enable src/dst length error int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_cmd_done_int" pos="16" rst="0x0">
          <comment>enable one command done int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_rng_int" pos="7" rst="0x0">
          <comment>enable rng/trng int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_tdes_key_err_int" pos="5" rst="0x0">
          <comment>enable tdes key check error int</comment>
        </bits>
      </reg>
      <reg name="ce_int_status" protect="rw">
        <comment>ce interrupt status</comment>
        <bits access="r" name="rf_ce_fde_en_len_err_status" pos="21" rst="0x0">
          <comment>src/dst length error int status</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_en_cmd_done_status" pos="20" rst="0x0">
          <comment>one command done int status,</comment>
        </bits>
        <bits access="r" name="rf_ce_en_len_err_status" pos="17" rst="0x0">
          <comment>src/dst length error int status</comment>
        </bits>
        <bits access="r" name="rf_ce_en_cmd_done_status" pos="16" rst="0x0">
          <comment>one command done int status,</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_int_status" pos="7" rst="0x0">
          <comment>ce rng/trng int status</comment>
        </bits>
        <bits access="r" name="rf_ce_tdes_key_err_int_status" pos="5" rst="0x0">
          <comment>ce tdes key check error int status</comment>
        </bits>
      </reg>
      <reg name="ce_int_clear" protect="rw">
        <comment>ce interrupt clear</comment>
        <bits access="r" name="rf_ce_fde_en_len_err_status" pos="21" rst="0x0">
          <comment>src/dst length error int status</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_en_cmd_done_status" pos="20" rst="0x0">
          <comment>one command done int status,</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_len_err_int" pos="17" rst="0x0">
          <comment>clear error int status</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_cmd_done_int" pos="16" rst="0x0">
          <comment>clear one command done int status,</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_tdes_key_err_int" pos="5" rst="0x0">
          <comment>clear tdes key check error int status</comment>
        </bits>
      </reg>
      <reg name="ce_start" protect="rw">
        <comment>start ce</comment>
        <bits access="rc" name="rf_ce_start" pos="0" rst="0x0">
          <comment>start ce</comment>
        </bits>
      </reg>
      <reg name="ce_clear" protect="rw">
        <comment>clear ce</comment>
        <bits access="rc" name="rf_ce_clear" pos="0" rst="0x0">
          <comment>reset ce status</comment>
        </bits>
      </reg>
      <reg name="ce_aes_mode" protect="rw">
        <comment>aes work mode cfg</comment>
        <bits access="rw" name="rf_ce_aes_key_update_n" pos="15" rst="0x0">
          <comment>1: don’t update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_xts_iv_rotation" pos="14" rst="0x1">
          <comment>0: rtl rotation, 1: no-rotation</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_key_len_sel" pos="13:12" rst="0x0">
          <comment>00: key 128bits,01:192bits,10,11:256bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_work_mode" pos="11:8" rst="0x0">
          <comment>0000:ECB,0001:CBC,0010:CTR,0011:XTS,0100:CMAC,0101:GCM,0110:GMAC,0111:CCM,1000:CBCMAC,1001:CFB,1010:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_mac_ctr_inc_mode" pos="6:5" rst="0x0">
          <comment>aes mac ctr inc mode:  00: normal mode; 01: low 64bit is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_en" pos="0" rst="0x0">
          <comment>aes module enable</comment>
        </bits>
      </reg>
      <reg name="ce_tdes_mode" protect="rw">
        <comment>tdes work mode cfg</comment>
        <bits access="rw" name="rf_ce_tdes_key_evenodd_check_on" pos="13" rst="0x0">
          <comment>0: disable,  1: enable even/odd check</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_key_even_sel" pos="12" rst="0x0">
          <comment>0:odd check,1:even check</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_work_mode" pos="9:8" rst="0x0">
          <comment>00:ECB,01:CBC</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_en" pos="0" rst="0x0">
          <comment>tdes module enable</comment>
        </bits>
      </reg>
      <reg name="ce_hash_mode" protect="rw">
        <comment>hash work mode cfg</comment>
        <bits access="rw" name="rf_hash_sha3_shake_out_len" pos="23:16" rst="0x0">
          <comment>sha3 shake out length</comment>
        </bits>
        <bits access="rw" name="rf_hash_hmac_pad_sel" pos="13:12" rst="0x0">
          <comment>00: normal hash; 01: ipad ;10: opad; 11: reserved</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_mode" pos="8:4" rst="0x0">
          <comment>hash work module,
5’d0: Doesn’t work
5’d1: MD5
5’d2: SHA-1 mode
5’d3: SHA-224 mode
5’d4: SHA-256 mode
5’d5: SHA-384 mode
5’d6: SHA-512 mode
5’d7: SHA-512/224 mode
5’d8: SHA-512/256 mode
5’d9: SM3 mode
5’d10: SHA3-224
5’d11: SHA3-256
5’d12: SHA3-384
5’d13: SHA3-512
5’d14: SHA3-SHAKE128
5’d15: SHA3-SHAKE256</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_en" pos="0" rst="0x0">
          <comment>hash module enable</comment>
        </bits>
      </reg>
      <reg name="ce_chacha_poly_mode" protect="rw">
        <comment>chacha poly work mode cfg</comment>
        <bits access="rw" name="rf_ce_chacha_poly_mode" pos="9:8" rst="0x0">
          <comment>00:chacha20 ; 01:poly1305;
10:AEAD_CHACHA20_POLY1305</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_poly_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encrypt,1:decrypt</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_poly_en" pos="0" rst="0x0">
          <comment>chacha poly module enable</comment>
        </bits>
      </reg>
      <reg name="ce_simon_speck_mode" protect="rw">
        <comment>simon speck work mode cfg</comment>
        <bits access="rw" name="rf_ce_simon_speck_key_update_n" pos="15" rst="0x0">
          <comment>1: don’t update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_key_len_sel" pos="14:13" rst="0x0">
          <comment>00: key 128bits,01:192bits,10:256bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_work_mode" pos="11:9" rst="0x0">
          <comment>000:ECB,001:CBC,010:CTR,100:CFB,101:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_sel" pos="8" rst="0x0">
          <comment>0:speck; 1:simon</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encrypt,1:decrypt</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_en" pos="0" rst="0x0">
          <comment>chacha poly module enable</comment>
        </bits>
      </reg>
      <reg name="ce_cfg" protect="rw">
        <comment>ce basic configure</comment>
        <bits access="rw" name="rf_ce_src_word_switch" pos="23" rst="0x0">
          <comment>switch source high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_word_switch" pos="22" rst="0x0">
          <comment>switch destination high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_src_byte_switch" pos="21" rst="0x1">
          <comment>source data switch of one word</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_byte_switch" pos="20" rst="0x0">
          <comment>destination data switch of one word</comment>
        </bits>
        <bits access="r" name="rf_ce_key_hdcp_en" pos="18" rst="0x0">
          <comment>0:disable hdcp mode, 1: enable hdcp mode</comment>
        </bits>
        <bits access="r" name="rf_ce_list_update_iv_sec_cnt" pos="17" rst="0x0">
          <comment>list update iv/sec/cnt flag</comment>
        </bits>
        <bits access="r" name="rf_ce_list_data_end_flag" pos="16" rst="0x0">
          <comment>data end in link list mode</comment>
        </bits>
        <bits access="r" name="rf_ce_list_end_flag" pos="15" rst="0x0">
          <comment>list end flag</comment>
        </bits>
        <bits access="r" name="rf_ce_list_aad_flag" pos="14" rst="0x0">
          <comment>0: isn't aad list 1: is aad list</comment>
        </bits>
        <bits access="r" name="rf_ce_list_aad_end_flag" pos="13" rst="0x0">
          <comment>0: aad no-end list 1: aad end list</comment>
        </bits>
        <bits access="rw" name="rf_ce_do_wait_bdone" pos="12" rst="0x1">
          <comment>wait axi B channel bready</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_iram_flag" pos="11" rst="0x0">
          <comment>0:normal mode, 1: iram key or secure ddr key</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_session_key_flag" pos="10" rst="0x0">
          <comment>0: normal mode, 1: aes/sm4 key from session key</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_ddr_flag" pos="8" rst="0x0">
          <comment>1: all crypto key in ddr/iram; 0: from registers</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_bypass" pos="7" rst="0x0">
          <comment>0:normal mode, 1: bypass ce</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_aad_flag" pos="6" rst="0x0">
          <comment>0: std flag 1: std aad flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_aad_end_flag" pos="5" rst="0x0">
          <comment>0: std aad no-end flag 1: std aad end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_end_flag" pos="4" rst="0x0">
          <comment>std end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_cmd_ioc" pos="3" rst="0x0">
          <comment>0: enable cmd int output: 1: don't output int</comment>
        </bits>
        <bits access="rw" name="rf_ce_dont_dump_ddr" pos="2" rst="0x0">
          <comment>0: dump from ddr; 1: don't dump</comment>
        </bits>
        <bits access="rw" name="rf_ce_dont_rcv_ddr" pos="1" rst="0x0">
          <comment>0: rcv from ddr; 1: don't rcv</comment>
        </bits>
        <bits access="rw" name="rf_ce_link_mode_flag" pos="0" rst="0x0">
          <comment>0:std mode, 1: link mode</comment>
        </bits>
      </reg>
      <reg name="ce_src_frag_length" protect="rw">
        <comment>dma read port node data length</comment>
        <bits access="rw" name="rf_ce_src_addr_hi" pos="27:24" rst="0x0">
          <comment>source address high 4bits; or aes mac aad address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_src_frag_len" pos="23:0" rst="0x0">
          <comment>source fragment length of each node;  or aes mac aad length</comment>
        </bits>
      </reg>
      <reg name="ce_dst_frag_length" protect="rw">
        <comment>dma write port node data length</comment>
        <bits access="rw" name="rf_ce_dst_addr_hi" pos="27:24" rst="0x0">
          <comment>destination address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_frag_len" pos="23:0" rst="0x0">
          <comment>destination fragment length of each node</comment>
        </bits>
      </reg>
      <reg name="ce_src_addr" protect="rw">
        <comment>dma source address</comment>
      </reg>
      <reg name="ce_dst_addr" protect="rw">
        <comment>dma destination address</comment>
      </reg>
      <reg name="ce_list_length" protect="rw">
        <comment>dma one length</comment>
        <bits access="rw" name="rf_ce_list_ptr_hi" pos="19:16" rst="0x0">
          <comment>ce_list_ptr high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_list_len" pos="11:0" rst="0x0">
          <comment>first list length,support max 256 nodes</comment>
        </bits>
      </reg>
      <reg name="ce_list_ptr" protect="rw">
        <comment>dma list pointer</comment>
      </reg>
      <reg name="ce_aes_tdes_rsa_key_length" protect="rw">
        <comment>aes tdes rsa key length</comment>
        <bits access="rw" name="rf_ce_aes_tdes_rsa_key_addr_hi" pos="27:24" rst="0x0">
          <comment>aes hmac key address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_tdes_rsa_key_len" pos="23:0" rst="0x0">
          <comment>aes hmac key length</comment>
        </bits>
      </reg>
      <reg name="ce_aes_tdes_rsa_key_address" protect="rw">
        <comment>aes tdes rsa key address</comment>
      </reg>
      <reg name="ce_aes_tag_length" protect="rw">
        <comment>aes tag length</comment>
        <bits access="rw" name="rf_ce_aes_tag_addr_hi" pos="11:8" rst="0x0">
          <comment>aes tag address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_tag_len" pos="7:0" rst="0x10">
          <comment>aes tag length</comment>
        </bits>
      </reg>
      <reg name="ce_aes_tag_address" protect="rw">
        <comment>aes tag address</comment>
      </reg>
      <reg name="ce_iv_sec_cnt0" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt1" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt2" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt3" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_aes_des_key10" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key11" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key12" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key13" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key14" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key15" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key16" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key17" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key20" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key21" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key22" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key23" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key24" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key25" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key26" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key27" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_sm4_mode" protect="rw">
        <comment>sm4 work mode cfg</comment>
        <bits access="rw" name="rf_ce_sm4_key_update_n" pos="12" rst="0x0">
          <comment>1: don’t update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_xts_inv_rotation" pos="11" rst="0x1">
          <comment>0: rtl rotation, 1: no-rotation</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_work_mode" pos="10:8" rst="0x0">
          <comment>000:ECB,001:CBC,010:CTR,011:XTS,100:CFB,101:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_en" pos="0" rst="0x0">
          <comment>sm4 module enable</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_ip_version" protect="rw">
        <comment>IP version</comment>
        <bits access="r" name="rf_ce_ip_version_hi" pos="31:4" rst="0x40">
          <comment>r4</comment>
        </bits>
        <bits access="rw" name="rf_ce_ip_version_lo" pos="3:0" rst="0x0">
          <comment>px</comment>
        </bits>
      </reg>
      <hole size="1056"/>
      <reg name="ce_pf_calc" protect="rw">
        <comment>ce performace counter</comment>
      </reg>
      <reg name="ce_user_flag" protect="rw">
        <comment>ce use flag</comment>
        <bits access="r" name="rf_ce_pub_priority_vld" pos="8" rst="0x0">
          <comment>when the siganl is high ,then flag the pub aes/sm4/hash is catch the cmd from the pub cmd buf or the pub is working</comment>
        </bits>
        <bits access="r" name="rf_ce_sec_priority_vld" pos="4" rst="0x0">
          <comment>when the siganl is high ,then flag the sec aes/sm4/hash is catch the cmd from the sec cmd buf or the sec is working</comment>
        </bits>
        <bits access="rw" name="rf_ce_use_flag" pos="0" rst="0x0">
          <comment>ce sec or pub use the ce aes/sm4/hash cicpher module</comment>
        </bits>
      </reg>
      <reg name="ce_axi_axcache" protect="rw">
        <comment>axi bus cache</comment>
        <bits access="rw" name="rf_ce_src_outstanding_num" pos="15:12" rst="0x7">
          <comment>axi read port outstanding number</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_outstanding_num" pos="11:8" rst="0x7">
          <comment>axi write port outstanding number</comment>
        </bits>
        <bits access="rw" name="rf_ce_axi_awcache" pos="7:4" rst="0x0">
          <comment>axi bus wcache</comment>
        </bits>
        <bits access="rw" name="rf_ce_axi_arcache" pos="3:0" rst="0x0">
          <comment>axi bus rcache</comment>
        </bits>
      </reg>
      <reg name="ce_cmd_stop_ctrl" protect="rw">
        <comment>cmd stop ctrl</comment>
        <bits access="rc" name="rf_ce_fde_cmd_stop_clear" pos="22" rst="0x0">
          <comment>fde to restart</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_cmd_stop_status" pos="21" rst="0x0">
          <comment>1: fde stop command is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_cmd_stop" pos="20" rst="0x0">
          <comment>0:fde  to execute next cmd; 1: fde finish current cmd,then stop</comment>
        </bits>
        <bits access="rc" name="rf_ce_cmd_stop_clear" pos="18" rst="0x0">
          <comment>to restart</comment>
        </bits>
        <bits access="r" name="rf_ce_cmd_stop_status" pos="17" rst="0x0">
          <comment>1: stop command is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_cmd_stop" pos="16" rst="0x0">
          <comment>0: to execute next cmd; 1: finish current cmd,then stop</comment>
        </bits>
      </reg>
      <reg name="ce_axi_protect_sel" protect="rw">
        <comment>axi prot sel</comment>
        <bits access="rw" name="fde_dummy" pos="15:13" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="fde_axi_prot_sel_wtxt" pos="12" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="fde_axi_prot_sel_rtxt" pos="11" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="fde_axi_prot_sel_rlist" pos="10" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="fde_axi_prot_sel_rkey" pos="9" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="fde_axi_prot_sel_en" pos="8" rst="0x0">
          <comment>0: disable fde side sel; 1: enable fde side axi sel</comment>
        </bits>
        <bits access="rw" name="pub_dummy" pos="7:5" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="pub_axi_prot_sel_wtxt" pos="4" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pub_axi_prot_sel_rtxt" pos="3" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pub_axi_prot_sel_rlist" pos="2" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pub_axi_prot_sel_rkey" pos="1" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pub_axi_prot_sel_en" pos="0" rst="0x0">
          <comment>0: disable pub side sel; 1: enable pub side axi sel</comment>
        </bits>
      </reg>
      <reg name="ce_pf_calc_high" protect="rw">
        <comment>ce performace counter high 32 bit</comment>
      </reg>
      <hole size="1216"/>
      <reg name="ce_rng_en" protect="rw">
        <comment>RNG module enable RNG module enable</comment>
        <bits access="rw" name="rf_ce_rng_data_mux_enable" pos="18" rst="0x0">
          <comment>if the signal is high,then the rng data  come from cpu.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_mux_ring_enable" pos="17" rst="0x0">
          <comment>if the signal is high,then the osc rings sel signal come from rf_rng_src_sel_enable.</comment>
        </bits>
        <bits access="rw" name="rf_rng_auto_enable" pos="16" rst="0x1">
          <comment>if the signal is high,then the osc rings is auto choose to work</comment>
        </bits>
        <bits access="rw" name="rf_rng_src_sel_enable" pos="15:8" rst="0xff">
          <comment>the signal control which osc ring is work,when the least bit is high,then the first one osc ring is choose as the entropy.</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_ptest_mode_en" pos="4" rst="0x0">
          <comment>trng source test enable</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_rst_from_cpu" pos="3" rst="0x0">
          <comment>the rst signal to the exotic trng module</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_src_from_cpu_enable" pos="2" rst="0x0">
          <comment>the signal can change when the trng is work ,which can control the trng start or stop by cpu.</comment>
        </bits>
        <bits access="rc" name="rf_ce_trng_src_en" pos="1" rst="0x0">
          <comment>trng source enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_en" pos="0" rst="0x0">
          <comment>RNG module enable bit:
1:enbale RNG module to generate random number when auto mode is not enable</comment>
        </bits>
      </reg>
      <reg name="ce_rng_config" protect="rw">
        <comment>RNG module config RNG module config</comment>
        <bits access="rw" name="number_of_samples_threshold" pos="31:20" rst="0xfff">
          <comment>Threshold bit value for random data , indicates that the cycle of the src_en is high, the max value is 12'hFFF.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_ptest_data_in" pos="16" rst="0x0">
          <comment>when the data_in is 0,the test result should be 1,and the data_in is 1,the test result should be 0;</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_data_valid_threshold" pos="11:8" rst="0x3">
          <comment>Threshold value for rng_data_valid, indicates that when rng_data_valid high, there area at least number of rng_data_valid_threshold words in SRAM，the max value is 4'hf.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_exotic_fault_rst_sel" pos="7" rst="0x0">
          <comment>ce_rng_exotic_fault_rst_sel:                  1'b0:the rst generated by the fault signal,                 1'b1:don't generated the rst signal,the rst signal come from the cpu</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_source_sel" pos="6:5" rst="0x3">
          <comment>local RNG entropty source select</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_data_len_sel" pos="4" rst="0x0">
          <comment>when it's 1,the the post process module need data bitwith is 440bit,else is 256bit</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_trng_sel" pos="3" rst="0x0">
          <comment>the signal select the trng data come from exotic or local trng module 1:exotic 0:local</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_ring_sel" pos="2:0" rst="0x3">
          <comment>select entropy source,the range is 0x0 to 0x7</comment>
        </bits>
      </reg>
      <reg name="ce_rng_data" protect="rw">
        <comment>RNG data for cpu to read RNG data for cpu to read</comment>
      </reg>
      <reg name="ce_rng_sample_period" protect="rw">
        <comment>time interval between two samples time interval between two samples</comment>
        <bits access="rw" name="rf_ce_rng_first_sample_en" pos="31" rst="0x0">
          <comment>enable first level sample</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_first_sample_period" pos="30:16" rst="0x0">
          <comment>sample period between two samples, the value is from 0 to 255</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_second_sample_period" pos="15:0" rst="0x0">
          <comment>sample period between two samples, the value is from 0 to 255</comment>
        </bits>
      </reg>
      <reg name="ce_rng_post_process_en" protect="rw">
        <comment>post process functions select post process functions select</comment>
        <bits access="rw" name="rf_ce_rng_post_eight_en" pos="7" rst="0x0">
          <comment>when it's 1,the the PRNG data  xor with trng data</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_seven_en" pos="6" rst="0x0">
          <comment>when it's 1,the the final post process module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_six_en" pos="5" rst="0x0">
          <comment>when it's 1,the the xor process module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_five_en" pos="4" rst="0x0">
          <comment>when it's 1,the the cycle_code module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_four_en" pos="3" rst="0x1">
          <comment>when it's 1,the the lfsr module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_three_en" pos="2" rst="0x0"/>
        <bits access="rw" name="rf_ce_rng_post_second_en" pos="1" rst="0x0">
          <comment>post data path 1 enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_first_en" pos="0" rst="0x0">
          <comment>post data path 0 enable</comment>
        </bits>
      </reg>
      <reg name="ce_rng_work_status" protect="rw">
        <comment>rng work status rng work status</comment>
        <bits access="r" name="rf_ce_rng_rsa_key_gen_rand_num" pos="31:16" rst="0x0">
          <comment>rand data number when keygen done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_process" pos="15:14" rst="0x0">
          <comment>2'b01:Instantiate ;                                                     2'b10:Reseed ;                                                       2'b11:Genarate.</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_pattern_req" pos="13" rst="0x0">
          <comment>when it's 1,cpu can send next 64bit pattern</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_fail" pos="12" rst="0x0">
          <comment>when it's 1,the drbg KAT test fail</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_done" pos="11" rst="0x0">
          <comment>DRBG KAT test done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_es_test_fail" pos="10" rst="0x0">
          <comment>when it's 1,the start-up/on-demand test fail(1024 sample)</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_es_test_done" pos="9" rst="0x0">
          <comment>start-up/on-demand test done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_test_result" pos="8" rst="0x0">
          <comment>the result of test mode</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_result_vld" pos="7" rst="0x0">
          <comment>when it's 1,indicate that the drbg test result data in 0x260 register is valid (cpu can read to check)</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_data_type" pos="6:5" rst="0x0">
          <comment>2'b01: C [439:0] ;                                                    2'b10: V[439:0] ;                                                        2'b11: reseed_counter[31:0].                                  Corresponds to the data of each process in [15:14] .</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_fifo_empty" pos="4" rst="0x1">
          <comment>the fifo status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_error_fault" pos="3" rst="0x0">
          <comment>the exotic rng module status</comment>
        </bits>
        <bits access="r" name="rf_rng_rsa_pka_busy" pos="2" rst="0x0"/>
        <bits access="r" name="rf_ce_rng_data_valid" pos="1" rst="0x0">
          <comment>when high indicates that RNG module has generate 256 bits random data</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_auto_mode_ongoing" pos="0" rst="0x0">
          <comment>when high indicates that auto mode is ongoing, CPU can't access rng_data register</comment>
        </bits>
      </reg>
      <reg name="ce_rng_timeout_cnt" protect="rw">
        <comment>rng time out counter rng time out counter</comment>
      </reg>
      <reg name="ce_rng_int_en" protect="rw">
        <comment>rng interrupt enable rng interrupt enable</comment>
        <bits access="rw" name="rf_ce_rng_cont_htest_int_en" pos="5" rst="0x0">
          <comment>enable continuous health test interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_sram_short_int_en" pos="4" rst="0x0">
          <comment>enable sram short interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_timeout_int_en" pos="3" rst="0x0">
          <comment>enable timeout interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process2_int_en" pos="2" rst="0x0">
          <comment>enable process2 interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process1_int_en" pos="1" rst="0x0">
          <comment>enable process1 interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process0_int_en" pos="0" rst="0x0">
          <comment>enable process0 interrupt</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sts" protect="rw">
        <comment>rng interrupt status rng interrupt status</comment>
        <bits access="r" name="rf_ce_rng_con_htest_int_sts" pos="5" rst="0x0">
          <comment>continuous health test interrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_sram_short_int_sts" pos="4" rst="0x0">
          <comment>sram_short_interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_timeout_int_sts" pos="3" rst="0x0">
          <comment>timeout interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process2_int_sts" pos="2" rst="0x0">
          <comment>process2 interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process1_int_sts" pos="1" rst="0x0">
          <comment>process1 interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process0_int_sts" pos="0" rst="0x0">
          <comment>process0 interrrupt status</comment>
        </bits>
      </reg>
      <reg name="ce_rng_int_clr" protect="rw">
        <comment>rng interrupt clear rng interrupt clear</comment>
        <bits access="rc" name="rf_ce_rng_clear_con_htest_int" pos="5" rst="0x0">
          <comment>clear continuous health test interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_sram_short_int" pos="4" rst="0x0">
          <comment>clear sram short  interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_timeout_int" pos="3" rst="0x0">
          <comment>clear timeout interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process2_int" pos="2" rst="0x0">
          <comment>clear process2 interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process1_int" pos="1" rst="0x0">
          <comment>clear process1 interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process0_int" pos="0" rst="0x0">
          <comment>clear process0 interrupt</comment>
        </bits>
      </reg>
      <reg name="ce_rng_mode" protect="rw">
        <comment>RNG module work mode RNG module work mode</comment>
        <bits access="rw" name="rf_ce_prng_mode" pos="8" rst="0x0">
          <comment>PRNG work mode:
1: Auto Seed update Mode
0: Mannual seed update Mode</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_mode" pos="1:0" rst="0x0">
          <comment>RNG module work mode:
10: PRNG mode
01: TRNG mode                                           00：11: Mixed mode for TRNG</comment>
        </bits>
      </reg>
      <reg name="ce_prng_seed_update" protect="rw">
        <comment>PRNG mode seed update config PRNG mode seed update config</comment>
        <bits access="rc" name="rf_ce_prng_seed_update" pos="0" rst="0x0">
          <comment>When Write to 1, PRNG will update seed to PRNG_SEED_CONFIG register value</comment>
        </bits>
      </reg>
      <reg name="ce_prng_seed_config" protect="rw">
        <comment>PRNG mode seed update config PRNG mode seed update config</comment>
      </reg>
      <reg name="ce_rng_bit_rate" protect="rw">
        <comment>RNG Bit Rate RNG Bit Rate</comment>
        <bits access="r" name="rf_rng_gen_bit_cnt" pos="31:16" rst="0x0">
          <comment>RNG Bit Counter</comment>
        </bits>
        <bits access="r" name="rf_rng_bit_rate" pos="15:0" rst="0x0">
          <comment>RNG Bit number each 10000 clock cycle</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sram_data_threshhold" protect="rw">
        <comment>SRAM data numuber threshold SRAM data numuber threshold</comment>
        <bits access="rw" name="rf_ce_rng_sram_valid_threshholdd" pos="3:0" rst="0x0">
          <comment>SRAM data numuber threshold,</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sram_data_residue_num" protect="rw">
        <comment>rng_sram_data_residue_num rng_sram_data_residue_num</comment>
        <bits access="r" name="rf_ce_rng_sram_data_residue_num" pos="3:0" rst="0x0">
          <comment>rng_sram_data_residue_num</comment>
        </bits>
      </reg>
      <reg name="ce_rng_exotic_fault_counter_config" protect="rw">
        <comment>exotic fault counter rng exotic fault counter config</comment>
        <bits access="rw" name="rf_ce_exotic_fault_counter_config" pos="15:0" rst="0x0">
          <comment>config the fault counter and read the counter</comment>
        </bits>
      </reg>
      <reg name="ce_rng_drbg_seed_cnt" protect="rw">
        <comment>drbg seed count drbg seed count</comment>
        <bits access="rw" name="rf_ce_rng_drbg_seed_cnt" pos="15:0" rst="0xc">
          <comment>config the drbg seed after certain time</comment>
        </bits>
      </reg>
      <reg name="ce_rng_ring_num_cfg_l" protect="rw">
        <comment>config ring ring number config ring ring number</comment>
      </reg>
      <reg name="ce_rng_ring_num_cfg_h" protect="rw">
        <comment>config ring ring number config ring ring number</comment>
      </reg>
      <reg name="ce_rng_health_test_config" protect="rw">
        <comment>rng_health_test_config rng_health_test_config</comment>
        <bits access="rw" name="rf_ce_rng_ones_freq_max" pos="18:8" rst="0x25f">
          <comment>default:11'd607(freq 0/1 in 1024)</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_long_term_bit_max" pos="7:2" rst="0x2f">
          <comment>default:6'd47 (conse 48 0/1)   [23]</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_drbg_test_en" pos="1" rst="0x0">
          <comment>open drbg test(on-demand test)</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_es_test_en" pos="0" rst="0x0">
          <comment>open es test(on-demand test)</comment>
        </bits>
      </reg>
      <reg name="ce_rng_drbg_test_pattern_l" protect="rw">
        <comment>ce_rng_drbg_test_pattern_l ce_rng_drbg_test_pattern_l</comment>
      </reg>
      <reg name="ce_rng_drbg_test_pattern_h" protect="rw">
        <comment>ce_rng_drbg_test_pattern_h ce_rng_drbg_test_pattern_h</comment>
      </reg>
      <reg name="ce_rng_raw_data_to_cpu" protect="rw">
        <comment>raw_random_number raw_random_number</comment>
      </reg>
      <reg name="ce_rng_drbg_test_result" protect="rw">
        <comment>ce_rng_drbg_sha256_result ce_rng_drbg_sha256_result</comment>
      </reg>
      <hole size="1248"/>
      <reg name="ce_session_key0" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key1" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key2" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key3" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key4" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key5" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key6" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key7" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key0" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key1" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key2" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key3" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key4" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key5" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key6" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key7" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <hole size="3584"/>
      <reg name="ce_cmd_fifo_entry" protect="rw">
        <comment>ce_cmd_fifo_entry</comment>
      </reg>
      <reg name="ce_cmd_fifo_status" protect="rw">
        <comment>ce_cmd_fifo_status</comment>
      </reg>
      <reg name="ce_rcv_addr_lo" protect="rw">
        <comment>ce_rcv_addr_lo</comment>
      </reg>
      <reg name="ce_dump_addr_lo" protect="rw">
        <comment>ce_dump_addr_lo</comment>
      </reg>
      <reg name="ce_dump_addr_hi" protect="rw">
        <comment>ce_dump_addr_hi</comment>
        <bits access="rw" name="rf_ce_dump_addr_hi" pos="7:4" rst="0x0">
          <comment>ce dump address hi</comment>
        </bits>
        <bits access="rw" name="rf_ce_rcv_addr_hi" pos="3:0" rst="0x0">
          <comment>ce rcv address hi</comment>
        </bits>
      </reg>
      <reg name="ce_finish_cmd_cnt" protect="rw">
        <comment>ce_finish_cmd_cnt</comment>
      </reg>
      <hole size="3904"/>
      <reg name="ce_fde_aes_cmd_fifo_entry" protect="rw">
        <comment>ce_fde_aes_cmd_fifo_entry</comment>
      </reg>
      <reg name="ce_fde_aes_cmd_fifo_status" protect="rw">
        <comment>ce_fde_aes_cmd_fifo_status</comment>
      </reg>
      <reg name="ce_fde_aes_rcv_addr_lo" protect="rw">
        <comment>ce_fde_aes_rcv_addr_lo</comment>
      </reg>
      <reg name="ce_fde_aes_dump_addr_lo" protect="rw">
        <comment>ce_fde_aes_dump_addr_lo</comment>
      </reg>
      <reg name="ce_fde_aes_dump_addr_hi" protect="rw">
        <comment>ce_fde_aes_dump_addr_hi</comment>
        <bits access="rw" name="rf_ce_fde_aes_dump_addr_hi" pos="7:4" rst="0x0">
          <comment>ce  fde_aes cipher dump address hi,or aes tag address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_rcv_addr_hi" pos="3:0" rst="0x0">
          <comment>ce  fde_aes cipher rcv address hi</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_finish_cmd_cnt" protect="rw">
        <comment>ce_fde_aes_finish_cmd_cnt</comment>
      </reg>
      <reg name="ce_fde_aes_start" protect="rw">
        <comment>start fde_aes cipher ce</comment>
        <bits access="rc" name="rf_ce_fde_aes_start" pos="0" rst="0x0">
          <comment>start fde_aes cipher ce(TDES/AES/SM4/SM1/SM7/GHASH)</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_clear" protect="rw">
        <comment>clear fde_aes cipher ce</comment>
        <bits access="rc" name="rf_ce_fde_aes_clear" pos="0" rst="0x0">
          <comment>reset ce fde_aes cipher status</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_mode" protect="rw">
        <comment>fde_aes cipher work mode cfg</comment>
        <bits access="rw" name="rf_ce_fde_aes_mac_ctr_inc_mode" pos="21:20" rst="0x0">
          <comment>aes mac ctr inc mode:  00: normal mode; 01: low 64bit is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_key_len_sel" pos="17:16" rst="0x0">
          <comment>00: key 128bits,01:192bits,10,11:256bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_xts_iv_rotation" pos="12" rst="0x1">
          <comment>0: rtl rotation, 1: no-rotation(sm4/aes)</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_work_mode" pos="11:8" rst="0x0">
          <comment>0000:ECB,0001:CBC,0010:CTR,0011:XTS</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_en" pos="0" rst="0x0">
          <comment>fde_aes cipher module enable</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_cfg" protect="rw">
        <comment>ce  fde_aes cipher basic configure</comment>
        <bits access="rw" name="rf_ce_fde_auto_update_iv_sec_cnt" pos="24" rst="0x1">
          <comment>ce fde iv auto add 1‘b1 each 512Byte msg</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_src_word_switch" pos="23" rst="0x0">
          <comment>fde_aes switch source high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_dst_word_switch" pos="22" rst="0x0">
          <comment>fde_aes switch destination high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_src_byte_switch" pos="21" rst="0x1">
          <comment>fde_aes cipher source data switch of one byte</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_dst_byte_switch" pos="20" rst="0x0">
          <comment>fde_aes cipher destination data switch of one byte</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_list_update_iv_sec_cnt" pos="17" rst="0x0">
          <comment>list update iv/sec/cnt flag</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_aes_list_data_end_flag" pos="16" rst="0x0">
          <comment>fde_aes cipher data end in link list mode</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_aes_list_end_flag" pos="15" rst="0x0">
          <comment>fde_aes cipher list end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_key_in_iram_flag" pos="11" rst="0x0">
          <comment>0:normal mode, 1: iram key or secure ddr key</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_key_in_session_key_flag" pos="10" rst="0x0">
          <comment>0: normal mode, 1: aes key from session key</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_key_in_ddr_flag" pos="8" rst="0x0">
          <comment>1: fde_aes cipher all crypto key in ddr/iram,and the iv also come from drr except the link list mode; 0:fde_aes cipher from registers</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_bypass" pos="7" rst="0x0"/>
        <bits access="rw" name="rf_ce_fde_aes_std_mode_end_flag" pos="4" rst="0x0">
          <comment>fde_aes cipher std end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_cmd_ioc" pos="3" rst="0x0">
          <comment>0: fde_aes cipher enable cmd int output: 1: don't output int</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_dont_dump_ddr" pos="2" rst="0x0">
          <comment>0:fde_aes cipher dump from ddr; 1:fde_aes cipher don't dump</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_dont_rcv_ddr" pos="1" rst="0x0">
          <comment>0:fde_aes cipher rcv from ddr; 1:fde_aes cipher don't rcv</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_link_mode_flag" pos="0" rst="0x0">
          <comment>0:fde_aes cipher std mode, 1:fde_aes cipher link mode</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_list_length" protect="rw">
        <comment>fde_aes cipher dma one length</comment>
        <bits access="rw" name="rf_ce_fde_aes_list_ptr_hi" pos="19:16" rst="0x0">
          <comment>ce_fde_aes_list_ptr high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_list_len" pos="11:0" rst="0x0">
          <comment>fde_aes cipher first list length,support max 40 nodes</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_list_ptr" protect="rw">
        <comment>fde_aes cipher dma list pointer</comment>
      </reg>
      <reg name="ce_fde_aes_src_frag_length" protect="rw">
        <comment>fde_aes cipher dma read port node data length</comment>
        <bits access="rw" name="rf_ce_fde_aes_dst_addr_hi" pos="31:28" rst="0x0">
          <comment>fde_aes cipher destination address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_src_addr_hi" pos="27:24" rst="0x0">
          <comment>fde_aes cipher source address high 4bits; or aes mac aad address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_src_frag_len" pos="23:0" rst="0x0">
          <comment>fde_aes cipher source fragment length of each node;  or aes mac aad length</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_src_addr" protect="rw">
        <comment>fde_aes cipher dma source address</comment>
      </reg>
      <reg name="ce_fde_aes_dst_addr" protect="rw">
        <comment>fde_aes cipher dma destination address</comment>
      </reg>
      <reg name="ce_fde_aes_key_length" protect="rw">
        <comment>fde aes key length</comment>
        <bits access="rw" name="rf_ce_fde_aes_key_addr_hi" pos="27:24" rst="0x0">
          <comment>fde aes key address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_key_len" pos="23:0" rst="0x0">
          <comment>fde aes key length</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_key_address" protect="rw">
        <comment>fde aes key address</comment>
      </reg>
      <reg name="ce_fde_aes_dst_ddr_sel" protect="rw">
        <comment>fde aes dst ddr select</comment>
        <bits access="rw" name="rf_ce_fde_aes_dst_ddr_sel" pos="0" rst="0x0">
          <comment>axi awprot under key in iram mode
0: non_sec 1: sec</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_dummy_reg" protect="rw">
        <comment>ce fde aes dummy register</comment>
        <bits access="rw" name="rf_ce_fde_dummy_reg" pos="7:0" rst="0x0">
          <comment>ce fde aes dummy register</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_fde_iv_sec_cnt0" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_fde_iv_sec_cnt1" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_fde_iv_sec_cnt2" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_fde_iv_sec_cnt3" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_fde_aes_key10" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key11" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key12" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key13" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key14" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key15" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key16" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key17" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key20" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key21" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key22" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key23" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key24" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key25" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key26" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key27" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <hole size="768"/>
      <reg name="ce_fde_session_key0" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key1" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key2" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key3" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key4" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key5" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key6" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key7" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key0" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key1" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key2" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key3" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key4" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key5" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key6" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key7" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
    </module>
    <instance address="0x04002000" name="CE_PUB" type="CE_PUB"/>
  </archive>
  <archive relative="emmc.xml">
    <module category="System" name="EMMC">
      <reg name="blk_cnt" protect="rw">
        <comment>DMA Block Count</comment>
      </reg>
      <reg name="blk_size" protect="rw">
        <comment>Block Size and Count</comment>
        <bits access="rw" name="blk_size" pos="11:0" rst="0x0">
          <comment>Transfer blocks size. This register specifies the block size for block data transfers for CMD17, CMD18, CMD24, CMD25, and CMD53.
0x0000: no data transfer
0x0001: 1 byte</comment>
        </bits>
      </reg>
      <reg name="argumnet" protect="rw">
        <comment>Argument</comment>
      </reg>
      <reg name="tr_mode" protect="rw">
        <comment>Transfer mode and command</comment>
        <bits access="rw" name="boot_ack" pos="31" rst="0x0">
          <comment>Set to indicate the host whether card will send boot ack
1’b1: send boot ack
1’b0: not send boot ack</comment>
        </bits>
        <bits access="rw" name="cmd_line_boot" pos="30" rst="0x0">
          <comment>Set to begin drive low cmd line and waiting to receive boot data block
1’b1: Drive cmd line low
1’b0: not drive cmd line</comment>
        </bits>
        <bits access="rw" name="cmd_index" pos="29:24" rst="0x0">
          <comment>Command index, set to the command number (CMD0-63, ACMD0-63)</comment>
        </bits>
        <bits access="rw" name="cmd_type" pos="23:22" rst="0x0">
          <comment>Commend type. There are three types of special commands, Suspend, Resume and Abort. These bits shall bet set to 00b for all other commands.
00: Normal
01/10: Reserved
11: Abort</comment>
        </bits>
        <bits access="rw" name="data_pre_sel" pos="21" rst="0x0">
          <comment>Data present select
0: no data present
1: data present
This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line. It is set to 0 for the following:
1. Commands using only CMD line (e.g., CMD52)
2. Commands with no data transfer but using busy signal on DAT[0] line (R1b or R5b, e.g., CMD38)
3. Resume Command</comment>
        </bits>
        <bits access="rw" name="cmd_ind_chk_en" pos="20" rst="0x0">
          <comment>Command index check enable
0: disable
1: enable
If this bit is set to 1, the HC shall check the index field in the Response to see if it has the same value as the command index. If it is not, it is reported as a Command Index Error. If this bit is set to 0, the Index field is not checked.</comment>
        </bits>
        <bits access="rw" name="cmd_crc_chk_en" pos="19" rst="0x0">
          <comment>Command CRC check enable
0: disable
1: enable
If this bit is set to 1, the HC shall check the CRC field in the Response. If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0, the CRC field is not checked</comment>
        </bits>
        <bits access="rw" name="sub_cmd_flag" pos="18" rst="0x0">
          <comment>Sub Command Flag
0: Main Command
1: Sub Command</comment>
        </bits>
        <bits access="rw" name="resp_type_sel" pos="17:16" rst="0x0">
          <comment>Response type select
00: no response
01: response length 136
10: response length 48
11: response length 48, check Busy after response</comment>
        </bits>
        <bits access="rw" name="resp_int_dis" pos="8" rst="0x0">
          <comment>Response Interrupt Disable
0: Response Interrupt is enabled.
1: Response Interrupt is disabled.
Support response error check function to avoid overhead of response error check by Host Driver. Only R1 or R5 can be checked.
If Host Driver checks response error, sets this bit to 0 and waits Command Complete Interrupt and then checks the response register.
If Host Controller checks response error, sets this bit to 1 and sets Response Error Check Enable to 1, Command Complete Interrupt is disabled by this bit regardless of Command Complete Signal Enable</comment>
        </bits>
        <bits access="rw" name="resp_err_chk_en" pos="7" rst="0x0">
          <comment>Response Error Check Enable
0: Response Error check is disabled
1: Response Error check is enabled.
Support response error check function to avoid overhead of response error check by Host driver. Only R1 or R5 can be checked.
If Host Driver check response error, this bit is set to 0 and Response Interrupt Disable is set to 0,
If Host Controller checks response error, sets this bit to 1 and sets Response Interrupt Disable to 1. Response Type R1/R5 selects either R1 or R5 response type. If an error is detected, Response Error Interrupt is generated in the Error Interrupt Status register.</comment>
        </bits>
        <bits access="rw" name="resp_type" pos="6" rst="0x0">
          <comment>Response Type R1/R5
0: R1 (Memory)
1: R5 (SDIO)
When response error check is enabled, this bit selects either R1 or R5 response types. Two types of response checks are supported: R1 for memory and R5 for SDIO.
Error Statues checked in R1
Bit: 19/20/21/23/25/26/29/30/31
Response Flags Checked in R5:
Bit: 0/1/3/7</comment>
        </bits>
        <bits access="rw" name="mult_blk_sel" pos="5" rst="0x0">
          <comment>Multiple/single block select
0: single block
1: multiple blocks</comment>
        </bits>
        <bits access="rw" name="data_dir_sel" pos="4" rst="0x0">
          <comment>Data transfer direction select
0: write (Host to Card)
1: read (Card to Host)</comment>
        </bits>
        <bits access="rw" name="auto_cmd_en" pos="3:2" rst="0x0">
          <comment>Auto CMD enable
00: disable
01: Auto CMD12 Enable
10: Auto CMD23 Enable
11: Auto CMD auto select
1: Auto CMD12 Enable: Multiple block transfers for memory require CMD12 to stop the transaction. When this bit is set to 1, the HC shall issue CMD12 automatically when last block transfer is completed. The HD shall not set this bit to issue commands that do not require CMD12 to stop data transfer.
2: Auto CMD23 Enable:
When this bit field is set to 10b, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command Register
3: Auto CMD auto select.
When this mode select, selection of auto CMD depends on setting of CMD23 Enable in the Host Ctrl 2 register which indicated whether card support CMD23. If CMD23 Enable=1, auto CMD23 is used and if CMD23 Enable=0, auto CMD12 is used. Use of Auto CMD Auto Select is recommended rather than use of Auto CMD12 Enable or Auto CMD23 Enable.</comment>
        </bits>
        <bits access="rw" name="blk_cnt_en" pos="1" rst="0x0">
          <comment>Block count enable
(This design not support infinite mode, so it is always 1)</comment>
        </bits>
        <bits access="rw" name="dma_en" pos="0" rst="0x0">
          <comment>DMA enable
(This design not support NO-DMA mode, so it is always 1)</comment>
        </bits>
      </reg>
      <reg name="resp0" protect="rw">
        <comment>RESP0</comment>
      </reg>
      <reg name="resp1" protect="rw">
        <comment>RESP1</comment>
      </reg>
      <reg name="resp2" protect="rw">
        <comment>RESP2</comment>
      </reg>
      <reg name="resp3" protect="rw">
        <comment>RESP3</comment>
      </reg>
      <hole size="32"/>
      <reg name="pres_state" protect="rw">
        <comment>DMC AXI channel 0 configuration register</comment>
        <bits access="r" name="sub_cmd_flag" pos="28" rst="0x0">
          <comment>Sub Command Flag
0: Main Command
1: Sub Command</comment>
        </bits>
        <bits access="r" name="cmd_line" pos="24" rst="0x1">
          <comment>CMD line signal level. This status is used to check CMD line level to recover from errors, and for debugging</comment>
        </bits>
        <bits access="r" name="dat_line3_0" pos="23:20" rst="0xf">
          <comment>DAT [3:0] line signal level. This status is used to check DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT [0].
[23]: for DAT[3]
[22]: for DAT[2]
[21]: for DAT[1]
[20]: for DAT[0]</comment>
        </bits>
        <bits access="rw" name="read_active" pos="9" rst="0x0">
          <comment>Read transfer active. This status is used for detecting completion of a read transfer. This bit is set to 1 for either of the following conditions:
1. After the end bit of the read command
2. When writing a 1 to continue Request in the Block Gap Control register to restart a read transfer
This bit is cleared to 0 for either of the following conditions:
1. When the last data block as specified by block length is transferred to the system.
2. When all valid data blocks have been transferred to the system and no current block transfers are being sent as a result of the Stop at Block Gap Request set to 1. A transfer complete interrupt is generated when this bit changes to 0.
0: no valid data
1: transferring data</comment>
        </bits>
        <bits access="r" name="write_acitve" pos="8" rst="0x0">
          <comment>Write transfer active. This status indicates a write transfer is active. If this bit is 0, it means no valid write data exists in the HC. This bit is set in either of the following cases:
1. After the end bit of the write command
2. When writing a 1 to Continue Request in the Block Gap Control register to restart a write transfer
This bit is cleared in either of the following cases:
1. After getting the CRC status of the last data block as specified by the transfer count (Single or Multiple)
2. After getting a CRC status of any block where data transmission is about to be stopped by a Stop at Block Gap Request.
During a write transaction, a Block Gap Event interrupt is generated when this bit is changed to 0, as a result of the Stop at Block Gap Request being set. This status is useful for the HD in determining when to issue commands during write busy.
0: no valid data
1: transferring data</comment>
        </bits>
        <bits access="r" name="dat_line7_4" pos="7:4" rst="0xf">
          <comment>This bit selects 32B or 64B size when splitting AXI burst to DDR bursts.
0 : only 32byte split size
1 : dynamic split size, 32B or 64B, based on AXI transactions</comment>
        </bits>
        <bits access="r" name="dat_line_active" pos="2" rst="0x0">
          <comment>DAT line active. This bit indicates whether one of the DAT line on SD bus is in use.
0: DAT line inactive
1: DAT line active</comment>
        </bits>
        <bits access="r" name="cmd_inh_dat" pos="1" rst="0x0">
          <comment>Command inhibit (DAT)
This status bit is generated if either the DAT Line Active or the Read Transfer Active is 1. If this bit is 0, it indicates the HC can issue the next SD command. Commands with busy signal belong to Command Inhibit (DAT) (e.g., R1b, R5b type). Changing from 1 to 0 generates a Transfer Complete interrupt in the Normal Interrupt status register. Note: The SD Host Driver can save registers in the range of 0x0000 ~ 0x000D for a suspend transaction after this bit has changed from 1 to 0.
0: can issue command that uses the DAT line
1: cannot issue command that uses the DAT line</comment>
        </bits>
        <bits access="r" name="cmd_inh_cmd" pos="0" rst="0x0">
          <comment>Command inhibit (CMD)
If this bit is 0, it indicates the CMD line is not in use and the HC can issue a SD command using the CMD line. This bit is set immediately after the Command register (0x000F) is written. This bit is cleared when the command response is received. Even if the Command Inhibit (DAT) is set to 1, Commands using only the CMD line can be issued if this bit is 0. Changing from 1 to 0 generates a Command complete interrupt in the Normal Interrupt Status register. If the HC cannot issue the command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit shall remain 1 and the Command Complete is not set. Status issuing Auto CMD12 is not read from this bit.</comment>
        </bits>
      </reg>
      <reg name="host_ctrl1" protect="rw">
        <comment>SD Host Control Register1</comment>
        <bits access="rw" name="int_at_blk_gap" pos="19" rst="0x1">
          <comment>Interrupt at block gap. This bit is valid only in 4-bit mode of the SDIO card and selects a sample point in the interrupt cycle. Setting to 1 enables interrupt detection at the block gap for a multiple block transfer. If the SD card cannot signal an interrupt during a multiple block transfer, this bit should be set to 0. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card.</comment>
        </bits>
        <bits access="rw" name="rd_wait_ctrl" pos="18" rst="0x0">
          <comment>Read wait control. The read wait function is optional for SDIO cards. If the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using DAT[2] line. Otherwise, the HC has to stop the SD clock to hold read data, which restricts commands generation. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card. If the card does not support read wait, this bit shall never be set to 1 or DAT line conflict may occur. If this bit is set to 0, Suspend/Resume cannot be supported.
0: disable read wait control
1: enable read wait control</comment>
        </bits>
        <bits access="rw" name="sd8_mode" pos="5" rst="0x0">
          <comment>SD8 bit mode
Extended Data Transfer Width
This bit controls 8-bit bus width mode for embedded device. Support of this function is indicated in 8-bit Support for Embedded Device in the Capabilities register. If a device supports 8-bit bus mode, this bit may be set to 1. If this bit is 0, bus width is controller by Data Transfer Width in the Host Control 1 register.
1: 8-bit Bus Width
0: Bus Width is Selected by Data Transfer Width</comment>
        </bits>
        <bits access="rw" name="dma_sel" pos="4:3" rst="0x0">
          <comment>DMA Select
2’b00: SDMA is select
2’b01: Reserved
2’b10: ADMA2 is select
2’b11: ADMA2/3 is select</comment>
        </bits>
        <bits access="rw" name="sd4b_mode" pos="1" rst="0x0">
          <comment>Data transfer width, SD1 or SD4. This bit selects the data width of the HC. The HD shall select it to match the data width of the SD card.
0: 1-bit mode
1: 4-bit mode</comment>
        </bits>
      </reg>
      <reg name="clk_ctrl" protect="rw">
        <comment>SD Control Register2</comment>
        <bits access="rw" name="hw_rst_card" pos="27" rst="0x1">
          <comment>Hardware reset for card
1: Normal work
0: card reset , should be set back to 1 manually</comment>
        </bits>
        <bits access="w" name="sw_rst_dat" pos="26" rst="0x0">
          <comment>Software reset for DAT line. Only part of data circuit is reset. DMA circuit is also reset. The following registers and bits are cleared by this bit:
• Buffer Data Port Register:
 Buffer is cleared and initialized.
• Present State register:
 Buffer Read Enable
 Buffer Write Enable
 Read Transfer Active
 Write Transfer Active
 DAT Line Active
 Command Inhibit (DAT)
• Block Gap Control register:
 Continue Request
 Stop At Block Gap Request
• Normal Interrupt Status register
 Buffer Read Ready
 Buffer Write Ready
 Block Gap Event Transfer Complete
0: work
1: reset</comment>
        </bits>
        <bits access="w" name="sw_rst_cmd" pos="25" rst="0x0">
          <comment>Software reset for CMD line. Only part of command circuit is reset. The following registers and bits are cleared by this bit:
• Present State register
 Command Inhibit (CMD)
• Normal Interrupt Status register
 Command Complete
0: work
1: reset</comment>
        </bits>
        <bits access="w" name="sw_rst_all" pos="24" rst="0x0">
          <comment>Software reset for all. This reset affects the entire HC except for the card detection circuit. Register bits of type ROC, RW, RW1C, RWAC are cleared to 0. During its initialization, the HD shall set this bit to 1 to reset the HC. The HC shall reset this bit to 0 when Capabilities registers are valid and the HD can read them. Additional use of Software Reset for All may not affect the value of the Capabilities registers. If this bit is set to 1, the SD card shall reset itself and must be reinitialized by the HD.
0: work
1: reset</comment>
        </bits>
        <bits access="rw" name="data_timeout_cnt" pos="19:16" rst="0x0">
          <comment>Data timeout counter value. This value determines the interval by which DAT line timeouts are detected. Refer to the Data Timeout Error in the Error Interrupt Status register for information on factors that dictate timeout generation. Timeout clock frequency will be generated by dividing the base clock TMCLK by this value. When setting this register, prevent inadvertent timeout events by clearing the Data Timeout Error Status Enable (in the Error Interrupt Status Enable register).
0000: TMCLK * 2^(16)
0001: TMCLK * 2^(17)
…
1110: TMCLK * 2^(30)
1111: TMCLK * 2^(31)</comment>
        </bits>
        <bits access="rw" name="freq_div_0_7" pos="15:8" rst="0x0">
          <comment>SDCLK/RCLK Frequency Select
If Freq_div = 0:Base clk
   Freq_div = 1:Base clk/2
   Freq_div = 2:Base clk/4
   Freq_div = 3:Base clk/6
……
   Freq_div= n:Base clk/(2*n)</comment>
        </bits>
        <bits access="rw" name="freq_div_8_9" pos="7:6" rst="0x0">
          <comment>SDCLK/RCLK Frequency Select[9:8]</comment>
        </bits>
        <bits access="rw" name="sdclk_en" pos="2" rst="0x0">
          <comment>SD clock enable. The HC shall stop SDCLK when writing this bit to 0. SDCLK Frequency Select can be changed when this bit is 0. Then, the HC shall maintain the same clock frequency until SDCLK is stopped (stop at SDCLK = 0). If the HC detects the No Card state, this bit shall be cleared.
0: disable
1: enable</comment>
        </bits>
        <bits access="r" name="int_clk_stable" pos="1" rst="0x0">
          <comment>Internal clock stable. This bit is set to 1 when SD clock is stable after writing to Internal Clock Enable in this register to 1. The SD Host Driver shall wait to set SD Clock Enable until this bit is 1.Note: This is useful when using PLL for a clock oscillator that requires setup time.
0: not ready
1: ready</comment>
        </bits>
        <bits access="rw" name="int_clk_en" pos="0" rst="0x0">
          <comment>Internal clock enable. This bit is set to 0 when the HD is not using the HC or the HC awaits a wakeup event. The HC should stop its internal clock to go to the very low power state. Still, registers shall be able to be read and written. Clock starts to oscillate when this bit is set to 1. When clock oscillation is stable, the HC shall set Internal Clock Stable in this register to 1. This bit shall not affect card detection.
0: stop
1: oscillate
Note:
It is recommended to set this bit to 0  before changing the clock source, and then set it to 1 after the changing is done.
But changing the frequency divider need not to set this bit to 0.</comment>
        </bits>
      </reg>
      <reg name="int_st" protect="rw">
        <comment>Normal and error interrupt status</comment>
        <bits access="rc" name="axi_resp_err" pos="28" rst="0x0">
          <comment>AXI Bus Error
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="resp_error" pos="27" rst="0x0">
          <comment>Response Error
0: no error</comment>
        </bits>
        <bits access="rc" name="adma_error" pos="25" rst="0x0">
          <comment>ADMA Error
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="auto_cmd12_err" pos="24" rst="0x0">
          <comment>Auto CMD12 error. This occurs when detecting that one of the bits in Auto CMD12 Error Status register has changed from 0 to 1. This bit is set to 1 also when Auto CMD12 is not executed due to the previous command error.
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="data_end_bit_err" pos="22" rst="0x0">
          <comment>Data end bit error. This occurs when detecting 0 at the end bit position of read data which uses the DAT line or the end bit position of the CRC status.
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="data_crc_err" pos="21" rst="0x0">
          <comment>Data CRC error. This occurs when detecting CRC error when transferring read data which uses the DAT line or when detecting the Write CRC Status having a value of other than “010”.
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="data_timeout_err" pos="20" rst="0x0">
          <comment>Data timeout error. This occurs when detecting one of the following timeout conditions.
1. Busy Timeout for R1b, R5b type
2. Busy Timeout after Write CRC status
3. Write CRC status Timeout
4. Read Data Timeout
0: no error
1: timeout</comment>
        </bits>
        <bits access="rc" name="cmd_ind_err" pos="19" rst="0x0">
          <comment>Command index error. This occurs if a Command Index error occurs in the Command Response.
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="cmd_end_bit_err" pos="18" rst="0x0">
          <comment>Command end bit error. This occurs when detecting that the end bit of a command response is 0.
0: no error
1: end bit error generated</comment>
        </bits>
        <bits access="rc" name="cmd_crc_error" pos="17" rst="0x0">
          <comment>Command CRC error. Command CRC Error is generated in two cases.
1. If a response is returned and the Command Timeout Error is set to 0, this bit is set to 1 when detecting a CRC error in the command response
2. The HC detects a CMD line conflict by monitoring the CMD line when a command is issued. If the HC drives the CMD line to 1 level, but detects 0 levels on the CMD line at the next SDCLK edge, then the HC shall abort the command (stop driving CMD line) and set this bit to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line conflict.
0: no error
1: CRC error generated</comment>
        </bits>
        <bits access="rc" name="cmd_timeout_err" pos="16" rst="0x0">
          <comment>Command timeout error. This occurs only if the no response is returned within 64 SDCLK cycles from the end bit of the command. If the HC detects a CMD line conflict, in which case Command CRC Error shall also be set. This bit shall be set without waiting for 64 SDCLK cycles because the command will be aborted by the HC.
0: no error
1: timeout</comment>
        </bits>
        <bits access="rc" name="err_int" pos="15" rst="0x0">
          <comment>Error Interrupt
If any of the bits in the Error Interrpt Status register are set, then this bit is set. Therefore the Host Driver can efficiently test for an error by checking this bit first. This bit is read only.
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="adma3_complete" pos="14" rst="0x0">
          <comment>ADMA3 Complete</comment>
        </bits>
        <bits access="rc" name="card_int" pos="8" rst="0x0">
          <comment>Card interrupts. Writing this bit to 1 does not clear this bit. It is cleared by resetting the SD card interrupt factor. In 1-bit mode, the HC shall detect the Card Interrupt without SD Clock to support wakeup. In 4-bit mode, the card interrupt signal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the card and the interrupt to the Host system. When this status has been set and the HD needs to start this interrupt service, Card Interrupt Status Enable in the Normal Interrupt Status register shall be set to 0 in order to clear the card interrupt statuses latched in the HC and stop driving the Host System. After completion of the card interrupt service (the reset factor in the SD card and the interrupt signal may not be asserted), set Card Interrupt Status Enable to 1 and start sampling the interrupt signal again.
0: no card interrupt
1: card interrupt generated</comment>
        </bits>
        <bits access="rc" name="dma_int" pos="3" rst="0x0">
          <comment>DMA interrupt. This status is set if the HC detects the Host DMA Interrupt.
0: no DMA interrupt
1: DMA interrupt generated</comment>
        </bits>
        <bits access="rc" name="tr_complete" pos="1" rst="0x0">
          <comment>Transfer complete. This bit is set when a read/write transaction is completed.
Read Transaction: This bit is set at the falling edge of Read Transfer Active Status. There are two cases in which the Interrupt is generated. The first is when a data transfer is completed as specified by data length (after the last data has been read to the Host System). The second is when data has stopped at the block gap and completed the data transfer by setting the Stop at Block Gap Request in the Block Gap Control register (after valid data has been read to the Host System).
Write Transaction: This bit is set at the falling edge of the DAT Line Active Status. There are two cases in which the Interrupt is generated. The first is when the last data is written to the card as specified by data length and Busy signal is released. The second is when data transfers are stopped at the block gap by setting Stop at Block Gap Request in the Block Gap Control register and data transfers completed (after valid data is written to the SD card and the busy signal is released).
0: no data transfer complete
1: data transfer complete</comment>
        </bits>
        <bits access="rc" name="cmd_complete" pos="0" rst="0x0">
          <comment>Command complete. This bit is set when getting the end bit of the command response (except auto CMD12 and auto CMD23).
Note: Command Timeout Error has higher priority than Command Complete. If both are set to 1, it can be considered that the response was not received correctly.
0: no command complete
1: command complete</comment>
        </bits>
      </reg>
      <reg name="int_st_en" protect="rw">
        <comment>Normal and error interrupt status enable</comment>
        <bits access="rw" name="axi_resp_err_en" pos="28" rst="0x0">
          <comment>AXI Bus Error status enable</comment>
        </bits>
        <bits access="rw" name="resp_error_en" pos="27" rst="0x0">
          <comment>Response Error status enable</comment>
        </bits>
        <bits access="rw" name="adma_error_en" pos="25" rst="0x0">
          <comment>ADMA Error status enable</comment>
        </bits>
        <bits access="rw" name="auto_cmd12_err_en" pos="24" rst="0x0">
          <comment>Auto CMD12 error status enable</comment>
        </bits>
        <bits access="rw" name="data_end_bit_err_en" pos="22" rst="0x0">
          <comment>Data end bit error status enable</comment>
        </bits>
        <bits access="rw" name="data_crc_err_en" pos="21" rst="0x0">
          <comment>Data CRC error status enable</comment>
        </bits>
        <bits access="rw" name="data_timeout_err_en" pos="20" rst="0x0">
          <comment>Data timeout error status enable</comment>
        </bits>
        <bits access="rw" name="cmd_ind_err_en" pos="19" rst="0x0">
          <comment>Command index error status enable</comment>
        </bits>
        <bits access="rw" name="cmd_end_bit_err_en" pos="18" rst="0x0">
          <comment>Command end bit error status enable</comment>
        </bits>
        <bits access="rw" name="cmd_crc_error_en" pos="17" rst="0x0">
          <comment>Command CRC error status enable</comment>
        </bits>
        <bits access="rw" name="cmd_timeout_err_en" pos="16" rst="0x0">
          <comment>Command timeout error status enable</comment>
        </bits>
        <bits access="rw" name="adma3_complete_en" pos="14" rst="0x0">
          <comment>ADMA3 Complete status enable</comment>
        </bits>
        <bits access="rw" name="card_int_en" pos="8" rst="0x0">
          <comment>Card interrupt status enable</comment>
        </bits>
        <bits access="rw" name="dma_int_en" pos="3" rst="0x0">
          <comment>DMA interrupt status enable</comment>
        </bits>
        <bits access="rw" name="tr_complete_en" pos="1" rst="0x0">
          <comment>Transfer complete status enable</comment>
        </bits>
        <bits access="rw" name="cmd_complete_en" pos="0" rst="0x0">
          <comment>Command complete status enable</comment>
        </bits>
      </reg>
      <reg name="int_sig_en" protect="rw">
        <comment>Normal and error interrupt signal enable</comment>
        <bits access="rw" name="axi_resp_err_en" pos="28" rst="0x0">
          <comment>AXI Bus Error signal enable</comment>
        </bits>
        <bits access="rw" name="resp_error_en" pos="27" rst="0x0">
          <comment>Response Error signal enable</comment>
        </bits>
        <bits access="rw" name="adma_error_en" pos="25" rst="0x0">
          <comment>ADMA Error signal enable</comment>
        </bits>
        <bits access="rw" name="auto_cmd12_err_en" pos="24" rst="0x0">
          <comment>Auto CMD12 error signal enable</comment>
        </bits>
        <bits access="rw" name="cur_lmt_err_en" pos="23" rst="0x0">
          <comment>Current limit error signal enable</comment>
        </bits>
        <bits access="rw" name="data_end_bit_err_en" pos="22" rst="0x0">
          <comment>Data end bit error signal enable</comment>
        </bits>
        <bits access="rw" name="data_crc_err_en" pos="21" rst="0x0">
          <comment>Data CRC error signal enable</comment>
        </bits>
        <bits access="rw" name="data_timeout_err_en" pos="20" rst="0x0">
          <comment>Data timeout error signal enable</comment>
        </bits>
        <bits access="rw" name="cmd_ind_err_en" pos="19" rst="0x0">
          <comment>Command index error signal enable</comment>
        </bits>
        <bits access="rw" name="cmd_end_bit_err_en" pos="18" rst="0x0">
          <comment>Command end bit error signal enable</comment>
        </bits>
        <bits access="rw" name="cmd_crc_error_en" pos="17" rst="0x0">
          <comment>Command CRC error signal enable</comment>
        </bits>
        <bits access="rw" name="cmd_timeout_err_en" pos="16" rst="0x0">
          <comment>Command timeout error signal enable</comment>
        </bits>
        <bits access="rw" name="adma3_complete_en" pos="14" rst="0x0">
          <comment>ADMA3 transfer complete signal enable</comment>
        </bits>
        <bits access="rw" name="card_int_en" pos="8" rst="0x0">
          <comment>Card interrupt signal enable</comment>
        </bits>
        <bits access="rw" name="dma_int_en" pos="3" rst="0x0">
          <comment>DMA interrupt signal enable</comment>
        </bits>
        <bits access="rw" name="tr_complete_en" pos="1" rst="0x0">
          <comment>Transfer complete signal enable</comment>
        </bits>
        <bits access="rw" name="cmd_complete_en" pos="0" rst="0x0">
          <comment>Command complete signal enable</comment>
        </bits>
      </reg>
      <reg name="host_ctrl2" protect="rw">
        <comment>Host controller 2 and Auto CMD12 error status</comment>
        <bits access="rw" name="addr_64bit_en" pos="29" rst="0x0">
          <comment>The system address is 32 bit or 64 bits
0: 32 bit address
1: 64 bit address</comment>
        </bits>
        <bits access="r" name="host_ver_4_en" pos="28" rst="0x1">
          <comment>This design is host version 4</comment>
        </bits>
        <bits access="rw" name="cmd23_enable" pos="27" rst="0x0">
          <comment>CMD23 Enable
This bit is used to select Auto CMD23 or Auto CMD12 for ADMA3 data transfer. Refer to Auto CMD Enable in the Transfer Mode Register
0:  AutoCMD auto select CMD12
1:  AutoCMD auto select CMD23</comment>
        </bits>
        <bits access="rw" name="adma2_len_mode" pos="26" rst="0x0">
          <comment>The ADMA2 length mode is 26 bit or 16bit
0: 16 bit data length mode
1: 26 bit data length mode</comment>
        </bits>
        <bits access="rw" name="uhs_mode" pos="19:16" rst="0x0">
          <comment>UHS Mode Select
This field is used to select one of UHS-I mode and effective when 1.8V Signaling Enable is set to 1.
If Preset Value Enable in the SD_CTRL3 register is set to 1, Host controller sets SDCLK Frequency Select, Clock Generator Select in the Clock Control register according to Preset Value registers. In this case, one of preset value registers is selected by this field. Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitch. After setting this field, Host Driver sets SD Clock Enable again.
4’b0000: SDR12
4’b0001: SDR25
4’b0010: SDR50
4’b0011: SDR104
4’b0100: DDR50
4’b0101: HS200
4’b0110: HS400
4’b0111: HS401 (EMMC5.1) HS400 mode
4’b1000: DDR200, SD6.0</comment>
        </bits>
        <bits access="r" name="cmd_not_iss_err" pos="7" rst="0x0">
          <comment>Command not issued error. Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error ([4:1]) in this register.
0: no error
1: not issued</comment>
        </bits>
        <bits access="r" name="acmd_idx_err" pos="4" rst="0x0">
          <comment>Auto CMD index error. This occurs if the Command Index error occurs in response to a command.
0: no error
1: error</comment>
        </bits>
        <bits access="r" name="acmd_end_bit_err" pos="3" rst="0x0">
          <comment>Auto CMD end bit error. This occurs when detecting that the end bit of command response is 0.
0: no error
1: end bit error generated</comment>
        </bits>
        <bits access="r" name="acmd_crc_err" pos="2" rst="0x0">
          <comment>Auto CMD CRC error. This occurs when detecting a CRC error in the command response.
0: no error
1: CRC error generated</comment>
        </bits>
        <bits access="r" name="acmd_timeout_err" pos="1" rst="0x0">
          <comment>Auto CMD timeout error. This occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command. If this bit is set to 1, the other error status bits ([4:2]) are meaningless.
0: no error
1: timeout</comment>
        </bits>
        <bits access="r" name="acmd12_not_exec" pos="0" rst="0x0">
          <comment>Auto CMD12 Not Executed
If memory multiple block data transfer is not started due to command error. This bit is not set because it is not necessary to issue auto cmd12. Setting this bit to 1 means the Host Controller cannot issue auto cmd12 to stop memory multiple block data transfer due to some error. If this bit is set to 1. Other error status bits are meaningless.</comment>
        </bits>
      </reg>
      <reg name="cap1" protect="rw">
        <comment>Capabilities</comment>
        <bits access="r" name="slot_type" pos="31:30" rst="0x0">
          <comment>Slot Type
2’b00: Removable Card Slot</comment>
        </bits>
        <bits access="r" name="async_int" pos="29" rst="0x0">
          <comment>Asynchronous Interrupt Support
1’b0:Asynchronous  Interrupt Not Supported</comment>
        </bits>
        <bits access="r" name="addr_64bit_sup_v3" pos="28" rst="0x1">
          <comment>64 bit System Bus Support
1’b0 64 bit System Bus Support</comment>
        </bits>
        <bits access="r" name="addr_64bit_sup_v4" pos="27" rst="0x1">
          <comment>64 bit System Bus Support
1’b0 64 bit System Bus Support</comment>
        </bits>
        <bits access="r" name="v18" pos="26" rst="0x1">
          <comment>Voltage support 1.8 V.
0: 1.8 V not supported
1: 1.8 V supported</comment>
        </bits>
        <bits access="r" name="v30" pos="25" rst="0x0">
          <comment>Voltage support 3.0 V.
0: 3.0 V not supported
1: 3.0 V supported</comment>
        </bits>
        <bits access="r" name="v33" pos="24" rst="0x0">
          <comment>Voltage support 3.3 V.
0: 3.3 V not supported
1: 3.3 V supported</comment>
        </bits>
        <bits access="r" name="susp_res" pos="23" rst="0x0">
          <comment>Suspend/resume support. This bit indicates whether the HC supports Suspend/Resume function. If this bit is 0, the Suspend and Resume mechanism is not supported and the HD shall not issue either Suspend/Resume command.
0: not supported
1: supported</comment>
        </bits>
        <bits access="r" name="dma" pos="22" rst="0x1">
          <comment>DMA support. This bit indicates whether the HC is capable of using DMA to transfer data between system memory and the HC directly.
0: DMA not supported
1: DMA supported</comment>
        </bits>
        <bits access="r" name="high_speed" pos="21" rst="0x1">
          <comment>High speed support. This bit indicates whether the HC and the Host System support High Speed mode and they can supply SD Clock frequency from 25 MHz to 50 MHz
0: high speed not supported
1: high speed supported</comment>
        </bits>
        <bits access="r" name="adma2_support" pos="19" rst="0x1">
          <comment>ADMA2 Support
1’b0: ADMA2 is not supported
1’b1: ADMA2 is supported</comment>
        </bits>
        <bits access="r" name="sup_8bit" pos="18" rst="0x1">
          <comment>8-bit Support for Device
1’b1: 8-bit Bus Width Supported</comment>
        </bits>
        <bits access="r" name="max_blk_size" pos="17:16" rst="0x1">
          <comment>This value indicates the maximum block size that the HD can read and write to the buffer in the HC. The buffer shall transfer this block size without wait cycles.
00: 512 bytes
01: 1024 bytes
10: 2048 bytes
11: 4096 bytes</comment>
        </bits>
        <bits access="r" name="base_clk_frq" pos="15:8" rst="0x0">
          <comment>This value indicates the base (maximum) clock frequency for the SD clock. The unit is MHz If the real frequency is 16.5 MHz, a larger value shall be set, i.e., 010001b (17 MHz) because the HD uses this value to calculate the clock divider value and it shall not exceed the upper limit of the SD clock frequency. The supported range is 10 to 63 MHz If these bits are all 0, the Host System has to get information via another method.
0: get information via another method (Registry Entry)
1: 1 MHz
2: 2 MHz
…
FF: 255 MHz</comment>
        </bits>
        <bits access="r" name="timeout_clk_unit" pos="7" rst="0x1">
          <comment>This bit shows the unit of base clock frequency used to detect Data Timeout Error.
0: kHz
1: MHz</comment>
        </bits>
        <bits access="r" name="timeout_clk_frq" pos="5:0" rst="0x0">
          <comment>This bit shows the base clock frequency used to detect Data Timeout Error.
0: get information via another method
1: 1 MHz
2: 2 MHz
…
63: 63 MHz</comment>
        </bits>
      </reg>
      <reg name="cap2" protect="rw">
        <comment>Capabilities 2</comment>
        <bits access="r" name="adma3_support" pos="27" rst="0x1">
          <comment>ADMA3 is support</comment>
        </bits>
        <bits access="r" name="ddr50_sup" pos="2" rst="0x1">
          <comment>DDR50 Support
1’b0: DDR50 is Supported</comment>
        </bits>
        <bits access="r" name="sdr104_sup" pos="1" rst="0x1">
          <comment>SDR104 Support
1’b0 : SDR104 is  Supported</comment>
        </bits>
        <bits access="r" name="sdr50_sup" pos="0" rst="0x1">
          <comment>SDR50 Support
1’b0: SDR50 is Supported</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="frc_evt" protect="rw">
        <comment>Force event register</comment>
        <bits access="w" name="frc_evt_acmd_err" pos="27" rst="0x0">
          <comment>Force Event for Auto CMD Error</comment>
        </bits>
        <bits access="w" name="frc_evt_tun_err" pos="25" rst="0x0">
          <comment>Force Event for tuning Error</comment>
        </bits>
        <bits access="w" name="frc_evt_resp_err" pos="24" rst="0x0">
          <comment>Force Event for Response Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_dat_end" pos="22" rst="0x0">
          <comment>Force Event for Data End Bit Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_dat_crc" pos="21" rst="0x0">
          <comment>Force Event for Data CRC Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_dat_tout" pos="20" rst="0x0">
          <comment>Force Event for Data Timeout Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_ind" pos="19" rst="0x0">
          <comment>Force Event for Command Index Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_end" pos="18" rst="0x0">
          <comment>Force Event for Command End Bit Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_crc" pos="17" rst="0x0">
          <comment>Force Event for Command CRC Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_tout" pos="16" rst="0x0">
          <comment>Force Event for Command Time Out Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd12" pos="7" rst="0x0">
          <comment>Force Event for Command Not Issued By Auto CMD12 Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd_ind" pos="4" rst="0x0">
          <comment>Force Event for Auto CMD Index Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd_end" pos="3" rst="0x0">
          <comment>Force Event for Auto CMD End Bit Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd_crc" pos="2" rst="0x0">
          <comment>Force Event for Auto CMD Timeout Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd_tout" pos="1" rst="0x0">
          <comment>Force Event for Auto CMD Timeout Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd_nexec" pos="0" rst="0x0">
          <comment>Force Event for Auto CMD 12 Not Executed
1: Interrupt is generated
0: No Interrupt</comment>
        </bits>
      </reg>
      <reg name="adma_err_sts" protect="rw">
        <comment>ADMA Error State register</comment>
        <bits access="r" name="bresp_err" pos="19:18" rst="0x0">
          <comment>If BRESP = SLVERR or DECERR, then BRESP_ERR is occurred, and this register will indicted the type of Error.
00: OKAY
01: EXOKAY
10: SLVERR
11: DECERR</comment>
        </bits>
        <bits access="r" name="rresp_err" pos="17:16" rst="0x0">
          <comment>If RRESP = SLVERR or DECERR, then RRESP_ERR is occurred, and this register will indicted the type of Error.
00: OKAY
01: EXOKAY
10: SLVERR
11: DECERR</comment>
        </bits>
        <bits access="r" name="adma_length_mismatch" pos="2" rst="0x0">
          <comment>ADMA Length Mismatch Error
1: Error
0: No Error
This error occurs in the following 2 cases:
1) While Block Count Enable being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length
2) Total data length cannot be divided by the block length.</comment>
        </bits>
        <bits access="r" name="adma_err_state" pos="1:0" rst="0x0">
          <comment>ADMA Error State
This field indicates the state of ADMA when error is occurred during ADMA data transfer.
2’b00: ST_STOP (Stop DMA), Points next of the error descriptor.
2’b01: ST_FDS (Fetch Descriptor), Points the error descriptor
2’b10:  Reserved
2’b11: ST_TFR (Transfer Data), Points the next of the error descriptor</comment>
        </bits>
      </reg>
      <reg name="adma2_addr_l" protect="rw">
        <comment>ADMA2 System Address Low registers</comment>
      </reg>
      <reg name="adma2_addr_h" protect="rw">
        <comment>ADMA2 System Address High registers</comment>
      </reg>
      <hole size="192"/>
      <reg name="adma3_addr_l" protect="rw">
        <comment>ADMA3 System Address Low registers</comment>
      </reg>
      <reg name="adma3_addr_h" protect="rw">
        <comment>ADMA3 System Address High registers</comment>
      </reg>
      <hole size="992"/>
      <reg name="host_ver" protect="rw">
        <comment>Host version number</comment>
        <bits access="r" name="host_ver" pos="23:16" rst="0x4">
          <comment>This status indicates the Host Controller Spec Version. The upper and lower 4 bits indicate the version.
00: SD Host Specification version 1.0
01 SD Host Specification Version 2.0
02 SD Host Specification Version 3.0
03 SD Host Specification Version 4.0
04 SD Host Specification Version 4.1
Others: reserved</comment>
        </bits>
        <bits access="r" name="slt1_int" pos="0" rst="0x0">
          <comment>One slot, it is equal to the int_to_arm</comment>
        </bits>
      </reg>
      <hole size="2048"/>
      <reg name="dll_cfg" protect="rw">
        <comment>EMMC PHY DLL CFG registers</comment>
        <bits access="r" name="dll_wait_cnt" pos="31:28" rst="0x4">
          <comment>Cycles to wait DLL locked signals.</comment>
        </bits>
        <bits access="rw" name="dll_rdneg_cpst_en" pos="27" rst="0x0">
          <comment>Read negedge delay cell  select
0:use user defined value from CLKNEGRD_DLY_ VAL
1:use dll generated value which referenced form CLKNEGRD_DLY_ VAL</comment>
        </bits>
        <bits access="rw" name="dll_rdpos_cpst_en" pos="26" rst="0x0">
          <comment>Read posedge delay cell  select
0:use user defined value from CLKPOSRD_DLY_VAL
1:use dll generated value which referenced form CLKPOSRD_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="dll_rdcmd_cpst_en" pos="25" rst="0x0">
          <comment>Read cmd delay cell  select
0:use user defined value from CLKCMDRD_DLY_VAL
1:use dll generated value which referenced form CLKCMDRD_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="dll_datwr_cpst_en" pos="24" rst="0x0">
          <comment>write delay cell  select
0:use user defined value from CLKDATWR_DLY_VAL
1:use dll generated value which referenced form CLKDATWR_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="dll_clk_sel" pos="22" rst="0x0">
          <comment>DLL Clock source selection
0: Select 1x clock
1: Select 2x clock</comment>
        </bits>
        <bits access="rw" name="dll_en" pos="21" rst="0x0">
          <comment>DLL enable signal
0:DLL disable
1:DLL enable</comment>
        </bits>
        <bits access="rw" name="dll_clr" pos="20" rst="0x0">
          <comment>DLL clear signal
1:clear DLL</comment>
        </bits>
        <bits access="rw" name="dll_auto_clr_en" pos="19" rst="0x0">
          <comment>Don’t  support in this version</comment>
        </bits>
        <bits access="rw" name="dll_cpst_en" pos="18" rst="0x0">
          <comment>DLL output delay value enable</comment>
        </bits>
        <bits access="rw" name="dll_cpst_start" pos="17" rst="0x0">
          <comment>DLL start enable signal, this bit should be write to 1’b0 when it is enabled to 1’b1</comment>
        </bits>
        <bits access="rw" name="dll_half_mode" pos="16" rst="0x0">
          <comment>DLL lock mode:
0: full cycle lock mode
1: half cycle lock mode</comment>
        </bits>
        <bits access="rw" name="dll_init" pos="14:8" rst="0x1">
          <comment>DLL count initial value, DLL use it as the initial value to count the delay value.</comment>
        </bits>
        <bits access="rw" name="dll_cpst_threshold" pos="7:4" rst="0x0">
          <comment>DLL  change  threshold value, DLL update rd/wr/cmd delay line value if the DLL count delta bigger then DLL_CPST_THRESHOLD</comment>
        </bits>
        <bits access="rw" name="dll_phase_interval" pos="2:1" rst="0x0">
          <comment>DLL phase interval , DLL use it as the interval of phase 1 and phase2</comment>
        </bits>
        <bits access="rw" name="clk_phase_sel" pos="0" rst="0x0">
          <comment>OUPUT clock phase select</comment>
        </bits>
      </reg>
      <reg name="dll_dly" protect="rw">
        <comment>EMMC PHY DLL DLY registers</comment>
        <bits access="rw" name="clknegrd_dly_val" pos="31:24" rst="0x0">
          <comment>Clock Read Data Negedge Delay Value
Based Phase is same as PHY Clock
Refer to description of CLKDATWR_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="clkposrd_dly_val" pos="23:16" rst="0x0">
          <comment>Clock Read Data Posedge Delay Value
Based Phase is same as PHY Clock
Refer to description of CLKDATWR_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="clkcmdrd_dly_val" pos="15:8" rst="0x0">
          <comment>Clock Read Command Line Delay Value
Based Phase is same as PHY Clock
Refer to description of CLKDATWR_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="clkdatwr_dly_val" pos="7:0" rst="0x0">
          <comment>Clock Data Write Line Delay Value
Based Phase is invert of PHY Clock
When DLL_DATWR_CPST_EN is enable,
This register is act as proportion of DLL clock cycle.
E.g.(when DLL_DATWR _CPST_EN==1)
If CLKDATWR _DLY_ VAL ==’h40, it means delay ‘h40/’h100 ≈ 1/4  cycle.
If CLKDATWR_DLY_ VAL ==’h80, it means delay ‘h80/’h100F ≈ 1/2  cycle.</comment>
        </bits>
      </reg>
      <reg name="dll_dly_offset" protect="rw">
        <comment>EMMC PHY DLL Offset Read registers</comment>
        <bits access="rw" name="clknegrd_dly_inv" pos="29" rst="0x0">
          <comment>Clock Read Data Negedge Delay Invert</comment>
        </bits>
        <bits access="rw" name="clknegrd_dly_offset" pos="28:24" rst="0x0">
          <comment>Refer to description of CLKDATWR_DLY_OFFSET</comment>
        </bits>
        <bits access="rw" name="clkposrd_dly_inv" pos="21" rst="0x0">
          <comment>Clock Read Data Posedge Delay Invert</comment>
        </bits>
        <bits access="rw" name="clkposrd_dly_offset" pos="20:16" rst="0x0">
          <comment>Refer to description of CLKDATWR_DLY_OFFSET</comment>
        </bits>
        <bits access="rw" name="clkcmdrd_dly_inv" pos="13" rst="0x0">
          <comment>Clock Read Command Line Delay Invert</comment>
        </bits>
        <bits access="rw" name="clkcmdrd_dly_offset" pos="12:8" rst="0x0">
          <comment>Refer to description of CLKDATWR_DLY_OFFSET</comment>
        </bits>
        <bits access="rw" name="clkdatwr_dly_inv" pos="5" rst="0x0">
          <comment>Clock Data Write Line Delay Invert</comment>
        </bits>
        <bits access="rw" name="clkdatwr_dly_offset" pos="4:0" rst="0x0">
          <comment>Data Write Delay offset. The highest bit indicates if it is add or sub.
OFFSET [4]=0:  CLKDATWR_DLY_VAL + OFFSET [3:0]
OFFSET [4]=1:  CLKDATWR_DLY_VAL – OFFSET [3:0].
If DLL_DATWR _CPST_EN==1, the offset is added after the proportion.
E.g. If
Clock cycle (CYC)== 5ns
CLKDATWR _DLY_ VAL (VAL) ==’h40, CLKDATWR_DLY_OFFSET (OFSET) == ‘h6,
DLL_CNT(CNT) == ‘h20
 it means delay:
(VAL/’h100)*CYC + (CYC * OFSET) / CN =
 (‘h40/’h100)*5ns + (5ns * ‘h6) / ‘h20 ≈2.2ns</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="dll_sts0" protect="rw">
        <comment>EMMC PHY DLL STS0 registers</comment>
        <bits access="r" name="dll_phase1" pos="20" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_phase2" pos="19" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_locked" pos="18" rst="0x0">
          <comment>If use DLL, software should wait this value to 1’b1</comment>
        </bits>
        <bits access="r" name="dll_error" pos="17" rst="0x0">
          <comment>If use DLL, soft ware should wait DLL_LOCKED to 1’b1 and  at that time ,this bit is 1’b0</comment>
        </bits>
        <bits access="r" name="dll_cpst_st" pos="16" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_st" pos="11:8" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_cnt" pos="7:0" rst="0x0">
          <comment>DLL delay cell counts of 1 cycle</comment>
        </bits>
      </reg>
      <reg name="dll_sts1" protect="rw">
        <comment>EMMC PHY DLL STS1 registers</comment>
        <bits access="r" name="clknegrd_dly_cnt" pos="31:24" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="clkposrd_dly_cnt" pos="23:16" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="clkcmdrd_dly_cnt" pos="15:8" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="clkdatwr_dly_cnt" pos="7:0" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="ram_addr_buf_l" protect="rw">
        <comment>EMMC Buffer Processing System Low address</comment>
      </reg>
      <reg name="ram_addr_buf_h" protect="rw">
        <comment>EMMC Buffer Processing System High address</comment>
      </reg>
      <reg name="blk_cnt_buf" protect="rw">
        <comment>EMMC Buffer Processing Block Count</comment>
      </reg>
      <reg name="blk_cnt_io" protect="rw">
        <comment>EMMC IO Processing Block Count</comment>
      </reg>
      <hole size="128"/>
      <reg name="adma2_addr_ing_l" protect="rw">
        <comment>EMMC Processing ADMA2 Low address</comment>
      </reg>
      <reg name="adma2_addr_ing_h" protect="rw">
        <comment>EMMC Processing ADMA2 High address</comment>
      </reg>
      <reg name="adma3_addr_ing_l" protect="rw">
        <comment>EMMC Processing ADMA3 Low address</comment>
      </reg>
      <reg name="adma3_addr_ing_h" protect="rw">
        <comment>EMMC Processing ADMA3 High address</comment>
      </reg>
      <reg name="busy_posi" protect="rw">
        <comment>EMMC Busy/CRC Status Position registers</comment>
        <bits access="rw" name="outr_clk_auto_en" pos="25" rst="0x0">
          <comment>Control the Output clock SD_CLK auto gating
0: disable auto gating
1: enable auto gating</comment>
        </bits>
        <bits access="rw" name="innr_clk_auto_en" pos="24" rst="0x0">
          <comment>Control the internal clock auto gating
0: disable auto gating
1: enable auto gating</comment>
        </bits>
        <bits access="rw" name="crcsts_posi_sts" pos="23:20" rst="0x6">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="rw" name="read_busy_posi_sts" pos="19:16" rst="0xa">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="rw" name="abort_bug_option" pos="15" rst="0x1">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="rw" name="mstrs_prot" pos="14:12" rst="0x0">
          <comment>Master PROT attributes.
It directly maps to the AXI master bus. AWPROT_emmc and ARPROT_emmc port.</comment>
        </bits>
        <bits access="rw" name="sdcard_clk_oe" pos="11" rst="0x1">
          <comment>Control the Output enable of clock SD_CLK
0: Clock OE is 0
1: Clock OE is 1</comment>
        </bits>
        <bits access="rw" name="sdcard_clk_ie" pos="10" rst="0x0">
          <comment>Control the Input enable of clock SD_CLK,
0: Clock IE is 0
1: Clock IE is 1</comment>
        </bits>
        <bits access="rw" name="crcsts_posi_force" pos="9" rst="0x0">
          <comment>CRC Status Position Force Enable
0: use default value
1: use CRCSTS_POSI value
(Debug or designer set only)</comment>
        </bits>
        <bits access="rw" name="read_busy_posi_force" pos="8" rst="0x0">
          <comment>Read Busy Position Force Enable
0: use default value
1: use READ_BUSY_POSI value
(Debug or designer set only)</comment>
        </bits>
        <bits access="rw" name="crcsts_posi_set" pos="7:4" rst="0x0">
          <comment>CRC Status Position Adjustment
This register can adjust the sample position of CRC status, the need of this register is because of the HS200 or HS400 read data or CRC status may delay more cycles than legacy mode
When CRCSTS_POSI_FORCE is set 1 this register is valid, else the actual value is used internal set value.</comment>
        </bits>
        <bits access="rw" name="read_busy_posi_set" pos="3:0" rst="0x0">
          <comment>Read Busy Position Adjustment
This register can adjust the sample position of read busy, the need of this register is because of the HS200 or HS400 read data or CRC status may delay more cycles than legacy mode.
When controller is read busy, the moment of stopping clock may be adjust through this register.
When READ_BUSY_POSI_FORCE is set 1 this register is valid, else the actual value is used internal set value.</comment>
        </bits>
      </reg>
      <reg name="fsm_crcerr_sts" protect="rw">
        <comment>EMMC CRC Error Status registers</comment>
        <bits access="r" name="rdata_crc_error" pos="15:0" rst="0x0">
          <comment>(Debug only)
Bit[15] : Neg 7
Bit[14] : neg 6
Bit[13] : neg 5
Bit[12] : neg 4
Bit[11] : neg 3
Bit[10] : neg 2
Bit[9] : neg 1
Bit[8] : neg 0
Bit[7] : pos 7
Bit[6] : pos 6
Bit[5] : pos 5
Bit[4] : pos 4
Bit[3] : pos 3
Bit[2] : pos 2
Bit[1] : pos 1
Bit[0] : pos 0
The BIT[15:8] just used in DDR mode.</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="fsm_debug0" protect="rw">
        <comment>EMMC FSM Debug0 register</comment>
        <bits access="r" name="clk_pad_out_ind" pos="31" rst="0x0">
          <comment>This bit indicate whether the pad clock is working or stop.
0: clock is stopped.
1: clock is working</comment>
        </bits>
        <bits access="r" name="recv_fsm" pos="19:16" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="trans_fsm" pos="13:8" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="cmd_fsm" pos="4:0" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
      </reg>
      <reg name="fsm_debug1" protect="rw">
        <comment>EMMC FSM Debug1 register</comment>
        <bits access="r" name="adma3_fsm" pos="15:12" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="adma2_fsm" pos="11:9" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="mst_fsm" pos="7:4" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="io_fsm" pos="3:0" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
      </reg>
      <reg name="fsm_debug2" protect="rw">
        <comment>EMMC FSM Debug2 register</comment>
        <bits access="r" name="data_fsm" pos="7:4" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="addr_fsm" pos="3:0" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
      </reg>
      <hole size="256"/>
      <reg name="dll_backup" protect="rw">
        <comment>DLL USED BACKUP SIGNAL</comment>
        <bits access="rw" name="oe_ext_optional" pos="4" rst="0x0">
          <comment>Oe_ext_optional( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_slice_en_value" pos="3" rst="0x0">
          <comment>Force slice en value( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_slice_en_force" pos="2" rst="0x0">
          <comment>Force slice enable( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_backup_value" pos="1" rst="0x1">
          <comment>Force dll use backup mode value( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_backup" pos="0" rst="0x0">
          <comment>Force dll use backup mode( Reserved  for  vender asic only)</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04006000" name="EMMC" type="EMMC"/>
  </archive>
  <archive relative="gpt_lite.xml">
    <module category="System" name="GPT_LITE">
      <reg name="cr" protect="rw">
        <comment/>
        <bits access="rw" name="refclk_sel" pos="31" rst="0x1">
          <comment>refclk_sel</comment>
        </bits>
        <bits access="rw" name="tri_cnt_en" pos="12" rst="0x0">
          <comment>Input triger number count enable</comment>
        </bits>
        <bits access="rw" name="tri" pos="11:9" rst="0x0">
          <comment>slave_mode trigger select</comment>
        </bits>
        <bits access="rw" name="arpe" pos="8" rst="0x1">
          <comment>auto preload value</comment>
        </bits>
        <bits access="rw" name="cms" pos="7:6" rst="0x0">
          <comment>Center-aligned mode select 00: disable , other:enable</comment>
        </bits>
        <bits access="rw" name="dir" pos="5" rst="0x0">
          <comment>counter dir , 0: cnt ++ , 1: cnt --</comment>
        </bits>
        <bits access="rw" name="opm" pos="4" rst="0x0">
          <comment>one pulse mode,  0:disable 1:enable</comment>
        </bits>
        <bits access="rw" name="udis" pos="3" rst="0x0">
          <comment>update disable, 0:disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="ckd" pos="2:1" rst="0x0">
          <comment>clock fdts didiver, 01: divided by 2 10:divided by 4, other:bypass</comment>
        </bits>
        <bits access="rw" name="cen" pos="0" rst="0x0">
          <comment>counter enable, 0: disbale, 1:enable</comment>
        </bits>
      </reg>
      <reg name="smcr" protect="rw">
        <comment/>
        <bits access="rw" name="sms" pos="2:0" rst="0x0">
          <comment>slave mode select: 100: slave mode, 101:gate mode, 110:trig mode, others disable</comment>
        </bits>
      </reg>
      <reg name="egr" protect="rw">
        <comment/>
        <bits access="r" name="ug" pos="0" rst="0x0">
          <comment>bit type is changed from w1c to rc. user trigger gen</comment>
        </bits>
      </reg>
      <reg name="ccmr_oc" protect="rw">
        <comment/>
        <bits access="rw" name="oc2ce" pos="15" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc2m" pos="14:12" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc2pe" pos="11" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc2fe" pos="10" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc2s" pos="9:8" rst="0x0">
          <comment>channel source sel, bit[9] 0: output enable, 1 output disable bit[8] 0: use ti2, 1: use ti1</comment>
        </bits>
        <bits access="rw" name="oc1ce" pos="7" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc1m" pos="6:4" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc1pe" pos="3" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc1fe" pos="2" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc1s" pos="1:0" rst="0x0">
          <comment>channel source sel, bit[0] 0: output enable, 1 output disable bit[1] 0: use ti2, 1: use ti1</comment>
        </bits>
      </reg>
      <reg name="ccmr_ic" protect="rw">
        <comment/>
        <bits access="rw" name="ic2f" pos="13:10" rst="0x0">
          <comment>ti2 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic2psc" pos="9:8" rst="0x0">
          <comment>ti2 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
        <bits access="rw" name="ic1f" pos="5:2" rst="0x0">
          <comment>ti1 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic1psc" pos="1:0" rst="0x0">
          <comment>ti1 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
      </reg>
      <reg name="ccer" protect="rw">
        <comment/>
        <bits access="rw" name="cc2p" pos="3" rst="0x0">
          <comment>ti2 polarity</comment>
        </bits>
        <bits access="rw" name="cc2e" pos="2" rst="0x0">
          <comment>ti2 enable</comment>
        </bits>
        <bits access="rw" name="cc1p" pos="1" rst="0x0">
          <comment>ti1 polarity</comment>
        </bits>
        <bits access="rw" name="cc1e" pos="0" rst="0x0">
          <comment>ti1 enable</comment>
        </bits>
      </reg>
      <reg name="cnt" protect="rw">
        <comment/>
        <bits access="r" name="cnt_value" pos="15:0" rst="0x0">
          <comment>cnt_value</comment>
        </bits>
      </reg>
      <reg name="psc" protect="rw">
        <comment/>
        <bits access="rw" name="psc_value" pos="15:0" rst="0x0">
          <comment>cnt prescale value</comment>
        </bits>
      </reg>
      <reg name="arr" protect="rw">
        <comment/>
        <bits access="rw" name="arr_value" pos="15:0" rst="0xffff">
          <comment>cnt max value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr1_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr1_capture" pos="15:0" rst="0xffff">
          <comment>ic1 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr2_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr2_capture" pos="15:0" rst="0xffff">
          <comment>ic2 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr1_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr1_compare" pos="15:0" rst="0xffff">
          <comment>ic1 compare value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr2_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr2_compare" pos="15:0" rst="0xffff">
          <comment>ic2 compare value</comment>
        </bits>
      </reg>
      <reg name="isr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="irsr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="mask" protect="rw">
        <comment/>
        <bits access="rw" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="rw" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="rw" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="rw" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="clr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>bit type is changed from w1c to rc. cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>bit type is changed from w1c to rc. trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04809000" name="AP_GPT_LITE" type="GPT_LITE"/>
    <instance address="0x5150d000" name="LPS_GPT_LITE" type="GPT_LITE"/>
  </archive>
  <archive relative="med.xml">
    <module category="System" name="MED">
      <reg name="med_ch0_work_cfg" protect="rw">
        <comment>med_ch0_work_cfg</comment>
        <bits access="rw" name="med_ch0_bypass_en" pos="4" rst="0x0">
          <comment>1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption</comment>
        </bits>
        <bits access="rw" name="med_ch0_enable" pos="0" rst="0x0">
          <comment>1:enable ch0;     0:disable ch0;</comment>
        </bits>
      </reg>
      <reg name="med_ch0_base_addr_cfg" protect="rw">
        <comment>med_ch0_base_addr_cfg</comment>
        <bits access="rw" name="med_ch0_base_addr" pos="31:5" rst="0x0">
          <comment>the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000</comment>
        </bits>
      </reg>
      <reg name="med_ch0_addr_size_cfg" protect="rw">
        <comment>med_ch0_addr_size_cfg</comment>
        <bits access="rw" name="med_ch0_addr_size" pos="23:5" rst="0x0">
          <comment>the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF</comment>
        </bits>
      </reg>
      <reg name="med_ch0_read_addr_remap" protect="rw">
        <comment>med_ch0_read_addr_remap</comment>
        <bits access="rw" name="med_ch0_remap_read_addr" pos="31:5" rst="0x0">
          <comment>the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024</comment>
        </bits>
      </reg>
      <hole size="128"/>
      <reg name="med_ch1_work_cfg" protect="rw">
        <comment>med_ch1_work_cfg</comment>
        <bits access="rw" name="med_ch1_bypass_en" pos="4" rst="0x0">
          <comment>1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption</comment>
        </bits>
        <bits access="rw" name="med_ch1_enable" pos="0" rst="0x0">
          <comment>1:enable ch1;    0:disable ch1;</comment>
        </bits>
      </reg>
      <reg name="med_ch1_base_addr_cfg" protect="rw">
        <comment>med_ch1_base_addr_cfg</comment>
        <bits access="rw" name="med_ch1_base_addr" pos="31:5" rst="0x0">
          <comment>the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000</comment>
        </bits>
      </reg>
      <reg name="med_ch1_addr_size_cfg" protect="rw">
        <comment>med_ch1_addr_size_cfg</comment>
        <bits access="rw" name="med_ch1_addr_size" pos="23:5" rst="0x0">
          <comment>the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF</comment>
        </bits>
      </reg>
      <reg name="med_ch1_read_addr_remap" protect="rw">
        <comment>med_ch1_read_addr_remap</comment>
        <bits access="rw" name="med_ch1_remap_read_addr" pos="31:5" rst="0x0">
          <comment>the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024</comment>
        </bits>
      </reg>
      <hole size="128"/>
      <reg name="med_ch2_work_cfg" protect="rw">
        <comment>med_ch2_work_cfg</comment>
        <bits access="rw" name="med_ch2_bypass_en" pos="4" rst="0x0">
          <comment>1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption</comment>
        </bits>
        <bits access="rw" name="med_ch2_enable" pos="0" rst="0x0">
          <comment>1:enable ch2;    0:disable ch2;</comment>
        </bits>
      </reg>
      <reg name="med_ch2_base_addr_cfg" protect="rw">
        <comment>med_ch2_base_addr_cfg</comment>
        <bits access="rw" name="med_ch2_base_addr" pos="31:5" rst="0x0">
          <comment>the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000</comment>
        </bits>
      </reg>
      <reg name="med_ch2_addr_size_cfg" protect="rw">
        <comment>med_ch2_addr_size_cfg</comment>
        <bits access="rw" name="med_ch2_addr_size" pos="23:5" rst="0x0">
          <comment>the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF</comment>
        </bits>
      </reg>
      <reg name="med_ch2_read_addr_remap" protect="rw">
        <comment>med_ch2_read_addr_remap</comment>
        <bits access="rw" name="med_ch2_remap_read_addr" pos="31:5" rst="0x0">
          <comment>the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024</comment>
        </bits>
      </reg>
      <hole size="128"/>
      <reg name="med_ch3_work_cfg" protect="rw">
        <comment>med_ch3_work_cfg</comment>
        <bits access="rw" name="med_ch3_bypass_en" pos="4" rst="0x0">
          <comment>1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption</comment>
        </bits>
        <bits access="rw" name="med_ch3_enable" pos="0" rst="0x0">
          <comment>1:enable ch3;    0:disable ch3;</comment>
        </bits>
      </reg>
      <reg name="med_ch3_base_addr_cfg" protect="rw">
        <comment>med_ch3_base_addr_cfg</comment>
        <bits access="rw" name="med_ch3_base_addr" pos="31:5" rst="0x0">
          <comment>the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000</comment>
        </bits>
      </reg>
      <reg name="med_ch3_addr_size_cfg" protect="rw">
        <comment>med_ch3_addr_size_cfg</comment>
        <bits access="rw" name="med_ch3_addr_size" pos="23:5" rst="0x0">
          <comment>the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF</comment>
        </bits>
      </reg>
      <reg name="med_ch3_read_addr_remap" protect="rw">
        <comment>med_ch3_read_addr_remap</comment>
        <bits access="rw" name="med_ch3_remap_read_addr" pos="31:5" rst="0x0">
          <comment>the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024</comment>
        </bits>
      </reg>
      <hole size="1024"/>
      <reg name="med_write_addr_remap" protect="rw">
        <comment>med_write_addr_remap</comment>
        <bits access="rw" name="med_remap_write_addr" pos="31:5" rst="0x0">
          <comment>the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu write address is 0x1000_0024,then after med , then address is  is 0x2000_0024</comment>
        </bits>
      </reg>
      <reg name="med_write_base_addr_cfg" protect="rw">
        <comment>med_write_base_addr_cfg</comment>
        <bits access="rw" name="med_write_base_addr" pos="31:5" rst="0x0">
          <comment>the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000</comment>
        </bits>
      </reg>
      <reg name="med_write_addr_size_cfg" protect="rw">
        <comment>med_write_addr_size_cfg</comment>
        <bits access="rw" name="med_write_addr_size" pos="23:5" rst="0x0">
          <comment>the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="med_clr" protect="rw">
        <comment>med_clr</comment>
        <bits access="rc" name="med_write_cnt_clr" pos="5" rst="0x0">
          <comment>1:active,clear the 0x118 address bit31~bit12;</comment>
        </bits>
        <bits access="rc" name="med_simon_clr" pos="4" rst="0x0">
          <comment>1:active,clear the simon core</comment>
        </bits>
        <bits access="rc" name="med_write_ram_clr" pos="1" rst="0x0">
          <comment>1:active,clear the med inner write ram</comment>
        </bits>
        <bits access="rc" name="med_read_ram_clr" pos="0" rst="0x0">
          <comment>1:active,clear the med inner read ram</comment>
        </bits>
      </reg>
      <reg name="med_work_mode" protect="rw">
        <comment>med_work_mode</comment>
        <bits access="rw" name="med_clk_force_on" pos="16" rst="0x0">
          <comment>can force the med clk gate always on, then the clk  freerun</comment>
        </bits>
        <bits access="rw" name="med_write_bus_error_en" pos="10" rst="0x0">
          <comment>when the med send cmd to write flash data, and the slave happen bus error, then the med will back the slave bus error to master.</comment>
        </bits>
        <bits access="rw" name="med_read_bus_error_en" pos="9" rst="0x0">
          <comment>when the med send cmd to read flash data, and the slave happen bus error, then the med will back the slave bus error to master.</comment>
        </bits>
        <bits access="rw" name="med_bus_error_en" pos="8" rst="0x0">
          <comment>enable the med module ahb bus error,when the master access to med, and the access address is error, the med will generate the buss error to master.</comment>
        </bits>
        <bits access="rw" name="med_key_iv_sel" pos="0" rst="0x0">
          <comment>1:sel the key from efuse,                               0: key from soft ware</comment>
        </bits>
      </reg>
      <reg name="med_int_en" protect="rw">
        <comment>med_int_en</comment>
        <bits access="rw" name="med_addr_err_int_en" pos="6" rst="0x0">
          <comment>enable med ahb addr out of range all channel</comment>
        </bits>
        <bits access="rw" name="med_err_resp_int_en" pos="5" rst="0x0">
          <comment>enable med error response int</comment>
        </bits>
        <bits access="rw" name="med_ch3_dis_addr_vld_int_en" pos="4" rst="0x0">
          <comment>enable med channel3 addr error int</comment>
        </bits>
        <bits access="rw" name="med_ch2_dis_addr_vld_int_en" pos="3" rst="0x0">
          <comment>enable med channel2 addr error int</comment>
        </bits>
        <bits access="rw" name="med_ch1_dis_addr_vld_int_en" pos="2" rst="0x0">
          <comment>enable med channel1 addr error int</comment>
        </bits>
        <bits access="rw" name="med_ch0_dis_addr_vld_int_en" pos="1" rst="0x0">
          <comment>enable med channel0 addr error int</comment>
        </bits>
        <bits access="rw" name="med_wr_done_int_en" pos="0" rst="0x0">
          <comment>enable med write done int</comment>
        </bits>
      </reg>
      <reg name="med_int_raw" protect="rw">
        <comment>emd_int_raw</comment>
        <bits access="r" name="med_addr_err_int_raw" pos="6" rst="0x0">
          <comment>med ahb addr out of range all channel status</comment>
        </bits>
        <bits access="r" name="med_err_resp_int_raw" pos="5" rst="0x0">
          <comment>med error response int status</comment>
        </bits>
        <bits access="r" name="med_ch3_dis_addr_vld_int_raw" pos="4" rst="0x0">
          <comment>med channel3 addr error int status</comment>
        </bits>
        <bits access="r" name="med_ch2_dis_addr_vld_int_raw" pos="3" rst="0x0">
          <comment>med channel2 addr error int status</comment>
        </bits>
        <bits access="r" name="med_ch1_dis_addr_vld_int_raw" pos="2" rst="0x0">
          <comment>med channel1 addr error int status</comment>
        </bits>
        <bits access="r" name="med_ch0_dis_addr_vld_int_raw" pos="1" rst="0x0">
          <comment>med channel0 addr error int status</comment>
        </bits>
        <bits access="r" name="med_wr_done_int_raw" pos="0" rst="0x0">
          <comment>med write done int status</comment>
        </bits>
      </reg>
      <reg name="med_int_clear" protect="rw">
        <comment>med_int_clear</comment>
        <bits access="rc" name="med_addr_err_int_clr" pos="6" rst="0x0">
          <comment>clear med ahb addr out of range all channel status</comment>
        </bits>
        <bits access="rc" name="med_err_resp_int_clr" pos="5" rst="0x0">
          <comment>clear med error response int</comment>
        </bits>
        <bits access="rc" name="med_ch3_dis_addr_vld_int_clr" pos="4" rst="0x0">
          <comment>clear med channel3 addr error int</comment>
        </bits>
        <bits access="rc" name="med_ch2_dis_addr_vld_int_clr" pos="3" rst="0x0">
          <comment>clear med channel2 addr error int</comment>
        </bits>
        <bits access="rc" name="med_ch1_dis_addr_vld_int_clr" pos="2" rst="0x0">
          <comment>clear med channel1 addr error int</comment>
        </bits>
        <bits access="rc" name="med_ch0_dis_addr_vld_int_clr" pos="1" rst="0x0">
          <comment>clear med channel0 addr error int</comment>
        </bits>
        <bits access="rc" name="med_wr_done_int_clr" pos="0" rst="0x0">
          <comment>clear med  write done int</comment>
        </bits>
      </reg>
      <reg name="med_error_addr" protect="rw">
        <comment>med_error_addr</comment>
      </reg>
      <reg name="med_status0" protect="rw">
        <comment>med_status0</comment>
        <bits access="r" name="med_write_word_cnt" pos="31:12" rst="0x0"/>
        <bits access="r" name="med_wr_busy" pos="5" rst="0x0"/>
        <bits access="r" name="med_rd_busy" pos="4" rst="0x0"/>
        <bits access="r" name="med_work_busy" pos="3" rst="0x0"/>
        <bits access="r" name="med_mster_ahb_hready" pos="2" rst="0x1"/>
        <bits access="r" name="med_mster_slv_hready" pos="1" rst="0x1"/>
        <bits access="r" name="med_simon_odata_ready" pos="0" rst="0x1"/>
      </reg>
      <reg name="med_status1" protect="rw">
        <comment>med_status1</comment>
      </reg>
      <reg name="med_status2" protect="rw">
        <comment>med_status2</comment>
      </reg>
      <reg name="med_status3" protect="rw">
        <comment>med_status3</comment>
      </reg>
      <reg name="med_soft_key" protect="rw">
        <comment>med_soft_key</comment>
      </reg>
    </module>
    <instance address="0x04000000" name="MED" type="MED"/>
  </archive>
  <archive relative="ap_spi.xml">
    <module category="System" name="AP_SPI">
      <reg name="spi_txd" protect="rw">
        <comment>Transmit word or Receive word Write data to this address initiates a character transmission through TX FIFO
Read this address retrieve data from RX fifo</comment>
      </reg>
      <reg name="spi_clkd" protect="rw">
        <comment>Clock divisor  Clock divisor bit 0 to 15</comment>
        <bits access="rw" name="spi_clkd" pos="15:0" rst="0x3">
          <comment>Specify the clock ratio between spi_sck and clk_spi.
If clk_spi runs at 48 MHz, and spi_sck runs at 12MHz, SPI_CLKD should be 1,
spi_sck = clk_spi/2(n+1).
If IS_FST bit is assert, the valid SPI_CLKD is 0, 1, 2 and 3.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl0" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="sync_3wrd_pol" pos="15" rst="0x0">
          <comment>Sync_polarity, positive or negative pulse for SPI or 3-wire mode ,read command polarity</comment>
        </bits>
        <bits access="rw" name="sync_md" pos="14" rst="0x0">
          <comment>“1” : sync mode</comment>
        </bits>
        <bits access="rw" name="is_sck_rev" pos="13" rst="0x0">
          <comment>“1” : spi_sck reverse</comment>
        </bits>
        <bits access="rw" name="spi_csn_pre" pos="11:8" rst="0xf">
          <comment>1 bit chip select.
“0”: cs0 is valid
“1”: cs0 is invalid</comment>
        </bits>
        <bits access="rw" name="lsb" pos="7" rst="0x0">
          <comment>In default, The input data is shifted high order first into the chip; the output data is shifted out high order first from the Most Significant Bit (MSB) on SO. When this bit is set, the data will be shift out or in from the LSB</comment>
        </bits>
        <bits access="rw" name="chnl_len" pos="6:2" rst="0x0">
          <comment>Transmit data bit number.
“0” : 32 bits per word
“1” : 1 bits per word
…
“31”: 31 bits per word</comment>
        </bits>
        <bits access="rw" name="ng_tx" pos="1" rst="0x1">
          <comment>“1” enable TX data shift out at clock neg-edge</comment>
        </bits>
        <bits access="rw" name="ng_rx" pos="0" rst="0x0">
          <comment>“1” enable RX data shift in at clock neg-edge</comment>
        </bits>
      </reg>
      <reg name="spi_ctl1" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="do_hold_en" pos="15:14" rst="0x0">
          <comment>“00” : default(follow before version)
“01” : spi do stay 0 value when in idle
“10” : spi do stay 1 value when in idle
“11” : spi do stay last-bit value when in idle</comment>
        </bits>
        <bits access="rw" name="is_txmd" pos="13" rst="0x1">
          <comment>1:is tx mode 0:not tx mode</comment>
        </bits>
        <bits access="rw" name="is_rxmd" pos="12" rst="0x1">
          <comment>1:is rx mode 0:not rx mode</comment>
        </bits>
        <bits access="rw" name="sync_csn_sel" pos="11:8" rst="0x0">
          <comment>S8 CD or SYNC signal maps to csn number
“0x0001” selects csn0 as cd signal
“0x0010” selects csn1 as cd signal
In SPI_HS it must be 0x0000 and disable sync and s8 mode</comment>
        </bits>
        <bits access="rw" name="s8_md" pos="7" rst="0x0">
          <comment>“1” : enable S8 mode</comment>
        </bits>
        <bits access="rw" name="cs_h_md" pos="6" rst="0x0">
          <comment>3-wire Melody timing 1, csn high mode enable</comment>
        </bits>
        <bits access="rw" name="s3w_md" pos="5" rst="0x0">
          <comment>“1” : enable 3-wire mode</comment>
        </bits>
        <bits access="rw" name="s3w_pos" pos="4:0" rst="0x0">
          <comment>3-wire mode, w/r control position
or the sync pulse position(the pulse will
locates on top of bit N)</comment>
        </bits>
      </reg>
      <reg name="spi_ctl2" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="dma_req_seq_sel" pos="10" rst="0x0">
          <comment>0:DMA TX and RX REQ independent
1:DMA TX REQ are depended on RX REQ status</comment>
        </bits>
        <bits access="rw" name="tx_dma_sel" pos="9" rst="0x0">
          <comment>0: tx_dma_req keep 1 until receiving the tx_dma_ack
1: tx_dma_req is “1” when tx_empty is “1”,else “0”</comment>
        </bits>
        <bits access="rw" name="rx_dma_sel" pos="8" rst="0x0">
          <comment>0: rx_dma_req keep 1 until receiving the rx_dma_ack
1: rx_dma_req is “1” when rx_full is “1”,else “0”</comment>
        </bits>
        <bits access="rw" name="rx_only_nhd" pos="7" rst="0x0">
          <comment>“0” : working on only receive
mode, when rxf_realfull is high, SPI will be held until rxf_realfull is low
“1” : no holding</comment>
        </bits>
        <bits access="rw" name="dma_en" pos="6" rst="0x0">
          <comment>“1” enable DMA mode</comment>
        </bits>
        <bits access="rw" name="is_slvd" pos="5" rst="0x0">
          <comment>“0” : master
“1” : slave, only support microplus mode</comment>
        </bits>
        <bits access="rw" name="s3w_rd_strt" pos="4:0" rst="0x0">
          <comment>Read data start bit, used for 3 wire mode and 3 wire 9bit RW mode.
The 3 wire 9bit RW mode reuse this config registers, it indicated read data start position.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl3" protect="rw">
        <comment>RXF watermark  SPI RX FIFO FULL/EMPTY watermark</comment>
        <bits access="rw" name="rxf_empty_thrhld" pos="12:8" rst="0x10">
          <comment>Receive FIFO data empty threshold. Relative with rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="rw" name="rxf_full_thrhld" pos="4:0" rst="0x10">
          <comment>Receive FIFO data full threshold. Relative with rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_ctl4" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="rx_only_do" pos="15" rst="0x0">
          <comment>working in only receive mode,
“0” : SPI send all 0 to slave
“1” : SPI send all 1 to slave</comment>
        </bits>
        <bits access="rw" name="is_fst" pos="14" rst="0x0">
          <comment>“0” : normal mode
“1” : fast mode
Both for matser mode and slave mode,and in master mode SPI_SCK must be quicker  than 1/8 spi_clk</comment>
        </bits>
        <bits access="rw" name="phs_dly" pos="13:12" rst="0x0">
          <comment>Phase delay. Relate to fast mode.
When in normal mode, this bit is not used . Only used for slave mode</comment>
        </bits>
        <bits access="rw" name="sync_clkmask_en" pos="11" rst="0x0">
          <comment>“1” Mask out the first clock pulse in SPI mode</comment>
        </bits>
        <bits access="rw" name="sync_half" pos="10" rst="0x0">
          <comment>Sync_half, sync width is half  spi_sck cycle</comment>
        </bits>
        <bits access="rw" name="is_rx_only" pos="9" rst="0x0">
          <comment>“1”:receive data only.
The bit should be written at last.
Only used for master mode</comment>
        </bits>
        <bits access="rw" name="block_num" pos="8:0" rst="0x0">
          <comment>Number of data words ready to receive in “receive only” mode. Only used for master mode.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl5" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="itvl_num_sam" pos="15:0" rst="0x0">
          <comment>For master, transmit data interval, programmable n from 0 to 65535, delay is (n*4+3) clock cycle.
For slave, max receive data interval. If the slave has not sampled the edge of spi_clk in the interval(n*4+3), slave will stop the receive process and send timout interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_int_en" protect="rw">
        <comment>Interrupt enable  SPI interrupt enable register</comment>
        <bits access="rw" name="rx_end_int_en" pos="9" rst="0x0">
          <comment>Rx end interrupt enable</comment>
        </bits>
        <bits access="rw" name="tx_end_int_en" pos="8" rst="0x0">
          <comment>Tx end interrupt enable</comment>
        </bits>
        <bits access="rw" name="txf_w_empty_int_en" pos="7" rst="0x0">
          <comment>txf_empty interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_r_full_int_en" pos="6" rst="0x0">
          <comment>Rxf_full interrupt enable</comment>
        </bits>
        <bits access="rw" name="time_out_int_en" pos="5" rst="0x0">
          <comment>Slave mode timeout interrupt enable</comment>
        </bits>
        <bits access="rw" name="rx_ovf_int_en" pos="4" rst="0x0">
          <comment>Rx_overrun_reg interrupt enable</comment>
        </bits>
        <bits access="rw" name="txf_empty_en" pos="3" rst="0x0"/>
        <bits access="rw" name="txf_full_int_en" pos="2" rst="0x0">
          <comment>Tx_fifo_full interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_empty_int_en" pos="1" rst="0x0">
          <comment>Rx_fifo_empty interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_full_int_en" pos="0" rst="0x0">
          <comment>Rx_fifo_full interrupt enable</comment>
        </bits>
      </reg>
      <reg name="spi_int_clr" protect="rw">
        <comment>Interrupt clear SPI interrupt clear register</comment>
        <bits access="w" name="rx_end_int_clr" pos="9" rst="0x0">
          <comment>Rx data end interrupt clear</comment>
        </bits>
        <bits access="w" name="tx_end_int_clr" pos="8" rst="0x0">
          <comment>Tx data end interrupt clear</comment>
        </bits>
        <bits access="w" name="time_out_int_clr" pos="5" rst="0x0">
          <comment>Write “1” clear slave mode timeout interrupt</comment>
        </bits>
        <bits access="w" name="rx_ovf_int_clr" pos="4" rst="0x0">
          <comment>Write “1” clear Rx_overrun_reg interrupt</comment>
        </bits>
        <bits access="w" name="txf_empty_int_clr" pos="3" rst="0x0">
          <comment>Write “1” clear Tx_fifo_empty interrupt</comment>
        </bits>
        <bits access="w" name="txf_full_int_clr" pos="2" rst="0x0">
          <comment>Write “1” clear Tx_fifo_full interrupt</comment>
        </bits>
        <bits access="w" name="rxf_empty_int_clr" pos="1" rst="0x0">
          <comment>Write “1” clear Rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="w" name="rxf_full_int_clr" pos="0" rst="0x0">
          <comment>Write “1” clear Rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_int_raw_sts" protect="rw">
        <comment>Raw status  SPI interrupt raw status</comment>
        <bits access="r" name="rx_end_irq" pos="9" rst="0x0">
          <comment>Raw rx data end interrupt, this bit is set when spi controller received RX_DATA_LEN data from slave.</comment>
        </bits>
        <bits access="r" name="tx_end_irq" pos="8" rst="0x0">
          <comment>Raw tx data end interrupt,this bit is set when spi controller send TX_DATA_LEN data.</comment>
        </bits>
        <bits access="r" name="txf_empty_w" pos="7" rst="0x1">
          <comment>Raw txf_empty interrupt, This bit is set when the number of tx fifo data byte is less than the tx empty watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_full_r" pos="6" rst="0x0">
          <comment>Raw rxf_full interrupt.This bit is set when the number of rx fifo data byte is larger than the rx full watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="time_out_raw_sts" pos="5" rst="0x0">
          <comment>Raw slave mode time out interrupt</comment>
        </bits>
        <bits access="r" name="rx_ovf_raw_sts" pos="4" rst="0x0">
          <comment>Raw Rx_overrun_reg interrupt</comment>
        </bits>
        <bits access="r" name="tx_fifo_empty_w" pos="3" rst="0x1">
          <comment>Txf_empty_w(for debug)</comment>
        </bits>
        <bits access="r" name="txf_full_raw_sts" pos="2" rst="0x0">
          <comment>Raw Tx_fifo_full interrupt</comment>
        </bits>
        <bits access="r" name="rxf_empty_raw_sts" pos="1" rst="0x1">
          <comment>Raw rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="r" name="rx_full_raw_sts" pos="0" rst="0x0">
          <comment>Rxf_full_r(for debug)</comment>
        </bits>
      </reg>
      <reg name="spi_int_mask_sts" protect="rw">
        <comment>Mask status  SPI interrupt mask status</comment>
        <bits access="r" name="rx_end_irq_mask_sts" pos="9" rst="0x0">
          <comment>Raw rx data end interrupt, this bit is set when spi controller received RX_DATA_LEN data from slave.</comment>
        </bits>
        <bits access="r" name="tx_end_irq_mask_sts" pos="8" rst="0x0">
          <comment>Raw tx data end interrupt,this bit is set when spi controller send TX_DATA_LEN data.</comment>
        </bits>
        <bits access="r" name="txf_empty_mask_sts" pos="7" rst="0x1">
          <comment>Txf_empty interrupt mask status.</comment>
        </bits>
        <bits access="r" name="rxf_full_mask_sts" pos="6" rst="0x0">
          <comment>Rxf_full interrupt mask status.</comment>
        </bits>
        <bits access="r" name="time_out_mask_sts" pos="5" rst="0x0">
          <comment>Slave mode time out interrupt mask status</comment>
        </bits>
        <bits access="r" name="rx_ovf_mask_sts" pos="4" rst="0x0">
          <comment>Rx_overrun_reg interrupt mask status</comment>
        </bits>
        <bits access="r" name="txf_full_mask_sts" pos="2" rst="0x0">
          <comment>Tx_fifo_full interrupt mask status</comment>
        </bits>
        <bits access="r" name="rxf_empty_mask_sts" pos="1" rst="0x1">
          <comment>Rx_fifo_empty interrupt mask status</comment>
        </bits>
      </reg>
      <reg name="spi_sts1" protect="rw">
        <comment>RXF address  SPI RX FIFO write address and read address</comment>
        <bits access="r" name="rxf_waddr" pos="12:8" rst="0x0">
          <comment>RX FIFO write address</comment>
        </bits>
        <bits access="r" name="rxf_raddr" pos="4:0" rst="0x0">
          <comment>RX FIFO read address</comment>
        </bits>
      </reg>
      <reg name="spi_sts2" protect="rw">
        <comment>latch SPI status  SPI status register</comment>
        <bits access="r" name="spi_cs" pos="12" rst="0x0">
          <comment>Spi_cs(for debug)</comment>
        </bits>
        <bits access="r" name="spi_sck" pos="11" rst="0x0">
          <comment>Spi_sck(for debug)</comment>
        </bits>
        <bits access="r" name="spi_txd" pos="10" rst="0x0">
          <comment>Spi_txd(for debug)</comment>
        </bits>
        <bits access="r" name="spi_rxd" pos="9" rst="0x0">
          <comment>Spi_rxd(for debug)</comment>
        </bits>
        <bits access="r" name="busy" pos="8" rst="0x0">
          <comment>“1” transmit process
“0” idle state</comment>
        </bits>
        <bits access="r" name="txf_real_empty" pos="7" rst="0x1">
          <comment>TX FIFO has no data</comment>
        </bits>
        <bits access="r" name="txf_real_full" pos="6" rst="0x0">
          <comment>TX FIFO is real full. (not relates to TX full threshold)</comment>
        </bits>
        <bits access="r" name="rxf_real_empty" pos="5" rst="0x1">
          <comment>RX FIFO has no data</comment>
        </bits>
        <bits access="r" name="rxf_real_full" pos="4" rst="0x0">
          <comment>RX FIFO is real full. (not relates to TX full threshold)</comment>
        </bits>
        <bits access="r" name="txf_empty" pos="3" rst="0x1">
          <comment>This bit is set when the number of TX FIFO data byte is less than the TX empty interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="txf_full" pos="2" rst="0x0">
          <comment>This bit is set when the number of TX FIFO data byte is larger than the TX full interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_empty" pos="1" rst="0x1">
          <comment>This bit is set when the number of RX FIFO data byte is less than the RX empty interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_full" pos="0" rst="0x0">
          <comment>This bit is set when the number of RX FIFO data byte is larger than the RX full interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
      </reg>
      <reg name="spi_dspwait" protect="rw">
        <comment>DSP Register This register is used for DSP control</comment>
        <bits access="rw" name="tx_data_swt" pos="7:6" rst="0x0">
          <comment>Write data switch.
2’b0: WDATA=PDATA;
2’b1: WDATA={PDATA[7:0], PDATA[15:8], PDATA[23:16], PDATA[31:24]};
2’b2: WDATA={PDATA[15:0],PDATA[31:16]};
2’b3: WDATA={PDATA[23:16], PDATA[31:24], PDATA[7:0], PDATA[15:8]};</comment>
        </bits>
        <bits access="rw" name="rx_data_swt" pos="5:4" rst="0x0">
          <comment>Read data switch.
2’b0: RDATA=PDATA;
2’b1: RDATA={PDATA[7:0], PDATA[15:8], PDATA[23:16], PDATA[31:24]};
2’b2: RDATA={PDATA[15:0],PDATA[31:16]};</comment>
        </bits>
        <bits access="rw" name="spi_dspwait" pos="3:0" rst="0x1">
          <comment>This register is used for DSP control</comment>
        </bits>
      </reg>
      <reg name="spi_sts3" protect="rw">
        <comment>RX conunter monitor This register is used to observe the status</comment>
        <bits access="r" name="rx_cnt" pos="8:0" rst="0x0">
          <comment>working in only receive mode
as master</comment>
        </bits>
      </reg>
      <reg name="spi_ctl6" protect="rw">
        <comment>TXF configuration This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="txf_empty_thrhld" pos="12:8" rst="0x10">
          <comment>TX FIFO data empty threshold. Relative with rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="rw" name="txf_full_thrhld" pos="4:0" rst="0x10">
          <comment>TX FIFO data full threshold. Relative with rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_sts4" protect="rw">
        <comment>TXF address This register is used to configuration of the SPI interface</comment>
        <bits access="r" name="txf_waddr" pos="12:8" rst="0x0">
          <comment>TX FIFO write address</comment>
        </bits>
        <bits access="r" name="txf_raddr" pos="4:0" rst="0x0">
          <comment>TX FIFO read address</comment>
        </bits>
      </reg>
      <reg name="spi_fifo_rst" protect="rw">
        <comment>FIFO reset configuration Used to reset TX/RX FIFO</comment>
        <bits access="rw" name="spi_fifo_rst" pos="0" rst="0x0">
          <comment>“1” : reset all FIFOs. FIFO address will changed to 0</comment>
        </bits>
      </reg>
      <reg name="spi_ctl7" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="data_line2_en" pos="15" rst="0x0">
          <comment>1: two data line function enable
0: two data line function disable</comment>
        </bits>
        <bits access="rw" name="rgb565_en" pos="14" rst="0x0">
          <comment>1: enable RGB565 data format
0: disable RGB565 data format</comment>
        </bits>
        <bits access="rw" name="rgb666_en" pos="13" rst="0x0">
          <comment>1: enable RGB666 data format
0: disable RGB666 data format</comment>
        </bits>
        <bits access="rw" name="rgb888_en" pos="12" rst="0x0">
          <comment>1: enable RGB888 data format
0: disable RGB888 data format</comment>
        </bits>
        <bits access="rw" name="spi_slv_sel" pos="11" rst="0x0">
          <comment>1: SPI slave in Low speed mode
0: SPI slave in High speed mode</comment>
        </bits>
        <bits access="rw" name="spi_slv_en" pos="10" rst="0x0">
          <comment>Used when SPI slave in High speed mode.
1: enable spi slave rtx
0: disable spi slave rtx</comment>
        </bits>
        <bits access="rw" name="data_in_mode" pos="9" rst="0x0">
          <comment>Use for 3 wire 9bit RW mode and 4 wire 8bit RW mode (SPI_MODE=5 or SPI_MODE=6).
0: Data in and data out of SPI share one IO (SDA).
1: Data in and data out of SPI use separated IO (SDI, SDO).</comment>
        </bits>
        <bits access="rw" name="spi_rx_hld_en" pos="8" rst="0x0">
          <comment>1: enable ahb2apb bridge read hold when rx fifo empty
0: disable ahb2apb bridge read hold</comment>
        </bits>
        <bits access="rw" name="spi_tx_hld_en" pos="7" rst="0x0">
          <comment>1: enable ahb2apb bridge write hold when tx fifo full
0: disable ahb2apb bridge write hold</comment>
        </bits>
        <bits access="rw" name="tx_cmd_set" pos="6" rst="0x0">
          <comment>1: select fmark as the dma request
0: select software dma request</comment>
        </bits>
        <bits access="rw" name="spi_mode" pos="5:3" rst="0x0">
          <comment>Used for master only
0: SPI_MODE disable
1: 3 wire 9 bit, cd bit, SDI/SDO share  one IO
2: 3 wire 9 bit, cd bit, SDI, SDO
3: 4 wire 8 bit, cd pin, SDI/SDO share one IO
4: 4 wire 8 bit, cd pin, SDI, SDO
5: 3 wire 9bit RW mode, 9 bit command and 8 bit read data, cd bit is enable. Design for LCD driver.
6: 4 wire 8bit RW mode, 8bit command and 8 bit read data. Use CD PAD indicates command or data. Design for LCD driver.</comment>
        </bits>
        <bits access="rw" name="csn_i_sel" pos="2:1" rst="0x0">
          <comment>CSN select control:
0: CSN 0
1: CSN 1
2: CSN 2
3: CSN 3</comment>
        </bits>
        <bits access="rw" name="csn_ie_ctl" pos="0" rst="0x0">
          <comment>CSN IE output set(only slave)
0: not support csn input
1: support csn intput</comment>
        </bits>
      </reg>
      <reg name="spi_sts5" protect="rw">
        <comment>Statue Register Used to observe csn error</comment>
        <bits access="r" name="csn_in_err_sync2" pos="4" rst="0x0">
          <comment>1: indicates csn occurring a exception</comment>
        </bits>
        <bits access="r" name="csn_in_sync2" pos="0" rst="0x0">
          <comment>csn for slave</comment>
        </bits>
      </reg>
      <reg name="spi_ctl8" protect="rw">
        <comment>Configure Register Used for configure SPI interface</comment>
        <bits access="rw" name="spi_cd_bit" pos="15" rst="0x0">
          <comment>Spi tx cd bit:
0: indicates command
1: indicates data</comment>
        </bits>
        <bits access="rw" name="spi_cd_bit2" pos="14" rst="0x0">
          <comment>Use for 4 wire 8bit RW mode. Determine CD PAD high or low in read data phase.</comment>
        </bits>
        <bits access="rw" name="cd_data2_sel" pos="13" rst="0x0">
          <comment>Second data line of two data line function select bit:
0: CD PAD as second data line
1: DI PAD as second data line</comment>
        </bits>
        <bits access="rw" name="rgb_pix_mode" pos="12" rst="0x0">
          <comment>Two data line RGB data format mode:
0: 1pixel mode
1: 2/3 pixel mode</comment>
        </bits>
        <bits access="rw" name="data_line2_sw" pos="11" rst="0x0">
          <comment>2-data-line switch. Only valid in 2-data-line mode(DATA_LINE2_EN set to 1):
0: use spi_do as first data line,spi_di as second data line.
1: use spi_di as first data line, spi_do as second data line.</comment>
        </bits>
        <bits access="rw" name="spi_tx_dumy_len" pos="9:4" rst="0x0">
          <comment>Spi tx dummy clock length</comment>
        </bits>
        <bits access="rw" name="spi_tx_data_len_h" pos="3:0" rst="0x0">
          <comment>Indicates tx data length from tx fifo, High 4 bits of spi tx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl9" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="spi_tx_data_len_l" pos="15:0" rst="0x0">
          <comment>Indicates: spi tx data length from tx fifo, Low 16bit of tx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl10" protect="rw">
        <comment>Configure register SPI status register</comment>
        <bits access="rw" name="spi_rx_dumy_len" pos="9:4" rst="0x0">
          <comment>Spi rx dummy clock length</comment>
        </bits>
        <bits access="rw" name="spi_rx_data_len_h" pos="3:0" rst="0x0">
          <comment>Indicates receives data length from slave, high 4 bits of spi rx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl11" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="spi_rx_data_len_l" pos="15:0" rst="0x0">
          <comment>Indicates: spi receives data length from slave, Low 16bit of rx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl12" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="sw_tx_req" pos="1" rst="0x0">
          <comment>Software TX data request, for write LCD</comment>
        </bits>
        <bits access="rw" name="sw_rx_req" pos="0" rst="0x0">
          <comment>Software RX data request, for read LCD</comment>
        </bits>
      </reg>
      <reg name="spi_sts6" protect="rw">
        <comment>Statue Register Used to observe TX data counter</comment>
        <bits access="r" name="tx_data_cnt" pos="15:0" rst="0x0">
          <comment>Tx data cnt</comment>
        </bits>
      </reg>
      <reg name="spi_sts7" protect="rw">
        <comment>Statue Register Used to observe TX statue</comment>
        <bits access="r" name="tx_dummy_cnt" pos="15:10" rst="0x0">
          <comment>tx dummy counter</comment>
        </bits>
        <bits access="r" name="tx_data_cnt" pos="3:0" rst="0x0">
          <comment>tx data counter</comment>
        </bits>
      </reg>
      <reg name="spi_sts8" protect="rw">
        <comment>Statue Register Used to observe RX data counter</comment>
        <bits access="r" name="rx_data_cnt" pos="15:0" rst="0x0">
          <comment>Rx data cnt</comment>
        </bits>
      </reg>
      <reg name="spi_sts9" protect="rw">
        <comment>Statue Register Used to observe RX statue</comment>
        <bits access="r" name="rx_dummy_cnt" pos="15:10" rst="0x0">
          <comment>rx dummy counter</comment>
        </bits>
        <bits access="r" name="rx_data_cnt" pos="3:0" rst="0x0">
          <comment>rx data counter</comment>
        </bits>
      </reg>
      <reg name="spi_version" protect="rw">
        <comment>Statue Register Used to observe spi version</comment>
        <bits access="rw" name="spi_version" pos="15:0" rst="0x205">
          <comment>Spi version</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04008000" name="AP_SPI" type="AP_SPI"/>
  </archive>
  <archive relative="wlan.xml">
    <module category="System" name="WLAN">
      <hole size="32"/>
      <reg name="bank_addr" protect="rw">
        <comment/>
      </reg>
      <reg name="offset_addr" protect="rw">
        <comment/>
      </reg>
      <reg name="regwdata" protect="rw">
        <comment/>
      </reg>
      <reg name="regrdata" protect="rw">
        <comment/>
      </reg>
      <reg name="protocol_version" protect="rw">
        <comment/>
        <bits access="r" name="protocol_version" pos="1:0" rst="0x0">
          <comment>protocol_version</comment>
        </bits>
      </reg>
      <reg name="type" protect="rw">
        <comment/>
        <bits access="r" name="type" pos="1:0" rst="0x0">
          <comment>Protocol Type</comment>
        </bits>
      </reg>
      <reg name="subtype" protect="rw">
        <comment/>
        <bits access="r" name="subtype" pos="3:0" rst="0x0">
          <comment>Protocol Subtype</comment>
        </bits>
      </reg>
      <reg name="desaddr_l" protect="rw">
        <comment/>
      </reg>
      <reg name="desaddr_h" protect="rw">
        <comment/>
        <bits access="r" name="desaddr_h" pos="15:0" rst="0x0">
          <comment>Beacon Destination address high</comment>
        </bits>
      </reg>
      <reg name="srcaddr_l" protect="rw">
        <comment/>
      </reg>
      <reg name="srcaddr_h" protect="rw">
        <comment/>
        <bits access="r" name="srcaddr_h" pos="15:0" rst="0x0">
          <comment>Beacon Source address high</comment>
        </bits>
      </reg>
      <reg name="bssidaddr_l" protect="rw">
        <comment/>
      </reg>
      <reg name="bssidaddr_h" protect="rw">
        <comment/>
        <bits access="r" name="bssidaddr_h" pos="15:0" rst="0x0">
          <comment>BSSID address high</comment>
        </bits>
      </reg>
      <reg name="seqcontl" protect="rw">
        <comment/>
        <bits access="r" name="seqcontl" pos="15:0" rst="0x0">
          <comment>Beacon sequence control</comment>
        </bits>
      </reg>
      <reg name="rssival" protect="rw">
        <comment/>
        <bits access="r" name="rssival" pos="7:0" rst="0x0">
          <comment>Wlan rssi value</comment>
        </bits>
      </reg>
      <hole size="512"/>
      <reg name="apb_config" protect="rw">
        <comment/>
        <bits access="rw" name="phyrxenn" pos="16" rst="0x1">
          <comment>RX mode enable signal,0:enable,1:disable</comment>
        </bits>
        <bits access="rw" name="type" pos="13:12" rst="0x0">
          <comment>beacon type,should be 00</comment>
        </bits>
        <bits access="rw" name="subtype" pos="11:8" rst="0x8">
          <comment>beacon type,should be 1000</comment>
        </bits>
        <bits access="rw" name="apb_hold" pos="1" rst="0x1">
          <comment>hold enable from apb,0:disable,1:enable,wlan interrupt can only be cleared by software when this bit set 1 and the walue of registers is kept until the interrupt is cleared</comment>
        </bits>
        <bits access="rw" name="apb_clear" pos="0" rst="0x0">
          <comment>Wlan rssi value</comment>
        </bits>
      </reg>
      <reg name="datardyinterrupt" protect="rw">
        <comment/>
        <bits access="r" name="datardyinterrupt" pos="0" rst="0x0">
          <comment>data receive ready interrupt</comment>
        </bits>
      </reg>
      <hole size="288"/>
      <reg name="framectrl" protect="rw">
        <comment/>
        <bits access="r" name="framectrl" pos="7:0" rst="0x0">
          <comment>Beacon frame control</comment>
        </bits>
      </reg>
      <reg name="duration" protect="rw">
        <comment/>
        <bits access="r" name="duration" pos="15:0" rst="0x0">
          <comment>Beacon duratin</comment>
        </bits>
      </reg>
      <reg name="ht_ctrl" protect="rw">
        <comment/>
      </reg>
      <reg name="tstamp_l" protect="rw">
        <comment/>
      </reg>
      <reg name="tstamp_h" protect="rw">
        <comment/>
      </reg>
      <reg name="bcnintvl" protect="rw">
        <comment/>
        <bits access="r" name="bcnintvl" pos="15:0" rst="0x0">
          <comment>Beacon interval</comment>
        </bits>
      </reg>
      <reg name="capinfo" protect="rw">
        <comment/>
        <bits access="r" name="capinfo" pos="15:0" rst="0x0">
          <comment>Beacon Capbility information</comment>
        </bits>
      </reg>
      <reg name="elmtid" protect="rw">
        <comment/>
        <bits access="r" name="elmtid" pos="7:0" rst="0x0">
          <comment>Beacon SSID Elment ID</comment>
        </bits>
      </reg>
      <reg name="ssidlen" protect="rw">
        <comment/>
        <bits access="r" name="ssidlen" pos="7:0" rst="0x0">
          <comment>Beacon SSID length</comment>
        </bits>
      </reg>
      <reg name="ssidbyte1" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte2" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte3" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte4" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte5" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte6" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte7" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte8" protect="rw">
        <comment/>
      </reg>
      <reg name="out_fcsval" protect="rw">
        <comment/>
      </reg>
    </module>
    <instance address="0x14008000" name="WLAN" type="WLAN"/>
  </archive>
  <archive relative="cp_sysram_patch.xml">
    <module category="System" name="CP_SYSRAM_PATCH">
      <reg name="patch00" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid00" pos="28" rst="0x0">
          <comment>patch_addrs00地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs00" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs00进行读写时转换到RAM的固定地址中（0x10100000-0x1010000f）</comment>
        </bits>
      </reg>
      <reg name="patch01" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid01" pos="28" rst="0x0">
          <comment>patch_addrs01地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs01" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs01进行读写时转换到RAM的固定地址中（0x10100010-0x1010001f）</comment>
        </bits>
      </reg>
      <reg name="patch02" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid02" pos="28" rst="0x0">
          <comment>patch_addrs02地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs02" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs02进行读写时转换到RAM的固定地址中（0x10100020-0x1010002f）</comment>
        </bits>
      </reg>
      <reg name="patch03" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid03" pos="28" rst="0x0">
          <comment>patch_addrs03地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs03" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs03进行读写时转换到RAM的固定地址中（0x10100030-0x1010003f）</comment>
        </bits>
      </reg>
      <reg name="patch04" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid04" pos="28" rst="0x0">
          <comment>patch_addrs04地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs04" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs04进行读写时转换到RAM的固定地址中（0x10100040-0x1010004f）</comment>
        </bits>
      </reg>
      <reg name="patch05" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid05" pos="28" rst="0x0">
          <comment>patch_addrs05地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs05" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs05进行读写时转换到RAM的固定地址中（0x10100050-0x1010005f）</comment>
        </bits>
      </reg>
      <reg name="patch06" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid06" pos="28" rst="0x0">
          <comment>patch_addrs06地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs06" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs06进行读写时转换到RAM的固定地址中（0x10100060-0x1010006f）</comment>
        </bits>
      </reg>
      <reg name="patch07" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid07" pos="28" rst="0x0">
          <comment>patch_addrs07地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs07" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs07进行读写时转换到RAM的固定地址中（0x10100070-0x1010007f）</comment>
        </bits>
      </reg>
      <reg name="patch08" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid08" pos="28" rst="0x0">
          <comment>patch_addrs08地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs08" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs08进行读写时转换到RAM的固定地址中（0x10100080-0x1010008f）</comment>
        </bits>
      </reg>
      <reg name="patch09" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid09" pos="28" rst="0x0">
          <comment>patch_addrs09地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs09" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs09进行读写时转换到RAM的固定地址中（0x10100090-0x1010009f）</comment>
        </bits>
      </reg>
      <reg name="patch10" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid10" pos="28" rst="0x0">
          <comment>patch_addrs10地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs10" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs10进行读写时转换到RAM的固定地址中（0x101000a0-0x101000af）</comment>
        </bits>
      </reg>
      <reg name="patch11" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid11" pos="28" rst="0x0">
          <comment>patch_addrs11地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs11" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs11进行读写时转换到RAM的固定地址中（0x101000b0-0x101000bf）</comment>
        </bits>
      </reg>
      <reg name="patch12" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid12" pos="28" rst="0x0">
          <comment>patch_addrs12地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs12" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs12进行读写时转换到RAM的固定地址中（0x101000c0-0x101000cf）</comment>
        </bits>
      </reg>
      <reg name="patch13" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid13" pos="28" rst="0x0">
          <comment>patch_addrs13地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs13" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs13进行读写时转换到RAM的固定地址中（0x101000d0-0x101000df）</comment>
        </bits>
      </reg>
      <reg name="patch14" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid14" pos="28" rst="0x0">
          <comment>patch_addrs14地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs14" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs14进行读写时转换到RAM的固定地址中（0x101000e0-0x101000ef）</comment>
        </bits>
      </reg>
      <reg name="patch15" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid15" pos="28" rst="0x0">
          <comment>patch_addrs15地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs15" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs15进行读写时转换到RAM的固定地址中（0x101000f0-0x101000ff）</comment>
        </bits>
      </reg>
      <reg name="patch16" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid16" pos="28" rst="0x0">
          <comment>patch_addrs16地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs16" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs16进行读写时转换到RAM的固定地址中（0x10100100-0x1010010f）</comment>
        </bits>
      </reg>
      <reg name="patch17" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid17" pos="28" rst="0x0">
          <comment>patch_addrs17地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs17" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs17进行读写时转换到RAM的固定地址中（0x10100110-0x1010011f）</comment>
        </bits>
      </reg>
      <reg name="patch18" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid18" pos="28" rst="0x0">
          <comment>patch_addrs18地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs18" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs18进行读写时转换到RAM的固定地址中（0x10100120-0x1010012f）</comment>
        </bits>
      </reg>
      <reg name="patch19" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid19" pos="28" rst="0x0">
          <comment>patch_addrs19地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs19" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs19进行读写时转换到RAM的固定地址中（0x10100130-0x1010013f）</comment>
        </bits>
      </reg>
      <reg name="patch20" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid20" pos="28" rst="0x0">
          <comment>patch_addrs20地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs20" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs20进行读写时转换到RAM的固定地址中（0x10100140-0x1010014f）</comment>
        </bits>
      </reg>
      <reg name="patch21" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid21" pos="28" rst="0x0">
          <comment>patch_addrs21地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs21" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs21进行读写时转换到RAM的固定地址中（0x10100150-0x1010015f）</comment>
        </bits>
      </reg>
      <reg name="patch22" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid22" pos="28" rst="0x0">
          <comment>patch_addrs22地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs22" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs22进行读写时转换到RAM的固定地址中（0x10100160-0x1010016f）</comment>
        </bits>
      </reg>
      <reg name="patch23" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid23" pos="28" rst="0x0">
          <comment>patch_addrs23地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs23" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs23进行读写时转换到RAM的固定地址中（0x10100170-0x1010017f）</comment>
        </bits>
      </reg>
      <reg name="patch24" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid24" pos="28" rst="0x0">
          <comment>patch_addrs24地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs24" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs24进行读写时转换到RAM的固定地址中（0x10100180-0x1010018f）</comment>
        </bits>
      </reg>
      <reg name="patch25" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid25" pos="28" rst="0x0">
          <comment>patch_addrs25地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs25" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs25进行读写时转换到RAM的固定地址中（0x10100190-0x1010019f）</comment>
        </bits>
      </reg>
      <reg name="patch26" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid26" pos="28" rst="0x0">
          <comment>patch_addrs26地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs26" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs26进行读写时转换到RAM的固定地址中（0x101001a0-0x101001af）</comment>
        </bits>
      </reg>
      <reg name="patch27" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid27" pos="28" rst="0x0">
          <comment>patch_addrs27地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs27" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs27进行读写时转换到RAM的固定地址中（0x101001b0-0x101001bf）</comment>
        </bits>
      </reg>
      <reg name="patch28" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid28" pos="28" rst="0x0">
          <comment>patch_addrs28地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs28" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs28进行读写时转换到RAM的固定地址中（0x101001c0-0x101001cf）</comment>
        </bits>
      </reg>
      <reg name="patch29" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid29" pos="28" rst="0x0">
          <comment>patch_addrs29地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs29" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs29进行读写时转换到RAM的固定地址中（0x101001d0-0x101001df）</comment>
        </bits>
      </reg>
      <reg name="patch30" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid30" pos="28" rst="0x0">
          <comment>patch_addrs30地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs30" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs30进行读写时转换到RAM的固定地址中（0x101001e0-0x101001ef）</comment>
        </bits>
      </reg>
      <reg name="patch31" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid31" pos="28" rst="0x0">
          <comment>patch_addrs31地址对应的patch功能使能</comment>
        </bits>
        <bits access="rw" name="patch_addrs31" pos="27:0" rst="0x0">
          <comment>对ROM地址patch_addrs31进行读写时转换到RAM的固定地址中（0x101001f0-0x101001ff）</comment>
        </bits>
      </reg>
      <reg name="pagespy0_cfg0" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_enable0" pos="30" rst="0x0">
          <comment>pagespy功能使能</comment>
        </bits>
        <bits access="rw" name="pagespy_detectr0" pos="29" rst="0x0">
          <comment>监控读操作使能</comment>
        </bits>
        <bits access="rw" name="pagespy_detectw0" pos="28" rst="0x0">
          <comment>监控写操作使能</comment>
        </bits>
        <bits access="rw" name="pagespy_sta_addr0" pos="27:0" rst="0x0">
          <comment>pagespy监控的开始地址</comment>
        </bits>
      </reg>
      <reg name="pagespy0_cfg1" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_end_addr0" pos="27:0" rst="0x0">
          <comment>pagespy监控的结束地址</comment>
        </bits>
      </reg>
      <reg name="pagespy1_cfg0" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_enable1" pos="30" rst="0x0">
          <comment>pagespy功能使能</comment>
        </bits>
        <bits access="rw" name="pagespy_detectr1" pos="29" rst="0x0">
          <comment>监控读操作使能</comment>
        </bits>
        <bits access="rw" name="pagespy_detectw1" pos="28" rst="0x0">
          <comment>监控写操作使能</comment>
        </bits>
        <bits access="rw" name="pagespy_sta_addr1" pos="27:0" rst="0x0">
          <comment>pagespy监控的开始地址</comment>
        </bits>
      </reg>
      <reg name="pagespy1_cfg1" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_end_addr1" pos="27:0" rst="0x0">
          <comment>pagespy监控的结束地址</comment>
        </bits>
      </reg>
      <reg name="pagespy2_cfg0" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_enable2" pos="30" rst="0x0">
          <comment>pagespy功能使能</comment>
        </bits>
        <bits access="rw" name="pagespy_detectr2" pos="29" rst="0x0">
          <comment>监控读操作使能</comment>
        </bits>
        <bits access="rw" name="pagespy_detectw2" pos="28" rst="0x0">
          <comment>监控写操作使能</comment>
        </bits>
        <bits access="rw" name="pagespy_sta_addr2" pos="27:0" rst="0x0">
          <comment>pagespy监控的开始地址</comment>
        </bits>
      </reg>
      <reg name="pagespy2_cfg1" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_end_addr2" pos="27:0" rst="0x0">
          <comment>pagespy监控的结束地址</comment>
        </bits>
      </reg>
      <reg name="pagespy3_cfg0" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_enable3" pos="30" rst="0x0">
          <comment>pagespy功能使能</comment>
        </bits>
        <bits access="rw" name="pagespy_detectr3" pos="29" rst="0x0">
          <comment>监控读操作使能</comment>
        </bits>
        <bits access="rw" name="pagespy_detectw3" pos="28" rst="0x0">
          <comment>监控写操作使能</comment>
        </bits>
        <bits access="rw" name="pagespy_sta_addr3" pos="27:0" rst="0x0">
          <comment>pagespy监控的开始地址</comment>
        </bits>
      </reg>
      <reg name="pagespy3_cfg1" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_end_addr3" pos="27:0" rst="0x0">
          <comment>pagespy监控的结束地址</comment>
        </bits>
      </reg>
      <reg name="pagespy0_sta0" protect="rw">
        <comment/>
        <bits access="r" name="pagespy_status0" pos="18" rst="0x0">
          <comment>pagespy返回的标志位，监控地址段内产生读或写操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_hitr0" pos="17" rst="0x0">
          <comment>监控地址段内产生读操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_hitw0" pos="16" rst="0x0">
          <comment>监控地址段内产生写操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_aid0" pos="15:0" rst="0x0">
          <comment>返回该读或写操作的CPU的ID号</comment>
        </bits>
      </reg>
      <reg name="pagespy0_sta1" protect="rw">
        <comment/>
      </reg>
      <reg name="pagespy1_sta0" protect="rw">
        <comment/>
        <bits access="r" name="pagespy_status1" pos="18" rst="0x0">
          <comment>pagespy返回的标志位，监控地址段内产生读或写操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_hitr1" pos="17" rst="0x0">
          <comment>监控地址段内产生读操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_hitw1" pos="16" rst="0x0">
          <comment>监控地址段内产生写操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_aid1" pos="15:0" rst="0x0">
          <comment>返回该读或写操作的CPU的ID号</comment>
        </bits>
      </reg>
      <reg name="pagespy1_sta1" protect="rw">
        <comment/>
      </reg>
      <reg name="pagespy2_sta0" protect="rw">
        <comment/>
        <bits access="r" name="pagespy_status2" pos="18" rst="0x0">
          <comment>pagespy返回的标志位，监控地址段内产生读或写操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_hitr2" pos="17" rst="0x0">
          <comment>监控地址段内产生读操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_hitw2" pos="16" rst="0x0">
          <comment>监控地址段内产生写操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_aid2" pos="15:0" rst="0x0">
          <comment>返回该读或写操作的CPU的ID号</comment>
        </bits>
      </reg>
      <reg name="pagespy2_sta1" protect="rw">
        <comment/>
      </reg>
      <reg name="pagespy3_sta0" protect="rw">
        <comment/>
        <bits access="r" name="pagespy_status3" pos="18" rst="0x0">
          <comment>pagespy返回的标志位，监控地址段内产生读或写操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_hitr3" pos="17" rst="0x0">
          <comment>监控地址段内产生读操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_hitw3" pos="16" rst="0x0">
          <comment>监控地址段内产生写操作时为1</comment>
        </bits>
        <bits access="r" name="pagespy_aid3" pos="15:0" rst="0x0">
          <comment>返回该读或写操作的CPU的ID号</comment>
        </bits>
      </reg>
      <reg name="pagespy3_sta1" protect="rw">
        <comment/>
      </reg>
    </module>
    <instance address="0x14003000" name="CP_SYSRAM_PATCH" type="CP_SYSRAM_PATCH"/>
  </archive>
  <archive relative="cp_freq_bias.xml">
    <module category="System" name="CP_FREQ_BIAS">
      <reg name="raw_int_sts" protect="rw">
        <comment>raw interrupt status Register raw interrupt status Register</comment>
      </reg>
      <reg name="int_en" protect="rw">
        <comment>interrupt enable Register interrupt enable Register</comment>
      </reg>
      <reg name="masked_int_sts" protect="rw">
        <comment>masked interrupt status Register masked interrupt status Register</comment>
      </reg>
      <reg name="int_clr" protect="rw">
        <comment>interrupt clear Register interrupt clear Register</comment>
      </reg>
      <reg name="freq_bias_ctrl_0" protect="rw">
        <comment>tempurature control register tempurature control register</comment>
        <bits access="rw" name="frac_freq_div_en" pos="28">
          <comment>1: frac freq div mode
0:  integer freq div mode</comment>
        </bits>
        <bits access="rw" name="ext_chan_sel_sw" pos="27">
          <comment>1: ext  osc static mode
0:  ext tsx static mode</comment>
        </bits>
        <bits access="rw" name="ext_chan_sel_mode" pos="26">
          <comment>1: sw config ,ext tsx/osc static mode
0:  ext tsx/osc swtich mode</comment>
        </bits>
        <bits access="rw" name="osc_src_mode" pos="25">
          <comment>1: External OSC option
0: Internal OSC option</comment>
        </bits>
        <bits access="rw" name="freq_bias_mode" pos="24">
          <comment>0:hardware mode
1:software mode</comment>
        </bits>
        <bits access="rw" name="osc_temp_comp_shift" pos="23:20">
          <comment>osc left shift control of tempurature offset</comment>
        </bits>
        <bits access="rw" name="temp_comp_shift" pos="19:16">
          <comment>left shift control of tempurature offset</comment>
        </bits>
        <bits access="rw" name="input_flag" pos="15">
          <comment>1:first do OSC
0:first do TSX</comment>
        </bits>
        <bits access="rw" name="switch_enb" pos="14">
          <comment>1:  switch osx tsx enable
0:  switch osx tsx disable</comment>
        </bits>
        <bits access="rw" name="freq_bias_mode1" pos="13">
          <comment>1:  OSC option
0:  TSX option</comment>
        </bits>
        <bits access="rw" name="freq_bias_src_mode" pos="12">
          <comment>1: External TSX option
0: Internal TSX option</comment>
        </bits>
        <bits access="rw" name="srst_osc_inter_thm" pos="11">
          <comment>1: enable osc internal thermal ADS synchronous reset</comment>
        </bits>
        <bits access="rw" name="osc_edge_sel_temp" pos="10">
          <comment>1: sample the osc adc data at the posedge of adc clock
0: sample the osc dac data at the negedge of adc clock</comment>
        </bits>
        <bits access="rw" name="srst_inter_thm" pos="9">
          <comment>1: enable internal thermal ADS synchronous reset</comment>
        </bits>
        <bits access="rw" name="edge_sel_temp" pos="8">
          <comment>1: sample the adc data at the posedge of adc clock
0: sample the dac data at the negedge of adc clock</comment>
        </bits>
        <bits access="rw" name="osc_temp_filter_en" pos="5">
          <comment>enable the osc filter filter in the calculation(update)</comment>
        </bits>
        <bits access="rw" name="filter_en_temp" pos="4">
          <comment>enable the tsx filter filter in the calculation(update)</comment>
        </bits>
        <bits access="rw" name="thm_adc_dump_en" pos="3">
          <comment>enable the thermal ADC data dump to Memory</comment>
        </bits>
        <bits access="rw" name="osc_cal_en_temp" pos="1">
          <comment>enable the osc calcualtion of  tempurature compensation</comment>
        </bits>
        <bits access="rw" name="cal_en_temp" pos="0">
          <comment>enable the tsx calcualtion of  tempurature compensation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_1" protect="rw">
        <comment>the length of intergration the length of intergration</comment>
        <bits access="rw" name="intergration_len_temp" pos="19:0">
          <comment>the length of intergration</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_2" protect="rw">
        <comment>the coef0 of frequency calculation the coef1 of frequency calculation</comment>
        <bits access="rw" name="c0_temp" pos="15:0">
          <comment>c0 of frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_3" protect="rw">
        <comment>the coef1 of frequency calculation the coef2 of frequency calculation</comment>
        <bits access="rw" name="c1_temp" pos="15:0">
          <comment>c0 of frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_4" protect="rw">
        <comment>the coef2 of frequency calculation the coef3 of frequency calculation</comment>
        <bits access="rw" name="c2_temp" pos="15:0">
          <comment>c2of frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_5" protect="rw">
        <comment>the coef3 of frequency calculation the coef4 of frequency calculation</comment>
        <bits access="rw" name="c3_temp" pos="15:0">
          <comment>c0 of frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_6" protect="rw">
        <comment>the reserved  register of frequency calculation the reserved  register of frequency calculation</comment>
      </reg>
      <reg name="freq_bias_ctrl_7" protect="rw">
        <comment>the configur register of external sigma-delta ADC over resampling the configur register of external sigma-delta ADC over resampling</comment>
        <bits access="rw" name="ext_conf_clk_inv_pos" pos="31:28" rst="0x3">
          <comment>external TSX over resampling  output divider clk second inverse  position.</comment>
        </bits>
        <bits access="rw" name="ext_conf_clk_init_pos" pos="27:24" rst="0x1">
          <comment>external TSX over resampling  output divider clk initial inverse position.</comment>
        </bits>
        <bits access="rw" name="ext_conf_cnter_max" pos="20:16" rst="0x3">
          <comment>external TSX over resampling resampling ration over origin signma delta ADC working clk frequency. For example, the origin sampling clk and resmapling clk is 6.5M and 26M, and the ratio is 4 .then the value of this register should be ration-1 =3.</comment>
        </bits>
        <bits access="rw" name="ext_conf_first_pls_pos" pos="15:12" rst="0x3">
          <comment>external TSX over resampling first pulse generate postion in delay chain.
Typital is 1</comment>
        </bits>
        <bits access="rw" name="ext_conf_best_pos" pos="8:4">
          <comment>external TSX over resampling  best sampling positon .</comment>
        </bits>
        <bits access="rw" name="ext_conf_clk_init_val" pos="2">
          <comment>external TSX over resampling  output divider clk init value.</comment>
        </bits>
        <bits access="rw" name="ext_conf_sync_order" pos="1">
          <comment>external TSX over resampling  delay chain sync mode select.
1: high first
0: low first</comment>
        </bits>
        <bits access="rw" name="ext_conf_en" pos="0">
          <comment>external TSX over resampling  work enable</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_8" protect="rw">
        <comment>offset of osc frequency calculation offset of osc frequency calculation</comment>
        <bits access="rw" name="osc_temp_offset" pos="19:0">
          <comment>offset of osc frequency calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_9" protect="rw">
        <comment>the coef0 of  osc frequency calculation the coef1 of  osc frequency calculation</comment>
        <bits access="rw" name="osc_c0_temp" pos="15:0">
          <comment>c0 of  osc frequency calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_soft_val" protect="rw">
        <comment>the freq bias cal val  reg in software mode the freq bias cal val  reg in software mode</comment>
        <bits access="rw" name="freq_bias_soft_val_upd" pos="31">
          <comment>software calculation frequency bias update.Write to this reg will gen an plus.</comment>
        </bits>
        <bits access="rw" name="freq_bias_soft_val" pos="25:0">
          <comment>software calculation frequency bias</comment>
        </bits>
      </reg>
      <reg name="freq_bias_upd_cnter" protect="rw">
        <comment>the counter of frequency calculation done the counter of frequency calculation done</comment>
      </reg>
      <reg name="freq_bias_temp_upd_cnter" protect="rw">
        <comment>the counter of tempurature calculation done the counter of tempurature calculation done</comment>
      </reg>
      <reg name="freq_bias_ctrl_10" protect="rw">
        <comment>the coef1 of osc frequency calculation the coef2 of osc frequency calculation</comment>
        <bits access="rw" name="osc_c1_temp" pos="15:0">
          <comment>c1 of osc frequency calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_11" protect="rw">
        <comment>the coef2 of osc  frequency calculation the coef3 of osc  frequency calculation</comment>
        <bits access="rw" name="osc_c2_temp" pos="15:0">
          <comment>c2 of osc frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_12" protect="rw">
        <comment>the coef3 of  osc frequency calculation the coef4 of  osc frequency calculation</comment>
        <bits access="rw" name="osc_c3_temp" pos="15:0">
          <comment>c3 of osc frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_13" protect="rw">
        <comment>switch ctrl switch ctrl</comment>
        <bits access="rw" name="osc_data_num" pos="31:26">
          <comment>osc_data_num</comment>
        </bits>
        <bits access="rw" name="tsx_data_num" pos="25:20">
          <comment>tsx_data_num</comment>
        </bits>
        <bits access="rw" name="adc_delay_num" pos="19:0">
          <comment>adc delay num</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_14" protect="rw">
        <comment>the configur register of external sigma-delta ADC over resampling(frac freq div) the configur register of external sigma-delta ADC over resampling(frac freq div)</comment>
        <bits access="rw" name="ext_conf_toggle_neg" pos="19:16" rst="0x5">
          <comment>external TSX/OSC over resampling  output divider neg clk inverse position.</comment>
        </bits>
        <bits access="rw" name="ext_conf_toggle_pos" pos="15:12" rst="0x1">
          <comment>external TSX/OSC over resampling  output divider pos clk  inverse position.</comment>
        </bits>
        <bits access="rw" name="ext_conf_first_pls_pos" pos="11:8" rst="0x1">
          <comment>external TSX/OSC over resampling first pulse generate postion in delay chain.
Typital is 1</comment>
        </bits>
        <bits access="rw" name="ext_conf_frac_cnter_max" pos="7:4" rst="0x6">
          <comment>external TSX/OSC over resampling resampling ration over origin signma delta ADC working clk frequency. For example, the origin sampling clk and resmapling clk is 26/3.5M and 26M, and the ratio is 3.5 .then the value of this register should be ration*2-1 =6.</comment>
        </bits>
        <bits access="rw" name="ext_conf_frac_clk_sel" pos="2">
          <comment>1: neg clk sample
0: pos clk sample</comment>
        </bits>
        <bits access="rw" name="ext_conf_frac_sync_order" pos="1">
          <comment>external TSX/OSC over resampling  delay chain sync mode select.
1: high first
0: low first</comment>
        </bits>
        <bits access="rw" name="ext_conf_frac_en" pos="0">
          <comment>external TSX/OSC over resampling  work enable</comment>
        </bits>
      </reg>
      <hole size="320"/>
      <reg name="freq_bias_status0" protect="rw">
        <comment>the status  reg of frequency bias calculation  the status  reg of frequency bias calculation</comment>
        <bits access="r" name="freq_raw_bias_upd" pos="31">
          <comment>hardware calculation frequency bias update.Write to this reg will gen an plus</comment>
        </bits>
        <bits access="r" name="freq_bias" pos="25:0">
          <comment>hardware calculation frequency bias value</comment>
        </bits>
      </reg>
      <reg name="freq_bias_status1" protect="rw">
        <comment>the status  reg of tempurature calculation  the status  reg of tempurature calculation</comment>
        <bits access="r" name="freq_bias_integer_upd" pos="31">
          <comment>hardware calculation frequency bias update.Write to this reg will gen an plus</comment>
        </bits>
        <bits access="r" name="freq_bias_temp" pos="19:0">
          <comment>hardware integration value of calculation tempurature</comment>
        </bits>
      </reg>
      <reg name="freq_bias_status2" protect="rw">
        <comment>the status  reg of frequency bias calculation  the status  reg of frequency bias calculation</comment>
        <bits access="r" name="osc_freq_raw_bias_upd" pos="31">
          <comment>hardware calculation frequency bias update.Write to this reg will gen an plus</comment>
        </bits>
        <bits access="r" name="osc_freq_bias" pos="25:0">
          <comment>hardware calculation frequency bias value</comment>
        </bits>
      </reg>
      <reg name="freq_bias_status3" protect="rw">
        <comment>the status  reg of tempurature calculation  the status  reg of tempurature calculation</comment>
        <bits access="r" name="osc_freq_bias_integer_upd" pos="31">
          <comment>hardware calculation frequency bias update.Write to this reg will gen an plus</comment>
        </bits>
        <bits access="r" name="osc_freq_bias_temp" pos="19:0">
          <comment>hardware integration value of calculation tempurature</comment>
        </bits>
      </reg>
      <reg name="freq_bias_status4" protect="rw">
        <comment>the status  reg of tempurature calculation  the status  reg of tempurature calculation</comment>
        <bits access="r" name="freq_bias_sum_upd" pos="31">
          <comment>hardware calculation frequency bias update.Write to this reg will gen an plus</comment>
        </bits>
        <bits access="r" name="freq_bias_sum" pos="25:0">
          <comment>hardware integration value of calculation tempurature</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_15" protect="rw">
        <comment>osc_cal_post  ctrl osc_cal_post  ctrl</comment>
        <bits access="rw" name="osc_rate_deltat" pos="31:16"/>
        <bits access="rw" name="osc_alpha" pos="15:0"/>
      </reg>
      <reg name="freq_bias_ctrl_16" protect="rw">
        <comment>osc_cal_post  ctrl osc_cal_post  ctrl</comment>
        <bits access="rw" name="osc_freq_bias_sel" pos="7" rst="0x1">
          <comment>0 is osc_freq_bias_pre, 1 is osc_freq_bias_post</comment>
        </bits>
        <bits access="rw" name="osc_t2reset_num" pos="6:1">
          <comment>t2reset_cnt th</comment>
        </bits>
        <bits access="rw" name="osc_t2reset_cnt_clr" pos="0">
          <comment>clear osc t2reset_cnt</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_17" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_rate_deltat" pos="31:16"/>
        <bits access="rw" name="tsx_alpha" pos="15:0"/>
      </reg>
      <reg name="freq_bias_ctrl_18" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_freq_bias_sel" pos="31" rst="0x1">
          <comment>0 is tsx_freq_bias_pre, 1 is tsx_freq_bias_post</comment>
        </bits>
        <bits access="rw" name="tsx_fcalth_coef" pos="30:19"/>
        <bits access="rw" name="tsx_ratehys_coef" pos="18:7"/>
        <bits access="rw" name="tsx_smth_coef" pos="6:2"/>
        <bits access="rw" name="tsx_t2reset_cnt_clr" pos="0">
          <comment>clear osc t2reset_cnt</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_19" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_t2reset_num" pos="31:26">
          <comment>t2reset_cnt th</comment>
        </bits>
        <bits access="rw" name="tsx_fcalth_osft" pos="25:0"/>
      </reg>
      <reg name="freq_bias_ctrl_20" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_age_th_inv" pos="31:16">
          <comment>t2reset_cnt th</comment>
        </bits>
        <bits access="rw" name="tsx_age_th" pos="15:0"/>
      </reg>
      <reg name="freq_bias_ctrl_21" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_maxtemp_rate_th" pos="31:16">
          <comment>t2reset_cnt th</comment>
        </bits>
        <bits access="rw" name="tsx_ratehys_ofst" pos="15:0"/>
      </reg>
      <reg name="freq_bias_ctrl_22" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_23" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_24" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_25" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_26" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_27" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_28" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_29" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_30" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_31" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_32" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_rate_tab_val20" pos="15:0"/>
      </reg>
      <reg name="freq_bias_ctrl_33" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_smth_sft" pos="22:20"/>
        <bits access="rw" name="tsx_temp_th" pos="19:0"/>
      </reg>
      <reg name="freq_bias_rpt0" protect="rw">
        <comment>freq_bias_rpt0 freq_bias_rpt0</comment>
        <bits access="r" name="osc_temp" pos="19:0"/>
      </reg>
      <reg name="freq_bias_rpt1" protect="rw">
        <comment>freq_bias_rpt1 freq_bias_rpt1</comment>
        <bits access="r" name="osc_temp2" pos="27:0"/>
      </reg>
      <reg name="freq_bias_rpt2" protect="rw">
        <comment>freq_bias_rpt2 freq_bias_rpt2</comment>
        <bits access="r" name="tsx_temp" pos="19:0"/>
      </reg>
      <reg name="freq_bias_rpt3" protect="rw">
        <comment>freq_bias_rpt3 freq_bias_rpt3</comment>
        <bits access="r" name="tsx_temp2" pos="27:0"/>
      </reg>
      <reg name="freq_bias_rpt4" protect="rw">
        <comment>freq_bias_rpt4 freq_bias_rpt4</comment>
        <bits access="r" name="tsx_fcal" pos="25:0"/>
      </reg>
    </module>
    <instance address="0x12080000" name="CP_FREQ_BIAS" type="CP_FREQ_BIAS"/>
  </archive>
  <archive relative="cp_glb.xml">
    <module category="System" name="CP_GLB">
      <reg name="sysctrl00" protect="rw">
        <comment/>
        <bits access="rw" name="slv_disable_req_cp_ltecpu_force" pos="24" rst="0x0">
          <comment>1：cp cpu访问lte时软件控制的防挂死功能使能</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_ltecpu_sel" pos="23" rst="0x0">
          <comment>1：cp cpu访问lte时防挂死功能由软件控制；0：由硬件控制</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_ltedma_force" pos="22" rst="0x0">
          <comment>1：cp访问lte dma时软件控制的防挂死功能使能</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_ltedma_sel" pos="21" rst="0x0">
          <comment>1：cp访问lte dma时防挂死功能由软件控制；0：由硬件控制</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_psram_force" pos="20" rst="0x0">
          <comment>1：cp访问psram时软件控制的防挂死功能使能</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_psram_sel" pos="19" rst="0x0">
          <comment>1：cp访问psram时防挂死功能由软件控制；0：由硬件控制</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_gnss_force" pos="18" rst="0x0">
          <comment>1：cp访问gnss时软件控制的防挂死功能使能</comment>
        </bits>
        <bits access="rw" name="rg_ifc2cp_clk_auto_gate_en" pos="16" rst="0x0">
          <comment>1：ifc2cp的异步桥auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_ifc2cp_nonbuf_early_resp_en" pos="15" rst="0x0">
          <comment>1：ifc发送数据到异步桥后，就可返回responds,把不可缓存的写操作视作可缓存的写操作</comment>
        </bits>
        <bits access="rw" name="rg_cp_ahb_xhb400_awsparse" pos="14" rst="0x1">
          <comment>axi的wstrb（指示哪8bitS有效信号）转到ahb指示信号,作为AHB的awsparse信号</comment>
        </bits>
        <bits access="rw" name="rg_tsx_sclk_auto_gate_en" pos="13" rst="0x0">
          <comment>1：tsx_sclk的异步桥auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_tsx_mclk_auto_gate_en" pos="12" rst="0x0">
          <comment>1：tsx_mclk的异步桥auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_tsx_nonbuf_early_resp_en" pos="11" rst="0x0">
          <comment>1：总线传数据到buffer，未从buffer输出完成，就可返回responds，把不可缓存的写操作视作可缓存的写操作</comment>
        </bits>
        <bits access="rw" name="rg_aon2cp_sclk_auto_gate_en" pos="10" rst="0x0">
          <comment>1：aon2cp_sclk的异步桥auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_aon2cp_mclk_auto_gate_en" pos="9" rst="0x0">
          <comment>1：aon2cp_mclk的异步桥auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_aon2cp_nonbuf_early_resp_en" pos="8" rst="0x0">
          <comment>1：aon到cp传输数据到buffer，未从buffer输出完成，就可返回responds，把不可缓存的写操作视作可缓存的写操作</comment>
        </bits>
        <bits access="rw" name="rg_cp2gnss_xhb400_awsparse" pos="7" rst="0x1">
          <comment>axi的wstrb（指示哪8bitS有效信号）转到ahb指示信号，作为AHB的awsparse信号</comment>
        </bits>
        <bits access="rw" name="rg_cp2aon_xhb400_awsparse" pos="3" rst="0x1">
          <comment>axi的wstrb（指示哪8bitS有效信号）转到ahb指示信号，作为AHB的awsparse信号</comment>
        </bits>
      </reg>
      <reg name="sysctrl01" protect="rw">
        <comment/>
        <bits access="rw" name="arqos_cp_ifc" pos="31:28" rst="0x0">
          <comment>ifc写数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="awqos_cp_ifc" pos="27:24" rst="0x0">
          <comment>ifc读数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="arqos_axidma" pos="23:20" rst="0x0">
          <comment>axidma写数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="awqos_axidma" pos="19:16" rst="0x0">
          <comment>axidma读数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="arqos_f8" pos="15:12" rst="0x0">
          <comment>f8写数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="awqos_f8" pos="11:8" rst="0x0">
          <comment>f8读数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="arqos_cp_a5" pos="7:4" rst="0x0">
          <comment>cp a5写数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="awqos_cp_a5" pos="3:0" rst="0x0">
          <comment>cp a5读数据总线的优先级</comment>
        </bits>
      </reg>
      <reg name="sysctrl02" protect="rw">
        <comment/>
        <bits access="rw" name="arqos_lte_dma" pos="23:20" rst="0x0">
          <comment>lte dma写数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="awqos_lte_dma" pos="19:16" rst="0x0">
          <comment>lte dma读数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="arqos_lte_cpu" pos="15:12" rst="0x0">
          <comment>lte cpu写数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="awqos_lte_cpu" pos="11:8" rst="0x0">
          <comment>lte cpu读数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="arqos_aon_m" pos="7:4" rst="0x0">
          <comment>aon m写数据总线的优先级</comment>
        </bits>
        <bits access="rw" name="awqos_aon_m" pos="3:0" rst="0x0">
          <comment>aon m读数据总线的优先级</comment>
        </bits>
      </reg>
      <reg name="sysctrl03" protect="rw">
        <comment/>
        <bits access="rw" name="lpc_main_early_wakeup_bypass" pos="26" rst="0x0">
          <comment>1：lpc_main的wakeup功能使能，无需等待外设的cactive信号便可唤醒时钟</comment>
        </bits>
        <bits access="rw" name="lp_force_s6" pos="25" rst="0x0">
          <comment>1：s6的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_s5" pos="24" rst="0x0">
          <comment>1：s5的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_s4" pos="23" rst="0x0">
          <comment>1：s4的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_s3" pos="22" rst="0x0">
          <comment>1：s3的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_s2" pos="21" rst="0x0">
          <comment>1：s2的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_s1" pos="20" rst="0x0">
          <comment>1：s1的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_s0" pos="19" rst="0x0">
          <comment>1：s0的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_main" pos="18" rst="0x0">
          <comment>1：main的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_m4" pos="17" rst="0x0">
          <comment>1：m4的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_m3" pos="16" rst="0x0">
          <comment>1：m3的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_m2" pos="15" rst="0x0">
          <comment>1：m2的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_m1" pos="14" rst="0x0">
          <comment>1：m1的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_force_m0" pos="13" rst="0x0">
          <comment>1：m0的强制关闭总线使能打开，保证当前传输完成</comment>
        </bits>
        <bits access="rw" name="lp_eb_s6" pos="12" rst="0x0">
          <comment>1:s6的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_s5" pos="11" rst="0x0">
          <comment>1:s5的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_s4" pos="10" rst="0x0">
          <comment>1:s4的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_s3" pos="9" rst="0x0">
          <comment>1:s3的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_s2" pos="8" rst="0x0">
          <comment>1:s2的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_s1" pos="7" rst="0x0">
          <comment>1:s1的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_s0" pos="6" rst="0x0">
          <comment>1:s0的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_main" pos="5" rst="0x0">
          <comment>1:main的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_m4" pos="4" rst="0x0">
          <comment>1:m4的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_m3" pos="3" rst="0x0">
          <comment>1:m3的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_m2" pos="2" rst="0x0">
          <comment>1:m2的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_m1" pos="1" rst="0x0">
          <comment>1:m1的控制低功耗使能打开</comment>
        </bits>
        <bits access="rw" name="lp_eb_m0" pos="0" rst="0x0">
          <comment>1:m0的控制低功耗使能打开</comment>
        </bits>
      </reg>
      <reg name="sysctrl04" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_m0" pos="23:16" rst="0x0">
          <comment>m0退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_m0" pos="15:0" rst="0x80">
          <comment>m0总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl05" protect="rw">
        <comment>·</comment>
        <bits access="rw" name="pu_num_m1" pos="23:16" rst="0x0">
          <comment>m1退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_m1" pos="15:0" rst="0x80">
          <comment>m1总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl06" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_m2" pos="23:16" rst="0x0">
          <comment>m2退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_m2" pos="15:0" rst="0x80">
          <comment>m2总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl07" protect="rw">
        <comment>·</comment>
        <bits access="rw" name="pu_num_m3" pos="23:16" rst="0x0">
          <comment>m3退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_m3" pos="15:0" rst="0x80">
          <comment>m3总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl08" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_m4" pos="23:16" rst="0x0">
          <comment>m4退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_m4" pos="15:0" rst="0x80">
          <comment>m4总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl09" protect="rw">
        <comment>·</comment>
        <bits access="rw" name="pu_num_s0" pos="23:16" rst="0x0">
          <comment>s0退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_s0" pos="15:0" rst="0x80">
          <comment>s0总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl10" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_s1" pos="23:16" rst="0x0">
          <comment>s1退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_s1" pos="15:0" rst="0x80">
          <comment>s1总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl11" protect="rw">
        <comment>·</comment>
        <bits access="rw" name="pu_num_s2" pos="23:16" rst="0x0">
          <comment>s2退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_s2" pos="15:0" rst="0x80">
          <comment>s2总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl12" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_s3" pos="23:16" rst="0x0">
          <comment>s3退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_s3" pos="15:0" rst="0x80">
          <comment>s3总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl13" protect="rw">
        <comment>·</comment>
        <bits access="rw" name="pu_num_s4" pos="23:16" rst="0x0">
          <comment>s4退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_s4" pos="15:0" rst="0x80">
          <comment>s4总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl14" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_s5" pos="23:16" rst="0x0">
          <comment>s5退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_s5" pos="15:0" rst="0x80">
          <comment>s5总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl15" protect="rw">
        <comment>·</comment>
        <bits access="rw" name="pu_num_s6" pos="23:16" rst="0x0">
          <comment>s6退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_s6" pos="15:0" rst="0x80">
          <comment>s6总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl16" protect="rw">
        <comment/>
        <bits access="rw" name="rg_osc_clkedge_sel" pos="10" rst="0x0">
          <comment>1：clk_thm_osc时钟反向</comment>
        </bits>
        <bits access="rw" name="rg_tsx_clkedge_sel" pos="9" rst="0x0">
          <comment>1：clk_thm_tsx时钟反向</comment>
        </bits>
        <bits access="rw" name="freq_bias_ch3_en" pos="8" rst="0x0">
          <comment>1：freq_bias的ch3时钟开启</comment>
        </bits>
        <bits access="rw" name="freq_bias_ch2_en" pos="7" rst="0x0">
          <comment>1：freq_bias的ch2时钟开启</comment>
        </bits>
        <bits access="rw" name="freq_bias_ch1_en" pos="6" rst="0x0">
          <comment>1：freq_bias的ch1时钟开启</comment>
        </bits>
        <bits access="rw" name="freq_bias_ch0_en" pos="5" rst="0x1">
          <comment>1：freq_bias的ch0时钟开启</comment>
        </bits>
        <bits access="rw" name="cp_a5_resp_err_mask" pos="4" rst="0x0">
          <comment>1：a5收到axi bresp和rresp时忽略</comment>
        </bits>
        <bits access="rw" name="cp_ifc_hresp_err_mask" pos="3" rst="0x1">
          <comment>1：ifc总线respond返回error时忽略</comment>
        </bits>
        <bits access="rw" name="wlan_iq_sync_sel" pos="2" rst="0x0">
          <comment>1:wlan_iq使用同步后的信号；0：wlan_iq使用未作同步的信号</comment>
        </bits>
      </reg>
      <reg name="sysctrl17" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_cp_ahb_en" pos="12" rst="0x1">
          <comment>1：cgm_cp_ahb总线使能</comment>
        </bits>
        <bits access="rw" name="cgm_cp_axi_en" pos="11" rst="0x1">
          <comment>1：cgm_cp_axi总线使能</comment>
        </bits>
        <bits access="rw" name="cgm_cp_a5_en" pos="10" rst="0x1">
          <comment>1：cgm_cp_a5总线使能</comment>
        </bits>
        <bits access="rw" name="cgm_cp_axi_update" pos="9" rst="0x0">
          <comment>1：cgm_cp_update的使能打开</comment>
        </bits>
        <bits access="rw" name="cgm_cp_ahb_div" pos="8:6" rst="0x1">
          <comment>1：cgm_cp_ahb分频的使能打开</comment>
        </bits>
        <bits access="rw" name="cgm_cp_axi_div" pos="5:3" rst="0x0">
          <comment>1:cgm_cp_axi分频的使能打开</comment>
        </bits>
        <bits access="rw" name="cgm_cp_axi_sel" pos="2:0" rst="0x1">
          <comment>1：cgm_cp_axi选择哪个分频信号</comment>
        </bits>
      </reg>
      <reg name="sysctrl18" protect="rw">
        <comment/>
        <bits access="rw" name="freq_bias_ahb_en" pos="29" rst="0x0">
          <comment>1：freq_bias_ahb时钟打开；0：freq_bias_ahb时钟关闭</comment>
        </bits>
        <bits access="rw" name="aon2cp_ahb_en" pos="28" rst="0x1">
          <comment>1：aon2cp_ahb时钟打开；0：aon2cp_ahb时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ifc_en" pos="27" rst="0x1">
          <comment>1：cp_ahb_ifc时钟打开；0：cp_ahb_ifc时钟关闭APB Master use, can auto gate</comment>
        </bits>
        <bits access="rw" name="cp_apb_ifc_en" pos="26" rst="0x1">
          <comment>1：cp_apb_ifc时钟打开；0：cp_apb_ifc时钟关闭APB DMA master use</comment>
        </bits>
        <bits access="rw" name="dap_dap_en" pos="23" rst="0x1">
          <comment>1:dap时钟打开；0：dap时钟关闭</comment>
        </bits>
        <bits access="rw" name="freq_bias_func_en" pos="22" rst="0x0">
          <comment>1：freq_bias_func时钟打开；0：freq_bias_func时钟关闭</comment>
        </bits>
        <bits access="rw" name="wlan_11b_en" pos="21" rst="0x0">
          <comment>1：wlan_11b时钟打开；0：wlan_11b时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_busmon_func_en" pos="20" rst="0x0">
          <comment>1：busmon_func时钟打开；0：busmon_func时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci2_func_en" pos="19" rst="0x0">
          <comment>1：sci2_func时钟打开；0：busmon时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci2_conf_en" pos="18" rst="0x0">
          <comment>1：sci2_conf时钟打开；0：sci2_conf时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci2_mod_en" pos="17" rst="0x0">
          <comment>1：sci2_mod时钟打开；0：sci2_mod时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci1_func_en" pos="16" rst="0x0">
          <comment>1：sci1_func时钟打开；0：sci1_func时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci1_mod_en" pos="15" rst="0x0">
          <comment>1：sci1_conf时钟打开；0：sci1_conf时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci1_conf_en" pos="14" rst="0x0">
          <comment>1：sci1_mod时钟打开；0：sci1_mod时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_timer3_mod_en" pos="13" rst="0x0">
          <comment>1：timer3_mod时钟打开；0：timer3_mod时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_timer3_conf_en" pos="12" rst="0x0">
          <comment>1：timer3_conf时钟打开；0：timer3_conf时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_timer4_mod_en" pos="11" rst="0x0">
          <comment>1：timer4_mod时钟打开；0：timer4_mod时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_timer4_conf_en" pos="10" rst="0x0">
          <comment>1：timer4_conf时钟打开；0：timer4_conf时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sysram_conf_en" pos="9" rst="0x0">
          <comment>1：sysram_conf时钟打开；0：sysram_conf时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_axidma_en" pos="8" rst="0x0">
          <comment>1：axidma时钟打开；0：axidma时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ch3_en" pos="7" rst="0x0">
          <comment>1：ahb_ch3时钟打开；0：ahb_ch3时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ch2_en" pos="6" rst="0x0">
          <comment>1：ahb_ch2时钟打开；0：ahb_ch2时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ch1_en" pos="5" rst="0x0">
          <comment>1：ahb_ch1时钟打开；0：ahb_ch1时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ch0_en" pos="4" rst="0x0">
          <comment>1：ahb_ch0时钟打开；0：ahb_ch0时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ch_dbg_en" pos="3" rst="0x0">
          <comment>1：ahb_ch_dbg时钟打开；0：ahb_ch_dbg时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_f8_en" pos="2" rst="0x0">
          <comment>1：ahb_f8时钟打开；0：ahb_f8时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_irq1_en" pos="1" rst="0x1">
          <comment>1：ahb_irq1时钟打开；0：ahb_irq1时钟关闭</comment>
        </bits>
        <bits access="rw" name="cp_ahb_irq0_en" pos="0" rst="0x1">
          <comment>1：ahb_irq0时钟打开；0：ahb_irq0时钟关闭</comment>
        </bits>
      </reg>
      <reg name="sysctrl19" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_thm_osc_en" pos="7" rst="0x0">
          <comment>1:clk_thm_osc_gen时钟打开；0：clk_thm_osc_gen时钟关闭</comment>
        </bits>
        <bits access="rw" name="cgm_thm_tsx_en" pos="6" rst="0x0">
          <comment>1:clk_thm_tsx_gen时钟打开；0：clk_thm_tsx_gen时钟关闭</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_tsx_en" pos="5" rst="0x0">
          <comment>1:clk_gnss_tsx_gen时钟打开；0：clk_gnss_tsx_gen时钟关闭</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_tsx_sel" pos="4" rst="0x1">
          <comment>1:clk_gnss_tsx_mux时钟打开；0：clk_gnss_tsx_mux时钟关闭</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_11b_adc_en" pos="3" rst="0x0">
          <comment>1:clk_wcn_11b_adc_gen时钟打开；0：clk_wcn_11b_adc_gen时钟关闭</comment>
        </bits>
        <bits access="rw" name="cgm_wdg_32k_en" pos="2" rst="0x0">
          <comment>1:clk_wdg_32k_gen时钟打开；0：clk_wdg_32k_gen时钟关闭</comment>
        </bits>
        <bits access="rw" name="cgm_timer_26m_en" pos="1" rst="0x0">
          <comment>1:clk_timer_26m_gen时钟打开；0：clk_timer_26m_gen时钟关闭</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_11b_dfe_en" pos="0" rst="0x0">
          <comment>1:clk_wcn_11b_dfe_gen时钟打开；0：clk_wcn_11b_dfe_gen时钟关闭</comment>
        </bits>
      </reg>
      <reg name="sysctrl20" protect="rw">
        <comment/>
        <bits access="rw" name="tsx_ip_soft_rst" pos="27" rst="0x0">
          <comment>1：rst_osc_26m通过软件复位</comment>
        </bits>
        <bits access="rw" name="tsx_ab_soft_rst" pos="26" rst="0x0">
          <comment>1：rst_tsx_ab_m通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_psram_async_soft_rst" pos="25" rst="0x0">
          <comment>1:async_bridge_cp_soft_rst通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_ltedma_async_soft_rst" pos="24" rst="0x0">
          <comment>1:cp_ltedma_async_soft_rst_to_lte通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_ltecpu_async_soft_rst" pos="23" rst="0x0">
          <comment>1:cp_ltecpu_async_soft_rst_to_lte通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp2aon_soft_rst" pos="22" rst="0x0">
          <comment>1：rst_cp2aon_aon通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp2gnss_soft_rst" pos="21" rst="0x0">
          <comment>1：rst_cp2gnss_cp通过软件复位</comment>
        </bits>
        <bits access="rw" name="aon2cp_soft_rst" pos="20" rst="0x0">
          <comment>1：rst_aon2cp_aon通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_timer4_soft_rst" pos="19" rst="0x0">
          <comment>1：rst_timer4_26m通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_sci1_soft_rst" pos="18" rst="0x0">
          <comment>1：rst_sci1通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_sci2_soft_rst" pos="17" rst="0x0">
          <comment>1：rst_sci2通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_bsumon_apb_soft_rst" pos="16" rst="0x0">
          <comment>1：rst_busmon_apb通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_busmon_m0_soft_rst" pos="15" rst="0x0">
          <comment>1：rst_busmon_m0通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_busmon_m1_soft_rst" pos="14" rst="0x0">
          <comment>1：rst_busmon_m1通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_busmon_m2_soft_rst" pos="13" rst="0x0">
          <comment>1：rst_busmon_m2通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_busmon_m3_soft_rst" pos="12" rst="0x0">
          <comment>1：rst_busmon_m3通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_busmon_m4_soft_rst" pos="11" rst="0x0">
          <comment>1：rst_busmon_m4通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_wlan_soft_rst" pos="10" rst="0x0">
          <comment>1：rst_wlan_apb通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_f8_soft_rst" pos="9" rst="0x0">
          <comment>1：rst_f8通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_axidma_soft_rst" pos="8" rst="0x0">
          <comment>1：rst_axidma通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_imem_axi_soft_rst" pos="7" rst="0x0">
          <comment>1：rst_imem_axi通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_imem_apb_soft_rst" pos="6" rst="0x0">
          <comment>1：rst_imem_apb通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_timer3_soft_rst" pos="5" rst="0x0">
          <comment>1：rst_timer3通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_irq0_soft_rst" pos="4" rst="0x0">
          <comment>1：rst_irq0通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_irq1_soft_rst" pos="3" rst="0x0">
          <comment>1：rst_irq1通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_a5dbg_soft_rst" pos="2" rst="0x0">
          <comment>1：rst_a5dbg通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_a5cs_soft_rst" pos="1" rst="0x0">
          <comment>1：rst_a5cs通过软件复位</comment>
        </bits>
        <bits access="rw" name="cp_a5_soft_rst" pos="0" rst="0x0">
          <comment>1：rst_a5通过软件复位</comment>
        </bits>
      </reg>
      <reg name="sysctrl21" protect="rw">
        <comment/>
        <bits access="rw" name="cp_axi_auto_gate_en" pos="14" rst="0x0">
          <comment>1:cp_axi的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="cp_a5_auto_gate_en" pos="13" rst="0x0">
          <comment>1:cp_a5的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="cp2freq_ahb_auto_gate_en" pos="12" rst="0x0">
          <comment>1:cp2freq_ahb的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="ifc2cp_ahb_auto_gate_en" pos="9" rst="0x0">
          <comment>1:ifc2cp_ahb的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="aon2cp_ahb_auto_gate_en" pos="8" rst="0x0">
          <comment>1:aon2cp_ahb的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="cp_sci2_auto_gate_en" pos="7" rst="0x0">
          <comment>1:cp_sci2的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="cp_sci1_auto_gate_en" pos="6" rst="0x0">
          <comment>1:cp_sci1的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="cp_ifc_auto_gate_en" pos="5" rst="0x0">
          <comment>1:cp_ifc的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="cp_ifc_ch3_auto_gate_en" pos="4" rst="0x0">
          <comment>1:cp_ifc_ch3的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="cp_ifc_ch2_auto_gate_en" pos="3" rst="0x0">
          <comment>1:cp_ifc_ch2的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="cp_ifc_ch1_auto_gate_en" pos="2" rst="0x0">
          <comment>1:cp_ifc_ch1的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="cp_ifc_ch0_auto_gate_en" pos="1" rst="0x0">
          <comment>1:cp_ifc_ch0的auto_gate使能</comment>
        </bits>
        <bits access="rw" name="cp_ifc_ch_dbg_auto_gate_en" pos="0" rst="0x0">
          <comment>1:cp_ifc_ch_dbg的auto_gate使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl22" protect="rw">
        <comment>·</comment>
        <bits access="rw" name="cp_apbreg_soft_rst" pos="0" rst="0x0">
          <comment>1:rst_cp_apbreg通过软件复位</comment>
        </bits>
      </reg>
      <reg name="sysstat01" protect="rw">
        <comment/>
      </reg>
      <reg name="sysstat02" protect="rw">
        <comment/>
      </reg>
      <reg name="sysstat03" protect="rw">
        <comment/>
      </reg>
      <reg name="sysstat04" protect="rw">
        <comment/>
        <bits access="r" name="bridge_trans_idle_cp_ltecpu" pos="8">
          <comment>cp ltecpu的trans idle信号，1：表示此模块监控地端口已经完成所有传输</comment>
        </bits>
        <bits access="r" name="pwr_handshk_clk_req_cp_ltecpu" pos="7">
          <comment>cp ltecpu的pwr_handshk_clk_req信号</comment>
        </bits>
        <bits access="r" name="axi_detector_overflow_cp_ltecpu" pos="6">
          <comment>cp ltecpu的axi_detector_overflow信号</comment>
        </bits>
        <bits access="r" name="bridge_trans_idle_cp_ltedma" pos="5">
          <comment>cp ltedma的trans idle信号，1：表示此模块监控地端口已经完成所有传输</comment>
        </bits>
        <bits access="r" name="pwr_handshk_clk_req_cp_ltedma" pos="4">
          <comment>cp ltedma的pwr_handshk_clk_req信号</comment>
        </bits>
        <bits access="r" name="axi_detector_overflow_cp_ltedma" pos="3">
          <comment>cp ltedma的axi_detector_overflow信号</comment>
        </bits>
        <bits access="r" name="bridge_trans_idle_cp_psram" pos="2">
          <comment>cp psram的trans idle信号，1：表示此模块监控地端口已经完成所有传输</comment>
        </bits>
        <bits access="r" name="pwr_handshk_clk_req_cp_psram" pos="1">
          <comment>cp psram的pwr_handshk_clk_req信号</comment>
        </bits>
        <bits access="r" name="axi_detector_overflow_cp_psram" pos="0">
          <comment>cp psram的axi_detector_overflow信号</comment>
        </bits>
      </reg>
      <reg name="sysstat05" protect="rw">
        <comment/>
        <bits access="r" name="all_slave_force_slp" pos="29">
          <comment>1:所有slave的deep_sleep使能打开</comment>
        </bits>
        <bits access="r" name="all_master_force_slp" pos="28">
          <comment>1:所有master的deep_sleep使能打开</comment>
        </bits>
        <bits access="r" name="cp_slp_ack" pos="27">
          <comment>1：cp的deep_sleep的ack信号</comment>
        </bits>
        <bits access="r" name="cp_light_stop" pos="26">
          <comment>1：cp的light sleep使能关闭</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s6" pos="25">
          <comment>1：s6的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s5" pos="24">
          <comment>1：s5的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s4" pos="23">
          <comment>1：s4的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s3" pos="22">
          <comment>1：s3的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s2" pos="21">
          <comment>1：s2的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s1" pos="20">
          <comment>1：s1的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s0" pos="19">
          <comment>1：s0的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_main" pos="18">
          <comment>1：main的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_m4" pos="17">
          <comment>1：m4的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_m3" pos="16">
          <comment>1：m3的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_m2" pos="15">
          <comment>1：m2的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_m1" pos="14">
          <comment>1：m1的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_m0" pos="13">
          <comment>1：m0的lpc处于busy状态，lpc的输入时钟需要退出gated状态</comment>
        </bits>
        <bits access="r" name="lp_stat_s6" pos="12">
          <comment>1:s6已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_s5" pos="11">
          <comment>1:s5已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_s4" pos="10">
          <comment>1:s4已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_s3" pos="9">
          <comment>1:s3已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_s2" pos="8">
          <comment>1:s2已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_s1" pos="7">
          <comment>1:s1已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_s0" pos="6">
          <comment>1:s0已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_main" pos="5">
          <comment>1:main已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_m4" pos="4">
          <comment>1:m4已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_m3" pos="3">
          <comment>1:m3已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_m2" pos="2">
          <comment>1:m2已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_m1" pos="1">
          <comment>1:m1已经进入低功耗模式</comment>
        </bits>
        <bits access="r" name="lp_stat_m0" pos="0">
          <comment>1:m0已经进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysstat06" protect="rw">
        <comment/>
        <bits access="r" name="force_ack_s6" pos="12">
          <comment>1：s6 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s5" pos="11">
          <comment>1：s5 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s4" pos="10">
          <comment>1：s4 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s3" pos="9">
          <comment>1：s3 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s2" pos="8">
          <comment>1：s2 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s1" pos="7">
          <comment>1：s1 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s0" pos="6">
          <comment>1：s0 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_main" pos="5">
          <comment>1：main lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_m4" pos="4">
          <comment>1：m4 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_m3" pos="3">
          <comment>1：m3 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_m2" pos="2">
          <comment>1：m2 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_m1" pos="1">
          <comment>1：m1 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_m0" pos="0">
          <comment>1：m0 lpc进入Low_powe状态，且此时被lp_force强制维持在LP状态，知道lp_force=0</comment>
        </bits>
      </reg>
      <reg name="sysstat07" protect="rw">
        <comment/>
        <bits access="r" name="cp_dbg_monitor" pos="27:20">
          <comment>cp_dbg的monitor信号</comment>
        </bits>
        <bits access="r" name="busmon_busy4" pos="19">
          <comment>master4占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_wbusy4" pos="18">
          <comment>master4写占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_rbusy4" pos="17">
          <comment>master4读占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_busy3" pos="16">
          <comment>master3占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_wbusy3" pos="15">
          <comment>master3写占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_rbusy3" pos="14">
          <comment>master3读占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_busy2" pos="13">
          <comment>master2占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_wbusy2" pos="12">
          <comment>master2写占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_rbusy2" pos="11">
          <comment>master2读占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_busy1" pos="10">
          <comment>master1占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_wbusy1" pos="9">
          <comment>master1写占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_rbusy1" pos="8">
          <comment>master1读占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_busy0" pos="7">
          <comment>master0占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_wbusy0" pos="6">
          <comment>master0写占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon_rbusy0" pos="5">
          <comment>master0读占用总线信号</comment>
        </bits>
        <bits access="r" name="busmon4_lock" pos="4">
          <comment>master4锁死</comment>
        </bits>
        <bits access="r" name="busmon3_lock" pos="3">
          <comment>master3锁死</comment>
        </bits>
        <bits access="r" name="busmon2_lock" pos="2">
          <comment>master2锁死</comment>
        </bits>
        <bits access="r" name="busmon1_lock" pos="1">
          <comment>master1锁死</comment>
        </bits>
        <bits access="r" name="busmon0_lock" pos="0">
          <comment>master0锁死</comment>
        </bits>
      </reg>
      <reg name="sysstat08" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl23" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl24" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl25" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl26" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl27" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl28" protect="rw">
        <comment/>
        <bits access="rw" name="core_stop_bypass" pos="25" rst="0x0">
          <comment>1:cp deep sleep请求不等待CP-A5进入WFI，强制force LPC</comment>
        </bits>
        <bits access="rw" name="light_bypass_wlan" pos="24" rst="0x1">
          <comment>1:进入light sleep后，不管wlan是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_timer4" pos="23" rst="0x1">
          <comment>1:进入light sleep后，不管timer4是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_timer3" pos="22" rst="0x1">
          <comment>1:进入light sleep后，不管timer3是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_sci2" pos="21" rst="0x0">
          <comment>1:进入light sleep后，不管sci2是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_sci1" pos="20" rst="0x0">
          <comment>1:进入light sleep后，不管sci1是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_s6" pos="19" rst="0x1">
          <comment>1:进入light sleep后，不管s6是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_s5" pos="18" rst="0x1">
          <comment>1:进入light sleep后，不管s5是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_s4" pos="17" rst="0x1">
          <comment>1:进入light sleep后，不管s4是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_s3" pos="16" rst="0x1">
          <comment>1:进入light sleep后，不管s3是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_s2" pos="15" rst="0x1">
          <comment>1:进入light sleep后，不管s2是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_s1" pos="14" rst="0x1">
          <comment>1:进入light sleep后，不管s1是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_s0" pos="13" rst="0x1">
          <comment>1:进入light sleep后，不管s0是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_m4" pos="12" rst="0x1">
          <comment>1:进入light sleep后，不管m4是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_m3" pos="11" rst="0x1">
          <comment>1:进入light sleep后，不管m3是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_m2" pos="10" rst="0x0">
          <comment>1:进入light sleep后，不管m2是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_m1" pos="9" rst="0x0">
          <comment>1:进入light sleep后，不管m1是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_m0" pos="8" rst="0x1">
          <comment>1:进入light sleep后，不管m0是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_main_lpc" pos="7" rst="0x0">
          <comment>1:进入light sleep后，不管main_lpc是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_m4_lpc" pos="6" rst="0x0">
          <comment>1:进入light sleep后，不管m4_lpc是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_m3_lpc" pos="5" rst="0x0">
          <comment>1:进入light sleep后，不管m3_lpc是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_m2_lpc" pos="4" rst="0x0">
          <comment>1:进入light sleep后，不管m2_lpc是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_m1_lpc" pos="3" rst="0x0">
          <comment>1:进入light sleep后，不管m1_lpc是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="light_bypass_m0_lpc" pos="2" rst="0x0">
          <comment>1:进入light sleep后，不管m0_lpc是否有传输都进入light sleep功能</comment>
        </bits>
        <bits access="rw" name="cp_light_stop_en" pos="1" rst="0x0">
          <comment>1：cp的light sleep功能关闭</comment>
        </bits>
        <bits access="rw" name="core_int_disable" pos="0" rst="0x0">
          <comment>1：进入deep sleep后，cpu不再接收中断</comment>
        </bits>
      </reg>
      <reg name="sysstat09" protect="rw">
        <comment/>
        <bits access="r" name="reset_dc" pos="31">
          <comment>wlan内部状态信号</comment>
        </bits>
        <bits access="r" name="dc_est_q" pos="30:16">
          <comment>wlan内部状态信号</comment>
        </bits>
        <bits access="r" name="set_dc" pos="15">
          <comment>wlan内部状态信号</comment>
        </bits>
        <bits access="r" name="dc_est_i" pos="14:0">
          <comment>wlan内部状态信号</comment>
        </bits>
      </reg>
      <reg name="sysctrl29" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_main" pos="23:16" rst="0x0">
          <comment>main退出低功耗模式后延迟几个cycle后打开clk</comment>
        </bits>
        <bits access="rw" name="lp_num_main" pos="15:0" rst="0x80">
          <comment>main总线没有传输后，等多少的cycle进入低功耗模式</comment>
        </bits>
      </reg>
      <reg name="sysctrl30" protect="rw">
        <comment/>
        <bits access="rw" name="cp_latch_bitmap" pos="0" rst="0x0">
          <comment>1:cp可通过硬件传数据到rf_bitmap模块，且该模块的数据可以不通过总线直接传到cp</comment>
        </bits>
      </reg>
      <reg name="sysstat10" protect="rw">
        <comment/>
        <bits access="r" name="latch_cnt_122m88_value_m" pos="31:16">
          <comment>122.88M/26M counter计数值，GNSS RTC/CPU/EM Latch、软件Latch使能后更新，共48bit，中间16bits【17：0】为1ms计数循环，【21：18】为10ms计数循环，【48：22】为计满循环，格式同LTE Frame timer3</comment>
        </bits>
        <bits access="r" name="latch_cnt_122m88_value_l" pos="15:0">
          <comment>122.88M/26M counter计数值，GNSS RTC/CPU/EM Latch、软件Latch使能后更新，共48bit，低16bits【17：0】为1ms计数循环，【21：18】为10ms计数循环，【48：22】为计满循环，格式同LTE Frame timer3</comment>
        </bits>
      </reg>
      <reg name="sysstat11" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_wptr" pos="23:16">
          <comment>Bitmap wptr写指针，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
        <bits access="r" name="latch_cnt_122m88_value_h" pos="15:0">
          <comment>122.88M/26M counter计数值，GNSS RTC/CPU/EM Latch、软件Latch使能后更新，共48bit，高16bits【17：0】为1ms计数循环，【21：18】为10ms计数循环，【48：22】为计满循环，格式同LTE Frame timer3</comment>
        </bits>
      </reg>
      <reg name="sysstat12" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num1" pos="31:16">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num0" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat13" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num3" pos="31:16">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num2" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat14" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num5" pos="31:16">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num4" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat15" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num7" pos="31:16">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num6" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat16" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num9" pos="31:16">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num8" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat17" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num11" pos="31:16">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num10" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat18" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num13" pos="31:16">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num12" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat19" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num15" pos="31:16">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num14" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <hole size="6592"/>
      <reg name="sysctrl00_set" protect="rw"/>
      <hole size="64"/>
      <reg name="sysctrl03_set" protect="rw"/>
      <hole size="384"/>
      <reg name="sysctrl16_set" protect="rw"/>
      <reg name="sysctrl17_set" protect="rw"/>
      <reg name="sysctrl18_set" protect="rw"/>
      <reg name="sysctrl19_set" protect="rw"/>
      <reg name="sysctrl20_set" protect="rw"/>
      <reg name="sysctrl21_set" protect="rw"/>
      <reg name="sysctrl22_set" protect="rw"/>
      <hole size="256"/>
      <reg name="sysctrl23_set" protect="rw"/>
      <reg name="sysctrl24_set" protect="rw"/>
      <reg name="sysctrl25_set" protect="rw"/>
      <reg name="sysctrl26_set" protect="rw"/>
      <reg name="sysctrl27_set" protect="rw"/>
      <reg name="sysctrl28_set" protect="rw"/>
      <hole size="7008"/>
      <reg name="sysctrl00_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="sysctrl03_clr" protect="rw"/>
      <hole size="384"/>
      <reg name="sysctrl16_clr" protect="rw"/>
      <reg name="sysctrl17_clr" protect="rw"/>
      <reg name="sysctrl18_clr" protect="rw"/>
      <reg name="sysctrl19_clr" protect="rw"/>
      <reg name="sysctrl20_clr" protect="rw"/>
      <reg name="sysctrl21_clr" protect="rw"/>
      <reg name="sysctrl22_clr" protect="rw"/>
      <hole size="256"/>
      <reg name="sysctrl23_clr" protect="rw"/>
      <reg name="sysctrl24_clr" protect="rw"/>
      <reg name="sysctrl25_clr" protect="rw"/>
      <reg name="sysctrl26_clr" protect="rw"/>
      <reg name="sysctrl27_clr" protect="rw"/>
      <reg name="sysctrl28_clr" protect="rw"/>
    </module>
    <var name="REG_CP_GLB_SET_OFFSET" value="0x400"/>
    <var name="REG_CP_GLB_CLR_OFFSET" value="0x800"/>
    <instance address="0x120c0000" name="CP_GLB" type="CP_GLB"/>
  </archive>
  <archive relative="gnss_sys.xml">
    <module category="System" name="GNSS_SYS">
      <reg name="ahb_eb0" protect="rw">
        <comment>AHB_EB0</comment>
        <bits access="rw" name="mtx_dump_eb" pos="9" rst="0x1">
          <comment>NEW，clk_mtx_dump使能信号，GNSS dump数据处理模块使用</comment>
        </bits>
        <bits access="rw" name="gnss_mtx_eb" pos="8" rst="0x1">
          <comment>原L6第4bit，用于控制GNSS MTX时钟，下式中蓝色字体为该EB信号，cgm_gnss_mtx_en为MTX时钟使能信号：
cgm_gnss_mtx_en = ~cp2gnss_lp_stat | gnss_mtx_en
cp2gnss_lp_stat为CP-sys的LPC状态信号</comment>
        </bits>
        <bits access="rw" name="rfad_spi_wclk_eb" pos="7" rst="0x1">
          <comment>NEW，RFAD_SPI模块功能时钟使能信号</comment>
        </bits>
        <bits access="rw" name="rfad_spi_hclk_eb" pos="6" rst="0x1">
          <comment>NEW，RFAD_SPI模块总线时钟使能信号</comment>
        </bits>
        <bits access="rw" name="pps_wclk_eb" pos="5" rst="0x1">
          <comment>原L6第8bit，PPS模块功能时钟使能信号</comment>
        </bits>
        <bits access="rw" name="pps_hclk_eb" pos="4" rst="0x1">
          <comment>原L6第7bit，PPS模块总线时钟使能信号</comment>
        </bits>
        <bits access="rw" name="rft_wclk_eb" pos="3" rst="0x1">
          <comment>原L6第6bit，RFT模块功能时钟使能信号</comment>
        </bits>
        <bits access="rw" name="rft_hclk_eb" pos="2" rst="0x1">
          <comment>原L6第5bit，RFT模块总线时钟使能信号</comment>
        </bits>
        <bits access="rw" name="lpc_eb" pos="1" rst="0x1">
          <comment>NEW，GNSS2PSRAM异步桥LPC时钟使能信号</comment>
        </bits>
        <bits access="rw" name="clk_reg_eb" pos="0" rst="0x1">
          <comment>NEW，clk_top的总线时钟使能，最好不要关掉</comment>
        </bits>
      </reg>
      <reg name="gnss_bb_en" protect="rw">
        <comment>GNSS_BB_enable</comment>
        <bits access="rw" name="gnss_bb_67m_en" pos="10" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_pps_clk_en" pos="9" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_viterbi_clk_en" pos="8" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_te_fifo_clk_en" pos="7" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_te_mem_clk_en" pos="6" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_cof_mem_clk_en" pos="5" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_ae_fifo_clk_en" pos="4" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_te_clk_en" pos="3" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_ae_clk_en" pos="2" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_pp_clk_en" pos="1" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_hclk_en" pos="0" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
      </reg>
      <reg name="fun_test_mode" protect="rw">
        <comment>FUN_TEST_MODE</comment>
        <bits access="r" name="ptest_func_mode" pos="0" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
      </reg>
      <hole size="1696"/>
      <reg name="ahb_sys_ctl6" protect="rw">
        <comment>AHB_SYS_CTL6</comment>
        <bits access="r" name="ptest" pos="0" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
      </reg>
      <hole size="4320"/>
      <reg name="platform_id" protect="rw">
        <comment>PLATFORM_ID</comment>
      </reg>
      <reg name="project_id" protect="rw">
        <comment>PROJECT_ID</comment>
      </reg>
      <reg name="derived_id" protect="rw">
        <comment>DERIVED_ID</comment>
        <bits access="r" name="derived_id" pos="15:8" rst="0x0">
          <comment>NOT USE，Change the reset value</comment>
        </bits>
        <bits access="r" name="metal_fix_id" pos="7:0" rst="0x0">
          <comment>NOT USE，Change the reset value</comment>
        </bits>
      </reg>
      <reg name="manufacture_id" protect="rw">
        <comment>MANUFACTURE_ID</comment>
        <bits access="r" name="process_id" pos="15:8" rst="0x0">
          <comment>NOT USE，Change the reset value</comment>
        </bits>
        <bits access="r" name="foundry_id" pos="7:0" rst="0x0">
          <comment>NOT USE，Change the reset value</comment>
        </bits>
      </reg>
      <reg name="implementation_id" protect="rw">
        <comment>IMPLEMENTATION_ID</comment>
        <bits access="r" name="mem_compiler" pos="15:8" rst="0x0">
          <comment>NOT USE，Change the reset value</comment>
        </bits>
        <bits access="r" name="std_cell" pos="7:0" rst="0x0">
          <comment>NOT USE，Change the reset value</comment>
        </bits>
      </reg>
      <hole size="1792"/>
      <reg name="cgm_en_ctrl" protect="rw">
        <comment>CGM_EN_CTRL</comment>
        <bits access="rw" name="gnss_ip_rtc_en" pos="4" rst="0x1">
          <comment>原L6第8bit，GNSS_wrap RTC时钟使能</comment>
        </bits>
        <bits access="rw" name="gnss_ip_adc_en" pos="3" rst="0x1">
          <comment>NEW，GNSS_wrap ADC时钟使能</comment>
        </bits>
        <bits access="rw" name="gnss_ip_bb_pp_en" pos="2" rst="0x1">
          <comment>NEW，GNSS_wrap bb_pp时钟使能</comment>
        </bits>
        <bits access="rw" name="gnss_ip_ae_en" pos="1" rst="0x1">
          <comment>NEW,  GNSS_wrap AE_clk使能信号</comment>
        </bits>
        <bits access="rw" name="gnss_ip_en" pos="0" rst="0x1">
          <comment>NEW，GNSS_wrap gnss_clk时钟使能</comment>
        </bits>
      </reg>
      <hole size="352"/>
      <reg name="gnss2psram_lpc_cfg" protect="rw">
        <comment>GNSS2PSRAM_LPC_CFG</comment>
        <bits access="rw" name="gnss2psram_lp_eb" pos="24" rst="0x1">
          <comment>gnss2psram异步桥LPC的使能信号</comment>
        </bits>
        <bits access="rw" name="gnss2psram_lp_pu_num" pos="23:16" rst="0x0">
          <comment>LPC收到开时钟请求后，等待cycle数，一般保持默认不懂</comment>
        </bits>
        <bits access="rw" name="gnss2psram_lp_num" pos="15:0" rst="0x80">
          <comment>LPC收到关时钟请求后，等待cycle数，一般保持默认不懂</comment>
        </bits>
      </reg>
      <reg name="gnss2psram_lpc_status" protect="rw">
        <comment>GNSS2PSRAM_LPC_STATUS</comment>
        <bits access="r" name="gnss2psram_lp_status" pos="0" rst="0x1">
          <comment>LPC状态信号，只读</comment>
        </bits>
      </reg>
      <reg name="gnss2psram_lpc_force" protect="rw">
        <comment>GNSS2PSRAM_LPC_FORCE</comment>
        <bits access="rw" name="gnss2psram_lp_force" pos="1" rst="0x0">
          <comment>LPC的force信号，可以强制开关经过LPC的时钟</comment>
        </bits>
        <bits access="r" name="gnss2psram_lp_force_ack" pos="0" rst="0x0">
          <comment>force_ack信号，只读</comment>
        </bits>
      </reg>
      <hole size="24192"/>
      <reg name="ahb_eb0_set" protect="rw"/>
      <reg name="gnss_bb_en_set" protect="rw"/>
      <hole size="8032"/>
      <reg name="cgm_en_ctrl_set" protect="rw"/>
      <hole size="352"/>
      <reg name="gnss2psram_lpc_cfg_set" protect="rw"/>
      <hole size="24256"/>
      <reg name="ahb_eb0_clr" protect="rw"/>
      <reg name="gnss_bb_en_clr" protect="rw"/>
      <hole size="8032"/>
      <reg name="cgm_en_ctrl_clr" protect="rw"/>
      <hole size="352"/>
      <reg name="gnss2psram_lpc_cfg_clr" protect="rw"/>
      <hole size="24256"/>
      <reg name="soft_rst" protect="rw">
        <comment>SOFT_RST</comment>
        <bits access="rw" name="dump_soft_rst" pos="5" rst="0x0">
          <comment>NEW，dump逻辑的软复位信号，写1复位</comment>
        </bits>
        <bits access="rw" name="gnss_soft_rst" pos="4" rst="0x0">
          <comment>原L6第20bit，GNSS_wrap的软复位，写1复位</comment>
        </bits>
        <bits access="rw" name="rft_soft_rst" pos="3" rst="0x0">
          <comment>原L6第19bit，RFT模块软复位，写1复位</comment>
        </bits>
        <bits access="rw" name="pps_soft_rst" pos="2" rst="0x0">
          <comment>原L6第4bit，PPS模块软复位，写1复位</comment>
        </bits>
        <bits access="rw" name="lpc_soft_rst" pos="1" rst="0x0">
          <comment>NEW，LPC模块软复位，写1复位</comment>
        </bits>
        <bits access="rw" name="rfad_spi_soft" pos="0" rst="0x0">
          <comment>NEW，RFAD_SPI软复位，写1复位</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="pwr_on_rstn_index" protect="rw">
        <comment>PWR_ON_RSTN_INDEX</comment>
        <bits access="rw" name="lna_en" pos="1" rst="0x0">
          <comment>NOT CHANGE，外部低噪声放大器使能信号</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ram_ema" protect="rw">
        <comment>RAM_EMA</comment>
        <bits access="rw" name="gnss_ram_rme_ctrl" pos="14" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_ram_rm_ctrl" pos="13:10" rst="0x2">
          <comment>NOT USE</comment>
        </bits>
      </reg>
      <hole size="416"/>
      <reg name="fpgadebug" protect="rw">
        <comment>FPGADEBUG</comment>
      </reg>
      <hole size="3776"/>
      <reg name="sleep_status" protect="rw">
        <comment>SLEEP_STATUS</comment>
        <bits access="r" name="chip_deep_sleep" pos="0" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
      </reg>
      <hole size="1024"/>
      <reg name="auto_gate_ctrl0" protect="rw">
        <comment>AUTO_GATE_CTRL0</comment>
      </reg>
      <reg name="auto_gate_ctrl1" protect="rw">
        <comment>AUTO_GATE_CTRL1</comment>
      </reg>
      <reg name="auto_gate_ctrl2" protect="rw">
        <comment>AUTO_GATE_CTRL2</comment>
      </reg>
      <reg name="auto_gate_ctrl3" protect="rw">
        <comment>AUTO_GATE_CTRL3</comment>
      </reg>
      <reg name="auto_gate_status0" protect="rw">
        <comment>AUTO_GATE_STATUS0</comment>
      </reg>
      <reg name="auto_gate_status1" protect="rw">
        <comment>AUTO_GATE_STATUS1</comment>
      </reg>
      <reg name="auto_gate_status2" protect="rw">
        <comment>AUTO_GATE_STATUS2</comment>
      </reg>
      <reg name="auto_gate_status3" protect="rw">
        <comment>AUTO_GATE_STATUS3</comment>
      </reg>
      <hole size="224"/>
      <reg name="latch_pulse_num" protect="rw">
        <comment>LATCH_PULSE_NUM</comment>
        <bits access="rw" name="latch_pulse_num" pos="3:0" rst="0xf">
          <comment>GNSS输出的RTC_latch与CPU_latch信号的脉冲拓宽配置，可根据同步时钟频率配置不同脉宽，也可以默认15</comment>
        </bits>
      </reg>
      <reg name="adc_iq_hold_sel" protect="rw">
        <comment>ADC_IQ_HOLD_SEL</comment>
        <bits access="rw" name="adc_iq_hold_sel" pos="0" rst="0x0">
          <comment>GNSS hold时需要将IQ数据切成0，需要RF-sys提供hold使能信号，该使能信号有同步和非同步两种方式，当该bit为1的时候选非同步方式，0即为同步后使能信号将IQ切成0</comment>
        </bits>
      </reg>
      <reg name="async_bridge_dbg_singal_w" protect="rw">
        <comment>ASYNC_BRIDGE_DBG_SINGAL_W</comment>
      </reg>
      <reg name="async_bridge_detector_overflow" protect="rw">
        <comment>ASYNC_BRIDGE_DETECTOR_OVERFLOW</comment>
        <bits access="r" name="axi_detector_overflow" pos="0" rst="0x0">
          <comment>异步桥overflow状态信号，只读</comment>
        </bits>
      </reg>
      <reg name="gps_coexist_in" protect="rw">
        <comment>GPS_COEXIST_IN</comment>
        <bits access="rw" name="gps_coexist_in" pos="0" rst="0x0">
          <comment>GNSS_wrap的GPS共存信号</comment>
        </bits>
      </reg>
      <reg name="axi_reg_slice_ds_force" protect="rw">
        <comment>AXI_REG_SLICE_DS_FORCE</comment>
        <bits access="rw" name="dowm_sream_disable_force" pos="1" rst="0x0">
          <comment>AXI anti_hang功能</comment>
        </bits>
        <bits access="rw" name="dowm_sream_disable_force_sel" pos="0" rst="0x1">
          <comment>AXI anti_hang功能，默认选择dowm_sream_disable_force，写0表示选择AXI通路下游的ISO_EN</comment>
        </bits>
      </reg>
      <reg name="gnss_axi_qos" protect="rw">
        <comment>AXI_REG_SLICE_DS_FORCE</comment>
        <bits access="rw" name="gnss_awqos" pos="7:4" rst="0x0">
          <comment>GNSS to PSRAM AWQOS config</comment>
        </bits>
        <bits access="rw" name="gnss_arqos" pos="3:0" rst="0x0">
          <comment>GNSS to PSRAM ARQOS config</comment>
        </bits>
      </reg>
      <reg name="gnss_ahb_err_resp_en" protect="rw">
        <comment>AXI_REG_SLICE_DS_FORCE</comment>
        <bits access="rw" name="ahb_err_resp_en" pos="0" rst="0x0">
          <comment>AHB Anti_hang err resp en，active high，force to resp err</comment>
        </bits>
      </reg>
      <hole size="26592"/>
      <reg name="soft_rst_set" protect="rw"/>
      <hole size="5888"/>
      <reg name="latch_pulse_num_set" protect="rw"/>
      <reg name="adc_iq_hold_sel_set" protect="rw"/>
      <hole size="64"/>
      <reg name="gps_coexist_in_set" protect="rw"/>
      <reg name="axi_reg_slice_ds_force_set" protect="rw"/>
      <reg name="gnss_axi_qos_set" protect="rw"/>
      <reg name="gnss_ahb_err_resp_en_set" protect="rw"/>
      <hole size="26592"/>
      <reg name="soft_rst_clr" protect="rw"/>
      <hole size="5888"/>
      <reg name="latch_pulse_num_clr" protect="rw"/>
      <reg name="adc_iq_hold_sel_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="gps_coexist_in_clr" protect="rw"/>
      <reg name="axi_reg_slice_ds_force_clr" protect="rw"/>
      <reg name="gnss_axi_qos_clr" protect="rw"/>
      <reg name="gnss_ahb_err_resp_en_clr" protect="rw"/>
    </module>
    <var name="REG_GNSS_SYS_SET_OFFSET" value="0x1000"/>
    <var name="REG_GNSS_SYS_CLR_OFFSET" value="0x2000"/>
    <instance address="0x1c000000" name="GNSS_SYS" type="GNSS_SYS"/>
  </archive>
  <archive relative="gnss_clk.xml">
    <module category="System" name="GNSS_CLK">
      <hole size="320"/>
      <reg name="cgm_gnss_mtx_sel_cfg" protect="rw">
        <comment>cgm_gnss_mtx_sel_cfg clk_mtx_sel</comment>
        <bits access="rw" name="cgm_gnss_mtx_sel" pos="2:0" rst="0x0">
          <comment>0: 26m, 1: 62.5m, 2: 125m, 3: 133m, 4: 158m, 5:167m</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_gnss_bb_pp_sel_cfg" protect="rw">
        <comment>cgm_gnss_bb_pp_sel_cfg clk_bb_pp_sel</comment>
        <bits access="rw" name="cgm_gnss_bb_pp_sel" pos="16" rst="0x0">
          <comment>not use</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_gnss_adc_sel_cfg" protect="rw">
        <comment>cgm_gnss_adc_sel_cfg clk_adc_sel</comment>
        <bits access="rw" name="cgm_gnss_adc_sel" pos="16" rst="0x0"/>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg0" protect="rw">
        <comment>cgm_busy_src_monitor_cfg0 cgm_busy_monitor</comment>
        <bits access="r" name="cgm_busy_src_monitor0" pos="8:0" rst="0x40">
          <comment>cgm_busy monitor</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x1c010000" name="GNSS_CLK" type="GNSS_CLK"/>
  </archive>
  <archive relative="gnss_spi.xml">
    <module category="System" name="GNSS_SPI">
      <reg name="spi_cfg" protect="rw">
        <comment>SPI_CFG</comment>
        <bits access="rw" name="spi_rw" pos="30" rst="0x0">
          <comment>0: write ; 1 : read</comment>
        </bits>
        <bits access="rw" name="distance" pos="29:26" rst="0x3">
          <comment>两次相邻操作，SE无效时最小时间，sclk时钟个数的一半</comment>
        </bits>
        <bits access="rw" name="frq_div_rd" pos="25:23" rst="0x1">
          <comment>读分频系数：4 + FRQ_DIV_RD*2</comment>
        </bits>
        <bits access="rw" name="frq_div_wr" pos="22:20" rst="0x1">
          <comment>读分频系数：4 + FRQ_DIV_WR*2</comment>
        </bits>
        <bits access="rw" name="cs_inv" pos="19" rst="0x0">
          <comment>半双工读数据时片选信号反相使能
0：不反向；1：反相</comment>
        </bits>
        <bits access="rw" name="dux" pos="18" rst="0x0">
          <comment>双工模式选择，0：半；1：全</comment>
        </bits>
        <bits access="rw" name="ms" pos="17" rst="0x0">
          <comment>接受数据时模式选择
0：3线（只支持半双工读）；1：4线</comment>
        </bits>
        <bits access="rw" name="rd_inter" pos="16:15" rst="0x2">
          <comment>SPI半双工读选择间隔第几个SPI时钟采样，default：2</comment>
        </bits>
        <bits access="rw" name="rd_edge" pos="14" rst="0x0">
          <comment>读数据采样沿
0：相反沿采数据，与发送沿为反相沿（全双工时必须为0）
1：同沿采数据，与发送沿为同一沿</comment>
        </bits>
        <bits access="rw" name="sec" pos="13" rst="0x0">
          <comment>片选使能控制选择
0：片选在时钟之前有效（normal）
1：片选在时钟之后有效（DIG_RF）</comment>
        </bits>
        <bits access="rw" name="cpha" pos="12" rst="0x1">
          <comment>SPI时钟相位控制
0:数据采样发生在时钟奇数沿
1：数据采样发生在时钟偶数沿</comment>
        </bits>
        <bits access="rw" name="cpol" pos="11" rst="0x0">
          <comment>SPI时钟极性控制
0：SPI接口在IDLE状态时，时钟为低电平；
1：SPI接口在IDLE状态时，时钟为高电平；</comment>
        </bits>
        <bits access="rw" name="spol" pos="10" rst="0x0">
          <comment>SPI片选极性控制
0：SPI片选低有效
1：SPI片选高有效</comment>
        </bits>
        <bits access="rw" name="rx_data_len" pos="9:5" rst="0xf">
          <comment>SPI接收数据长度，default = 16bit</comment>
        </bits>
        <bits access="rw" name="tx_data_len" pos="4:0" rst="0x1f">
          <comment>SPI发送数据长度，default = 32bit</comment>
        </bits>
      </reg>
      <reg name="spi_rxdata" protect="rw">
        <comment>SPI_RXDATA</comment>
      </reg>
      <reg name="spi_immdata" protect="rw">
        <comment>SPI_IMMDATA</comment>
      </reg>
      <hole size="32"/>
      <reg name="spi_status" protect="rw">
        <comment>SPI_STATUS</comment>
        <bits access="r" name="spi_status" pos="0" rst="0x0">
          <comment>1：SPI正在传输；0：传输完成</comment>
        </bits>
      </reg>
      <hole size="32608"/>
      <reg name="spi_cfg_set" protect="rw"/>
      <hole size="32"/>
      <reg name="spi_immdata_set" protect="rw"/>
      <hole size="32672"/>
      <reg name="spi_cfg_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="spi_immdata_clr" protect="rw"/>
    </module>
    <var name="REG_GNSS_SPI_SET_OFFSET" value="0x1000"/>
    <var name="REG_GNSS_SPI_CLR_OFFSET" value="0x2000"/>
    <instance address="0x1c040000" name="GNSS_SPI" type="GNSS_SPI"/>
  </archive>
  <archive relative="iomux.xml">
    <module category="System" name="IOMUX">
      <reg name="pwr_pad_ctl" protect="rw">
        <comment>Reserved address for Power Pad control registers</comment>
        <bits access="rw" name="pwrreg_ms_v_mmc_18_30" pos="20" rst="0x1">
          <comment>Power control pin[MS] for power [V_MMC_18_30]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_v_mmc_18_30" pos="19" rst="0x0">
          <comment>Power control pin[MSOUT] for power [V_MMC_18_30]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_v_mmc_18_30" pos="18" rst="0x0">
          <comment>Power control pin[MSEN] for power [V_MMC_18_30]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_v_lcd_18_33" pos="17" rst="0x1">
          <comment>Power control pin[MS] for power [V_LCD_18_33]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_v_lcd_18_33" pos="16" rst="0x0">
          <comment>Power control pin[MSOUT] for power [V_LCD_18_33]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_v_lcd_18_33" pos="15" rst="0x0">
          <comment>Power control pin[MSEN] for power [V_LCD_18_33]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_vddio_18_33" pos="14" rst="0x1">
          <comment>Power control pin[MS] for power [VDDIO_18_33]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_vddio_18_33" pos="13" rst="0x0">
          <comment>Power control pin[MSOUT] for power [VDDIO_18_33]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_vddio_18_33" pos="12" rst="0x0">
          <comment>Power control pin[MSEN] for power [VDDIO_18_33]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_vsim0" pos="11" rst="0x1">
          <comment>Power control pin[MS] for power [VSIM0]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_vsim0" pos="10" rst="0x0">
          <comment>Power control pin[MSOUT] for power [VSIM0]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_vsim0" pos="9" rst="0x0">
          <comment>Power control pin[MSEN] for power [VSIM0]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_vsim1" pos="8" rst="0x1">
          <comment>Power control pin[MS] for power [VSIM1]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_vsim1" pos="7" rst="0x0">
          <comment>Power control pin[MSOUT] for power [VSIM1]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_vsim1" pos="6" rst="0x0">
          <comment>Power control pin[MSEN] for power [VSIM1]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_vlpvddio1833_1" pos="5" rst="0x1">
          <comment>Power control pin[MS] for power [VLPVDDIO1833_1]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_vlpvddio1833_1" pos="4" rst="0x0">
          <comment>Power control pin[MSOUT] for power [VLPVDDIO1833_1]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_vlpvddio1833_1" pos="3" rst="0x0">
          <comment>Power control pin[MSEN] for power [VLPVDDIO1833_1]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_lpvddio_18_33" pos="2" rst="0x1">
          <comment>Power control pin[MS] for power [LPVDDIO_18_33]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_lpvddio_18_33" pos="1" rst="0x0">
          <comment>Power control pin[MSOUT] for power [LPVDDIO_18_33]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_lpvddio_18_33" pos="0" rst="0x0">
          <comment>Power control pin[MSEN] for power [LPVDDIO_18_33]</comment>
        </bits>
      </reg>
      <reg name="pin_ctrl_reg0" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="pin_ctrl_reg1" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="pin_ctrl_reg2" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="pin_ctrl_reg3" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="pin_ctrl_reg4" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="pin_ctrl_reg5" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="rfdig_gpio_7" protect="rw">
        <comment>Pad u_RFDIG_GPIO_7 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio7
     3: lte_gpo_8</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_6" protect="rw">
        <comment>Pad u_RFDIG_GPIO_6 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio6
     3: lte_gpo_7</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_5" protect="rw">
        <comment>Pad u_RFDIG_GPIO_5 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio5
     3: lte_gpo_5</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_4" protect="rw">
        <comment>Pad u_RFDIG_GPIO_4 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio4
     3: lte_gpo_4</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_3" protect="rw">
        <comment>Pad u_RFDIG_GPIO_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio3
     3: lte_gpo_3</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_2" protect="rw">
        <comment>Pad u_RFDIG_GPIO_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio2
     3: lte_gpo_2</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_1" protect="rw">
        <comment>Pad u_u_RFDIG_GPIO_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rffe_sda
     1: rf_gpio1
     3: lte_gpo_1</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_0" protect="rw">
        <comment>Pad u_RFDIG_GPIO_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: rffe_sck
     1: rf_gpio0
     3: lte_gpo_0</comment>
        </bits>
      </reg>
      <reg name="keyin_4" protect="rw">
        <comment>Pad u_KEYIN_4 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_4
     1: gpio_8
     2: pwm_0
     3: pwm_4
     4: i2c_m2_scl
     6: debug_bus_12
     7: uart_5_rxd</comment>
        </bits>
      </reg>
      <reg name="keyout_5" protect="rw">
        <comment>Pad u_KEYOUT_5 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_5
     1: gpio_11
     2: pwm_3
     3: uart_4_txd
     7: uart_5_rts</comment>
        </bits>
      </reg>
      <reg name="keyin_5" protect="rw">
        <comment>Pad u_KEYIN_5 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_5
     1: gpio_9
     2: pwm_1
     3: pwm_5
     4: i2c_m2_sda
     7: uart_5_txd</comment>
        </bits>
      </reg>
      <reg name="keyout_4" protect="rw">
        <comment>Pad u_KEYOUT_4 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_4
     1: gpio_10
     2: pwm_2
     3: uart_4_rxd
     7: uart_5_cts</comment>
        </bits>
      </reg>
      <reg name="uart_1_rts" protect="rw">
        <comment>Pad u_UART_1_RTS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_1_rts
     1: pwm_3
     2: pwm_11
     3: uart_2_rxd
     4: gpio_15</comment>
        </bits>
      </reg>
      <reg name="uart_1_txd" protect="rw">
        <comment>Pad u_UART_1_TXD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_1_txd
     1: gpio_13</comment>
        </bits>
      </reg>
      <reg name="uart_1_rxd" protect="rw">
        <comment>Pad u_UART_1_RXD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_1_rxd
     1: gpio_12</comment>
        </bits>
      </reg>
      <reg name="uart_1_cts" protect="rw">
        <comment>Pad u_UART_1_CTS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_1_cts
     1: gpio_14
     2: pwm_10
     3: uart_2_txd</comment>
        </bits>
      </reg>
      <reg name="gpio_0" protect="rw">
        <comment>Pad u_GPIO_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_0
     1: spi_2_clk
     3: uart_1_rxd
     4: uart_3_rxd
     5: pwm_8
     6: debug_clk
     7: uart_2_rxd</comment>
        </bits>
      </reg>
      <reg name="gpio_3" protect="rw">
        <comment>Pad u_GPIO_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_3
     1: spi_2_di_1
     3: uart_1_rts
     4: uart_4_txd
     5: pwm_11
     6: debug_bus_2
     7: uart_2_rts</comment>
        </bits>
      </reg>
      <reg name="gpio_2" protect="rw">
        <comment>Pad u_GPIO_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_2
     1: spi_2_dio_0
     3: uart_1_cts
     4: uart_4_rxd
     5: pwm_10
     6: debug_bus_1
     7: uart_2_cts</comment>
        </bits>
      </reg>
      <reg name="gpio_1" protect="rw">
        <comment>Pad u_GPIO_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_1
     1: spi_2_cs_0
     3: uart_1_txd
     4: uart_3_txd
     5: pwm_9
     6: debug_bus_0
     7: uart_2_txd</comment>
        </bits>
      </reg>
      <reg name="gpio_7" protect="rw">
        <comment>Pad u_GPIO_7 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_7
     1: pwm_2
     2: i2c_m2_sda
     3: uart_6_txd
     4: uart_3_txd</comment>
        </bits>
      </reg>
      <reg name="gpio_6" protect="rw">
        <comment>Pad u_GPIO_6 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_6
     1: pwm_1
     2: i2c_m2_scl
     3: uart_6_rxd
     4: uart_3_rxd</comment>
        </bits>
      </reg>
      <reg name="gpio_5" protect="rw">
        <comment>Pad u_GPIO_5 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_5
     1: pwm_0
     3: uart_5_txd
     4: uart_3_rts
     5: test_clkout
     6: debug_bus_4</comment>
        </bits>
      </reg>
      <reg name="gpio_4" protect="rw">
        <comment>Pad u_GPIO_4 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_4
     1: spi_2_cs_1
     3: uart_5_rxd
     4: uart_3_cts
     5: pwm_12
     6: debug_bus_3</comment>
        </bits>
      </reg>
      <reg name="adi_sda" protect="rw">
        <comment>Pad u_ADI_SDA control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ADI_SDA</comment>
        </bits>
      </reg>
      <reg name="adi_scl" protect="rw">
        <comment>Pad u_ADI_SCL control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ADI_SCL</comment>
        </bits>
      </reg>
      <reg name="resetb" protect="rw">
        <comment>Pad u_RESETB control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: RESETB</comment>
        </bits>
      </reg>
      <reg name="osc_32k" protect="rw">
        <comment>Pad u_OSC_32K control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: OSC_32K</comment>
        </bits>
      </reg>
      <reg name="pmic_ext_int" protect="rw">
        <comment>Pad u_PMIC_EXT_INT control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: PMIC_EXT_INT</comment>
        </bits>
      </reg>
      <reg name="chip_pd" protect="rw">
        <comment>Pad u_CHIP_PD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: CHIP_PD</comment>
        </bits>
      </reg>
      <reg name="ptest" protect="rw">
        <comment>Pad u_PTEST control</comment>
      </reg>
      <reg name="clk26m_pmic" protect="rw">
        <comment>Pad u_CLK26M_PMIC control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: clk26m_pmic</comment>
        </bits>
      </reg>
      <reg name="sim_1_rst" protect="rw">
        <comment>Pad u_SIM_1_RST control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_1_rst
     1: gpio_32
     2: pwm_6</comment>
        </bits>
      </reg>
      <reg name="sim_1_dio" protect="rw">
        <comment>Pad u_SIM_1_DIO control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_1_dio
     1: gpio_31
     2: pwm_5</comment>
        </bits>
      </reg>
      <reg name="sim_1_clk" protect="rw">
        <comment>Pad u_SIM_1_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_1_clk
     1: gpio_30
     2: pwm_4</comment>
        </bits>
      </reg>
      <reg name="sim_0_rst" protect="rw">
        <comment>Pad u_SIM_0_RST control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_0_rst</comment>
        </bits>
      </reg>
      <reg name="sim_0_dio" protect="rw">
        <comment>Pad u_SIM_0_DIO control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_0_dio</comment>
        </bits>
      </reg>
      <reg name="sim_0_clk" protect="rw">
        <comment>Pad u_SIM_0_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_0_clk</comment>
        </bits>
      </reg>
      <reg name="sw_clk" protect="rw">
        <comment>Pad u_SW_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ap_jtag_tck
     1: gpio_24
     3: spi_1_clk
     4: sdmmc2_clk
     6: tsx_adc_ch_sel</comment>
        </bits>
      </reg>
      <reg name="sw_dio" protect="rw">
        <comment>Pad u_SW_DIO control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ap_jtag_tms
     1: gpio_25
     3: spi_1_cs_0
     4: sdmmc2_cmd
     6: tsx_adc_clk</comment>
        </bits>
      </reg>
      <reg name="debug_host_tx" protect="rw">
        <comment>Pad u_DEBUG_HOST_TX control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ap_jtag_tdo
     1: gpio_27
     2: debug_host_tx
     3: spi_1_di_1
     4: sdmmc2_data_1
     6: osc_adc_clk</comment>
        </bits>
      </reg>
      <reg name="debug_host_rx" protect="rw">
        <comment>Pad u_DEBUG_HOST_RX control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ap_jtag_tdi
     1: gpio_26
     2: debug_host_rx
     3: spi_1_dio_0
     4: sdmmc2_data_0
     6: tsx_adc_ch_data</comment>
        </bits>
      </reg>
      <reg name="debug_host_clk" protect="rw">
        <comment>Pad u_DEBUG_HOST_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ap_jtag_trst
     1: gpio_28
     2: debug_host_clk
     3: spi_1_cs_1
     4: sdmmc2_data_2
     6: osc_adc_data</comment>
        </bits>
      </reg>
      <reg name="camera_rst_l" protect="rw">
        <comment>Pad u_CAMERA_RST_L control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: camera_rst_l
     1: pwm_6
     2: i2c_m3_scl
     3: gpio_44
     6: debug_bus_2
     8: DBG_DO_11</comment>
        </bits>
      </reg>
      <reg name="spi_camera_sck" protect="rw">
        <comment>Pad u_SPI_CAMERA_SCK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_camera_sck
     1: pwm_9
     2: gpio_18
     3: aud_da_d1
     6: debug_bus_7</comment>
        </bits>
      </reg>
      <reg name="spi_camera_si_1" protect="rw">
        <comment>Pad u_SPI_CAMERA_SI_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_camera_si_1
     1: i2c_m2_sda
     2: spi_camera_si_0
     3: spi_camera_ssn
     6: debug_bus_6</comment>
        </bits>
      </reg>
      <reg name="spi_camera_si_0" protect="rw">
        <comment>Pad u_SPI_CAMERA_SI_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_camera_si_0
     1: i2c_m2_scl
     2: spi_camera_si_1
     3: gpio_47
     6: CTS
     8: DBG_CLK</comment>
        </bits>
      </reg>
      <reg name="camera_ref_clk" protect="rw">
        <comment>Pad u_CAMERA_REF_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: camera_ref_clk
     1: pwm_8
     2: gpio_46
     6: debug_bus_4
     8: DBG_TRIG</comment>
        </bits>
      </reg>
      <reg name="camera_pwdn" protect="rw">
        <comment>Pad u_CAMERA_PWDN control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: camera_pwdn
     1: pwm_7
     2: i2c_m3_sda
     3: gpio_45
     6: debug_bus_3
     7: GPADC_IN3
     8: DBG_DO_12</comment>
        </bits>
      </reg>
      <reg name="i2s_sdat_i" protect="rw">
        <comment>Pad u_I2S_SDAT_I control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2s1_sdat_i
     1: pwm_10
     2: gpio_21
     3: aud_ad_d0
     4: i2c_m3_scl
     8: DBG_DO_15</comment>
        </bits>
      </reg>
      <reg name="i2s1_sdat_o" protect="rw">
        <comment>Pad u_I2S1_SDAT_O control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: i2s1_sdat_o
     1: pwm_11
     2: gpio_22
     3: aud_sclk
     4: i2c_m3_sda</comment>
        </bits>
      </reg>
      <reg name="i2s1_lrck" protect="rw">
        <comment>Pad u_I2S1_LRCK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2s1_lrck
     1: i2c_m3_sda
     2: gpio_20
     3: aud_ad_sync
     8: DBG_DO_14</comment>
        </bits>
      </reg>
      <reg name="i2s1_bck" protect="rw">
        <comment>Pad u_I2S1_BCK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2s1_bck
     1: i2c_m3_scl
     2: gpio_19
     3: aud_da_d0
     8: DBG_DO_13</comment>
        </bits>
      </reg>
      <reg name="i2s1_mclk" protect="rw">
        <comment>Pad u_I2S1_MCLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: i2s1_mclk
     1: gpio_46</comment>
        </bits>
      </reg>
      <reg name="i2c_m2_scl" protect="rw">
        <comment>Pad u_I2C_M2_SCL control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2c_m2_scl
     1: pwm_4
     2: gpio_42
     3: aud_da_sync
     6: debug_bus_0
     8: DBG_DO_9</comment>
        </bits>
      </reg>
      <reg name="i2c_m2_sda" protect="rw">
        <comment>Pad u_I2C_M2_SDA control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2c_m2_sda
     1: pwm_5
     2: gpio_43
     3: aud_da_d1
     6: debug_bus_1
     8: DBG_DO_10</comment>
        </bits>
      </reg>
      <reg name="nand_sel" protect="rw">
        <comment>Pad u_Nand_sel control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: Nand_sel</comment>
        </bits>
      </reg>
      <reg name="keyout_3" protect="rw">
        <comment>Pad u_KEYOUT_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_3
     1: gpio_35
     3: i2c_m1_sda
     6: debug_clk</comment>
        </bits>
      </reg>
      <reg name="keyout_2" protect="rw">
        <comment>Pad u_KEYOUT_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_2
     1: gpio_34
     3: i2c_m1_scl
     6: debug_bus_15</comment>
        </bits>
      </reg>
      <reg name="keyout_1" protect="rw">
        <comment>Pad u_KEYOUT_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_1
     1: gpio_33
     2: uart_6_txd
     3: pwm_7
     6: debug_bus_14</comment>
        </bits>
      </reg>
      <reg name="keyout_0" protect="rw">
        <comment>Pad u_KEYOUT_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_0
     1: gpio_32
     2: uart_6_rxd
     3: pwm_6
     6: debug_bus_13</comment>
        </bits>
      </reg>
      <reg name="keyin_3" protect="rw">
        <comment>Pad u_KEYIN_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_3
     1: gpio_31
     2: uart_4_txd
     6: debug_bus_11</comment>
        </bits>
      </reg>
      <reg name="keyin_2" protect="rw">
        <comment>Pad u_KEYIN_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_2
     1: gpio_30
     2: uart_4_rxd
     6: debug_bus_10</comment>
        </bits>
      </reg>
      <reg name="keyin_1" protect="rw">
        <comment>Pad u_KEYIN_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_1
     1: gpio_29
     2: pwm_15
     6: debug_bus_9</comment>
        </bits>
      </reg>
      <reg name="keyin_0" protect="rw">
        <comment>Pad u_KEYIN_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_0
     1: gpio_28
     2: pwm_14
     6: debug_bus_8</comment>
        </bits>
      </reg>
      <reg name="lcd_rstb" protect="rw">
        <comment>Pad u_LCD_RSTB control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: lcd_rstb
     2: gpio_41
     6: debug_bus_11</comment>
        </bits>
      </reg>
      <reg name="lcd_fmark" protect="rw">
        <comment>Pad u_LCD_FMARK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: lcd_fmark
     1: spi_flash1_sio_3
     2: gpio_40
     6: debug_bus_10
     7: GPADC_IN2
     8: DBG_DO_8</comment>
        </bits>
      </reg>
      <reg name="spi_lcd_select" protect="rw">
        <comment>Pad u_SPI_LCD_SELECT control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_lcd_select
     1: spi_flash1_sio_2
     2: gpio_39
     6: debug_bus_9
     8: DBG_DO_7</comment>
        </bits>
      </reg>
      <reg name="spi_lcd_cs" protect="rw">
        <comment>Pad u_SPI_LCD_CS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_lcd_cs
     1: spi_flash1_sio_1
     2: gpio_38
     6: debug_bus_8
     8: DBG_DO_6</comment>
        </bits>
      </reg>
      <reg name="spi_lcd_clk" protect="rw">
        <comment>Pad u_SPI_LCD_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_lcd_clk
     1: spi_flash1_sio_0
     2: gpio_37
     6: debug_bus_7
     8: DBG_DO_5</comment>
        </bits>
      </reg>
      <reg name="spi_lcd_sdc" protect="rw">
        <comment>Pad u_SPI_LCD_SDC control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_lcd_sdc
     1: spi_flash1_cs
     2: gpio_36
     6: debug_bus_6
     7: GPADC_IN1
     8: DBG_DO_4</comment>
        </bits>
      </reg>
      <reg name="spi_lcd_sio" protect="rw">
        <comment>Pad u_SPI_LCD_SIO control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_lcd_sio
     1: spi_flash1_clk
     2: gpio_35
     6: debug_bus_5
     8: DBG_DO_3</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_rst" protect="rw">
        <comment>Pad u_SDMMC1_RST control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_RST
     1: gpio_36</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_7" protect="rw">
        <comment>Pad u_SDMMC1_DATA_7 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_7
     1: gpio_27
     2: pwm_13
     3: i2c_m2_sda
     4: spi_1_cs_1
     5: uart_4_txd
     6: spi_flash1_sio_3
     7: timestamp_out
     8: dbgio_data7</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_6" protect="rw">
        <comment>Pad u_SDMMC1_DATA_6 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_6
     1: gpio_26
     2: pwm_12
     3: i2c_m2_scl
     4: spi_1_di_1
     5: uart_4_rxd
     6: spi_flash1_sio_2
     7: timestamp_in
     8: dbgio_data6</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_5" protect="rw">
        <comment>Pad u_SDMMC1_DATA_5 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_5
     1: gpio_25
     2: i2c_m1_sda
     3: timestamp_out
     4: spi_1_dio_0
     5: uart_4_rts
     6: spi_flash1_sio_1
     7: PPS_OUT
     8: dbgio_data5</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_4" protect="rw">
        <comment>Pad u_SDMMC1_DATA_4 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_4
     1: gpio_24
     2: i2c_m1_scl
     3: timestamp_in
     4: spi_1_cs_0
     5: uart_4_cts
     6: spi_flash1_sio_0
     7: Lna_en
     8: dbgio_data4</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_3" protect="rw">
        <comment>Pad u_SDMMC1_DATA_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_3
     1: gpio_21
     2: spi_camera_sck
     3: pwm_15
     4: spi_1_clk
     5: uart_3_txd
     6: spi_flash1_cs
     8: dbgio_data3</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_2" protect="rw">
        <comment>Pad u_SDMMC1_DATA_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_2
     1: gpio_20
     2: spi_camera_si_1
     3: spi_camera_si_0
     4: spi_2_cs_1
     5: uart_3_rxd
     6: spi_flash1_clk
     8: dbgio_data2</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_1" protect="rw">
        <comment>Pad u_SDMMC1_DATA_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_1
     1: gpio_19
     2: spi_camera_si_0
     3: spi_camera_si_1
     4: spi_2_di_1
     5: uart_5_txd
     6: uart_6_rts
     8: dbgio_data1</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_0" protect="rw">
        <comment>Pad u_SDMMC1_DATA_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_0
     1: gpio_18
     2: camera_ref_clk
     3: i2c_m1_sda
     4: spi_2_dio_0
     5: uart_5_rxd
     6: uart_6_cts
     8: dbgio_data0</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_cmd" protect="rw">
        <comment>Pad u_SDMMC1_CMD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_CMD
     1: gpio_17
     2: camera_pwdn
     3: i2c_m1_scl
     4: spi_2_cs_0
     5: uart_2_txd
     6: uart_6_txd
     8: dbgio_cmd</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_clk" protect="rw">
        <comment>Pad u_SDMMC1_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_CLK
     1: gpio_16
     2: camera_rst_l
     3: pwm_14
     4: spi_2_clk
     5: uart_2_rxd
     6: uart_6_rxd
     8: dbgio_clk</comment>
        </bits>
      </reg>
      <reg name="uart_2_rts" protect="rw">
        <comment>Pad u_UART_2_RTS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_2_rts
     1: gpio_34
     2: uart_2_rxd
     3: i2c_m3_sda
     4: uart_4_txd</comment>
        </bits>
      </reg>
      <reg name="uart_2_cts" protect="rw">
        <comment>Pad u_UART_2_CTS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_2_cts
     1: gpio_33
     2: uart_2_txd
     3: i2c_m3_scl
     4: uart_4_rxd</comment>
        </bits>
      </reg>
      <reg name="uart_2_txd" protect="rw">
        <comment>Pad u_UART_2_TXD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_2_txd
     1: i2c_m1_sda
     2: pwm_13
     3: gpio_32
     4: uart_3_txd</comment>
        </bits>
      </reg>
      <reg name="uart_2_rxd" protect="rw">
        <comment>Pad u_UART_2_RXD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_2_rxd
     1: i2c_m1_scl
     2: pwm_12
     3: gpio_31
     4: uart_3_rxd</comment>
        </bits>
      </reg>
      <reg name="i2c_m1_sda" protect="rw">
        <comment>Pad u_I2C_M1_SDA control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2c_m1_sda
     1: gpio_30
     2: uart_4_txd
     4: rf_gpio8</comment>
        </bits>
      </reg>
      <reg name="i2c_m1_scl" protect="rw">
        <comment>Pad u_I2C_M1_SCL control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2c_m1_scl
     1: gpio_29
     2: uart_4_rxd
     4: rf_gpio9</comment>
        </bits>
      </reg>
      <reg name="gpio_23" protect="rw">
        <comment>Pad u_GPIO_23 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_23
     1: spi_flash1_sio_3
     2: pwm_9
     3: sdmmc2_data_3
     4: rf_gpio8</comment>
        </bits>
      </reg>
      <reg name="gpio_22" protect="rw">
        <comment>Pad u_GPIO_22 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_22
     1: spi_flash1_sio_2
     2: spi_2_cs_1
     3: sdmmc2_data_2
     4: rf_gpio9
     5: osc_adc_data</comment>
        </bits>
      </reg>
      <reg name="gpio_21" protect="rw">
        <comment>Pad u_GPIO_21 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_21
     1: spi_flash1_sio_1
     2: spi_2_di_1
     3: sdmmc2_data_1
     5: osc_adc_clk</comment>
        </bits>
      </reg>
      <reg name="gpio_20" protect="rw">
        <comment>Pad u_GPIO_20 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_20
     1: spi_flash1_sio_0
     2: spi_2_dio_0
     3: sdmmc2_data_0
     4: pwm_15
     5: tsx_adc_ch_data</comment>
        </bits>
      </reg>
      <reg name="gpio_19" protect="rw">
        <comment>Pad u_GPIO_19 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_19
     1: spi_flash1_cs
     2: spi_2_cs_0
     3: sdmmc2_cmd
     4: pwm_14
     5: tsx_adc_clk</comment>
        </bits>
      </reg>
      <reg name="gpio_18" protect="rw">
        <comment>Pad u_GPIO_18 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_18
     1: spi_flash1_clk
     2: spi_2_clk
     3: sdmmc2_clk
     4: pwm_13
     5: tsx_adc_ch_sel
     6: digrf_strobe_s_o</comment>
        </bits>
      </reg>
      <reg name="gpio_17" protect="rw">
        <comment>Pad u_GPIO_17 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_17
     1: uart_3_rxd
     2: pwm_8
     3: i2c_m3_sda
     5: PPS_OUT
     6: uart_2_rts</comment>
        </bits>
      </reg>
      <reg name="gpio_16" protect="rw">
        <comment>Pad u_GPIO_16 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_16
     1: uart_3_txd
     2: pwm_7
     3: i2c_m3_scl
     4: sdmmc2_data_3
     5: Lna_en
     6: uart_2_cts</comment>
        </bits>
      </reg>
      <reg name="m_spi_d_3" protect="rw">
        <comment>Pad u_M_SPI_D_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_D_3</comment>
        </bits>
      </reg>
      <reg name="m_spi_d_2" protect="rw">
        <comment>Pad u_M_SPI_D_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_D_2</comment>
        </bits>
      </reg>
      <reg name="m_spi_d_1" protect="rw">
        <comment>Pad u_M_SPI_D_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_D_1</comment>
        </bits>
      </reg>
      <reg name="m_spi_d_0" protect="rw">
        <comment>Pad u_M_SPI_D_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_D_0</comment>
        </bits>
      </reg>
      <reg name="m_spi_cs" protect="rw">
        <comment>Pad u_M_SPI_CS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_CS</comment>
        </bits>
      </reg>
      <reg name="m_spi_clk" protect="rw">
        <comment>Pad u_M_SPI_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_CLK</comment>
        </bits>
      </reg>
      <hole size="4896"/>
      <reg name="pad_rfdig_gpio_7" protect="rw">
        <comment>Pad u_RFDIG_GPIO_7 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_6" protect="rw">
        <comment>Pad u_RFDIG_GPIO_6 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_5" protect="rw">
        <comment>Pad u_RFDIG_GPIO_5 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_4" protect="rw">
        <comment>Pad u_RFDIG_GPIO_4 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_3" protect="rw">
        <comment>Pad u_RFDIG_GPIO_3 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_2" protect="rw">
        <comment>Pad u_RFDIG_GPIO_2 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_1" protect="rw">
        <comment>Pad u_u_RFDIG_GPIO_1 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_0" protect="rw">
        <comment>Pad u_RFDIG_GPIO_0 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_4" protect="rw">
        <comment>Pad u_KEYIN_4 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_5" protect="rw">
        <comment>Pad u_KEYOUT_5 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_5" protect="rw">
        <comment>Pad u_KEYIN_5 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_4" protect="rw">
        <comment>Pad u_KEYOUT_4 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_1_rts" protect="rw">
        <comment>Pad u_UART_1_RTS control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_1_txd" protect="rw">
        <comment>Pad u_UART_1_TXD control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_1_rxd" protect="rw">
        <comment>Pad u_UART_1_RXD control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_1_cts" protect="rw">
        <comment>Pad u_UART_1_CTS control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_0" protect="rw">
        <comment>Pad u_GPIO_0 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_3" protect="rw">
        <comment>Pad u_GPIO_3 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_2" protect="rw">
        <comment>Pad u_GPIO_2 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_1" protect="rw">
        <comment>Pad u_GPIO_1 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_7" protect="rw">
        <comment>Pad u_GPIO_7 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_6" protect="rw">
        <comment>Pad u_GPIO_6 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_5" protect="rw">
        <comment>Pad u_GPIO_5 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_4" protect="rw">
        <comment>Pad u_GPIO_4 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_adi_sda" protect="rw">
        <comment>Pad u_ADI_SDA control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_adi_scl" protect="rw">
        <comment>Pad u_ADI_SCL control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_resetb" protect="rw">
        <comment>Pad u_RESETB control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
      </reg>
      <reg name="pad_osc_32k" protect="rw">
        <comment>Pad u_OSC_32K control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_pmic_ext_int" protect="rw">
        <comment>Pad u_PMIC_EXT_INT control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_chip_pd" protect="rw">
        <comment>Pad u_CHIP_PD control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x1">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x1">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_ptest" protect="rw">
        <comment>Pad u_PTEST control</comment>
      </reg>
      <reg name="pad_clk26m_pmic" protect="rw">
        <comment>Pad u_CLK26M_PMIC control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_1_rst" protect="rw">
        <comment>Pad u_SIM_1_RST control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_1_dio" protect="rw">
        <comment>Pad u_SIM_1_DIO control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_1_clk" protect="rw">
        <comment>Pad u_SIM_1_CLK control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_0_rst" protect="rw">
        <comment>Pad u_SIM_0_RST control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x1">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x1">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_0_dio" protect="rw">
        <comment>Pad u_SIM_0_DIO control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x1">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_0_clk" protect="rw">
        <comment>Pad u_SIM_0_CLK control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x1">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x1">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sw_clk" protect="rw">
        <comment>Pad u_SW_CLK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sw_dio" protect="rw">
        <comment>Pad u_SW_DIO control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_debug_host_tx" protect="rw">
        <comment>Pad u_DEBUG_HOST_TX control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_debug_host_rx" protect="rw">
        <comment>Pad u_DEBUG_HOST_RX control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_debug_host_clk" protect="rw">
        <comment>Pad u_DEBUG_HOST_CLK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_camera_rst_l" protect="rw">
        <comment>Pad u_CAMERA_RST_L control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_camera_sck" protect="rw">
        <comment>Pad u_SPI_CAMERA_SCK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_camera_si_1" protect="rw">
        <comment>Pad u_SPI_CAMERA_SI_1 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_camera_si_0" protect="rw">
        <comment>Pad u_SPI_CAMERA_SI_0 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_camera_ref_clk" protect="rw">
        <comment>Pad u_CAMERA_REF_CLK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_camera_pwdn" protect="rw">
        <comment>Pad u_CAMERA_PWDN control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2s_sdat_i" protect="rw">
        <comment>Pad u_I2S_SDAT_I control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2s1_sdat_o" protect="rw">
        <comment>Pad u_I2S1_SDAT_O control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2s1_lrck" protect="rw">
        <comment>Pad u_I2S1_LRCK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2s1_bck" protect="rw">
        <comment>Pad u_I2S1_BCK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2s1_mclk" protect="rw">
        <comment>Pad u_I2S1_MCLK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2c_m2_scl" protect="rw">
        <comment>Pad u_I2C_M2_SCL control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2c_m2_sda" protect="rw">
        <comment>Pad u_I2C_M2_SDA control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_nand_sel" protect="rw">
        <comment>Pad u_Nand_sel control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_3" protect="rw">
        <comment>Pad u_KEYOUT_3 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_2" protect="rw">
        <comment>Pad u_KEYOUT_2 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_1" protect="rw">
        <comment>Pad u_KEYOUT_1 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_0" protect="rw">
        <comment>Pad u_KEYOUT_0 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_3" protect="rw">
        <comment>Pad u_KEYIN_3 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_2" protect="rw">
        <comment>Pad u_KEYIN_2 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_1" protect="rw">
        <comment>Pad u_KEYIN_1 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_0" protect="rw">
        <comment>Pad u_KEYIN_0 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_lcd_rstb" protect="rw">
        <comment>Pad u_LCD_RSTB control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_lcd_fmark" protect="rw">
        <comment>Pad u_LCD_FMARK control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_lcd_select" protect="rw">
        <comment>Pad u_SPI_LCD_SELECT control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_lcd_cs" protect="rw">
        <comment>Pad u_SPI_LCD_CS control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_lcd_clk" protect="rw">
        <comment>Pad u_SPI_LCD_CLK control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_lcd_sdc" protect="rw">
        <comment>Pad u_SPI_LCD_SDC control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_lcd_sio" protect="rw">
        <comment>Pad u_SPI_LCD_SIO control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_rst" protect="rw">
        <comment>Pad u_SDMMC1_RST control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_7" protect="rw">
        <comment>Pad u_SDMMC1_DATA_7 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_6" protect="rw">
        <comment>Pad u_SDMMC1_DATA_6 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_5" protect="rw">
        <comment>Pad u_SDMMC1_DATA_5 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_4" protect="rw">
        <comment>Pad u_SDMMC1_DATA_4 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_3" protect="rw">
        <comment>Pad u_SDMMC1_DATA_3 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_2" protect="rw">
        <comment>Pad u_SDMMC1_DATA_2 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_1" protect="rw">
        <comment>Pad u_SDMMC1_DATA_1 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_0" protect="rw">
        <comment>Pad u_SDMMC1_DATA_0 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_cmd" protect="rw">
        <comment>Pad u_SDMMC1_CMD control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_clk" protect="rw">
        <comment>Pad u_SDMMC1_CLK control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_2_rts" protect="rw">
        <comment>Pad u_UART_2_RTS control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_2_cts" protect="rw">
        <comment>Pad u_UART_2_CTS control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_2_txd" protect="rw">
        <comment>Pad u_UART_2_TXD control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_2_rxd" protect="rw">
        <comment>Pad u_UART_2_RXD control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2c_m1_sda" protect="rw">
        <comment>Pad u_I2C_M1_SDA control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2c_m1_scl" protect="rw">
        <comment>Pad u_I2C_M1_SCL control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_23" protect="rw">
        <comment>Pad u_GPIO_23 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_22" protect="rw">
        <comment>Pad u_GPIO_22 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_21" protect="rw">
        <comment>Pad u_GPIO_21 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_20" protect="rw">
        <comment>Pad u_GPIO_20 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_19" protect="rw">
        <comment>Pad u_GPIO_19 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_18" protect="rw">
        <comment>Pad u_GPIO_18 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_17" protect="rw">
        <comment>Pad u_GPIO_17 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_16" protect="rw">
        <comment>Pad u_GPIO_16 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_d_3" protect="rw">
        <comment>Pad u_M_SPI_D_3 control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_d_2" protect="rw">
        <comment>Pad u_M_SPI_D_2 control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_d_1" protect="rw">
        <comment>Pad u_M_SPI_D_1 control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_d_0" protect="rw">
        <comment>Pad u_M_SPI_D_0 control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_cs" protect="rw">
        <comment>Pad u_M_SPI_CS control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_clk" protect="rw">
        <comment>Pad u_M_SPI_CLK control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <hole size="21056"/>
      <reg name="pwr_pad_ctl_reserved_set" protect="rw"/>
      <reg name="pin_ctrl_reg0_set" protect="rw"/>
      <reg name="pin_ctrl_reg1_set" protect="rw"/>
      <reg name="pin_ctrl_reg2_set" protect="rw"/>
      <reg name="pin_ctrl_reg3_set" protect="rw"/>
      <reg name="pin_ctrl_reg4_set" protect="rw"/>
      <reg name="pin_ctrl_reg5_set" protect="rw"/>
      <reg name="rfdig_gpio_7_set" protect="rw"/>
      <reg name="rfdig_gpio_6_set" protect="rw"/>
      <reg name="rfdig_gpio_5_set" protect="rw"/>
      <reg name="rfdig_gpio_4_set" protect="rw"/>
      <reg name="rfdig_gpio_3_set" protect="rw"/>
      <reg name="rfdig_gpio_2_set" protect="rw"/>
      <reg name="rfdig_gpio_1_set" protect="rw"/>
      <reg name="rfdig_gpio_0_set" protect="rw"/>
      <reg name="keyin_4_set" protect="rw"/>
      <reg name="keyout_5_set" protect="rw"/>
      <reg name="keyin_5_set" protect="rw"/>
      <reg name="keyout_4_set" protect="rw"/>
      <reg name="uart_1_rts_set" protect="rw"/>
      <reg name="uart_1_txd_set" protect="rw"/>
      <reg name="uart_1_rxd_set" protect="rw"/>
      <reg name="uart_1_cts_set" protect="rw"/>
      <reg name="gpio_0_set" protect="rw"/>
      <reg name="gpio_3_set" protect="rw"/>
      <reg name="gpio_2_set" protect="rw"/>
      <reg name="gpio_1_set" protect="rw"/>
      <reg name="gpio_7_set" protect="rw"/>
      <reg name="gpio_6_set" protect="rw"/>
      <reg name="gpio_5_set" protect="rw"/>
      <reg name="gpio_4_set" protect="rw"/>
      <reg name="adi_sda_set" protect="rw"/>
      <reg name="adi_scl_set" protect="rw"/>
      <reg name="resetb_set" protect="rw"/>
      <reg name="osc_32k_set" protect="rw"/>
      <reg name="pmic_ext_int_set" protect="rw"/>
      <reg name="chip_pd_set" protect="rw"/>
      <hole size="32"/>
      <reg name="clk26m_pmic_set" protect="rw"/>
      <reg name="sim_1_rst_set" protect="rw"/>
      <reg name="sim_1_dio_set" protect="rw"/>
      <reg name="sim_1_clk_set" protect="rw"/>
      <reg name="sim_0_rst_set" protect="rw"/>
      <reg name="sim_0_dio_set" protect="rw"/>
      <reg name="sim_0_clk_set" protect="rw"/>
      <reg name="sw_clk_set" protect="rw"/>
      <reg name="sw_dio_set" protect="rw"/>
      <reg name="debug_host_tx_set" protect="rw"/>
      <reg name="debug_host_rx_set" protect="rw"/>
      <reg name="debug_host_clk_set" protect="rw"/>
      <reg name="camera_rst_l_set" protect="rw"/>
      <reg name="spi_camera_sck_set" protect="rw"/>
      <reg name="spi_camera_si_1_set" protect="rw"/>
      <reg name="spi_camera_si_0_set" protect="rw"/>
      <reg name="camera_ref_clk_set" protect="rw"/>
      <reg name="camera_pwdn_set" protect="rw"/>
      <reg name="i2s_sdat_i_set" protect="rw"/>
      <reg name="i2s1_sdat_o_set" protect="rw"/>
      <reg name="i2s1_lrck_set" protect="rw"/>
      <reg name="i2s1_bck_set" protect="rw"/>
      <reg name="i2s1_mclk_set" protect="rw"/>
      <reg name="i2c_m2_scl_set" protect="rw"/>
      <reg name="i2c_m2_sda_set" protect="rw"/>
      <reg name="nand_sel_set" protect="rw"/>
      <reg name="keyout_3_set" protect="rw"/>
      <reg name="keyout_2_set" protect="rw"/>
      <reg name="keyout_1_set" protect="rw"/>
      <reg name="keyout_0_set" protect="rw"/>
      <reg name="keyin_3_set" protect="rw"/>
      <reg name="keyin_2_set" protect="rw"/>
      <reg name="keyin_1_set" protect="rw"/>
      <reg name="keyin_0_set" protect="rw"/>
      <reg name="lcd_rstb_set" protect="rw"/>
      <reg name="lcd_fmark_set" protect="rw"/>
      <reg name="spi_lcd_select_set" protect="rw"/>
      <reg name="spi_lcd_cs_set" protect="rw"/>
      <reg name="spi_lcd_clk_set" protect="rw"/>
      <reg name="spi_lcd_sdc_set" protect="rw"/>
      <reg name="spi_lcd_sio_set" protect="rw"/>
      <reg name="sdmmc1_rst_set" protect="rw"/>
      <reg name="sdmmc1_data_7_set" protect="rw"/>
      <reg name="sdmmc1_data_6_set" protect="rw"/>
      <reg name="sdmmc1_data_5_set" protect="rw"/>
      <reg name="sdmmc1_data_4_set" protect="rw"/>
      <reg name="sdmmc1_data_3_set" protect="rw"/>
      <reg name="sdmmc1_data_2_set" protect="rw"/>
      <reg name="sdmmc1_data_1_set" protect="rw"/>
      <reg name="sdmmc1_data_0_set" protect="rw"/>
      <reg name="sdmmc1_cmd_set" protect="rw"/>
      <reg name="sdmmc1_clk_set" protect="rw"/>
      <reg name="uart_2_rts_set" protect="rw"/>
      <reg name="uart_2_cts_set" protect="rw"/>
      <reg name="uart_2_txd_set" protect="rw"/>
      <reg name="uart_2_rxd_set" protect="rw"/>
      <reg name="i2c_m1_sda_set" protect="rw"/>
      <reg name="i2c_m1_scl_set" protect="rw"/>
      <reg name="gpio_23_set" protect="rw"/>
      <reg name="gpio_22_set" protect="rw"/>
      <reg name="gpio_21_set" protect="rw"/>
      <reg name="gpio_20_set" protect="rw"/>
      <reg name="gpio_19_set" protect="rw"/>
      <reg name="gpio_18_set" protect="rw"/>
      <reg name="gpio_17_set" protect="rw"/>
      <reg name="gpio_16_set" protect="rw"/>
      <reg name="m_spi_d_3_set" protect="rw"/>
      <reg name="m_spi_d_2_set" protect="rw"/>
      <reg name="m_spi_d_1_set" protect="rw"/>
      <reg name="m_spi_d_0_set" protect="rw"/>
      <reg name="m_spi_cs_set" protect="rw"/>
      <reg name="m_spi_clk_set" protect="rw"/>
      <hole size="4896"/>
      <reg name="pad_rfdig_gpio_7_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_6_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_5_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_4_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_3_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_2_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_1_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_0_set" protect="rw"/>
      <reg name="pad_keyin_4_set" protect="rw"/>
      <reg name="pad_keyout_5_set" protect="rw"/>
      <reg name="pad_keyin_5_set" protect="rw"/>
      <reg name="pad_keyout_4_set" protect="rw"/>
      <reg name="pad_uart_1_rts_set" protect="rw"/>
      <reg name="pad_uart_1_txd_set" protect="rw"/>
      <reg name="pad_uart_1_rxd_set" protect="rw"/>
      <reg name="pad_uart_1_cts_set" protect="rw"/>
      <reg name="pad_gpio_0_set" protect="rw"/>
      <reg name="pad_gpio_3_set" protect="rw"/>
      <reg name="pad_gpio_2_set" protect="rw"/>
      <reg name="pad_gpio_1_set" protect="rw"/>
      <reg name="pad_gpio_7_set" protect="rw"/>
      <reg name="pad_gpio_6_set" protect="rw"/>
      <reg name="pad_gpio_5_set" protect="rw"/>
      <reg name="pad_gpio_4_set" protect="rw"/>
      <reg name="pad_adi_sda_set" protect="rw"/>
      <reg name="pad_adi_scl_set" protect="rw"/>
      <reg name="pad_resetb_set" protect="rw"/>
      <reg name="pad_osc_32k_set" protect="rw"/>
      <reg name="pad_pmic_ext_int_set" protect="rw"/>
      <reg name="pad_chip_pd_set" protect="rw"/>
      <hole size="32"/>
      <reg name="pad_clk26m_pmic_set" protect="rw"/>
      <reg name="pad_sim_1_rst_set" protect="rw"/>
      <reg name="pad_sim_1_dio_set" protect="rw"/>
      <reg name="pad_sim_1_clk_set" protect="rw"/>
      <reg name="pad_sim_0_rst_set" protect="rw"/>
      <reg name="pad_sim_0_dio_set" protect="rw"/>
      <reg name="pad_sim_0_clk_set" protect="rw"/>
      <reg name="pad_sw_clk_set" protect="rw"/>
      <reg name="pad_sw_dio_set" protect="rw"/>
      <reg name="pad_debug_host_tx_set" protect="rw"/>
      <reg name="pad_debug_host_rx_set" protect="rw"/>
      <reg name="pad_debug_host_clk_set" protect="rw"/>
      <reg name="pad_camera_rst_l_set" protect="rw"/>
      <reg name="pad_spi_camera_sck_set" protect="rw"/>
      <reg name="pad_spi_camera_si_1_set" protect="rw"/>
      <reg name="pad_spi_camera_si_0_set" protect="rw"/>
      <reg name="pad_camera_ref_clk_set" protect="rw"/>
      <reg name="pad_camera_pwdn_set" protect="rw"/>
      <reg name="pad_i2s_sdat_i_set" protect="rw"/>
      <reg name="pad_i2s1_sdat_o_set" protect="rw"/>
      <reg name="pad_i2s1_lrck_set" protect="rw"/>
      <reg name="pad_i2s1_bck_set" protect="rw"/>
      <reg name="pad_i2s1_mclk_set" protect="rw"/>
      <reg name="pad_i2c_m2_scl_set" protect="rw"/>
      <reg name="pad_i2c_m2_sda_set" protect="rw"/>
      <reg name="pad_nand_sel_set" protect="rw"/>
      <reg name="pad_keyout_3_set" protect="rw"/>
      <reg name="pad_keyout_2_set" protect="rw"/>
      <reg name="pad_keyout_1_set" protect="rw"/>
      <reg name="pad_keyout_0_set" protect="rw"/>
      <reg name="pad_keyin_3_set" protect="rw"/>
      <reg name="pad_keyin_2_set" protect="rw"/>
      <reg name="pad_keyin_1_set" protect="rw"/>
      <reg name="pad_keyin_0_set" protect="rw"/>
      <reg name="pad_lcd_rstb_set" protect="rw"/>
      <reg name="pad_lcd_fmark_set" protect="rw"/>
      <reg name="pad_spi_lcd_select_set" protect="rw"/>
      <reg name="pad_spi_lcd_cs_set" protect="rw"/>
      <reg name="pad_spi_lcd_clk_set" protect="rw"/>
      <reg name="pad_spi_lcd_sdc_set" protect="rw"/>
      <reg name="pad_spi_lcd_sio_set" protect="rw"/>
      <reg name="pad_sdmmc1_rst_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_7_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_6_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_5_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_4_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_3_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_2_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_1_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_0_set" protect="rw"/>
      <reg name="pad_sdmmc1_cmd_set" protect="rw"/>
      <reg name="pad_sdmmc1_clk_set" protect="rw"/>
      <reg name="pad_uart_2_rts_set" protect="rw"/>
      <reg name="pad_uart_2_cts_set" protect="rw"/>
      <reg name="pad_uart_2_txd_set" protect="rw"/>
      <reg name="pad_uart_2_rxd_set" protect="rw"/>
      <reg name="pad_i2c_m1_sda_set" protect="rw"/>
      <reg name="pad_i2c_m1_scl_set" protect="rw"/>
      <reg name="pad_gpio_23_set" protect="rw"/>
      <reg name="pad_gpio_22_set" protect="rw"/>
      <reg name="pad_gpio_21_set" protect="rw"/>
      <reg name="pad_gpio_20_set" protect="rw"/>
      <reg name="pad_gpio_19_set" protect="rw"/>
      <reg name="pad_gpio_18_set" protect="rw"/>
      <reg name="pad_gpio_17_set" protect="rw"/>
      <reg name="pad_gpio_16_set" protect="rw"/>
      <reg name="pad_m_spi_d_3_set" protect="rw"/>
      <reg name="pad_m_spi_d_2_set" protect="rw"/>
      <reg name="pad_m_spi_d_1_set" protect="rw"/>
      <reg name="pad_m_spi_d_0_set" protect="rw"/>
      <reg name="pad_m_spi_cs_set" protect="rw"/>
      <reg name="pad_m_spi_clk_set" protect="rw"/>
      <hole size="21056"/>
      <reg name="pwr_pad_ctl_reserved_clr" protect="rw"/>
      <reg name="pin_ctrl_reg0_clr" protect="rw"/>
      <reg name="pin_ctrl_reg1_clr" protect="rw"/>
      <reg name="pin_ctrl_reg2_clr" protect="rw"/>
      <reg name="pin_ctrl_reg3_clr" protect="rw"/>
      <reg name="pin_ctrl_reg4_clr" protect="rw"/>
      <reg name="pin_ctrl_reg5_clr" protect="rw"/>
      <reg name="rfdig_gpio_7_clr" protect="rw"/>
      <reg name="rfdig_gpio_6_clr" protect="rw"/>
      <reg name="rfdig_gpio_5_clr" protect="rw"/>
      <reg name="rfdig_gpio_4_clr" protect="rw"/>
      <reg name="rfdig_gpio_3_clr" protect="rw"/>
      <reg name="rfdig_gpio_2_clr" protect="rw"/>
      <reg name="rfdig_gpio_1_clr" protect="rw"/>
      <reg name="rfdig_gpio_0_clr" protect="rw"/>
      <reg name="keyin_4_clr" protect="rw"/>
      <reg name="keyout_5_clr" protect="rw"/>
      <reg name="keyin_5_clr" protect="rw"/>
      <reg name="keyout_4_clr" protect="rw"/>
      <reg name="uart_1_rts_clr" protect="rw"/>
      <reg name="uart_1_txd_clr" protect="rw"/>
      <reg name="uart_1_rxd_clr" protect="rw"/>
      <reg name="uart_1_cts_clr" protect="rw"/>
      <reg name="gpio_0_clr" protect="rw"/>
      <reg name="gpio_3_clr" protect="rw"/>
      <reg name="gpio_2_clr" protect="rw"/>
      <reg name="gpio_1_clr" protect="rw"/>
      <reg name="gpio_7_clr" protect="rw"/>
      <reg name="gpio_6_clr" protect="rw"/>
      <reg name="gpio_5_clr" protect="rw"/>
      <reg name="gpio_4_clr" protect="rw"/>
      <reg name="adi_sda_clr" protect="rw"/>
      <reg name="adi_scl_clr" protect="rw"/>
      <reg name="resetb_clr" protect="rw"/>
      <reg name="osc_32k_clr" protect="rw"/>
      <reg name="pmic_ext_int_clr" protect="rw"/>
      <reg name="chip_pd_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="clk26m_pmic_clr" protect="rw"/>
      <reg name="sim_1_rst_clr" protect="rw"/>
      <reg name="sim_1_dio_clr" protect="rw"/>
      <reg name="sim_1_clk_clr" protect="rw"/>
      <reg name="sim_0_rst_clr" protect="rw"/>
      <reg name="sim_0_dio_clr" protect="rw"/>
      <reg name="sim_0_clk_clr" protect="rw"/>
      <reg name="sw_clk_clr" protect="rw"/>
      <reg name="sw_dio_clr" protect="rw"/>
      <reg name="debug_host_tx_clr" protect="rw"/>
      <reg name="debug_host_rx_clr" protect="rw"/>
      <reg name="debug_host_clk_clr" protect="rw"/>
      <reg name="camera_rst_l_clr" protect="rw"/>
      <reg name="spi_camera_sck_clr" protect="rw"/>
      <reg name="spi_camera_si_1_clr" protect="rw"/>
      <reg name="spi_camera_si_0_clr" protect="rw"/>
      <reg name="camera_ref_clk_clr" protect="rw"/>
      <reg name="camera_pwdn_clr" protect="rw"/>
      <reg name="i2s_sdat_i_clr" protect="rw"/>
      <reg name="i2s1_sdat_o_clr" protect="rw"/>
      <reg name="i2s1_lrck_clr" protect="rw"/>
      <reg name="i2s1_bck_clr" protect="rw"/>
      <reg name="i2s1_mclk_clr" protect="rw"/>
      <reg name="i2c_m2_scl_clr" protect="rw"/>
      <reg name="i2c_m2_sda_clr" protect="rw"/>
      <reg name="nand_sel_clr" protect="rw"/>
      <reg name="keyout_3_clr" protect="rw"/>
      <reg name="keyout_2_clr" protect="rw"/>
      <reg name="keyout_1_clr" protect="rw"/>
      <reg name="keyout_0_clr" protect="rw"/>
      <reg name="keyin_3_clr" protect="rw"/>
      <reg name="keyin_2_clr" protect="rw"/>
      <reg name="keyin_1_clr" protect="rw"/>
      <reg name="keyin_0_clr" protect="rw"/>
      <reg name="lcd_rstb_clr" protect="rw"/>
      <reg name="lcd_fmark_clr" protect="rw"/>
      <reg name="spi_lcd_select_clr" protect="rw"/>
      <reg name="spi_lcd_cs_clr" protect="rw"/>
      <reg name="spi_lcd_clk_clr" protect="rw"/>
      <reg name="spi_lcd_sdc_clr" protect="rw"/>
      <reg name="spi_lcd_sio_clr" protect="rw"/>
      <reg name="sdmmc1_rst_clr" protect="rw"/>
      <reg name="sdmmc1_data_7_clr" protect="rw"/>
      <reg name="sdmmc1_data_6_clr" protect="rw"/>
      <reg name="sdmmc1_data_5_clr" protect="rw"/>
      <reg name="sdmmc1_data_4_clr" protect="rw"/>
      <reg name="sdmmc1_data_3_clr" protect="rw"/>
      <reg name="sdmmc1_data_2_clr" protect="rw"/>
      <reg name="sdmmc1_data_1_clr" protect="rw"/>
      <reg name="sdmmc1_data_0_clr" protect="rw"/>
      <reg name="sdmmc1_cmd_clr" protect="rw"/>
      <reg name="sdmmc1_clk_clr" protect="rw"/>
      <reg name="uart_2_rts_clr" protect="rw"/>
      <reg name="uart_2_cts_clr" protect="rw"/>
      <reg name="uart_2_txd_clr" protect="rw"/>
      <reg name="uart_2_rxd_clr" protect="rw"/>
      <reg name="i2c_m1_sda_clr" protect="rw"/>
      <reg name="i2c_m1_scl_clr" protect="rw"/>
      <reg name="gpio_23_clr" protect="rw"/>
      <reg name="gpio_22_clr" protect="rw"/>
      <reg name="gpio_21_clr" protect="rw"/>
      <reg name="gpio_20_clr" protect="rw"/>
      <reg name="gpio_19_clr" protect="rw"/>
      <reg name="gpio_18_clr" protect="rw"/>
      <reg name="gpio_17_clr" protect="rw"/>
      <reg name="gpio_16_clr" protect="rw"/>
      <reg name="m_spi_d_3_clr" protect="rw"/>
      <reg name="m_spi_d_2_clr" protect="rw"/>
      <reg name="m_spi_d_1_clr" protect="rw"/>
      <reg name="m_spi_d_0_clr" protect="rw"/>
      <reg name="m_spi_cs_clr" protect="rw"/>
      <reg name="m_spi_clk_clr" protect="rw"/>
      <hole size="4896"/>
      <reg name="pad_rfdig_gpio_7_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_6_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_5_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_4_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_3_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_2_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_1_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_0_clr" protect="rw"/>
      <reg name="pad_keyin_4_clr" protect="rw"/>
      <reg name="pad_keyout_5_clr" protect="rw"/>
      <reg name="pad_keyin_5_clr" protect="rw"/>
      <reg name="pad_keyout_4_clr" protect="rw"/>
      <reg name="pad_uart_1_rts_clr" protect="rw"/>
      <reg name="pad_uart_1_txd_clr" protect="rw"/>
      <reg name="pad_uart_1_rxd_clr" protect="rw"/>
      <reg name="pad_uart_1_cts_clr" protect="rw"/>
      <reg name="pad_gpio_0_clr" protect="rw"/>
      <reg name="pad_gpio_3_clr" protect="rw"/>
      <reg name="pad_gpio_2_clr" protect="rw"/>
      <reg name="pad_gpio_1_clr" protect="rw"/>
      <reg name="pad_gpio_7_clr" protect="rw"/>
      <reg name="pad_gpio_6_clr" protect="rw"/>
      <reg name="pad_gpio_5_clr" protect="rw"/>
      <reg name="pad_gpio_4_clr" protect="rw"/>
      <reg name="pad_adi_sda_clr" protect="rw"/>
      <reg name="pad_adi_scl_clr" protect="rw"/>
      <reg name="pad_resetb_clr" protect="rw"/>
      <reg name="pad_osc_32k_clr" protect="rw"/>
      <reg name="pad_pmic_ext_int_clr" protect="rw"/>
      <reg name="pad_chip_pd_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="pad_clk26m_pmic_clr" protect="rw"/>
      <reg name="pad_sim_1_rst_clr" protect="rw"/>
      <reg name="pad_sim_1_dio_clr" protect="rw"/>
      <reg name="pad_sim_1_clk_clr" protect="rw"/>
      <reg name="pad_sim_0_rst_clr" protect="rw"/>
      <reg name="pad_sim_0_dio_clr" protect="rw"/>
      <reg name="pad_sim_0_clk_clr" protect="rw"/>
      <reg name="pad_sw_clk_clr" protect="rw"/>
      <reg name="pad_sw_dio_clr" protect="rw"/>
      <reg name="pad_debug_host_tx_clr" protect="rw"/>
      <reg name="pad_debug_host_rx_clr" protect="rw"/>
      <reg name="pad_debug_host_clk_clr" protect="rw"/>
      <reg name="pad_camera_rst_l_clr" protect="rw"/>
      <reg name="pad_spi_camera_sck_clr" protect="rw"/>
      <reg name="pad_spi_camera_si_1_clr" protect="rw"/>
      <reg name="pad_spi_camera_si_0_clr" protect="rw"/>
      <reg name="pad_camera_ref_clk_clr" protect="rw"/>
      <reg name="pad_camera_pwdn_clr" protect="rw"/>
      <reg name="pad_i2s_sdat_i_clr" protect="rw"/>
      <reg name="pad_i2s1_sdat_o_clr" protect="rw"/>
      <reg name="pad_i2s1_lrck_clr" protect="rw"/>
      <reg name="pad_i2s1_bck_clr" protect="rw"/>
      <reg name="pad_i2s1_mclk_clr" protect="rw"/>
      <reg name="pad_i2c_m2_scl_clr" protect="rw"/>
      <reg name="pad_i2c_m2_sda_clr" protect="rw"/>
      <reg name="pad_nand_sel_clr" protect="rw"/>
      <reg name="pad_keyout_3_clr" protect="rw"/>
      <reg name="pad_keyout_2_clr" protect="rw"/>
      <reg name="pad_keyout_1_clr" protect="rw"/>
      <reg name="pad_keyout_0_clr" protect="rw"/>
      <reg name="pad_keyin_3_clr" protect="rw"/>
      <reg name="pad_keyin_2_clr" protect="rw"/>
      <reg name="pad_keyin_1_clr" protect="rw"/>
      <reg name="pad_keyin_0_clr" protect="rw"/>
      <reg name="pad_lcd_rstb_clr" protect="rw"/>
      <reg name="pad_lcd_fmark_clr" protect="rw"/>
      <reg name="pad_spi_lcd_select_clr" protect="rw"/>
      <reg name="pad_spi_lcd_cs_clr" protect="rw"/>
      <reg name="pad_spi_lcd_clk_clr" protect="rw"/>
      <reg name="pad_spi_lcd_sdc_clr" protect="rw"/>
      <reg name="pad_spi_lcd_sio_clr" protect="rw"/>
      <reg name="pad_sdmmc1_rst_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_7_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_6_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_5_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_4_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_3_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_2_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_1_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_0_clr" protect="rw"/>
      <reg name="pad_sdmmc1_cmd_clr" protect="rw"/>
      <reg name="pad_sdmmc1_clk_clr" protect="rw"/>
      <reg name="pad_uart_2_rts_clr" protect="rw"/>
      <reg name="pad_uart_2_cts_clr" protect="rw"/>
      <reg name="pad_uart_2_txd_clr" protect="rw"/>
      <reg name="pad_uart_2_rxd_clr" protect="rw"/>
      <reg name="pad_i2c_m1_sda_clr" protect="rw"/>
      <reg name="pad_i2c_m1_scl_clr" protect="rw"/>
      <reg name="pad_gpio_23_clr" protect="rw"/>
      <reg name="pad_gpio_22_clr" protect="rw"/>
      <reg name="pad_gpio_21_clr" protect="rw"/>
      <reg name="pad_gpio_20_clr" protect="rw"/>
      <reg name="pad_gpio_19_clr" protect="rw"/>
      <reg name="pad_gpio_18_clr" protect="rw"/>
      <reg name="pad_gpio_17_clr" protect="rw"/>
      <reg name="pad_gpio_16_clr" protect="rw"/>
      <reg name="pad_m_spi_d_3_clr" protect="rw"/>
      <reg name="pad_m_spi_d_2_clr" protect="rw"/>
      <reg name="pad_m_spi_d_1_clr" protect="rw"/>
      <reg name="pad_m_spi_d_0_clr" protect="rw"/>
      <reg name="pad_m_spi_cs_clr" protect="rw"/>
      <reg name="pad_m_spi_clk_clr" protect="rw"/>
    </module>
    <var name="REG_IOMUX_SET_OFFSET" value="0x1000"/>
    <var name="REG_IOMUX_CLR_OFFSET" value="0x2000"/>
    <instance address="0x51510000" name="IOMUX" type="IOMUX"/>
  </archive>
  <archive relative="pwrctrl.xml">
    <module category="System" name="PWRCTRL">
      <reg name="pwrctrl_hwen" protect="rw">
        <comment>PWRCTRL_HWEN power domain shutdown/on controled by hardware signal or sofeware register.</comment>
        <bits access="rw" name="cp_pwr_hwen" pos="1" rst="0x0">
          <comment>CP power domain control by:
0:software register
1:hardware signal from IDLE_LPS module</comment>
        </bits>
        <bits access="rw" name="ap_pwr_hwen" pos="0" rst="0x1">
          <comment>AP power domain control by:
0:software register
1:hardware signal from IDLE_LPS module</comment>
        </bits>
      </reg>
      <reg name="ap_pwr_ctrl" protect="rw">
        <comment>AP_PWR_CTRL Register control AP power domani on/off.</comment>
        <bits access="rw" name="ap_pwr_ctrl" pos="0" rst="0x0">
          <comment>AP power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="cp_pwr_ctrl" protect="rw">
        <comment>CP_PWR_CTRL Register control CP power domani on/off.</comment>
        <bits access="rw" name="cp_pwr_ctrl" pos="0" rst="0x0">
          <comment>CP power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="pub_pwr_ctrl" protect="rw">
        <comment>PUB_PWR_CTRL Register control PUB power domani on/off. PUB power domain whil be shutdown when bit[2:0]=2'b11,otherwise power on.</comment>
        <bits access="rw" name="cp_pol" pos="1" rst="0x1">
          <comment>PUB power domain poll register bit for CP A5
0:poll to power on
1:poll to shutdown</comment>
        </bits>
        <bits access="rw" name="ap_pol" pos="0" rst="0x1">
          <comment>PUB power domain poll register bit for AP A5
0:poll to power on
1:poll to shutdown</comment>
        </bits>
      </reg>
      <reg name="rf_pwr_ctrl" protect="rw">
        <comment>RF_PWR_CTRL Register control RF power domani on/off.</comment>
        <bits access="rw" name="rf_pwr_ctrl" pos="0" rst="0x1">
          <comment>RF power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="usb_pwr_ctrl" protect="rw">
        <comment>USB_PWR_CTRL Register control USB power domani on/off.</comment>
        <bits access="rw" name="usb_pwr_ctrl" pos="0" rst="0x1">
          <comment>USB power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="lte_pwr_ctrl" protect="rw">
        <comment>LTE_PWR_CTRL Register control LTE power domani on/off.</comment>
        <bits access="rw" name="lte_pwr_ctrl" pos="0" rst="0x0">
          <comment>LTE power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="gnss_pwr_ctrl" protect="rw">
        <comment>GNSS_PWR_CTRL Register control GNSS power domani on/off.</comment>
        <bits access="rw" name="gnss_pwr_ctrl" pos="0" rst="0x0">
          <comment>GNSS power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="ap_pwr_stat" protect="rw">
        <comment>AP_PWR_STAT AP power domain state.</comment>
        <bits access="r" name="ap_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="ap_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="cp_pwr_stat" protect="rw">
        <comment>CP power domain state. CP power domain state.</comment>
        <bits access="r" name="cp_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="cp_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="pub_pwr_stat" protect="rw">
        <comment>PUB_PWR_STAT PUB power domain state.</comment>
        <bits access="r" name="pub_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="pub_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="rf_pwr_stat" protect="rw">
        <comment>RF_PWR_STAT RF power domain state.</comment>
        <bits access="r" name="rf_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="rf_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="usb_pwr_stat" protect="rw">
        <comment>USB_PWR_STAT USB power domain state.</comment>
        <bits access="r" name="usb_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="usb_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="lte_pwr_stat" protect="rw">
        <comment>LTE_PWR_STAT LTE power domain state.</comment>
        <bits access="r" name="lte_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="lte_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="gnss_pwr_stat" protect="rw">
        <comment>GNSS_PWR_STAT GNSS power domain state.</comment>
        <bits access="r" name="gnss_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="gnss_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="state_delay" protect="rw">
        <comment>STATE_DELAY Power domain control state machine delay value between two states.</comment>
        <bits access="rw" name="delay_value" pos="15:0" rst="0xff">
          <comment>Power domain control state machine delay value between two states, counts with 26MHz clock.</comment>
        </bits>
      </reg>
      <reg name="pd_m_delay" protect="rw">
        <comment>PD_M_DELAY Power switch mather chain delay value.</comment>
        <bits access="rw" name="delay_value" pos="15:0" rst="0xd0">
          <comment>Power switch mather chain delay value, counts with 26MHz clock.</comment>
        </bits>
      </reg>
      <reg name="pd_d_delay" protect="rw">
        <comment>PD_D_DELAY Power switch daughter chain delay value.</comment>
        <bits access="rw" name="delay_value" pos="15:0" rst="0x500">
          <comment>Power switch daughter chain delay value, counts with 26MHz clock.</comment>
        </bits>
      </reg>
      <reg name="psram_hold_ctrl" protect="rw">
        <comment>PSRAM_HOLD_CTRL Control latch the value of PSRAM IO from PSRAM controller.</comment>
        <bits access="rw" name="latch_en" pos="0" rst="0x0">
          <comment>0:not latch
1:latch</comment>
        </bits>
      </reg>
      <reg name="slp_bypass" protect="rw">
        <comment>SLP_BYPASS Control bypass the sleep handshake action when shutdown power domain.</comment>
        <bits access="rw" name="gnss_slp_bypass" pos="6" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="lte_slp_bypass" pos="5" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="usb_slp_bypass" pos="4" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="rf_slp_bypass" pos="3" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="pub_slp_bypass" pos="2" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="cp_slp_bypass" pos="1" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="ap_slp_bypass" pos="0" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
      </reg>
      <reg name="slp_timeout_flag" protect="rw">
        <comment>SLP_TIMEOUT_FLAG Flag of power domain sleep handshake action timeout.Write &quot;1&quot; to clear relevant bit.</comment>
        <bits access="rw" name="gnss_slp_timeout" pos="6" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="lte_slp_timeout" pos="5" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="usb_slp_timeout" pos="4" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="rf_slp_timeout" pos="3" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="pub_slp_timeout" pos="2" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="cp_slp_timeout" pos="1" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="ap_slp_timeout" pos="0" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
      </reg>
      <reg name="pwrctrl_int_en_ap" protect="rw">
        <comment>PWRCTRL_INT_EN_AP</comment>
        <bits access="rw" name="pwrctrl_int_en_gnss_sys" pos="6" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_lte_sys" pos="5" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_usb_sys" pos="4" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_rf_sys" pos="3" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_pub_sys" pos="2" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_cp_sys" pos="1" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_ap_sys" pos="0" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
      </reg>
      <reg name="pwrctrl_int_en_cp" protect="rw">
        <comment>PWRCTRL_INT_EN_CP</comment>
        <bits access="rw" name="pwrctrl_int_en_gnss_sys" pos="6" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_lte_sys" pos="5" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_usb_sys" pos="4" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_rf_sys" pos="3" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_pub_sys" pos="2" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_cp_sys" pos="1" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_ap_sys" pos="0" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
      </reg>
      <reg name="pwrctrl_sm_state" protect="rw">
        <comment>PWRCTRL_SM_STATE The state value of the power domain state machine.</comment>
        <bits access="r" name="gnss_sm_state" pos="27:24" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="lte_sm_state" pos="23:20" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="usb_sm_state" pos="19:16" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="rf_sm_state" pos="15:12" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="pub_sm_state" pos="11:8" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="cp_sm_state" pos="7:4" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="ap_sm_state" pos="3:0" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
      </reg>
      <hole size="7424"/>
      <reg name="pwrctrl_hwen_set" protect="rw"/>
      <hole size="64"/>
      <reg name="pub_pwr_ctrl_set" protect="rw"/>
      <hole size="480"/>
      <reg name="slp_bypass_set" protect="rw"/>
      <reg name="slp_timeout_flag_set" protect="rw"/>
      <reg name="pwrctrl_int_en_ap_set" protect="rw"/>
      <reg name="pwrctrl_int_en_cp_set" protect="rw"/>
      <hole size="7456"/>
      <reg name="pwrctrl_hwen_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="pub_pwr_ctrl_clr" protect="rw"/>
      <hole size="480"/>
      <reg name="slp_bypass_clr" protect="rw"/>
      <reg name="slp_timeout_flag_clr" protect="rw"/>
      <reg name="pwrctrl_int_en_ap_clr" protect="rw"/>
      <reg name="pwrctrl_int_en_cp_clr" protect="rw"/>
    </module>
    <var name="REG_PWRCTRL_SET_OFFSET" value="0x400"/>
    <var name="REG_PWRCTRL_CLR_OFFSET" value="0x800"/>
    <instance address="0x51707000" name="PWRCTRL" type="PWRCTRL"/>
  </archive>
  <archive relative="idle_lps.xml">
    <module category="System" name="IDLE_LPS">
      <reg name="lps_ctrl_ap" protect="rw">
        <comment>LPS_CTRL_AP AP sleep enable register(Enable AP sleep when writing 0x49444c45 to this register, accessed by software only.)</comment>
        <bits access="rw" name="idct_ap" pos="0" rst="0x0">
          <comment>Enable AP sleep
0:disable
1:enable</comment>
        </bits>
      </reg>
      <reg name="ap_sig_en" protect="rw">
        <comment>AP_SIG_EN signal of low power related enable register</comment>
        <bits access="rw" name="ap_dis_val" pos="5" rst="0x1"/>
        <bits access="rw" name="ap_pow_on_en" pos="4" rst="0x1">
          <comment>ap_pow_on_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="ap_cg_en" pos="3" rst="0x1">
          <comment>ap_cg_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="ap_pd_pll_en" pos="2" rst="0x1">
          <comment>ap_pd_pll_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="ap_pd_xtal_en" pos="1" rst="0x1">
          <comment>ap_pd_xtal_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="ap_chip_pd_en" pos="0" rst="0x1">
          <comment>ap_chip_pd_en ctrl
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="ap_lps_sig_time" protect="rw">
        <comment>AP_LPS_SIG_TIME low power related time control register</comment>
        <bits access="rw" name="ap_t4" pos="31:24" rst="0x1">
          <comment>The time from enable clock to obtain clock</comment>
        </bits>
        <bits access="rw" name="ap_t3" pos="23:16" rst="0xa">
          <comment>The time of PLL from power saving state to output normal clock.</comment>
        </bits>
        <bits access="rw" name="ap_t2" pos="15:8" rst="0xa0">
          <comment>The time of OSC circuit from power saving
state to normal state.</comment>
        </bits>
        <bits access="rw" name="ap_t1" pos="7:0" rst="0x1">
          <comment>The time of PMIC boost stabilization.</comment>
        </bits>
      </reg>
      <reg name="lps_ctrl_cp" protect="rw">
        <comment>LPS_CTRL_CP CP sleep enable register(Enable CP sleep when writing 0x49444c45 to this register, accessed by software only.)</comment>
        <bits access="rw" name="idct_cp" pos="0" rst="0x0">
          <comment>Enable CP sleep
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="cp_pm2_sta" protect="rw">
        <comment>CP_PM2_STA mark pm2</comment>
        <bits access="rw" name="cp_pm2_sta" pos="0" rst="0x0">
          <comment>pm2 sta
1:PM2 valid
0:PM2 invalid</comment>
        </bits>
      </reg>
      <reg name="cp_sig_en" protect="rw">
        <comment>CP_SIG_EN signal of low power related enable register</comment>
        <bits access="rw" name="cp_dis_val" pos="5" rst="0x1"/>
        <bits access="rw" name="cp_pow_on_en" pos="4" rst="0x1">
          <comment>cp_pow_on_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="cp_cg_en" pos="3" rst="0x1">
          <comment>cp_cg_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="cp_pd_pll_en" pos="2" rst="0x1">
          <comment>cp_pd_pll_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="cp_pd_xtal_en" pos="1" rst="0x1">
          <comment>cp_pd_xtal_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="cp_chip_pd_en" pos="0" rst="0x1">
          <comment>cp_chip_pd_en ctrl
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="cp_lps_sig_time" protect="rw">
        <comment>CP_LPS_SIG_TIME low power related time control register</comment>
        <bits access="rw" name="cp_t4" pos="31:24" rst="0x1">
          <comment>The time from enable clock to obtain clock</comment>
        </bits>
        <bits access="rw" name="cp_t3" pos="23:16" rst="0xa">
          <comment>The time of PLL from power saving state to output normal clock.</comment>
        </bits>
        <bits access="rw" name="cp_t2" pos="15:8" rst="0xa0">
          <comment>The time of OSC circuit from power saving
state to normal state.</comment>
        </bits>
        <bits access="rw" name="cp_t1" pos="7:0" rst="0x1">
          <comment>The time of PMIC boost stabilization.</comment>
        </bits>
      </reg>
      <reg name="pm2_off_time" protect="rw">
        <comment>PM2_OFF_TIME low power related time control register</comment>
        <bits access="rw" name="n4" pos="31:24" rst="0x2">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="n3" pos="23:16" rst="0x2">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="n2" pos="15:8" rst="0x1">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="n1" pos="7:0" rst="0x1">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
      </reg>
      <reg name="pm2_on_time" protect="rw">
        <comment>AON_CLOCK_EN0 low power related time control register</comment>
        <bits access="rw" name="p4" pos="31:24" rst="0x2">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="p3" pos="23:16" rst="0x2">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="p2" pos="15:8" rst="0x1">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
      </reg>
      <reg name="pm2_on_off_time" protect="rw">
        <comment>PM2_ON_OFF_TIME low power related time control register</comment>
        <bits access="rw" name="p6" pos="31:24" rst="0x20">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="p5" pos="23:16" rst="0x4">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="n6" pos="15:8" rst="0x20">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="n5" pos="7:0" rst="0x4">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
      </reg>
      <reg name="ap_pm2_sta" protect="rw">
        <comment>AP_PM2_STA mark pm2</comment>
        <bits access="rw" name="ap_pm2_sta" pos="0" rst="0x0">
          <comment>pm2 sta
1:PM2 valid
0:PM2 invalid</comment>
        </bits>
      </reg>
      <reg name="ap_pm2_mode_en" protect="rw">
        <comment>AP_PM2_MODE_EN AP PM2 enable</comment>
        <bits access="rw" name="ap_pm2_mode_en" pos="0" rst="0x0">
          <comment>AP enable PM2 mode
0:enable PM2 mode
1:disable PM2 mode</comment>
        </bits>
      </reg>
      <reg name="aon_sig_en" protect="rw">
        <comment>AON_SIG_EN AON CTRL signal enable</comment>
        <bits access="rw" name="dis_val" pos="6" rst="0x1"/>
        <bits access="rw" name="pd_aon_shutdown_d_b_en" pos="5" rst="0x1">
          <comment>pd_aon_shutdown_d_b ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="pd_aon_shutdown_m_b_en" pos="4" rst="0x1">
          <comment>pd_aon_shutdown_m_b ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="pd_aon_mem" pos="3" rst="0x1">
          <comment>pd_aon_mem ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="rst_aon_n_en" pos="2" rst="0x1">
          <comment>rst_aon_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="pd_aon_iso" pos="1" rst="0x1">
          <comment>pd_aon_iso ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="clk_en_aon_en" pos="0" rst="0x1">
          <comment>clk_en_aon ctrl
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="sleep_prot_time" protect="rw">
        <comment>SLEEP_PROT_TIME</comment>
        <bits access="rw" name="sleep_prot_time" pos="7:0" rst="0x9">
          <comment>The minimum threshold of deep sleep, to ensure PMIC have complete deep sleep in and deep sleep out.</comment>
        </bits>
      </reg>
      <reg name="eliminate_jitter" protect="rw">
        <comment>ELIMINATE_JITTER</comment>
        <bits access="rw" name="eliminate_time" pos="31:24" rst="0x1">
          <comment>Eliminate jitter delay register</comment>
        </bits>
        <bits access="rw" name="eliminate_en" pos="23:0" rst="0x0">
          <comment>Emilinate the jitter from awake signal when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="ap_lps_sta" protect="rw">
        <comment>AP_LPS_STA</comment>
        <bits access="rw" name="ap_perip_awk_stat" pos="3" rst="0x0">
          <comment>awake valid
0：invalid
1：valid</comment>
        </bits>
        <bits access="rw" name="ap_pow_ack_stat" pos="2" rst="0x0">
          <comment>AP_POW_ACK sta(ap exit sleep mode)
0：POW_ACK value
1：POW_ACK value</comment>
        </bits>
        <bits access="rw" name="ap_lps_end_stat" pos="1" rst="0x0">
          <comment>AP_LPS end sta
0:not sleep
1:sleep</comment>
        </bits>
        <bits access="r" name="ap_lps_stat" pos="0" rst="0x0">
          <comment>AP_SYS state
0: normal working
1: low power mode</comment>
        </bits>
      </reg>
      <reg name="cp_inten" protect="rw">
        <comment>CP_INTEN</comment>
        <bits access="rw" name="cp_t9_irq_en" pos="14" rst="0x0">
          <comment>t9_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t8_irq_en" pos="13" rst="0x0">
          <comment>t8_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t7_irq_en" pos="12" rst="0x0">
          <comment>t7_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_load_irq_en" pos="11" rst="0x0">
          <comment>load_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_sys_awk_irq_to_cp_en" pos="10" rst="0x0">
          <comment>ap_sys_awk_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_sys_awk_irq_to_cp_en" pos="9" rst="0x0">
          <comment>cp_sys_awk_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_tstamp_irq_en" pos="8" rst="0x0">
          <comment>tstamp_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t6_irq_en" pos="7" rst="0x0">
          <comment>t6_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t5_irq_en" pos="6" rst="0x0">
          <comment>t5_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t4_irq_en" pos="5" rst="0x0">
          <comment>t4 enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t3_irq_en" pos="4" rst="0x0">
          <comment>t3_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t2_irq_en" pos="3" rst="0x0">
          <comment>t2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t1_irq_en" pos="2" rst="0x0">
          <comment>t1_irq_enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_p2_irq_en" pos="1" rst="0x0">
          <comment>p2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_p1_irq_en" pos="0" rst="0x0">
          <comment>p1_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cp_int_sta" protect="rw">
        <comment>CP_INT_STA</comment>
        <bits access="rw" name="cp_int_sta" pos="14:0" rst="0x0">
          <comment>clear cp interrupt state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="ap_inten" protect="rw">
        <comment>AP_INTEN ap interrupt enable register</comment>
        <bits access="rw" name="ap_t9_irq_en" pos="14" rst="0x0">
          <comment>t9_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t8_irq_en" pos="13" rst="0x0">
          <comment>t8_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t7_irq_en" pos="12" rst="0x0">
          <comment>t7_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_tstamp_irq_en" pos="11" rst="0x0">
          <comment>tstamp_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_load_irq_en" pos="10" rst="0x0">
          <comment>load_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_sys_awk_irq_to_ap_en" pos="9" rst="0x0">
          <comment>ap_sys_awk_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_sys_awk_irq_to_ap_en" pos="8" rst="0x0">
          <comment>cp_sys_awk_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t6_irq_en" pos="7" rst="0x0">
          <comment>t6_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t5_irq_en" pos="6" rst="0x0">
          <comment>t5_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t4_irq_en" pos="5" rst="0x0">
          <comment>t4 enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t3_irq_en" pos="4" rst="0x0">
          <comment>t3_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t2_irq_en" pos="3" rst="0x0">
          <comment>t2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t1_irq_en" pos="2" rst="0x0">
          <comment>t1_irq_enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_p2_irq_en" pos="1" rst="0x0">
          <comment>p2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_p1_irq_en" pos="0" rst="0x0">
          <comment>p1_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="ap_int_sta" protect="rw">
        <comment>AP_INT_STA ap interrupt state</comment>
        <bits access="rw" name="ap_int_sta" pos="14:0" rst="0x0">
          <comment>clear ap interrupt state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="ap_awk_en" protect="rw">
        <comment>AP_AWK_EN AP wakeup enable register</comment>
        <bits access="rw" name="ap_p2_awk_en" pos="31" rst="0x0">
          <comment>P2_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_t6_awk_en" pos="30" rst="0x0">
          <comment>T6_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_t5_awk_en" pos="29" rst="0x0">
          <comment>T5_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_t4_awk_en" pos="28" rst="0x0">
          <comment>T4_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_t3_awk_en" pos="27" rst="0x0">
          <comment>T3_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_t2_awk_en" pos="26" rst="0x0">
          <comment>T2_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_t1_awk_en" pos="25" rst="0x0">
          <comment>T1_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_p1_awk_en" pos="24" rst="0x0">
          <comment>P1_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk23_en" pos="23" rst="0x0">
          <comment>AWK23_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk22_en" pos="22" rst="0x0">
          <comment>AWK22_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk21_en" pos="21" rst="0x0">
          <comment>AWK21_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk20_en" pos="20" rst="0x0">
          <comment>AWK20_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk19_en" pos="19" rst="0x0">
          <comment>AWK19_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk18_en" pos="18" rst="0x0">
          <comment>AWK18_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk17_en" pos="17" rst="0x0">
          <comment>AWK17_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk16_en" pos="16" rst="0x0">
          <comment>AWK16_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk15_en" pos="15" rst="0x0">
          <comment>AWK15_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk14_en" pos="14" rst="0x0">
          <comment>AWK14_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk13_en" pos="13" rst="0x0">
          <comment>AWK13_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk12_en" pos="12" rst="0x0">
          <comment>AWK12_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk11_en" pos="11" rst="0x0">
          <comment>AWK11_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk10_en" pos="10" rst="0x0">
          <comment>AWK10_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk9_en" pos="9" rst="0x0">
          <comment>AWK9_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk8_en" pos="8" rst="0x0">
          <comment>AWK8_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk7_en" pos="7" rst="0x0">
          <comment>AWK7_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk6_en" pos="6" rst="0x0">
          <comment>AWK6_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk5_en" pos="5" rst="0x0">
          <comment>AWK5_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk4_en" pos="4" rst="0x0">
          <comment>AWK4_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk3_en" pos="3" rst="0x0">
          <comment>AWK3_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk2_en" pos="2" rst="0x0">
          <comment>AWK2_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk1_en" pos="1" rst="0x0">
          <comment>AWK1_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk0_en" pos="0" rst="0x0">
          <comment>AWK0_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="ap_awk_st" protect="rw">
        <comment>AP_AWK_ST</comment>
      </reg>
      <reg name="cp_awk_en" protect="rw">
        <comment>CP_AWK_EN CP wakeup enable register</comment>
        <bits access="rw" name="cp_p2_awk_en" pos="31" rst="0x0">
          <comment>P2_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_t6_awk_en" pos="30" rst="0x0">
          <comment>T6_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_t5_awk_en" pos="29" rst="0x0">
          <comment>T5_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_t4_awk_en" pos="28" rst="0x0">
          <comment>T4_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_t3_awk_en" pos="27" rst="0x0">
          <comment>T3_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_t2_awk_en" pos="26" rst="0x0">
          <comment>T2_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_t1_awk_en" pos="25" rst="0x0">
          <comment>T1_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_p1_awk_en" pos="24" rst="0x0">
          <comment>P1_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk23_en" pos="23" rst="0x0">
          <comment>AWK23_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk22_en" pos="22" rst="0x0">
          <comment>AWK22_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk21_en" pos="21" rst="0x0">
          <comment>AWK21_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk20_en" pos="20" rst="0x0">
          <comment>AWK20_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk19_en" pos="19" rst="0x0">
          <comment>AWK19_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk18_en" pos="18" rst="0x0">
          <comment>AWK18_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk17_en" pos="17" rst="0x0">
          <comment>AWK17_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk16_en" pos="16" rst="0x0">
          <comment>AWK16_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk15_en" pos="15" rst="0x0">
          <comment>AWK15_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk14_en" pos="14" rst="0x0">
          <comment>AWK14_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk13_en" pos="13" rst="0x0">
          <comment>AWK13_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk12_en" pos="12" rst="0x0">
          <comment>AWK12_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk11_en" pos="11" rst="0x0">
          <comment>AWK11_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk10_en" pos="10" rst="0x0">
          <comment>AWK10_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk9_en" pos="9" rst="0x0">
          <comment>AWK9_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk8_en" pos="8" rst="0x0">
          <comment>AWK8_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk7_en" pos="7" rst="0x0">
          <comment>AWK7_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk6_en" pos="6" rst="0x0">
          <comment>AWK6_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk5_en" pos="5" rst="0x0">
          <comment>AWK5_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk4_en" pos="4" rst="0x0">
          <comment>AWK4_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk3_en" pos="3" rst="0x0">
          <comment>AWK3_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk2_en" pos="2" rst="0x0">
          <comment>AWK2_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk1_en" pos="1" rst="0x0">
          <comment>AWK1_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk0_en" pos="0" rst="0x0">
          <comment>AWK0_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cp_awk_st" protect="rw">
        <comment>CP_AWK_ST</comment>
      </reg>
      <reg name="cp_lps_sta" protect="rw">
        <comment>CP_LPS_STA</comment>
        <bits access="rw" name="cp_perip_awk_stat" pos="4" rst="0x0">
          <comment>CP AKW valid
0:disvalid
1:valid</comment>
        </bits>
        <bits access="rw" name="cp_pow_ack_stat" pos="3" rst="0x0">
          <comment>CP_POW_ACK sta(sleep end)
0：LOW
1：HIGH</comment>
        </bits>
        <bits access="rw" name="cp_lps_end_stat" pos="2" rst="0x0">
          <comment>CP_LPS end sta
0:don't sleep
1:IDLE  end</comment>
        </bits>
        <bits access="rw" name="cp_awk_up_stat" pos="1" rst="0x0">
          <comment>paging awk（just P1 awk）
0:no paging awk
1:paging  awk</comment>
        </bits>
        <bits access="rw" name="cp_lps_stat" pos="0" rst="0x0">
          <comment>SYS state
0:  normal working
1:  low power mode</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cp_p1_time" protect="rw">
        <comment>CP_P1_TIME</comment>
      </reg>
      <reg name="cp_p2_time" protect="rw">
        <comment>CP_P2_TIME</comment>
      </reg>
      <reg name="lps_t_time1" protect="rw">
        <comment>LPS_T_TIME1</comment>
      </reg>
      <reg name="lps_t_time2" protect="rw">
        <comment>LPS_T_TIME2</comment>
      </reg>
      <reg name="lps_t_time3" protect="rw">
        <comment>LPS_T_TIME3</comment>
      </reg>
      <reg name="lps_t_time4" protect="rw">
        <comment>LPS_T_TIME4</comment>
      </reg>
      <reg name="lps_t_time5" protect="rw">
        <comment>LPS_T_TIME5</comment>
      </reg>
      <reg name="lps_t_time6" protect="rw">
        <comment>LPS_T_TIME6</comment>
      </reg>
      <reg name="load_en" protect="rw">
        <comment>LOAD_EN</comment>
        <bits access="rw" name="load_en" pos="0" rst="0x0">
          <comment>load_time enable
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_32k_ref" protect="rw">
        <comment>LPS_32K_REF 32K reference counter</comment>
      </reg>
      <reg name="ref_32k_fnl" protect="rw">
        <comment>REF_32K_FNL REF_32K CONT clocked register</comment>
      </reg>
      <reg name="lps_tpctrl" protect="rw">
        <comment>LPS_TPCTRL time stamp register</comment>
        <bits access="rw" name="tstamp_confg" pos="1" rst="0x0">
          <comment>0: bit 0 control the time stamp, bit 0 auto clear to be 0 after time stamp finsihed.
1:time stamp loop</comment>
        </bits>
        <bits access="rw" name="tstamp_en" pos="0" rst="0x0">
          <comment>1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="lps_tp_sta" protect="rw">
        <comment>LPS_TP_STA</comment>
        <bits access="rw" name="tp_sta0" pos="0" rst="0x0">
          <comment>1:tstamp saved
0:nothing</comment>
        </bits>
      </reg>
      <reg name="load_time" protect="rw">
        <comment>LOAD_TIME</comment>
      </reg>
      <reg name="mon_sel" protect="rw">
        <comment>MON_SEL</comment>
        <bits access="rw" name="mon15_sel" pos="31:30" rst="0x0">
          <comment>mon15_sel:
00: select t5_awk
01: select awake[5]
10: select awake[12]
11: select awake[21]</comment>
        </bits>
        <bits access="rw" name="mon14_sel" pos="29:28" rst="0x0">
          <comment>mon14_sel:
00: select t4_awk
01: select awake[4]
10: select awake[11]
11: select awake[20]</comment>
        </bits>
        <bits access="rw" name="mon13_sel" pos="27:26" rst="0x0">
          <comment>mon13_sel:
00: select t3_awk
01: select awake[3]
10: select awake[10]
11: select awake[19]</comment>
        </bits>
        <bits access="rw" name="mon12_sel" pos="25:24" rst="0x0">
          <comment>mon12_sel:
00: select t2_awk
01: select awake[2]
10: select awake[9]
11: select awake[18]</comment>
        </bits>
        <bits access="rw" name="mon11_sel" pos="23:22" rst="0x0">
          <comment>mon11_sel:
00: select t1_awk
01: select awake[1]
10: select awake[8]
11: select awake[17]</comment>
        </bits>
        <bits access="rw" name="mon10_sel" pos="21:20" rst="0x0">
          <comment>mon10_sel:
00: select p2_int
01: select awake[0]
10: select awake[7]
11: select awake[16]</comment>
        </bits>
        <bits access="rw" name="mon9_sel" pos="19:18" rst="0x0">
          <comment>mon9_sel:
00: select p1_awk
01: select chip_pd
10: select awake[6]
11: select awake[15]</comment>
        </bits>
        <bits access="rw" name="mon8_sel" pos="17:16" rst="0x0">
          <comment>mon8_sel:
00: select awake[22]
01: select awake[23]
10: select t6_awk
11: select awake[14]</comment>
        </bits>
        <bits access="rw" name="mon7_sel" pos="15:14" rst="0x0">
          <comment>mon7_sel:
00: select ap_chip_pd
01: select cp_ship_pd
10: select pd_aon_shutdown_d_b.
11: select awake[13]</comment>
        </bits>
        <bits access="rw" name="mon6_sel" pos="13:12" rst="0x0">
          <comment>mon6_sel:
00: select ap_pd_xtal
01: select cp_pd_xtal
10: select pd_aon_shutdown_m_b.
11: select t6_int.</comment>
        </bits>
        <bits access="rw" name="mon5_sel" pos="11:10" rst="0x0">
          <comment>mon5_sel:
00: select ap_pd_pll
01: select cp_pd_pll
10: select pd_aon_mem.
11: select t5_int.</comment>
        </bits>
        <bits access="rw" name="mon4_sel" pos="9:8" rst="0x0">
          <comment>mon4_sel:
00: select ap_lps_cg
01: select cp_lps_cg
10: select rst_aon_n.
11: select t4_int.</comment>
        </bits>
        <bits access="rw" name="mon3_sel" pos="7:6" rst="0x0">
          <comment>mon3_sel:
00: select ap_pow_on_ack
01: select cp_pow_on_ack
10: select pd_aon_iso.
11: select t3_int.</comment>
        </bits>
        <bits access="rw" name="mon2_sel" pos="5:4" rst="0x0">
          <comment>mon2_sel:
00: select ap_pow_on
01: select cp_pow_on
10: select clk_en_aon.
11: select t2_int.</comment>
        </bits>
        <bits access="rw" name="mon1_sel" pos="3:2" rst="0x0">
          <comment>mon1_sel:
00: select idst_ap
01: select idst_cp.
10: select idst_aon
11: select t1_int</comment>
        </bits>
        <bits access="rw" name="mon0_sel" pos="1:0" rst="0x0">
          <comment>mon0_sel:
00: select idct_ap.
01: select idct_cp.
10: select pm2_mode_en.
11: select p1_int</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="lps_res0" protect="rw">
        <comment>LPS_RES0</comment>
      </reg>
      <reg name="lps_res1" protect="rw">
        <comment>LPS_RES1</comment>
      </reg>
      <reg name="lps_res2" protect="rw">
        <comment>LPS_RES2</comment>
      </reg>
      <reg name="lps_res3" protect="rw">
        <comment>LPS_RES3</comment>
      </reg>
      <reg name="lps_res4" protect="rw">
        <comment>LPS_RES4</comment>
      </reg>
      <reg name="lps_res5" protect="rw">
        <comment>LPS_RES5</comment>
      </reg>
      <reg name="lps_res6" protect="rw">
        <comment>LPS_RES6</comment>
      </reg>
      <reg name="lps_res7" protect="rw">
        <comment>LPS_RES7</comment>
      </reg>
      <reg name="lps_res8" protect="rw">
        <comment>LPS_RES8</comment>
      </reg>
      <reg name="lps_res9" protect="rw">
        <comment>LPS_RES9</comment>
      </reg>
      <reg name="lps_res10" protect="rw">
        <comment>LPS_RES10</comment>
      </reg>
      <reg name="lps_res11" protect="rw">
        <comment>LPS_RES11</comment>
      </reg>
      <reg name="cp_p1_en" protect="rw">
        <comment>CP_P1_EN</comment>
        <bits access="rw" name="lps_p1_en" pos="0" rst="0x0">
          <comment>paging timer en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="cp_p2_en" protect="rw">
        <comment>CP_P2_TEN</comment>
        <bits access="rw" name="lps_p2_en" pos="0" rst="0x0">
          <comment>awake timer en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t1_en" protect="rw">
        <comment>LPS_T1_EN</comment>
        <bits access="rw" name="lps_t1_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t2_en" protect="rw">
        <comment>LPS_T2_EN</comment>
        <bits access="rw" name="lps_t2_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t3_en" protect="rw">
        <comment>LPS_T3_EN</comment>
        <bits access="rw" name="lps_t3_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t4_en" protect="rw">
        <comment>LPS_T4_EN</comment>
        <bits access="rw" name="lps_t4_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t5_en" protect="rw">
        <comment>LPS_T5_EN</comment>
        <bits access="rw" name="lps_t5_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t6_en" protect="rw">
        <comment>LPS_T6_EN</comment>
        <bits access="rw" name="lps_t6_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="ap_awk_en1" protect="rw">
        <comment>AP_AWK_EN1</comment>
        <bits access="rw" name="ap_t9_awk_en" pos="2" rst="0x0">
          <comment>T9_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_t8_awk_en" pos="1" rst="0x0">
          <comment>T8_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_t7_awk_en" pos="0" rst="0x0">
          <comment>T7_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="ap_awk_st1" protect="rw">
        <comment>AP_AWK_ST1</comment>
        <bits access="rw" name="ap_awk_sta1" pos="2:0" rst="0x0">
          <comment>clear ap wake state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="cp_awk_en1" protect="rw">
        <comment>CP_AWK_EN1</comment>
        <bits access="rw" name="cp_t9_awk_en" pos="2" rst="0x0">
          <comment>T9_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_t8_awk_en" pos="1" rst="0x0">
          <comment>T8_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_t7_awk_en" pos="0" rst="0x0">
          <comment>T7_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cp_awk_st1" protect="rw">
        <comment>CP_AWK_ST1</comment>
        <bits access="rw" name="cp_awk_sta1" pos="2:0" rst="0x0">
          <comment>clear ap wake state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="lps_t_time7" protect="rw">
        <comment>LPS_T_TIME7</comment>
      </reg>
      <reg name="lps_t_time8" protect="rw">
        <comment>LPS_T_TIME8</comment>
      </reg>
      <reg name="lps_t_time9" protect="rw">
        <comment>LPS_T_TIME9</comment>
      </reg>
      <reg name="lps_t7_en" protect="rw">
        <comment>LPS_T7_EN</comment>
        <bits access="rw" name="lps_t7_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t8_en" protect="rw">
        <comment>LPS_T8_EN</comment>
        <bits access="rw" name="lps_t8_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t9_en" protect="rw">
        <comment>LPS_T9_EN</comment>
        <bits access="rw" name="lps_t9_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="cp_pm2_mode_en" protect="rw">
        <comment>CP_PM2_MODE_EN CP PM2 enable</comment>
        <bits access="rw" name="cp_pm2_mode_en" pos="0" rst="0x0">
          <comment>CP enable PM2 mode
0:enable PM2 mode
1:disable PM2 mode</comment>
        </bits>
      </reg>
      <hole size="576"/>
      <reg name="cp_inten_set" protect="rw"/>
      <hole size="96"/>
      <reg name="ap_inten_set" protect="rw"/>
      <hole size="96"/>
      <reg name="ap_awk_en_set" protect="rw"/>
      <hole size="96"/>
      <reg name="cp_awk_en_set" protect="rw"/>
      <hole size="608"/>
      <reg name="mon_sel_set" protect="rw"/>
      <hole size="352"/>
      <reg name="cp_inten_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="ap_inten_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="ap_awk_en_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="ap_awk_en1_set" protect="rw"/>
      <reg name="cp_awk_en_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="cp_awk_en1_set" protect="rw"/>
      <hole size="512"/>
      <reg name="mon_sel_clr" protect="rw"/>
      <hole size="704"/>
      <reg name="ap_awk_en1_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="cp_awk_en1_clr" protect="rw"/>
    </module>
    <var name="REG_IDLE_LPS_SET_OFFSET" value="0x160"/>
    <var name="REG_IDLE_LPS_CLR_OFFSET" value="0x210"/>
    <instance address="0x51702000" name="IDLE_LPS" type="IDLE_LPS"/>
  </archive>
  <archive relative="lps_clk.xml">
    <module category="System" name="LPS_CLK">
      <reg name="user_gate_force_off" protect="rw">
        <comment>user_gate_force_off</comment>
        <bits access="rw" name="lps_ahb_ana_wrap3_force_off" pos="17" rst="0x0">
          <comment>lps_ahb_ana_wrap3_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_idle_lps_force_off" pos="16" rst="0x0">
          <comment>lps_ahb_idle_lps_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_pwrctrl_func_force_off" pos="15" rst="0x0">
          <comment>lps_ahb_pwrctrl_func_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_pwrctrl_intf_force_off" pos="14" rst="0x0">
          <comment>lps_ahb_pwrctrl_intf_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_osc_force_off" pos="13" rst="0x0">
          <comment>lps_ahb_keypad_osc_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_always_force_off" pos="12" rst="0x0">
          <comment>lps_ahb_keypad_always_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_force_off" pos="11" rst="0x0">
          <comment>lps_ahb_keypad_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_apb_reg_force_off" pos="10" rst="0x0">
          <comment>lps_ahb_apb_reg_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpt1_force_off" pos="9" rst="0x0">
          <comment>lps_ahb_gpt1_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpio_mod_force_off" pos="8" rst="0x0">
          <comment>lps_ahb_gpio_mod_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpio1_force_off" pos="7" rst="0x0">
          <comment>lps_ahb_gpio1_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_force_off" pos="6" rst="0x0">
          <comment>lps_ahb_uart1_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_always_force_off" pos="5" rst="0x0">
          <comment>lps_ahb_uart1_always_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_mod_force_off" pos="4" rst="0x0">
          <comment>lps_ahb_uart1_mod_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_to_aon_force_off" pos="3" rst="0x0">
          <comment>lps_ahb_to_aon_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_32k_fr_force_off" pos="2" rst="0x0">
          <comment>lps_32k_fr_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="uart1_bf_div_uart1_always_force_off" pos="1" rst="0x0">
          <comment>uart1_bf_div_uart1_always_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="uart1_bf_div_uart1_force_off" pos="0" rst="0x0">
          <comment>uart1_bf_div_uart1_force_off force clk on, default : 1'b0</comment>
        </bits>
      </reg>
      <reg name="user_gate_auto_gate_en" protect="rw">
        <comment>user_gate_auto_gate_en</comment>
        <bits access="rw" name="lps_ahb_ana_wrap3_auto_gate_en" pos="17" rst="0x1">
          <comment>lps_ahb_ana_wrap3_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_idle_lps_auto_gate_en" pos="16" rst="0x1">
          <comment>lps_ahb_idle_lps_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_pwrctrl_func_auto_gate_en" pos="15" rst="0x1">
          <comment>lps_ahb_pwrctrl_func_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_pwrctrl_intf_auto_gate_en" pos="14" rst="0x1">
          <comment>lps_ahb_pwrctrl_intf_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_osc_auto_gate_en" pos="13" rst="0x1">
          <comment>lps_ahb_keypad_osc_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_always_auto_gate_en" pos="12" rst="0x1">
          <comment>lps_ahb_keypad_always_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_auto_gate_en" pos="11" rst="0x1">
          <comment>lps_ahb_keypad_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_apb_reg_auto_gate_en" pos="10" rst="0x1">
          <comment>lps_ahb_apb_reg_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpt1_auto_gate_en" pos="9" rst="0x1">
          <comment>lps_ahb_gpt1_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpio_mod_auto_gate_en" pos="8" rst="0x1">
          <comment>lps_ahb_gpio_mod_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpio1_auto_gate_en" pos="7" rst="0x1">
          <comment>lps_ahb_gpio1_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_auto_gate_en" pos="6" rst="0x1">
          <comment>lps_ahb_uart1_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_always_auto_gate_en" pos="5" rst="0x1">
          <comment>lps_ahb_uart1_always_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_mod_auto_gate_en" pos="4" rst="0x1">
          <comment>lps_ahb_uart1_mod_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_to_aon_auto_gate_en" pos="3" rst="0x1">
          <comment>lps_ahb_to_aon_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_32k_fr_auto_gate_en" pos="2" rst="0x1">
          <comment>lps_32k_fr_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="uart1_bf_div_uart1_always_auto_gate_en" pos="1" rst="0x1">
          <comment>uart1_bf_div_uart1_always_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="uart1_bf_div_uart1_auto_gate_en" pos="0" rst="0x1">
          <comment>uart1_bf_div_uart1_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
      </reg>
      <hole size="256"/>
      <reg name="cgm_uart1_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart1_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart1_bf_div_sel" pos="1:0" rst="0x1">
          <comment>cgm_uart1_bf_div_sel: clk_uart1_bf_div source , 0: rtc_32k, 1: xtal_lp_26m, 2: xtal_26m, 3: rc26m_26m, default: 2'h1</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="cgm_lps_ahb_sel_cfg" protect="rw">
        <comment>cgm_lps_ahb_sel_cfg</comment>
        <bits access="rw" name="cgm_lps_ahb_sel" pos="1:0" rst="0x1">
          <comment>cgm_lps_ahb_sel: clk_lps_ahb source , 0: rtc_32k, 1: xtal_lp_26m, 2: xtal_26m, 3: rc26m_26m, default: 2'h1</comment>
        </bits>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg0" protect="rw">
        <comment>cgm_busy_src_monitor_cfg0</comment>
        <bits access="r" name="cgm_busy_src_monitor0" pos="8:0">
          <comment>cgm_busy_src_monitor0, 0:(cgm_uart1_bf_div_sel_ac == 2) &amp; cgm_busy_uart1_bf_div 1:cgm_busy_lps_ahb_sel_2 &amp; cgm_busy_lps_ahb 2:(cgm_uart1_bf_div_sel_ac == 1) &amp; cgm_busy_uart1_bf_div 3:cgm_busy_lps_ahb_sel_1 &amp; cgm_busy_lps_ahb 4:(cgm_uart1_bf_div_sel_ac == 3) &amp; cgm_busy_uart1_bf_div 5:cgm_busy_lps_ahb_sel_3 &amp; cgm_busy_lps_ahb 6:(cgm_uart1_bf_div_sel_ac == 0) &amp; cgm_busy_uart1_bf_div 7:cgm_busy_lps_32k 8:cgm_busy_lps_ahb_sel_0 &amp; cgm_busy_lps_ahb</comment>
        </bits>
      </reg>
      <hole size="1472"/>
      <reg name="user_gate_force_off_set" protect="rw"/>
      <reg name="user_gate_auto_gate_en_set" protect="rw"/>
      <hole size="1984"/>
      <reg name="user_gate_force_off_clr" protect="rw"/>
      <reg name="user_gate_auto_gate_en_clr" protect="rw"/>
    </module>
    <var name="REG_LPS_CLK_SET_OFFSET" value="0x100"/>
    <var name="REG_LPS_CLK_CLR_OFFSET" value="0x200"/>
    <instance address="0x51701000" name="LPS_CLK" type="LPS_CLK"/>
  </archive>
  <archive relative="lps_clk_gen.xml">
    <module category="System" name="LPS_CLK_GEN">
      <hole size="256"/>
      <reg name="soft_cnt_done0_cfg" protect="rw">
        <comment>soft_cnt_done0_cfg</comment>
        <bits access="rw" name="rc26m_26m_soft_cnt_done" pos="0" rst="0x1">
          <comment>rc26m_26m_soft_cnt_done counter wait for source stable</comment>
        </bits>
      </reg>
      <reg name="pll_wait_sel0_cfg" protect="rw">
        <comment>pll_wait_sel0_cfg</comment>
        <bits access="rw" name="rc26m_26m_wait_auto_gate_sel" pos="0" rst="0x1">
          <comment>rc26m_26m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
      </reg>
      <reg name="pll_wait_sw_ctl0_cfg" protect="rw">
        <comment>pll_wait_sw_ctl0_cfg</comment>
        <bits access="rw" name="rc26m_26m_wait_force_en" pos="0" rst="0x1">
          <comment>rc26m_26m_wait_force_en pll wait's enable sw control</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="gate_en_sel0_cfg" protect="rw">
        <comment>gate_en_sel0_cfg</comment>
        <bits access="rw" name="cgm_rtc_32k_ap_auto_gate_sel" pos="6" rst="0x1">
          <comment>cgm_rtc_32k_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_ap_auto_gate_sel" pos="5" rst="0x1">
          <comment>cgm_rc_26m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_cp_auto_gate_sel" pos="4" rst="0x1">
          <comment>cgm_rtc_32k_cp_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_aon_auto_gate_sel" pos="3" rst="0x1">
          <comment>cgm_rtc_32k_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_aon_auto_gate_sel" pos="2" rst="0x1">
          <comment>cgm_rc_26m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_lps_auto_gate_sel" pos="1" rst="0x1">
          <comment>cgm_rtc_32k_lps_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_lps_auto_gate_sel" pos="0" rst="0x1">
          <comment>cgm_rc_26m_lps_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
      </reg>
      <reg name="gate_en_sw_ctl0_cfg" protect="rw">
        <comment>gate_en_sw_ctl0_cfg</comment>
        <bits access="rw" name="cgm_rtc_32k_ap_force_en" pos="6" rst="0x1">
          <comment>cgm_rtc_32k_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_ap_force_en" pos="5" rst="0x1">
          <comment>cgm_rc_26m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_cp_force_en" pos="4" rst="0x1">
          <comment>cgm_rtc_32k_cp_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_aon_force_en" pos="3" rst="0x1">
          <comment>cgm_rtc_32k_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_aon_force_en" pos="2" rst="0x1">
          <comment>cgm_rc_26m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_lps_force_en" pos="1" rst="0x1">
          <comment>cgm_rtc_32k_lps_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_lps_force_en" pos="0" rst="0x1">
          <comment>cgm_rc_26m_lps_force_en clock gating enable sw control</comment>
        </bits>
      </reg>
      <reg name="monitor_wait_en_status0_cfg" protect="rw">
        <comment>monitor_wait_en_status0_cfg</comment>
        <bits access="r" name="monitor_wait_en_status" pos="0" rst="0x0">
          <comment>monitor_wait_en_status , 0:rc26m_26m</comment>
        </bits>
      </reg>
      <reg name="monitor_gate_auto_en_status0_cfg" protect="rw">
        <comment>monitor_gate_auto_en_status0_cfg</comment>
        <bits access="r" name="monitor_gate_auto_en_status" pos="6:0" rst="0x0">
          <comment>monitor_gate_auto_en_status , 0:cgm_rtc_32k_ap, 1:cgm_rc_26m_ap, 2:cgm_rtc_32k_cp, 3:cgm_rtc_32k_aon, 4:cgm_rc_26m_aon, 5:cgm_rtc_32k_lps, 6:cgm_rc_26m_lps</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51708000" name="LPS_CLK_GEN" type="LPS_CLK_GEN"/>
  </archive>
  <archive relative="pub_apb.xml">
    <module category="System" name="PUB_APB">
      <reg name="apb_eb" protect="rw">
        <comment>module enable module enable</comment>
        <bits access="rw" name="reserved_eb" pos="2" rst="0x0">
          <comment>Reserved Enable. Active High;
0 : Disable ;
1 : Enable ;</comment>
        </bits>
        <bits access="rw" name="mtx_cfg_eb" pos="1" rst="0x0">
          <comment>mtx_cfg Enable. Active High;
0 : Disable ;
1 : Enable ;</comment>
        </bits>
        <bits access="rw" name="pagespy_eb" pos="0" rst="0x0">
          <comment>pagespy Enable. Active High;
0 : Disable ;
1 : Enable ;</comment>
        </bits>
      </reg>
      <reg name="apb_soft_rst" protect="rw">
        <comment>Soft Reset  Soft Reset</comment>
        <bits access="rw" name="reserved_soft_rst" pos="3" rst="0x0">
          <comment>Reserved Soft Reset. Active High;
0 : Keep module in normal mode;
1 : Reset module;</comment>
        </bits>
        <bits access="rw" name="mtx_cfg_rst" pos="2" rst="0x0">
          <comment>mtx_cfg Soft Reset. Active High;
0 : Keep module in normal mode;
1 : Reset module;</comment>
        </bits>
        <bits access="rw" name="dmc400_soft_rst" pos="1" rst="0x0">
          <comment>dmc400 Soft Reset. Active High;
0 : Keep module in normal mode;
1 : Reset module;</comment>
        </bits>
        <bits access="rw" name="pagespy_soft_rst" pos="0" rst="0x0">
          <comment>pagespy Soft Reset. Active High;
0 : Keep module in normal mode;
1 : Reset module;</comment>
        </bits>
      </reg>
      <reg name="debug_ctrl" protect="rw">
        <comment>debug_ctrl debug_ctrl</comment>
      </reg>
      <reg name="slp_ctrl" protect="rw">
        <comment>psram sleep ctrl psram sleep ctrl</comment>
        <bits access="rw" name="half_slp_reg" pos="19" rst="0x0">
          <comment>half_slp_reg</comment>
        </bits>
        <bits access="rw" name="enable" pos="18" rst="0x0">
          <comment>enable</comment>
        </bits>
        <bits access="rw" name="force_reg" pos="17" rst="0x0">
          <comment>force_reg</comment>
        </bits>
        <bits access="rw" name="force_en" pos="16" rst="0x0">
          <comment>force_en</comment>
        </bits>
        <bits access="rw" name="wait_num" pos="15:0" rst="0x0">
          <comment>wait_num</comment>
        </bits>
      </reg>
      <reg name="lps_gate_sel" protect="rw">
        <comment>psram gate_sel psram gate_sel</comment>
        <bits access="rw" name="cgm_gate_auto_sel" pos="9:0" rst="0x3ff">
          <comment>gate_auto_sel</comment>
        </bits>
      </reg>
      <reg name="lps_gate_force" protect="rw">
        <comment>psram gate_force psram gate_force</comment>
        <bits access="rw" name="cgm_gate_force_en" pos="9:0" rst="0x3ff">
          <comment>gate_force_en</comment>
        </bits>
      </reg>
      <reg name="cgm_psram" protect="rw">
        <comment>cgm_psram cgm_psram</comment>
        <bits access="rw" name="sel_2x" pos="7:5" rst="0x0">
          <comment>cgm_psram_2x_sel</comment>
        </bits>
        <bits access="rw" name="div_2x" pos="4:3" rst="0x0">
          <comment>cgm_psram_2x_div</comment>
        </bits>
        <bits access="rw" name="div_1x" pos="1" rst="0x0">
          <comment>cgm_psram_1x_div</comment>
        </bits>
      </reg>
      <reg name="lpc_ctrl0" protect="rw">
        <comment>lpc_ctrl0 lpc_ctrl0</comment>
        <bits access="rw" name="pu_num" pos="23:16" rst="0x0">
          <comment>pu_num</comment>
        </bits>
        <bits access="rw" name="lp_num" pos="15:0" rst="0x80">
          <comment>lp_num</comment>
        </bits>
      </reg>
      <reg name="lpc_ctrl1" protect="rw">
        <comment>lpc_ctrl1 lpc_ctrl1</comment>
        <bits access="rw" name="lp_force" pos="1" rst="0x0">
          <comment>lp_force</comment>
        </bits>
        <bits access="rw" name="lp_eb" pos="0" rst="0x0">
          <comment>lp_eb</comment>
        </bits>
      </reg>
      <reg name="pub_anti_hang" protect="rw">
        <comment>pub_anti_hang pub_anti_hang</comment>
        <bits access="rw" name="error_resp_en" pos="4" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="reserved2_en" pos="2" rst="0x1">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="reserved1_en" pos="1" rst="0x1">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="pagespy_id_sel" pos="0" rst="0x1">
          <comment>1: select fw ID
0: select matrix id</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="monitor_clk" protect="rw">
        <comment>monitor_clock_status monitor_clock_status</comment>
        <bits access="r" name="cgm_busy_status" pos="21:12" rst="0x0">
          <comment>monitor_cgm_busy_status</comment>
        </bits>
        <bits access="r" name="gate_en_status" pos="9:0" rst="0x0">
          <comment>monitor_gate_en_status</comment>
        </bits>
      </reg>
      <reg name="debug_status" protect="rw">
        <comment>debug_status debug_status</comment>
      </reg>
      <hole size="1600"/>
      <reg name="apb_eb_set" protect="rw"/>
      <reg name="apb_soft_rst_set" protect="rw"/>
      <hole size="64"/>
      <reg name="lps_gate_sel_set" protect="rw"/>
      <reg name="lps_gate_force_set" protect="rw"/>
      <hole size="64"/>
      <reg name="lpc_ctrl1_set" protect="rw"/>
      <reg name="pub_anti_hang_set" protect="rw"/>
      <hole size="1728"/>
      <reg name="apb_eb_clr" protect="rw"/>
      <reg name="apb_soft_rst_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="lps_gate_sel_clr" protect="rw"/>
      <reg name="lps_gate_force_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="lpc_ctrl1_clr" protect="rw"/>
      <reg name="pub_anti_hang_clr" protect="rw"/>
    </module>
    <var name="REG_PUB_APB_SET_OFFSET" value="0x100"/>
    <var name="REG_PUB_APB_CLR_OFFSET" value="0x200"/>
    <instance address="0x51603000" name="PUB_APB" type="PUB_APB"/>
  </archive>
  <archive relative="rf_dfe.xml">
    <module category="System" name="RF_DFE">
      <reg name="general_mode" protect="rw">
        <comment/>
        <bits access="rw" name="reset_mode" pos="14" rst="0x0">
          <comment>1: use external resetn
0: use sw/enable generated internal resetn for rxdp</comment>
        </bits>
        <bits access="rw" name="clk_dac_inv_mode" pos="13" rst="0x0">
          <comment>0: clk_dac
1: clk_dac invert</comment>
        </bits>
        <bits access="rw" name="clk_adc_inv_mode" pos="12" rst="0x0">
          <comment>0: clk_adc
1: clk_adc invert</comment>
        </bits>
        <bits access="rw" name="rx_mode" pos="7:4" rst="0x0">
          <comment>0:no use
1:no use
2:LTE-1.4M
3:LTE-3M
4:LTE-5M
5:LTE-10M
6:LTE-15M
7:LTE-20M
8:no use</comment>
        </bits>
        <bits access="rw" name="adc_clk_mode" pos="2:1" rst="0x0">
          <comment>0:30.72MHz
1:61.44MHz
2:122.88MHz</comment>
        </bits>
        <bits access="rw" name="zf_if_mode" pos="0" rst="0x0">
          <comment>0: IF mode
1: ZF mode</comment>
        </bits>
      </reg>
      <reg name="dfe_clock_gate_enable_reg" protect="rw">
        <comment/>
        <bits access="rw" name="reg_clkgate_en" pos="14" rst="0x0">
          <comment>0: registers module clk gating enabled;
1: registers module clk always on;
new add for debug, should not config</comment>
        </bits>
        <bits access="rw" name="txdp_loft_mode" pos="13" rst="0x0">
          <comment>0: RX CIC1 doesn't work in loft mode;
1: RX CIC1 works in loft mode</comment>
        </bits>
        <bits access="rw" name="sw_resetn" pos="9" rst="0x1">
          <comment>sw controlled resetn for rxdp
0: assert reset
1: not reset</comment>
        </bits>
        <bits access="rw" name="clk_rate_convert_rg" pos="8" rst="0x0">
          <comment>DFE clock shift control. Change in 8910m, when clock_shift enable, only config this bit, no need config rxdp_rc or txdp_rc (deleted)
0: clock shift disabled
1: clock shift enabled. When it is enabled, all DFE clocks except GSM TX clock are working in 17/16 normal frequency</comment>
        </bits>
        <bits access="rw" name="clk_122p88m_en" pos="6" rst="0x1">
          <comment>clock enable for BB LTE @122.88MHz</comment>
        </bits>
        <bits access="rw" name="txdp_nb_dfe_clk_en" pos="4" rst="0x0">
          <comment>clock enable for DFE NB/WT/LTE TX</comment>
        </bits>
        <bits access="rw" name="rxdp_dfe_clk_en" pos="2" rst="0x0">
          <comment>clock enable for DFE RX</comment>
        </bits>
        <bits access="rw" name="txdp_clk_dac_en" pos="1" rst="0x0">
          <comment>clock enable for DAC</comment>
        </bits>
        <bits access="rw" name="rxdp_adc_clk_en" pos="0" rst="0x0">
          <comment>clock eanble for ADC</comment>
        </bits>
      </reg>
      <reg name="rxdp_dcc" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_dcc_load" pos="6" rst="0x0">
          <comment>Start to load DC value, active high. Before next load, set it low firstly</comment>
        </bits>
        <bits access="rw" name="dcc_imgrej_rg" pos="5" rst="0x0">
          <comment>IQ swap in DC module
0: no swap
1. swap</comment>
        </bits>
        <bits access="rw" name="dcc_hold_en_rg" pos="4" rst="0x0">
          <comment>Hold DC accumulator calculation in DC calibration mode</comment>
        </bits>
        <bits access="rw" name="dcc_bypass_rg" pos="3" rst="0x0">
          <comment>This register is not used. But DC module bypass is actrually controlled by register rxdp_bypass_dcc and rxdp_bypass_mode_dcc</comment>
        </bits>
        <bits access="rw" name="dcc_dc_delta_ld_st_rg" pos="2" rst="0x0">
          <comment>Store initial value to DC accumulator at positive edge in DC cancel mode or DC calibration mode.</comment>
        </bits>
        <bits access="rw" name="dcc_dc_calib_en_rg" pos="1" rst="0x0">
          <comment>Load DC value in calibration mode to debug port, only used for debug purpose</comment>
        </bits>
        <bits access="rw" name="dcc_rx_calib_sel_rg" pos="0" rst="0x0">
          <comment>DC module work mode.
0: DC calibration mode
1: DC cancel mode</comment>
        </bits>
      </reg>
      <reg name="rxdp_dc_calib_re" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_dc_calib_re_rg" pos="15:0" rst="0x0">
          <comment>DC real part value used in cancel mode</comment>
        </bits>
      </reg>
      <reg name="rxdp_dc_calib_im" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_dc_calib_im_rg" pos="15:0" rst="0x0">
          <comment>DC image part value used in cancel mode</comment>
        </bits>
      </reg>
      <reg name="rxdp_dc_delta_re" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_dc_delta_re_rg" pos="15:0" rst="0x0">
          <comment>Accumulator initial real part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register</comment>
        </bits>
      </reg>
      <reg name="rxdp_dc_delta_im" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_dc_delta_im_rg" pos="15:0" rst="0x0">
          <comment>Accumulator initial image part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register</comment>
        </bits>
      </reg>
      <reg name="rxdp_dc_cr" protect="rw">
        <comment/>
        <bits access="rw" name="conv_slow_bw_ct_rg" pos="11:9" rst="0x0">
          <comment>Slow convergence control, work with conv_mode_ct_rg register</comment>
        </bits>
        <bits access="rw" name="conv_fast_bw_ct_rg" pos="8:6" rst="0x0">
          <comment>Fast convergence control, work with conv_mode_ct_rg register</comment>
        </bits>
        <bits access="rw" name="conv_tmr_ct_rg" pos="5:2" rst="0x0">
          <comment>Duration time of DC calibration, which is based on sample unit</comment>
        </bits>
        <bits access="rw" name="conv_mode_ct_rg" pos="1:0" rst="0x0">
          <comment>DC convergence loop mode selection.
0: fast
1: slow
2: fast-&gt;slow
3: fast-&gt;hold</comment>
        </bits>
      </reg>
      <reg name="rxdp_gain_ct_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gain_ct_load" pos="13" rst="0x0">
          <comment>load rxdp_gain_ct to DFE.
Write it to 1b'0 before assert it; new add, when [12]=0, need use this bit</comment>
        </bits>
        <bits access="rw" name="rxdp_gain_ct_load_bypass" pos="12" rst="0x1">
          <comment>bypass rxdp_gain_ct_load; new add,
1: direct use [10:0] in static adjust agc gain
0: use [10:0] need load first  for dynamic adjust agc gain</comment>
        </bits>
        <bits access="rw" name="rxdp_gain_ct" pos="10:0" rst="0x0">
          <comment>Gain BB control. [-24db, 47.9375db], step=1/16db;
change the step from 1/8db to 1/16db</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="rxdp_gdeq_coef0_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef0_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of RX group delay coefficient 0</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef0_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef0_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of RX group delay coefficient 0</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef1_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef1_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of RX group delay coefficient 1</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef1_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef1_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of RX group delay coefficient 1</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef2_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef2_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of RX group delay coefficient 2</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef2_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef2_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of RX group delay coefficient 2</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef3_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef3_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of RX group delay coefficient 3</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef3_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_bp_lp_sel" pos="4" rst="0x0">
          <comment>1: LP
0: BP</comment>
        </bits>
        <bits access="rw" name="rxdp_gdeq_coef3_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of RX group delay coefficient 3</comment>
        </bits>
      </reg>
      <reg name="rxdp_adc_wr_buf_fifo" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_adc_smp_rate_rg" pos="6:1" rst="0x0">
          <comment>Read rate of DFE ADC FIFO, which depends on RX mode. 8910m move 0x0060[12:7] to here[6:1]
5'h00: GGE
5'h01: NB/WT</comment>
        </bits>
        <bits access="rw" name="rxdp_adc_wr_en_rg" pos="0" rst="0x1">
          <comment>Write enable of DFE ADC FIFO, active high</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="rxdp_dcc_valid_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_dcc_val_reg" pos="0" rst="0x0">
          <comment>Valid indication of DC value after assert rxdp_dcc_load to avoid metastability. rxdp_dcc_re_o and rxdp_dcc_im_o are stable when this register is high</comment>
        </bits>
      </reg>
      <reg name="rxdp_dcc_re_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_dcc_re_o" pos="15:0" rst="0x0">
          <comment>Real part of DC value, it is stable when rxdp_dcc_val_reg is high</comment>
        </bits>
      </reg>
      <reg name="rxdp_dcc_im_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_dcc_im_o" pos="15:0" rst="0x0">
          <comment>Image part of DC value, it is stable when rxdp_dcc_val_reg is high</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch_ct" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch_dataen0" pos="1" rst="0x1">
          <comment>Data enable of Notch DC
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rxdp_notch_dataen1" pos="0" rst="0x1"/>
      </reg>
      <reg name="rxdp_notch_a0_i_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch_a0_i" pos="11:0" rst="0x0">
          <comment>Coefficient a for real part of Notch DC</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch_a0_q_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch_a0_q" pos="11:0" rst="0x0">
          <comment>Coefficient a for image part of Notch DC</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch_k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch_k0" pos="5:0" rst="0x0">
          <comment>Coefficient k of Notch DC</comment>
        </bits>
      </reg>
      <reg name="rxdp_mirror_remove" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_mrrm_bw_sel" pos="1:0" rst="0x0">
          <comment>mrrm bandwidth selection</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_ct" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_dataen0" pos="1" rst="0x1">
          <comment>Data enable of Notch H 1st core
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rxdp_notch2_dataen1" pos="0" rst="0x1">
          <comment>Data enable of Notch H 2nd core
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_a0_i_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_a0_i" pos="11:0" rst="0x0">
          <comment>Coefficient a for real part of Notch H 1st core</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_a0_q_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_a0_q" pos="11:0" rst="0x0">
          <comment>Coefficient a for image part of Notch H 1st core</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_a1_i_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_a1_i" pos="11:0" rst="0x0">
          <comment>Coefficient a for real part of Notch H 2nd core</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_a1_q_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_a1_q" pos="11:0" rst="0x0">
          <comment>Coefficient a for image part of Notch H 2nd core</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_k0" pos="11:6" rst="0x0">
          <comment>Coefficient k of Notch H 1st core</comment>
        </bits>
        <bits access="rw" name="rxdp_notch2_k1" pos="5:0" rst="0x0">
          <comment>Coefficient k of Notch H 2nd core</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef0" pos="15:0" rst="0x0">
          <comment>Coefficient COEF0 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef1" pos="15:0" rst="0x0">
          <comment>Coefficient COEF1 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef2_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef2" pos="15:0" rst="0x0">
          <comment>Coefficient COEF2 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef3" pos="15:0" rst="0x0">
          <comment>Coefficient COEF3 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef4_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef4" pos="15:0" rst="0x0">
          <comment>Coefficient COEF4 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef5_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef5" pos="15:0" rst="0x0">
          <comment>Coefficient COEF5 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef6_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef6" pos="15:0" rst="0x0">
          <comment>Coefficient COEF6 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef7_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef7" pos="15:0" rst="0x0">
          <comment>Coefficient COEF7 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef8_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef8" pos="15:0" rst="0x0">
          <comment>Coefficient COEF8 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef9_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef9" pos="15:0" rst="0x0">
          <comment>Coefficient COEF9 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef10_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef10" pos="15:0" rst="0x0">
          <comment>Coefficient COEF10 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef11_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef11" pos="15:0" rst="0x0">
          <comment>Coefficient COEF11 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef12_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef12" pos="15:0" rst="0x0">
          <comment>Coefficient COEF12 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef13_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef13" pos="15:0" rst="0x0">
          <comment>Coefficient COEF13 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef14_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef14" pos="15:0" rst="0x0">
          <comment>Coefficient COEF14 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef15_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef15" pos="15:0" rst="0x0">
          <comment>Coefficient COEF15 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef16_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef16" pos="15:0" rst="0x0">
          <comment>Coefficient COEF16 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef17_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef17" pos="15:0" rst="0x0">
          <comment>Coefficient COEF17 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef18_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef18" pos="15:0" rst="0x0">
          <comment>Coefficient COEF18 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef19_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef19" pos="15:0" rst="0x0">
          <comment>Coefficient COEF19 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef20_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef20" pos="15:0" rst="0x0">
          <comment>Coefficient COEF20 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef21_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef21" pos="15:0" rst="0x0">
          <comment>Coefficient COEF21 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef22_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef22" pos="15:0" rst="0x0">
          <comment>Coefficient COEF22 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef23_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef23" pos="15:0" rst="0x0">
          <comment>Coefficient COEF23 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_mixer_freq_in_reg0" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_mixer_freq_p0" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of frequency offset for Mixer</comment>
        </bits>
      </reg>
      <reg name="rxdp_mixer_freq_in_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_mixer_freq_p1" pos="7:0" rst="0x0">
          <comment>Bit [23:16] of frequency offset for Mixer</comment>
        </bits>
      </reg>
      <reg name="rxdp_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rssi3_enable" pos="11" rst="0x0">
          <comment>RSSI3 enable</comment>
        </bits>
        <bits access="rw" name="rxdp_rssi3_ushift" pos="10:8" rst="0x0">
          <comment>RSSI3 ushift value</comment>
        </bits>
        <bits access="rw" name="rxdp_rssi_ob_enable" pos="7" rst="0x0">
          <comment>Outband RSSI enable</comment>
        </bits>
        <bits access="rw" name="rxdp_rssi_ib_enable" pos="6" rst="0x0">
          <comment>Inband RSSI enable</comment>
        </bits>
        <bits access="rw" name="rxdp_rssi_ob_ushift" pos="5:3" rst="0x0">
          <comment>Outband RSSI ushift value</comment>
        </bits>
        <bits access="rw" name="rxdp_rssi_ib_ushift" pos="2:0" rst="0x0">
          <comment>Inband RSSI ushift value</comment>
        </bits>
      </reg>
      <reg name="rxdp_imbc_wa_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_imbc_wa" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_wq_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_imbc_wq" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_misc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_imbc_bw_fast_ct_rg" pos="10:7" rst="0x0"/>
        <bits access="rw" name="rxdp_imbc_bw_slow_ct" pos="6:3" rst="0x0"/>
        <bits access="rw" name="rxdp_imbc_hold_dr" pos="2" rst="0x0"/>
        <bits access="rw" name="rxdp_imbc_calc_rels" pos="1" rst="0x0"/>
        <bits access="rw" name="rxdp_imbc_load" pos="0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_wa_out_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_imbc_wa_out" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_wq_out_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_imbc_wq_out" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_out_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_imbc_val_out" pos="0" rst="0x0"/>
      </reg>
      <reg name="rxdp_rc_rate_ofs_period_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_rate_ofs_period" pos="9:0" rst="0x10"/>
      </reg>
      <reg name="rxdp_rc_rate_ofs_hi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_rate_ofs_hi" pos="7:0" rst="0x80"/>
      </reg>
      <reg name="rxdp_rc_rate_ofs_lo_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_rate_ofs_lo" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="start_max_min_ib_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="start_max_min_ib_rssi" pos="0" rst="0x0">
          <comment>start inband RSSI max and min measurement</comment>
        </bits>
      </reg>
      <reg name="count_16lsb_ib_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16lsb_ib_rssi" pos="15:0" rst="0x7800">
          <comment>timer count[15:0] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="count_16msb_ib_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16msb_ib_rssi" pos="15:0" rst="0x0">
          <comment>timer count[31:16] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="load_max_min_ib_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_max_min_ib_rssi" pos="0" rst="0x0">
          <comment>start to load max and min measurement report. Before next load, set it low firstly</comment>
        </bits>
      </reg>
      <reg name="rssi_min_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_min_val_reg_ib_rssi" pos="10" rst="0x0">
          <comment>valid of max and min measurement report</comment>
        </bits>
        <bits access="r" name="rssi_min_reg_ib_rssi" pos="9:0" rst="0x0">
          <comment>inband RSSI min value</comment>
        </bits>
      </reg>
      <reg name="rssi_max_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_reg_ib_rssi" pos="9:0" rst="0x0">
          <comment>inband RSSI max value, it is stable when rssi_max_min_val_reg_ib_rssi is high</comment>
        </bits>
      </reg>
      <reg name="int_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_int_ib_rssi" pos="2" rst="0x0">
          <comment>interrupt status to be able to start to load max and min measurement report</comment>
        </bits>
        <bits access="rw" name="int_mask_ib_rssi" pos="1" rst="0x0">
          <comment>interrupt mask</comment>
        </bits>
        <bits access="rw" name="int_clear_ib_rssi" pos="0" rst="0x0">
          <comment>interrupt clear</comment>
        </bits>
      </reg>
      <reg name="load_ib_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_ib_rssi" pos="0" rst="0x0">
          <comment>indication to read instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_val_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_val_reg_ib_rssi" pos="0" rst="0x0">
          <comment>valid of instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_ib_rssi" pos="9:0" rst="0x0">
          <comment>inband RSSI instant value</comment>
        </bits>
      </reg>
      <reg name="start_max_min_ob_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="start_max_min_ob_rssi" pos="0" rst="0x0">
          <comment>start outband RSSI max and min measurement</comment>
        </bits>
      </reg>
      <reg name="count_16lsb_ob_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16lsb_ob_rssi" pos="15:0" rst="0x7800">
          <comment>timer count[15:0] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="count_16msb_ob_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16msb_ob_rssi" pos="15:0" rst="0x0">
          <comment>timer count[31:16] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="load_max_min_ob_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_max_min_ob_rssi" pos="0" rst="0x0">
          <comment>indication to read max and min measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_max_min_val_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_min_val_reg_ob_rssi" pos="0" rst="0x0">
          <comment>valid of max and min measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_min_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_min_reg_ob_rssi" pos="9:0" rst="0x0">
          <comment>outband RSSI min value</comment>
        </bits>
      </reg>
      <reg name="rssi_max_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_reg_ob_rssi" pos="9:0" rst="0x0">
          <comment>outband RSSI max value</comment>
        </bits>
      </reg>
      <reg name="int_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_int_ob_rssi" pos="2" rst="0x0">
          <comment>interrupt status to be able to start to load max and min measurement report</comment>
        </bits>
        <bits access="rw" name="int_mask_ob_rssi" pos="1" rst="0x0">
          <comment>interrupt mask</comment>
        </bits>
        <bits access="rw" name="int_clear_ob_rssi" pos="0" rst="0x0">
          <comment>interrupt clear</comment>
        </bits>
      </reg>
      <reg name="load_ob_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_ob_rssi" pos="0" rst="0x0">
          <comment>indication to read instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_val_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_val_reg_ob_rssi" pos="0" rst="0x0">
          <comment>valid of instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_wd_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_wd_ob_rssi" pos="9:0" rst="0x0">
          <comment>outband RSSI instant value for WD</comment>
        </bits>
      </reg>
      <reg name="rssi_up_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_up_ob_rssi" pos="9:0" rst="0x0">
          <comment>outband RSSI instant value for UP</comment>
        </bits>
      </reg>
      <reg name="rssi_dn_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_dn_ob_rssi" pos="9:0" rst="0x0">
          <comment>outband RSSI instant value for DN</comment>
        </bits>
      </reg>
      <reg name="rxdp_rc_stretch_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_stretch" pos="7:0" rst="0x8"/>
      </reg>
      <reg name="rxdp_rc_rate_ofs_rest_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_rate_ofs_rest" pos="9:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_bypass_control_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_bypass_gainbb" pos="14" rst="0x0">
          <comment>Gain_BB</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_notch2_2" pos="13" rst="0x0">
          <comment>Notrch(H) 2nd core</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_notch2_1" pos="12" rst="0x0">
          <comment>Notrch(H) 1st core</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_dnbh1" pos="11" rst="0x0">
          <comment>Deci. HBF1</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_aci_lpf" pos="10" rst="0x0">
          <comment>ACI Filter</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_gdeq" pos="7" rst="0x0">
          <comment>Group Delay Equ</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_notch1_1" pos="5" rst="0x0">
          <comment>Notch(DC)</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mixer" pos="4" rst="0x0">
          <comment>Mixer</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_rc" pos="3" rst="0x0">
          <comment>RC</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_dcc" pos="1" rst="0x0">
          <comment>DC Calib.&amp;Cancel</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_cic1" pos="0" rst="0x0">
          <comment>Deci.CIC1</comment>
        </bits>
      </reg>
      <reg name="rxdp_bypass_control_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_bypass_dnhb2" pos="6" rst="0x0">
          <comment>dnhb2</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_imbc" pos="5" rst="0x0">
          <comment>imbc</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mrrm" pos="4" rst="0x0">
          <comment>mrrm</comment>
        </bits>
      </reg>
      <reg name="rxdp_bypass_mode_control_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_bypass_mode_gainbb" pos="14" rst="0x0">
          <comment>Gain_BB</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_notch2_2" pos="13" rst="0x0">
          <comment>Notrch(H) 2nd core</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_notch2_1" pos="12" rst="0x0">
          <comment>Notrch(H) 1st core</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_dnbh1" pos="11" rst="0x0">
          <comment>Deci. HBF1</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_aci_lpf" pos="10" rst="0x0">
          <comment>ACI Filter</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_gdeq" pos="7" rst="0x0">
          <comment>Group Delay Equ</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_notch1_1" pos="5" rst="0x0">
          <comment>Notch(DC)</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_mixer" pos="4" rst="0x0">
          <comment>Mixer</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_rc" pos="3" rst="0x0">
          <comment>RC</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_dcc" pos="1" rst="0x0">
          <comment>DC Calib.&amp;Cancel</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_cic1" pos="0" rst="0x0">
          <comment>Deci.CIC1</comment>
        </bits>
      </reg>
      <reg name="rxdp_bypass_mode_control_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_bypass_mode_dnhb2" pos="6" rst="0x0">
          <comment>dnhb2</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_imbc" pos="5" rst="0x0">
          <comment>imbc</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_mrrm" pos="4" rst="0x0">
          <comment>mrrm</comment>
        </bits>
      </reg>
      <reg name="rxdp_dcc_re_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_dcc_re_real" pos="15:0" rst="0x0">
          <comment>instant value of rxdp_dcc_re, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rxdp_dcc_im_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_dcc_im_real" pos="15:0" rst="0x0">
          <comment>instant value of rxdp_dcc_im, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rssi_real_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_real_ib_rssi" pos="9:0" rst="0x230">
          <comment>instant value of rssi_reg_ib_rssi, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rssi_wd_real_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_wd_real_ob_rssi" pos="9:0" rst="0x0">
          <comment>instant value of rssi_reg_wd_ob_rssi, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rssi_up_real_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_up_real_ob_rssi" pos="9:0" rst="0x0">
          <comment>instant value of rssi_reg_up_ob_rssi, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rssi_dn_real_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_dn_real_ob_rssi" pos="9:0" rst="0x0">
          <comment>instant value of rssi_reg_dn_ob_rssi, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rxdp_imbc_wa_out_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_imbc_wa_out_real" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_wq_out_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_imbc_wq_out_real" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="start_max_min_rssi3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="start_max_min_rssi3" pos="0" rst="0x0">
          <comment>start RSSI3 max and min measurement</comment>
        </bits>
      </reg>
      <reg name="count_16lsb_rssi3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16lsb_rssi3" pos="15:0" rst="0x7800">
          <comment>timer count[15:0] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="count_16msb_rssi3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16msb_rssi3" pos="15:0" rst="0x0">
          <comment>timer count[31:16] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="load_max_min_rssi3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_max_min_rssi3" pos="0" rst="0x0">
          <comment>start to load max and min measurement report. Before next load, set it low firstly</comment>
        </bits>
      </reg>
      <reg name="rssi_min_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_min_val_reg_rssi3" pos="10" rst="0x0">
          <comment>valid of max and min measurement report</comment>
        </bits>
        <bits access="r" name="rssi_min_reg_rssi3" pos="9:0" rst="0x0">
          <comment>RSSI3 min value</comment>
        </bits>
      </reg>
      <reg name="rssi_max_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_reg_rssi3" pos="9:0" rst="0x0">
          <comment>RSSI3 max value, it is stable when rssi_max_min_val_reg_rssi3 is high</comment>
        </bits>
      </reg>
      <reg name="int_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_int_rssi3" pos="2" rst="0x0">
          <comment>interrupt status to be able to start to load max and min measurement report</comment>
        </bits>
        <bits access="rw" name="int_mask_rssi3" pos="1" rst="0x0">
          <comment>interrupt mask</comment>
        </bits>
        <bits access="rw" name="int_clear_rssi3" pos="0" rst="0x0">
          <comment>interrupt clear</comment>
        </bits>
      </reg>
      <reg name="load_rssi3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_rssi3" pos="0" rst="0x0">
          <comment>indication to read instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_val_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_val_reg_rssi3" pos="0" rst="0x0">
          <comment>valid of instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_rssi3" pos="9:0" rst="0x0">
          <comment>RSSI3 instant value</comment>
        </bits>
      </reg>
      <reg name="rssi_real_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_real_rssi3" pos="9:0" rst="0x230">
          <comment>instant value of rssi_reg_rssi3, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch_cordic_enable_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch_cordic_gain_sel" pos="4:3" rst="0x1"/>
        <bits access="rw" name="rxdp_notch2_cordic1_enable" pos="2" rst="0x0"/>
        <bits access="rw" name="rxdp_notch2_cordic0_enable" pos="1" rst="0x0"/>
        <bits access="rw" name="rxdp_notch1_cordic_enable" pos="0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch1_cordic_amp_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch1_cordic_amp" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch1_cordic_zin_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch1_cordic_zin" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic0_amp_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_cordic0_amp" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic0_zin_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_cordic0_zin" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic1_amp_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_cordic1_amp" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic1_zin_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_cordic1_zin" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="txdp_cfr_th_liner_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_cfr_th_liner" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txdp_sine_rate_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_sine_rate" pos="7:0" rst="0x1"/>
      </reg>
      <reg name="txdp_rc_stretch_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_rc_stretch" pos="7:0" rst="0x8"/>
      </reg>
      <reg name="txdp_rc_rate_ofs_rest_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_rc_rate_ofs_rest" pos="9:0" rst="0x0"/>
      </reg>
      <reg name="txdp_rc_rate_ofs_period_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_rc_rate_ofs_period" pos="9:0" rst="0x10"/>
      </reg>
      <reg name="txdp_rc_rate_ofs_hi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_rc_rate_ofs_hi" pos="7:0" rst="0x80"/>
      </reg>
      <reg name="txdp_rc_rate_ofs_lo_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_rc_rate_ofs_lo" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="clk_convert_rate_reg" protect="rw">
        <comment/>
        <bits access="rw" name="clk_convert_rate_b" pos="15:8" rst="0x10"/>
        <bits access="rw" name="clk_convert_rate_a" pos="7:0" rst="0x11"/>
      </reg>
      <reg name="rxdp_notch1_cordic_dout_i_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch1_cordic_dout_i" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch1_cordic_dout_q_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch1_cordic_dout_q" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic0_dout_i_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch2_cordic0_dout_i" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic0_dout_q_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch2_cordic0_dout_q" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic1_dout_i_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch2_cordic1_dout_i" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic1_dout_q_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch2_cordic1_dout_q" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch_gen_val_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch2_cordic1_dout_val" pos="2" rst="0x0"/>
        <bits access="r" name="rxdp_notch2_cordic0_dout_val" pos="1" rst="0x0"/>
        <bits access="r" name="rxdp_notch1_cordic_dout_val" pos="0" rst="0x0"/>
      </reg>
      <reg name="resetn_notch_gen_reg" protect="rw">
        <comment/>
        <bits access="rw" name="resetn_notch_gen" pos="0" rst="0x0"/>
      </reg>
      <reg name="dfe_dump_smp_rate_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dfe_dump_smp_rate" pos="7:0" rst="0x3"/>
      </reg>
      <hole size="1440"/>
      <reg name="txdp_wedge_gain_ct_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_gain_ct_load" pos="13" rst="0x0">
          <comment>load txdp_wedge_gain_ct to DFE. Write it to 1b'0 before assert it, new add, when [12]=0, need use this bit</comment>
        </bits>
        <bits access="rw" name="txdp_wedge_gain_ct_load_bypass" pos="12" rst="0x1">
          <comment>bypass txdp_wedge_gain_ct_load; new add, 1: direct use [10:0] in static adjust agc gain 0: use [10:0] need load first  for dynamic adjust agc gain</comment>
        </bits>
        <bits access="rw" name="txdp_wedge_gain_ct" pos="10:0" rst="0x0">
          <comment>Gain control of NB/WT TX. [-24db, 47.9375db], step=1/16db; change the step from 1/8db to 1/16db</comment>
        </bits>
      </reg>
      <hole size="672"/>
      <reg name="txdp_wedge_am_shrink_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_shrink" pos="7:0" rst="0x0"/>
      </reg>
      <hole size="32"/>
      <reg name="txdp_wedge_pm_shift_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_shift" pos="1:0" rst="0x0"/>
      </reg>
      <reg name="txdp_wedge_am_p0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p0" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p1" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p2_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p2" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p3" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p4_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p4" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p5_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p5" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p6_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p6" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p7_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p7" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p8_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p8" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p9_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p9" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p10_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p10" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p11_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p11" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p12_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p12" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p13_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p13" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p14_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p14" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p15_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p15" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p16_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p16" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p0" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p1" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p2_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p2" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p3" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p4_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p4" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p5_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p5" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p6_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p6" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p7_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p7" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p8_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p8" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p9_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p9" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p10_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p10" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p11_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p11" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p12_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p12" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p13_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p13" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p14_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p14" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p15_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p15" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p16_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p16" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="aclr_coef4" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef04" pos="9:0" rst="0x0">
          <comment>Coefficient 4 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef5" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef05" pos="9:0" rst="0x0">
          <comment>Coefficient 5 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef6" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef06" pos="9:0" rst="0x0">
          <comment>Coefficient 6 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef7" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef07" pos="9:0" rst="0x0">
          <comment>Coefficient 7 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="clk_convert_rate_load" protect="rw">
        <comment/>
        <bits access="rw" name="clk_convert_rate_load" pos="0" rst="0x0"/>
      </reg>
      <reg name="clk_dac_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="clk_dac_test_sel" pos="3:2" rst="0x0">
          <comment>resource of clk_dac when test mode.
00: clk_122p88m
01: clk_61p44m
10: clk_30p72m
11: clk_adc_gge_nb</comment>
        </bits>
        <bits access="rw" name="clk_dac_test_en" pos="1" rst="0x0">
          <comment>enable clk_dac when test mode</comment>
        </bits>
        <bits access="rw" name="clk_dac_sel" pos="0" rst="0x0">
          <comment>0: clk_dac is from function mode
1: clk_dac is from test mode</comment>
        </bits>
      </reg>
      <reg name="txdp_delay_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_delay" pos="7:0" rst="0x0">
          <comment>txdp_delay</comment>
        </bits>
      </reg>
      <reg name="aclr_coef0" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef00" pos="9:0" rst="0x0">
          <comment>Coefficient 0 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef1" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef01" pos="9:0" rst="0x0">
          <comment>Coefficient 1 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef2" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef02" pos="9:0" rst="0x0">
          <comment>Coefficient 2 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef3" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef03" pos="9:0" rst="0x0">
          <comment>Coefficient 3 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef0_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef0_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of coefficient 0 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef0_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef0_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of coefficient 0 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef1_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef1_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of coefficient 1 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef1_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef1_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of coefficient 1 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef2_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef2_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of coefficient 2 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef2_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef2_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of coefficient 2 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef3_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef3_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of coefficient 3 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef3_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef3_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of coefficient 3 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <hole size="384"/>
      <reg name="txdp_loft_offset_i_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_offset_i" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_offset_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_offset" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_phase_err_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_phase_err" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_amp_err_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_amp_err" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_rssi_reg" protect="rw">
        <comment/>
        <bits access="r" name="txdp_loft_rssi_err" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_tone_amp_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_tone_amp" pos="11:0" rst="0x1ff"/>
      </reg>
      <reg name="txdp_loft_tone_fre_reg0" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_tone_fre0" pos="15:0" rst="0xd555"/>
      </reg>
      <reg name="txdp_loft_tone_fre_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_tone_fre1" pos="6:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_misc0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_sincos_en" pos="15" rst="0x0"/>
        <bits access="rw" name="txdp_loft_din_loft_sel" pos="14" rst="0x0"/>
        <bits access="rw" name="txdp_loft_cali_en" pos="13" rst="0x0"/>
        <bits access="rw" name="txdp_loft_cancel_bypass" pos="12" rst="0x0"/>
        <bits access="rw" name="txdp_loft_offset_dr" pos="11" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="txdp_loft_phase_err_dr" pos="10" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="txdp_loft_amp_err_dr" pos="9" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="txdp_loft_flg_loft_calib" pos="8" rst="0x0"/>
        <bits access="rw" name="txdp_loft_bpf_enable" pos="7" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="txdp_loft_bpf_bypass" pos="6" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="txdp_loft_rssi_ushift" pos="5:3" rst="0x0"/>
        <bits access="rw" name="txdp_loft_rssi_period_idx" pos="2" rst="0x0"/>
        <bits access="rw" name="txdp_loft_rssi_enable" pos="1" rst="0x0"/>
        <bits access="rw" name="txdp_loft_rssi_load" pos="0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_gain1_reg" protect="rw">
        <comment/>
        <bits access="r" name="txdp_loft_rssi_val" pos="13" rst="0x0"/>
        <bits access="rw" name="txdp_loft_gain1_ct" pos="12:7" rst="0x0"/>
        <bits access="rw" name="txdp_loft_gain1_ct_dyn" pos="6:1" rst="0x0"/>
        <bits access="rw" name="txdp_loft_gain1_ct_sel" pos="0" rst="0x0"/>
      </reg>
      <reg name="data_format_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="nb_tx_rx_loop" pos="8" rst="0x0">
          <comment>BB TX data loopback to BB RX</comment>
        </bits>
        <bits access="rw" name="rx_iq_swap" pos="7" rst="0x0">
          <comment>BB RX IQ swap.
1: swap;
0: normal</comment>
        </bits>
        <bits access="rw" name="tx_iq_swap" pos="6" rst="0x0">
          <comment>BB TX IQ swap.
1: swap;
0: normal</comment>
        </bits>
        <bits access="rw" name="adc_iq_swap" pos="5" rst="0x0">
          <comment>ADC IQ swap.
1: swap;
0: normal</comment>
        </bits>
        <bits access="rw" name="dac_iq_swap" pos="4" rst="0x0">
          <comment>DAC IQ swap. 1: swap; 0: normal</comment>
        </bits>
        <bits access="rw" name="rx_off_bin_en" pos="3" rst="0x0">
          <comment>BB RX.
0: two's complement
1: offset binary</comment>
        </bits>
        <bits access="rw" name="tx_off_bin_en" pos="2" rst="0x0">
          <comment>BB TX.
0: two's complement
1: offset binary</comment>
        </bits>
        <bits access="rw" name="adc_off_bin_en" pos="1" rst="0x0">
          <comment>RF ADC.
0: two's complement
1: offset binary</comment>
        </bits>
        <bits access="rw" name="dac_off_bin_en" pos="0" rst="0x1">
          <comment>RF DAC.
0: two's complement
1: offset binary</comment>
        </bits>
      </reg>
      <reg name="txdp_loft_rssi_reg_real" protect="rw">
        <comment/>
        <bits access="r" name="txdp_loft_rssi_err_real" pos="15:0" rst="0x0">
          <comment>instant value of txdp_loft_rssi_err</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="temper_tsx_ct" protect="rw">
        <comment/>
        <bits access="r" name="temper_tsx_pout_val_rg" pos="9" rst="0x0">
          <comment>valid indication of temper_dout after assert temper_pout_load to avoid metastability. Thetemper_dout is stable when this register is high</comment>
        </bits>
        <bits access="rw" name="temper_tsx_pout_load" pos="8" rst="0x0">
          <comment>start to load the result of temper_dout. Before next load, set it low firstly</comment>
        </bits>
        <bits access="rw" name="temper_tsx_lpf3_bypass" pos="7" rst="0x0"/>
        <bits access="rw" name="temper_tsx_ushift" pos="6:4" rst="0x0">
          <comment>bandwidth select</comment>
        </bits>
        <bits access="rw" name="temper_tsx_bw_sel" pos="3:2" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="temper_tsx_lpf_bypass" pos="1" rst="0x0"/>
        <bits access="rw" name="temper_tsx_hold_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="temper_tsx_dout_reg" protect="rw">
        <comment/>
        <bits access="r" name="temper_tsx_dout" pos="15:0" rst="0x0">
          <comment>temper_dout value</comment>
        </bits>
      </reg>
      <reg name="tsx_temp_clk_ct" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_clk_en" pos="7" rst="0x0">
          <comment>clock enable for temper</comment>
        </bits>
        <bits access="rw" name="temper_tsx_clk_freq_sel" pos="6:5" rst="0x0">
          <comment>divide mode of clock from analog for Temcomp
0: not divide
1: 1/2 divide
2: 1/4 divide
3: 1/8 divide</comment>
        </bits>
        <bits access="rw" name="temper_tsx_clk_phase_sel" pos="4" rst="0x0">
          <comment>clock invert for Temcomp
0: clock invert disable
1: clock invert enable</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_a11_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_a11" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_a12_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_a12" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_g1_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_g1" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_a21_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_a21" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_a22_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_a22" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_g2_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_g2" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_dout_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="temper_tsx_dout_real" pos="15:0" rst="0x8000">
          <comment>instant value of temper_dout</comment>
        </bits>
      </reg>
      <hole size="448"/>
      <reg name="temper_ct" protect="rw">
        <comment/>
        <bits access="r" name="temper_pout_val_rg" pos="9" rst="0x0">
          <comment>valid indication of temper_dout after assert temper_pout_load to avoid metastability. Thetemper_dout is stable when this register is high</comment>
        </bits>
        <bits access="rw" name="temper_pout_load" pos="8" rst="0x0">
          <comment>start to load the result of temper_dout. Before next load, set it low firstly</comment>
        </bits>
        <bits access="rw" name="temper_lpf3_bypass" pos="7" rst="0x0"/>
        <bits access="rw" name="temper_ushift" pos="6:4" rst="0x0">
          <comment>bandwidth select</comment>
        </bits>
        <bits access="rw" name="temper_bw_sel" pos="3:2" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="temper_lpf_bypass" pos="1" rst="0x0"/>
        <bits access="rw" name="temper_hold_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="temper_dout_reg" protect="rw">
        <comment/>
        <bits access="r" name="temper_dout" pos="15:0" rst="0x0">
          <comment>temper_dout value</comment>
        </bits>
      </reg>
      <reg name="osc_temp_clk_ct" protect="rw">
        <comment/>
        <bits access="rw" name="temper_clk_en" pos="7" rst="0x0">
          <comment>clock enable for temper</comment>
        </bits>
        <bits access="rw" name="temper_clk_freq_sel" pos="6:5" rst="0x0">
          <comment>divide mode of clock from analog for Temcomp
0: not divide
1: 1/2 divide
2: 1/4 divide
3: 1/8 divide</comment>
        </bits>
        <bits access="rw" name="temper_clk_phase_sel" pos="4" rst="0x0">
          <comment>clock invert for Temcomp
0: clock invert disable
1: clock invert enable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="temper_lpf_a11_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_a11" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_lpf_a12_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_a12" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_lpf_g1_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_g1" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_lpf_a21_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_a21" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_lpf_a22_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_a22" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_lpf_g2_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_g2" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <hole size="256"/>
      <reg name="temper_dout_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="temper_dout_real" pos="15:0" rst="0x8000">
          <comment>instant value of temper_dout</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="dfe_sw_clkgate_en_rg" protect="rw">
        <comment/>
        <bits access="rw" name="dfe_sw_clkgate_en" pos="0" rst="0x0">
          <comment>dfe_sw_clkgate_en</comment>
        </bits>
      </reg>
      <reg name="mon_ct" protect="rw">
        <comment/>
        <bits access="rw" name="dfe_monitor_swap" pos="4" rst="0x0">
          <comment>swap of dfe_monitor[15:8] and dfe_monitor[7:0]</comment>
        </bits>
        <bits access="rw" name="dfe_monitor_sel" pos="3:0" rst="0x0">
          <comment>dfe_monitor select</comment>
        </bits>
      </reg>
      <reg name="dac_offset_re_rg" protect="rw">
        <comment/>
        <bits access="rw" name="dac_offset_re" pos="11:0" rst="0x0">
          <comment>The offset on DAC real part</comment>
        </bits>
      </reg>
      <reg name="dac_offset_im_rg" protect="rw">
        <comment/>
        <bits access="rw" name="dac_offset_im" pos="11:0" rst="0x0">
          <comment>The offset on DAC image part</comment>
        </bits>
      </reg>
      <reg name="dac_tx_amp_re_rg" protect="rw">
        <comment/>
        <bits access="rw" name="dac_tx_amp_re" pos="11:0" rst="0x0">
          <comment>The DAC real part on test mode</comment>
        </bits>
      </reg>
      <reg name="dac_tx_amp_im_rg" protect="rw">
        <comment/>
        <bits access="rw" name="dac_tx_amp_im" pos="11:0" rst="0x0">
          <comment>The DAC image part on test mode</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="data_dac_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="data_dac_sel" pos="14:13" rst="0x0">
          <comment>select of function DAC data or test DAC data
00/01: select function DAC data including sine waveform
10: select test DAC data in txdp
11: select test DAC data in txdp</comment>
        </bits>
        <bits access="rw" name="sine_enable_rg" pos="12" rst="0x0">
          <comment>enable sine generation module</comment>
        </bits>
        <bits access="rw" name="rxdp_test_dac_en_rg" pos="11" rst="0x0">
          <comment>enable of test DAC data in rxdp</comment>
        </bits>
        <bits access="rw" name="rxdp_test_dac_sel_rg" pos="10:6" rst="0x0">
          <comment>select of test DAC data in rxdp</comment>
        </bits>
        <bits access="rw" name="txdp_test_dac_en_rg" pos="5" rst="0x0">
          <comment>enable of test DAC data in txdp</comment>
        </bits>
        <bits access="rw" name="txdp_test_dac_sel_rg" pos="4:0" rst="0x0">
          <comment>select of test DAC data in txdp</comment>
        </bits>
      </reg>
      <reg name="sincos_amp" protect="rw">
        <comment/>
        <bits access="rw" name="sincos_amp_rg" pos="11:0" rst="0x1ff">
          <comment>sine amp</comment>
        </bits>
      </reg>
      <reg name="sincos_fre_lo" protect="rw">
        <comment/>
        <bits access="rw" name="sincos_fre_rg_lo" pos="15:0" rst="0xd555">
          <comment>sine frequency[15:0]</comment>
        </bits>
      </reg>
      <reg name="sincos_fre_hi" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_bypass_loft" pos="8" rst="0x0">
          <comment>LOFT</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_loft" pos="7" rst="0x0">
          <comment>LOFT</comment>
        </bits>
        <bits access="rw" name="sincos_fre_rg_hi" pos="6:0" rst="0x0">
          <comment>sine frequence[22:16]</comment>
        </bits>
      </reg>
      <reg name="txdp_bypass_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_bypass_uphb5" pos="13" rst="0x0">
          <comment>UPHBF(3)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_uphb4" pos="12" rst="0x0">
          <comment>UPHBF(2)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_gdeq" pos="11" rst="0x0">
          <comment>Group Delay Equ.</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_polariq_ampm" pos="9" rst="0x0">
          <comment>AMPM of DPD</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_polariq" pos="7" rst="0x0">
          <comment>Whole DPD</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_rc" pos="6" rst="0x0">
          <comment>RC</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_gain" pos="5" rst="0x0">
          <comment>Gain</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_cfr" pos="3" rst="0x0">
          <comment>CFR</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_uphb1" pos="2" rst="0x0">
          <comment>UPHBF(1)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_aclr_lpf" pos="1" rst="0x0">
          <comment>ACLR LPF</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_ampequ" pos="0" rst="0x0">
          <comment>ampequ, new add</comment>
        </bits>
      </reg>
      <reg name="txdp_bypass_mode_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_bypass_mode_uphb5" pos="13" rst="0x0">
          <comment>UPHBF(3)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_uphb4" pos="12" rst="0x0">
          <comment>UPHBF(2)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_gdeq" pos="11" rst="0x0">
          <comment>Group Delay Equ.</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_polariq_ampm" pos="9" rst="0x0">
          <comment>AMPM of DPD</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_polariq" pos="7" rst="0x0">
          <comment>Whole DPD</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_rc" pos="6" rst="0x0">
          <comment>RC</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_gain" pos="5" rst="0x0">
          <comment>Gain</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_cfr" pos="3" rst="0x0">
          <comment>CFR</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_uphb1" pos="2" rst="0x0">
          <comment>UPHBF(1)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_aclr_lpf" pos="1" rst="0x0">
          <comment>ACLR LPF</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_ampequ" pos="0" rst="0x0">
          <comment>ampequ</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="reserved_all_zeros_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rsv_all_zero" pos="15:0" rst="0x0">
          <comment>all zero bits, reserved for ECO</comment>
        </bits>
      </reg>
      <reg name="reserved_all_ones_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rsv_all_ones" pos="15:0" rst="0xffff">
          <comment>all one bits, reserved for ECO</comment>
        </bits>
      </reg>
      <reg name="pwr_rf_acc_len_reg" protect="rw">
        <comment/>
        <bits access="rw" name="pwr_rf_acc_len_rg" pos="15:0" rst="0x0">
          <comment>all one bits, reserved for ECO</comment>
        </bits>
      </reg>
      <reg name="pwr_rf_acc_misc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="pwr_adc_off_bin_en" pos="5" rst="0x0"/>
        <bits access="rw" name="pwr_rf_ushift_rg" pos="4:2" rst="0x0">
          <comment>pwr_rf_ushift_rg</comment>
        </bits>
        <bits access="rw" name="pwr_rf_start_rg" pos="1" rst="0x0">
          <comment>pwr_rf_start_rg</comment>
        </bits>
        <bits access="rw" name="pwr_rf_polar_rg" pos="0" rst="0x0">
          <comment>pwr_rf_polar_rg</comment>
        </bits>
      </reg>
      <reg name="pwr_rf_acc_report_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwr_rf_o" pos="11:1" rst="0x4c0"/>
        <bits access="r" name="pwr_rf_calc_done" pos="0" rst="0x0"/>
      </reg>
      <hole size="96"/>
      <reg name="txdp_clk_gate_enable_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_clkgate_en" pos="14" rst="0x0"/>
        <bits access="rw" name="txdp_aclr_clkgate_en" pos="13" rst="0x0"/>
        <bits access="rw" name="txdp_uphb1_clkgate_en" pos="12" rst="0x0"/>
        <bits access="rw" name="txdp_gain_clkgate_en" pos="9" rst="0x0"/>
        <bits access="rw" name="txdp_rc_clkgate_en" pos="8" rst="0x0"/>
        <bits access="rw" name="txdp_dpd_clkgate_en" pos="7" rst="0x0"/>
        <bits access="rw" name="txdp_gdeq_clkgate_en" pos="6" rst="0x0"/>
        <bits access="rw" name="txdp_uphb4_clkgate_en" pos="5" rst="0x0"/>
        <bits access="rw" name="txdp_uphb5_clkgate_en" pos="4" rst="0x0"/>
        <bits access="rw" name="txdp_loft_clkgate_en" pos="2" rst="0x0"/>
        <bits access="rw" name="txdp_sine_clkgate_en" pos="0" rst="0x0">
          <comment>1: clk always on, 0: clk gating by hardware</comment>
        </bits>
      </reg>
      <reg name="rxdp_clk_gate_enable_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_clkgate_en" pos="0" rst="0x0">
          <comment>1: clk always on, 0: clk gating by hardware</comment>
        </bits>
      </reg>
      <reg name="rxdp_clk_gate_enable_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_imbc_clkgate_en" pos="15" rst="0x0"/>
        <bits access="rw" name="rxdp_mixer_clkgate_en" pos="14" rst="0x0"/>
        <bits access="rw" name="rxdp_notch1_clkgate_en" pos="13" rst="0x0"/>
        <bits access="rw" name="rxdp_gdeq_clkgate_en" pos="12" rst="0x0"/>
        <bits access="rw" name="rxdp_ob_clkgate_en" pos="10" rst="0x0"/>
        <bits access="rw" name="rxdp_mrrm_clkgate_en" pos="9" rst="0x0"/>
        <bits access="rw" name="rxdp_dnhb1_clkgate_en" pos="8" rst="0x0"/>
        <bits access="rw" name="rxdp_aci_clkgate_en" pos="7" rst="0x0"/>
        <bits access="rw" name="rxdp_notch2_clkgate_en" pos="6" rst="0x0"/>
        <bits access="rw" name="rxdp_gainbb_clkgate_en" pos="5" rst="0x0"/>
        <bits access="rw" name="rxdp_dnhb2_clkgate_en" pos="4" rst="0x0"/>
        <bits access="rw" name="rxdp_ib_clkgate_en" pos="3" rst="0x0"/>
        <bits access="rw" name="rxdp_notch_gen_clkgate_en" pos="1" rst="0x0"/>
        <bits access="rw" name="rxdp_rssi3_clkgate_en" pos="0" rst="0x0">
          <comment>1: clk always on, 0: clk gating by hardware</comment>
        </bits>
      </reg>
      <reg name="test_dac_bits_sel_register" protect="rw">
        <comment/>
        <bits access="rw" name="test_dac_bits_sel" pos="2:0" rst="0x0">
          <comment>determine dac bits position when test mode.
0:[11:0],
1:[12:1],
2:[13:2],
3:[14:3],
4:[15:4]</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_coef0_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_coef0_rg" pos="11:0" rst="0x0">
          <comment>Bit [11:0] of coefficient 0 of ampequ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_coef1_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_coef1_rg" pos="11:0" rst="0x0">
          <comment>Bit [11:0] of coefficient 1 of ampequ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_coef2_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_coef2_rg" pos="11:0" rst="0x0">
          <comment>Bit [11:0] of coefficient 2 of ampequ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_coef3_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_coef3_rg" pos="11:0" rst="0x0">
          <comment>Bit [11:0] of coefficient 3 of ampequ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_g" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_g_rg" pos="15:0" rst="0x0">
          <comment>Bit [27:12] of gain for ampequ.  for NB/LTE/eMTC TX, must  config for all tx, init value 0x400</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_g_ext_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_g_ext" pos="11:0" rst="0x0">
          <comment>Bit [11:0] of gain for ampequ. It works with register txdp_ampequ_g_rg</comment>
        </bits>
      </reg>
      <reg name="fifo_sample_rate_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="fifo_a_smp_rate_rg" pos="10:4" rst="0x3">
          <comment>read interval for FIFO A, new add change with different rx mode</comment>
        </bits>
        <bits access="rw" name="fifo_b_smp_rate_rg" pos="3:0" rst="0x3">
          <comment>read interval for FIFO B, new add change with different rx mode</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="fifo_status_reg" protect="rw">
        <comment/>
        <bits access="r" name="fifo_dump_full_status" pos="15" rst="0x0">
          <comment>FIFO dump full</comment>
        </bits>
        <bits access="r" name="fifo_dump_empty_status" pos="14" rst="0x1">
          <comment>FIFO dump empty</comment>
        </bits>
        <bits access="r" name="fifo_txdp_rc_full_status" pos="13" rst="0x0">
          <comment>FIFO txdp_rc full</comment>
        </bits>
        <bits access="r" name="fifo_txdp_rc_empty_status" pos="12" rst="0x1">
          <comment>FIFO txdp_rc empty</comment>
        </bits>
        <bits access="r" name="fifo_rxdp_rc_full_status" pos="11" rst="0x0">
          <comment>FIFO rxdp_rc full</comment>
        </bits>
        <bits access="r" name="fifo_rxdp_rc_empty_status" pos="10" rst="0x1">
          <comment>FIFO rxdp_rc empty</comment>
        </bits>
        <bits access="r" name="fifo_adc_full_status" pos="9" rst="0x0">
          <comment>FIFO ADC full</comment>
        </bits>
        <bits access="r" name="fifo_adc_empty_status" pos="8" rst="0x1">
          <comment>FIFO ADC empty, this FIFO used between ADC and DFE</comment>
        </bits>
        <bits access="r" name="fifo_b_full_status" pos="3" rst="0x0">
          <comment>FIFO B full</comment>
        </bits>
        <bits access="r" name="fifo_b_empty_status" pos="2" rst="0x1">
          <comment>FIFO B empty, this FIFO used when LVDS RX for adc-dfe-lvds-bb</comment>
        </bits>
        <bits access="r" name="fifo_a_full_status" pos="1" rst="0x0">
          <comment>FIFO A full</comment>
        </bits>
        <bits access="r" name="fifo_a_empty_status" pos="0" rst="0x1">
          <comment>FIFO A empty, this FIFO used when normal RX or LVDS TX for adc-dfe-lvds-bb</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="dfe_dump_reg" protect="rw">
        <comment/>
        <bits access="rw" name="sel_clk_dump_w" pos="11:8" rst="0x0">
          <comment>clock frequency select when dump FIFO write
0000: clk_122p88m_m
0001: clk_adc
001x: clk_245p76m
01xx: clk_245p76m_m
1xxx: clk_pwd</comment>
        </bits>
        <bits access="rw" name="dfe_dump_vld_sel" pos="5:4" rst="0x0">
          <comment>valid width select when dump
00: 1 cycle period (245.76M)
01: 2 cycle period (245.76M)
10: 3 cycle period (245.76M)
11: 4 cycle period (245.76M)</comment>
        </bits>
        <bits access="rw" name="dfe_dump_en" pos="3" rst="0x0">
          <comment>enable dump</comment>
        </bits>
        <bits access="rw" name="dfe_dump_resetn" pos="2" rst="0x0"/>
        <bits access="rw" name="dfe_dump_sel" pos="1:0" rst="0x0">
          <comment>dump node selection. It works with register sel_clk_dump_w for correct clock.
0: dump RX data from DFE, sel_clk_dump_w can be clk_122p88m_m/clk_61p44m_m/lvds2dfe_clk_dig_ref
1: dump TX data from BB, sel_clk_dump_w can be clk_122p88m_m/clk_61p44m_m/lvds2dfe_clk_dig_ref
2: dump RXDP data, sel_clk_dump_w can be clk_rxdp/clk_rxdp_m
3: dump TXDP data, sel_clk_dump_w can be clk_txdp/clk_245p76m_m(clk_txdp_m)/clk_pwd
others: dump data from LVDS, sel_clk_dump_w can be can be lvds2dfe_clk</comment>
        </bits>
      </reg>
      <reg name="aclr_coef8" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef08" pos="9:0" rst="0x0">
          <comment>Coefficient 8 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef9" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef09" pos="9:0" rst="0x0">
          <comment>Coefficient 9 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef10" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef10" pos="9:0" rst="0x0">
          <comment>Coefficient 10 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef11" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef11" pos="9:0" rst="0x0">
          <comment>Coefficient 11 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef12" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef12" pos="9:0" rst="0x0">
          <comment>Coefficient 12 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef13" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef13" pos="9:0" rst="0x0">
          <comment>Coefficient 13 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef14" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef14" pos="9:0" rst="0x0">
          <comment>Coefficient 14 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef15" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef15" pos="9:0" rst="0x0">
          <comment>Coefficient 15 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef16" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef16" pos="9:0" rst="0x0">
          <comment>Coefficient 16 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef17" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef17" pos="9:0" rst="0x0">
          <comment>Coefficient 17 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef18" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef18" pos="9:0" rst="0x0">
          <comment>Coefficient 18 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef19" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef19" pos="9:0" rst="0x0">
          <comment>Coefficient 19 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef20" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef20" pos="9:0" rst="0x0">
          <comment>Coefficient 20 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef21" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef21" pos="9:0" rst="0x0">
          <comment>Coefficient 21 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef22" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef22" pos="9:0" rst="0x0">
          <comment>Coefficient 22 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef23" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef23" pos="9:0" rst="0x0">
          <comment>Coefficient 23 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_dcc_load" pos="6" rst="0x0">
          <comment>Start to load DC value, active high. Before next load, set it low firstly</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_imgrej_rg" pos="5" rst="0x0">
          <comment>IQ swap in DC module
0: no swap
1. swap</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_hold_en_rg" pos="4" rst="0x0">
          <comment>Hold DC accumulator calculation in DC calibration mode</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_bypass_rg" pos="3" rst="0x0">
          <comment>This register is used.</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_dc_delta_ld_st_rg" pos="2" rst="0x0">
          <comment>Store initial value to DC accumulator at positive edge in DC cancel mode or DC calibration mode.</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_dc_calib_en_rg" pos="1" rst="0x0">
          <comment>Load DC value in calibration mode to debug port, only used for debug purpose</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_rx_calib_sel_rg" pos="0" rst="0x0">
          <comment>DC module work mode.
0: DC calibration mode
1: DC cancel mode</comment>
        </bits>
      </reg>
      <reg name="pwd_dc_calib_re" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_dc_calib_re_rg" pos="9:0" rst="0x0">
          <comment>DC real part value used in cancel mode</comment>
        </bits>
      </reg>
      <reg name="pwd_dc_calib_im" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_dc_calib_im_rg" pos="9:0" rst="0x0">
          <comment>DC image part value used in cancel mode</comment>
        </bits>
      </reg>
      <reg name="pwd_dc_delta_re" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_dc_delta_re_rg" pos="9:0" rst="0x0">
          <comment>Accumulator initial real part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register</comment>
        </bits>
      </reg>
      <reg name="pwd_dc_delta_im" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_dc_delta_im_rg" pos="9:0" rst="0x0">
          <comment>Accumulator initial image part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register</comment>
        </bits>
      </reg>
      <reg name="pwd_dc_cr" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_conv_slow_bw_ct_rg" pos="11:9" rst="0x0">
          <comment>Slow convergence control, work with conv_mode_ct_rg register</comment>
        </bits>
        <bits access="rw" name="pwd_conv_fast_bw_ct_rg" pos="8:6" rst="0x0">
          <comment>Fast convergence control, work with conv_mode_ct_rg register</comment>
        </bits>
        <bits access="rw" name="pwd_conv_tmr_ct_rg" pos="5:2" rst="0x0">
          <comment>Duration time of DC calibration, which is based on sample unit</comment>
        </bits>
        <bits access="rw" name="pwd_conv_mode_ct_rg" pos="1:0" rst="0x0">
          <comment>DC convergence loop mode selection.
0: fast
1: slow
2: fast-&gt;slow
3: fast-&gt;hold</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc_valid_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwd_dcc_val_reg" pos="0" rst="0x0">
          <comment>Valid indication of DC value after assert rxdp_dcc_load to avoid metastability. rxdp_dcc_re_o and rxdp_dcc_im_o are stable when this register is high</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc_re_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwd_dcc_re_o" pos="9:0" rst="0x0">
          <comment>Real part of DC value, it is stable when pwd_dcc_val_reg is high</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc_im_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwd_dcc_im_o" pos="9:0" rst="0x0">
          <comment>Image part of DC value, it is stable when pwd_dcc_val_reg is high</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc_re_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwd_dcc_re_real" pos="9:0" rst="0x0">
          <comment>instant value of rxdp_dcc_re, new add for debug</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc_im_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwd_dcc_im_real" pos="9:0" rst="0x0">
          <comment>instant value of rxdp_dcc_im, new add for debug</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x50032000" name="RF_DFE" type="RF_DFE"/>
  </archive>
  <archive relative="rf_bitmap.xml">
    <module category="System" name="RF_BITMAP">
      <reg name="sysctrl1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_clk_cnt_sel" pos="11" rst="0x0">
          <comment>1:选择LTE BBPLL tuned 122.88M，0：选择晶体untuned 26M</comment>
        </bits>
        <bits access="rw" name="rg_adj_cnt_122m88_ms_num_val_sel" pos="10" rst="0x0">
          <comment>软件调整122.88m计数周期生效时刻选择0：下帧起效；1：当帧起效</comment>
        </bits>
        <bits access="rw" name="rg_adj_cnt_122m88_ms_num_enable" pos="9" rst="0x0">
          <comment>软件调整122.88m计数周期使能，生效时刻可选</comment>
        </bits>
        <bits access="rw" name="rg_adj_cnt_122m88_enable" pos="8" rst="0x0">
          <comment>软件调整122.88M counter计数值使能，立即生效</comment>
        </bits>
        <bits access="rw" name="rg_latch_cnt_122m88_enable" pos="7" rst="0x0">
          <comment>软件Latch 122.88m counter使能</comment>
        </bits>
        <bits access="rw" name="rg_gnss_latch_cnt_122m88_enable" pos="6" rst="0x0">
          <comment>GNSS RTC/CPU/EM Latch 122.88m counter使能</comment>
        </bits>
        <bits access="rw" name="rg_cnt_122m88_clr" pos="5" rst="0x0">
          <comment>Tuned 122.88M counter计数清零</comment>
        </bits>
        <bits access="rw" name="rg_cnt_122m88_enable" pos="4" rst="0x0">
          <comment>Tuned 122.88M counter计数使能</comment>
        </bits>
        <bits access="rw" name="rg_latch_wptr_enable" pos="3" rst="0x0">
          <comment>软件latch bitmap wptr写指针和循环计数值使能</comment>
        </bits>
        <bits access="rw" name="rg_gnss_latch_wptr_enable" pos="2" rst="0x0">
          <comment>GNSS RTC/CPU/EM Latch bitmap wptr写指针和循环计数值使能</comment>
        </bits>
        <bits access="rw" name="rg_bitmap_wptr_clr" pos="1" rst="0x0">
          <comment>清除bitmap循环到0，清除wptr写指针</comment>
        </bits>
        <bits access="rw" name="rg_bitmap_enable" pos="0" rst="0x0">
          <comment>Bitmap功能开关使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_bitmap_cycle_index_num" pos="7:0" rst="0x7f">
          <comment>Bitmap循环周期设置，默认为0-127循环，最大0-255循环,Bitmap功能启动前需要配置完毕，启动过程中不支持修改</comment>
        </bits>
      </reg>
      <reg name="sysctrl3" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cnt_122m88_ms_num_l" pos="15:0" rst="0xdfff">
          <comment>122.88M计数中断产生周期设置，默认为1ms；如果是26M，1ms对应值是0x658F</comment>
        </bits>
      </reg>
      <reg name="sysctrl4" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cnt_122m88_ms_num_h" pos="1:0" rst="0x1">
          <comment>122.88M计数中断产生周期设置，默认为1ms；如果是26M，1ms对应值是0x0</comment>
        </bits>
      </reg>
      <reg name="sysctrl5" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cnt_122m88_adj_val_l" pos="15:0" rst="0x0">
          <comment>软件调整122.88M/26M counter计数值，立即生效</comment>
        </bits>
      </reg>
      <reg name="sysctrl6" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cnt_122m88_adj_val_m" pos="15:0" rst="0x0">
          <comment>软件调整122.88M/26M counter计数值，立即生效</comment>
        </bits>
      </reg>
      <reg name="sysctrl7" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cnt_122m88_adj_val_h" pos="15:0" rst="0x0">
          <comment>软件调整122.88M/26M counter计数值，立即生效</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="sysstat1" protect="rw">
        <comment/>
        <bits access="r" name="latch_cnt_122m88_value_l" pos="15:0">
          <comment>122.88M/26M counter计数值，GNSS RTC/CPU/EM Latch、软件Latch使能后更新，共48bit，【17：0】为1ms计数循环，【21：18】为10ms计数循环，【48：22】为计满循环，格式同LTE Frame timer3</comment>
        </bits>
      </reg>
      <reg name="sysstat2" protect="rw">
        <comment/>
        <bits access="r" name="latch_cnt_122m88_value_m" pos="15:0">
          <comment>122.88M/26M counter计数值，GNSS RTC/CPU/EM Latch、软件Latch使能后更新，共48bit，【17：0】为1ms计数循环，【21：18】为10ms计数循环，【48：22】为计满循环，格式同LTE Frame timer3</comment>
        </bits>
      </reg>
      <reg name="sysstat3" protect="rw">
        <comment/>
        <bits access="r" name="latch_cnt_122m88_value_h" pos="15:0">
          <comment>122.88M/26M counter计数值，GNSS RTC/CPU/EM Latch、软件Latch使能后更新，共48bit，【17：0】为1ms计数循环，【21：18】为10ms计数循环，【48：22】为计满循环，格式同LTE Frame timer3</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="sysstat7" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_wptr" pos="7:0">
          <comment>Bitmap wptr写指针，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat8" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num0" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat9" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num1" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat10" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num2" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat11" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num3" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat12" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num4" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat13" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num5" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat14" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num6" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat15" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num7" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat16" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num8" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat17" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num9" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat18" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num10" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat19" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num11" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat20" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num12" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat21" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num13" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat22" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num14" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <reg name="sysstat23" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num15" pos="15:0">
          <comment>Bitmap置位计数值，软件latch使能后更新，判断到valid为1后有效</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="sysctrl11" protect="rw">
        <comment/>
        <bits access="rw" name="lte_gnss_mail_flag" pos="15:0" rst="0x0">
          <comment>LTE-GNSS信息交互bit寄存器，保留软件使用</comment>
        </bits>
      </reg>
      <reg name="sysctrl12" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer0" pos="15:0" rst="0x0">
          <comment>Bitmap软件置位寄存器，保留软件使用</comment>
        </bits>
      </reg>
      <reg name="sysctrl13" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer1" pos="15:0" rst="0x0">
          <comment>Bitmap软件置位寄存器，保留软件使用</comment>
        </bits>
      </reg>
      <reg name="sysctrl14" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer2" pos="15:0" rst="0x0">
          <comment>Bitmap软件置位寄存器，保留软件使用</comment>
        </bits>
      </reg>
      <reg name="sysctrl15" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer3" pos="15:0" rst="0x0">
          <comment>Bitmap软件置位寄存器，保留软件使用</comment>
        </bits>
      </reg>
      <reg name="sysctrl16" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer4" pos="15:0" rst="0x0">
          <comment>Bitmap软件置位寄存器，保留软件使用</comment>
        </bits>
      </reg>
      <reg name="sysctrl17" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer5" pos="15:0" rst="0x0">
          <comment>Bitmap软件置位寄存器，保留软件使用</comment>
        </bits>
      </reg>
      <reg name="sysctrl18" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer6" pos="15:0" rst="0x0">
          <comment>Bitmap软件置位寄存器，保留软件使用</comment>
        </bits>
      </reg>
      <reg name="sysctrl19" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer7" pos="15:0" rst="0x0">
          <comment>Bitmap软件置位寄存器，保留软件使用</comment>
        </bits>
      </reg>
      <hole size="6816"/>
      <reg name="sysctrl1_set" protect="rw"/>
      <hole size="1056"/>
      <reg name="sysctrl11_set" protect="rw"/>
      <reg name="sysctrl12_set" protect="rw"/>
      <reg name="sysctrl13_set" protect="rw"/>
      <reg name="sysctrl14_set" protect="rw"/>
      <reg name="sysctrl15_set" protect="rw"/>
      <reg name="sysctrl16_set" protect="rw"/>
      <reg name="sysctrl17_set" protect="rw"/>
      <reg name="sysctrl18_set" protect="rw"/>
      <reg name="sysctrl19_set" protect="rw"/>
      <hole size="6816"/>
      <reg name="sysctrl1_clr" protect="rw"/>
      <hole size="1056"/>
      <reg name="sysctrl11_clr" protect="rw"/>
      <reg name="sysctrl12_clr" protect="rw"/>
      <reg name="sysctrl13_clr" protect="rw"/>
      <reg name="sysctrl14_clr" protect="rw"/>
      <reg name="sysctrl15_clr" protect="rw"/>
      <reg name="sysctrl16_clr" protect="rw"/>
      <reg name="sysctrl17_clr" protect="rw"/>
      <reg name="sysctrl18_clr" protect="rw"/>
      <reg name="sysctrl19_clr" protect="rw"/>
    </module>
    <var name="REG_RF_BITMAP_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_BITMAP_CLR_OFFSET" value="0x800"/>
    <instance address="0x50036000" name="RF_BITMAP" type="RF_BITMAP"/>
  </archive>
  <archive relative="rf_ana.xml">
    <module category="System" name="RF_ANA">
      <reg name="bandgap_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="bg_cal_r_d_bb" pos="15:12" rst="0x7">
          <comment>bandgap trim</comment>
        </bits>
        <bits access="rw" name="ldo_levelshifter_out" pos="11:9" rst="0x2">
          <comment>ISM TXABB LDO output voltage selection
ISM TXABB  LDO output voltage control signal
000     0.84V                     100   0.96V
001     0.87V                     101   0.99V
010     0.9V                        110   1.02V
011     0.93V                     111    1.05V</comment>
        </bits>
        <bits access="rw" name="ldo_levelshifter_cp_tune" pos="8:7" rst="0x2">
          <comment>Top LevelShIft LDO ripple cancelling cap control signal to mitigate VDD variation effect conotrol VDD_input
00    1.8V
01    1.5V
10    1.2V
11    1.2V</comment>
        </bits>
      </reg>
      <reg name="ldo_pu_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="lna_ldo_en_in_bb" pos="15" rst="0x0">
          <comment>LNA ldo power up</comment>
        </bits>
        <bits access="rw" name="lna_ldo_fast_charge_en_bb" pos="14" rst="0x0">
          <comment>LNA ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="rxabb_ldo_en_bb" pos="13" rst="0x0">
          <comment>RX ABB ldo power up</comment>
        </bits>
        <bits access="rw" name="rxabb_ldo_fc_pulse_bb" pos="12" rst="0x0">
          <comment>RX ABB ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="adc_ldo_bias_en_bb" pos="11" rst="0x0">
          <comment>ADC LDO bias enable</comment>
        </bits>
        <bits access="rw" name="adc_ldo_en_bb" pos="10" rst="0x0">
          <comment>ADC LDO enable</comment>
        </bits>
        <bits access="rw" name="txflt_ldo_en_bb" pos="9" rst="0x0">
          <comment>TX filter ldo power up</comment>
        </bits>
        <bits access="rw" name="txflt_ldo_fc_pulse_bb" pos="8" rst="0x0">
          <comment>TX filter ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="dac_ldo_en_bb" pos="7" rst="0x0">
          <comment>DAC LDO enable</comment>
        </bits>
        <bits access="rw" name="dac_ldo_fc_pulse_bb" pos="6" rst="0x0">
          <comment>DAC LDO fast charge</comment>
        </bits>
        <bits access="rw" name="pwdadc_ldo_bias_en_bb" pos="5" rst="0x0">
          <comment>PWDADC LDO bias enable, only used in ditital domain</comment>
        </bits>
        <bits access="rw" name="pwdadc_ldo_en_bb" pos="4" rst="0x0">
          <comment>PWDADC LDO enable, only used in digital domain</comment>
        </bits>
      </reg>
      <reg name="ldo_pu_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_ldo_bias_en_bb" pos="15" rst="0x0">
          <comment>rxpll gro ldo bias en</comment>
        </bits>
        <bits access="rw" name="rxpll_gro_ldo_en_bb" pos="14" rst="0x0">
          <comment>rxpll gro ldo en</comment>
        </bits>
        <bits access="rw" name="rxpll_presc_ldo_en_bb" pos="13" rst="0x0">
          <comment>RXPLL presc ldo power up</comment>
        </bits>
        <bits access="rw" name="rxpll_presc_ldo_fast_charge_en_bb" pos="12" rst="0x0">
          <comment>RXPLL presc ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_dig_en_bb" pos="11" rst="0x0">
          <comment>RXPLL RDAC ldo digital power up</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_vref_en_bb" pos="10" rst="0x0">
          <comment>RXPLL RDAC ldo vref power up</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_vref_fc_en_bb" pos="9" rst="0x0">
          <comment>RXPLL RDAC ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="rxvco_ldo_en_bb" pos="8" rst="0x0">
          <comment>RX VCO ldo power up</comment>
        </bits>
        <bits access="rw" name="rxvco_ldo_fc_bb" pos="7" rst="0x0">
          <comment>RX VCO ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="rxvco_ldo_load_bb" pos="6" rst="0x0">
          <comment>RX VCO ldo load en</comment>
        </bits>
        <bits access="rw" name="rxvco_buf_ldo_en_bb" pos="5" rst="0x0">
          <comment>RX VCO buffer ldo power up</comment>
        </bits>
        <bits access="rw" name="rxvco_buf_ldo_fc_bb" pos="4" rst="0x0">
          <comment>RX VCO buffer ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="rxvco_buf_ldo_load_bb" pos="3" rst="0x0">
          <comment>RX VCO buffer ldo load en</comment>
        </bits>
        <bits access="rw" name="rxvco_tc_en_bb" pos="2" rst="0x0">
          <comment>RX VCO TC power up</comment>
        </bits>
        <bits access="rw" name="rxvco_tc_fc_bb" pos="1" rst="0x0">
          <comment>RX VCO TC fast charge en</comment>
        </bits>
      </reg>
      <reg name="ldo_pu_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_ldo_bias_en_bb" pos="15" rst="0x0">
          <comment>txpll gro ldo bias en</comment>
        </bits>
        <bits access="rw" name="txpll_gro_ldo_en_bb" pos="14" rst="0x0">
          <comment>txpll gro ldo en</comment>
        </bits>
        <bits access="rw" name="txpll_presc_ldo_en_bb" pos="13" rst="0x0">
          <comment>TXPLL presc ldo power up</comment>
        </bits>
        <bits access="rw" name="txpll_presc_ldo_fast_charge_en_bb" pos="12" rst="0x0">
          <comment>TXPLL presc ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_dig_en_bb" pos="11" rst="0x0">
          <comment>TXPLL RDAC ldo digital power up</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_vref_en_bb" pos="10" rst="0x0">
          <comment>TXPLL RDAC ldo vref power up</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_vref_fc_en_bb" pos="9" rst="0x0">
          <comment>TXPLL RDAC ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_en_bb" pos="8" rst="0x0">
          <comment>TX VCO ldo power up</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_fc_bb" pos="7" rst="0x0">
          <comment>TX VCO ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_load_bb" pos="6" rst="0x0">
          <comment>TX VCO ldo load en</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_en_bb" pos="5" rst="0x0">
          <comment>TX VCO buffer ldo power up</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_fc_bb" pos="4" rst="0x0">
          <comment>TX VCO buffer ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_load_bb" pos="3" rst="0x0">
          <comment>TX VCO buffer ldo load en</comment>
        </bits>
        <bits access="rw" name="txvco_tc_en_bb" pos="2" rst="0x0">
          <comment>TX VCO TC power up</comment>
        </bits>
        <bits access="rw" name="txvco_tc_fc_bb" pos="1" rst="0x0">
          <comment>TX VCO TC fast charge en</comment>
        </bits>
      </reg>
      <reg name="trx_pu_0" protect="rw">
        <comment/>
        <bits access="rw" name="pu_bg_bb" pos="15" rst="0x1">
          <comment>Pu of bandgap</comment>
        </bits>
        <bits access="rw" name="pu_mdll_bb" pos="14" rst="0x0">
          <comment>pu_mdll_bb</comment>
        </bits>
        <bits access="rw" name="mdll_startup_bb" pos="13" rst="0x0">
          <comment>mdll start up</comment>
        </bits>
        <bits access="rw" name="pu_xdrv_bb" pos="12" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
pu xdrv buffer</comment>
        </bits>
      </reg>
      <reg name="trx_pu_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_bias_en_bb" pos="15" rst="0x0">
          <comment>rxvco_bias_en</comment>
        </bits>
        <bits access="rw" name="rxvco_ibias_en_bb" pos="14" rst="0x0">
          <comment>rxvco_ibias_en</comment>
        </bits>
        <bits access="rw" name="rxvco_vcoh_sel_bb" pos="13" rst="0x0">
          <comment>rxvcoh pu</comment>
        </bits>
        <bits access="rw" name="rxvco_vcol_sel_bb" pos="12" rst="0x0">
          <comment>rxvcol pu</comment>
        </bits>
        <bits access="rw" name="rxvco_pkdet_en_bb" pos="11" rst="0x0">
          <comment>rxvco_pkdet enable</comment>
        </bits>
        <bits access="rw" name="pu_rxpll_presc_bb" pos="10" rst="0x0">
          <comment>pu_rxpll_presc_bb</comment>
        </bits>
        <bits access="rw" name="pu_rxpll_gro_bb" pos="9" rst="0x0">
          <comment>pu_rxpll_gro_bb</comment>
        </bits>
        <bits access="rw" name="pu_rxpll_rdac_bb" pos="8" rst="0x0">
          <comment>pu_rxpll_rdac_bb</comment>
        </bits>
        <bits access="rw" name="rxpll_gro_rstn_bb" pos="7" rst="0x0">
          <comment>rxpll_gro_rstn_bb</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_rstn_bb" pos="6" rst="0x0">
          <comment>rxpll_rdac reset</comment>
        </bits>
      </reg>
      <reg name="trx_pu_2" protect="rw">
        <comment/>
        <bits access="rw" name="pu_lna_bb" pos="15" rst="0x0">
          <comment>LNA power up</comment>
        </bits>
        <bits access="rw" name="lna_pkd_en_bb" pos="14" rst="0x0">
          <comment>lna peak detector enable</comment>
        </bits>
        <bits access="rw" name="pga_en_bb" pos="13" rst="0x0">
          <comment>RX PGA enable</comment>
        </bits>
        <bits access="rw" name="pga_pkd_en_bb" pos="12" rst="0x0">
          <comment>rx pga peak detector enable</comment>
        </bits>
        <bits access="rw" name="pu_pga_bb" pos="11" rst="0x0">
          <comment>RX PGA DCDC IDAC power up</comment>
        </bits>
        <bits access="rw" name="pu_rxflt_bb" pos="10" rst="0x0">
          <comment>RX filter DCDC IDAC power up</comment>
        </bits>
        <bits access="rw" name="rxflt_rstn_bb" pos="9" rst="0x0">
          <comment>RX filter OPA negative reset</comment>
        </bits>
        <bits access="rw" name="rxflt_en_bb" pos="8" rst="0x0">
          <comment>RX filter enable</comment>
        </bits>
        <bits access="rw" name="pu_rxmixer_bb" pos="7" rst="0x0">
          <comment>rx mixer power up</comment>
        </bits>
        <bits access="rw" name="pu_tia_bb" pos="6" rst="0x0">
          <comment>tia power up</comment>
        </bits>
        <bits access="rw" name="adc_bias_en_bb" pos="5" rst="0x0">
          <comment>ADC enable</comment>
        </bits>
        <bits access="rw" name="adc_ref_enh_bb" pos="4" rst="0x0">
          <comment>ADC enable</comment>
        </bits>
        <bits access="rw" name="adc_clk_enh_bb" pos="3" rst="0x0">
          <comment>ADC enable</comment>
        </bits>
        <bits access="rw" name="adc_enh_bb" pos="2" rst="0x0">
          <comment>ADC enable</comment>
        </bits>
        <bits access="rw" name="adc_rstn_bb" pos="1" rst="0x0">
          <comment>ADC reset negative</comment>
        </bits>
      </reg>
      <reg name="trx_pu_3" protect="rw">
        <comment/>
        <bits access="rw" name="txvco_bias_en_bb" pos="15" rst="0x0">
          <comment>txvco_bias_en</comment>
        </bits>
        <bits access="rw" name="txvco_ibias_en_bb" pos="14" rst="0x0">
          <comment>txvco_ibias_en</comment>
        </bits>
        <bits access="rw" name="txvco_vcoh_sel_bb" pos="13" rst="0x0">
          <comment>txvcoh pu</comment>
        </bits>
        <bits access="rw" name="txvco_vcol_sel_bb" pos="12" rst="0x0">
          <comment>txvcol pu</comment>
        </bits>
        <bits access="rw" name="txvco_pkdet_en_bb" pos="11" rst="0x0">
          <comment>peak detector enable</comment>
        </bits>
        <bits access="rw" name="pu_txpll_presc_bb" pos="10" rst="0x0">
          <comment>pu_txpll_presc_bb</comment>
        </bits>
        <bits access="rw" name="pu_txpll_gro_bb" pos="9" rst="0x0"/>
        <bits access="rw" name="pu_txpll_rdac_bb" pos="8" rst="0x0">
          <comment>txpll RDAC power up</comment>
        </bits>
        <bits access="rw" name="txpll_gro_rstn_bb" pos="7" rst="0x0">
          <comment>txpll_gro_rstn_bb</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_rstn_bb" pos="6" rst="0x0">
          <comment>txpll RDAC reset</comment>
        </bits>
      </reg>
      <reg name="trx_pu_4" protect="rw">
        <comment/>
        <bits access="rw" name="txflt_rstn_bb" pos="15" rst="0x0">
          <comment>TX filter reset negative</comment>
        </bits>
        <bits access="rw" name="pu_dac_bb" pos="14" rst="0x0">
          <comment>DAC power up control</comment>
        </bits>
        <bits access="rw" name="dac_rstn_bb" pos="13" rst="0x0">
          <comment>DAC reset negative</comment>
        </bits>
        <bits access="rw" name="txmixer_en_bb" pos="12" rst="0x0">
          <comment>TX mixer work on enable</comment>
        </bits>
        <bits access="rw" name="pu_txflt_bb" pos="11" rst="0x0">
          <comment>TX filter power up control</comment>
        </bits>
        <bits access="rw" name="pu_txrf_bb" pos="10" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
txrf power on conrol</comment>
        </bits>
        <bits access="rw" name="txpad_en_bb" pos="9" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
TX PA driver work on enable</comment>
        </bits>
        <bits access="rw" name="pu_pwd_bb" pos="8" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
power detector power up</comment>
        </bits>
        <bits access="rw" name="pwdadc_rstn_bb" pos="7" rst="0x0">
          <comment>PWDADC reset negative</comment>
        </bits>
        <bits access="rw" name="pu_pwd_pga_bb" pos="6" rst="0x0">
          <comment>PWD PGA power up</comment>
        </bits>
        <bits access="rw" name="pwdadc_bias_en_bb" pos="5" rst="0x0">
          <comment>PWDADC enable</comment>
        </bits>
        <bits access="rw" name="pwdadc_ref_enh_bb" pos="4" rst="0x0">
          <comment>PWDADC enable</comment>
        </bits>
        <bits access="rw" name="pwdadc_clk_enh_bb" pos="3" rst="0x0">
          <comment>PWDADC enable</comment>
        </bits>
        <bits access="rw" name="pwdadc_enh_bb" pos="2" rst="0x0">
          <comment>PWDADC enable</comment>
        </bits>
        <bits access="rw" name="pwd_rstn_bb" pos="1" rst="0x0">
          <comment>PWD reset negative</comment>
        </bits>
      </reg>
      <reg name="trx_pu_5" protect="rw">
        <comment/>
        <bits access="rw" name="pu_dly_pwd_bb" pos="14" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
power detector power up delay</comment>
        </bits>
        <bits access="rw" name="pu_dly_txflt_bb" pos="13" rst="0x0">
          <comment>TX filter power up delay</comment>
        </bits>
        <bits access="rw" name="pu_dly_txrf_bb" pos="12" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
txrf power on conrol delay</comment>
        </bits>
      </reg>
      <reg name="mdll_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="mdll_div_bit_bb" pos="15:12" rst="0x7">
          <comment>Frequency division ratio of loop,
5~10.</comment>
        </bits>
        <bits access="rw" name="mdll_dither_en_bb" pos="11" rst="0x0">
          <comment>Dither control enable</comment>
        </bits>
        <bits access="rw" name="mdll_band_bit_bb" pos="10:8" rst="0x4">
          <comment>mdll_band_bit_bb</comment>
        </bits>
        <bits access="rw" name="mdll_band_sel_bb" pos="7" rst="0x1">
          <comment>mdll_band_sel_bb</comment>
        </bits>
        <bits access="rw" name="mdll_dither_bit_bb" pos="6:4" rst="0x4">
          <comment>Dither control bit</comment>
        </bits>
        <bits access="rw" name="mdll_cp_ibit_bb" pos="3:1" rst="0x1">
          <comment>mdll_cp_ibit_bb</comment>
        </bits>
        <bits access="rw" name="mdll_dither_mode_bb" pos="0" rst="0x0">
          <comment>Dither control mode selection</comment>
        </bits>
      </reg>
      <reg name="mdll_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="mdll_regu_vcosel_bb" pos="15:13" rst="0x4">
          <comment>Reset voltage control</comment>
        </bits>
        <bits access="rw" name="mdll_clk_divn_bb" pos="12:11" rst="0x0">
          <comment>Frequency division 1/2/4 of clock output buffer
01 /1; 10 /2; 11 /4;</comment>
        </bits>
        <bits access="rw" name="mdll_refclk_test_en_bb" pos="10" rst="0x0">
          <comment>mdll_refclk_test_en_bb</comment>
        </bits>
        <bits access="rw" name="mdll_vctrl_test_en_bb" pos="9" rst="0x0">
          <comment>mdll_vctrl_test_en_bb</comment>
        </bits>
        <bits access="rw" name="disable_refclk_rxpll_bb" pos="8" rst="0x0">
          <comment>disable_refclk_rxpll_bb</comment>
        </bits>
        <bits access="rw" name="disable_refclk_txpll_bb" pos="7" rst="0x0">
          <comment>disable_refclk_txpll_bb</comment>
        </bits>
      </reg>
      <reg name="xtal_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="xtal_iptat_en_bb" pos="1" rst="0x0">
          <comment>ptat current enable, for tsenadc.
TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="xtal26m_refpll_crf_en_bb" pos="0" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
      </reg>
      <reg name="rxvco_ldo_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_ldo_vcomode_sel_bb" pos="15" rst="0x1"/>
        <bits access="rw" name="rxvco_ldo_powermode_sel_bb" pos="14" rst="0x0"/>
        <bits access="rw" name="rxvco_ldo_short_en_bb" pos="13" rst="0x0"/>
        <bits access="rw" name="rxvco_ldo_out_bb" pos="12:10" rst="0x5"/>
        <bits access="rw" name="rxvco_ldo_trim_bb" pos="9:6" rst="0x7"/>
      </reg>
      <reg name="rxvco_buf_ldo_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_buf_ldo_vcomode_sel_bb" pos="15" rst="0x1"/>
        <bits access="rw" name="rxvco_buf_ldo_powermode_sel_bb" pos="14" rst="0x0"/>
        <bits access="rw" name="rxvco_buf_ldo_short_en_bb" pos="13" rst="0x0"/>
        <bits access="rw" name="rxvco_buf_ldo_out_bb" pos="12:10" rst="0x5"/>
        <bits access="rw" name="rxvco_buf_ldo_trim_bb" pos="9:6" rst="0x7"/>
      </reg>
      <reg name="rxvco_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_bias_extra_bb" pos="15" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_bias_sel_bb" pos="14" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_ktc_ctat_bb" pos="13:11" rst="0x3"/>
        <bits access="rw" name="rxvco_ktc_ptat_bb" pos="10:8" rst="0x3"/>
        <bits access="rw" name="rxvco_var_short_bb" pos="7" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_varbias_rcsel_bb" pos="6:5" rst="0x3"/>
        <bits access="rw" name="rxvco_varbias_vbsel_ctat_bb" pos="4:3" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_varbias_vbsel_ptat_bb" pos="2:1" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_var_reverse_bb" pos="0" rst="0x0">
          <comment>varactor bias reverse seleted</comment>
        </bits>
      </reg>
      <reg name="rxvco_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_varcom_bb" pos="15:13" rst="0x4"/>
        <bits access="rw" name="rxvco_vardif_bb" pos="12:10" rst="0x4"/>
        <bits access="rw" name="rxvco_pkd_pdt_bb" pos="9:7" rst="0x2"/>
        <bits access="rw" name="rxvco_pkd_ref_bb" pos="6:4" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_pkd_ref_ctrl_bb" pos="3" rst="0x0">
          <comment>tbd</comment>
        </bits>
      </reg>
      <reg name="rxvco_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_cm_sca_ctrl_bb" pos="15:12" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_lcl_div1_bb" pos="11" rst="0x0">
          <comment>rxvco_lcl_div1</comment>
        </bits>
        <bits access="rw" name="rxvco_lcl_div2_bb" pos="10" rst="0x0">
          <comment>rxvco_lcl_div2</comment>
        </bits>
        <bits access="rw" name="rxvco_lte_en_bb" pos="9" rst="0x0">
          <comment>rxvco lte en</comment>
        </bits>
      </reg>
      <reg name="rxpll_ldo_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_presc_ldo_ref_trim_bb" pos="15:12" rst="0x7">
          <comment>FBDIV LDO VREF TRIM，默认值750mV</comment>
        </bits>
        <bits access="rw" name="rxpll_presc_ldo_out_bb" pos="11:9" rst="0x5">
          <comment>FBDIV LDO VOUT，默认值950mV</comment>
        </bits>
        <bits access="rw" name="rxpll_presc_ldo_cripple_bb" pos="8:7" rst="0x2">
          <comment>FBDIV LDO镜像极点，1.2V VDD配2</comment>
        </bits>
        <bits access="rw" name="rxpll_gro_ldo_in_trim_bb" pos="6:3" rst="0x7">
          <comment>GRO Master LDO VREF TRIM，默认值750mV</comment>
        </bits>
        <bits access="rw" name="rxpll_gro_ldo_out_trim_bb" pos="2:1" rst="0x0">
          <comment>GRO Master LDO VOUT，默认值950mV</comment>
        </bits>
      </reg>
      <reg name="rxpll_ldo_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_ldo_cp_trim_bb" pos="15:13" rst="0x3">
          <comment>GRO Master LDO CP TRIM</comment>
        </bits>
        <bits access="rw" name="rxpll_gro_ldo_res_adjust_bb" pos="12:11" rst="0x2">
          <comment>GRO Master Slave LDO VDDRES</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_dig_ref_trim_bb" pos="10:7" rst="0x7">
          <comment>RDAC DIG LDO VREF TRIM,默认值750mV</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_dig_out_bb" pos="6:4" rst="0x5">
          <comment>RDAC DIG LDO VOUT,默认值950mV</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_dig_cripple_bb" pos="3:2" rst="0x2">
          <comment>RDAC DIG LDO 镜像极点, 1.2V VDD配2</comment>
        </bits>
      </reg>
      <reg name="rxpll_ldo_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_rdac_ldo_vref_ref_trim_bb" pos="15:12" rst="0x7">
          <comment>RDAC VREF LDO VREF TRIM,默认值750mV</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_vref_out_bb" pos="11:8" rst="0x5">
          <comment>RDAC VREF LDO VOUT,默认值880mV</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_vref_cripple_bb" pos="7:6" rst="0x2">
          <comment>RDAC VREF LDO 镜像极点, 1.2V VDD配2</comment>
        </bits>
        <bits access="rw" name="rxpll_fbdiv_vddres_bb" pos="5:3" rst="0x4">
          <comment>FBDIV VDDRES</comment>
        </bits>
      </reg>
      <reg name="rxpll_gro_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_reg0_bb" pos="15:0" rst="0x0">
          <comment>&lt;3&gt; 根据mdll选择slave ldo是否需要并入额外的nmos，mdll&lt;4，配置为1；mdll&gt;=4，配置为0；
&lt;4&gt; rxpll_gro_ldo_in_trim_en</comment>
        </bits>
      </reg>
      <reg name="rxpll_gro_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_reg1_bb" pos="15:0" rst="0x2aa3">
          <comment>[15]mod23_enb   [14]mod3_dly_more [13:4]clk_sample &amp; clk_dig dly  [3:2]pfd死区时间 [1:0]gro mode</comment>
        </bits>
      </reg>
      <reg name="rxpll_gro_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_reg2_bb" pos="15:0" rst="0x4">
          <comment>[1:0]clk_en for tdc cal
[2]在gro mode3时选择dn_en=0或者up_en的反；</comment>
        </bits>
      </reg>
      <reg name="rxpll_gro_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_reg3_bb" pos="15:0" rst="0x0">
          <comment>reserved</comment>
        </bits>
      </reg>
      <reg name="rxpll_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_rdac_vlow_selb_bb" pos="15:13" rst="0x0">
          <comment>vlow sel, 0~1/3vh, 1~1/5vh 3~1/9vh 7~0</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_clk_edgesel_bb" pos="12" rst="0x0">
          <comment>rdac clk edge sel</comment>
        </bits>
        <bits access="rw" name="rxpll_fbcsel_bit_bb" pos="11:9" rst="0x0">
          <comment>rxpll_fbdiv sdm clk &amp; ndiv load dly,0~dly more</comment>
        </bits>
        <bits access="rw" name="rxpll_sdmclk_sel_bb" pos="8" rst="0x0">
          <comment>rxpll_sdmclk_sel_bb</comment>
        </bits>
        <bits access="rw" name="rxpll_open_en_bb" pos="7" rst="0x0">
          <comment>RXPLL open loop enable</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_rcflt_r_bb" pos="6:4" rst="0x0">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="lna_sel_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="en_lna_wifi_bb" pos="15" rst="0x0">
          <comment>LNA wifi selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_h1_bb" pos="14" rst="0x0">
          <comment>LNA lte hb 1 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_h2_bb" pos="13" rst="0x0">
          <comment>LNA lte hb 2 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_m1_bb" pos="12" rst="0x0">
          <comment>LNA lte mb 1 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_m2_bb" pos="11" rst="0x0">
          <comment>LNA lte mb 2 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_m3_bb" pos="10" rst="0x0">
          <comment>LNA lte mb 3 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_m4_bb" pos="9" rst="0x0">
          <comment>LNA lte mb 4 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_m5_bb" pos="8" rst="0x0">
          <comment>LNA lte mb 5 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_gnss_bb" pos="7" rst="0x0">
          <comment>LNA lte gnss selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_l1_bb" pos="6" rst="0x0">
          <comment>LNA lte lb 1 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_l2_bb" pos="5" rst="0x0">
          <comment>LNA lte lb 2 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_l3_bb" pos="4" rst="0x0">
          <comment>LNA lte lb 3 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_l4_bb" pos="3" rst="0x0">
          <comment>LNA lte lb 4 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_l5_bb" pos="2" rst="0x0">
          <comment>LNA lte lb 5 selection</comment>
        </bits>
        <bits access="rw" name="rxmixer_vco_sel5g_bb" pos="1" rst="0x0">
          <comment>rxmixer LO signal selection, high for 5g VCO, low for 4g VCO;</comment>
        </bits>
        <bits access="rw" name="rxmixer_vco_selrx_bb" pos="0" rst="0x0">
          <comment>rxmixer LO signal selection, high for rx VCO, low for tx VCO;</comment>
        </bits>
      </reg>
      <reg name="lna_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="lna_power_res_bit_bb" pos="15:13" rst="0x7">
          <comment>lna_power_res_control</comment>
        </bits>
        <bits access="rw" name="lna_ldo_bypass_bb" pos="12" rst="0x0">
          <comment>LNA LDO bypass, work at 1.2V</comment>
        </bits>
        <bits access="rw" name="lna_ldo_cp_tune_bb" pos="11:10" rst="0x2">
          <comment>LNA LDO ripple cancelling cap control signal to mitigate VDD variation effect conotrol</comment>
        </bits>
        <bits access="rw" name="lna_ldo_out_bb" pos="9:7" rst="0x4">
          <comment>LNA LDO output voltage control signal 000 0.825V; 001 0.85V; 010 0.875; V011 0.9V; 100 0.925V; 101 0.95V; 110 0.975V; 111 1.0V;</comment>
        </bits>
        <bits access="rw" name="lna_gain0_bit_bb" pos="6" rst="0x1">
          <comment>lna gain0, not used</comment>
        </bits>
        <bits access="rw" name="lna_resf_en_bb" pos="3" rst="0x1">
          <comment>LNA Feedback resistor enable</comment>
        </bits>
      </reg>
      <reg name="lna_pkd_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="lna_pkd_pdt_bb" pos="15:13" rst="0x4">
          <comment>LNA peak detector threshold level control signa</comment>
        </bits>
        <bits access="rw" name="lna_pkd_ref_1_bb" pos="12:10" rst="0x3">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="lna_pkd_ref_2_bb" pos="9:7" rst="0x3">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="lna_pkd_ref_ctrl_bb" pos="6" rst="0x0">
          <comment>LNA peak detector threshold level control signal.</comment>
        </bits>
        <bits access="rw" name="lna_in_capbank_bb" pos="5:3" rst="0x4">
          <comment>LNA input matching capbank tune</comment>
        </bits>
      </reg>
      <reg name="rxmixer_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="rxmixer_lodc_h_bb" pos="15" rst="0x0">
          <comment>Lo dc level high mode</comment>
        </bits>
        <bits access="rw" name="rxmixer_lodc_lte_bit_bb" pos="14:13" rst="0x2">
          <comment>Lo dc level for lte mode</comment>
        </bits>
        <bits access="rw" name="tia_rin_bit_bb" pos="12:11" rst="0x1">
          <comment>Rin of tia. 00 for 50ohm, 11 for 250ohm</comment>
        </bits>
        <bits access="rw" name="tia_bypass_bb" pos="10" rst="0x0">
          <comment>Tia bypass mode</comment>
        </bits>
        <bits access="rw" name="lna_h2_capbank_bb" pos="9:7" rst="0x4">
          <comment>LNA mixer matching capbank tune high band2</comment>
        </bits>
        <bits access="rw" name="lna_m3_capbank_bb" pos="6:4" rst="0x4">
          <comment>LNA mixer matching capbank tune middle band3</comment>
        </bits>
      </reg>
      <reg name="pga_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxabb_ldo_out_bb" pos="15:13" rst="0x5">
          <comment>RX ABB LDO output voltage control signal 000 0.825V; 001 0.85V; 010 0.875; V011 0.9V; 100 0.925V; 101 0.95V; 110 0.975V; 111 1.0V;</comment>
        </bits>
        <bits access="rw" name="rxabb_ldo_cp_tun_bb" pos="12:11" rst="0x2">
          <comment>RX ABB LDO ripple cancelling cap control signal to mitigate VDD variation effect conotrol</comment>
        </bits>
        <bits access="rw" name="pga_i_bit_bb" pos="10:9" rst="0x1">
          <comment>Current of pga. 00 for 1.2mA, 11 for 3.5mA, 01 and 10 for 1.8mA.</comment>
        </bits>
        <bits access="rw" name="pga_rs_bit_bb" pos="8:4" rst="0x2">
          <comment>Rs control, 1st pole and 2nd pole control, only valid when pga_blk_mode=1</comment>
        </bits>
        <bits access="rw" name="pga_op_millercc_bit_bb" pos="3:2" rst="0x3">
          <comment>控制补偿电容大小，00 for 100f，01 and 10 for 200f，11 for 300f</comment>
        </bits>
        <bits access="rw" name="pga_op_millercn_bit_bb" pos="1:0" rst="0x3">
          <comment>控制补偿电容大小，00 is invalid，01 and 10 for 150fF，11 for 300fF.</comment>
        </bits>
      </reg>
      <reg name="pga_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="pga_bw_mode_bb" pos="15:13" rst="0x5">
          <comment>Bw control, 000 for 700KHz, 101 for 10MHz</comment>
        </bits>
        <bits access="rw" name="pga_cf_bit_bb" pos="12:8" rst="0xe">
          <comment>Cf control, 1st pole control, only valid when pga_blk_mode=1</comment>
        </bits>
        <bits access="rw" name="pga_blk_mode_bb" pos="7" rst="0x0">
          <comment>Gsm blokcer mode enable or test model for external control the capacitor and resistor in pga</comment>
        </bits>
        <bits access="rw" name="pga_rpre_bit_bb" pos="6:5" rst="0x3">
          <comment>Rpre control, blk fliter bw control, only valid when pga_blk_mode=1</comment>
        </bits>
        <bits access="rw" name="pga_c2nd_bit_bb" pos="4:3" rst="0x3">
          <comment>2nd pole control, only valid when pga_blk_mode=1</comment>
        </bits>
        <bits access="rw" name="pga_bw_tune_bit_bb" pos="2:0" rst="0x3">
          <comment>Bw tune. 000 for 0.8*bw, 111 for 1.5*bw.</comment>
        </bits>
      </reg>
      <reg name="pga_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="pga_ctun_bit_bb" pos="15:7" rst="0x82">
          <comment>控制带宽，并tuning带宽，512*40fF</comment>
        </bits>
        <bits access="rw" name="pga_pkd_ref1_bb" pos="6:4" rst="0x4">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="pga_pkd_ref2_bb" pos="3:1" rst="0x3">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="pga_pkd_ref_ctrl_bb" pos="0" rst="0x0">
          <comment>LNA peak detector threshold level control signal.</comment>
        </bits>
      </reg>
      <reg name="pga_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="pga_pkd_rctime_sel_bb" pos="15:14" rst="0x0">
          <comment>time for charge and discharge</comment>
        </bits>
        <bits access="rw" name="pga_pkd_ibias_sel_bb" pos="13:12" rst="0x0">
          <comment>bias current of the pkd op</comment>
        </bits>
        <bits access="rw" name="rxabb_ldo_trim_bb" pos="11:8" rst="0x7">
          <comment>ldo vout ctrl word</comment>
        </bits>
        <bits access="rw" name="pga_cm_con_bb" pos="7:5" rst="0x3">
          <comment>pga op vocm ctrl word</comment>
        </bits>
      </reg>
      <reg name="rxabb_dccal_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rx_dccal_i_bit_bb" pos="15:8" rst="0x80">
          <comment>Dc offset calibration</comment>
        </bits>
        <bits access="rw" name="rx_dccal_q_bit_bb" pos="7:0" rst="0x80">
          <comment>Dc offset calibration</comment>
        </bits>
      </reg>
      <reg name="rxabb_dccal_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rx_dccal_range_bit_bb" pos="15:14" rst="0x2">
          <comment>Dc offset calibration range</comment>
        </bits>
      </reg>
      <reg name="rxflt_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxflt_aux_en_bb" pos="15" rst="0x0">
          <comment>aux input for filter enable</comment>
        </bits>
        <bits access="rw" name="rxflt_bwmode_bit_bb" pos="14:12" rst="0x5">
          <comment>bandwith selection</comment>
        </bits>
        <bits access="rw" name="rxflt_bwtun_bit_bb" pos="11:8" rst="0x6">
          <comment>bandwith tuning</comment>
        </bits>
        <bits access="rw" name="rxflt_if_swap_bb" pos="7" rst="0x0">
          <comment>IQ swap, not use</comment>
        </bits>
        <bits access="rw" name="rxflt_if_en_bb" pos="6" rst="0x0">
          <comment>bandpass mode enable, set 0</comment>
        </bits>
        <bits access="rw" name="rxflt_if_freq_bit_bb" pos="5:3" rst="0x0">
          <comment>center frequency selection (not use)</comment>
        </bits>
      </reg>
      <reg name="rxflt_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="anti_kick_back_filter_bw_bb" pos="15:14" rst="0x1">
          <comment>anti_kick_back_filter_bw_control</comment>
        </bits>
        <bits access="rw" name="rxflt_op_millercc_bit_bb" pos="13:12" rst="0x3">
          <comment>控制补偿电容大小，00 for 100f，01 and 10 for 200f，11 for 300f</comment>
        </bits>
        <bits access="rw" name="rxflt_op_millercn_bit_bb" pos="11:10" rst="0x3">
          <comment>控制补偿电容大小，00 is invalid，01 and 10 for 150fF，11 for 300fF.</comment>
        </bits>
        <bits access="rw" name="rxflt_i_bit_bb" pos="9:8" rst="0x1">
          <comment>RX filter bias current select</comment>
        </bits>
      </reg>
      <reg name="rxflt_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxflt_bwtun_c1_bb" pos="15:8" rst="0x0">
          <comment>带宽档位控制 and tuning</comment>
        </bits>
        <bits access="rw" name="rxflt_bwtun_c2_bb" pos="7:1" rst="0x0">
          <comment>带宽档位控制 and tuning</comment>
        </bits>
      </reg>
      <reg name="adc_ldo_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="adc_ldo_cp_trim_bb" pos="15:13" rst="0x3">
          <comment>ADC LDO for charge pump output voltage control signal</comment>
        </bits>
        <bits access="rw" name="adc_ldo_in_trim_bb" pos="12:9" rst="0x7">
          <comment>ADC LDO input voltage control signal</comment>
        </bits>
        <bits access="rw" name="adc_ldo_out_trim_bb" pos="8:7" rst="0x1">
          <comment>ADC LDO output voltage control signal</comment>
        </bits>
      </reg>
      <reg name="adc_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="adc_clk_rst_ctrl_bb" pos="15:14" rst="0x1">
          <comment>Rst time control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="adc_clk_vin_delay_ctrl_bb" pos="13:12" rst="0x1">
          <comment>Signal in delay control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="adc_clkout_polarity_bb" pos="11" rst="0x0">
          <comment>CLOCK OUT polarity,0:rising edge,1:falling edge</comment>
        </bits>
        <bits access="rw" name="adc_en_latch_adjust_bb" pos="10:9" rst="0x1">
          <comment>Compare time control</comment>
        </bits>
        <bits access="rw" name="adc_loop_delay_ctrl_bb" pos="8:5" rst="0x4">
          <comment>Loop delay time control</comment>
        </bits>
        <bits access="rw" name="adc_msb_delay_ctrl_bb" pos="4:3" rst="0x1">
          <comment>MSB compare time control</comment>
        </bits>
        <bits access="rw" name="adc_ns_charge_set_time_ctrl_bb" pos="2:1" rst="0x1">
          <comment>Noise shaping charge set time control</comment>
        </bits>
        <bits access="rw" name="adc_ns_enh_bb" pos="0" rst="0x0">
          <comment>Noise shaping enable</comment>
        </bits>
      </reg>
      <reg name="adc_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="adc_os_code_q_bb" pos="14:10" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_code_0p5_q_bb" pos="9" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_code_0p25_q_bb" pos="8" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_code_i_bb" pos="6:2" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_code_0p5_i_bb" pos="1" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_code_0p25_i_bb" pos="0" rst="0x0">
          <comment>Offset control</comment>
        </bits>
      </reg>
      <reg name="adc_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="adc_ns_vcm_ctrl_bb" pos="15:13" rst="0x0">
          <comment>Ns common mode voltage control</comment>
        </bits>
        <bits access="rw" name="adc_os_cap_flow_i_bb" pos="12" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_cap_flow_q_bb" pos="11" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_res_adjust_bb" pos="10:9" rst="0x1"/>
        <bits access="rw" name="adc_residual_comp_en_bb" pos="8" rst="0x0">
          <comment>Residual compare enable</comment>
        </bits>
        <bits access="rw" name="adc_samp_hold_ctrl_bb" pos="7:6" rst="0x0">
          <comment>Sample clock delay control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="adc_stb_ctrl_bb" pos="5:3" rst="0x0">
          <comment>STB control</comment>
        </bits>
        <bits access="rw" name="adc_input_os_vcm_ctrl_bb" pos="2:0" rst="0x0">
          <comment>ADC vcm calibration</comment>
        </bits>
      </reg>
      <reg name="adc_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="adc_vcm_ctrl_bb" pos="15:13" rst="0x0">
          <comment>common mode voltage control</comment>
        </bits>
        <bits access="rw" name="adc_vrp_ctrl_bb" pos="12:9" rst="0x0">
          <comment>Vrp reference voltage control</comment>
        </bits>
        <bits access="rw" name="adc_vrp_i_ctrl_bb" pos="8:5" rst="0x6">
          <comment>Vrp control</comment>
        </bits>
        <bits access="rw" name="adc_clk_sel_bb" pos="4:3" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="adc_ns_slap_ctrl_bb" pos="1" rst="0x1">
          <comment>Ns slap control</comment>
        </bits>
        <bits access="rw" name="adc_input_short_bb" pos="0" rst="0x0">
          <comment>ADC input short for calibration</comment>
        </bits>
      </reg>
      <reg name="adc_rsv_0" protect="rw">
        <comment/>
      </reg>
      <reg name="pwdadc_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="pwdadc_clk_rst_ctrl_bb" pos="15:14" rst="0x1">
          <comment>Rst time control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="pwdadc_clk_vin_delay_ctrl_bb" pos="13:12" rst="0x1">
          <comment>Signal in delay control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="pwdadc_clkout_polarity_bb" pos="11" rst="0x0">
          <comment>CLOCK OUT polarity,0:rising edge,1:falling edge</comment>
        </bits>
        <bits access="rw" name="pwdadc_en_latch_adjust_bb" pos="10:9" rst="0x1">
          <comment>Compare time control</comment>
        </bits>
        <bits access="rw" name="pwdadc_loop_delay_ctrl_bb" pos="8:5" rst="0x4">
          <comment>Loop delay time control</comment>
        </bits>
        <bits access="rw" name="pwdadc_msb_delay_ctrl_bb" pos="4:3" rst="0x1">
          <comment>MSB compare time control</comment>
        </bits>
        <bits access="rw" name="pwdadc_ns_charge_set_time_ctrl_bb" pos="2:1" rst="0x1">
          <comment>Noise shaping charge set time control</comment>
        </bits>
        <bits access="rw" name="pwdadc_ns_enh_bb" pos="0" rst="0x0">
          <comment>Noise shaping enable</comment>
        </bits>
      </reg>
      <reg name="pwdadc_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="pwdadc_ns_slap_ctrl_bb" pos="15" rst="0x1">
          <comment>Ns slap control</comment>
        </bits>
        <bits access="rw" name="pwdadc_ns_vcm_ctrl_bb" pos="14:12" rst="0x0">
          <comment>Ns common mode voltage control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_cap_flow_i_bb" pos="11" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_cap_flow_q_bb" pos="10" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_code_0p5_i_bb" pos="9" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_code_0p5_q_bb" pos="8" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_code_0p25_i_bb" pos="7" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_code_0p25_q_bb" pos="6" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_code_i_bb" pos="5:1" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_input_short_bb" pos="0" rst="0x0">
          <comment>PWDADC input short for calibration</comment>
        </bits>
      </reg>
      <reg name="pwdadc_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="pwdadc_os_code_q_bb" pos="15:11" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_res_adjust_bb" pos="10:9" rst="0x1"/>
        <bits access="rw" name="pwdadc_residual_comp_en_bb" pos="8" rst="0x0">
          <comment>Residual compare enable</comment>
        </bits>
        <bits access="rw" name="pwdadc_samp_hold_ctrl_bb" pos="7:6" rst="0x0">
          <comment>Sample clock delay control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="pwdadc_stb_ctrl_bb" pos="5:3" rst="0x0">
          <comment>STB control</comment>
        </bits>
        <bits access="rw" name="pwdadc_clk_sel_bb" pos="2:1" rst="0x1">
          <comment>PWDADC clk selection</comment>
        </bits>
      </reg>
      <reg name="pwdadc_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="pwdadc_vcm_ctrl_bb" pos="15:13" rst="0x0">
          <comment>common mode voltage control</comment>
        </bits>
        <bits access="rw" name="pwdadc_vrp_ctrl_bb" pos="12:9" rst="0x0">
          <comment>Vrp reference voltage control</comment>
        </bits>
        <bits access="rw" name="pwdadc_vrp_i_ctrl_bb" pos="8:5" rst="0x6">
          <comment>Vrp control</comment>
        </bits>
        <bits access="rw" name="pwdadc_input_os_vcm_ctrl_bb" pos="4:2" rst="0x0">
          <comment>PWDADC vcm calibration</comment>
        </bits>
      </reg>
      <reg name="rx_gain_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="lna_gain_bb" pos="15:14" rst="0x3">
          <comment>lna gain control</comment>
        </bits>
        <bits access="rw" name="lna_bias_bb" pos="13:12" rst="0x2">
          <comment>lna bias control</comment>
        </bits>
        <bits access="rw" name="lna_vbc_bit_bb" pos="11:9" rst="0x2">
          <comment>LNA common gate bias select.</comment>
        </bits>
        <bits access="rw" name="pga_gain_bit_bb" pos="8:7" rst="0x3">
          <comment>Pga gain control, 11 for 4k Rf, 00 for 0.5k Rf.</comment>
        </bits>
        <bits access="rw" name="rxflt_gain_bit_bb" pos="6:3" rst="0xb">
          <comment>filter gain selection</comment>
        </bits>
        <bits access="rw" name="lna_resf_bit_bb" pos="2:0" rst="0x0">
          <comment>Rf of lna for impendance matching</comment>
        </bits>
      </reg>
      <reg name="rx_reserve1" protect="rw">
        <comment/>
        <bits access="rw" name="rx_reserve1_bb" pos="15:0" rst="0x0">
          <comment>[4] rxflt_bypass
[3:2] pga_dcoc_ictrl_bit&lt;1:0&gt;
[1:0] flt_dcoc_ictrl_bit&lt;1:0&gt;</comment>
        </bits>
      </reg>
      <reg name="rx_reserve2" protect="rw">
        <comment/>
        <bits access="rw" name="rx_reserve2_bb" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rx_reserve3" protect="rw">
        <comment/>
        <bits access="rw" name="rx_reserve3_bb" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txvco_ldo_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="txvco_ldo_vcomode_sel_bb" pos="15" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_powermode_sel_bb" pos="14" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_short_en_bb" pos="13" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_out_bb" pos="12:10" rst="0x5">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_trim_bb" pos="9:6" rst="0x7">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="txvco_buf_ldo_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="txvcobuf_ldo_vcomode_sel_bb" pos="15" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_powermode_sel_bb" pos="14" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_short_en_bb" pos="13" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_out_bb" pos="12:10" rst="0x5">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_trim_bb" pos="9:6" rst="0x7">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="txvco_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="txvco_bias_extra_bb" pos="15" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_bias_sel_bb" pos="14" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_ktc_ctat_bb" pos="13:11" rst="0x4"/>
        <bits access="rw" name="txvco_ktc_ptat_bb" pos="10:8" rst="0x4"/>
        <bits access="rw" name="txvco_var_short_bb" pos="7" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_varbias_rcsel_bb" pos="6:5" rst="0x3"/>
        <bits access="rw" name="txvco_varbias_vbsel_ctat_bb" pos="4:3" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_varbias_vbsel_ptat_bb" pos="2:1" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_var_reverse_bb" pos="0" rst="0x0">
          <comment>varactor bias reverse seleted</comment>
        </bits>
      </reg>
      <reg name="txvco_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="txvco_varcom_bb" pos="15:13" rst="0x4"/>
        <bits access="rw" name="txvco_vardif_bb" pos="12:10" rst="0x4"/>
        <bits access="rw" name="txvco_pkd_pdt_bb" pos="9:7" rst="0x2"/>
        <bits access="rw" name="txvco_pkd_ref_bb" pos="6:4" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_pkd_ref_ctrl_bb" pos="3" rst="0x0">
          <comment>tbd</comment>
        </bits>
      </reg>
      <reg name="txvco_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="txvco_cm_sca_ctrl_bb" pos="15:12" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_lcl_div1_bb" pos="11" rst="0x0">
          <comment>txvco_lcl_div1</comment>
        </bits>
        <bits access="rw" name="txvco_lcl_div2_bb" pos="10" rst="0x0">
          <comment>txvco_lcl_div2</comment>
        </bits>
        <bits access="rw" name="txvco_tx_en_bb" pos="8" rst="0x0">
          <comment>txvco_tx_en_bb</comment>
        </bits>
        <bits access="rw" name="txvco_rxlte_en_bb" pos="7" rst="0x0">
          <comment>txvco_rxlte_en_bb</comment>
        </bits>
        <bits access="rw" name="txvco_gnss_en_bb" pos="6" rst="0x0">
          <comment>txvco_gnss_en_bb</comment>
        </bits>
        <bits access="rw" name="txvco_rx_div1_en_bb" pos="5" rst="0x0">
          <comment>txvco_rx_div1_en_bb</comment>
        </bits>
        <bits access="rw" name="txrfdiv_div2_en_bb" pos="4" rst="0x0">
          <comment>txrfdiv_div2_en_bb</comment>
        </bits>
        <bits access="rw" name="txrfdiv_div4_en_bb" pos="3" rst="0x0">
          <comment>txrfdiv_div4_en_bb</comment>
        </bits>
        <bits access="rw" name="txrfdiv_lte_en_bb" pos="2" rst="0x0">
          <comment>txrfdiv_lte_en_bb</comment>
        </bits>
        <bits access="rw" name="txrfdiv_pwd_en_bb" pos="1" rst="0x0">
          <comment>txrfdiv_pwd_en_bb</comment>
        </bits>
      </reg>
      <reg name="txpll_ldo_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_presc_ldo_ref_trim_bb" pos="15:12" rst="0x7">
          <comment>FBDIV LDO VREF TRIM，默认值750mV</comment>
        </bits>
        <bits access="rw" name="txpll_presc_ldo_out_bb" pos="11:9" rst="0x5">
          <comment>FBDIV LDO VOUT，默认值950mV</comment>
        </bits>
        <bits access="rw" name="txpll_presc_ldo_cripple_bb" pos="8:7" rst="0x2">
          <comment>FBDIV LDO镜像极点，1.2V VDD配2</comment>
        </bits>
        <bits access="rw" name="txpll_gro_ldo_in_trim_bb" pos="6:3" rst="0x7">
          <comment>GRO Master LDO VREF TRIM，默认值750mV</comment>
        </bits>
        <bits access="rw" name="txpll_gro_ldo_out_trim_bb" pos="2:1" rst="0x0">
          <comment>GRO Master LDO VOUT，默认值950mV</comment>
        </bits>
      </reg>
      <reg name="txpll_ldo_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_ldo_cp_trim_bb" pos="15:13" rst="0x3">
          <comment>GRO Master LDO CP TRIM</comment>
        </bits>
        <bits access="rw" name="txpll_gro_ldo_res_adjust_bb" pos="12:11" rst="0x2">
          <comment>GRO Master Slave LDO VDDRES</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_dig_ref_trim_bb" pos="10:7" rst="0x7">
          <comment>RDAC DIG LDO VREF TRIM,默认值750mV</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_dig_out_bb" pos="6:4" rst="0x5">
          <comment>RDAC DIG LDO VOUT,默认值950mV</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_dig_cripple_bb" pos="3:2" rst="0x2">
          <comment>RDAC DIG LDO 镜像极点, 1.2V VDD配2</comment>
        </bits>
      </reg>
      <reg name="txpll_ldo_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_rdac_ldo_vref_ref_trim_bb" pos="15:12" rst="0x7">
          <comment>RDAC VREF LDO VREF TRIM,默认值750mV</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_vref_out_bb" pos="11:8" rst="0x5">
          <comment>RDAC VREF LDO VOUT,默认值880mV</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_vref_cripple_bb" pos="7:6" rst="0x2">
          <comment>RDAC VREF LDO 镜像极点, 1.2V VDD配2</comment>
        </bits>
        <bits access="rw" name="txpll_fbdiv_vddres_bb" pos="5:3" rst="0x4">
          <comment>FBDIV VDDRES</comment>
        </bits>
      </reg>
      <reg name="txpll_gro_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_reg0_bb" pos="15:0" rst="0x0">
          <comment>&lt;3&gt; 根据mdll选择slave ldo是否需要并入额外的nmos，mdll&lt;4，配置为1；mdll&gt;=4，配置为0；
&lt;4&gt; txpll_gro_ldo_in_trim_en</comment>
        </bits>
      </reg>
      <reg name="txpll_gro_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_reg1_bb" pos="15:0" rst="0x2aa3">
          <comment>[15]mod23_enb   [14]mod3_dly_more [13:4]clk_sample &amp; clk_dig dly  [3:2]pfd死区时间 [1:0]gro mode</comment>
        </bits>
      </reg>
      <reg name="txpll_gro_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_reg2_bb" pos="15:0" rst="0x4">
          <comment>[1:0]clk_en for tdc cal
[2]在gro mode3时选择dn_en=0或者up_en的反；</comment>
        </bits>
      </reg>
      <reg name="txpll_gro_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_reg3_bb" pos="15:0" rst="0x0">
          <comment>reserved</comment>
        </bits>
      </reg>
      <reg name="txpll_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_rdac_vlow_selb_bb" pos="15:13" rst="0x0">
          <comment>vlow sel, 0~1/3vh, 1~1/5vh 3~1/9vh 7~0</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_clk_edgesel_bb" pos="12" rst="0x0">
          <comment>rdac clk edge sel</comment>
        </bits>
        <bits access="rw" name="txpll_fbcsel_bit_bb" pos="11:9" rst="0x0">
          <comment>rxpll_fbdiv sdm clk &amp; ndiv load dly,0~dly more</comment>
        </bits>
        <bits access="rw" name="txpll_sdmclk_sel_bb" pos="8" rst="0x0">
          <comment>rxpll_sdmclk_sel_bb</comment>
        </bits>
        <bits access="rw" name="txpll_open_en_bb" pos="7" rst="0x0">
          <comment>RXPLL open loop enable</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_rcflt_r_bb" pos="6:4" rst="0x0">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="txrf_gain" protect="rw">
        <comment/>
        <bits access="rw" name="txrf_ph45_en_bb" pos="15" rst="0x1">
          <comment>45 degree slice enable</comment>
        </bits>
        <bits access="rw" name="txflt_ph45_en_bb" pos="14" rst="0x1">
          <comment>45 degree signal output enable</comment>
        </bits>
        <bits access="rw" name="txrf_gain1_bit_bb" pos="13:9" rst="0x1e">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
driver and mixer slice control</comment>
        </bits>
        <bits access="rw" name="txrf_gain2_bit_bb" pos="8:4" rst="0x1f">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
driver gain setting</comment>
        </bits>
        <bits access="rw" name="txrf_gain3_bit_bb" pos="3:1" rst="0x5">
          <comment>mixer input rc filter attenuation</comment>
        </bits>
      </reg>
      <reg name="txrf_gain_compensation" protect="rw">
        <comment/>
        <bits access="rw" name="txrf_gain2c_bit_bb" pos="15:12" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
0 deg driver gain compensation setting</comment>
        </bits>
        <bits access="rw" name="txrf_gain2c_p45_bit_bb" pos="11:8" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
+45 deg driver gain compensation setting</comment>
        </bits>
        <bits access="rw" name="txrf_gain2c_n45_bit_bb" pos="7:4" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
-45 deg driver gain compensation setting</comment>
        </bits>
        <bits access="rw" name="txpad_bias_ibit_bb" pos="3:1" rst="0x3">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
pad gm current bias tuning</comment>
        </bits>
      </reg>
      <reg name="txrf_gain_adj" protect="rw">
        <comment/>
        <bits access="rw" name="txpad_aux_vbit_bb" pos="15:14" rst="0x1">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
pad mgtr voltage bias tuning</comment>
        </bits>
        <bits access="rw" name="txpad_cas_vbit_bb" pos="13:12" rst="0x1">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
pad cascade voltage bias tuning</comment>
        </bits>
        <bits access="rw" name="txrf_sw_sel1_bb" pos="11" rst="0x1">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
output switch size control</comment>
        </bits>
        <bits access="rw" name="txrf_sw_sel2_bb" pos="10" rst="0x1">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
output switch size control</comment>
        </bits>
        <bits access="rw" name="txrf_en_bbload_bb" pos="9" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
45 degree load banlance for filter</comment>
        </bits>
        <bits access="rw" name="txrf_bandbalance_bit_bb" pos="8:7" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
attenuation before mixer for band difference</comment>
        </bits>
        <bits access="rw" name="txrf_hb1_en_bb" pos="6" rst="0x1">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
high band branch1 enable</comment>
        </bits>
        <bits access="rw" name="txrf_hb2_en_bb" pos="5" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
high band branch2 enable</comment>
        </bits>
        <bits access="rw" name="txrf_lb1_en_bb" pos="4" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
low band branch1 enable</comment>
        </bits>
        <bits access="rw" name="txrf_lb2_en_bb" pos="3" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
low band branch2 enable</comment>
        </bits>
      </reg>
      <reg name="txrf_matchcap" protect="rw">
        <comment/>
        <bits access="rw" name="txpad_cap_bit_bb" pos="15:12" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
frequence selection for different band.</comment>
        </bits>
        <bits access="rw" name="txpad_cap_ulb_bit_bb" pos="11:10" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
frequence selection for different band. Ulb</comment>
        </bits>
        <bits access="rw" name="txpad_deq_bit_bb" pos="9:8" rst="0x0">
          <comment>driver banlun deQ tuning</comment>
        </bits>
        <bits access="rw" name="txrf_rcflt_rbit_bb" pos="7:6" rst="0x2"/>
        <bits access="rw" name="txrf_mix_r2r_cbit_bb" pos="5" rst="0x0"/>
      </reg>
      <reg name="txflt_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="txflt_ldo_out_bb" pos="15:13" rst="0x4">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txflt_ldo_cp_tune_bb" pos="12:11" rst="0x2">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="tx_dccal_en_bb" pos="10" rst="0x0">
          <comment>caplatch enable</comment>
        </bits>
        <bits access="rw" name="tx_dccal_clk_edgesel_bb" pos="9" rst="0x0">
          <comment>cal_clk edge selection</comment>
        </bits>
        <bits access="rw" name="txflt_cc_bb" pos="8:7" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txflt_cn_bb" pos="6:5" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txflt_ibias_bit_bb" pos="4:3" rst="0x2">
          <comment>ibias current control</comment>
        </bits>
        <bits access="rw" name="txflt_vcm_ref_bb" pos="2:0" rst="0x3">
          <comment>TX filter output CM ctrl</comment>
        </bits>
      </reg>
      <reg name="txflt_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="txflt_hp_bit_bb" pos="15:14" rst="0x0">
          <comment>input high pass freq. control</comment>
        </bits>
        <bits access="rw" name="txflt_testin_en_bb" pos="13" rst="0x0">
          <comment>test mode enable</comment>
        </bits>
        <bits access="rw" name="txflt_bw_bit_bb" pos="12:10" rst="0x5">
          <comment>filter bandwidth control</comment>
        </bits>
        <bits access="rw" name="txflt_bwtun_bit_bb" pos="9:2" rst="0x41">
          <comment>filter bandwidth tuning control</comment>
        </bits>
        <bits access="rw" name="txflt_buffer_ibit_bb" pos="1:0" rst="0x2">
          <comment>TX filter output buffer current control</comment>
        </bits>
      </reg>
      <reg name="dac_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="dac_range_bit_bb" pos="15:14" rst="0x2">
          <comment>Vp_diff 00/01：300mv;10：600mv;11：750mv</comment>
        </bits>
        <bits access="rw" name="dac_auxout_en_bb" pos="13" rst="0x0">
          <comment>dac_auxout_en_bb</comment>
        </bits>
        <bits access="rw" name="dac_iout_en_bb" pos="12" rst="0x0">
          <comment>dac_iout_en_bb</comment>
        </bits>
        <bits access="rw" name="dac_muxen_bit_bb" pos="11:10" rst="0x1">
          <comment>bit[0]:en for tx
bit[1]:en for test</comment>
        </bits>
        <bits access="rw" name="dac_clkedge_sel_bb" pos="9" rst="0x1">
          <comment>0: negative;1: positive</comment>
        </bits>
        <bits access="rw" name="dac_vhigh_bit_bb" pos="8:6" rst="0x5">
          <comment>vhigh control, 000:600mv, 001:644mv, 010:692mv, 011:738mv, 100:788mv, 101:835mv, 110:882mv, 111:930mv;</comment>
        </bits>
        <bits access="rw" name="dac_core_bit_bb" pos="5:3" rst="0x4">
          <comment>dac_core_bit_bb</comment>
        </bits>
      </reg>
      <reg name="dac_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="dac_tia_cmi_bit_bb" pos="11:10" rst="0x2">
          <comment>tia input common mode voltage, 00:450mv, 01:550mv, 10:650mv, 11:750mv</comment>
        </bits>
        <bits access="rw" name="dac_tia_cmo_bit_bb" pos="9:8" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="dac_tia_opamp_fbcap_bit_bb" pos="7:6" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="dac_ldo_cp_tune_bb" pos="5:4" rst="0x2">
          <comment>LDO</comment>
        </bits>
        <bits access="rw" name="dac_ldo_out_bb" pos="3:1" rst="0x4">
          <comment>LDO out voltage control</comment>
        </bits>
      </reg>
      <reg name="gnss_clkgen_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_bufsel_bb" pos="15:14" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_div_bb" pos="13:9" rst="0x6">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_vres_bb" pos="8:6" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_bufsel_bb" pos="5:4" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_div_bb" pos="3:0" rst="0x4">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="gnss_clkgen_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_clkgen_m4_clk_vres_bb" pos="15:13" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_bufsel_bb" pos="12:11" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_div_bb" pos="10:6" rst="0x6">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_vres_bb" pos="5:3" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_tsx_adc_clk_bufsel_bb" pos="2:1" rst="0x1">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="gnss_clkgen_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_clkgen_tsx_adc_clk_div_bb" pos="15:12" rst="0x8">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_tsx_adc_clk_vres_bb" pos="11:9" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_ana_adc_clk_bufsel_bb" pos="8:7" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_ana_adc_clk_div_bb" pos="6:0" rst="0x7">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="gnss_clkgen_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_clkgen_ana_adc_clk_vres_bb" pos="15:13" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_mux_bb" pos="12:11" rst="0x2">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_mux_bb" pos="10:9" rst="0x2">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_div_frac_en_bb" pos="8" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_frac_divf_bb" pos="7:5" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_frac_divn_bb" pos="4:2" rst="0x4">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_frac_sel_bb" pos="1" rst="0x0">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="gnss_clkgen_ctrl_4" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_div_en_bb" pos="15" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_en_bb" pos="14" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_div_en_bb" pos="13" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_en_bb" pos="12" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_div_en_bb" pos="11" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_en_bb" pos="10" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_tsx_adc_clk_div_en_bb" pos="9" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_tsx_adc_clk_en_bb" pos="8" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_ana_adc_clk_div_en_bb" pos="7" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_ana_adc_clk_en_bb" pos="6" rst="0x0">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="rxflt_dccal" protect="rw">
        <comment/>
        <bits access="rw" name="rxflt_dccal_i_bit_bb" pos="15:8" rst="0x80">
          <comment>Dc offset calibration rxflt input</comment>
        </bits>
        <bits access="rw" name="rxflt_dccal_q_bit_bb" pos="7:0" rst="0x80">
          <comment>Dc offset calibration rxflt input</comment>
        </bits>
      </reg>
      <reg name="tx_reserve_0" protect="rw">
        <comment/>
        <bits access="rw" name="lte_tx_rsv_09_h_bb" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="tx_reserve_1" protect="rw">
        <comment/>
        <bits access="rw" name="lte_tx_rsv_09_l_bb" pos="15:8" rst="0x2">
          <comment>[0] LTE_TX_VCO_DIV_BUF_EN
[1] LTE_TX_VCO_RX_DIV1_EN</comment>
        </bits>
        <bits access="rw" name="lte_tx_rsv_18_bb" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="pwd_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_pga_res_bit_bb" pos="15:12" rst="0x0"/>
        <bits access="rw" name="pwd_mgain_bit_bb" pos="11:9" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
power detector mixer gain selection</comment>
        </bits>
        <bits access="rw" name="pwd_pga_ldo_res_adj_bb" pos="8:7" rst="0x1"/>
        <bits access="rw" name="pwd_pga_cn_bit_bb" pos="6:5" rst="0x3"/>
        <bits access="rw" name="pwd_pga_cc_bit_bb" pos="4:3" rst="0x3"/>
      </reg>
      <reg name="pwd_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_pga_cap_bit_bb" pos="15:12" rst="0x7"/>
      </reg>
      <reg name="pwd_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_cal_i_bb" pos="15:10" rst="0x20">
          <comment>Pwd pga dc offset calibration</comment>
        </bits>
        <bits access="rw" name="pwd_cal_i_done_bb" pos="9" rst="0x1">
          <comment>pwd_cal_i_done_bb</comment>
        </bits>
        <bits access="rw" name="pwd_cal_i_en_bb" pos="8" rst="0x0">
          <comment>Pwd pga dc offset calibration enable</comment>
        </bits>
        <bits access="rw" name="pwd_cal_q_bb" pos="7:2" rst="0x20">
          <comment>Pwd pga dc offset calibration</comment>
        </bits>
        <bits access="rw" name="pwd_cal_q_done_bb" pos="1" rst="0x1">
          <comment>pwd_cal_q_done_bb</comment>
        </bits>
        <bits access="rw" name="pwd_cal_q_en_bb" pos="0" rst="0x0">
          <comment>Pwd pga dc offset calibration enable</comment>
        </bits>
      </reg>
      <reg name="ts_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="ts_ldo_en_bb" pos="15" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO enable</comment>
        </bits>
        <bits access="rw" name="ts_ldo_fast_charge_en_bb" pos="14" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO fast charge</comment>
        </bits>
        <bits access="rw" name="pu_ts_bb" pos="13" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
TS power up</comment>
        </bits>
        <bits access="rw" name="ts_pwdint_en_bb" pos="12" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Voltage measurement mode</comment>
        </bits>
        <bits access="rw" name="ts_pwdext_en_bb" pos="11" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Voltage measurement mode</comment>
        </bits>
        <bits access="rw" name="ts_xtaltest_en_bb" pos="10" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Voltage measurement mode</comment>
        </bits>
        <bits access="rw" name="ts_chopper_en_bb" pos="9" rst="0x1">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Chopper enable</comment>
        </bits>
        <bits access="rw" name="ts_div_bit_bb" pos="8:5" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Chopper clock select</comment>
        </bits>
        <bits access="rw" name="ts_refsel_bit_bb" pos="4:3" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC reference selection</comment>
        </bits>
        <bits access="rw" name="ts_adc_ibit_bb" pos="2:0" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
The SDMADC bias current. 000 is 2uA.</comment>
        </bits>
      </reg>
      <reg name="ts_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="ts_vbe_bit_bb" pos="15:8" rst="0x20">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
VBE control, which is used to calibrate the non-linearity of temperature sensor.</comment>
        </bits>
        <bits access="rw" name="ts_resetn_bb" pos="7" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Reset</comment>
        </bits>
        <bits access="rw" name="ts_testmode_en_bb" pos="6" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
TS Test mode  power up</comment>
        </bits>
        <bits access="rw" name="ts_vbe_sdmbit_bb" pos="5" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
VBE non linearity calibration using another SDMADC</comment>
        </bits>
        <bits access="rw" name="ts_beta_en_bb" pos="4" rst="0x1">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Biploar core beta dependance calibration</comment>
        </bits>
        <bits access="rw" name="ts_clksel_bit_bb" pos="3:2" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC CLK select. 00 1/8 MCLK; 01 1/4 MCLK; 10 1/2 MCLK; 11 MCLK</comment>
        </bits>
        <bits access="rw" name="ts_clk_edgesel_bb" pos="1" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Clk edge selected for MCLK</comment>
        </bits>
        <bits access="rw" name="ts_clk_divedge_sel_bb" pos="0" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Clk edge selected for internal MCLK divider.</comment>
        </bits>
      </reg>
      <reg name="ts_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="ts_ldo_cp_tune_bb" pos="15:14" rst="0x1">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO psr improved</comment>
        </bits>
        <bits access="rw" name="ts_ldo_out_bb" pos="13:11" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO output voltage seltect for 1.5V</comment>
        </bits>
      </reg>
      <reg name="cm_reserve1" protect="rw">
        <comment/>
        <bits access="rw" name="cm_reserve1_bb" pos="15:0" rst="0x0">
          <comment>[0] additional control bit for pwd_pga_cap_bit
[1] ISO signal for clk26m_lp_uart, 0 for isolation, vcore_top domain</comment>
        </bits>
      </reg>
      <reg name="cm_reserve2" protect="rw">
        <comment/>
        <bits access="rw" name="cm_reserve2_bb" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="cm_reserve3" protect="rw">
        <comment/>
        <bits access="rw" name="cm_reserve3_bb" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="revid_reg" protect="rw">
        <comment/>
        <bits access="r" name="revid" pos="7:0" rst="0x0">
          <comment>revid</comment>
        </bits>
      </reg>
      <reg name="test_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="tx_if_en_bb" pos="15" rst="0x0">
          <comment>TX IF test interface open enable</comment>
        </bits>
        <bits access="rw" name="dac_out_en_bb" pos="14" rst="0x0">
          <comment>DAC out test interface open enable</comment>
        </bits>
        <bits access="rw" name="pll_test_en_bb" pos="13" rst="0x0">
          <comment>CLK of PLL test enable</comment>
        </bits>
        <bits access="rw" name="test_mdll_vctrl_sw_en_bb" pos="12" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_ldoref_adc_sw_en_bb" pos="11" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_clk_mdll_sw_en_bb" pos="10" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_bg_cal_r_en_bb" pos="9" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK
Band gap iref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_txvco_sw_en_bb" pos="8" rst="0x0">
          <comment>TX VCO ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_txvcobuf_sw_en_bb" pos="7" rst="0x0">
          <comment>TX VCOBUF ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_rxabb_sw_en_bb" pos="6" rst="0x0">
          <comment>RX ABB ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_rxvco_sw_en_bb" pos="5" rst="0x0">
          <comment>RX VCO ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_rxvcobuf_sw_en_bb" pos="4" rst="0x0">
          <comment>RX VCOBUF ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_txvco_en_bb" pos="3" rst="0x0">
          <comment>txvco_test_en</comment>
        </bits>
        <bits access="rw" name="rx_5g_test_en_bb" pos="2" rst="0x0">
          <comment>rx_5g_test_en</comment>
        </bits>
        <bits access="rw" name="rx_4g_test_en_bb" pos="1" rst="0x0">
          <comment>rx_4g_test_en</comment>
        </bits>
        <bits access="rw" name="rx_lo_test_en_bb" pos="0" rst="0x0">
          <comment>rx_lo_test_en</comment>
        </bits>
      </reg>
      <reg name="test_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="test_clk_ts_sw_en_bb" pos="15" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_vl_ts_sw_en_bb" pos="14" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_vr_ts_sw_en_bb" pos="13" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_vref_ts_sw_en_bb" pos="12" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_vpa_ts_sw_en_bb" pos="11" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_ldoref_rxpll_rdac_sw_en_bb" pos="10" rst="0x0">
          <comment>RX PLL RDAC ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_txpll_rdac_sw_en_bb" pos="9" rst="0x0">
          <comment>TX PLL RDAC ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_iq_adcinput_sw_en_bb" pos="8" rst="0x0">
          <comment>ADC INPUT TEST EN</comment>
        </bits>
        <bits access="rw" name="cal_rxiq_div2_en_bb" pos="7" rst="0x0">
          <comment>rxiq calibration signal divide by 2 enable</comment>
        </bits>
        <bits access="rw" name="cal_rxiq_div4_en_bb" pos="6" rst="0x0">
          <comment>rxiq calibration signal divide by 4 enable</comment>
        </bits>
        <bits access="rw" name="cal_rxiq_att_ctrl_bb" pos="5:1" rst="0x8">
          <comment>rxiq calibration signal ATT CTRL</comment>
        </bits>
      </reg>
      <reg name="cal_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="cal_txiq_sel_bb" pos="15" rst="0x0">
          <comment>0:cal sig from padrv; 1: cal sig from ext pa;</comment>
        </bits>
        <bits access="rw" name="cal_txiq_en_bb" pos="14" rst="0x0"/>
        <bits access="rw" name="cal_rxiq_mix_sel_bb" pos="13" rst="0x0"/>
        <bits access="rw" name="cal_rxiq_en_bb" pos="12" rst="0x0"/>
        <bits access="rw" name="txpad_att_ctl_bb" pos="11:10" rst="0x0"/>
        <bits access="rw" name="tx_ed_ibp_bb" pos="9:7" rst="0x2">
          <comment>ed ptat current source adjust</comment>
        </bits>
        <bits access="rw" name="tx_ed_ibg_bb" pos="6:4" rst="0x2">
          <comment>ed bg current source adjust</comment>
        </bits>
        <bits access="rw" name="cal_rxiq_att_adj_bb" pos="3:0" rst="0x4">
          <comment>rxiq calibration signal ATT adjust</comment>
        </bits>
      </reg>
      <reg name="rf_output_readonly_0" protect="rw">
        <comment/>
        <bits access="r" name="tx_dccal_outi_bb" pos="15" rst="0x0">
          <comment>from AVDDRF_12_RF &amp; AVSS_RF
TX dc cal output I</comment>
        </bits>
        <bits access="r" name="tx_dccal_outq_bb" pos="14" rst="0x0">
          <comment>from AVDDRF_12_RF &amp; AVSS_RF
TX dc cal output Q</comment>
        </bits>
        <bits access="r" name="lna_pkd_out_1_bb" pos="13" rst="0x0">
          <comment>from AVDDRF_12_LNA &amp; AVSS_LNA
LNA peak detector output signal</comment>
        </bits>
        <bits access="r" name="lna_pkd_out_2_bb" pos="12" rst="0x0">
          <comment>from AVDDRF_12_LNA &amp; AVSS_LNA
LNA peak detector output signal</comment>
        </bits>
        <bits access="r" name="pga_pkd_out_bb" pos="11:10" rst="0x0">
          <comment>from AVDDRF_12_CLK &amp; AVSS_RXABB
RX PGA peak detector output signal</comment>
        </bits>
        <bits access="r" name="rxvco_pkdet_out_bb" pos="9" rst="0x0">
          <comment>from AVDDRF_12_RX &amp; AVSS_LNA
RX VCO peak detector output</comment>
        </bits>
        <bits access="r" name="txvco_pkdet_out_bb" pos="8" rst="0x0">
          <comment>from AVDDRF_12_RF &amp; AVSS_RF
TX VCO peak detector output</comment>
        </bits>
        <bits access="r" name="rxpll_lock_bb" pos="7" rst="0x0">
          <comment>RXPLL lock flag, generated by DLPF;</comment>
        </bits>
        <bits access="r" name="txpll_lock_bb" pos="6" rst="0x0">
          <comment>TXPLL lock flag, generated by DLPF;</comment>
        </bits>
      </reg>
      <reg name="rf_output_readonly_1" protect="rw">
        <comment/>
        <bits access="r" name="adc_conv_done_i_wi_ns_bb" pos="15" rst="0x0"/>
        <bits access="r" name="adc_conv_done_q_wi_ns_bb" pos="14" rst="0x0"/>
        <bits access="r" name="adc_conv_done_i_wo_ns_bb" pos="13" rst="0x0"/>
        <bits access="r" name="adc_conv_done_q_wo_ns_bb" pos="12" rst="0x0"/>
        <bits access="r" name="pwdadc_conv_done_i_wi_ns_bb" pos="11" rst="0x0"/>
        <bits access="r" name="pwdadc_conv_done_q_wi_ns_bb" pos="10" rst="0x0"/>
        <bits access="r" name="pwdadc_conv_done_i_wo_ns_bb" pos="9" rst="0x0"/>
        <bits access="r" name="pwdadc_conv_done_q_wo_ns_bb" pos="8" rst="0x0"/>
      </reg>
      <reg name="tsenadc_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rg_tsen_adcldo_en_bb" pos="15" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADCLDO enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_adcldo_v_bb" pos="14:11" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO output setting</comment>
        </bits>
        <bits access="rw" name="rg_tsen_adcldoref_bb" pos="10:6" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO trim setting(VREF)</comment>
        </bits>
        <bits access="rw" name="rg_tsen_chop_clksel_bb" pos="1:0" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
CHOP CLK setting
00:/8192
01:/4096
10:/2048
11:/1024</comment>
        </bits>
      </reg>
      <reg name="tsenadc_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_tsen_clksel_bb" pos="15:14" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
SAMPLE CLK setting
00:/4
01:/4
10:/2
11:/1</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_bias_bb" pos="13:12" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC BIAS setting
00:10uA
01:5uA
10:15uA
11:20uA</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_capchop_en_bb" pos="11" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC CAPCHOP CK enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_chop_en_bb" pos="10" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC CHOP CK enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_data_edge_sel_bb" pos="9" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC sample edge select:
0:positive edge 1:negative edge</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_en_bb" pos="8" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC enable</comment>
        </bits>
      </reg>
      <reg name="tsenadc_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_tsen_sdadc_input_en_bb" pos="15" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC input RC enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_offset_en_bb" pos="14" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC offset cancel enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_rst_bb" pos="13" rst="0x1">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC reset signal, 0 to reset</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_ugbuf_en_bb" pos="12" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC input UGBUF enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_vcmi_bb" pos="11:10" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC_input CM setting</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_vcmo_bb" pos="9:8" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC_output CM setting</comment>
        </bits>
        <bits access="rw" name="rg_tsen_test_clk_sel_bb" pos="7" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
CLK_TSEN_TEST channel select enable:
0: choose CLK path from 1.8V CLK_TSEN_26M
1: choose CLK path from 0.9V CLK_TSEN_TEST</comment>
        </bits>
        <bits access="rw" name="rg_tsen_ugbuf_bias_bb" pos="6:5" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC BIAS setting
00:10uA
01:5uA
10:15uA
11:20uA</comment>
        </bits>
        <bits access="rw" name="rg_tsen_ugbuf_chop_en_bb" pos="4" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC UGBUF CHOP CK enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_ugbuf_ctrl_bb" pos="3:2" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC_UGBUF GBW setting</comment>
        </bits>
      </reg>
      <reg name="apc_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="apc_bprc_bb" pos="15" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="apc_hv_gain_bit_bb" pos="14:12" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="apc_lv_gain_bit_bb" pos="11:9" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="apc_pga_ibit_bb" pos="8:7" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="pu_ramp_dac_bb" pos="6" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
      </reg>
      <reg name="apc_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="ramp_dac_din_bb" pos="9:0" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
      </reg>
      <hole size="4928"/>
      <reg name="bandgap_ctrl_0_set" protect="rw"/>
      <reg name="ldo_pu_ctrl_0_set" protect="rw"/>
      <reg name="ldo_pu_ctrl_1_set" protect="rw"/>
      <reg name="ldo_pu_ctrl_2_set" protect="rw"/>
      <reg name="trx_pu_0_set" protect="rw"/>
      <reg name="trx_pu_1_set" protect="rw"/>
      <reg name="trx_pu_2_set" protect="rw"/>
      <reg name="trx_pu_3_set" protect="rw"/>
      <reg name="trx_pu_4_set" protect="rw"/>
      <reg name="trx_pu_5_set" protect="rw"/>
      <reg name="mdll_ctrl_0_set" protect="rw"/>
      <reg name="mdll_ctrl_1_set" protect="rw"/>
      <reg name="xtal_ctrl_0_set" protect="rw"/>
      <reg name="rxvco_ldo_ctrl_set" protect="rw"/>
      <reg name="rxvco_buf_ldo_ctrl_set" protect="rw"/>
      <reg name="rxvco_ctrl_0_set" protect="rw"/>
      <reg name="rxvco_ctrl_1_set" protect="rw"/>
      <reg name="rxvco_ctrl_2_set" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_0_set" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_1_set" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_2_set" protect="rw"/>
      <reg name="rxpll_gro_ctrl_0_set" protect="rw"/>
      <reg name="rxpll_gro_ctrl_1_set" protect="rw"/>
      <reg name="rxpll_gro_ctrl_2_set" protect="rw"/>
      <reg name="rxpll_gro_ctrl_3_set" protect="rw"/>
      <reg name="rxpll_ctrl_0_set" protect="rw"/>
      <reg name="lna_sel_ctrl_set" protect="rw"/>
      <reg name="lna_ctrl_set" protect="rw"/>
      <reg name="lna_pkd_ctrl_set" protect="rw"/>
      <reg name="rxmixer_ctrl_set" protect="rw"/>
      <reg name="pga_ctrl_0_set" protect="rw"/>
      <reg name="pga_ctrl_1_set" protect="rw"/>
      <reg name="pga_ctrl_2_set" protect="rw"/>
      <reg name="pga_ctrl_3_set" protect="rw"/>
      <reg name="rxabb_dccal_ctrl_0_set" protect="rw"/>
      <reg name="rxabb_dccal_ctrl_1_set" protect="rw"/>
      <reg name="rxflt_ctrl_0_set" protect="rw"/>
      <reg name="rxflt_ctrl_1_set" protect="rw"/>
      <reg name="rxflt_ctrl_2_set" protect="rw"/>
      <reg name="adc_ldo_ctrl_set" protect="rw"/>
      <reg name="adc_ctrl_0_set" protect="rw"/>
      <reg name="adc_ctrl_1_set" protect="rw"/>
      <reg name="adc_ctrl_2_set" protect="rw"/>
      <reg name="adc_ctrl_3_set" protect="rw"/>
      <reg name="adc_rsv_0_set" protect="rw"/>
      <reg name="pwdadc_ctrl_0_set" protect="rw"/>
      <reg name="pwdadc_ctrl_1_set" protect="rw"/>
      <reg name="pwdadc_ctrl_2_set" protect="rw"/>
      <reg name="pwdadc_ctrl_3_set" protect="rw"/>
      <reg name="rx_gain_ctrl_set" protect="rw"/>
      <reg name="rx_reserve1_set" protect="rw"/>
      <reg name="rx_reserve2_set" protect="rw"/>
      <reg name="rx_reserve3_set" protect="rw"/>
      <reg name="txvco_ldo_ctrl_set" protect="rw"/>
      <reg name="txvco_buf_ldo_ctrl_set" protect="rw"/>
      <reg name="txvco_ctrl_0_set" protect="rw"/>
      <reg name="txvco_ctrl_1_set" protect="rw"/>
      <reg name="txvco_ctrl_2_set" protect="rw"/>
      <reg name="txpll_ldo_ctrl_0_set" protect="rw"/>
      <reg name="txpll_ldo_ctrl_1_set" protect="rw"/>
      <reg name="txpll_ldo_ctrl_2_set" protect="rw"/>
      <reg name="txpll_gro_ctrl_0_set" protect="rw"/>
      <reg name="txpll_gro_ctrl_1_set" protect="rw"/>
      <reg name="txpll_gro_ctrl_2_set" protect="rw"/>
      <reg name="txpll_gro_ctrl_3_set" protect="rw"/>
      <reg name="txpll_ctrl_0_set" protect="rw"/>
      <reg name="txrf_gain_set" protect="rw"/>
      <reg name="txrf_gain_compensation_set" protect="rw"/>
      <reg name="txrf_gain_adj_set" protect="rw"/>
      <reg name="txrf_matchcap_set" protect="rw"/>
      <reg name="txflt_ctrl_0_set" protect="rw"/>
      <reg name="txflt_ctrl_1_set" protect="rw"/>
      <reg name="dac_ctrl_0_set" protect="rw"/>
      <reg name="dac_ctrl_1_set" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_0_set" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_1_set" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_2_set" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_3_set" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_4_set" protect="rw"/>
      <reg name="rxflt_dccal_set" protect="rw"/>
      <reg name="tx_reserve_0_set" protect="rw"/>
      <reg name="tx_reserve_1_set" protect="rw"/>
      <reg name="pwd_ctrl_0_set" protect="rw"/>
      <reg name="pwd_ctrl_1_set" protect="rw"/>
      <reg name="pwd_ctrl_2_set" protect="rw"/>
      <reg name="ts_ctrl_0_set" protect="rw"/>
      <reg name="ts_ctrl_1_set" protect="rw"/>
      <reg name="ts_ctrl_2_set" protect="rw"/>
      <reg name="cm_reserve1_set" protect="rw"/>
      <reg name="cm_reserve2_set" protect="rw"/>
      <reg name="cm_reserve3_set" protect="rw"/>
      <hole size="32"/>
      <reg name="test_ctrl_0_set" protect="rw"/>
      <reg name="test_ctrl_1_set" protect="rw"/>
      <reg name="cal_ctrl_0_set" protect="rw"/>
      <hole size="64"/>
      <reg name="tsenadc_ctrl_0_set" protect="rw"/>
      <reg name="tsenadc_ctrl_1_set" protect="rw"/>
      <reg name="tsenadc_ctrl_2_set" protect="rw"/>
      <reg name="apc_ctrl_0_set" protect="rw"/>
      <reg name="apc_ctrl_1_set" protect="rw"/>
      <hole size="4928"/>
      <reg name="bandgap_ctrl_0_clr" protect="rw"/>
      <reg name="ldo_pu_ctrl_0_clr" protect="rw"/>
      <reg name="ldo_pu_ctrl_1_clr" protect="rw"/>
      <reg name="ldo_pu_ctrl_2_clr" protect="rw"/>
      <reg name="trx_pu_0_clr" protect="rw"/>
      <reg name="trx_pu_1_clr" protect="rw"/>
      <reg name="trx_pu_2_clr" protect="rw"/>
      <reg name="trx_pu_3_clr" protect="rw"/>
      <reg name="trx_pu_4_clr" protect="rw"/>
      <reg name="trx_pu_5_clr" protect="rw"/>
      <reg name="mdll_ctrl_0_clr" protect="rw"/>
      <reg name="mdll_ctrl_1_clr" protect="rw"/>
      <reg name="xtal_ctrl_0_clr" protect="rw"/>
      <reg name="rxvco_ldo_ctrl_clr" protect="rw"/>
      <reg name="rxvco_buf_ldo_ctrl_clr" protect="rw"/>
      <reg name="rxvco_ctrl_0_clr" protect="rw"/>
      <reg name="rxvco_ctrl_1_clr" protect="rw"/>
      <reg name="rxvco_ctrl_2_clr" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_0_clr" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_1_clr" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_2_clr" protect="rw"/>
      <reg name="rxpll_gro_ctrl_0_clr" protect="rw"/>
      <reg name="rxpll_gro_ctrl_1_clr" protect="rw"/>
      <reg name="rxpll_gro_ctrl_2_clr" protect="rw"/>
      <reg name="rxpll_gro_ctrl_3_clr" protect="rw"/>
      <reg name="rxpll_ctrl_0_clr" protect="rw"/>
      <reg name="lna_sel_ctrl_clr" protect="rw"/>
      <reg name="lna_ctrl_clr" protect="rw"/>
      <reg name="lna_pkd_ctrl_clr" protect="rw"/>
      <reg name="rxmixer_ctrl_clr" protect="rw"/>
      <reg name="pga_ctrl_0_clr" protect="rw"/>
      <reg name="pga_ctrl_1_clr" protect="rw"/>
      <reg name="pga_ctrl_2_clr" protect="rw"/>
      <reg name="pga_ctrl_3_clr" protect="rw"/>
      <reg name="rxabb_dccal_ctrl_0_clr" protect="rw"/>
      <reg name="rxabb_dccal_ctrl_1_clr" protect="rw"/>
      <reg name="rxflt_ctrl_0_clr" protect="rw"/>
      <reg name="rxflt_ctrl_1_clr" protect="rw"/>
      <reg name="rxflt_ctrl_2_clr" protect="rw"/>
      <reg name="adc_ldo_ctrl_clr" protect="rw"/>
      <reg name="adc_ctrl_0_clr" protect="rw"/>
      <reg name="adc_ctrl_1_clr" protect="rw"/>
      <reg name="adc_ctrl_2_clr" protect="rw"/>
      <reg name="adc_ctrl_3_clr" protect="rw"/>
      <reg name="adc_rsv_0_clr" protect="rw"/>
      <reg name="pwdadc_ctrl_0_clr" protect="rw"/>
      <reg name="pwdadc_ctrl_1_clr" protect="rw"/>
      <reg name="pwdadc_ctrl_2_clr" protect="rw"/>
      <reg name="pwdadc_ctrl_3_clr" protect="rw"/>
      <reg name="rx_gain_ctrl_clr" protect="rw"/>
      <reg name="rx_reserve1_clr" protect="rw"/>
      <reg name="rx_reserve2_clr" protect="rw"/>
      <reg name="rx_reserve3_clr" protect="rw"/>
      <reg name="txvco_ldo_ctrl_clr" protect="rw"/>
      <reg name="txvco_buf_ldo_ctrl_clr" protect="rw"/>
      <reg name="txvco_ctrl_0_clr" protect="rw"/>
      <reg name="txvco_ctrl_1_clr" protect="rw"/>
      <reg name="txvco_ctrl_2_clr" protect="rw"/>
      <reg name="txpll_ldo_ctrl_0_clr" protect="rw"/>
      <reg name="txpll_ldo_ctrl_1_clr" protect="rw"/>
      <reg name="txpll_ldo_ctrl_2_clr" protect="rw"/>
      <reg name="txpll_gro_ctrl_0_clr" protect="rw"/>
      <reg name="txpll_gro_ctrl_1_clr" protect="rw"/>
      <reg name="txpll_gro_ctrl_2_clr" protect="rw"/>
      <reg name="txpll_gro_ctrl_3_clr" protect="rw"/>
      <reg name="txpll_ctrl_0_clr" protect="rw"/>
      <reg name="txrf_gain_clr" protect="rw"/>
      <reg name="txrf_gain_compensation_clr" protect="rw"/>
      <reg name="txrf_gain_adj_clr" protect="rw"/>
      <reg name="txrf_matchcap_clr" protect="rw"/>
      <reg name="txflt_ctrl_0_clr" protect="rw"/>
      <reg name="txflt_ctrl_1_clr" protect="rw"/>
      <reg name="dac_ctrl_0_clr" protect="rw"/>
      <reg name="dac_ctrl_1_clr" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_0_clr" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_1_clr" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_2_clr" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_3_clr" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_4_clr" protect="rw"/>
      <reg name="rxflt_dccal_clr" protect="rw"/>
      <reg name="tx_reserve_0_clr" protect="rw"/>
      <reg name="tx_reserve_1_clr" protect="rw"/>
      <reg name="pwd_ctrl_0_clr" protect="rw"/>
      <reg name="pwd_ctrl_1_clr" protect="rw"/>
      <reg name="pwd_ctrl_2_clr" protect="rw"/>
      <reg name="ts_ctrl_0_clr" protect="rw"/>
      <reg name="ts_ctrl_1_clr" protect="rw"/>
      <reg name="ts_ctrl_2_clr" protect="rw"/>
      <reg name="cm_reserve1_clr" protect="rw"/>
      <reg name="cm_reserve2_clr" protect="rw"/>
      <reg name="cm_reserve3_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="test_ctrl_0_clr" protect="rw"/>
      <reg name="test_ctrl_1_clr" protect="rw"/>
      <reg name="cal_ctrl_0_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="tsenadc_ctrl_0_clr" protect="rw"/>
      <reg name="tsenadc_ctrl_1_clr" protect="rw"/>
      <reg name="tsenadc_ctrl_2_clr" protect="rw"/>
      <reg name="apc_ctrl_0_clr" protect="rw"/>
      <reg name="apc_ctrl_1_clr" protect="rw"/>
    </module>
    <var name="REG_RF_ANA_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_ANA_CLR_OFFSET" value="0x800"/>
    <instance address="0x50031000" name="RF_ANA" type="RF_ANA"/>
  </archive>
  <archive relative="rf_dig_rtc.xml">
    <module category="System" name="RF_DIG_RTC">
      <reg name="reg_00_reg" protect="rw">
        <comment/>
        <bits access="rw" name="step_offset_update" pos="4" rst="0x0"/>
        <bits access="rw" name="xtal_sel_vref_vdig" pos="3" rst="0x0"/>
        <bits access="rw" name="xtal_sel_vrtc_vdig" pos="2" rst="0x0"/>
        <bits access="rw" name="pu_xtal_reg" pos="1" rst="0x1"/>
        <bits access="rw" name="pu_xtal_ana_sel_src" pos="0" rst="0x0">
          <comment>[0]:pu_xtal from BB;[1]pu xtal from reg</comment>
        </bits>
      </reg>
      <reg name="reg_18_reg" protect="rw">
        <comment/>
        <bits access="rw" name="step_offset_normal" pos="15:8" rst="0x0">
          <comment>32k gen div step_offset Normal mode</comment>
        </bits>
        <bits access="rw" name="step_offset_lp" pos="7:0" rst="0x0">
          <comment>32k gen div step_offset LP mode</comment>
        </bits>
      </reg>
      <reg name="reg_1c_reg" protect="rw">
        <comment/>
        <bits access="rw" name="lp_mode_delay" pos="7:6" rst="0x0">
          <comment>pu_xtal cycle select  2'b00: 4us; 2'b01:8us; 2'b10:12us; 2'b11:20us</comment>
        </bits>
        <bits access="rw" name="lp_mode_en_dr" pos="5" rst="0x0"/>
        <bits access="rw" name="lp_mode_en_reg" pos="4" rst="0x1"/>
        <bits access="rw" name="change_reg_flag_dr" pos="3" rst="0x0"/>
        <bits access="rw" name="change_reg_flag_reg" pos="2" rst="0x1"/>
        <bits access="rw" name="lp_mode_h_dr" pos="1" rst="0x0"/>
        <bits access="rw" name="lp_mode_h_reg" pos="0" rst="0x1"/>
      </reg>
      <reg name="reg_c4_reg" protect="rw">
        <comment/>
        <bits access="rw" name="enable_clk_26m_lp_uart" pos="14" rst="0x1">
          <comment>enable clk 26m lp uart to lps</comment>
        </bits>
        <bits access="rw" name="enable_clk_26m" pos="13" rst="0x1">
          <comment>enable clk 26m lp to analog</comment>
        </bits>
        <bits access="rw" name="xtal26m_plls2_en" pos="12" rst="0x1">
          <comment>BBPLL2 ref clk 26m enable</comment>
        </bits>
        <bits access="rw" name="xtal26m_plls1_en" pos="11" rst="0x1">
          <comment>BBPLL1 ref clk 26m enable</comment>
        </bits>
        <bits access="rw" name="xtal26m_interface_en" pos="10" rst="0x1">
          <comment>clk_26m_interface enable</comment>
        </bits>
        <bits access="rw" name="xtal26m_pllcal_en" pos="9" rst="0x1">
          <comment>RFPLL refcal clk 26m</comment>
        </bits>
        <bits access="rw" name="xtal26m_pwadc_en" pos="8" rst="0x1">
          <comment>pwdadc clk 26m enable</comment>
        </bits>
        <bits access="rw" name="xtal_osc_ibit_l" pos="7:4" rst="0x0">
          <comment>xtal_osc_ibit lp mode</comment>
        </bits>
        <bits access="rw" name="xtal_osc_ibit_n" pos="3:0" rst="0x8">
          <comment>xtal_osc_ibit normal mode</comment>
        </bits>
      </reg>
      <reg name="reg_c8_reg" protect="rw">
        <comment/>
        <bits access="rw" name="xtal_cfix_bit_l" pos="13" rst="0x0">
          <comment>xtal_cfix_bit lp mode</comment>
        </bits>
        <bits access="rw" name="xtal_cfix_bit_n" pos="12" rst="0x0">
          <comment>xtal_cfix_bit normal mode</comment>
        </bits>
        <bits access="rw" name="xtal_fixi_bit_l" pos="11:6" rst="0x1">
          <comment>xtal_fixi_bit lp mode</comment>
        </bits>
        <bits access="rw" name="xtal_fixi_bit_n" pos="5:0" rst="0x20">
          <comment>xtal_fixi_bit normal mode</comment>
        </bits>
      </reg>
      <reg name="reg_cc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="xdrv_aux1_power_bit" pos="10:8" rst="0x4">
          <comment>xdrv aux1 parameter</comment>
        </bits>
        <bits access="rw" name="xtal_reg_bit" pos="7:4" rst="0xc">
          <comment>XTAL parameter</comment>
        </bits>
        <bits access="rw" name="xdrv_reg_bit" pos="3:0" rst="0xc">
          <comment>xdrv parameter</comment>
        </bits>
      </reg>
      <reg name="reg_d0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="xtal_capbank_bit_l" pos="15:8" rst="0x4e">
          <comment>CADC bit lp mode</comment>
        </bits>
        <bits access="rw" name="xtal_capbank_bit_n" pos="7:0" rst="0x4e">
          <comment>CADC bit normal mode</comment>
        </bits>
      </reg>
      <reg name="reg_d4_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rtc_reser_l" pos="15:0" rst="0xff00">
          <comment>RTC</comment>
        </bits>
      </reg>
      <reg name="reg_d8_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rtc_reser_n" pos="15:0" rst="0xff00">
          <comment>RTC</comment>
        </bits>
      </reg>
      <reg name="reg_dc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="psm_sw_cnt_l" pos="15:0" rst="0x7ef4">
          <comment>normal mode switch to PSM counter</comment>
        </bits>
      </reg>
      <reg name="reg_e0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="psm_sw_cnt_h" pos="15:0" rst="0x0">
          <comment>normal mode switch to PSM counter</comment>
        </bits>
      </reg>
      <hole size="1696"/>
      <reg name="reg_00_reg_set" protect="rw"/>
      <reg name="reg_18_reg_set" protect="rw"/>
      <reg name="reg_1c_reg_set" protect="rw"/>
      <reg name="reg_c4_reg_set" protect="rw"/>
      <reg name="reg_c8_reg_set" protect="rw"/>
      <reg name="reg_cc_reg_set" protect="rw"/>
      <reg name="reg_d0_reg_set" protect="rw"/>
      <reg name="reg_d4_reg_set" protect="rw"/>
      <reg name="reg_d8_reg_set" protect="rw"/>
      <reg name="reg_dc_reg_set" protect="rw"/>
      <reg name="reg_e0_reg_set" protect="rw"/>
      <hole size="1696"/>
      <reg name="reg_00_reg_clr" protect="rw"/>
      <reg name="reg_18_reg_clr" protect="rw"/>
      <reg name="reg_1c_reg_clr" protect="rw"/>
      <reg name="reg_c4_reg_clr" protect="rw"/>
      <reg name="reg_c8_reg_clr" protect="rw"/>
      <reg name="reg_cc_reg_clr" protect="rw"/>
      <reg name="reg_d0_reg_clr" protect="rw"/>
      <reg name="reg_d4_reg_clr" protect="rw"/>
      <reg name="reg_d8_reg_clr" protect="rw"/>
      <reg name="reg_dc_reg_clr" protect="rw"/>
      <reg name="reg_e0_reg_clr" protect="rw"/>
    </module>
    <var name="REG_RF_DIG_RTC_SET_OFFSET" value="0x100"/>
    <var name="REG_RF_DIG_RTC_CLR_OFFSET" value="0x200"/>
    <instance address="0x50034000" name="RF_DIG_RTC" type="RF_DIG_RTC"/>
  </archive>
  <archive relative="rf_intf.xml">
    <module category="System" name="RF_INTF">
      <hole size="2048"/>
      <reg name="apb_reg_int0" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int0" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器会产生中断给riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int1" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器会产生中断给riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int2" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器会产生中断给riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int3" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int3" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器会产生中断给riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int4" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int4" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器会产生中断给riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int5" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int5" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器会产生中断给riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int6" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int6" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器会产生中断给riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int7" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int7" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器会产生中断给riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int8" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int8" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器会产生中断给riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int9" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int9" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器会产生中断给riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res10" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res10" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器不会产生中断给riscv，仅用于信息存储</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res11" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res11" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器不会产生中断给riscv，仅用于信息存储</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res12" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res12" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器不会产生中断给riscv，仅用于信息存储</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res13" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res13" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器不会产生中断给riscv，仅用于信息存储</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res14" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res14" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器不会产生中断给riscv，仅用于信息存储</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res15" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res15" pos="15:0" rst="0x0">
          <comment>CP-A5写此寄存器不会产生中断给riscv，仅用于信息存储</comment>
        </bits>
      </reg>
      <hole size="1536"/>
      <reg name="int_clear0" protect="rw">
        <comment/>
        <bits access="rw" name="rg_irq_clr_l" pos="15:0" rst="0x0">
          <comment>riscv中断清除bit，写1清0</comment>
        </bits>
      </reg>
      <reg name="int_clear1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_irq_clr_h" pos="15:0" rst="0x0">
          <comment>riscv中断清除bit，写1清0</comment>
        </bits>
      </reg>
      <reg name="int2tmcu0" protect="rw">
        <comment/>
        <bits access="r" name="irq_out_l" pos="15:0" rst="0x0">
          <comment>riscv中断状态指示bit</comment>
        </bits>
      </reg>
      <reg name="int2tmcu1" protect="rw">
        <comment/>
        <bits access="r" name="irq_out_h" pos="15:0" rst="0x0">
          <comment>riscv中断状态指示bit</comment>
        </bits>
      </reg>
      <reg name="irq_enable0" protect="rw">
        <comment/>
        <bits access="rw" name="rg_irq_en_l" pos="15:0" rst="0xffff">
          <comment>riscv中断使能bit，高有效</comment>
        </bits>
      </reg>
      <reg name="irq_enable1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_irq_en_h" pos="15:0" rst="0xffff">
          <comment>riscv中断使能bit，高有效</comment>
        </bits>
      </reg>
      <reg name="irq_raw0" protect="rw">
        <comment/>
        <bits access="r" name="irq_raw_l" pos="15:0" rst="0x0">
          <comment>riscv原始中断状态指示bit</comment>
        </bits>
      </reg>
      <reg name="irq_raw1" protect="rw">
        <comment/>
        <bits access="r" name="irq_raw_h" pos="15:0" rst="0x0">
          <comment>riscv原始中断状态指示bit</comment>
        </bits>
      </reg>
      <reg name="irq_select" protect="rw">
        <comment/>
        <bits access="rw" name="rg_irq_sel" pos="15:0" rst="0x0">
          <comment>riscv中断源头选择bit，详见riscv中断列表</comment>
        </bits>
      </reg>
      <reg name="afc_freq_bbpll1" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_bbpll11" pos="15:0" rst="0x0">
          <comment>BBPLL1 AFC频偏调整寄存器</comment>
        </bits>
      </reg>
      <reg name="afc_freq_bbpll12" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_bbpll12" pos="15:8" rst="0x0">
          <comment>BBPLL1 AFC频偏调整寄存器</comment>
        </bits>
        <bits access="rw" name="freq_offset_bbpll22" pos="7:0" rst="0x0">
          <comment>BBPLL2 AFC频偏调整寄存器</comment>
        </bits>
      </reg>
      <reg name="afc_freq_bbpll2" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_bbpll21" pos="15:0" rst="0x0">
          <comment>BBPLL2 AFC频偏调整寄存器</comment>
        </bits>
      </reg>
      <reg name="afc_freq_offset_mode" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_enable_bbpll2" pos="3" rst="0x0">
          <comment>BBPLL1 AFC调整使能bit</comment>
        </bits>
        <bits access="rw" name="freq_offset_enable_bbpll1" pos="2" rst="0x0">
          <comment>BBPLL1 AFC调整使能bit</comment>
        </bits>
        <bits access="rw" name="freq_offset_mode_bbpll2" pos="1" rst="0x0">
          <comment>reserved，不使用</comment>
        </bits>
        <bits access="rw" name="freq_offset_mode_bbpll1" pos="0" rst="0x0">
          <comment>reserved，不使用</comment>
        </bits>
      </reg>
      <reg name="freq_offset_ini_bbpll1_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_ini_bbpll11" pos="15:0" rst="0x0">
          <comment>BBPLL1初始频偏</comment>
        </bits>
      </reg>
      <reg name="freq_offset_ini_bbpll1_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_ini_bbpll22" pos="15:8" rst="0x0">
          <comment>BBPLL1初始频偏</comment>
        </bits>
        <bits access="rw" name="freq_offset_ini_bbpll12" pos="7:0" rst="0x0">
          <comment>BBPLL2初始频偏</comment>
        </bits>
      </reg>
      <reg name="freq_offset_ini_bbpll2_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_ini_bbpll21" pos="15:0" rst="0x0">
          <comment>BBPLL2初始频偏</comment>
        </bits>
      </reg>
      <reg name="bbpll1_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="plls1_ldo_out_bb" pos="15:13" rst="0x4">
          <comment>plls1 ldo output. TBD</comment>
        </bits>
        <bits access="rw" name="plls1_cpbias_bit_bb" pos="12:10" rst="0x4">
          <comment>plls1_cpbias_bit_bb</comment>
        </bits>
        <bits access="rw" name="plls1_cpc_ibit_bb" pos="9:7" rst="0x4">
          <comment>plls1_cpc_ibit_bb</comment>
        </bits>
        <bits access="rw" name="plls1_cpr_ibit_bb" pos="6:4" rst="0x4">
          <comment>plls1_cpr_ibit_bb</comment>
        </bits>
        <bits access="rw" name="plls1_notch_en_bb" pos="2" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="plls1_ldo_en_bb" pos="1" rst="0x1">
          <comment>plls1 ldo enable</comment>
        </bits>
        <bits access="rw" name="plls1_ldo_fast_charge_en_bb" pos="0" rst="0x1">
          <comment>plls1 ldo fast charge enable</comment>
        </bits>
      </reg>
      <reg name="bbpll1_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="pll_ldo_fastcharge_cnt_rx" pos="15:14" rst="0x0"/>
        <bits access="rw" name="pll_dly_num_pfd_rx" pos="13:11" rst="0x1"/>
        <bits access="rw" name="pll_lpmode_en_rx" pos="10" rst="0x0"/>
        <bits access="rw" name="pll_pcon_mode_rx" pos="9" rst="0x1"/>
        <bits access="rw" name="pll_refmulti2_en_rx" pos="8" rst="0x1"/>
        <bits access="rw" name="pll_high_test_rx" pos="7" rst="0x0"/>
        <bits access="rw" name="pll_low_test_rx" pos="6" rst="0x0"/>
        <bits access="rw" name="pll_test_en_rx" pos="5" rst="0x0"/>
        <bits access="rw" name="pll_sdm_clk_test_en_rx" pos="4" rst="0x0"/>
        <bits access="rw" name="pll_sdm_clk_sel_rst_rx" pos="3" rst="0x1"/>
        <bits access="rw" name="pll_sdm_clk_sel_nor_rx" pos="2" rst="0x0"/>
        <bits access="rw" name="pu_pll_dr_rx" pos="1" rst="0x0"/>
        <bits access="rw" name="pu_pll_reg_rx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll1_reg3" protect="rw">
        <comment/>
      </reg>
      <reg name="bbpll1_reg5" protect="rw">
        <comment/>
        <bits access="rw" name="pll_sdm_freq_rx1" pos="15:0" rst="0x24ec"/>
      </reg>
      <reg name="bbpll1_reg6" protect="rw">
        <comment/>
        <bits access="rw" name="pll_sdm_freq_rx0" pos="15:0" rst="0x4ec4"/>
      </reg>
      <reg name="bbpll1_reg7" protect="rw">
        <comment/>
        <bits access="rw" name="reser_sdm_rx" pos="15:8" rst="0x2">
          <comment>[8]:clk fbc inv
[9]:ref clk 52m
[10]:freq update</comment>
        </bits>
        <bits access="rw" name="int_dec_sel_rx" pos="7:5" rst="0x3"/>
        <bits access="rw" name="dither_bypass_rx" pos="4" rst="0x1"/>
        <bits access="rw" name="ss_en_rx" pos="3" rst="0x0"/>
        <bits access="rw" name="ss_squre_tri_sel_rx" pos="2" rst="0x0"/>
        <bits access="rw" name="pll_sdm_resetn_dr_rx" pos="1" rst="0x0"/>
        <bits access="rw" name="pll_sdm_resetn_reg_rx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll1_reg8" protect="rw">
        <comment/>
        <bits access="rw" name="pll_ss_devi_ct_rx" pos="15:8" rst="0x0"/>
        <bits access="rw" name="pll_ss_peri_ct_rx" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="bbpll1_reg9" protect="rw">
        <comment/>
      </reg>
      <reg name="bbpll1_rega" protect="rw">
        <comment/>
        <bits access="rw" name="sdm_reset_time_sel_rx" pos="14:13" rst="0x1"/>
        <bits access="rw" name="sdmclk_sel_time_sel_rx" pos="12:11" rst="0x1"/>
        <bits access="rw" name="pll_clk_dfe_sel_reg_rx" pos="10:9" rst="0x3"/>
        <bits access="rw" name="pll_clk_adc_sel_reg_rx" pos="8:7" rst="0x1"/>
        <bits access="rw" name="pll_clk_adc_en_reg_rx" pos="6" rst="0x0"/>
        <bits access="rw" name="pll_clk_adc_dfe_en_reg_rx" pos="5" rst="0x0"/>
        <bits access="rw" name="pll_clkout_en_reg_rx" pos="4:1" rst="0xf"/>
        <bits access="rw" name="clk_gen_en_reg_rx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll1_regb" protect="rw">
        <comment/>
        <bits access="r" name="pu_pll_rx" pos="15" rst="0x0"/>
        <bits access="r" name="pll_lock_rx" pos="14" rst="0x0"/>
        <bits access="r" name="rxpll_sx_cal_state" pos="13:11" rst="0x0">
          <comment>RXPLL cal state, ECO</comment>
        </bits>
        <bits access="r" name="pll_lock_steady_rx" pos="10" rst="0x0"/>
      </reg>
      <reg name="bbpll1_regd" protect="rw">
        <comment/>
        <bits access="rw" name="plls1_ldo_cp_tune_bb" pos="7:6" rst="0x2"/>
        <bits access="rw" name="resetn_spll_rx" pos="5" rst="0x1"/>
        <bits access="rw" name="vco_reset_dis_rx" pos="4" rst="0x1"/>
        <bits access="rw" name="pll_clkout_en_counter_sel_rx" pos="3:2" rst="0x1"/>
        <bits access="rw" name="lock_counter_sel_rx" pos="1:0" rst="0x1"/>
      </reg>
      <reg name="bbpll2_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="plls2_ldo_out_bb" pos="15:13" rst="0x4">
          <comment>plls2 ldo output. TBD</comment>
        </bits>
        <bits access="rw" name="plls2_cpbias_bit_bb" pos="12:10" rst="0x4">
          <comment>plls2_cpbias_bit_bb</comment>
        </bits>
        <bits access="rw" name="plls2_cpc_ibit_bb" pos="9:7" rst="0x4">
          <comment>plls2_cpc_ibit_bb</comment>
        </bits>
        <bits access="rw" name="plls2_cpr_ibit_bb" pos="6:4" rst="0x4">
          <comment>plls2_cpr_ibit_bb</comment>
        </bits>
        <bits access="rw" name="plls2_notch_en_bb" pos="2" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="plls2_ldo_en_bb" pos="1" rst="0x1">
          <comment>plls2 ldo enable</comment>
        </bits>
        <bits access="rw" name="plls2_ldo_fast_charge_en_bb" pos="0" rst="0x1">
          <comment>plls2 ldo fast charge enable</comment>
        </bits>
      </reg>
      <reg name="bbpll2_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="pll_ldo_fastcharge_cnt_tx" pos="15:14" rst="0x0"/>
        <bits access="rw" name="pll_dly_num_pfd_tx" pos="13:11" rst="0x1"/>
        <bits access="rw" name="pll_lpmode_en_tx" pos="10" rst="0x0"/>
        <bits access="rw" name="pll_pcon_mode_tx" pos="9" rst="0x1"/>
        <bits access="rw" name="pll_refmulti2_en_tx" pos="8" rst="0x1"/>
        <bits access="rw" name="pll_high_test_tx" pos="7" rst="0x0"/>
        <bits access="rw" name="pll_low_test_tx" pos="6" rst="0x0"/>
        <bits access="rw" name="pll_test_en_tx" pos="5" rst="0x0"/>
        <bits access="rw" name="pll_sdm_clk_test_en_tx" pos="4" rst="0x0"/>
        <bits access="rw" name="pll_sdm_clk_sel_rst_tx" pos="3" rst="0x1"/>
        <bits access="rw" name="pll_sdm_clk_sel_nor_tx" pos="2" rst="0x0"/>
        <bits access="rw" name="pu_pll_dr_tx" pos="1" rst="0x0"/>
        <bits access="rw" name="pu_pll_reg_tx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll2_reg3" protect="rw">
        <comment/>
      </reg>
      <reg name="bbpll2_reg5" protect="rw">
        <comment/>
        <bits access="rw" name="pll_sdm_freq_tx1" pos="15:0" rst="0x25cf"/>
      </reg>
      <reg name="bbpll2_reg6" protect="rw">
        <comment/>
        <bits access="rw" name="pll_sdm_freq_tx0" pos="15:0" rst="0x29bf"/>
      </reg>
      <reg name="bbpll2_reg7" protect="rw">
        <comment/>
        <bits access="rw" name="reser_sdm_tx" pos="15:8" rst="0x2">
          <comment>[8]:clk fbc inv
[9]:ref clk 52m
[10]:freq update</comment>
        </bits>
        <bits access="rw" name="int_dec_sel_tx" pos="7:5" rst="0x3"/>
        <bits access="rw" name="dither_bypass_tx" pos="4" rst="0x1"/>
        <bits access="rw" name="ss_en_tx" pos="3" rst="0x0"/>
        <bits access="rw" name="ss_squre_tri_sel_tx" pos="2" rst="0x0"/>
        <bits access="rw" name="pll_sdm_resetn_dr_tx" pos="1" rst="0x0"/>
        <bits access="rw" name="pll_sdm_resetn_reg_tx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll2_reg8" protect="rw">
        <comment/>
        <bits access="rw" name="pll_ss_devi_ct_tx" pos="15:8" rst="0x0"/>
        <bits access="rw" name="pll_ss_peri_ct_tx" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="bbpll2_reg9" protect="rw">
        <comment/>
      </reg>
      <reg name="bbpll2_rega" protect="rw">
        <comment/>
        <bits access="rw" name="sdm_reset_time_sel_tx" pos="14:13" rst="0x1"/>
        <bits access="rw" name="sdmclk_sel_time_sel_tx" pos="12:11" rst="0x1"/>
        <bits access="rw" name="pll_clk_adc_sel_reg_tx" pos="8:7" rst="0x2"/>
        <bits access="rw" name="pll_clk_adc_en_reg_tx" pos="6" rst="0x0"/>
        <bits access="rw" name="pll_clk_adc_dfe_en_reg_tx" pos="5" rst="0x0"/>
        <bits access="rw" name="pll_clkout_en_reg_tx" pos="4:1" rst="0xf"/>
        <bits access="rw" name="clk_gen_en_reg_tx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll2_regb" protect="rw">
        <comment/>
        <bits access="r" name="pu_pll_tx" pos="15" rst="0x0"/>
        <bits access="r" name="pll_lock_tx" pos="14" rst="0x0"/>
        <bits access="r" name="pll_sdm_resetn_tx" pos="13" rst="0x0"/>
        <bits access="r" name="pll_sdm_clk_sel_tx" pos="12" rst="0x0"/>
        <bits access="r" name="pll_clk_ready_tx" pos="11" rst="0x0"/>
        <bits access="r" name="pll_lock_steady_tx" pos="10" rst="0x0"/>
      </reg>
      <reg name="bbpll2_regd" protect="rw">
        <comment/>
        <bits access="rw" name="plls2_ldo_cp_tune_bb" pos="7:6" rst="0x2"/>
        <bits access="rw" name="resetn_spll_tx" pos="5" rst="0x1"/>
        <bits access="rw" name="vco_reset_dis_tx" pos="4" rst="0x1"/>
        <bits access="rw" name="pll_clkout_en_counter_sel_tx" pos="3:2" rst="0x1"/>
        <bits access="rw" name="lock_counter_sel_tx" pos="1:0" rst="0x1"/>
      </reg>
      <reg name="clk_gen_reg0" protect="rw">
        <comment/>
        <bits access="rw" name="rg_freq_clk_div_3" pos="11:9" rst="0x4">
          <comment>送给模拟的分配时钟系数</comment>
        </bits>
        <bits access="rw" name="rg_freq_clk_div_2" pos="8:6" rst="0x4">
          <comment>送给模拟的分配时钟系数</comment>
        </bits>
        <bits access="rw" name="rg_freq_clk_div_1" pos="5:3" rst="0x4">
          <comment>送给模拟的分配时钟系数</comment>
        </bits>
        <bits access="rw" name="rg_freq_clk_div_0" pos="2:0" rst="0x4">
          <comment>送给模拟的分配时钟系数</comment>
        </bits>
      </reg>
      <reg name="clk_gen_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_inv_clk_div" pos="7:4" rst="0x0">
          <comment>送给模拟的分配时钟反向</comment>
        </bits>
        <bits access="rw" name="rg_enable_clk_div" pos="3:0" rst="0x0">
          <comment>送给模拟的分配时钟使能bit</comment>
        </bits>
      </reg>
      <reg name="txpll_freq_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txpll_freq_m" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_m" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txpll_freq_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_h" pos="2:0" rst="0x0"/>
      </reg>
      <reg name="txpll_sdm_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_sdm_soft_rst_n" pos="6" rst="0x0">
          <comment>sdm rstn</comment>
        </bits>
        <bits access="rw" name="rg_txpll_freq_offset_enable" pos="5" rst="0x0">
          <comment>sdm input divN offset en</comment>
        </bits>
        <bits access="rw" name="rg_txpll_dither_bypass_reg" pos="4" rst="0x1">
          <comment>sdm dither for frac spur</comment>
        </bits>
        <bits access="rw" name="rg_txpll_fbc_inv_reg" pos="3" rst="0x0">
          <comment>sdm clk inv</comment>
        </bits>
        <bits access="rw" name="rg_txpll_int_dec_sel_reg" pos="2:0" rst="0x3">
          <comment>0 sel int, 1sel 1bit frac, 2sel 2bit frac. 3sel 3bit frac</comment>
        </bits>
      </reg>
      <reg name="txpll_freq_offset_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_offset_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txpll_freq_offset_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_offset_h" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="txpll_freq_offset_ini_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_offset_ini_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txpll_freq_offset_ini_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_offset_ini_h" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="txpll_sx_ctrl1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_afc_delay_vco" pos="15:14" rst="0x0">
          <comment>afc for vco wait time control</comment>
        </bits>
        <bits access="rw" name="rg_txpll_afc_bit_num" pos="13:12" rst="0x3">
          <comment>0 for 8bit cband calibration, 3 for 11bit cband calibration</comment>
        </bits>
        <bits access="rw" name="rg_txpll_afc_count_time" pos="11:10" rst="0x0">
          <comment>afccounter counttime control:
0--2^5/26M   1--2^6/26M
2--2^7/26M   3--2^8/26M</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_afc_bypass" pos="9" rst="0x0">
          <comment>a-afc bypass</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_cal_resetn" pos="8" rst="0x0">
          <comment>cal top rstn</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_aac_bypass" pos="7" rst="0x0">
          <comment>aac bypass</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_aac_pkd_delay" pos="6:5" rst="0x0">
          <comment>vco pkd wait time control:
0--500ns  1--750ns  2--1us  3--1.25us</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_aac_adder_step_sel" pos="4:3" rst="0x0">
          <comment>aac cal done vcobias adder control:
0--1  1--2  2--3  3--4</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_aac_cal_init_delay" pos="2:0" rst="0x1">
          <comment>aac cal init delay control,1~1us</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_ctrl2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_rf_sx_agc_resetn" pos="8" rst="0x0">
          <comment>pll agc rstn</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_agc_en" pos="7" rst="0x0">
          <comment>pll agc en</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_agc_cnt_time" pos="6:5" rst="0x0">
          <comment>pll agc counttime control</comment>
        </bits>
        <bits access="rw" name="rg_txpll_afc_sdm_en" pos="4" rst="0x1"/>
        <bits access="rw" name="rg_txpll_afc_delay_charging" pos="3:1" rst="0x2">
          <comment>afc charging delay control, 0~0, 7~3.5us</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_afc_startl2h" pos="0" rst="0x0">
          <comment>vco calibration start signal</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_ctrl3" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_sx_caldone_lock_en" pos="12" rst="0x0"/>
        <bits access="rw" name="rg_txpll_sx_lock_dly" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txpll_sx_ctrl4" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_afc_cal_freq_in_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txpll_sx_ctrl5" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_afc_cal_freq_in_h" pos="0" rst="0x0"/>
      </reg>
      <reg name="txpll_sx_ctrl6" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_afc_sel_dpll" pos="12" rst="0x0">
          <comment>0 sel a-afc cbank, 1 sel d-afc cbank</comment>
        </bits>
        <bits access="rw" name="rg_txpll_afc_sel_reg" pos="11" rst="0x0">
          <comment>0 for auto afc; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_afc_vco_cap" pos="10:0" rst="0x400">
          <comment>vco cbank spi</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_ctrl7" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_vco_bias_sel_reg" pos="12" rst="0x0">
          <comment>0 for auto aac; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_vco_bias" pos="11:8" rst="0xf">
          <comment>vco bias spi</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_open_en_sel_reg" pos="7" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_open_en" pos="6" rst="0x0">
          <comment>pll loop open en</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_cnt_en_sel_reg" pos="5" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_cnt_en" pos="4" rst="0x0">
          <comment>afccounter enable control, high active</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_cal_en_sel_reg" pos="3" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_cal_en" pos="2" rst="0x0">
          <comment>afccounter rst control, high active</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pu_vco_pkd_sel_reg" pos="1" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pu_vco_pkd" pos="0" rst="0x0">
          <comment>vco peakdetector en</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat1" protect="rw">
        <comment/>
        <bits access="r" name="txpll_afc_start_ack" pos="10">
          <comment>a-afc start signal</comment>
        </bits>
        <bits access="r" name="txpll_aac_start_ack" pos="9">
          <comment>aac start signal</comment>
        </bits>
        <bits access="r" name="txpll_rf_sx_aac_state" pos="8:7">
          <comment>aac state</comment>
        </bits>
        <bits access="r" name="txpll_rf_sx_cal_state" pos="6:4">
          <comment>cal top state</comment>
        </bits>
        <bits access="r" name="txpll_cal_done_agc" pos="3">
          <comment>agc cal done signal</comment>
        </bits>
        <bits access="r" name="txpll_cal_done_afc" pos="2">
          <comment>a-afc cal done signal</comment>
        </bits>
        <bits access="r" name="txpll_cal_done_aac" pos="1">
          <comment>aac cal done signal</comment>
        </bits>
        <bits access="r" name="txpll_cal_done_top" pos="0">
          <comment>cal top cal done signal, same as afc cal done</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat2" protect="rw">
        <comment/>
        <bits access="r" name="txpll_afc_err_min" pos="15:0">
          <comment>a-afc err min, for debug</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat3" protect="rw">
        <comment/>
        <bits access="r" name="da_afc_vco_cap_tx" pos="10:0">
          <comment>vco cbank</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat4" protect="rw">
        <comment/>
        <bits access="r" name="da_rf_pll_open_en_tx" pos="7" rst="0x0">
          <comment>pll loop en</comment>
        </bits>
        <bits access="r" name="da_rf_pll_cnt_en_tx" pos="6" rst="0x0">
          <comment>afccount en</comment>
        </bits>
        <bits access="r" name="da_rf_pll_cal_en_tx" pos="5" rst="0x0">
          <comment>afccount rst</comment>
        </bits>
        <bits access="r" name="da_rf_pu_vco_pkd_tx" pos="4" rst="0x0">
          <comment>vco pkd en</comment>
        </bits>
        <bits access="r" name="da_rf_vco_bias_tx" pos="3:0" rst="0x0">
          <comment>vco bias</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat5" protect="rw">
        <comment/>
        <bits access="r" name="ad_rf_pll_cnt_tx" pos="15:0">
          <comment>afccount output fot a-afc &amp; agc</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat6" protect="rw">
        <comment/>
        <bits access="r" name="ad_rf_vco_pkd_out_tx" pos="0">
          <comment>vco pkd output fot aac</comment>
        </bits>
      </reg>
      <reg name="rxpll_freq_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_freq_m" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_m" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_freq_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_h" pos="2:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_sdm_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_sdm_soft_rst_n" pos="6" rst="0x0">
          <comment>sdm rstn</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_freq_offset_enable" pos="5" rst="0x0">
          <comment>sdm input divN offset en</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_dither_bypass_reg" pos="4" rst="0x1">
          <comment>sdm dither for frac spur</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_fbc_inv_reg" pos="3" rst="0x0">
          <comment>sdm clk inv</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_int_dec_sel_reg" pos="2:0" rst="0x3">
          <comment>0 sel int, 1sel 1bit frac, 2sel 2bit frac. 3sel 3bit frac</comment>
        </bits>
      </reg>
      <reg name="rxpll_freq_offset_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_offset_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_freq_offset_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_offset_h" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_freq_offset_ini_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_offset_ini_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_freq_offset_ini_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_offset_ini_h" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_sx_ctrl1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_afc_delay_vco" pos="15:14" rst="0x0">
          <comment>afc for vco wait time control</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_afc_bit_num" pos="13:12" rst="0x3">
          <comment>0 for 8bit cband calibration, 3 for 11bit cband calibration</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_afc_count_time" pos="11:10" rst="0x0">
          <comment>afccounter counttime control:
0--2^5/26M   1--2^6/26M
2--2^7/26M   3--2^8/26M</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_afc_bypass" pos="9" rst="0x0">
          <comment>a-afc bypass</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_cal_resetn" pos="8" rst="0x0">
          <comment>cal top rstn</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_aac_bypass" pos="7" rst="0x0">
          <comment>aac bypass</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_aac_pkd_delay" pos="6:5" rst="0x0">
          <comment>vco pkd wait time control:
0--500ns  1--750ns  2--1us  3--1.25us</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_aac_adder_step_sel" pos="4:3" rst="0x0">
          <comment>aac cal done vcobias adder control:
0--1  1--2  2--3  3--4</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_aac_cal_init_delay" pos="2:0" rst="0x1">
          <comment>aac cal init delay control:</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_ctrl2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_rf_sx_agc_resetn" pos="8" rst="0x0">
          <comment>pll agc rstn</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_agc_en" pos="7" rst="0x0">
          <comment>pll agc en</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_agc_cnt_time" pos="6:5" rst="0x0">
          <comment>pll agc counttime control</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_afc_sdm_en" pos="4" rst="0x0"/>
        <bits access="rw" name="rg_rxpll_afc_delay_charging" pos="3:1" rst="0x2">
          <comment>afc charging delay control, 0~0, 7~3.5us</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_afc_startl2h" pos="0" rst="0x0">
          <comment>vco calibration start signal</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_ctrl3" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_sx_caldone_lock_en" pos="12" rst="0x0"/>
        <bits access="rw" name="rg_rxpll_sx_lock_dly" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_sx_ctrl4" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_afc_cal_freq_in_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_sx_ctrl5" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_afc_cal_freq_in_h" pos="0" rst="0x0"/>
      </reg>
      <reg name="rxpll_sx_ctrl6" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_afc_sel_dpll" pos="12" rst="0x0">
          <comment>0 sel a-afc cbank, 1 sel d-afc cbank</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_afc_sel_reg" pos="11" rst="0x0">
          <comment>0 for auto afc; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_afc_vco_cap" pos="10:0" rst="0x400">
          <comment>vco cbank spi</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_ctrl7" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_vco_bias_sel_reg" pos="12" rst="0x0">
          <comment>0 for auto aac; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_vco_bias" pos="11:8" rst="0xf">
          <comment>vco bias spi</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_open_en_sel_reg" pos="7" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_open_en" pos="6" rst="0x0">
          <comment>pll loop open en</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_cnt_en_sel_reg" pos="5" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_cnt_en" pos="4" rst="0x0">
          <comment>afccounter enable control, high active</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_cal_en_sel_reg" pos="3" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_cal_en" pos="2" rst="0x0">
          <comment>afccounter rst control, high active</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pu_vco_pkd_sel_reg" pos="1" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pu_vco_pkd" pos="0" rst="0x0">
          <comment>vco peakdetector en</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_stat1" protect="rw">
        <comment/>
      </reg>
      <reg name="rxpll_sx_stat2" protect="rw">
        <comment/>
      </reg>
      <reg name="rxpll_sx_stat3" protect="rw">
        <comment/>
        <bits access="r" name="da_afc_vco_cap_rx" pos="10:0">
          <comment>vco cbank</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_stat4" protect="rw">
        <comment/>
        <bits access="r" name="da_rf_pll_open_en_rx" pos="7" rst="0x0">
          <comment>pll loop en</comment>
        </bits>
        <bits access="r" name="da_rf_pll_cnt_en_rx" pos="6" rst="0x0">
          <comment>afccount en</comment>
        </bits>
        <bits access="r" name="da_rf_pll_cal_en_rx" pos="5" rst="0x0">
          <comment>afccount rst</comment>
        </bits>
        <bits access="r" name="da_rf_pu_vco_pkd_rx" pos="4" rst="0x0">
          <comment>vco pkd en</comment>
        </bits>
        <bits access="r" name="da_rf_vco_bias_rx" pos="3:0" rst="0x0">
          <comment>vco bias</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_stat5" protect="rw">
        <comment/>
        <bits access="r" name="ad_rf_pll_cnt_rx" pos="15:0">
          <comment>afccount output fot a-afc &amp; agc</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_stat6" protect="rw">
        <comment/>
        <bits access="r" name="ad_rf_vco_pkd_out_rx" pos="0">
          <comment>vco pkd output fot aac</comment>
        </bits>
      </reg>
      <reg name="peak_det_clr" protect="rw">
        <comment/>
        <bits access="rw" name="rg_peak_det_auto_ctrl_en" pos="11:8" rst="0x0">
          <comment>peak detector功能硬件检测到adc_en为1后自动打开，不需要配置软件使能bit</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_clr" pos="7:4" rst="0x0">
          <comment>peak detector中断清除</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_en" pos="3:0" rst="0x0">
          <comment>peak detector软件使能bit</comment>
        </bits>
      </reg>
      <reg name="peak_det_sta" protect="rw">
        <comment/>
        <bits access="r" name="peak_det_int" pos="11:8">
          <comment>peak detector中断状态bit</comment>
        </bits>
        <bits access="r" name="peak_det_flag_sync" pos="7:4">
          <comment>peak detector信号时钟同步后的状态</comment>
        </bits>
        <bits access="r" name="ad_peak_det_flag" pos="3:0">
          <comment>peak detector信号原始输入状态</comment>
        </bits>
      </reg>
      <reg name="peak_det_num1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_peak_det_num1" pos="15:8" rst="0x80">
          <comment>peak detector中断循环检测周期</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_num0" pos="7:0" rst="0x80">
          <comment>peak detector中断循环检测周期</comment>
        </bits>
      </reg>
      <reg name="peak_det_num2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_peak_det_num3" pos="15:8" rst="0x80">
          <comment>peak detector中断循环检测周期</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_num2" pos="7:0" rst="0x80">
          <comment>peak detector中断循环检测周期</comment>
        </bits>
      </reg>
      <reg name="peak_det_trig_num1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_peak_det_trig_num1" pos="15:8" rst="0x7f">
          <comment>peak detector中断检测触发周期</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_trig_num0" pos="7:0" rst="0x7f">
          <comment>peak detector中断检测触发周期</comment>
        </bits>
      </reg>
      <reg name="peak_det_trig_num2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_peak_det_trig_num3" pos="15:8" rst="0x7f">
          <comment>peak detector中断检测触发周期</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_trig_num2" pos="7:0" rst="0x7f">
          <comment>peak detector中断检测触发周期</comment>
        </bits>
      </reg>
      <hole size="5376"/>
      <reg name="int_clear0_set" protect="rw"/>
      <reg name="int_clear1_set" protect="rw"/>
      <hole size="64"/>
      <reg name="irq_enable0_set" protect="rw"/>
      <reg name="irq_enable1_set" protect="rw"/>
      <hole size="64"/>
      <reg name="irq_select_set" protect="rw"/>
      <hole size="96"/>
      <reg name="afc_freq_offset_mode_set" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll1_reg1_set" protect="rw"/>
      <reg name="bbpll1_reg2_set" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll1_reg7_set" protect="rw"/>
      <hole size="64"/>
      <reg name="bbpll1_rega_set" protect="rw"/>
      <hole size="32"/>
      <reg name="bbpll1_regd_set" protect="rw"/>
      <reg name="bbpll2_reg1_set" protect="rw"/>
      <reg name="bbpll2_reg2_set" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll2_reg7_set" protect="rw"/>
      <hole size="64"/>
      <reg name="bbpll2_rega_set" protect="rw"/>
      <hole size="32"/>
      <reg name="bbpll2_regd_set" protect="rw"/>
      <reg name="clk_gen_reg0_set" protect="rw"/>
      <reg name="clk_gen_reg1_set" protect="rw"/>
      <hole size="96"/>
      <reg name="txpll_sdm_ctrl_set" protect="rw"/>
      <hole size="128"/>
      <reg name="txpll_sx_ctrl1_set" protect="rw"/>
      <reg name="txpll_sx_ctrl2_set" protect="rw"/>
      <hole size="128"/>
      <reg name="txpll_sx_ctrl7_set" protect="rw"/>
      <hole size="288"/>
      <reg name="rxpll_sdm_ctrl_set" protect="rw"/>
      <hole size="128"/>
      <reg name="rxpll_sx_ctrl1_set" protect="rw"/>
      <reg name="rxpll_sx_ctrl2_set" protect="rw"/>
      <hole size="128"/>
      <reg name="rxpll_sx_ctrl7_set" protect="rw"/>
      <hole size="192"/>
      <reg name="peak_det_clr_set" protect="rw"/>
      <hole size="5536"/>
      <reg name="int_clear0_clr" protect="rw"/>
      <reg name="int_clear1_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="irq_enable0_clr" protect="rw"/>
      <reg name="irq_enable1_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="irq_select_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="afc_freq_offset_mode_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll1_reg1_clr" protect="rw"/>
      <reg name="bbpll1_reg2_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll1_reg7_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="bbpll1_rega_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="bbpll1_regd_clr" protect="rw"/>
      <reg name="bbpll2_reg1_clr" protect="rw"/>
      <reg name="bbpll2_reg2_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll2_reg7_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="bbpll2_rega_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="bbpll2_regd_clr" protect="rw"/>
      <reg name="clk_gen_reg0_clr" protect="rw"/>
      <reg name="clk_gen_reg1_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="txpll_sdm_ctrl_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="txpll_sx_ctrl1_clr" protect="rw"/>
      <reg name="txpll_sx_ctrl2_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="txpll_sx_ctrl7_clr" protect="rw"/>
      <hole size="288"/>
      <reg name="rxpll_sdm_ctrl_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="rxpll_sx_ctrl1_clr" protect="rw"/>
      <reg name="rxpll_sx_ctrl2_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="rxpll_sx_ctrl7_clr" protect="rw"/>
      <hole size="192"/>
      <reg name="peak_det_clr_clr" protect="rw"/>
    </module>
    <var name="REG_RF_INTF_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_INTF_CLR_OFFSET" value="0x800"/>
    <instance address="0x50030000" name="RF_INTF" type="RF_INTF"/>
  </archive>
  <archive relative="rffe.xml">
    <module category="System" name="RFFE">
      <reg name="cmd_mipi0" protect="rw">
        <comment/>
        <bits access="rw" name="cmd_mipi_low" pos="15:0" rst="0x0">
          <comment>cmd_mipi_sr[15:0]</comment>
        </bits>
      </reg>
      <reg name="cmd_mipi1" protect="rw">
        <comment/>
        <bits access="rw" name="cmd_mipi_high" pos="15:0" rst="0x0">
          <comment>cmd_mipi_sr[31:16],when write this reg,start the RFFE</comment>
        </bits>
      </reg>
      <reg name="data_mipi0" protect="rw">
        <comment/>
        <bits access="rw" name="data_mipi_low" pos="15:0" rst="0x0">
          <comment>data_mipi_sr[15:0]</comment>
        </bits>
      </reg>
      <reg name="data_mipi1" protect="rw">
        <comment/>
        <bits access="rw" name="data_mipi_high" pos="15:0" rst="0x0">
          <comment>data_mipi_sr[31:16]</comment>
        </bits>
      </reg>
      <reg name="data_out0" protect="rw">
        <comment/>
        <bits access="rw" name="data_out_low" pos="15:0" rst="0x0">
          <comment>data_out_mipi[15:0]</comment>
        </bits>
      </reg>
      <reg name="data_out1" protect="rw">
        <comment/>
        <bits access="rw" name="data_out_high" pos="15:0" rst="0x0">
          <comment>data_out_mipi[31:16]</comment>
        </bits>
      </reg>
      <reg name="data_valid" protect="rw">
        <comment/>
        <bits access="r" name="data_valid" pos="3:0" rst="0x0">
          <comment>data_valid_byte[3:0]</comment>
        </bits>
      </reg>
      <reg name="mipi_status" protect="rw">
        <comment/>
        <bits access="r" name="master_busy_mipi_dly" pos="1" rst="0x0">
          <comment>master_busy_mipi_dly</comment>
        </bits>
        <bits access="r" name="cmd_done_status" pos="0" rst="0x0">
          <comment>cmd_done_status</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x50038000" name="RFFE" type="RFFE"/>
  </archive>
  <archive relative="rf_rxdlpf.xml">
    <module category="System" name="RF_RXDLPF">
      <reg name="dlpf_ctrl_reg" protect="rw">
        <comment/>
        <bits access="rw" name="notch_en_sel_status3" pos="15" rst="0x0">
          <comment>DLPF notch bypass status3
1: notch bypass when the value of dlpf_det_status is less than 3</comment>
        </bits>
        <bits access="rw" name="sdm_bypass" pos="14" rst="0x0">
          <comment>DLPF sdm bypass</comment>
        </bits>
        <bits access="rw" name="notch_en_sel_status2" pos="13" rst="0x0">
          <comment>DLPF notch bypass status2
1: notch bypass when the value of dlpf_det_status is less than 2</comment>
        </bits>
        <bits access="rw" name="tdc_cal_clk_inv" pos="12" rst="0x0">
          <comment>gro mode tdc cal clk out inverse</comment>
        </bits>
        <bits access="rw" name="pha_err_clk_inv" pos="11" rst="0x0">
          <comment>gro mode phase err clk out inverse</comment>
        </bits>
        <bits access="rw" name="tdc_dout_clk_inv" pos="10" rst="0x0">
          <comment>gro mode tdc cal reg clk inverse</comment>
        </bits>
        <bits access="rw" name="pha_dout_clk_inv" pos="9" rst="0x0">
          <comment>gro mode phase err reg clk inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_mdll_num" pos="8:6" rst="0x5">
          <comment>DLPF MDLL mode
000: 26x2MHz
001: 26x3MHz
010: 26x4MHz
011: 26x5MHz
100: 26x6MHz
101: 26x7MHz
110: 26x8MHz
111: 26x9MHz</comment>
        </bits>
        <bits access="rw" name="dlpf_notch_bypass" pos="5" rst="0x0">
          <comment>DLPF notch bypass</comment>
        </bits>
        <bits access="rw" name="dlpf_clk_inv1_reg" pos="4" rst="0x0">
          <comment>DLPF output clock inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_clk_inv0_reg" pos="3" rst="0x0">
          <comment>DLPF input clock inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_lock_mode" pos="2" rst="0x1">
          <comment>DLPF lock mode</comment>
        </bits>
        <bits access="rw" name="dlpf_en" pos="1" rst="0x0">
          <comment>enable DLPF</comment>
        </bits>
      </reg>
      <reg name="dlpf_dr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_dr_mode" pos="14" rst="0x0">
          <comment>DLPF output direct control</comment>
        </bits>
        <bits access="rw" name="dlpf_dr_value" pos="13:0" rst="0x2000">
          <comment>DLPF output direct value</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_pha_offset_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_pha_offset" pos="15:0" rst="0xc8">
          <comment>DLPF afc phase offset</comment>
        </bits>
      </reg>
      <reg name="dlpf_kdco_pha_offset_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_kdco_pha_offset" pos="15:0" rst="0xc8">
          <comment>DLPF kdco phase offset</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_afc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_afc" pos="12:0" rst="0xa8">
          <comment>DLPF gain kp afc</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_afc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_afc" pos="15:0" rst="0x3f">
          <comment>DLPF gain ki afc</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_2m_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_2m" pos="12:0" rst="0x698">
          <comment>DLPF gain kp 2m</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_2m_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_2m" pos="15:0" rst="0x27d">
          <comment>DLPF gain ki 2m</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_200k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_200k" pos="12:0" rst="0xa8">
          <comment>DLPF gain kp 200k</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_200k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_200k" pos="15:0" rst="0x3f">
          <comment>DLPF gain ki 200k</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_gain0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir0_gain0" pos="15:0" rst="0xf8dd">
          <comment>DLPF IIR0 gain0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_gain1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir0_gain1" pos="15:0" rst="0x391">
          <comment>DLPF IIR0 gain1[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_gain0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain0" pos="15:0" rst="0x8522">
          <comment>DLPF IIR1 gain0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_gain1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain1" pos="15:0" rst="0x3d6e">
          <comment>DLPF IIR1 gain1[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir_gain_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain1_msb" pos="3" rst="0x0">
          <comment>DLPF IIR1 gain1[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir1_gain0_msb" pos="2" rst="0x0">
          <comment>DLPF IIR1 gain0[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir0_gain1_msb" pos="1" rst="0x0">
          <comment>DLPF IIR0 gain1[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir0_gain0_msb" pos="0" rst="0x0">
          <comment>DLPF IIR0 gain0[16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_diff_sel_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_diff_sel" pos="2:0" rst="0x2">
          <comment>dlpf_diff_sel value is set to reserved value</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>afc_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_diff_thr_msb" pos="15:0" rst="0x8">
          <comment>afc_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_cnt_thr" pos="15:0" rst="0x64">
          <comment>minimum value of afc_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>lock_2m_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_diff_thr_msb" pos="15:0" rst="0x8">
          <comment>lock_2m_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_cnt_thr" pos="15:0" rst="0xc8">
          <comment>minimum value of lock_2m_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>lock_200k_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_diff_thr_msb" pos="15:0" rst="0x2">
          <comment>lock_200k_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_cnt_thr" pos="15:0" rst="0x258">
          <comment>minimum value of lock_200k_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer0_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer0_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer0_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer0_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer0_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer0_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer1_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer1_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer1_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer1_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer1_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer1_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer2_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer2_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer2_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer2_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer2_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer2_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_capture_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_capture_en" pos="0" rst="0x0">
          <comment>DLPF capture enable to dump internal values</comment>
        </bits>
      </reg>
      <reg name="dlpf_status0_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_afc_code" pos="12:2" rst="0x400">
          <comment>real time afc_code</comment>
        </bits>
        <bits access="r" name="dlpf_det_status" pos="1:0" rst="0x0">
          <comment>DLPF detect status</comment>
        </bits>
      </reg>
      <reg name="dlpf_status1_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_kdco_code" pos="13:0" rst="0x2000">
          <comment>read time kdco_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_code_status" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_afc_code_reg" pos="10:0" rst="0x0">
          <comment>captured afc_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_kdco_code_status" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_kdco_code_reg" pos="13:0" rst="0x0">
          <comment>captured kdco_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_tdc_code_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_tdc_code" pos="15:0" rst="0x0">
          <comment>tdc_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_l_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_l" pos="15:0" rst="0x0">
          <comment>dlpf_sum0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_m_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_m" pos="15:0" rst="0x0">
          <comment>dlpf_sum0[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_h_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_h" pos="6:0" rst="0x0">
          <comment>dlpf_sum0[38:32]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_data_lsb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir0_data_lsb" pos="15:0" rst="0x0">
          <comment>iir0_data[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_data_msb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir0_data_msb" pos="15:0" rst="0x0">
          <comment>iir0_data[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_data_lsb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir1_data_lsb" pos="15:0" rst="0x0">
          <comment>iir1_data[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_data_msb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir1_data_msb" pos="15:0" rst="0x0">
          <comment>iir1_data[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_ctrl_bit_reg" protect="rw">
        <comment/>
        <bits access="rw" name="capture_data_sel_tdc" pos="8" rst="0x1"/>
        <bits access="rw" name="sel_clk_out2_inv" pos="7" rst="0x0"/>
        <bits access="rw" name="sel_clk_out1_inv" pos="6" rst="0x0"/>
        <bits access="rw" name="kdco_polar_sel" pos="5" rst="0x0"/>
        <bits access="rw" name="kdco_agc_mode" pos="4" rst="0x0"/>
        <bits access="rw" name="2m_lock_bypass" pos="3" rst="0x0"/>
        <bits access="rw" name="afc_bypass" pos="2" rst="0x0"/>
        <bits access="rw" name="iir1_bypass" pos="1" rst="0x0"/>
        <bits access="rw" name="iir0_bypass" pos="0" rst="0x0"/>
      </reg>
      <reg name="gro_phase_tdc_cal" protect="rw">
        <comment/>
        <bits access="r" name="phase_tdc_cal" pos="15:0" rst="0x0"/>
      </reg>
      <hole size="6720"/>
      <reg name="dlpf_ctrl_reg_set" protect="rw"/>
      <hole size="1376"/>
      <reg name="dlpf_ctrl_bit_reg_set" protect="rw"/>
      <hole size="6752"/>
      <reg name="dlpf_ctrl_reg_clr" protect="rw"/>
      <hole size="1376"/>
      <reg name="dlpf_ctrl_bit_reg_clr" protect="rw"/>
    </module>
    <var name="REG_RF_RXDLPF_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_RXDLPF_CLR_OFFSET" value="0x800"/>
    <instance address="0x50037000" name="RF_RXDLPF" type="RF_RXDLPF"/>
  </archive>
  <archive relative="rf_sysctrl.xml">
    <module category="System" name="RF_SYSCTRL">
      <reg name="sysctrl1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_sys_ctrl_pu_bbpll2_dr" pos="2" rst="0x0">
          <comment>1: pu_bbpll2 by reg
0: pu_bbpll2 by idle hw</comment>
        </bits>
        <bits access="rw" name="rg_sys_ctrl_pu_bbpll2" pos="1" rst="0x0">
          <comment>1:寄存器配置打开BBPLL2</comment>
        </bits>
        <bits access="rw" name="rg_sys_ctrl_pu_bbpll1" pos="0" rst="0x0">
          <comment>1:寄存器配置打开BBPLL1</comment>
        </bits>
      </reg>
      <reg name="sysctrl2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_enable_clk26m_aux1" pos="2" rst="0x0">
          <comment>1：打开clk 26m aux1</comment>
        </bits>
        <bits access="rw" name="rg_enable_clk26m_tsx_thm" pos="1" rst="0x0">
          <comment>1：打开clk 26m tsx adc时钟</comment>
        </bits>
        <bits access="rw" name="rg_enable_clk26m_osc_thm" pos="0" rst="0x0">
          <comment>1：打开clk 26m osc adc时钟</comment>
        </bits>
      </reg>
      <reg name="sysctrl3" protect="rw">
        <comment/>
        <bits access="rw" name="rg_bitmap_lte_rx_on" pos="10" rst="0x0">
          <comment>1：寄存器配置lte rx on，为bitmap模块冲突使用，功能同TXRX硬件送出的lte rx on</comment>
        </bits>
        <bits access="rw" name="gnss_coexist_ext" pos="9" rst="0x0">
          <comment>1：lte抢占gnss射频指示bit，送给gnss后，gnss模块内部iq置0</comment>
        </bits>
        <bits access="rw" name="gnss_int_mask_bit" pos="8" rst="0x0">
          <comment>1：gnss中断屏蔽bit</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_adc_wcn_clk_sel" pos="7" rst="0x1">
          <comment>1：gnss adc时钟选择gnss pll 66/33m
0：gnss adc时钟选择wifi pll 66/33m，在LTE紧急抢占gnss射频时，打开bbpll1稳定后，时钟切换到bbpll1</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_adc_wcn_clk_en" pos="6" rst="0x0">
          <comment>1：gnss adc使用wifi pll 66/33m时钟前使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_bb_pp_wcn_clk_sel" pos="5" rst="0x1">
          <comment>1：gnss pp时钟选择gnss pll 66/33m
0：gnss pp时钟选择wifi pll 66/33m，在LTE紧急抢占gnss射频时，打开bbpll1稳定后，时钟切换到bbpll1</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_bb_pp_wcn_clk_en" pos="4" rst="0x0">
          <comment>1：gnss pp使用wifi pll 66/33m时钟前使能</comment>
        </bits>
        <bits access="rw" name="rfdig_latch_gnss" pos="3" rst="0x0">
          <comment>1：capture gnss ae/te指针</comment>
        </bits>
        <bits access="rw" name="rg_lte_iq_sel_0" pos="2" rst="0x0">
          <comment>1：送给LTE的IQ源头置0</comment>
        </bits>
        <bits access="rw" name="rg_wifi_iq_sel_0" pos="1" rst="0x1">
          <comment>1：送给WIFI的IQ源头置0</comment>
        </bits>
        <bits access="rw" name="rg_gnss_iq_sel_0" pos="0" rst="0x1">
          <comment>1：送给GNSS的IQ源头置0</comment>
        </bits>
      </reg>
      <reg name="sysctrl4" protect="rw">
        <comment/>
        <bits access="rw" name="rg_ram_clk_auto_cg" pos="7:6" rst="0x3">
          <comment>1:riscv ram时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_sclk_auto_gate_en" pos="5" rst="0x0">
          <comment>1：aon访问rf的ahb async bridge slave端时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_mclk_auto_gate_en" pos="4" rst="0x0">
          <comment>1：aon访问rf的ahb async bridge master端时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_nonbuf_early_resp_en" pos="3" rst="0x0">
          <comment>1：aon访问rf的ahb async bridge early response使能</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_sclk_auto_gate_en" pos="2" rst="0x0">
          <comment>1：rf访问aon的ahb async bridge slave端时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_mclk_auto_gate_en" pos="1" rst="0x0">
          <comment>1：rf访问aon的ahb async bridge master端时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_nonbuf_early_resp_en" pos="0" rst="0x0">
          <comment>1：rf访问aon的ahb async bridge early response使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl5" protect="rw">
        <comment/>
        <bits access="rw" name="rg_pwd_adc_clkedge_sel" pos="13" rst="0x0">
          <comment>1：power detector adc时钟反向</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_sel_rxdlpf_afc" pos="12" rst="0x0">
          <comment>1:adda test mode=5,rxdlpf mode, debug data sel dafc and tdc_code
0:adda test mode=5,rxdlpf mode, debug data sel kdco and tdc_code</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_sel_txdlpf_afc" pos="11" rst="0x0">
          <comment>1:adda test mode=4,txdlpf mode, debug data sel dafc and tdc_code
0:adda test mode=4,txdlpf mode, debug data sel kdco and tdc_code</comment>
        </bits>
        <bits access="rw" name="rg_osc_adc_clkedge_sel" pos="10" rst="0x0">
          <comment>1：osc温度计adc时钟反向</comment>
        </bits>
        <bits access="rw" name="rg_tsx_adc_clkedge_sel" pos="9" rst="0x0">
          <comment>1：tsx温度计adc时钟反向</comment>
        </bits>
        <bits access="rw" name="rg_rf_test_pad_en" pos="8" rst="0x0">
          <comment>1：rf analog 测试pad输出使能
0：rf analog 测试pad输出high-z</comment>
        </bits>
        <bits access="rw" name="rg_hresp_err_mask" pos="7" rst="0x0">
          <comment>1：riscv接收AHB response error屏蔽</comment>
        </bits>
        <bits access="rw" name="rg_dfe_dump_sel_bit" pos="6:4" rst="0x0">
          <comment>dfe dump数据截位选择：
000：原始dfe dump数据输出
001：低4位丢弃
001：低3位丢弃
010：低2位丢弃
011：低1位丢弃</comment>
        </bits>
        <bits access="rw" name="rg_adc_clkedge_sel" pos="3" rst="0x0">
          <comment>1：adc输入时钟反沿</comment>
        </bits>
        <bits access="rw" name="rg_rtc_clkedge_sel" pos="2" rst="0x1">
          <comment>1：输出给rf analog的rtc时钟反沿</comment>
        </bits>
        <bits access="rw" name="rg_lte_dac_clkedge_sel" pos="1" rst="0x1">
          <comment>1：输出给rf analog的dac时钟反沿</comment>
        </bits>
        <bits access="rw" name="rg_lte_dac_clk_en" pos="0" rst="0x1">
          <comment>1：输出给rf analog的dac时钟使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl6" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxdlpf_soft_rst" pos="7" rst="0x1">
          <comment>1：rxdlpf复位</comment>
        </bits>
        <bits access="rw" name="rg_txdlpf_soft_rst" pos="6" rst="0x1">
          <comment>1：txdlpf复位</comment>
        </bits>
        <bits access="rw" name="rg_dfe_thm_osc_soft_rst" pos="5" rst="0x1">
          <comment>1：dfe osc temper复位</comment>
        </bits>
        <bits access="rw" name="rg_dfe_thm_tsx_soft_rst" pos="4" rst="0x1">
          <comment>1：dfe tsx temper复位</comment>
        </bits>
        <bits access="rw" name="rg_dfe_pwd_soft_rst" pos="3" rst="0x1">
          <comment>1：dfe pwd复位</comment>
        </bits>
        <bits access="rw" name="rg_dfe_txdp_soft_rst" pos="2" rst="0x1">
          <comment>1：dfe tx通道复位</comment>
        </bits>
        <bits access="rw" name="rg_dfe_rxdp_soft_rst" pos="1" rst="0x1">
          <comment>1：dfe rx通道复位</comment>
        </bits>
        <bits access="rw" name="rg_dfe_cgu_soft_rst" pos="0" rst="0x0">
          <comment>1：dfe clkrst复位</comment>
        </bits>
      </reg>
      <reg name="sysctrl7" protect="rw">
        <comment/>
        <bits access="rw" name="ptest_func_atspeed_sel" pos="2" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="rg_mipi_clk_half_en" pos="1" rst="0x0">
          <comment>1：mipi时钟选择13m
0：mipi时钟选择26m</comment>
        </bits>
        <bits access="rw" name="rg_usid_change_en" pos="0" rst="0x0">
          <comment>1：usid改变时多发一条trigger命令</comment>
        </bits>
      </reg>
      <reg name="sysctrl8" protect="rw">
        <comment/>
        <bits access="rw" name="rg_thm_osc_26m_auto_gate_en" pos="14" rst="0x0">
          <comment>1：送给rf analog的osc 26m时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_thm_tsx_26m_auto_gate_en" pos="13" rst="0x0">
          <comment>1：送给rf analog的tsx 26m时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_bbpll_122m_auto_gate_en" pos="12" rst="0x0">
          <comment>1：送给rf analog的bbpll2 122.88m时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_bbpll_245m_auto_gate_en" pos="11" rst="0x0">
          <comment>1：送给rf analog的bbpll2 245.76m时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_wcn_bbpll_80m_auto_gate_en" pos="10" rst="0x0">
          <comment>1：送给rf analog的bbpll1 80m时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_auto_gate_en" pos="7" rst="0x0">
          <comment>1：aon访问rf通路的AHB async bridge时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_auto_gate_en" pos="6" rst="0x0">
          <comment>1：rf访问aon通路的AHB async bridge时钟auto gate使能</comment>
        </bits>
        <bits access="rw" name="rg_cgm_dfe_245m76_en" pos="5" rst="0x1">
          <comment>1：dfe源头245.76m时钟使能，always 1</comment>
        </bits>
        <bits access="rw" name="rg_cgm_26m_interface_en" pos="4" rst="0x1">
          <comment>1：rf dig使用的26m时钟使能，always 1</comment>
        </bits>
        <bits access="rw" name="rg_cgm_ahb_en" pos="3" rst="0x1">
          <comment>1：rf_dig的ahb时钟使能，always 1</comment>
        </bits>
        <bits access="rw" name="rg_ahb_freq_auto_sel" pos="2" rst="0x0">
          <comment>1：ahb时钟自动切换使能，当rg_cgm_chb_sel【1：0】配置选择到的时钟对应PLL源头未打开，ahb时钟自动切换到26m</comment>
        </bits>
        <bits access="rw" name="rg_cgm_ahb_sel" pos="1:0" rst="0x0">
          <comment>00：dcxo 26m
01：wifi bbpll 80m
10：lte bbpll 122.88m
11：gnss pll 133m</comment>
        </bits>
      </reg>
      <reg name="sysctrl9" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cgm_thm_tsx_bist_en" pos="14" rst="0x1">
          <comment>1：ATE模式下的tsen bist模块时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_cgm_thm_tsx_pad_en" pos="13" rst="0x0">
          <comment>1：送到PAD的tsx时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_cgm_thm_tsx_dfe_en" pos="12" rst="0x1">
          <comment>1：送给DFE的tsx时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_cgm_thm_osc_pad_en" pos="11" rst="0x0">
          <comment>1：送到PAD的osc时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_cgm_thm_osc_en" pos="10" rst="0x1">
          <comment>1：dfe osc时钟源头使能</comment>
        </bits>
        <bits access="rw" name="rg_cgm_lte_adc_en" pos="9" rst="0x1">
          <comment>1：dfe adc时钟源头使能</comment>
        </bits>
        <bits access="rw" name="rg_pwd_dfe_pwd_en" pos="8" rst="0x1">
          <comment>1：dfe pwd时钟源头使能</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_peak_det_en" pos="7" rst="0x1">
          <comment>1：peak detector功能26m时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_bbpll2_en" pos="6" rst="0x1">
          <comment>1：bbpll2 sdm模块26m时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_bbpll1_en" pos="5" rst="0x1">
          <comment>1：bbpll1 sdm模块26m时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_txpll_cal_en" pos="4" rst="0x1">
          <comment>1：txpll calibration模块26m时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_rxpll_cal_en" pos="3" rst="0x1">
          <comment>1：rxpll calibration模块26m时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_intf_en" pos="2" rst="0x1">
          <comment>1：rf interface reg模块26m时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_rffe_clk_en" pos="1" rst="0x1">
          <comment>1：rffe接口和功能时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_rtc_clk_en" pos="0" rst="0x1">
          <comment>1：rtc接口时钟使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl10" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cgm_rf_bitmap_en" pos="12" rst="0x1">
          <comment>1：rf bitmap模块时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_ahb_wdg_en" pos="11" rst="0x1">
          <comment>1：wdg模块时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_ahb_timer0_en" pos="10" rst="0x1">
          <comment>1：timer模块时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_ahb_pulp_en" pos="9" rst="0x1">
          <comment>1：riscv时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_en" pos="8" rst="0x1">
          <comment>1：aon访问rf AHB通路时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_en" pos="7" rst="0x1">
          <comment>1：rf访问aon AHB通路时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_ahb_txdlpf_en" pos="6" rst="0x1">
          <comment>1：txdlpf接口时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_ahb_rxdlpf_en" pos="5" rst="0x1">
          <comment>1：rxdlpf接口时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_ahb_spi2ahb_en" pos="4" rst="0x1">
          <comment>1：spi2ahb模块接口时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_ahb_ram_en" pos="3" rst="0x1">
          <comment>1：riscv ram接口时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_ahb_intf_en" pos="2" rst="0x1">
          <comment>1：rf interface reg模块ahb接口时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_ahb_dfe_en" pos="1" rst="0x1">
          <comment>1：dfe模块接口时钟使能</comment>
        </bits>
        <bits access="rw" name="rg_ahb_bus_en" pos="0" rst="0x1">
          <comment>1：总线matrix时钟使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl11" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rx_gro_out2_rxdlpf_en" pos="7" rst="0x1">
          <comment>1：rxdlpf gro out2时钟源头使能</comment>
        </bits>
        <bits access="rw" name="rg_rx_gro_out1_rxdlpf_en" pos="6" rst="0x1">
          <comment>1：rxdlpf gro out1时钟源头使能</comment>
        </bits>
        <bits access="rw" name="rg_tx_gro_out2_txdlpf_en" pos="5" rst="0x1">
          <comment>1：txdlpf gro out2时钟源头使能</comment>
        </bits>
        <bits access="rw" name="rg_tx_gro_out1_txdlpf_en" pos="4" rst="0x1">
          <comment>1：txdlpf gro out1时钟源头使能</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_sdm_rxsdm_en" pos="3" rst="0x1">
          <comment>1：rxpll sdm时钟源头使能</comment>
        </bits>
        <bits access="rw" name="rg_txpll_sdm_txsdm_en" pos="2" rst="0x1">
          <comment>1：txpll sdm时钟源头使能</comment>
        </bits>
        <bits access="rw" name="rg_cgm_lpll_sdm_en" pos="1" rst="0x1">
          <comment>1：lte bbpll sdm时钟源头使能</comment>
        </bits>
        <bits access="rw" name="rg_cgm_wpll_sdm_en" pos="0" rst="0x1">
          <comment>1：wifi bbpll sdm时钟源头使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl12" protect="rw">
        <comment/>
        <bits access="rw" name="thm_osc_26m_cnt_done_bypass" pos="15" rst="0x1">
          <comment>1：osc时钟稳定时间等待功能bypass
0：硬件判断到pu和enable拉高后自动打开</comment>
        </bits>
        <bits access="rw" name="thm_tsx_26m_cnt_done_bypass" pos="14" rst="0x1">
          <comment>1：tsx时钟稳定时间等待功能bypass
0：硬件判断到pu和enable拉高后自动打开</comment>
        </bits>
        <bits access="rw" name="adc_122m_cnt_done_bypass" pos="13" rst="0x1">
          <comment>1：adc时钟稳定时间等待功能bypass
0：硬件判断到pu和enable拉高后自动打开</comment>
        </bits>
        <bits access="rw" name="bbpll_122m_cnt_done_bypass" pos="12" rst="0x1">
          <comment>1：bbpll2时钟稳定时间等待功能bypass
0：硬件判断到pu和lock拉高后自动打开</comment>
        </bits>
        <bits access="rw" name="bbpll_245m_cnt_done_bypass" pos="11" rst="0x1">
          <comment>1：bbpll2时钟稳定时间等待功能bypass
0：硬件判断到pu和lock拉高后自动打开</comment>
        </bits>
        <bits access="rw" name="wcn_bbpll_80m_cnt_done_bypass" pos="10" rst="0x1">
          <comment>1：bbpll1时钟稳定时间等待功能bypass
0：硬件判断到pu和lock拉高后自动打开</comment>
        </bits>
        <bits access="rw" name="gnss_pll_198m_cnt_done_bypass" pos="9" rst="0x1">
          <comment>1：gnss pll时钟稳定时间等待功能bypass
0：硬件判断到pu和lock拉高后自动打开</comment>
        </bits>
        <bits access="rw" name="gnss_pll_397m_cnt_done_bypass" pos="8" rst="0x1">
          <comment>1：gnss pll时钟稳定时间等待功能bypass
0：硬件判断到pu和lock拉高后自动打开</comment>
        </bits>
        <bits access="rw" name="thm_osc_26m_soft_cnt_done" pos="7" rst="0x1">
          <comment>1：软件不参与时钟稳定时间判断，由硬件决定</comment>
        </bits>
        <bits access="rw" name="thm_tsx_26m_soft_cnt_done" pos="6" rst="0x1">
          <comment>1：软件不参与时钟稳定时间判断，由硬件决定</comment>
        </bits>
        <bits access="rw" name="adc_122m_soft_cnt_done" pos="5" rst="0x1">
          <comment>1：软件不参与时钟稳定时间判断，由硬件决定</comment>
        </bits>
        <bits access="rw" name="bbpll_122m_soft_cnt_done" pos="4" rst="0x1">
          <comment>1：软件不参与时钟稳定时间判断，由硬件决定</comment>
        </bits>
        <bits access="rw" name="bbpll_245m_soft_cnt_done" pos="3" rst="0x1">
          <comment>1：软件不参与时钟稳定时间判断，由硬件决定</comment>
        </bits>
        <bits access="rw" name="wcn_bbpll_80m_soft_cnt_done" pos="2" rst="0x1">
          <comment>1：软件不参与时钟稳定时间判断，由硬件决定</comment>
        </bits>
        <bits access="rw" name="gnss_pll_198m_soft_cnt_done" pos="1" rst="0x1">
          <comment>1：软件不参与时钟稳定时间判断，由硬件决定</comment>
        </bits>
        <bits access="rw" name="gnss_pll_397m_soft_cnt_done" pos="0" rst="0x1">
          <comment>1：软件不参与时钟稳定时间判断，由硬件决定</comment>
        </bits>
      </reg>
      <reg name="sysctrl13" protect="rw">
        <comment/>
        <bits access="rw" name="thm_osc_26m_wait_force_en" pos="15" rst="0x1">
          <comment>1：当wait auto gate sel=0时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="thm_tsx_26m_wait_force_en" pos="14" rst="0x1">
          <comment>1：当wait auto gate sel=0时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="adc_122m_wait_force_en" pos="13" rst="0x1">
          <comment>1：当wait auto gate sel=0时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="bbpll_122m_wait_force_en" pos="12" rst="0x1">
          <comment>1：当wait auto gate sel=0时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="bbpll_245m_wait_force_en" pos="11" rst="0x1">
          <comment>1：当wait auto gate sel=0时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="wcn_bbpll_80m_wait_force_en" pos="10" rst="0x1">
          <comment>1：当wait auto gate sel=0时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="gnss_pll_198m_wait_force_en" pos="9" rst="0x1">
          <comment>1：当wait auto gate sel=0时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="gnss_pll_397m_wait_force_en" pos="8" rst="0x1">
          <comment>1：当wait auto gate sel=0时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="thm_osc_26m_wait_auto_gate_sel" pos="7" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="thm_tsx_26m_wait_auto_gate_sel" pos="6" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="adc_122m_wait_auto_gate_sel" pos="5" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="bbpll_122m_wait_auto_gate_sel" pos="4" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="bbpll_245m_wait_auto_gate_sel" pos="3" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="wcn_bbpll_80m_wait_auto_gate_sel" pos="2" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="gnss_pll_198m_wait_auto_gate_sel" pos="1" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="gnss_pll_397m_wait_auto_gate_sel" pos="0" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl14" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_div_pll_397m_33m1_auto_gate_sel" pos="7" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_56m7_auto_gate_sel" pos="6" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_132m3_auto_gate_sel" pos="5" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_158m8_auto_gate_sel" pos="4" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_33m1_force_en" pos="3" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_56m7_force_en" pos="2" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_132m3_force_en" pos="1" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_158m8_force_en" pos="0" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl15" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_gnss_pll_397m_pub_auto_gate_sel" pos="12" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_122_88m_lte_auto_gate_sel" pos="11" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_245_76m_lte_auto_gate_sel" pos="10" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_thm_osc_26m_cp_auto_gate_sel" pos="9" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_thm_tsx_26m_cp_auto_gate_sel" pos="8" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_adc_iq_cp_auto_gate_sel" pos="7" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_cp_auto_gate_sel" pos="6" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_cp_auto_gate_sel" pos="5" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_cp_auto_gate_sel" pos="4" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_57m_ap_auto_gate_sel" pos="3" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_ap_auto_gate_sel" pos="2" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_ap_auto_gate_sel" pos="1" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_ap_auto_gate_sel" pos="0" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl16" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_adc_iq_gnss_auto_gate_sel" pos="14" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_gnss_auto_gate_sel" pos="13" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_158m_gnss_auto_gate_sel" pos="12" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_gnss_auto_gate_sel" pos="11" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_33m_aon_auto_gate_sel" pos="10" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_aon_auto_gate_sel" pos="9" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_aon_auto_gate_sel" pos="8" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_aon_auto_gate_sel" pos="7" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_thm_osc_26m_rf_auto_gate_sel" pos="6" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_thm_tsx_26m_rf_auto_gate_sel" pos="5" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_adc_iq_rf_auto_gate_sel" pos="4" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_rf_auto_gate_sel" pos="3" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_rf_auto_gate_sel" pos="2" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_122_88m_rf_auto_gate_sel" pos="1" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_245_76m_rf_auto_gate_sel" pos="0" rst="0x1">
          <comment>1：硬件auto gating使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl17" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_gnss_pll_397m_pub_force_en" pos="12" rst="0x1">
          <comment>1：当auto gate sel=0时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_122_88m_lte_force_en" pos="11" rst="0x1">
          <comment>1：当auto gate sel=1时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_245_76m_lte_force_en" pos="10" rst="0x1">
          <comment>1：当auto gate sel=2时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_thm_osc_26m_cp_force_en" pos="9" rst="0x1">
          <comment>1：当auto gate sel=3时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_thm_tsx_26m_cp_force_en" pos="8" rst="0x1">
          <comment>1：当auto gate sel=4时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_adc_iq_cp_force_en" pos="7" rst="0x1">
          <comment>1：当auto gate sel=5时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_cp_force_en" pos="6" rst="0x1">
          <comment>1：当auto gate sel=6时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_cp_force_en" pos="5" rst="0x1">
          <comment>1：当auto gate sel=7时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_cp_force_en" pos="4" rst="0x1">
          <comment>1：当auto gate sel=8时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_57m_ap_force_en" pos="3" rst="0x1">
          <comment>1：当auto gate sel=9时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_ap_force_en" pos="2" rst="0x1">
          <comment>1：当auto gate sel=10时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_ap_force_en" pos="1" rst="0x1">
          <comment>1：当auto gate sel=11时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_ap_force_en" pos="0" rst="0x1">
          <comment>1：当auto gate sel=12时，软件强制打开对应时钟</comment>
        </bits>
      </reg>
      <reg name="sysctrl18" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_adc_iq_gnss_force_en" pos="14" rst="0x1">
          <comment>1：当auto gate sel=14时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_gnss_force_en" pos="13" rst="0x1">
          <comment>1：当auto gate sel=15时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_158m_gnss_force_en" pos="12" rst="0x1">
          <comment>1：当auto gate sel=16时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_gnss_force_en" pos="11" rst="0x1">
          <comment>1：当auto gate sel=17时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_33m_aon_force_en" pos="10" rst="0x1">
          <comment>1：当auto gate sel=18时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_aon_force_en" pos="9" rst="0x1">
          <comment>1：当auto gate sel=19时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_aon_force_en" pos="8" rst="0x1">
          <comment>1：当auto gate sel=20时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_aon_force_en" pos="7" rst="0x1">
          <comment>1：当auto gate sel=21时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_thm_osc_26m_rf_force_en" pos="6" rst="0x1">
          <comment>1：当auto gate sel=22时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_thm_tsx_26m_rf_force_en" pos="5" rst="0x1">
          <comment>1：当auto gate sel=23时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_adc_iq_rf_force_en" pos="4" rst="0x1">
          <comment>1：当auto gate sel=24时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_rf_force_en" pos="3" rst="0x1">
          <comment>1：当auto gate sel=25时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_rf_force_en" pos="2" rst="0x1">
          <comment>1：当auto gate sel=26时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_122_88m_rf_force_en" pos="1" rst="0x1">
          <comment>1：当auto gate sel=27时，软件强制打开对应时钟</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_245_76m_rf_force_en" pos="0" rst="0x1">
          <comment>1：当auto gate sel=28时，软件强制打开对应时钟</comment>
        </bits>
      </reg>
      <reg name="sysctrl19" protect="rw">
        <comment/>
        <bits access="rw" name="rg_tsen_bist_soft_rst" pos="3" rst="0x0">
          <comment>1：ATE模式使用的tsen bist模块复位</comment>
        </bits>
        <bits access="rw" name="rg_rf_bitmap_soft_rst" pos="2" rst="0x0">
          <comment>1：bitmap模块复位</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_soft_rst" pos="1" rst="0x0">
          <comment>1：rf访问aon的AHB async bridge复位</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_soft_rst" pos="0" rst="0x0">
          <comment>1：aon访问rf的AHB async bridge复位</comment>
        </bits>
      </reg>
      <reg name="sysctrl20" protect="rw">
        <comment/>
        <bits access="rw" name="rg_dfe_reg_soft_rst" pos="15" rst="0x0">
          <comment>1：dfe寄存器模块复位</comment>
        </bits>
        <bits access="rw" name="rg_intf_clkgen_soft_rst" pos="14" rst="0x0">
          <comment>1：rf interface模块clk div复位</comment>
        </bits>
        <bits access="rw" name="rg_intf_irq_ctrl_soft_rst" pos="13" rst="0x0">
          <comment>1：rf interface模块irq handler复位</comment>
        </bits>
        <bits access="rw" name="rg_intf_peak_det_soft_rst" pos="12" rst="0x0">
          <comment>1：rf interface模块peak det复位</comment>
        </bits>
        <bits access="rw" name="rg_intf_apb_reg_soft_rst" pos="11" rst="0x0">
          <comment>1：rf interface模块寄存器复位</comment>
        </bits>
        <bits access="rw" name="rg_spi2ahb_soft_rst" pos="10" rst="0x0">
          <comment>1：spi2ahb模块复位</comment>
        </bits>
        <bits access="rw" name="rg_rtc_soft_rst" pos="9" rst="0x0">
          <comment>1：riscv访问rf dig rtc接口复位</comment>
        </bits>
        <bits access="rw" name="rg_ana_regs_soft_rst" pos="8" rst="0x0">
          <comment>1：rf analog reg模块复位</comment>
        </bits>
        <bits access="rw" name="rg_rffe_soft_rst" pos="7" rst="0x0">
          <comment>1：rffe模块复位</comment>
        </bits>
        <bits access="rw" name="rg_wdg_soft_rst" pos="6" rst="0x0">
          <comment>1：wdg模块复位</comment>
        </bits>
        <bits access="rw" name="rg_timer0_soft_rst" pos="5" rst="0x0">
          <comment>1：timer0模块复位</comment>
        </bits>
        <bits access="rw" name="rg_rxdlpf_reg_soft_rst" pos="4" rst="0x0">
          <comment>1：rxdlpf模块寄存器复位</comment>
        </bits>
        <bits access="rw" name="rg_txdlpf_reg_soft_rst" pos="3" rst="0x0">
          <comment>1：txdlpf模块寄存器复位</comment>
        </bits>
        <bits access="rw" name="rg_ram_soft_rst" pos="2" rst="0x0">
          <comment>1：riscv ram模块接口复位</comment>
        </bits>
        <bits access="rw" name="rg_dbg_soft_rst" pos="1" rst="0x0">
          <comment>1：riscv模块debug功能复位</comment>
        </bits>
        <bits access="rw" name="rg_riscv_soft_rst" pos="0" rst="0x1">
          <comment>1：riscv核复位</comment>
        </bits>
      </reg>
      <reg name="sysctrl21" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rf_gpio_o" pos="9:0" rst="0x0">
          <comment>1：rfdig gpio输出值</comment>
        </bits>
      </reg>
      <reg name="sysctrl22" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rf_gpio_oen" pos="9:0" rst="0x3ff">
          <comment>1：rfidg gpio输入使能</comment>
        </bits>
      </reg>
      <reg name="sysctrl23" protect="rw">
        <comment/>
        <bits access="rw" name="rg_simc_pa_on" pos="11" rst="0x0">
          <comment>1：当rg_simc_pa_en=0时，PA大功率发射时simc auto gate功能软件使能</comment>
        </bits>
        <bits access="rw" name="rg_simc_pa_en" pos="10" rst="0x0">
          <comment>1：APC发射功率超过rg_simc_pa_on_th门限时，产生simc auto gate信号送给simc</comment>
        </bits>
        <bits access="rw" name="rg_simc_pa_on_th" pos="9:0" rst="0x0">
          <comment>simc功能PA发射功率门限</comment>
        </bits>
      </reg>
      <reg name="sysctrl24" protect="rw">
        <comment/>
        <bits access="rw" name="rg_sysctrl_soft_rst" pos="0" rst="0x0">
          <comment>1：sysctrl模块寄存器软复位</comment>
        </bits>
      </reg>
      <reg name="sysctrl25" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_gro_rstn_hw_ctrl_en" pos="14" rst="0x1">
          <comment>1：送给rf analog的gro rst信号由AAFC校准产生的OPEN_EN硬件决定，软件不参与</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_dlpf_rstn_hw_ctrl_en" pos="13" rst="0x1">
          <comment>1：rf analog送给dlpf的dlpf rstn信号由AAFC校准产生的OPEN_EN硬件决定，软件不参与</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_pkden_hw_ctrl_en" pos="12" rst="0x1">
          <comment>1：送给rf analog的vco pkdet功能由AAFC校准产生的vco pkdet硬件决定，软件不参与</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_open_hw_ctrl_en" pos="11" rst="0x1">
          <comment>1：送给rf analog的open_en信号由AAFC校准产生的OPEN_EN硬件决定，软件不参与</comment>
        </bits>
        <bits access="rw" name="rg_txpll_gro_rstn_hw_ctrl_en" pos="10" rst="0x1">
          <comment>1：送给rf analog的gro rst信号由AAFC校准产生的OPEN_EN硬件决定，软件不参与</comment>
        </bits>
        <bits access="rw" name="rg_txpll_dlpf_rstn_hw_ctrl_en" pos="9" rst="0x1">
          <comment>1：rf analog送给dlpf的dlpf rstn信号由AAFC校准产生的OPEN_EN硬件决定，软件不参与</comment>
        </bits>
        <bits access="rw" name="rg_txpll_pkden_hw_ctrl_en" pos="8" rst="0x1">
          <comment>1：送给rf analog的vco pkdet功能由AAFC校准产生的vco pkdet硬件决定，软件不参与</comment>
        </bits>
        <bits access="rw" name="rg_txpll_open_hw_ctrl_en" pos="7" rst="0x1">
          <comment>1：送给rf analog的open_en信号由AAFC校准产生的OPEN_EN硬件决定，软件不参与</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_mode_sel" pos="6:4" rst="0x0">
          <comment>adda测试模式选择：
000：adc测试模式，数据不经过dfe直接到ram
001：adc测试模式，数据经过dfe直接到ram
010：dfe dump数据到ram
011：dac测试模式
100：txdlpf测试模式
101：txdlpf测试模式
110：rxdlpf测试模式
111：rxdlpf测试模式</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_mode" pos="3" rst="0x0">
          <comment>1：进入adda测试模式</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_dac_sel" pos="2" rst="0x0">
          <comment>1：dac测试模式数据从ram自动发出不经过dfe
0：dac测试模式数据从ram发出后经过dfe</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_en" pos="1" rst="0x0">
          <comment>1：adda测试读写数据使能</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_soft_rst" pos="0" rst="0x1">
          <comment>1：adda测试模式复位</comment>
        </bits>
      </reg>
      <reg name="sysstat1" protect="rw">
        <comment/>
        <bits access="r" name="rf_gpio_i" pos="9:0" rst="0x0">
          <comment>rfdig gpio输入信号</comment>
        </bits>
      </reg>
      <reg name="sysstat2" protect="rw">
        <comment/>
        <bits access="r" name="rf_dbg_monitor" pos="7:0" rst="0x0">
          <comment>rfdig monitor信号寄存器可读</comment>
        </bits>
      </reg>
      <reg name="sysctrl26" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain0" pos="15:0" rst="0x0">
          <comment>wifi agc gain table0，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl27" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain1" pos="15:0" rst="0x0">
          <comment>wifi agc gain table1，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl28" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain2" pos="15:0" rst="0x0">
          <comment>wifi agc gain table2，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl29" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain3" pos="15:0" rst="0x0">
          <comment>wifi agc gain table3，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl30" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain4" pos="15:0" rst="0x0">
          <comment>wifi agc gain table4，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl31" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain5" pos="15:0" rst="0x0">
          <comment>wifi agc gain table5，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl32" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain6" pos="15:0" rst="0x0">
          <comment>wifi agc gain table6，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl33" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain7" pos="15:0" rst="0x0">
          <comment>wifi agc gain table7，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl34" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain8" pos="15:0" rst="0x0">
          <comment>wifi agc gain table8，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl35" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain9" pos="15:0" rst="0x0">
          <comment>wifi agc gain table9，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl36" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain10" pos="15:0" rst="0x0">
          <comment>wifi agc gain table10，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl37" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain11" pos="15:0" rst="0x0">
          <comment>wifi agc gain table11，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl38" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain12" pos="15:0" rst="0x0">
          <comment>wifi agc gain table12，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl39" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain13" pos="15:0" rst="0x0">
          <comment>wifi agc gain table13，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl40" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain14" pos="15:0" rst="0x0">
          <comment>wifi agc gain table14，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysctrl41" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain15" pos="15:0" rst="0x0">
          <comment>wifi agc gain table15，硬件根据wlan基带输出的auto gac index自动选择</comment>
        </bits>
      </reg>
      <reg name="sysstat3" protect="rw">
        <comment/>
        <bits access="r" name="wlan_gain_index" pos="3:0" rst="0x0">
          <comment>wlan基带输出的auto gac index，寄存器可读</comment>
        </bits>
      </reg>
      <reg name="sysctrl42" protect="rw">
        <comment/>
        <bits access="rw" name="rg_gain_out_sel_wifi" pos="4" rst="0x0">
          <comment>1：WIFI接收模式，送给rf analog的agc gain由auto gac index选择wifi_gain0-15寄存器，送给rf analog的wifi gain pga/rxflt dccal i/q选择寄存器
0：LTE和GNSS模式，送给rf analog的agc gain、pga/rxflt dccal i/q由软件配置</comment>
        </bits>
        <bits access="rw" name="rg_dc_qcal_sel" pos="3:2" rst="0x0">
          <comment>00：送给rf analog的pga I路校准信号选择寄存器
01：送给rf analog的pga I路校准信号选择dfe输出的dac sine补码
10：送给rf analog的pga I路校准信号选择dfe输出的dac sine原码
11：送给rf analog的pga I路校准信号选择0</comment>
        </bits>
        <bits access="rw" name="rg_dc_ical_sel" pos="1:0" rst="0x0">
          <comment>00：送给rf analog的pga Q路校准信号选择寄存器
01：送给rf analog的pga Q路校准信号选择dfe输出的dac sine补码
10：送给rf analog的pga Q路校准信号选择dfe输出的dac sine原码
11：送给rf analog的pga Q路校准信号选择0</comment>
        </bits>
      </reg>
      <reg name="sysctrl43" protect="rw">
        <comment/>
        <bits access="rw" name="rg_dc_qcal_offset" pos="15:8" rst="0x0">
          <comment>送给rf analog的pga I路校准信号选择dfe输出的dac sine补上固定offset</comment>
        </bits>
        <bits access="rw" name="rg_dc_ical_offset" pos="7:0" rst="0x0">
          <comment>送给rf analog的pga Q路校准信号选择dfe输出的dac sine补上固定offset</comment>
        </bits>
      </reg>
      <reg name="sysctrl44" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl45" protect="rw">
        <comment/>
      </reg>
      <reg name="sysstat4" protect="rw">
        <comment/>
      </reg>
      <reg name="sysstat5" protect="rw">
        <comment/>
        <bits access="r" name="cgm_ahb_sel_ac" pos="9:8" rst="0x0">
          <comment>经过ahb clk自动切换后的ahb freq sel值，只读</comment>
        </bits>
        <bits access="r" name="adda_test_mem_full" pos="0" rst="0x0">
          <comment>硬化的乘法器输出</comment>
        </bits>
      </reg>
      <reg name="sysctrl46" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_gro_auto_ctrl_en" pos="11" rst="0x1">
          <comment>1：txpll gro上电选择硬件时序</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_gro_auto_ctrl_en" pos="10" rst="0x1">
          <comment>1：rxpll gro上电选择硬件时序</comment>
        </bits>
        <bits access="rw" name="rg_pll_gro_stab_time" pos="9:0" rst="0x186">
          <comment>txpll/rxpll gro上电稳定时间</comment>
        </bits>
      </reg>
      <reg name="sysctrl47" protect="rw">
        <comment/>
        <bits access="rw" name="rg_adc_enh_bb_force" pos="14" rst="0x1">
          <comment>LTE2GNSS RX时：adc_enh_bb_force=0，强制关闭ADC使能，即adc_enh_bb=0；adc_enh_bb_force=1，ADC使能恢复，受rg_adc_auto_ctrl_en或软件寄存器控制</comment>
        </bits>
        <bits access="rw" name="rg_adc_clk_enh_bb_force" pos="13" rst="0x1">
          <comment>LTE2GNSS RX时：adc_clk_enh_bb_force=0，强制关闭ADC时钟使能，即adc_clk_enh_bb=0；adc_clk_enh_bb_force=1，ADC时钟使能恢复，受rg_adc_auto_ctrl_en或软件寄存器控制</comment>
        </bits>
        <bits access="rw" name="rg_adc_auto_ctrl_en" pos="12" rst="0x0">
          <comment>1：adc开关选择硬件时序</comment>
        </bits>
        <bits access="rw" name="rg_adc_bias_en_cnt" pos="11:0" rst="0x186">
          <comment>adc bias拉高稳定时间</comment>
        </bits>
      </reg>
      <reg name="sysctrl48" protect="rw">
        <comment/>
        <bits access="rw" name="rg_adc_clk_enh_cnt" pos="11:0" rst="0x30c">
          <comment>adc clk enh拉高稳定时间</comment>
        </bits>
      </reg>
      <reg name="sysctrl49" protect="rw">
        <comment/>
        <bits access="rw" name="rg_pwdadc_auto_ctrl_en" pos="12" rst="0x0">
          <comment>1：pwdadc开关选择硬件时序</comment>
        </bits>
        <bits access="rw" name="rg_pwdadc_bias_en_cnt" pos="11:0" rst="0x186">
          <comment>pwdadc bias拉高稳定时间</comment>
        </bits>
      </reg>
      <reg name="sysctrl50" protect="rw">
        <comment/>
        <bits access="rw" name="rg_pwdadc_clk_enh_cnt" pos="11:0" rst="0x30c">
          <comment>pwdadc clk enh拉高稳定时间</comment>
        </bits>
      </reg>
      <reg name="sysctrl51" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain0_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table0对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain0_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table0对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl52" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain1_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table1对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain1_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table1对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl53" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain2_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table2对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain2_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table2对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl54" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain3_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table3对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain3_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table3对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl55" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain4_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table4对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain4_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table4对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl56" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain5_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table5对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain5_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table5对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl57" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain6_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table6对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain6_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table6对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl58" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain7_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table7对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain7_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table7对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl59" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain8_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table8对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain8_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table8对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl60" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain9_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table9对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain9_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table9对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl61" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain10_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table10对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain10_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table10对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl62" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain11_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table11对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain11_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table11对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl63" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain12_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table12对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain12_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table12对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl64" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain13_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table13对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain13_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table13对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl65" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain14_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table14对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain14_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table14对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl66" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain15_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table15对应的Q路pga dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain15_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table15对应的I路pga dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl67" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain0_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table0对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain0_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table0对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl68" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain1_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table1对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain1_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table1对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl69" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain2_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table2对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain2_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table2对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl70" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain3_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table3对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain3_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table3对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl71" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain4_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table4对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain4_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table4对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl72" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain5_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table5对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain5_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table5对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl73" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain6_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table6对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain6_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table6对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl74" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain7_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table7对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain7_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table7对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl75" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain8_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table8对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain8_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table8对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl76" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain9_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table9对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain9_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table9对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl77" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain10_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table10对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain10_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table10对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl78" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain11_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table11对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain11_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table11对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl79" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain12_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table12对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain12_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table12对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl80" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain13_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table13对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain13_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table13对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl81" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain14_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table14对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain14_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table14对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <reg name="sysctrl82" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain15_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table15对应的Q路rxflt dc校准补偿值</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain15_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table15对应的I路rxflt dc校准补偿值</comment>
        </bits>
      </reg>
      <hole size="5408"/>
      <reg name="sysctrl1_set" protect="rw"/>
      <reg name="sysctrl2_set" protect="rw"/>
      <reg name="sysctrl3_set" protect="rw"/>
      <reg name="sysctrl4_set" protect="rw"/>
      <reg name="sysctrl5_set" protect="rw"/>
      <reg name="sysctrl6_set" protect="rw"/>
      <reg name="sysctrl7_set" protect="rw"/>
      <reg name="sysctrl8_set" protect="rw"/>
      <reg name="sysctrl9_set" protect="rw"/>
      <reg name="sysctrl10_set" protect="rw"/>
      <reg name="sysctrl11_set" protect="rw"/>
      <reg name="sysctrl12_set" protect="rw"/>
      <reg name="sysctrl13_set" protect="rw"/>
      <reg name="sysctrl14_set" protect="rw"/>
      <reg name="sysctrl15_set" protect="rw"/>
      <reg name="sysctrl16_set" protect="rw"/>
      <reg name="sysctrl17_set" protect="rw"/>
      <reg name="sysctrl18_set" protect="rw"/>
      <reg name="sysctrl19_set" protect="rw"/>
      <reg name="sysctrl20_set" protect="rw"/>
      <reg name="sysctrl21_set" protect="rw"/>
      <reg name="sysctrl22_set" protect="rw"/>
      <reg name="sysctrl23_set" protect="rw"/>
      <reg name="sysctrl24_set" protect="rw"/>
      <reg name="sysctrl25_set" protect="rw"/>
      <hole size="608"/>
      <reg name="sysctrl42_set" protect="rw"/>
      <reg name="sysctrl43_set" protect="rw"/>
      <hole size="128"/>
      <reg name="sysctrl46_set" protect="rw"/>
      <reg name="sysctrl47_set" protect="rw"/>
      <reg name="sysctrl48_set" protect="rw"/>
      <reg name="sysctrl49_set" protect="rw"/>
      <reg name="sysctrl50_set" protect="rw"/>
      <hole size="6432"/>
      <reg name="sysctrl1_clr" protect="rw"/>
      <reg name="sysctrl2_clr" protect="rw"/>
      <reg name="sysctrl3_clr" protect="rw"/>
      <reg name="sysctrl4_clr" protect="rw"/>
      <reg name="sysctrl5_clr" protect="rw"/>
      <reg name="sysctrl6_clr" protect="rw"/>
      <reg name="sysctrl7_clr" protect="rw"/>
      <reg name="sysctrl8_clr" protect="rw"/>
      <reg name="sysctrl9_clr" protect="rw"/>
      <reg name="sysctrl10_clr" protect="rw"/>
      <reg name="sysctrl11_clr" protect="rw"/>
      <reg name="sysctrl12_clr" protect="rw"/>
      <reg name="sysctrl13_clr" protect="rw"/>
      <reg name="sysctrl14_clr" protect="rw"/>
      <reg name="sysctrl15_clr" protect="rw"/>
      <reg name="sysctrl16_clr" protect="rw"/>
      <reg name="sysctrl17_clr" protect="rw"/>
      <reg name="sysctrl18_clr" protect="rw"/>
      <reg name="sysctrl19_clr" protect="rw"/>
      <reg name="sysctrl20_clr" protect="rw"/>
      <reg name="sysctrl21_clr" protect="rw"/>
      <reg name="sysctrl22_clr" protect="rw"/>
      <reg name="sysctrl23_clr" protect="rw"/>
      <reg name="sysctrl24_clr" protect="rw"/>
      <reg name="sysctrl25_clr" protect="rw"/>
      <hole size="608"/>
      <reg name="sysctrl42_clr" protect="rw"/>
      <reg name="sysctrl43_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="sysctrl46_clr" protect="rw"/>
      <reg name="sysctrl47_clr" protect="rw"/>
      <reg name="sysctrl48_clr" protect="rw"/>
      <reg name="sysctrl49_clr" protect="rw"/>
      <reg name="sysctrl50_clr" protect="rw"/>
    </module>
    <var name="REG_RF_SYSCTRL_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_SYSCTRL_CLR_OFFSET" value="0x800"/>
    <instance address="0x50035000" name="RF_SYSCTRL" type="RF_SYSCTRL"/>
  </archive>
  <archive relative="rf_txdlpf.xml">
    <module category="System" name="RF_TXDLPF">
      <reg name="dlpf_ctrl_reg" protect="rw">
        <comment/>
        <bits access="rw" name="notch_en_sel_status3" pos="15" rst="0x0">
          <comment>DLPF notch bypass status3
1: notch bypass when the value of dlpf_det_status is less than 3</comment>
        </bits>
        <bits access="rw" name="sdm_bypass" pos="14" rst="0x0">
          <comment>DLPF sdm bypass</comment>
        </bits>
        <bits access="rw" name="notch_en_sel_status2" pos="13" rst="0x0">
          <comment>DLPF notch bypass status2
1: notch bypass when the value of dlpf_det_status is less than 2</comment>
        </bits>
        <bits access="rw" name="tdc_cal_clk_inv" pos="12" rst="0x0">
          <comment>gro mode tdc cal clk out inverse</comment>
        </bits>
        <bits access="rw" name="pha_err_clk_inv" pos="11" rst="0x0">
          <comment>gro mode phase err clk out inverse</comment>
        </bits>
        <bits access="rw" name="tdc_dout_clk_inv" pos="10" rst="0x0">
          <comment>gro mode tdc cal reg clk inverse</comment>
        </bits>
        <bits access="rw" name="pha_dout_clk_inv" pos="9" rst="0x0">
          <comment>gro mode phase err reg clk inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_mdll_num" pos="8:6" rst="0x5">
          <comment>DLPF MDLL mode
000: 26x2MHz
001: 26x3MHz
010: 26x4MHz
011: 26x5MHz
100: 26x6MHz
101: 26x7MHz
110: 26x8MHz
111: 26x9MHz</comment>
        </bits>
        <bits access="rw" name="dlpf_notch_bypass" pos="5" rst="0x0">
          <comment>DLPF notch bypass</comment>
        </bits>
        <bits access="rw" name="dlpf_clk_inv1_reg" pos="4" rst="0x0">
          <comment>DLPF output clock inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_clk_inv0_reg" pos="3" rst="0x0">
          <comment>DLPF input clock inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_lock_mode" pos="2" rst="0x1">
          <comment>DLPF lock mode</comment>
        </bits>
        <bits access="rw" name="dlpf_en" pos="1" rst="0x0">
          <comment>enable DLPF</comment>
        </bits>
      </reg>
      <reg name="dlpf_dr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_dr_mode" pos="14" rst="0x0">
          <comment>DLPF output direct control</comment>
        </bits>
        <bits access="rw" name="dlpf_dr_value" pos="13:0" rst="0x2000">
          <comment>DLPF output direct value</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_pha_offset_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_pha_offset" pos="15:0" rst="0xc8">
          <comment>DLPF afc phase offset</comment>
        </bits>
      </reg>
      <reg name="dlpf_kdco_pha_offset_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_kdco_pha_offset" pos="15:0" rst="0xc8">
          <comment>DLPF kdco phase offset</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_afc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_afc" pos="12:0" rst="0xa8">
          <comment>DLPF gain kp afc</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_afc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_afc" pos="15:0" rst="0x3f">
          <comment>DLPF gain ki afc</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_2m_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_2m" pos="12:0" rst="0x698">
          <comment>DLPF gain kp 2m</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_2m_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_2m" pos="15:0" rst="0x27d">
          <comment>DLPF gain ki 2m</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_200k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_200k" pos="12:0" rst="0xa8">
          <comment>DLPF gain kp 200k</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_200k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_200k" pos="15:0" rst="0x3f">
          <comment>DLPF gain ki 200k</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_gain0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir0_gain0" pos="15:0" rst="0xf8dd">
          <comment>DLPF IIR0 gain0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_gain1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir0_gain1" pos="15:0" rst="0x391">
          <comment>DLPF IIR0 gain1[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_gain0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain0" pos="15:0" rst="0x8522">
          <comment>DLPF IIR1 gain0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_gain1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain1" pos="15:0" rst="0x3d6e">
          <comment>DLPF IIR1 gain1[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir_gain_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain1_msb" pos="3" rst="0x0">
          <comment>DLPF IIR1 gain1[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir1_gain0_msb" pos="2" rst="0x0">
          <comment>DLPF IIR1 gain0[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir0_gain1_msb" pos="1" rst="0x0">
          <comment>DLPF IIR0 gain1[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir0_gain0_msb" pos="0" rst="0x0">
          <comment>DLPF IIR0 gain0[16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_diff_sel_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_diff_sel" pos="2:0" rst="0x2">
          <comment>dlpf_diff_sel value is set to reserved value</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>afc_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_diff_thr_msb" pos="15:0" rst="0x8">
          <comment>afc_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_cnt_thr" pos="15:0" rst="0x64">
          <comment>minimum value of afc_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>lock_2m_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_diff_thr_msb" pos="15:0" rst="0x8">
          <comment>lock_2m_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_cnt_thr" pos="15:0" rst="0xc8">
          <comment>minimum value of lock_2m_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>lock_200k_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_diff_thr_msb" pos="15:0" rst="0x2">
          <comment>lock_200k_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_cnt_thr" pos="15:0" rst="0x258">
          <comment>minimum value of lock_200k_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer0_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer0_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer0_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer0_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer0_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer0_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer1_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer1_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer1_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer1_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer1_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer1_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer2_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer2_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer2_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer2_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer2_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer2_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_capture_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_capture_en" pos="0" rst="0x0">
          <comment>DLPF capture enable to dump internal values</comment>
        </bits>
      </reg>
      <reg name="dlpf_status0_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_afc_code" pos="12:2" rst="0x400">
          <comment>real time afc_code</comment>
        </bits>
        <bits access="r" name="dlpf_det_status" pos="1:0" rst="0x0">
          <comment>DLPF detect status</comment>
        </bits>
      </reg>
      <reg name="dlpf_status1_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_kdco_code" pos="13:0" rst="0x2000">
          <comment>read time kdco_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_code_status" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_afc_code_reg" pos="10:0" rst="0x0">
          <comment>captured afc_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_kdco_code_status" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_kdco_code_reg" pos="13:0" rst="0x0">
          <comment>captured kdco_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_tdc_code_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_tdc_code" pos="15:0" rst="0x0">
          <comment>tdc_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_l_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_l" pos="15:0" rst="0x0">
          <comment>dlpf_sum0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_m_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_m" pos="15:0" rst="0x0">
          <comment>dlpf_sum0[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_h_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_h" pos="6:0" rst="0x0">
          <comment>dlpf_sum0[38:32]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_data_lsb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir0_data_lsb" pos="15:0" rst="0x0">
          <comment>iir0_data[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_data_msb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir0_data_msb" pos="15:0" rst="0x0">
          <comment>iir0_data[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_data_lsb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir1_data_lsb" pos="15:0" rst="0x0">
          <comment>iir1_data[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_data_msb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir1_data_msb" pos="15:0" rst="0x0">
          <comment>iir1_data[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_ctrl_bit_reg" protect="rw">
        <comment/>
        <bits access="rw" name="capture_data_sel_tdc" pos="8" rst="0x1"/>
        <bits access="rw" name="sel_clk_out2_inv" pos="7" rst="0x0"/>
        <bits access="rw" name="sel_clk_out1_inv" pos="6" rst="0x0"/>
        <bits access="rw" name="kdco_polar_sel" pos="5" rst="0x0"/>
        <bits access="rw" name="kdco_agc_mode" pos="4" rst="0x0"/>
        <bits access="rw" name="2m_lock_bypass" pos="3" rst="0x0"/>
        <bits access="rw" name="afc_bypass" pos="2" rst="0x0"/>
        <bits access="rw" name="iir1_bypass" pos="1" rst="0x0"/>
        <bits access="rw" name="iir0_bypass" pos="0" rst="0x0"/>
      </reg>
      <reg name="gro_phase_tdc_cal" protect="rw">
        <comment/>
        <bits access="r" name="phase_tdc_cal" pos="15:0" rst="0x0"/>
      </reg>
      <hole size="6720"/>
      <reg name="dlpf_ctrl_reg_set" protect="rw"/>
      <hole size="1376"/>
      <reg name="dlpf_ctrl_bit_reg_set" protect="rw"/>
      <hole size="6752"/>
      <reg name="dlpf_ctrl_reg_clr" protect="rw"/>
      <hole size="1376"/>
      <reg name="dlpf_ctrl_bit_reg_clr" protect="rw"/>
    </module>
    <var name="REG_RF_TXDLPF_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_TXDLPF_CLR_OFFSET" value="0x800"/>
    <instance address="0x50033000" name="RF_TXDLPF" type="RF_TXDLPF"/>
  </archive>
  <archive relative="rf_tsen.xml">
    <module category="System" name="RF_TSEN">
      <reg name="tst_tsen_bist_cfg" protect="rw">
        <comment/>
        <bits access="rw" name="tst_tsen_bist_bypass" pos="13" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_cfg0" pos="12:10" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_cfg1" pos="9:7" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_cfg2" pos="6:4" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_cfg3" pos="3:1" rst="0x0"/>
      </reg>
      <reg name="tst_tsen_bist_time_sel" protect="rw">
        <comment/>
        <bits access="rw" name="tst_tsen_bist_code_in" pos="12:10" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_code_sel" pos="9" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_time_sel_cfg3" pos="8:7" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_time_sel_cfg2" pos="6:5" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_time_sel_cfg1" pos="4:3" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_time_sel_cfg0" pos="2:1" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="tst_bist_sel" protect="rw">
        <comment/>
        <bits access="rw" name="pad_oe_osc_data" pos="12" rst="0x0"/>
        <bits access="rw" name="pad_ie_osc_data" pos="11" rst="0x0"/>
        <bits access="rw" name="pad_oe_osc_clk" pos="10" rst="0x0"/>
        <bits access="rw" name="pad_ie_osc_clk" pos="9" rst="0x0"/>
        <bits access="rw" name="pad_oe_tsx_adc_ch_sel" pos="8" rst="0x0"/>
        <bits access="rw" name="pad_ie_tsx_adc_ch_sel" pos="7" rst="0x0"/>
        <bits access="rw" name="pad_oe_tsx_data" pos="6" rst="0x0"/>
        <bits access="rw" name="pad_ie_tsx_data" pos="5" rst="0x0"/>
        <bits access="rw" name="pad_oe_tsx_clk" pos="4" rst="0x0"/>
        <bits access="rw" name="pad_ie_tsx_clk" pos="3" rst="0x0"/>
        <bits access="rw" name="tsen_adc_ch_sel_pad" pos="2" rst="0x0"/>
        <bits access="rw" name="tsen_adc_ch_sel_src" pos="1" rst="0x0"/>
        <bits access="rw" name="tsen_adc_rst_sel_src" pos="0" rst="0x0"/>
      </reg>
      <reg name="tst_bist_res" protect="rw">
        <comment/>
        <bits access="r" name="tsen_bist_code" pos="3:1"/>
        <bits access="r" name="tst_tsen_bist_done" pos="0"/>
      </reg>
      <reg name="tst_tsen_c0_test_res0" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c0_res0" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c0_test_res1" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c0_res1" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c0_test_res2" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c0_res2" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c0_test_res3" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c0_res3" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c1_test_res0" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c1_res0" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c1_test_res1" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c1_res1" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c1_test_res2" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c1_res2" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c1_test_res3" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c1_res3" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c2_test_res0" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c2_res0" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c2_test_res1" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c2_res1" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c2_test_res2" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c2_res2" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c2_test_res3" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c2_res3" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c3_test_res0" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c3_res0" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c3_test_res1" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c3_res1" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c3_test_res2" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c3_res2" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c3_test_res3" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c3_res3" pos="15:0"/>
      </reg>
      <hole size="7552"/>
      <reg name="tst_tsen_bist_cfg_set" protect="rw"/>
      <reg name="tst_tsen_bist_time_sel_set" protect="rw"/>
      <reg name="tst_bist_sel_set" protect="rw"/>
      <hole size="8096"/>
      <reg name="tst_tsen_bist_cfg_clr" protect="rw"/>
      <reg name="tst_tsen_bist_time_sel_clr" protect="rw"/>
      <reg name="tst_bist_sel_clr" protect="rw"/>
    </module>
    <var name="REG_RF_TSEN_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_TSEN_CLR_OFFSET" value="0x800"/>
    <instance address="0x5003b000" name="RF_TSEN" type="RF_TSEN"/>
  </archive>
  <archive relative="reg_fw_sysctrl.xml">
    <module category="System" name="REG_FW_SYSCTRL">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="ahb2ahb_ab_dap_ctrl_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_funcdma_sts_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_funcdma_ctrl_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="apt_trigger_sel_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="dma_req_ctrl_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="emmc_slice_phy_ctrl_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_out_val_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_th_val_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_ctrl_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_debug_host_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart3_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart2_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mipi_csi_cfg_reg_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_soft_rst_ctrl1_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en3_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en2_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en1_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en0_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel3_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel2_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel1_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel0_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_en1_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_en0_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_lpc_ctrl_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_delay_num_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_en_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_mode_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rstctrl_lte_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clken_lte_intf_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clken_lte_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_soft_rst_ctrl0_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_1" protect="rw">
        <comment>REG_RD_CTRL_1 REG_RD_CTRL_1</comment>
        <bits access="rw" name="cfg_aon_io_core_ie_3_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_2_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_1_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_0_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_ahb2ahb_sync_cfg_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="dap_djtag_en_cfg_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_autogate_en_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_qos_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_anti_hang_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="plls_sts_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sysctrl_reg0_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_sts_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_ctrl_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_sts_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_ctrl_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="axi2axi_pub_sts_1_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="axi2axi_pub_sts_0_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2axi_pub_sts_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2axi_pub_ctrl_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_dap_sts_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="ahb2ahb_ab_dap_ctrl_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_funcdma_sts_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_funcdma_ctrl_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="apt_trigger_sel_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="dma_req_ctrl_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="emmc_slice_phy_ctrl_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_out_val_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_th_val_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_ctrl_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_debug_host_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart3_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart2_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mipi_csi_cfg_reg_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_soft_rst_ctrl1_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en3_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en2_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en1_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en0_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel3_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel2_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel1_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel0_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_en1_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_en0_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_lpc_ctrl_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_delay_num_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_en_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_mode_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rstctrl_lte_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clken_lte_intf_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clken_lte_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_soft_rst_ctrl0_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_1" protect="rw">
        <comment>REG_WR_CTRL_1 REG_WR_CTRL_1</comment>
        <bits access="rw" name="cfg_aon_io_core_ie_3_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_2_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_1_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_0_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_ahb2ahb_sync_cfg_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="dap_djtag_en_cfg_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_autogate_en_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_qos_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_anti_hang_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="plls_sts_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sysctrl_reg0_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_sts_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_ctrl_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_sts_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_ctrl_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="axi2axi_pub_sts_1_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="axi2axi_pub_sts_0_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2axi_pub_sts_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2axi_pub_ctrl_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_dap_sts_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array0" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY0 BIT_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_ctrl_addr_array0" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array1" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY1 BIT_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_ctrl_addr_array1" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array2" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY2 BIT_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_ctrl_addr_array2" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array3" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY3 BIT_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_ctrl_addr_array3" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array4" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY4 BIT_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_ctrl_addr_array4" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array5" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY5 BIT_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_ctrl_addr_array5" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array6" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY6 BIT_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_ctrl_addr_array6" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array7" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY7 BIT_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_ctrl_addr_array7" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array8" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY8 BIT_CTRL_ADDR_ARRAY8</comment>
        <bits access="rw" name="bit_ctrl_addr_array8" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array8</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array9" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY9 BIT_CTRL_ADDR_ARRAY9</comment>
        <bits access="rw" name="bit_ctrl_addr_array9" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array9</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array10" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY10 BIT_CTRL_ADDR_ARRAY10</comment>
        <bits access="rw" name="bit_ctrl_addr_array10" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array10</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array11" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY11 BIT_CTRL_ADDR_ARRAY11</comment>
        <bits access="rw" name="bit_ctrl_addr_array11" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array11</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array12" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY12 BIT_CTRL_ADDR_ARRAY12</comment>
        <bits access="rw" name="bit_ctrl_addr_array12" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array12</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array13" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY13 BIT_CTRL_ADDR_ARRAY13</comment>
        <bits access="rw" name="bit_ctrl_addr_array13" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array13</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array14" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY14 BIT_CTRL_ADDR_ARRAY14</comment>
        <bits access="rw" name="bit_ctrl_addr_array14" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array14</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array15" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY15 BIT_CTRL_ADDR_ARRAY15</comment>
        <bits access="rw" name="bit_ctrl_addr_array15" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array15</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_array0" protect="rw">
        <comment>BIT_CTRL_ARRAY0 BIT_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_ctrl_array1" protect="rw">
        <comment>BIT_CTRL_ARRAY1 BIT_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_ctrl_array2" protect="rw">
        <comment>BIT_CTRL_ARRAY2 BIT_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_ctrl_array3" protect="rw">
        <comment>BIT_CTRL_ARRAY3 BIT_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_ctrl_array4" protect="rw">
        <comment>BIT_CTRL_ARRAY4 BIT_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_ctrl_array5" protect="rw">
        <comment>BIT_CTRL_ARRAY5 BIT_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_ctrl_array6" protect="rw">
        <comment>BIT_CTRL_ARRAY6 BIT_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_ctrl_array7" protect="rw">
        <comment>BIT_CTRL_ARRAY7 BIT_CTRL_ARRAY7</comment>
      </reg>
      <reg name="bit_ctrl_array8" protect="rw">
        <comment>BIT_CTRL_ARRAY8 BIT_CTRL_ARRAY8</comment>
      </reg>
      <reg name="bit_ctrl_array9" protect="rw">
        <comment>BIT_CTRL_ARRAY9 BIT_CTRL_ARRAY9</comment>
      </reg>
      <reg name="bit_ctrl_array10" protect="rw">
        <comment>BIT_CTRL_ARRAY10 BIT_CTRL_ARRAY10</comment>
      </reg>
      <reg name="bit_ctrl_array11" protect="rw">
        <comment>BIT_CTRL_ARRAY11 BIT_CTRL_ARRAY11</comment>
      </reg>
      <reg name="bit_ctrl_array12" protect="rw">
        <comment>BIT_CTRL_ARRAY12 BIT_CTRL_ARRAY12</comment>
      </reg>
      <reg name="bit_ctrl_array13" protect="rw">
        <comment>BIT_CTRL_ARRAY13 BIT_CTRL_ARRAY13</comment>
      </reg>
      <reg name="bit_ctrl_array14" protect="rw">
        <comment>BIT_CTRL_ARRAY14 BIT_CTRL_ARRAY14</comment>
      </reg>
      <reg name="bit_ctrl_array15" protect="rw">
        <comment>BIT_CTRL_ARRAY15 BIT_CTRL_ARRAY15</comment>
      </reg>
    </module>
    <instance address="0x51305000" name="REG_FW_SYSCTRL" type="REG_FW_SYSCTRL"/>
  </archive>
  <archive relative="reg_fw_pwrctrl.xml">
    <module category="System" name="REG_FW_PWRCTRL">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="pwrctrl_sm_state_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_cp_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_ap_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="slp_timeout_flag_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="slp_bypass_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="psram_hold_ctrl_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pd_d_delay_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pd_m_delay_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="state_delay_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gnss_pwr_stat_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_pwr_stat_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_pwr_stat_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rf_pwr_stat_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pub_pwr_stat_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pwr_stat_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pwr_stat_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gnss_pwr_ctrl_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_pwr_ctrl_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_pwr_ctrl_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rf_pwr_ctrl_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pub_pwr_ctrl_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pwr_ctrl_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pwr_ctrl_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_hwen_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="pwrctrl_sm_state_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_cp_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_ap_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="slp_timeout_flag_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="slp_bypass_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="psram_hold_ctrl_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pd_d_delay_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pd_m_delay_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="state_delay_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gnss_pwr_stat_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_pwr_stat_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_pwr_stat_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rf_pwr_stat_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pub_pwr_stat_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pwr_stat_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pwr_stat_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gnss_pwr_ctrl_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_pwr_ctrl_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_pwr_ctrl_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rf_pwr_ctrl_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pub_pwr_ctrl_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pwr_ctrl_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pwr_ctrl_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_hwen_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array0" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY0 BIT_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_ctrl_addr_array0" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array1" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY1 BIT_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_ctrl_addr_array1" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array2" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY2 BIT_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_ctrl_addr_array2" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array3" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY3 BIT_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_ctrl_addr_array3" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array4" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY4 BIT_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_ctrl_addr_array4" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array5" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY5 BIT_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_ctrl_addr_array5" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array6" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY6 BIT_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_ctrl_addr_array6" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array7" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY7 BIT_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_ctrl_addr_array7" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_array0" protect="rw">
        <comment>BIT_CTRL_ARRAY0 BIT_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_ctrl_array1" protect="rw">
        <comment>BIT_CTRL_ARRAY1 BIT_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_ctrl_array2" protect="rw">
        <comment>BIT_CTRL_ARRAY2 BIT_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_ctrl_array3" protect="rw">
        <comment>BIT_CTRL_ARRAY3 BIT_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_ctrl_array4" protect="rw">
        <comment>BIT_CTRL_ARRAY4 BIT_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_ctrl_array5" protect="rw">
        <comment>BIT_CTRL_ARRAY5 BIT_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_ctrl_array6" protect="rw">
        <comment>BIT_CTRL_ARRAY6 BIT_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_ctrl_array7" protect="rw">
        <comment>BIT_CTRL_ARRAY7 BIT_CTRL_ARRAY7</comment>
      </reg>
    </module>
    <instance address="0x51315000" name="REG_FW_PWRCTRL" type="REG_FW_PWRCTRL"/>
  </archive>
  <archive relative="reg_fw_lps_apb.xml">
    <module category="System" name="REG_FW_LPS_APB">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="cfg_io_deep_sleep_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pu_clk26m_lp_iso_cfg_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_uart_swj_share_cfg_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_lp_ctrl_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc26m_pu_ctrl_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efs_por_read_block89_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efs_por_read_block3_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_por_usb_phy_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="iomux_g4_func_sel_latch_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_iram_ctrl_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="iispll_wait_number_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mpll_wait_number_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="apll_wait_number_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_plls_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_cause_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_reset_enable_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_boot_mode_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_gpt_lite_clock_sel_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_uart1_clock_sel_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_lps_ahb_clock_sel_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_psram_half_slp_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_debug_bond_option_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_rc26m_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart1_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_busy_status_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_gate_en_status_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_force_en_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_auto_sel_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_en_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efuse_por_read_disable_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_lps_soft_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_sys_soft_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_1" protect="rw">
        <comment>REG_RD_CTRL_1 REG_RD_CTRL_1</comment>
        <bits access="rw" name="cfg_simc_io_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_lps_io_core_ie_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="cfg_io_deep_sleep_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pu_clk26m_lp_iso_cfg_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_uart_swj_share_cfg_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_lp_ctrl_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc26m_pu_ctrl_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efs_por_read_block89_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efs_por_read_block3_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_por_usb_phy_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="iomux_g4_func_sel_latch_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_iram_ctrl_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="iispll_wait_number_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mpll_wait_number_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="apll_wait_number_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_plls_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_cause_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_reset_enable_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_boot_mode_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_gpt_lite_clock_sel_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_uart1_clock_sel_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_lps_ahb_clock_sel_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_psram_half_slp_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_debug_bond_option_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_rc26m_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart1_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_busy_status_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_gate_en_status_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_force_en_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_auto_sel_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_en_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efuse_por_read_disable_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_lps_soft_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_sys_soft_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_1" protect="rw">
        <comment>REG_WR_CTRL_1 REG_WR_CTRL_1</comment>
        <bits access="rw" name="cfg_simc_io_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_lps_io_core_ie_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array0" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY0 BIT_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_ctrl_addr_array0" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array1" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY1 BIT_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_ctrl_addr_array1" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array2" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY2 BIT_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_ctrl_addr_array2" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array3" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY3 BIT_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_ctrl_addr_array3" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array4" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY4 BIT_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_ctrl_addr_array4" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array5" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY5 BIT_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_ctrl_addr_array5" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array6" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY6 BIT_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_ctrl_addr_array6" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array7" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY7 BIT_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_ctrl_addr_array7" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_array0" protect="rw">
        <comment>BIT_CTRL_ARRAY0 BIT_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_ctrl_array1" protect="rw">
        <comment>BIT_CTRL_ARRAY1 BIT_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_ctrl_array2" protect="rw">
        <comment>BIT_CTRL_ARRAY2 BIT_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_ctrl_array3" protect="rw">
        <comment>BIT_CTRL_ARRAY3 BIT_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_ctrl_array4" protect="rw">
        <comment>BIT_CTRL_ARRAY4 BIT_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_ctrl_array5" protect="rw">
        <comment>BIT_CTRL_ARRAY5 BIT_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_ctrl_array6" protect="rw">
        <comment>BIT_CTRL_ARRAY6 BIT_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_ctrl_array7" protect="rw">
        <comment>BIT_CTRL_ARRAY7 BIT_CTRL_ARRAY7</comment>
      </reg>
    </module>
    <instance address="0x51316000" name="REG_FW_LPS_APB" type="REG_FW_LPS_APB"/>
  </archive>
  <archive relative="reg_fw_idle_lps.xml">
    <module category="System" name="REG_FW_IDLE_LPS">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="lps_t_time5_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time4_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time3_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time2_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time1_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p2_time_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p1_time_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_lps_sta_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_st_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_en_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_st_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_en_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_int_sta_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_inten_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_int_sta_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_inten_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_lps_sta_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="eliminate_jitter_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sleep_prot_time_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_sig_en_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pm2_mode_en_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pm2_sta_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_on_off_time_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_on_time_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_off_time_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_lps_sig_time_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_sig_en_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pm2_sta_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_ctrl_cp_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_lps_sig_time_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_sig_en_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_ctrl_ap_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_1" protect="rw">
        <comment>REG_RD_CTRL_1 REG_RD_CTRL_1</comment>
        <bits access="rw" name="cp_awk_st1_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_en1_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_st1_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_en1_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t6_en_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t5_en_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t4_en_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t3_en_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t2_en_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t1_en_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p2_en_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p1_en_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res11_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res10_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res9_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res8_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res7_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res6_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res5_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res4_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res3_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res2_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res1_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res0_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mon_sel_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="load_time_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_tp_sta_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_tpctrl_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ref_32k_fnl_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_32k_ref_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="load_en_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time6_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_2" protect="rw">
        <comment>REG_RD_CTRL_2 REG_RD_CTRL_2</comment>
        <bits access="rw" name="cp_pm2_mode_en_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t9_en_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t8_en_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t7_en_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time9_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time8_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time7_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="lps_t_time5_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time4_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time3_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time2_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time1_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p2_time_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p1_time_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_lps_sta_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_st_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_en_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_st_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_en_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_int_sta_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_inten_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_int_sta_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_inten_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_lps_sta_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="eliminate_jitter_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sleep_prot_time_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_sig_en_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pm2_mode_en_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pm2_sta_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_on_off_time_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_on_time_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_off_time_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_lps_sig_time_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_sig_en_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pm2_sta_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_ctrl_cp_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_lps_sig_time_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_sig_en_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_ctrl_ap_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_1" protect="rw">
        <comment>REG_WR_CTRL_1 REG_WR_CTRL_1</comment>
        <bits access="rw" name="cp_awk_st1_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_en1_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_st1_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_en1_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t6_en_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t5_en_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t4_en_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t3_en_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t2_en_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t1_en_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p2_en_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p1_en_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res11_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res10_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res9_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res8_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res7_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res6_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res5_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res4_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res3_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res2_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res1_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res0_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mon_sel_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="load_time_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_tp_sta_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_tpctrl_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ref_32k_fnl_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_32k_ref_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="load_en_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time6_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_2" protect="rw">
        <comment>REG_WR_CTRL_2 REG_WR_CTRL_2</comment>
        <bits access="rw" name="cp_pm2_mode_en_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t9_en_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t8_en_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t7_en_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time9_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time8_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time7_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array0" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY0 BIT_WR_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array0" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array1" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY1 BIT_WR_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array1" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array2" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY2 BIT_WR_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array2" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array3" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY3 BIT_WR_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array3" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array4" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY4 BIT_WR_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array4" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array5" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY5 BIT_WR_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array5" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array6" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY6 BIT_WR_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array6" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array7" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY7 BIT_WR_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array7" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array8" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY8 BIT_WR_CTRL_ADDR_ARRAY8</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array8" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array8</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array9" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY9 BIT_WR_CTRL_ADDR_ARRAY9</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array9" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array9</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array10" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY10 BIT_WR_CTRL_ADDR_ARRAY10</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array10" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array10</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array11" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY11 BIT_WR_CTRL_ADDR_ARRAY11</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array11" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array11</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array12" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY12 BIT_WR_CTRL_ADDR_ARRAY12</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array12" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array12</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array13" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY13 BIT_WR_CTRL_ADDR_ARRAY13</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array13" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array13</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array14" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY14 BIT_WR_CTRL_ADDR_ARRAY14</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array14" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array14</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array15" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY15 BIT_WR_CTRL_ADDR_ARRAY15</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array15" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array15</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_array0" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY0 BIT_WR_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_wr_ctrl_array1" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY1 BIT_WR_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_wr_ctrl_array2" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY2 BIT_WR_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_wr_ctrl_array3" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY3 BIT_WR_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_wr_ctrl_array4" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY4 BIT_WR_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_wr_ctrl_array5" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY5 BIT_WR_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_wr_ctrl_array6" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY6 BIT_WR_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_wr_ctrl_array7" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY7 BIT_WR_CTRL_ARRAY7</comment>
      </reg>
      <reg name="bit_wr_ctrl_array8" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY8 BIT_WR_CTRL_ARRAY8</comment>
      </reg>
      <reg name="bit_wr_ctrl_array9" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY9 BIT_WR_CTRL_ARRAY9</comment>
      </reg>
      <reg name="bit_wr_ctrl_array10" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY10 BIT_WR_CTRL_ARRAY10</comment>
      </reg>
      <reg name="bit_wr_ctrl_array11" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY11 BIT_WR_CTRL_ARRAY11</comment>
      </reg>
      <reg name="bit_wr_ctrl_array12" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY12 BIT_WR_CTRL_ARRAY12</comment>
      </reg>
      <reg name="bit_wr_ctrl_array13" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY13 BIT_WR_CTRL_ARRAY13</comment>
      </reg>
      <reg name="bit_wr_ctrl_array14" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY14 BIT_WR_CTRL_ARRAY14</comment>
      </reg>
      <reg name="bit_wr_ctrl_array15" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY15 BIT_WR_CTRL_ARRAY15</comment>
      </reg>
    </module>
    <instance address="0x51314000" name="REG_FW_IDLE_LPS" type="REG_FW_IDLE_LPS"/>
  </archive>
  <archive relative="lps_apb.xml">
    <module category="System" name="LPS_APB">
      <reg name="reset_sys_soft" protect="rw">
        <comment>RESET_SYS_SOFT</comment>
        <bits access="rw" name="chip_soft_reset" pos="7" rst="0x0"/>
        <bits access="rw" name="rf_sys_soft_reset" pos="6" rst="0x0"/>
        <bits access="rw" name="pub_sys_soft_reset" pos="5" rst="0x0"/>
        <bits access="rw" name="usb_sys_soft_reset" pos="4" rst="0x0"/>
        <bits access="rw" name="gnss_sys_soft_reset" pos="3" rst="0x0"/>
        <bits access="rw" name="lte_sys_soft_reset" pos="2" rst="0x0"/>
        <bits access="rw" name="cp_sys_soft_reset" pos="1" rst="0x0"/>
        <bits access="rw" name="ap_sys_soft_reset" pos="0" rst="0x0"/>
      </reg>
      <reg name="reset_lps_soft" protect="rw">
        <comment>RESET_LPS_SOFT</comment>
        <bits access="rw" name="rtc_timer_soft_reset" pos="7" rst="0x0"/>
        <bits access="rw" name="rc26m_calib_soft_reset" pos="6" rst="0x0"/>
        <bits access="rw" name="iomux_g4_soft_reset" pos="5" rst="0x0"/>
        <bits access="rw" name="ana_wrap3_soft_reset" pos="4" rst="0x0"/>
        <bits access="rw" name="uart1_soft_reset" pos="3" rst="0x0"/>
        <bits access="rw" name="keypad_soft_reset" pos="2" rst="0x0"/>
        <bits access="rw" name="gpio1_soft_reset" pos="1" rst="0x0"/>
        <bits access="rw" name="gpt1_soft_reset" pos="0" rst="0x0"/>
      </reg>
      <reg name="efuse_por_read_disable" protect="rw">
        <comment>EFUSE_POR_READ_DISABLE</comment>
        <bits access="rw" name="efuse_sel_flag" pos="2:1" rst="0x0">
          <comment>reference &quot;efuse_design_specification.docx&quot;</comment>
        </bits>
        <bits access="rw" name="efuse_por_read_disable" pos="0" rst="0x0"/>
      </reg>
      <reg name="lps_clk_en" protect="rw">
        <comment>LPS_CLK_EN</comment>
        <bits access="rw" name="lps_ahb_aon_en" pos="7" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rtc_timer_en" pos="6" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pwrctrl_en" pos="5" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uart1_en" pos="4" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="keypad_en" pos="3" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="idle_lps_en" pos="2" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gpt1_en" pos="1" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gpio1_en" pos="0" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="lps_clk_auto_sel" protect="rw">
        <comment>LPS_CLK_AUTO_SEL</comment>
      </reg>
      <reg name="lps_clk_force_en" protect="rw">
        <comment>LPS_CLK_FORCE_EN</comment>
      </reg>
      <reg name="lps_clk_gate_en_status" protect="rw">
        <comment>LPS_CLK_GATE_EN_STATUS</comment>
      </reg>
      <reg name="lps_clk_busy_status" protect="rw">
        <comment>LPS_CLK_BUSY_STATUS</comment>
      </reg>
      <reg name="cfg_clk_uart1" protect="rw">
        <comment>CFG_CLK_UART1</comment>
        <bits access="rw" name="cfg_clk_uart1_update" pos="31" rst="0x0"/>
        <bits access="rw" name="cfg_clk_uart1_demod" pos="29:16" rst="0x7"/>
        <bits access="rw" name="cfg_clk_uart1_num" pos="9:0" rst="0x1"/>
      </reg>
      <reg name="cfg_clk_rc26m" protect="rw">
        <comment>CFG_CLK_RC26M</comment>
        <bits access="rw" name="cfg_clk_rc26m_update" pos="31" rst="0x0"/>
        <bits access="rw" name="cfg_clk_rc26m_demod" pos="29:16" rst="0x1"/>
        <bits access="rw" name="cfg_clk_rc26m_num" pos="9:0" rst="0x1"/>
      </reg>
      <reg name="cfg_debug_bond_option" protect="rw">
        <comment>CFG_DEBUG_BOND_OPTION</comment>
        <bits access="rw" name="bond_sec_dap_en" pos="18" rst="0x0"/>
        <bits access="rw" name="bond_fdma_boot_cpu_en" pos="17" rst="0x0"/>
        <bits access="rw" name="bond_dbghost_en" pos="16" rst="0x0"/>
        <bits access="rw" name="bond_pad_jtag_en" pos="15" rst="0x0"/>
        <bits access="rw" name="bond_djtag_en" pos="14" rst="0x0"/>
        <bits access="rw" name="bond_swd_dbg_sys_en" pos="13" rst="0x0"/>
        <bits access="rw" name="bond_fdma_en" pos="12" rst="0x0"/>
        <bits access="rw" name="bond_cp_ca5_spniden" pos="11" rst="0x0"/>
        <bits access="rw" name="bond_cp_ca5_spiden" pos="10" rst="0x0"/>
        <bits access="rw" name="bond_cp_ca5_niden" pos="9" rst="0x0"/>
        <bits access="rw" name="bond_cp_ca5_dbgen" pos="8" rst="0x0"/>
        <bits access="rw" name="bond_cp_ca5_dap_deviceen" pos="7" rst="0x0"/>
        <bits access="rw" name="bond_ap_ca5_spniden" pos="6" rst="0x0"/>
        <bits access="rw" name="bond_ap_ca5_spiden" pos="5" rst="0x0"/>
        <bits access="rw" name="bond_ap_ca5_niden" pos="4" rst="0x0"/>
        <bits access="rw" name="bond_ap_ca5_dbgen" pos="3" rst="0x0"/>
        <bits access="rw" name="bond_ap_ca5_dap_deviceen" pos="2" rst="0x0"/>
        <bits access="rw" name="bond_swd_jtag_en" pos="1" rst="0x0"/>
        <bits access="r" name="bond_option_wr_flag" pos="0" rst="0x0"/>
      </reg>
      <reg name="cfg_psram_half_slp" protect="rw">
        <comment>CFG_PSRAM_HALF_SLP</comment>
        <bits access="rw" name="half_slp_req" pos="0" rst="0x0">
          <comment>0: PSRAM macro do not in half-sleep mode when PSRAM controller power-down
1: PSRAM macro in  half-sleep mode when PSRAM controller power-down</comment>
        </bits>
      </reg>
      <reg name="cfg_lps_ahb_clock_sel" protect="rw">
        <comment>CFG_LPS_AHB_CLOCK_SEL</comment>
        <bits access="rw" name="cgm_lps_ahb_sel" pos="1:0" rst="0x2">
          <comment>0:rtc_32k
1:xtal_lp_26m
2:xtal_26m
3:rc_26m</comment>
        </bits>
      </reg>
      <reg name="cfg_uart1_clock_sel" protect="rw">
        <comment>CFG_UART1_CLOCK_SEL</comment>
        <bits access="rw" name="cgm_uart1_bf_div_sel" pos="1:0" rst="0x2">
          <comment>0:rtc_32k
1:xtal_lp_2tm
2:xtal_26m
3:rc_26m</comment>
        </bits>
      </reg>
      <reg name="cfg_gpt_lite_clock_sel" protect="rw">
        <comment>CFG_GPT_LITE_CLOCK_SEL</comment>
        <bits access="rw" name="cgm_gpt_lite_sel" pos="1:0" rst="0x2">
          <comment>0:rtc_32k
1:xtal_lp_2tm
2:xtal_26m
3:rc_26m</comment>
        </bits>
      </reg>
      <reg name="cfg_boot_mode" protect="rw">
        <comment>CFG_BOOT_MODE</comment>
        <bits access="r" name="function_test_mode" pos="10" rst="0x0"/>
        <bits access="rw" name="boot_mode_sw" pos="9:4" rst="0x0"/>
        <bits access="rw" name="boot_mode_pin" pos="2:0" rst="0x0">
          <comment>This contains the state of boot mode pins latched during Reset.
bit 0: Force download.
bit 1: EMMC boot.
bit 2: Unused.</comment>
        </bits>
      </reg>
      <reg name="cfg_reset_enable" protect="rw">
        <comment>CFG_RESET_ENABLE</comment>
        <bits access="rw" name="dbghost_reset_ap_cpu_enable" pos="12" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dbghost_reset_enable" pos="11" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pub_mem_fw_invalid_reset_raw_enable" pos="10" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_mem_fw_invalid_reset_raw_enable" pos="9" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_mem_fw_invalid_reset_raw_enable" pos="8" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pub_mem_fw_invalid_reset_enable" pos="7" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_mem_fw_invalid_reset_enable" pos="6" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_mem_fw_invalid_reset_enable" pos="5" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="invalid_clk_26m_reset_enable" pos="4" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="invalid_clk_32k_reset_enable" pos="3" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rf_wdt_reset_enable" pos="2" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_wdt_reset_enable" pos="1" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_wdt_reset_enable" pos="0" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="reset_cause" protect="rw">
        <comment>RESET_CAUSE</comment>
        <bits access="rw" name="soft_reset" pos="14" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="funcdma_reset_ap_cpu" pos="13" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dbghost_reset_ap_cpu" pos="12" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dbghost_reset" pos="11" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pub_mem_fw_invalid_reset_raw" pos="10" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_mem_fw_invalid_reset_raw" pos="9" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_mem_fw_invalid_reset_raw" pos="8" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pub_mem_fw_invalid_reset" pos="7" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_mem_fw_invalid_reset" pos="6" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_mem_fw_invalid_reset" pos="5" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="invalid_clk_26m_reset" pos="4" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="invalid_clk_32k_reset" pos="3" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rf_wdt_reset" pos="2" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_wdt_reset" pos="1" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_wdt_reset" pos="0" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cfg_plls" protect="rw">
        <comment>CFG_PLLS</comment>
        <bits access="rw" name="bbpll_pd_sel" pos="21" rst="0x1">
          <comment>0: select hardware auto control signal
1: select bbpll_pd_force as control signal</comment>
        </bits>
        <bits access="rw" name="bbpll_pd_force" pos="20" rst="0x0">
          <comment>0: power-up
1: power-down</comment>
        </bits>
        <bits access="rw" name="iispll_clkout_en_mode" pos="19" rst="0x0">
          <comment>select hardware control mode:(valid when iispll_clkout_en_sel bit is &quot;0&quot;)
0: idle_lps output signal control
1: clock plan signal auto control</comment>
        </bits>
        <bits access="rw" name="iispll_clkout_en_sel" pos="18" rst="0x1">
          <comment>0: select hardware auto control signal
1: select iispll_clkout_en_force as control signal</comment>
        </bits>
        <bits access="rw" name="iispll_clkout_en_force" pos="17" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="iispll_pd_sel" pos="16" rst="0x1">
          <comment>0: select hardware auto control signal
1: select iispll_pd_force as control signal</comment>
        </bits>
        <bits access="rw" name="iispll_pd_force" pos="15" rst="0x1">
          <comment>0: power-up
1: power-down</comment>
        </bits>
        <bits access="rw" name="mpll_pub_sel" pos="14" rst="0x0">
          <comment>0: MPLL clock is not selected in PUB_SYS
1: MPLL clock is secected in PUB_SYS</comment>
        </bits>
        <bits access="rw" name="mpll_clkout_en_mode" pos="13" rst="0x0">
          <comment>select hardware control mode:(valid when mpll_clkout_en_sel bit is &quot;0&quot;)
0: idle_lps output signal control
1: clock plan signal auto control</comment>
        </bits>
        <bits access="rw" name="mpll_clkout_en_sel" pos="12" rst="0x1">
          <comment>0: select hardware auto control signal
1: select mpll_clkout_en_force as control signal</comment>
        </bits>
        <bits access="rw" name="mpll_clkout_en_force" pos="11" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="mpll_pd_sel" pos="10" rst="0x1">
          <comment>0: select hardware auto control signal
1: select mpll_pd_force as control signal</comment>
        </bits>
        <bits access="rw" name="mpll_pd_force" pos="9" rst="0x0">
          <comment>0: power-up
1: power-down</comment>
        </bits>
        <bits access="rw" name="apll_ap_sel" pos="8" rst="0x0">
          <comment>0: APLL clock is not selected in AP_SYS
1: APLL clock is secected in AP_SYS</comment>
        </bits>
        <bits access="rw" name="apll_cp_sel" pos="7" rst="0x0">
          <comment>0: APLL clock is not selected in CP_SYS
1: APLL clock is secected in CP_SYS</comment>
        </bits>
        <bits access="rw" name="apll_pub_sel" pos="6" rst="0x0">
          <comment>0: APLL clock is not selected in PUB_SYS
1: APLL clock is secected in PUB_SYS</comment>
        </bits>
        <bits access="rw" name="apll_aon_sel" pos="5" rst="0x0">
          <comment>0: APLL clock is not selected in AON_SYS
1: APLL clock is secected in AON_SYS</comment>
        </bits>
        <bits access="rw" name="apll_clkout_en_mode" pos="4" rst="0x0">
          <comment>select hardware control mode:(valid when apll_clkout_en_sel bit is &quot;0&quot;)
0: idle_lps output signal control
1: clock plan signal auto control</comment>
        </bits>
        <bits access="rw" name="apll_clkout_en_sel" pos="3" rst="0x1">
          <comment>0: select hardware auto control signal
1: select apll_clkout_en_force as control signal</comment>
        </bits>
        <bits access="rw" name="apll_clkout_en_force" pos="2" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="apll_pd_sel" pos="1" rst="0x1">
          <comment>0: select hardware auto control signal
1: select apll_pd_force as control signal</comment>
        </bits>
        <bits access="rw" name="apll_pd_force" pos="0" rst="0x0">
          <comment>0: power-up
1: power-down</comment>
        </bits>
      </reg>
      <reg name="apll_wait_number" protect="rw">
        <comment>APLL_WAIT_NUMBER</comment>
        <bits access="rw" name="apll_clkout_en_high" pos="29:16" rst="0x28b0">
          <comment>From PLL_CLKOUT_EN posedge to PLL_PRECHARGE posedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="apll_precharge_high" pos="15:5" rst="0x30d">
          <comment>From PLL_RST negedge to PLL_PRECHARGE posedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="apll_rst_low" pos="4:0" rst="0x10">
          <comment>From PLL_PD negedge to PLL_RST negedge,use 26M clock count.</comment>
        </bits>
      </reg>
      <reg name="mpll_wait_number" protect="rw">
        <comment>MPLL_WAIT_NUMBER</comment>
        <bits access="rw" name="mpll_clkout_en_high" pos="29:16" rst="0x28b0">
          <comment>From PLL_CLKOUT_EN negedge to PLL_PRECHARGE negedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="mpll_precharge_high" pos="15:5" rst="0x30d">
          <comment>From PLL_RST negedge to PLL_PRECHARGE posedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="mpll_rst_low" pos="4:0" rst="0x10">
          <comment>From PLL_PD negedge to PLL_RST negedge,use 26M clock count.</comment>
        </bits>
      </reg>
      <reg name="iispll_wait_number" protect="rw">
        <comment>IISMPLL_WAIT_NUMBER</comment>
        <bits access="rw" name="iispll_clkout_en_high" pos="29:16" rst="0x28b0">
          <comment>From PLL_CLKOUT_EN negedge to PLL_PRECHARGE negedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="iispll_precharge_high" pos="15:5" rst="0x30d">
          <comment>From PLL_RST negedge to PLL_PRECHARGE posedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="iispll_rst_low" pos="4:0" rst="0x10">
          <comment>From PLL_PD negedge to PLL_RST negedge,use 26M clock count.</comment>
        </bits>
      </reg>
      <reg name="aon_iram_ctrl" protect="rw">
        <comment>AON_IRAM_CTRL</comment>
        <bits access="r" name="aon_iram2_pu_delay" pos="18" rst="0x0">
          <comment>AON_IRAM2 PU_DELAY port value</comment>
        </bits>
        <bits access="r" name="aon_iram1_pu_delay" pos="17" rst="0x0">
          <comment>AON_IRAM1 PU_DELAY port value</comment>
        </bits>
        <bits access="r" name="aon_iram0_pu_delay" pos="16" rst="0x0">
          <comment>AON_IRAM0 PU_DELAY port value</comment>
        </bits>
        <bits access="rw" name="aon_iram2_ctrl_hw" pos="15:14" rst="0x0">
          <comment>AON_IRAM2 hardware control. It work when chip in deep-sleep, and recover to normal mode when wake-up:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram1_ctrl_hw" pos="13:12" rst="0x0">
          <comment>AON_IRAM1 hardware control. It work when chip in deep-sleep, and recover to normal mode when wake-up:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram0_ctrl_hw" pos="11:10" rst="0x0">
          <comment>AON_IRAM0 hardware control. It work when chip in deep-sleep, and recover to normal mode when wake-up:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram2_ctrl_sw" pos="9:8" rst="0x0">
          <comment>AON_IRAM2 software control:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram1_ctrl_sw" pos="7:6" rst="0x0">
          <comment>AON_IRAM1 software control:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram0_ctrl_sw" pos="5:4" rst="0x0">
          <comment>AON_IRAM0 software control:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram2_ctrl_mode_sel" pos="2" rst="0x0">
          <comment>1: AON_IRAM2 control by aon_iram2_ctrl_hw[1:0]
0: AON_IRAM2 control by aon_iram2_ctrl_sw</comment>
        </bits>
        <bits access="rw" name="aon_iram1_ctrl_mode_sel" pos="1" rst="0x0">
          <comment>1: AON_IRAM1 control by aon_iram1_ctrl_hw[1:0]
0: AON_IRAM1 control by aon_iram1_ctrl_sw</comment>
        </bits>
        <bits access="rw" name="aon_iram0_ctrl_mode_sel" pos="0" rst="0x0">
          <comment>1: AON_IRAM0 control by aon_iram0_ctrl_hw[1:0]
0: AON_IRAM0 control by aon_iram0_ctrl_sw</comment>
        </bits>
      </reg>
      <reg name="iomux_g4_func_sel_latch" protect="rw">
        <comment>IOMUX_G4_FUNC_SEL_LATCH</comment>
        <bits access="rw" name="iomux_g4_func_sel_latch" pos="0" rst="0x0">
          <comment>This bit will be set to &quot;1&quot; by hardware to latch G4 pad function select when deepsleep, software should write &quot;0&quot; to release after iomux reinitial.</comment>
        </bits>
      </reg>
      <reg name="cfg_por_usb_phy" protect="rw">
        <comment>CFG_POR_USB_PHY</comment>
        <bits access="rw" name="usb_por_rst" pos="3" rst="0x0">
          <comment>power on reset,reset all state machines,
1: the transmit and receive FSM are reset,
0: the transmit and receive FSM are operational</comment>
        </bits>
        <bits access="rw" name="usb_iso_sw_en" pos="2" rst="0x0">
          <comment>1: ISO Cell Enable, signals will be gated and output iso value
0: ISO Cell Disable, normal mode</comment>
        </bits>
        <bits access="rw" name="usb_ps_pd_l" pos="1" rst="0x0">
          <comment>Digital in USBPHY Power gating control (large switch), when power up ,need delay 100us after PD_S set to 1'b0;
“1”: power gating the USB2.0 CORE
“0”: enable the CORE power</comment>
        </bits>
        <bits access="rw" name="usb_ps_pd_s" pos="0" rst="0x0">
          <comment>Digital in USBPHY Power gating control (small switch)
“1”: power gating the USB2.0 CORE power
“0”: enable the CORE power</comment>
        </bits>
      </reg>
      <reg name="efs_por_read_block3" protect="rw">
        <comment>EFS_POR_READ_BLOCK3</comment>
      </reg>
      <reg name="efs_por_read_block89" protect="rw">
        <comment>EFS_POR_READ_BLOCK89</comment>
      </reg>
      <reg name="rc26m_pu_ctrl" protect="rw">
        <comment>RC26M_PU_CTRL</comment>
        <bits access="rw" name="rc26m_pu_sw" pos="1" rst="0x1">
          <comment>“1”: power up
“0”: power down</comment>
        </bits>
        <bits access="rw" name="rc26m_pu_ctrl_mode" pos="0" rst="0x0">
          <comment>“1”: hw mode, RC26M PU controlled by &quot;pd_xtal&quot; hardware signal from IDLE_LPS module.
“0”: sw mode, RC26M PU controlled by &quot;rc26m_pu_sw&quot; register bit.</comment>
        </bits>
      </reg>
      <reg name="aon_ahb_lp_ctrl" protect="rw">
        <comment>AON_AHB_LP_CTRL</comment>
        <bits access="rw" name="aon_ahb_lslp_sel" pos="6" rst="0x0">
          <comment>“0”: xtal_26m
“1”: rc26m</comment>
        </bits>
        <bits access="rw" name="aon_ahb_lslp_ctrl_en_cp" pos="5" rst="0x1">
          <comment>“1”: Aon ahb clock auto switch to 26M (bit[5] decide witch clock switch to) when CP_SYS in lightsleep mode(with also bit4 is &quot;1&quot;), and switch back to the clock witch software set(see &quot;cgm_aon_ahb_sel_cfg&quot; register at address 0x51508828) when wake-up.
“0”: Disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_lslp_ctrl_en_ap" pos="4" rst="0x1">
          <comment>“1”: Aon ahb clock auto switch to 26M (bit[5] decide witch clock switch to) when AP_SYS in lightsleep mode(with also bit5 is &quot;1&quot;), and switch back to the clock witch software set(see &quot;cgm_aon_ahb_sel_cfg&quot; register at address 0x51508828) when wake-up.
“0”: Disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_dslp_sel" pos="3" rst="0x0">
          <comment>“0”: xtal_26m
“1”: rc26m</comment>
        </bits>
        <bits access="rw" name="aon_ahb_dslp_slow_ctrl_en" pos="2" rst="0x1">
          <comment>“1”: Aon ahb clock auto switch to RC32K when chip in deepsleep mode, and switch back when wake-up (bit[3] decide witch clock switch back to). Hardware control signal is &quot;pd_pll&quot; from IDLE_LPS module.
“0”: Disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_dslp_fast_ctrl_en" pos="1" rst="0x1">
          <comment>“1”: Aon ahb clock auto switch to 26M (bit[3] decide witch clock switch to) when chip in deepsleep mode, and switch back to the clock witch software set(see &quot;cgm_aon_ahb_sel_cfg&quot; register at address 0x51508828) when wake-up. Hardware control signal is &quot;pow_on&quot; from IDLE_LPS module.
“0”: Disable.</comment>
        </bits>
        <bits access="rw" name="lps_ahb_dslp_ctrl_en" pos="0" rst="0x0">
          <comment>“1”: Lps ahb clock auto switch to RC32K when chip in deepsleep mode, and switch back to the clock witch software set(see &quot;CFG_LPS_AHB_CLOCK_SEL&quot; register at address 0x51705030) when wake-up. Hardware control signal is &quot;pd_pll&quot; from IDLE_LPS module.
“0”: Disable.</comment>
        </bits>
      </reg>
      <reg name="usb_uart_swj_share_cfg" protect="rw">
        <comment>USB_UART_SWJ_SHARE_CFG</comment>
        <bits access="rw" name="usb_bypass_fs" pos="1" rst="0x0">
          <comment>“1”: uart or swj in use
“0”: USB in use</comment>
        </bits>
        <bits access="rw" name="uart_swj_sel" pos="0" rst="0x0">
          <comment>“1”: swj in use(with bit1 also set to &quot;1&quot;).
“0”: uart in use(with bit1 also set to &quot;1&quot;).</comment>
        </bits>
      </reg>
      <reg name="pu_clk26m_lp_iso_cfg" protect="rw">
        <comment>PU_CLK26M_LP_ISO_CFG</comment>
        <bits access="rw" name="pu_clk26m_lp_iso" pos="0" rst="0x1">
          <comment>“1”: ISO cell no work.
“0”: ISO work, signal clk_26m_lp clamp to &quot;0&quot;.</comment>
        </bits>
      </reg>
      <reg name="cfg_io_deep_sleep" protect="rw">
        <comment>CFG_IO_DEEP_SLEEP</comment>
        <bits access="rw" name="dslp_wp_io_sys1" pos="17" rst="0x0">
          <comment>0 : software mode: dslp_io_sys1 and dslp_wp_sys1 signal controlled by bit[2] and bit[3] of this register.
1 : hardware mode:  dslp_io_sys1 and dslp_wp_sys1 signal controlled by idst_cp signal of IDLE_LPS module.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_io_sys0" pos="16" rst="0x0">
          <comment>0 : software mode: dslp_io_sys0 and dslp_wp_sys0 signal controlled by bit[0] and bit[1] of this register.
1 : hardware mode:  dslp_io_sys0 and dslp_wp_sys0 signal controlled by idst_ap signal of IDLE_LPS module.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys5" pos="11" rst="0x0">
          <comment>pinmux dslp_wp_sys5 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys5" pos="10" rst="0x0">
          <comment>pinmux dslp_io_sys5 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys4" pos="9" rst="0x0">
          <comment>pinmux dslp_wp_sys4 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys4" pos="8" rst="0x0">
          <comment>pinmux dslp_io_sys4 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys3" pos="7" rst="0x0">
          <comment>pinmux dslp_wp_sys3 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys3" pos="6" rst="0x0">
          <comment>pinmux dslp_io_sys3 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys2" pos="5" rst="0x0">
          <comment>pinmux dslp_wp_sys2 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys2" pos="4" rst="0x0">
          <comment>pinmux dslp_io_sys2 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys1_sw" pos="3" rst="0x0">
          <comment>pinmux dslp_wp_sys1 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys1_sw" pos="2" rst="0x0">
          <comment>pinmux dslp_io_sys1 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys0_sw" pos="1" rst="0x0">
          <comment>pinmux dslp_wp_sys0 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys0_sw" pos="0" rst="0x0">
          <comment>pinmux dslp_io_sys0 signal control.</comment>
        </bits>
      </reg>
      <reg name="cfg_lps_io_core_ie" protect="rw">
        <comment>CFG_LPS_IO_CORE_IE</comment>
      </reg>
      <reg name="cfg_simc_io" protect="rw">
        <comment>CFG_SIMC_IO</comment>
        <bits access="rw" name="core_out_sim_1_rst_sel" pos="15" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_oe_sim_1_dio_sel" pos="14" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_1_dio_sel" pos="13" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_1_clk_sel" pos="12" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_rst_sel" pos="11" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_oe_sim_0_dio_sel" pos="10" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_dio_sel" pos="9" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_clk_sel" pos="8" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_1_rst_sw" pos="7" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_oe_sim_1_dio_sw" pos="6" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_out_sim_1_dio_sw" pos="5" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_out_sim_1_clk_sw" pos="4" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_rst_sw" pos="3" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_oe_sim_0_dio_sw" pos="2" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_dio_sw" pos="1" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_clk_sw" pos="0" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
      </reg>
      <hole size="7072"/>
      <reg name="reset_sys_soft_set" protect="rw"/>
      <reg name="reset_lps_soft_set" protect="rw"/>
      <reg name="efuse_por_read_disable_set" protect="rw"/>
      <reg name="lps_clk_en_set" protect="rw"/>
      <reg name="lps_clk_auto_sel_set" protect="rw"/>
      <reg name="lps_clk_force_en_set" protect="rw"/>
      <hole size="64"/>
      <reg name="cfg_clk_uart1_set" protect="rw"/>
      <reg name="cfg_clk_rc26m_set" protect="rw"/>
      <hole size="192"/>
      <reg name="cfg_reset_enable_set" protect="rw"/>
      <reg name="reset_cause_set" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_plls_set" protect="rw"/>
      <hole size="96"/>
      <reg name="aon_iram_ctrl_set" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_por_usb_phy_set" protect="rw"/>
      <hole size="64"/>
      <reg name="rc26m_pu_ctrl_set" protect="rw"/>
      <reg name="aon_ahb_lp_ctrl_set" protect="rw"/>
      <reg name="usb_uart_swj_share_cfg_set" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_io_deep_sleep_set" protect="rw"/>
      <reg name="cfg_lps_io_core_ie_set" protect="rw"/>
      <reg name="cfg_simc_io_set" protect="rw"/>
      <hole size="7072"/>
      <reg name="reset_sys_soft_clr" protect="rw"/>
      <reg name="reset_lps_soft_clr" protect="rw"/>
      <reg name="efuse_por_read_disable_clr" protect="rw"/>
      <reg name="lps_clk_en_clr" protect="rw"/>
      <reg name="lps_clk_auto_sel_clr" protect="rw"/>
      <reg name="lps_clk_force_en_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="cfg_clk_uart1_clr" protect="rw"/>
      <reg name="cfg_clk_rc26m_clr" protect="rw"/>
      <hole size="192"/>
      <reg name="cfg_reset_enable_clr" protect="rw"/>
      <reg name="reset_cause_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_plls_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="aon_iram_ctrl_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_por_usb_phy_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="rc26m_pu_ctrl_clr" protect="rw"/>
      <reg name="aon_ahb_lp_ctrl_clr" protect="rw"/>
      <reg name="usb_uart_swj_share_cfg_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_io_deep_sleep_clr" protect="rw"/>
      <reg name="cfg_lps_io_core_ie_clr" protect="rw"/>
      <reg name="cfg_simc_io_clr" protect="rw"/>
    </module>
    <var name="REG_LPS_APB_SET_OFFSET" value="0x400"/>
    <var name="REG_LPS_APB_CLR_OFFSET" value="0x800"/>
    <instance address="0x51705000" name="LPS_APB" type="LPS_APB"/>
  </archive>
  <archive relative="reg_fw_iomux.xml">
    <module category="System" name="REG_FW_IOMUX">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="adi_sda_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_4_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_5_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_6_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_7_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_1_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_2_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_3_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_0_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_cts_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_rxd_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_txd_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_rts_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_4_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_5_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_5_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_4_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_0_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_1_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_2_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_3_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_4_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_5_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_6_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_7_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg5_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg4_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg3_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg2_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg1_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg0_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_1" protect="rw">
        <comment>REG_RD_CTRL_1 REG_RD_CTRL_1</comment>
        <bits access="rw" name="nand_sel_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m2_sda_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m2_scl_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_mclk_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_bck_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_lrck_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_sdat_o_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s_sdat_i_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_pwdn_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_ref_clk_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_si_0_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_si_1_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_sck_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_rst_l_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_clk_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_rx_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_tx_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sw_dio_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sw_clk_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_clk_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_dio_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_rst_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_clk_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_dio_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_rst_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk26m_pmic_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ptest_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="chip_pd_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pmic_ext_int_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="osc_32k_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="resetb_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="adi_scl_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_2" protect="rw">
        <comment>REG_RD_CTRL_2 REG_RD_CTRL_2</comment>
        <bits access="rw" name="i2c_m1_scl_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m1_sda_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_rxd_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_txd_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_cts_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_rts_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_clk_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_cmd_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_0_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_1_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_2_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_3_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_4_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_5_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_6_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_7_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_rst_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_sio_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_sdc_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_clk_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_cs_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_select_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lcd_fmark_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lcd_rstb_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_0_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_1_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_2_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_3_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_0_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_1_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_2_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_3_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_3" protect="rw">
        <comment>REG_RD_CTRL_3 REG_RD_CTRL_3</comment>
        <bits access="rw" name="m_spi_clk_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_cs_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_0_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_1_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_2_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_3_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_16_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_17_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_18_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_19_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_20_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_21_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_22_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_23_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="adi_sda_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_4_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_5_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_6_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_7_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_1_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_2_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_3_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_0_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_cts_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_rxd_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_txd_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_rts_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_4_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_5_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_5_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_4_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_0_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_1_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_2_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_3_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_4_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_5_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_6_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_7_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg5_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg4_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg3_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg2_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg1_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg0_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_1" protect="rw">
        <comment>REG_WR_CTRL_1 REG_WR_CTRL_1</comment>
        <bits access="rw" name="nand_sel_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m2_sda_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m2_scl_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_mclk_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_bck_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_lrck_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_sdat_o_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s_sdat_i_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_pwdn_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_ref_clk_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_si_0_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_si_1_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_sck_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_rst_l_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_clk_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_rx_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_tx_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sw_dio_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sw_clk_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_clk_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_dio_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_rst_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_clk_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_dio_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_rst_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk26m_pmic_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ptest_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="chip_pd_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pmic_ext_int_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="osc_32k_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="resetb_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="adi_scl_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_2" protect="rw">
        <comment>REG_WR_CTRL_2 REG_WR_CTRL_2</comment>
        <bits access="rw" name="i2c_m1_scl_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m1_sda_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_rxd_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_txd_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_cts_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_rts_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_clk_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_cmd_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_0_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_1_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_2_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_3_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_4_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_5_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_6_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_7_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_rst_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_sio_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_sdc_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_clk_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_cs_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_select_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lcd_fmark_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lcd_rstb_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_0_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_1_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_2_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_3_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_0_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_1_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_2_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_3_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_3" protect="rw">
        <comment>REG_WR_CTRL_3 REG_WR_CTRL_3</comment>
        <bits access="rw" name="m_spi_clk_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_cs_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_0_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_1_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_2_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_3_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_16_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_17_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_18_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_19_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_20_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_21_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_22_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_23_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array0" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY0 BIT_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_ctrl_addr_array0" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array1" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY1 BIT_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_ctrl_addr_array1" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array2" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY2 BIT_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_ctrl_addr_array2" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array3" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY3 BIT_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_ctrl_addr_array3" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array4" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY4 BIT_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_ctrl_addr_array4" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array5" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY5 BIT_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_ctrl_addr_array5" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array6" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY6 BIT_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_ctrl_addr_array6" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array7" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY7 BIT_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_ctrl_addr_array7" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_array0" protect="rw">
        <comment>BIT_CTRL_ARRAY0 BIT_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_ctrl_array1" protect="rw">
        <comment>BIT_CTRL_ARRAY1 BIT_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_ctrl_array2" protect="rw">
        <comment>BIT_CTRL_ARRAY2 BIT_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_ctrl_array3" protect="rw">
        <comment>BIT_CTRL_ARRAY3 BIT_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_ctrl_array4" protect="rw">
        <comment>BIT_CTRL_ARRAY4 BIT_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_ctrl_array5" protect="rw">
        <comment>BIT_CTRL_ARRAY5 BIT_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_ctrl_array6" protect="rw">
        <comment>BIT_CTRL_ARRAY6 BIT_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_ctrl_array7" protect="rw">
        <comment>BIT_CTRL_ARRAY7 BIT_CTRL_ARRAY7</comment>
      </reg>
    </module>
    <instance address="0x51306000" name="REG_FW_IOMUX" type="REG_FW_IOMUX"/>
  </archive>
  <archive relative="reg_fw_ap_apb.xml">
    <module category="System" name="REG_FW_AP_APB">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="cfg_qos1_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_qos0_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="chip_prod_id_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="misc_cfg_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cache_emmc_sdio_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="main_lpc_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s6_lpc_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s5_lpc_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s4_lpc_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s3_lpc_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s2_lpc_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s1_lpc_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s0_lpc_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m9_lpc_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m8_lpc_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m7_lpc_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m6_lpc_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m5_lpc_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m4_lpc_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m3_lpc_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m2_lpc_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m1_lpc_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m0_lpc_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst2_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst1_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst0_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en2_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode2_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en1_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode1_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en0_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode0_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_1" protect="rw">
        <comment>REG_RD_CTRL_1 REG_RD_CTRL_1</comment>
        <bits access="rw" name="cfg_clk_spiflash1_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart6_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart5_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart4_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status4_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status3_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status2_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status1_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status0_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status3_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status2_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status1_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status0_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en3_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en2_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en1_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en0_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel3_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel2_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel1_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel0_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_bridge_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt_ctrl_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt32k_th1_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt32k_th0_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th3_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th2_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th1_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th0_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="xhb_awsparse_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_monitor_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_qos2_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_2" protect="rw">
        <comment>REG_RD_CTRL_2 REG_RD_CTRL_2</comment>
        <bits access="rw" name="ap2pub_bridge_debug_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap2pub_bridge_status_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd3_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd2_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd1_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd0_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="anti_hang_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="light_sleep_bypass1_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="light_sleep_bypass0_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sleep_ctrl_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lp_force_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_apcpu_dbgen_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_spiflash2_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="cfg_qos1_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_qos0_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="chip_prod_id_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="misc_cfg_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cache_emmc_sdio_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="main_lpc_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s6_lpc_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s5_lpc_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s4_lpc_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s3_lpc_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s2_lpc_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s1_lpc_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s0_lpc_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m9_lpc_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m8_lpc_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m7_lpc_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m6_lpc_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m5_lpc_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m4_lpc_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m3_lpc_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m2_lpc_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m1_lpc_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m0_lpc_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst2_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst1_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst0_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en2_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode2_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en1_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode1_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en0_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode0_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_1" protect="rw">
        <comment>REG_WR_CTRL_1 REG_WR_CTRL_1</comment>
        <bits access="rw" name="cfg_clk_spiflash1_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart6_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart5_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart4_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status4_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status3_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status2_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status1_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status0_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status3_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status2_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status1_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status0_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en3_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en2_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en1_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en0_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel3_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel2_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel1_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel0_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_bridge_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt_ctrl_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt32k_th1_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt32k_th0_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th3_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th2_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th1_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th0_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="xhb_awsparse_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_monitor_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_qos2_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_2" protect="rw">
        <comment>REG_WR_CTRL_2 REG_WR_CTRL_2</comment>
        <bits access="rw" name="ap2pub_bridge_debug_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap2pub_bridge_status_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd3_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd2_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd1_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd0_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="anti_hang_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="light_sleep_bypass1_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="light_sleep_bypass0_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sleep_ctrl_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lp_force_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_apcpu_dbgen_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_spiflash2_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array0" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY0 BIT_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_ctrl_addr_array0" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array1" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY1 BIT_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_ctrl_addr_array1" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array2" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY2 BIT_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_ctrl_addr_array2" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array3" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY3 BIT_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_ctrl_addr_array3" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array4" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY4 BIT_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_ctrl_addr_array4" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array5" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY5 BIT_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_ctrl_addr_array5" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array6" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY6 BIT_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_ctrl_addr_array6" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array7" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY7 BIT_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_ctrl_addr_array7" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array8" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY8 BIT_CTRL_ADDR_ARRAY8</comment>
        <bits access="rw" name="bit_ctrl_addr_array8" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array8</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array9" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY9 BIT_CTRL_ADDR_ARRAY9</comment>
        <bits access="rw" name="bit_ctrl_addr_array9" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array9</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array10" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY10 BIT_CTRL_ADDR_ARRAY10</comment>
        <bits access="rw" name="bit_ctrl_addr_array10" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array10</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array11" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY11 BIT_CTRL_ADDR_ARRAY11</comment>
        <bits access="rw" name="bit_ctrl_addr_array11" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array11</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array12" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY12 BIT_CTRL_ADDR_ARRAY12</comment>
        <bits access="rw" name="bit_ctrl_addr_array12" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array12</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array13" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY13 BIT_CTRL_ADDR_ARRAY13</comment>
        <bits access="rw" name="bit_ctrl_addr_array13" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array13</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array14" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY14 BIT_CTRL_ADDR_ARRAY14</comment>
        <bits access="rw" name="bit_ctrl_addr_array14" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array14</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array15" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY15 BIT_CTRL_ADDR_ARRAY15</comment>
        <bits access="rw" name="bit_ctrl_addr_array15" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array15</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_array0" protect="rw">
        <comment>BIT_CTRL_ARRAY0 BIT_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_ctrl_array1" protect="rw">
        <comment>BIT_CTRL_ARRAY1 BIT_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_ctrl_array2" protect="rw">
        <comment>BIT_CTRL_ARRAY2 BIT_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_ctrl_array3" protect="rw">
        <comment>BIT_CTRL_ARRAY3 BIT_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_ctrl_array4" protect="rw">
        <comment>BIT_CTRL_ARRAY4 BIT_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_ctrl_array5" protect="rw">
        <comment>BIT_CTRL_ARRAY5 BIT_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_ctrl_array6" protect="rw">
        <comment>BIT_CTRL_ARRAY6 BIT_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_ctrl_array7" protect="rw">
        <comment>BIT_CTRL_ARRAY7 BIT_CTRL_ARRAY7</comment>
      </reg>
      <reg name="bit_ctrl_array8" protect="rw">
        <comment>BIT_CTRL_ARRAY8 BIT_CTRL_ARRAY8</comment>
      </reg>
      <reg name="bit_ctrl_array9" protect="rw">
        <comment>BIT_CTRL_ARRAY9 BIT_CTRL_ARRAY9</comment>
      </reg>
      <reg name="bit_ctrl_array10" protect="rw">
        <comment>BIT_CTRL_ARRAY10 BIT_CTRL_ARRAY10</comment>
      </reg>
      <reg name="bit_ctrl_array11" protect="rw">
        <comment>BIT_CTRL_ARRAY11 BIT_CTRL_ARRAY11</comment>
      </reg>
      <reg name="bit_ctrl_array12" protect="rw">
        <comment>BIT_CTRL_ARRAY12 BIT_CTRL_ARRAY12</comment>
      </reg>
      <reg name="bit_ctrl_array13" protect="rw">
        <comment>BIT_CTRL_ARRAY13 BIT_CTRL_ARRAY13</comment>
      </reg>
      <reg name="bit_ctrl_array14" protect="rw">
        <comment>BIT_CTRL_ARRAY14 BIT_CTRL_ARRAY14</comment>
      </reg>
      <reg name="bit_ctrl_array15" protect="rw">
        <comment>BIT_CTRL_ARRAY15 BIT_CTRL_ARRAY15</comment>
      </reg>
    </module>
    <instance address="0x5132a000" name="REG_FW_AP_APB" type="REG_FW_AP_APB"/>
  </archive>
  <archive relative="slv_fw_lps_ifc.xml">
    <module category="System" name="SLV_FW_LPS_IFC">
      <reg name="port0_default_address_0" protect="rw">
        <comment>port0 default address, bit 0 ~ 15. port0 default address, bit 0 ~ 15.</comment>
        <bits access="rw" name="port0_default_address_0" pos="15:0" rst="0xdf00"/>
      </reg>
      <reg name="port_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int write-clear</comment>
        </bits>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_raw" protect="rw">
        <comment>Original interrupt reg %d Original interrupt reg %d</comment>
        <bits access="r" name="port_0_r_raw" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_fin" protect="rw">
        <comment>Final interrupt reg %d Final interrupt reg %d</comment>
        <bits access="r" name="port_0_r_fin" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="uart1_rd_sec" pos="17:16" rst="0x3">
          <comment>control uart1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="idle_lps_rd_sec" pos="15:14" rst="0x3">
          <comment>control idle_lps_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpio1_rd_sec" pos="13:12" rst="0x3">
          <comment>control gpio1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="apb_reg_rd_sec" pos="11:10" rst="0x3">
          <comment>control apb_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="keypad_rd_sec" pos="9:8" rst="0x3">
          <comment>control keypad_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pwrctrl_rd_sec" pos="7:6" rst="0x3">
          <comment>control pwrctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="rtc_timer_rd_sec" pos="5:4" rst="0x3">
          <comment>control rtc_timer_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap3_rd_sec" pos="3:2" rst="0x3">
          <comment>control ana_wrap3_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="lps_ifc_rd_sec" pos="1:0" rst="0x3">
          <comment>control lps_ifc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="uart1_wr_sec" pos="17:16" rst="0x3">
          <comment>control uart1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="idle_lps_wr_sec" pos="15:14" rst="0x3">
          <comment>control idle_lps_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpio1_wr_sec" pos="13:12" rst="0x3">
          <comment>control gpio1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="apb_reg_wr_sec" pos="11:10" rst="0x3">
          <comment>control apb_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="keypad_wr_sec" pos="9:8" rst="0x3">
          <comment>control keypad_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pwrctrl_wr_sec" pos="7:6" rst="0x3">
          <comment>control pwrctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="rtc_timer_wr_sec" pos="5:4" rst="0x3">
          <comment>control rtc_timer_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap3_wr_sec" pos="3:2" rst="0x3">
          <comment>control ana_wrap3_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="lps_ifc_wr_sec" pos="1:0" rst="0x3">
          <comment>control lps_ifc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="id0_first_addr_0" protect="rw">
        <comment>id0 first_addr control id0 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id0_last_addr_0" protect="rw">
        <comment>id0 last_addr control id0 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id0_mstid_0" protect="rw">
        <comment>id0 mstid_0 master id control id0 mstid_0 master id control</comment>
      </reg>
      <reg name="id0_mstid_1" protect="rw">
        <comment>id0 mstid_1 master id control id0 mstid_1 master id control</comment>
      </reg>
      <reg name="id0_mstid_2" protect="rw">
        <comment>id0 mstid_2 master id control id0 mstid_2 master id control</comment>
      </reg>
      <reg name="id0_mstid_3" protect="rw">
        <comment>id0 mstid_3 master id control id0 mstid_3 master id control</comment>
      </reg>
      <reg name="id0_mstid_4" protect="rw">
        <comment>id0 mstid_4 master id control id0 mstid_4 master id control</comment>
      </reg>
      <reg name="id0_mstid_5" protect="rw">
        <comment>id0 mstid_5 master id control id0 mstid_5 master id control</comment>
      </reg>
      <reg name="id0_mstid_6" protect="rw">
        <comment>id0 mstid_6 master id control id0 mstid_6 master id control</comment>
      </reg>
      <reg name="id0_mstid_7" protect="rw">
        <comment>id0 mstid_7 master id control id0 mstid_7 master id control</comment>
      </reg>
      <reg name="id1_first_addr_0" protect="rw">
        <comment>id1 first_addr control id1 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id1_last_addr_0" protect="rw">
        <comment>id1 last_addr control id1 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id1_mstid_0" protect="rw">
        <comment>id1 mstid_0 master id control id1 mstid_0 master id control</comment>
      </reg>
      <reg name="id1_mstid_1" protect="rw">
        <comment>id1 mstid_1 master id control id1 mstid_1 master id control</comment>
      </reg>
      <reg name="id1_mstid_2" protect="rw">
        <comment>id1 mstid_2 master id control id1 mstid_2 master id control</comment>
      </reg>
      <reg name="id1_mstid_3" protect="rw">
        <comment>id1 mstid_3 master id control id1 mstid_3 master id control</comment>
      </reg>
      <reg name="id1_mstid_4" protect="rw">
        <comment>id1 mstid_4 master id control id1 mstid_4 master id control</comment>
      </reg>
      <reg name="id1_mstid_5" protect="rw">
        <comment>id1 mstid_5 master id control id1 mstid_5 master id control</comment>
      </reg>
      <reg name="id1_mstid_6" protect="rw">
        <comment>id1 mstid_6 master id control id1 mstid_6 master id control</comment>
      </reg>
      <reg name="id1_mstid_7" protect="rw">
        <comment>id1 mstid_7 master id control id1 mstid_7 master id control</comment>
      </reg>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clk_gate_bypass clk_gate_bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clk_gate_bypass</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51300000" name="SLV_FW_LPS_IFC" type="SLV_FW_LPS_IFC"/>
  </archive>
  <archive relative="slv_fw_ap_ifc.xml">
    <module category="System" name="SLV_FW_AP_IFC">
      <reg name="port0_default_address_0" protect="rw">
        <comment>port0 default address, bit 0 ~ 15. port0 default address, bit 0 ~ 15.</comment>
        <bits access="rw" name="port0_default_address_0" pos="15:0" rst="0xe000"/>
      </reg>
      <reg name="port_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int write-clear</comment>
        </bits>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_raw" protect="rw">
        <comment>Original interrupt reg %d Original interrupt reg %d</comment>
        <bits access="r" name="port_0_r_raw" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_fin" protect="rw">
        <comment>Final interrupt reg %d Final interrupt reg %d</comment>
        <bits access="r" name="port_0_r_fin" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="uart4_rd_sec" pos="11:10" rst="0x3">
          <comment>control uart4_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart5_rd_sec" pos="9:8" rst="0x3">
          <comment>control uart5_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart6_rd_sec" pos="7:6" rst="0x3">
          <comment>control uart6_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sdmmc_rd_sec" pos="5:4" rst="0x3">
          <comment>control sdmmc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="camera_rd_sec" pos="3:2" rst="0x3">
          <comment>control camera_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_ifc_rd_sec" pos="1:0" rst="0x3">
          <comment>control ap_ifc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="uart4_wr_sec" pos="11:10" rst="0x3">
          <comment>control uart4_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart5_wr_sec" pos="9:8" rst="0x3">
          <comment>control uart5_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart6_wr_sec" pos="7:6" rst="0x3">
          <comment>control uart6_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sdmmc_wr_sec" pos="5:4" rst="0x3">
          <comment>control sdmmc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="camera_wr_sec" pos="3:2" rst="0x3">
          <comment>control camera_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_ifc_wr_sec" pos="1:0" rst="0x3">
          <comment>control ap_ifc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="id0_first_addr_0" protect="rw">
        <comment>id0 first_addr control id0 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id0_last_addr_0" protect="rw">
        <comment>id0 last_addr control id0 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id0_mstid_0" protect="rw">
        <comment>id0 mstid_0 master id control id0 mstid_0 master id control</comment>
      </reg>
      <reg name="id0_mstid_1" protect="rw">
        <comment>id0 mstid_1 master id control id0 mstid_1 master id control</comment>
      </reg>
      <reg name="id0_mstid_2" protect="rw">
        <comment>id0 mstid_2 master id control id0 mstid_2 master id control</comment>
      </reg>
      <reg name="id0_mstid_3" protect="rw">
        <comment>id0 mstid_3 master id control id0 mstid_3 master id control</comment>
      </reg>
      <reg name="id0_mstid_4" protect="rw">
        <comment>id0 mstid_4 master id control id0 mstid_4 master id control</comment>
      </reg>
      <reg name="id0_mstid_5" protect="rw">
        <comment>id0 mstid_5 master id control id0 mstid_5 master id control</comment>
      </reg>
      <reg name="id0_mstid_6" protect="rw">
        <comment>id0 mstid_6 master id control id0 mstid_6 master id control</comment>
      </reg>
      <reg name="id0_mstid_7" protect="rw">
        <comment>id0 mstid_7 master id control id0 mstid_7 master id control</comment>
      </reg>
      <reg name="id1_first_addr_0" protect="rw">
        <comment>id1 first_addr control id1 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id1_last_addr_0" protect="rw">
        <comment>id1 last_addr control id1 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id1_mstid_0" protect="rw">
        <comment>id1 mstid_0 master id control id1 mstid_0 master id control</comment>
      </reg>
      <reg name="id1_mstid_1" protect="rw">
        <comment>id1 mstid_1 master id control id1 mstid_1 master id control</comment>
      </reg>
      <reg name="id1_mstid_2" protect="rw">
        <comment>id1 mstid_2 master id control id1 mstid_2 master id control</comment>
      </reg>
      <reg name="id1_mstid_3" protect="rw">
        <comment>id1 mstid_3 master id control id1 mstid_3 master id control</comment>
      </reg>
      <reg name="id1_mstid_4" protect="rw">
        <comment>id1 mstid_4 master id control id1 mstid_4 master id control</comment>
      </reg>
      <reg name="id1_mstid_5" protect="rw">
        <comment>id1 mstid_5 master id control id1 mstid_5 master id control</comment>
      </reg>
      <reg name="id1_mstid_6" protect="rw">
        <comment>id1 mstid_6 master id control id1 mstid_6 master id control</comment>
      </reg>
      <reg name="id1_mstid_7" protect="rw">
        <comment>id1 mstid_7 master id control id1 mstid_7 master id control</comment>
      </reg>
      <reg name="id2_first_addr_0" protect="rw">
        <comment>id2 first_addr control id2 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id2_last_addr_0" protect="rw">
        <comment>id2 last_addr control id2 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id2_mstid_0" protect="rw">
        <comment>id2 mstid_0 master id control id2 mstid_0 master id control</comment>
      </reg>
      <reg name="id2_mstid_1" protect="rw">
        <comment>id2 mstid_1 master id control id2 mstid_1 master id control</comment>
      </reg>
      <reg name="id2_mstid_2" protect="rw">
        <comment>id2 mstid_2 master id control id2 mstid_2 master id control</comment>
      </reg>
      <reg name="id2_mstid_3" protect="rw">
        <comment>id2 mstid_3 master id control id2 mstid_3 master id control</comment>
      </reg>
      <reg name="id2_mstid_4" protect="rw">
        <comment>id2 mstid_4 master id control id2 mstid_4 master id control</comment>
      </reg>
      <reg name="id2_mstid_5" protect="rw">
        <comment>id2 mstid_5 master id control id2 mstid_5 master id control</comment>
      </reg>
      <reg name="id2_mstid_6" protect="rw">
        <comment>id2 mstid_6 master id control id2 mstid_6 master id control</comment>
      </reg>
      <reg name="id2_mstid_7" protect="rw">
        <comment>id2 mstid_7 master id control id2 mstid_7 master id control</comment>
      </reg>
      <reg name="id3_first_addr_0" protect="rw">
        <comment>id3 first_addr control id3 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id3_last_addr_0" protect="rw">
        <comment>id3 last_addr control id3 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id3_mstid_0" protect="rw">
        <comment>id3 mstid_0 master id control id3 mstid_0 master id control</comment>
      </reg>
      <reg name="id3_mstid_1" protect="rw">
        <comment>id3 mstid_1 master id control id3 mstid_1 master id control</comment>
      </reg>
      <reg name="id3_mstid_2" protect="rw">
        <comment>id3 mstid_2 master id control id3 mstid_2 master id control</comment>
      </reg>
      <reg name="id3_mstid_3" protect="rw">
        <comment>id3 mstid_3 master id control id3 mstid_3 master id control</comment>
      </reg>
      <reg name="id3_mstid_4" protect="rw">
        <comment>id3 mstid_4 master id control id3 mstid_4 master id control</comment>
      </reg>
      <reg name="id3_mstid_5" protect="rw">
        <comment>id3 mstid_5 master id control id3 mstid_5 master id control</comment>
      </reg>
      <reg name="id3_mstid_6" protect="rw">
        <comment>id3 mstid_6 master id control id3 mstid_6 master id control</comment>
      </reg>
      <reg name="id3_mstid_7" protect="rw">
        <comment>id3 mstid_7 master id control id3 mstid_7 master id control</comment>
      </reg>
      <reg name="id4_first_addr_0" protect="rw">
        <comment>id4 first_addr control id4 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id4_last_addr_0" protect="rw">
        <comment>id4 last_addr control id4 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id4_mstid_0" protect="rw">
        <comment>id4 mstid_0 master id control id4 mstid_0 master id control</comment>
      </reg>
      <reg name="id4_mstid_1" protect="rw">
        <comment>id4 mstid_1 master id control id4 mstid_1 master id control</comment>
      </reg>
      <reg name="id4_mstid_2" protect="rw">
        <comment>id4 mstid_2 master id control id4 mstid_2 master id control</comment>
      </reg>
      <reg name="id4_mstid_3" protect="rw">
        <comment>id4 mstid_3 master id control id4 mstid_3 master id control</comment>
      </reg>
      <reg name="id4_mstid_4" protect="rw">
        <comment>id4 mstid_4 master id control id4 mstid_4 master id control</comment>
      </reg>
      <reg name="id4_mstid_5" protect="rw">
        <comment>id4 mstid_5 master id control id4 mstid_5 master id control</comment>
      </reg>
      <reg name="id4_mstid_6" protect="rw">
        <comment>id4 mstid_6 master id control id4 mstid_6 master id control</comment>
      </reg>
      <reg name="id4_mstid_7" protect="rw">
        <comment>id4 mstid_7 master id control id4 mstid_7 master id control</comment>
      </reg>
      <reg name="id5_first_addr_0" protect="rw">
        <comment>id5 first_addr control id5 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id5_last_addr_0" protect="rw">
        <comment>id5 last_addr control id5 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id5_mstid_0" protect="rw">
        <comment>id5 mstid_0 master id control id5 mstid_0 master id control</comment>
      </reg>
      <reg name="id5_mstid_1" protect="rw">
        <comment>id5 mstid_1 master id control id5 mstid_1 master id control</comment>
      </reg>
      <reg name="id5_mstid_2" protect="rw">
        <comment>id5 mstid_2 master id control id5 mstid_2 master id control</comment>
      </reg>
      <reg name="id5_mstid_3" protect="rw">
        <comment>id5 mstid_3 master id control id5 mstid_3 master id control</comment>
      </reg>
      <reg name="id5_mstid_4" protect="rw">
        <comment>id5 mstid_4 master id control id5 mstid_4 master id control</comment>
      </reg>
      <reg name="id5_mstid_5" protect="rw">
        <comment>id5 mstid_5 master id control id5 mstid_5 master id control</comment>
      </reg>
      <reg name="id5_mstid_6" protect="rw">
        <comment>id5 mstid_6 master id control id5 mstid_6 master id control</comment>
      </reg>
      <reg name="id5_mstid_7" protect="rw">
        <comment>id5 mstid_7 master id control id5 mstid_7 master id control</comment>
      </reg>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clk_gate_bypass clk_gate_bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clk_gate_bypass</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51321000" name="SLV_FW_AP_IFC" type="SLV_FW_AP_IFC"/>
  </archive>
  <archive relative="slv_fw_ap_ahb.xml">
    <module category="System" name="SLV_FW_AP_AHB">
      <reg name="port0_default_address_0" protect="rw">
        <comment>port0 default address, bit 0 ~ 26. port0 default address, bit 0 ~ 26.</comment>
        <bits access="rw" name="port0_default_address_0" pos="26:0" rst="0x7fff000"/>
      </reg>
      <reg name="port_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int write-clear</comment>
        </bits>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_raw" protect="rw">
        <comment>Original interrupt reg %d Original interrupt reg %d</comment>
        <bits access="r" name="port_0_r_raw" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_fin" protect="rw">
        <comment>Final interrupt reg %d Final interrupt reg %d</comment>
        <bits access="r" name="port_0_r_fin" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="emmc_rd_sec" pos="31:30" rst="0x3">
          <comment>control emmc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spi1_rd_sec" pos="29:28" rst="0x3">
          <comment>control spi1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="lzma_rd_sec" pos="27:26" rst="0x3">
          <comment>control lzma_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_imem_rd_sec" pos="25:24" rst="0x3">
          <comment>control ap_imem_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_busmon_rd_sec" pos="23:22" rst="0x3">
          <comment>control ap_busmon_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="apb_reg_rd_sec" pos="21:20" rst="0x3">
          <comment>control apb_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gouda_reg_rd_sec" pos="19:18" rst="0x3">
          <comment>control gouda_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_0_rd_sec" pos="17:16" rst="0x3">
          <comment>control timer1_0_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_wd_rd_sec" pos="15:14" rst="0x3">
          <comment>control timer1_wd_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_1_rd_sec" pos="13:12" rst="0x3">
          <comment>control timer1_1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer2_rd_sec" pos="11:10" rst="0x3">
          <comment>control timer2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer5_rd_sec" pos="9:8" rst="0x3">
          <comment>control timer5_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c1_rd_sec" pos="7:6" rst="0x3">
          <comment>control i2c1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c2_rd_sec" pos="5:4" rst="0x3">
          <comment>control i2c2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt3_rd_sec" pos="3:2" rst="0x3">
          <comment>control gpt3_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_clk_rd_sec" pos="1:0" rst="0x3">
          <comment>control ap_clk_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="rd_sec_1" protect="rw">
        <comment>rd 1 sec control rd 1 sec control</comment>
        <bits access="rw" name="spiflash1_reg_rd_sec" pos="15:14" rst="0x3">
          <comment>control spiflash1_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spiflash2_reg_rd_sec" pos="13:12" rst="0x3">
          <comment>control spiflash2_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gouda_rd_sec" pos="11:10" rst="0x3">
          <comment>control gouda_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_axidma_rd_sec" pos="9:8" rst="0x3">
          <comment>control ap_axidma_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="usb_rd_sec" pos="7:6" rst="0x3">
          <comment>control usb_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="med_rd_sec" pos="5:4" rst="0x3">
          <comment>control med_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ce_pub_rd_sec" pos="3:2" rst="0x3">
          <comment>control ce_pub_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ce_sec_rd_sec" pos="1:0" rst="0x3">
          <comment>control ce_sec_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="emmc_wr_sec" pos="31:30" rst="0x3">
          <comment>control emmc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spi1_wr_sec" pos="29:28" rst="0x3">
          <comment>control spi1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="lzma_wr_sec" pos="27:26" rst="0x3">
          <comment>control lzma_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_imem_wr_sec" pos="25:24" rst="0x3">
          <comment>control ap_imem_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_busmon_wr_sec" pos="23:22" rst="0x3">
          <comment>control ap_busmon_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="apb_reg_wr_sec" pos="21:20" rst="0x3">
          <comment>control apb_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gouda_reg_wr_sec" pos="19:18" rst="0x3">
          <comment>control gouda_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_0_wr_sec" pos="17:16" rst="0x3">
          <comment>control timer1_0_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_wd_wr_sec" pos="15:14" rst="0x3">
          <comment>control timer1_wd_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_1_wr_sec" pos="13:12" rst="0x3">
          <comment>control timer1_1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer2_wr_sec" pos="11:10" rst="0x3">
          <comment>control timer2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer5_wr_sec" pos="9:8" rst="0x3">
          <comment>control timer5_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c1_wr_sec" pos="7:6" rst="0x3">
          <comment>control i2c1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c2_wr_sec" pos="5:4" rst="0x3">
          <comment>control i2c2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt3_wr_sec" pos="3:2" rst="0x3">
          <comment>control gpt3_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_clk_wr_sec" pos="1:0" rst="0x3">
          <comment>control ap_clk_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_1" protect="rw">
        <comment>wr 1 sec control wr 1 sec control</comment>
        <bits access="rw" name="spiflash1_reg_wr_sec" pos="15:14" rst="0x3">
          <comment>control spiflash1_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spiflash2_reg_wr_sec" pos="13:12" rst="0x3">
          <comment>control spiflash2_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gouda_wr_sec" pos="11:10" rst="0x3">
          <comment>control gouda_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_axidma_wr_sec" pos="9:8" rst="0x3">
          <comment>control ap_axidma_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="usb_wr_sec" pos="7:6" rst="0x3">
          <comment>control usb_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="med_wr_sec" pos="5:4" rst="0x3">
          <comment>control med_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ce_pub_wr_sec" pos="3:2" rst="0x3">
          <comment>control ce_pub_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ce_sec_wr_sec" pos="1:0" rst="0x3">
          <comment>control ce_sec_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="id0_first_addr_0" protect="rw">
        <comment>id0 first_addr control id0 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id0_last_addr_0" protect="rw">
        <comment>id0 last_addr control id0 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id0_mstid_0" protect="rw">
        <comment>id0 mstid_0 master id control id0 mstid_0 master id control</comment>
      </reg>
      <reg name="id0_mstid_1" protect="rw">
        <comment>id0 mstid_1 master id control id0 mstid_1 master id control</comment>
      </reg>
      <reg name="id0_mstid_2" protect="rw">
        <comment>id0 mstid_2 master id control id0 mstid_2 master id control</comment>
      </reg>
      <reg name="id0_mstid_3" protect="rw">
        <comment>id0 mstid_3 master id control id0 mstid_3 master id control</comment>
      </reg>
      <reg name="id0_mstid_4" protect="rw">
        <comment>id0 mstid_4 master id control id0 mstid_4 master id control</comment>
      </reg>
      <reg name="id0_mstid_5" protect="rw">
        <comment>id0 mstid_5 master id control id0 mstid_5 master id control</comment>
      </reg>
      <reg name="id0_mstid_6" protect="rw">
        <comment>id0 mstid_6 master id control id0 mstid_6 master id control</comment>
      </reg>
      <reg name="id0_mstid_7" protect="rw">
        <comment>id0 mstid_7 master id control id0 mstid_7 master id control</comment>
      </reg>
      <reg name="id1_first_addr_0" protect="rw">
        <comment>id1 first_addr control id1 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id1_last_addr_0" protect="rw">
        <comment>id1 last_addr control id1 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id1_mstid_0" protect="rw">
        <comment>id1 mstid_0 master id control id1 mstid_0 master id control</comment>
      </reg>
      <reg name="id1_mstid_1" protect="rw">
        <comment>id1 mstid_1 master id control id1 mstid_1 master id control</comment>
      </reg>
      <reg name="id1_mstid_2" protect="rw">
        <comment>id1 mstid_2 master id control id1 mstid_2 master id control</comment>
      </reg>
      <reg name="id1_mstid_3" protect="rw">
        <comment>id1 mstid_3 master id control id1 mstid_3 master id control</comment>
      </reg>
      <reg name="id1_mstid_4" protect="rw">
        <comment>id1 mstid_4 master id control id1 mstid_4 master id control</comment>
      </reg>
      <reg name="id1_mstid_5" protect="rw">
        <comment>id1 mstid_5 master id control id1 mstid_5 master id control</comment>
      </reg>
      <reg name="id1_mstid_6" protect="rw">
        <comment>id1 mstid_6 master id control id1 mstid_6 master id control</comment>
      </reg>
      <reg name="id1_mstid_7" protect="rw">
        <comment>id1 mstid_7 master id control id1 mstid_7 master id control</comment>
      </reg>
      <reg name="id2_first_addr_0" protect="rw">
        <comment>id2 first_addr control id2 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id2_last_addr_0" protect="rw">
        <comment>id2 last_addr control id2 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id2_mstid_0" protect="rw">
        <comment>id2 mstid_0 master id control id2 mstid_0 master id control</comment>
      </reg>
      <reg name="id2_mstid_1" protect="rw">
        <comment>id2 mstid_1 master id control id2 mstid_1 master id control</comment>
      </reg>
      <reg name="id2_mstid_2" protect="rw">
        <comment>id2 mstid_2 master id control id2 mstid_2 master id control</comment>
      </reg>
      <reg name="id2_mstid_3" protect="rw">
        <comment>id2 mstid_3 master id control id2 mstid_3 master id control</comment>
      </reg>
      <reg name="id2_mstid_4" protect="rw">
        <comment>id2 mstid_4 master id control id2 mstid_4 master id control</comment>
      </reg>
      <reg name="id2_mstid_5" protect="rw">
        <comment>id2 mstid_5 master id control id2 mstid_5 master id control</comment>
      </reg>
      <reg name="id2_mstid_6" protect="rw">
        <comment>id2 mstid_6 master id control id2 mstid_6 master id control</comment>
      </reg>
      <reg name="id2_mstid_7" protect="rw">
        <comment>id2 mstid_7 master id control id2 mstid_7 master id control</comment>
      </reg>
      <reg name="id3_first_addr_0" protect="rw">
        <comment>id3 first_addr control id3 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id3_last_addr_0" protect="rw">
        <comment>id3 last_addr control id3 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id3_mstid_0" protect="rw">
        <comment>id3 mstid_0 master id control id3 mstid_0 master id control</comment>
      </reg>
      <reg name="id3_mstid_1" protect="rw">
        <comment>id3 mstid_1 master id control id3 mstid_1 master id control</comment>
      </reg>
      <reg name="id3_mstid_2" protect="rw">
        <comment>id3 mstid_2 master id control id3 mstid_2 master id control</comment>
      </reg>
      <reg name="id3_mstid_3" protect="rw">
        <comment>id3 mstid_3 master id control id3 mstid_3 master id control</comment>
      </reg>
      <reg name="id3_mstid_4" protect="rw">
        <comment>id3 mstid_4 master id control id3 mstid_4 master id control</comment>
      </reg>
      <reg name="id3_mstid_5" protect="rw">
        <comment>id3 mstid_5 master id control id3 mstid_5 master id control</comment>
      </reg>
      <reg name="id3_mstid_6" protect="rw">
        <comment>id3 mstid_6 master id control id3 mstid_6 master id control</comment>
      </reg>
      <reg name="id3_mstid_7" protect="rw">
        <comment>id3 mstid_7 master id control id3 mstid_7 master id control</comment>
      </reg>
      <reg name="id4_first_addr_0" protect="rw">
        <comment>id4 first_addr control id4 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id4_last_addr_0" protect="rw">
        <comment>id4 last_addr control id4 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id4_mstid_0" protect="rw">
        <comment>id4 mstid_0 master id control id4 mstid_0 master id control</comment>
      </reg>
      <reg name="id4_mstid_1" protect="rw">
        <comment>id4 mstid_1 master id control id4 mstid_1 master id control</comment>
      </reg>
      <reg name="id4_mstid_2" protect="rw">
        <comment>id4 mstid_2 master id control id4 mstid_2 master id control</comment>
      </reg>
      <reg name="id4_mstid_3" protect="rw">
        <comment>id4 mstid_3 master id control id4 mstid_3 master id control</comment>
      </reg>
      <reg name="id4_mstid_4" protect="rw">
        <comment>id4 mstid_4 master id control id4 mstid_4 master id control</comment>
      </reg>
      <reg name="id4_mstid_5" protect="rw">
        <comment>id4 mstid_5 master id control id4 mstid_5 master id control</comment>
      </reg>
      <reg name="id4_mstid_6" protect="rw">
        <comment>id4 mstid_6 master id control id4 mstid_6 master id control</comment>
      </reg>
      <reg name="id4_mstid_7" protect="rw">
        <comment>id4 mstid_7 master id control id4 mstid_7 master id control</comment>
      </reg>
      <reg name="id5_first_addr_0" protect="rw">
        <comment>id5 first_addr control id5 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id5_last_addr_0" protect="rw">
        <comment>id5 last_addr control id5 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id5_mstid_0" protect="rw">
        <comment>id5 mstid_0 master id control id5 mstid_0 master id control</comment>
      </reg>
      <reg name="id5_mstid_1" protect="rw">
        <comment>id5 mstid_1 master id control id5 mstid_1 master id control</comment>
      </reg>
      <reg name="id5_mstid_2" protect="rw">
        <comment>id5 mstid_2 master id control id5 mstid_2 master id control</comment>
      </reg>
      <reg name="id5_mstid_3" protect="rw">
        <comment>id5 mstid_3 master id control id5 mstid_3 master id control</comment>
      </reg>
      <reg name="id5_mstid_4" protect="rw">
        <comment>id5 mstid_4 master id control id5 mstid_4 master id control</comment>
      </reg>
      <reg name="id5_mstid_5" protect="rw">
        <comment>id5 mstid_5 master id control id5 mstid_5 master id control</comment>
      </reg>
      <reg name="id5_mstid_6" protect="rw">
        <comment>id5 mstid_6 master id control id5 mstid_6 master id control</comment>
      </reg>
      <reg name="id5_mstid_7" protect="rw">
        <comment>id5 mstid_7 master id control id5 mstid_7 master id control</comment>
      </reg>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clk_gate_bypass clk_gate_bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clk_gate_bypass</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51322000" name="SLV_FW_AP_AHB" type="SLV_FW_AP_AHB"/>
  </archive>
  <archive relative="slv_fw_aon_ifc.xml">
    <module category="System" name="SLV_FW_AON_IFC">
      <reg name="port0_default_address_0" protect="rw">
        <comment>port0 default address, bit 0 ~ 15. port0 default address, bit 0 ~ 15.</comment>
        <bits access="rw" name="port0_default_address_0" pos="15:0" rst="0xdf00"/>
      </reg>
      <reg name="port_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int write-clear</comment>
        </bits>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_raw" protect="rw">
        <comment>Original interrupt reg %d Original interrupt reg %d</comment>
        <bits access="r" name="port_0_r_raw" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_fin" protect="rw">
        <comment>Final interrupt reg %d Final interrupt reg %d</comment>
        <bits access="r" name="port_0_r_fin" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="uart2_rd_sec" pos="11:10" rst="0x3">
          <comment>control uart2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart3_rd_sec" pos="9:8" rst="0x3">
          <comment>control uart3_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dbg_uart_rd_sec" pos="7:6" rst="0x3">
          <comment>control dbg_uart_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aif_rd_sec" pos="5:4" rst="0x3">
          <comment>control aif_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_ifc_rd_sec" pos="3:2" rst="0x3">
          <comment>control aon_ifc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dbg_host_rd_sec" pos="1:0" rst="0x3">
          <comment>control dbg_host_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="uart2_wr_sec" pos="11:10" rst="0x3">
          <comment>control uart2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart3_wr_sec" pos="9:8" rst="0x3">
          <comment>control uart3_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dbg_uart_wr_sec" pos="7:6" rst="0x3">
          <comment>control dbg_uart_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aif_wr_sec" pos="5:4" rst="0x3">
          <comment>control aif_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_ifc_wr_sec" pos="3:2" rst="0x3">
          <comment>control aon_ifc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dbg_host_wr_sec" pos="1:0" rst="0x3">
          <comment>control dbg_host_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="id0_first_addr_0" protect="rw">
        <comment>id0 first_addr control id0 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id0_last_addr_0" protect="rw">
        <comment>id0 last_addr control id0 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id0_mstid_0" protect="rw">
        <comment>id0 mstid_0 master id control id0 mstid_0 master id control</comment>
      </reg>
      <reg name="id0_mstid_1" protect="rw">
        <comment>id0 mstid_1 master id control id0 mstid_1 master id control</comment>
      </reg>
      <reg name="id0_mstid_2" protect="rw">
        <comment>id0 mstid_2 master id control id0 mstid_2 master id control</comment>
      </reg>
      <reg name="id0_mstid_3" protect="rw">
        <comment>id0 mstid_3 master id control id0 mstid_3 master id control</comment>
      </reg>
      <reg name="id0_mstid_4" protect="rw">
        <comment>id0 mstid_4 master id control id0 mstid_4 master id control</comment>
      </reg>
      <reg name="id0_mstid_5" protect="rw">
        <comment>id0 mstid_5 master id control id0 mstid_5 master id control</comment>
      </reg>
      <reg name="id0_mstid_6" protect="rw">
        <comment>id0 mstid_6 master id control id0 mstid_6 master id control</comment>
      </reg>
      <reg name="id0_mstid_7" protect="rw">
        <comment>id0 mstid_7 master id control id0 mstid_7 master id control</comment>
      </reg>
      <reg name="id1_first_addr_0" protect="rw">
        <comment>id1 first_addr control id1 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id1_last_addr_0" protect="rw">
        <comment>id1 last_addr control id1 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id1_mstid_0" protect="rw">
        <comment>id1 mstid_0 master id control id1 mstid_0 master id control</comment>
      </reg>
      <reg name="id1_mstid_1" protect="rw">
        <comment>id1 mstid_1 master id control id1 mstid_1 master id control</comment>
      </reg>
      <reg name="id1_mstid_2" protect="rw">
        <comment>id1 mstid_2 master id control id1 mstid_2 master id control</comment>
      </reg>
      <reg name="id1_mstid_3" protect="rw">
        <comment>id1 mstid_3 master id control id1 mstid_3 master id control</comment>
      </reg>
      <reg name="id1_mstid_4" protect="rw">
        <comment>id1 mstid_4 master id control id1 mstid_4 master id control</comment>
      </reg>
      <reg name="id1_mstid_5" protect="rw">
        <comment>id1 mstid_5 master id control id1 mstid_5 master id control</comment>
      </reg>
      <reg name="id1_mstid_6" protect="rw">
        <comment>id1 mstid_6 master id control id1 mstid_6 master id control</comment>
      </reg>
      <reg name="id1_mstid_7" protect="rw">
        <comment>id1 mstid_7 master id control id1 mstid_7 master id control</comment>
      </reg>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clk_gate_bypass clk_gate_bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clk_gate_bypass</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51301000" name="SLV_FW_AON_IFC" type="SLV_FW_AON_IFC"/>
  </archive>
  <archive relative="slv_fw_aon_ahb.xml">
    <module category="System" name="SLV_FW_AON_AHB">
      <reg name="port0_default_address_0" protect="rw">
        <comment>port0 default address, bit 0 ~ 26. port0 default address, bit 0 ~ 26.</comment>
        <bits access="rw" name="port0_default_address_0" pos="26:0" rst="0x7fff00"/>
      </reg>
      <reg name="port_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int write-clear</comment>
        </bits>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_raw" protect="rw">
        <comment>Original interrupt reg %d Original interrupt reg %d</comment>
        <bits access="r" name="port_0_r_raw" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_fin" protect="rw">
        <comment>Final interrupt reg %d Final interrupt reg %d</comment>
        <bits access="r" name="port_0_r_fin" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="idle_timer_rd_sec" pos="31:30" rst="0x3">
          <comment>control idle_timer_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_clk_pre_rd_sec" pos="29:28" rst="0x3">
          <comment>control aon_clk_pre_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_clk_core_rd_sec" pos="27:26" rst="0x3">
          <comment>control aon_clk_core_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aud_2ad_rd_sec" pos="25:24" rst="0x3">
          <comment>control aud_2ad_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt2_rd_sec" pos="23:22" rst="0x3">
          <comment>control gpt2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spi2_rd_sec" pos="21:20" rst="0x3">
          <comment>control spi2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt1_rd_sec" pos="19:18" rst="0x3">
          <comment>control gpt1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="djtag_cfg_rd_sec" pos="17:16" rst="0x3">
          <comment>control djtag_cfg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap2_rd_sec" pos="15:14" rst="0x3">
          <comment>control ana_wrap2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="iomux_rd_sec" pos="13:12" rst="0x3">
          <comment>control iomux_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dmc400_rd_sec" pos="11:10" rst="0x3">
          <comment>control dmc400_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="psram_phy_rd_sec" pos="9:8" rst="0x3">
          <comment>control psram_phy_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pagespy_rd_sec" pos="7:6" rst="0x3">
          <comment>control pagespy_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pub_apb_reg_rd_sec" pos="5:4" rst="0x3">
          <comment>control pub_apb_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dap_rd_sec" pos="3:2" rst="0x3">
          <comment>control dap_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pub_nic_gpv_rd_sec" pos="1:0" rst="0x3">
          <comment>control pub_nic_gpv_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="rd_sec_1" protect="rw">
        <comment>rd 1 sec control rd 1 sec control</comment>
        <bits access="rw" name="spinlock_rd_sec" pos="25:24" rst="0x3">
          <comment>control spinlock_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_rd_sec" pos="23:22" rst="0x3">
          <comment>control adi_mst_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_sp0_rd_sec" pos="21:20" rst="0x3">
          <comment>control adi_mst_sp0_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_sp1_rd_sec" pos="19:18" rst="0x3">
          <comment>control adi_mst_sp1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="efuse_rd_sec" pos="17:16" rst="0x3">
          <comment>control efuse_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="tzpc_rd_sec" pos="15:14" rst="0x3">
          <comment>control tzpc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sys_ctrl_rd_sec" pos="13:12" rst="0x3">
          <comment>control sys_ctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap1_rd_sec" pos="11:10" rst="0x3">
          <comment>control ana_wrap1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="mon_ctrl_rd_sec" pos="9:8" rst="0x3">
          <comment>control mon_ctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpio2_rd_sec" pos="7:6" rst="0x3">
          <comment>control gpio2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c3_rd_sec" pos="5:4" rst="0x3">
          <comment>control i2c3_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="scc_top_rd_sec" pos="3:2" rst="0x3">
          <comment>control scc_top_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sysmail_rd_sec" pos="1:0" rst="0x3">
          <comment>control sysmail_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="idle_timer_wr_sec" pos="31:30" rst="0x3">
          <comment>control idle_timer_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_clk_pre_wr_sec" pos="29:28" rst="0x3">
          <comment>control aon_clk_pre_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_clk_core_wr_sec" pos="27:26" rst="0x3">
          <comment>control aon_clk_core_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aud_2ad_wr_sec" pos="25:24" rst="0x3">
          <comment>control aud_2ad_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt2_wr_sec" pos="23:22" rst="0x3">
          <comment>control gpt2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spi2_wr_sec" pos="21:20" rst="0x3">
          <comment>control spi2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt1_wr_sec" pos="19:18" rst="0x3">
          <comment>control gpt1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="djtag_cfg_wr_sec" pos="17:16" rst="0x3">
          <comment>control djtag_cfg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap2_wr_sec" pos="15:14" rst="0x3">
          <comment>control ana_wrap2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="iomux_wr_sec" pos="13:12" rst="0x3">
          <comment>control iomux_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dmc400_wr_sec" pos="11:10" rst="0x3">
          <comment>control dmc400_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="psram_phy_wr_sec" pos="9:8" rst="0x3">
          <comment>control psram_phy_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pagespy_wr_sec" pos="7:6" rst="0x3">
          <comment>control pagespy_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pub_apb_reg_wr_sec" pos="5:4" rst="0x3">
          <comment>control pub_apb_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dap_wr_sec" pos="3:2" rst="0x3">
          <comment>control dap_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pub_nic_gpv_wr_sec" pos="1:0" rst="0x3">
          <comment>control pub_nic_gpv_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_1" protect="rw">
        <comment>wr 1 sec control wr 1 sec control</comment>
        <bits access="rw" name="spinlock_wr_sec" pos="25:24" rst="0x3">
          <comment>control spinlock_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_wr_sec" pos="23:22" rst="0x3">
          <comment>control adi_mst_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_sp0_wr_sec" pos="21:20" rst="0x3">
          <comment>control adi_mst_sp0_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_sp1_wr_sec" pos="19:18" rst="0x3">
          <comment>control adi_mst_sp1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="efuse_wr_sec" pos="17:16" rst="0x3">
          <comment>control efuse_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="tzpc_wr_sec" pos="15:14" rst="0x3">
          <comment>control tzpc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sys_ctrl_wr_sec" pos="13:12" rst="0x3">
          <comment>control sys_ctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap1_wr_sec" pos="11:10" rst="0x3">
          <comment>control ana_wrap1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="mon_ctrl_wr_sec" pos="9:8" rst="0x3">
          <comment>control mon_ctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpio2_wr_sec" pos="7:6" rst="0x3">
          <comment>control gpio2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c3_wr_sec" pos="5:4" rst="0x3">
          <comment>control i2c3_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="scc_top_wr_sec" pos="3:2" rst="0x3">
          <comment>control scc_top_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sysmail_wr_sec" pos="1:0" rst="0x3">
          <comment>control sysmail_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="id0_first_addr_0" protect="rw">
        <comment>id0 first_addr control id0 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id0_last_addr_0" protect="rw">
        <comment>id0 last_addr control id0 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id0_mstid_0" protect="rw">
        <comment>id0 mstid_0 master id control id0 mstid_0 master id control</comment>
      </reg>
      <reg name="id0_mstid_1" protect="rw">
        <comment>id0 mstid_1 master id control id0 mstid_1 master id control</comment>
      </reg>
      <reg name="id0_mstid_2" protect="rw">
        <comment>id0 mstid_2 master id control id0 mstid_2 master id control</comment>
      </reg>
      <reg name="id0_mstid_3" protect="rw">
        <comment>id0 mstid_3 master id control id0 mstid_3 master id control</comment>
      </reg>
      <reg name="id0_mstid_4" protect="rw">
        <comment>id0 mstid_4 master id control id0 mstid_4 master id control</comment>
      </reg>
      <reg name="id0_mstid_5" protect="rw">
        <comment>id0 mstid_5 master id control id0 mstid_5 master id control</comment>
      </reg>
      <reg name="id0_mstid_6" protect="rw">
        <comment>id0 mstid_6 master id control id0 mstid_6 master id control</comment>
      </reg>
      <reg name="id0_mstid_7" protect="rw">
        <comment>id0 mstid_7 master id control id0 mstid_7 master id control</comment>
      </reg>
      <reg name="id1_first_addr_0" protect="rw">
        <comment>id1 first_addr control id1 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id1_last_addr_0" protect="rw">
        <comment>id1 last_addr control id1 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id1_mstid_0" protect="rw">
        <comment>id1 mstid_0 master id control id1 mstid_0 master id control</comment>
      </reg>
      <reg name="id1_mstid_1" protect="rw">
        <comment>id1 mstid_1 master id control id1 mstid_1 master id control</comment>
      </reg>
      <reg name="id1_mstid_2" protect="rw">
        <comment>id1 mstid_2 master id control id1 mstid_2 master id control</comment>
      </reg>
      <reg name="id1_mstid_3" protect="rw">
        <comment>id1 mstid_3 master id control id1 mstid_3 master id control</comment>
      </reg>
      <reg name="id1_mstid_4" protect="rw">
        <comment>id1 mstid_4 master id control id1 mstid_4 master id control</comment>
      </reg>
      <reg name="id1_mstid_5" protect="rw">
        <comment>id1 mstid_5 master id control id1 mstid_5 master id control</comment>
      </reg>
      <reg name="id1_mstid_6" protect="rw">
        <comment>id1 mstid_6 master id control id1 mstid_6 master id control</comment>
      </reg>
      <reg name="id1_mstid_7" protect="rw">
        <comment>id1 mstid_7 master id control id1 mstid_7 master id control</comment>
      </reg>
      <reg name="id2_first_addr_0" protect="rw">
        <comment>id2 first_addr control id2 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id2_last_addr_0" protect="rw">
        <comment>id2 last_addr control id2 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id2_mstid_0" protect="rw">
        <comment>id2 mstid_0 master id control id2 mstid_0 master id control</comment>
      </reg>
      <reg name="id2_mstid_1" protect="rw">
        <comment>id2 mstid_1 master id control id2 mstid_1 master id control</comment>
      </reg>
      <reg name="id2_mstid_2" protect="rw">
        <comment>id2 mstid_2 master id control id2 mstid_2 master id control</comment>
      </reg>
      <reg name="id2_mstid_3" protect="rw">
        <comment>id2 mstid_3 master id control id2 mstid_3 master id control</comment>
      </reg>
      <reg name="id2_mstid_4" protect="rw">
        <comment>id2 mstid_4 master id control id2 mstid_4 master id control</comment>
      </reg>
      <reg name="id2_mstid_5" protect="rw">
        <comment>id2 mstid_5 master id control id2 mstid_5 master id control</comment>
      </reg>
      <reg name="id2_mstid_6" protect="rw">
        <comment>id2 mstid_6 master id control id2 mstid_6 master id control</comment>
      </reg>
      <reg name="id2_mstid_7" protect="rw">
        <comment>id2 mstid_7 master id control id2 mstid_7 master id control</comment>
      </reg>
      <reg name="id3_first_addr_0" protect="rw">
        <comment>id3 first_addr control id3 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id3_last_addr_0" protect="rw">
        <comment>id3 last_addr control id3 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id3_mstid_0" protect="rw">
        <comment>id3 mstid_0 master id control id3 mstid_0 master id control</comment>
      </reg>
      <reg name="id3_mstid_1" protect="rw">
        <comment>id3 mstid_1 master id control id3 mstid_1 master id control</comment>
      </reg>
      <reg name="id3_mstid_2" protect="rw">
        <comment>id3 mstid_2 master id control id3 mstid_2 master id control</comment>
      </reg>
      <reg name="id3_mstid_3" protect="rw">
        <comment>id3 mstid_3 master id control id3 mstid_3 master id control</comment>
      </reg>
      <reg name="id3_mstid_4" protect="rw">
        <comment>id3 mstid_4 master id control id3 mstid_4 master id control</comment>
      </reg>
      <reg name="id3_mstid_5" protect="rw">
        <comment>id3 mstid_5 master id control id3 mstid_5 master id control</comment>
      </reg>
      <reg name="id3_mstid_6" protect="rw">
        <comment>id3 mstid_6 master id control id3 mstid_6 master id control</comment>
      </reg>
      <reg name="id3_mstid_7" protect="rw">
        <comment>id3 mstid_7 master id control id3 mstid_7 master id control</comment>
      </reg>
      <reg name="id4_first_addr_0" protect="rw">
        <comment>id4 first_addr control id4 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id4_last_addr_0" protect="rw">
        <comment>id4 last_addr control id4 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id4_mstid_0" protect="rw">
        <comment>id4 mstid_0 master id control id4 mstid_0 master id control</comment>
      </reg>
      <reg name="id4_mstid_1" protect="rw">
        <comment>id4 mstid_1 master id control id4 mstid_1 master id control</comment>
      </reg>
      <reg name="id4_mstid_2" protect="rw">
        <comment>id4 mstid_2 master id control id4 mstid_2 master id control</comment>
      </reg>
      <reg name="id4_mstid_3" protect="rw">
        <comment>id4 mstid_3 master id control id4 mstid_3 master id control</comment>
      </reg>
      <reg name="id4_mstid_4" protect="rw">
        <comment>id4 mstid_4 master id control id4 mstid_4 master id control</comment>
      </reg>
      <reg name="id4_mstid_5" protect="rw">
        <comment>id4 mstid_5 master id control id4 mstid_5 master id control</comment>
      </reg>
      <reg name="id4_mstid_6" protect="rw">
        <comment>id4 mstid_6 master id control id4 mstid_6 master id control</comment>
      </reg>
      <reg name="id4_mstid_7" protect="rw">
        <comment>id4 mstid_7 master id control id4 mstid_7 master id control</comment>
      </reg>
      <reg name="id5_first_addr_0" protect="rw">
        <comment>id5 first_addr control id5 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id5_last_addr_0" protect="rw">
        <comment>id5 last_addr control id5 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id5_mstid_0" protect="rw">
        <comment>id5 mstid_0 master id control id5 mstid_0 master id control</comment>
      </reg>
      <reg name="id5_mstid_1" protect="rw">
        <comment>id5 mstid_1 master id control id5 mstid_1 master id control</comment>
      </reg>
      <reg name="id5_mstid_2" protect="rw">
        <comment>id5 mstid_2 master id control id5 mstid_2 master id control</comment>
      </reg>
      <reg name="id5_mstid_3" protect="rw">
        <comment>id5 mstid_3 master id control id5 mstid_3 master id control</comment>
      </reg>
      <reg name="id5_mstid_4" protect="rw">
        <comment>id5 mstid_4 master id control id5 mstid_4 master id control</comment>
      </reg>
      <reg name="id5_mstid_5" protect="rw">
        <comment>id5 mstid_5 master id control id5 mstid_5 master id control</comment>
      </reg>
      <reg name="id5_mstid_6" protect="rw">
        <comment>id5 mstid_6 master id control id5 mstid_6 master id control</comment>
      </reg>
      <reg name="id5_mstid_7" protect="rw">
        <comment>id5 mstid_7 master id control id5 mstid_7 master id control</comment>
      </reg>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clk_gate_bypass clk_gate_bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clk_gate_bypass</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51302000" name="SLV_FW_AON_AHB" type="SLV_FW_AON_AHB"/>
  </archive>
  <archive relative="mst_flt_aon_rf.xml">
    <module category="System" name="MST_FLT_AON_RF">
      <reg name="mst_filter_id0" protect="rw">
        <comment>mst_filter_id0 mst_filter_id0</comment>
      </reg>
      <reg name="mst_filter_id1" protect="rw">
        <comment>mst_filter_id1 mst_filter_id1</comment>
      </reg>
      <reg name="mst_filter_id2" protect="rw">
        <comment>mst_filter_id2 mst_filter_id2</comment>
      </reg>
      <reg name="mst_filter_id3" protect="rw">
        <comment>mst_filter_id3 mst_filter_id3</comment>
      </reg>
      <reg name="mst_filter_id4" protect="rw">
        <comment>mst_filter_id4 mst_filter_id4</comment>
      </reg>
      <reg name="mst_filter_id5" protect="rw">
        <comment>mst_filter_id5 mst_filter_id5</comment>
      </reg>
      <reg name="mst_filter_id6" protect="rw">
        <comment>mst_filter_id6 mst_filter_id6</comment>
      </reg>
      <reg name="mst_filter_id7" protect="rw">
        <comment>mst_filter_id7 mst_filter_id7</comment>
      </reg>
      <reg name="mst_filter_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="mst_filter_int_en" pos="0" rst="0x0">
          <comment>read/write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_raw0" protect="rw">
        <comment>Original interrupt reg  Original interrupt reg</comment>
        <bits access="r" name="mst_filter_int_raw0" pos="0" rst="0x0">
          <comment>read/write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_status0" protect="rw">
        <comment>Interrupt status reg  Interrupt status reg</comment>
        <bits access="r" name="mst_filter_int_status0" pos="0" rst="0x0">
          <comment>read/write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="mst_filter_int_clr" pos="0" rst="0x0">
          <comment>read/write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="mst_filter_debug_reg0" protect="rw">
        <comment>debug register debug register</comment>
      </reg>
      <reg name="mst_filter_debug_reg2" protect="rw">
        <comment>debug register debug register</comment>
        <bits access="r" name="mst_filter_debug_hwrite" pos="8" rst="0x0"/>
        <bits access="r" name="mst_filter_debug_hauser" pos="7:0" rst="0x0">
          <comment>when miss, latch hauser</comment>
        </bits>
      </reg>
      <reg name="mst_filter_resp" protect="rw">
        <comment>response error reg responce error reg</comment>
        <bits access="rw" name="mst_filter_resp_en" pos="0" rst="0x0">
          <comment>read/write channel address miss int write-clear</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51304000" name="MST_FLT_AON_RF" type="MST_FLT_AON_RF"/>
  </archive>
  <archive relative="mst_flt_aon_cp.xml">
    <module category="System" name="MST_FLT_AON_CP">
      <reg name="mst_filter_id0" protect="rw">
        <comment>mst_filter_id0 mst_filter_id0</comment>
      </reg>
      <reg name="mst_filter_id1" protect="rw">
        <comment>mst_filter_id1 mst_filter_id1</comment>
      </reg>
      <reg name="mst_filter_id2" protect="rw">
        <comment>mst_filter_id2 mst_filter_id2</comment>
      </reg>
      <reg name="mst_filter_id3" protect="rw">
        <comment>mst_filter_id3 mst_filter_id3</comment>
      </reg>
      <reg name="mst_filter_id4" protect="rw">
        <comment>mst_filter_id4 mst_filter_id4</comment>
      </reg>
      <reg name="mst_filter_id5" protect="rw">
        <comment>mst_filter_id5 mst_filter_id5</comment>
      </reg>
      <reg name="mst_filter_id6" protect="rw">
        <comment>mst_filter_id6 mst_filter_id6</comment>
      </reg>
      <reg name="mst_filter_id7" protect="rw">
        <comment>mst_filter_id7 mst_filter_id7</comment>
      </reg>
      <reg name="mst_filter_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="mst_filter_int_en" pos="0" rst="0x0">
          <comment>read/write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_raw0" protect="rw">
        <comment>Original interrupt reg  Original interrupt reg</comment>
        <bits access="r" name="mst_filter_int_raw0" pos="0" rst="0x0">
          <comment>read/write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_status0" protect="rw">
        <comment>Interrupt status reg  Interrupt status reg</comment>
        <bits access="r" name="mst_filter_int_status0" pos="0" rst="0x0">
          <comment>read/write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="mst_filter_int_clr" pos="0" rst="0x0">
          <comment>read/write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="mst_filter_debug_reg0" protect="rw">
        <comment>debug register debug register</comment>
      </reg>
      <reg name="mst_filter_debug_reg2" protect="rw">
        <comment>debug register debug register</comment>
        <bits access="r" name="mst_filter_debug_hwrite" pos="8" rst="0x0"/>
        <bits access="r" name="mst_filter_debug_hauser" pos="7:0" rst="0x0">
          <comment>when miss, latch hauser</comment>
        </bits>
      </reg>
      <reg name="mst_filter_resp" protect="rw">
        <comment>response error reg responce error reg</comment>
        <bits access="rw" name="mst_filter_resp_en" pos="0" rst="0x0">
          <comment>read/write channel address miss int write-clear</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51303000" name="MST_FLT_AON_CP" type="MST_FLT_AON_CP"/>
  </archive>
  <archive relative="mem_fw_spiflash2.xml">
    <module category="System" name="MEM_FW_SPIFLASH2">
      <reg name="port0_default_r_addr_0" protect="rw">
        <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10). default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_r_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <reg name="port0_default_w_addr_0" protect="rw">
        <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10). default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_w_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <hole size="1984"/>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clock gate bypass clock gate bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clock gate bypass</comment>
        </bits>
      </reg>
      <hole size="2016"/>
      <reg name="port_int_w_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_w_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_w_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_w_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="0" rst="0x0">
          <comment>Port 0 read address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_r_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="0" rst="0x0">
          <comment>Port 0 read address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_r_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_r_raw" pos="0" rst="0x0">
          <comment>Port 0 read address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_r_fin" pos="0" rst="0x0">
          <comment>Port 0 read address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <hole size="3840"/>
      <reg name="port_0_w_debug_addr" protect="rw">
        <comment>Debug address register for port 0 write channel Debug address register for port 0 write channel</comment>
        <bits access="r" name="w_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 write channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_w_debug_id" protect="rw">
        <comment>Debug id register for port 0 write channel Debug id register for port 0 write channel</comment>
        <bits access="r" name="w_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 write channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_addr" protect="rw">
        <comment>Debug address register for port 0 read channel Debug address register for port 0 read channel</comment>
        <bits access="r" name="r_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 read channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_id" protect="rw">
        <comment>Debug id register for port 0 read channel Debug id register for port 0 read channel</comment>
        <bits access="r" name="r_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 read channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <hole size="8064"/>
      <reg name="seg_default_first_addr" protect="rw">
        <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte) Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_last_addr" protect="rw">
        <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte) Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_mst_r_id0" protect="rw">
        <comment>Default Segment Read Master ID select 0~31 Default Segment Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_r_id1" protect="rw">
        <comment>Default Segment Read Master ID select 32~63 Default Segment Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_r_id2" protect="rw">
        <comment>Default Segment Read Master ID select 64~95 Default Segment Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_r_id3" protect="rw">
        <comment>Default Segment Read Master ID select 96~127 Default Segment Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_r_id4" protect="rw">
        <comment>Default Segment Read Master ID select 128~159 Default Segment Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_r_id5" protect="rw">
        <comment>Default Segment Read Master ID select 160~191 Default Segment Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_r_id6" protect="rw">
        <comment>Default Segment Read Master ID select 192~223 Default Segment Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_r_id7" protect="rw">
        <comment>Default Segment Read Master ID select 224~255 Default Segment Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_default_mst_w_id0" protect="rw">
        <comment>Default Segment write Master ID select 0~31 Default Segment write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_w_id1" protect="rw">
        <comment>Default Segment write Master ID select 32~63 Default Segment write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_w_id2" protect="rw">
        <comment>Default Segment write Master ID select 64~95 Default Segment write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_w_id3" protect="rw">
        <comment>Default Segment write Master ID select 96~127 Default Segment write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_w_id4" protect="rw">
        <comment>Default Segment write Master ID select 128~159 Default Segment write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_w_id5" protect="rw">
        <comment>Default Segment write Master ID select 160~191 Default Segment write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_w_id6" protect="rw">
        <comment>Default Segment write Master ID select 192~223 Default Segment write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_w_id7" protect="rw">
        <comment>Default Segment write Master ID select 224~255 Default Segment write Master ID select 224~255</comment>
      </reg>
      <hole size="15808"/>
      <reg name="seg_0_first_addr" protect="rw">
        <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte) Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_last_addr" protect="rw">
        <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte) Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_mst_r_id0" protect="rw">
        <comment>Segment 0 Read Master ID select 0~31 Segment 0 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_r_id1" protect="rw">
        <comment>Segment 0 Read Master ID select 32~63 Segment 0 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_r_id2" protect="rw">
        <comment>Segment 0 Read Master ID select 64~95 Segment 0 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_r_id3" protect="rw">
        <comment>Segment 0 Read Master ID select 96~127 Segment 0 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_r_id4" protect="rw">
        <comment>Segment 0 Read Master ID select 128~159 Segment 0 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_r_id5" protect="rw">
        <comment>Segment 0 Read Master ID select 160~191 Segment 0 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_r_id6" protect="rw">
        <comment>Segment 0 Read Master ID select 192~223 Segment 0 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_r_id7" protect="rw">
        <comment>Segment 0 Read Master ID select 224~255 Segment 0 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_0_mst_w_id0" protect="rw">
        <comment>Segment 0 Write Master ID select 0~31 Segment 0 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_w_id1" protect="rw">
        <comment>Segment 0 Write Master ID select 32~63 Segment 0 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_w_id2" protect="rw">
        <comment>Segment 0 Write Master ID select 64~95 Segment 0 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_w_id3" protect="rw">
        <comment>Segment 0 Write Master ID select 96~127 Segment 0 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_w_id4" protect="rw">
        <comment>Segment 0 Write Master ID select 128~159 Segment 0 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_w_id5" protect="rw">
        <comment>Segment 0 Write Master ID select 160~191 Segment 0 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_w_id6" protect="rw">
        <comment>Segment 0 Write Master ID select 192~223 Segment 0 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_w_id7" protect="rw">
        <comment>Segment 0 Write Master ID select 224~255 Segment 0 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_1_first_addr" protect="rw">
        <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte) Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_last_addr" protect="rw">
        <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte) Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_mst_r_id0" protect="rw">
        <comment>Segment 1 Read Master ID select 0~31 Segment 1 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_r_id1" protect="rw">
        <comment>Segment 1 Read Master ID select 32~63 Segment 1 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_r_id2" protect="rw">
        <comment>Segment 1 Read Master ID select 64~95 Segment 1 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_r_id3" protect="rw">
        <comment>Segment 1 Read Master ID select 96~127 Segment 1 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_r_id4" protect="rw">
        <comment>Segment 1 Read Master ID select 128~159 Segment 1 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_r_id5" protect="rw">
        <comment>Segment 1 Read Master ID select 160~191 Segment 1 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_r_id6" protect="rw">
        <comment>Segment 1 Read Master ID select 192~223 Segment 1 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_r_id7" protect="rw">
        <comment>Segment 1 Read Master ID select 224~255 Segment 1 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_1_mst_w_id0" protect="rw">
        <comment>Segment 1 Write Master ID select 0~31 Segment 1 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_w_id1" protect="rw">
        <comment>Segment 1 Write Master ID select 32~63 Segment 1 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_w_id2" protect="rw">
        <comment>Segment 1 Write Master ID select 64~95 Segment 1 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_w_id3" protect="rw">
        <comment>Segment 1 Write Master ID select 96~127 Segment 1 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_w_id4" protect="rw">
        <comment>Segment 1 Write Master ID select 128~159 Segment 1 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_w_id5" protect="rw">
        <comment>Segment 1 Write Master ID select 160~191 Segment 1 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_w_id6" protect="rw">
        <comment>Segment 1 Write Master ID select 192~223 Segment 1 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_w_id7" protect="rw">
        <comment>Segment 1 Write Master ID select 224~255 Segment 1 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_2_first_addr" protect="rw">
        <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte) Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_last_addr" protect="rw">
        <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte) Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_mst_r_id0" protect="rw">
        <comment>Segment 2 Read Master ID select 0~31 Segment 2 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_r_id1" protect="rw">
        <comment>Segment 2 Read Master ID select 32~63 Segment 2 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_r_id2" protect="rw">
        <comment>Segment 2 Read Master ID select 64~95 Segment 2 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_r_id3" protect="rw">
        <comment>Segment 2 Read Master ID select 96~127 Segment 2 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_r_id4" protect="rw">
        <comment>Segment 2 Read Master ID select 128~159 Segment 2 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_r_id5" protect="rw">
        <comment>Segment 2 Read Master ID select 160~191 Segment 2 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_r_id6" protect="rw">
        <comment>Segment 2 Read Master ID select 192~223 Segment 2 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_r_id7" protect="rw">
        <comment>Segment 2 Read Master ID select 224~255 Segment 2 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_2_mst_w_id0" protect="rw">
        <comment>Segment 2 Write Master ID select 0~31 Segment 2 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_w_id1" protect="rw">
        <comment>Segment 2 Write Master ID select 32~63 Segment 2 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_w_id2" protect="rw">
        <comment>Segment 2 Write Master ID select 64~95 Segment 2 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_w_id3" protect="rw">
        <comment>Segment 2 Write Master ID select 96~127 Segment 2 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_w_id4" protect="rw">
        <comment>Segment 2 Write Master ID select 128~159 Segment 2 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_w_id5" protect="rw">
        <comment>Segment 2 Write Master ID select 160~191 Segment 2 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_w_id6" protect="rw">
        <comment>Segment 2 Write Master ID select 192~223 Segment 2 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_w_id7" protect="rw">
        <comment>Segment 2 Write Master ID select 224~255 Segment 2 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_3_first_addr" protect="rw">
        <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte) Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_last_addr" protect="rw">
        <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte) Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_mst_r_id0" protect="rw">
        <comment>Segment 3 Read Master ID select 0~31 Segment 3 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_r_id1" protect="rw">
        <comment>Segment 3 Read Master ID select 32~63 Segment 3 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_r_id2" protect="rw">
        <comment>Segment 3 Read Master ID select 64~95 Segment 3 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_r_id3" protect="rw">
        <comment>Segment 3 Read Master ID select 96~127 Segment 3 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_r_id4" protect="rw">
        <comment>Segment 3 Read Master ID select 128~159 Segment 3 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_r_id5" protect="rw">
        <comment>Segment 3 Read Master ID select 160~191 Segment 3 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_r_id6" protect="rw">
        <comment>Segment 3 Read Master ID select 192~223 Segment 3 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_r_id7" protect="rw">
        <comment>Segment 3 Read Master ID select 224~255 Segment 3 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_3_mst_w_id0" protect="rw">
        <comment>Segment 3 Write Master ID select 0~31 Segment 3 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_w_id1" protect="rw">
        <comment>Segment 3 Write Master ID select 32~63 Segment 3 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_w_id2" protect="rw">
        <comment>Segment 3 Write Master ID select 64~95 Segment 3 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_w_id3" protect="rw">
        <comment>Segment 3 Write Master ID select 96~127 Segment 3 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_w_id4" protect="rw">
        <comment>Segment 3 Write Master ID select 128~159 Segment 3 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_w_id5" protect="rw">
        <comment>Segment 3 Write Master ID select 160~191 Segment 3 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_w_id6" protect="rw">
        <comment>Segment 3 Write Master ID select 192~223 Segment 3 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_w_id7" protect="rw">
        <comment>Segment 3 Write Master ID select 224~255 Segment 3 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_4_first_addr" protect="rw">
        <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte) Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_last_addr" protect="rw">
        <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte) Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_mst_r_id0" protect="rw">
        <comment>Segment 4 Read Master ID select 0~31 Segment 4 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_r_id1" protect="rw">
        <comment>Segment 4 Read Master ID select 32~63 Segment 4 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_r_id2" protect="rw">
        <comment>Segment 4 Read Master ID select 64~95 Segment 4 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_r_id3" protect="rw">
        <comment>Segment 4 Read Master ID select 96~127 Segment 4 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_r_id4" protect="rw">
        <comment>Segment 4 Read Master ID select 128~159 Segment 4 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_r_id5" protect="rw">
        <comment>Segment 4 Read Master ID select 160~191 Segment 4 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_r_id6" protect="rw">
        <comment>Segment 4 Read Master ID select 192~223 Segment 4 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_r_id7" protect="rw">
        <comment>Segment 4 Read Master ID select 224~255 Segment 4 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_4_mst_w_id0" protect="rw">
        <comment>Segment 4 Write Master ID select 0~31 Segment 4 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_w_id1" protect="rw">
        <comment>Segment 4 Write Master ID select 32~63 Segment 4 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_w_id2" protect="rw">
        <comment>Segment 4 Write Master ID select 64~95 Segment 4 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_w_id3" protect="rw">
        <comment>Segment 4 Write Master ID select 96~127 Segment 4 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_w_id4" protect="rw">
        <comment>Segment 4 Write Master ID select 128~159 Segment 4 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_w_id5" protect="rw">
        <comment>Segment 4 Write Master ID select 160~191 Segment 4 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_w_id6" protect="rw">
        <comment>Segment 4 Write Master ID select 192~223 Segment 4 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_w_id7" protect="rw">
        <comment>Segment 4 Write Master ID select 224~255 Segment 4 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_5_first_addr" protect="rw">
        <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte) Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_last_addr" protect="rw">
        <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte) Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_mst_r_id0" protect="rw">
        <comment>Segment 5 Read Master ID select 0~31 Segment 5 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_r_id1" protect="rw">
        <comment>Segment 5 Read Master ID select 32~63 Segment 5 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_r_id2" protect="rw">
        <comment>Segment 5 Read Master ID select 64~95 Segment 5 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_r_id3" protect="rw">
        <comment>Segment 5 Read Master ID select 96~127 Segment 5 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_r_id4" protect="rw">
        <comment>Segment 5 Read Master ID select 128~159 Segment 5 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_r_id5" protect="rw">
        <comment>Segment 5 Read Master ID select 160~191 Segment 5 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_r_id6" protect="rw">
        <comment>Segment 5 Read Master ID select 192~223 Segment 5 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_r_id7" protect="rw">
        <comment>Segment 5 Read Master ID select 224~255 Segment 5 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_5_mst_w_id0" protect="rw">
        <comment>Segment 5 Write Master ID select 0~31 Segment 5 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_w_id1" protect="rw">
        <comment>Segment 5 Write Master ID select 32~63 Segment 5 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_w_id2" protect="rw">
        <comment>Segment 5 Write Master ID select 64~95 Segment 5 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_w_id3" protect="rw">
        <comment>Segment 5 Write Master ID select 96~127 Segment 5 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_w_id4" protect="rw">
        <comment>Segment 5 Write Master ID select 128~159 Segment 5 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_w_id5" protect="rw">
        <comment>Segment 5 Write Master ID select 160~191 Segment 5 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_w_id6" protect="rw">
        <comment>Segment 5 Write Master ID select 192~223 Segment 5 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_w_id7" protect="rw">
        <comment>Segment 5 Write Master ID select 224~255 Segment 5 Write Master ID select 224~255</comment>
      </reg>
    </module>
    <instance address="0x51328000" name="MEM_FW_SPIFLASH2" type="MEM_FW_SPIFLASH2"/>
  </archive>
  <archive relative="mem_fw_spiflash1.xml">
    <module category="System" name="MEM_FW_SPIFLASH1">
      <reg name="port0_default_r_addr_0" protect="rw">
        <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10). default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_r_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <reg name="port0_default_w_addr_0" protect="rw">
        <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10). default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_w_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <hole size="1984"/>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clock gate bypass clock gate bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clock gate bypass</comment>
        </bits>
      </reg>
      <hole size="2016"/>
      <reg name="port_int_w_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_w_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_w_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_w_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="0" rst="0x0">
          <comment>Port 0 read address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_r_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="0" rst="0x0">
          <comment>Port 0 read address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_r_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_r_raw" pos="0" rst="0x0">
          <comment>Port 0 read address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_r_fin" pos="0" rst="0x0">
          <comment>Port 0 read address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <hole size="3840"/>
      <reg name="port_0_w_debug_addr" protect="rw">
        <comment>Debug address register for port 0 write channel Debug address register for port 0 write channel</comment>
        <bits access="r" name="w_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 write channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_w_debug_id" protect="rw">
        <comment>Debug id register for port 0 write channel Debug id register for port 0 write channel</comment>
        <bits access="r" name="w_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 write channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_addr" protect="rw">
        <comment>Debug address register for port 0 read channel Debug address register for port 0 read channel</comment>
        <bits access="r" name="r_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 read channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_id" protect="rw">
        <comment>Debug id register for port 0 read channel Debug id register for port 0 read channel</comment>
        <bits access="r" name="r_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 read channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <hole size="8064"/>
      <reg name="seg_default_first_addr" protect="rw">
        <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte) Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_last_addr" protect="rw">
        <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte) Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_mst_r_id0" protect="rw">
        <comment>Default Segment Read Master ID select 0~31 Default Segment Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_r_id1" protect="rw">
        <comment>Default Segment Read Master ID select 32~63 Default Segment Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_r_id2" protect="rw">
        <comment>Default Segment Read Master ID select 64~95 Default Segment Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_r_id3" protect="rw">
        <comment>Default Segment Read Master ID select 96~127 Default Segment Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_r_id4" protect="rw">
        <comment>Default Segment Read Master ID select 128~159 Default Segment Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_r_id5" protect="rw">
        <comment>Default Segment Read Master ID select 160~191 Default Segment Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_r_id6" protect="rw">
        <comment>Default Segment Read Master ID select 192~223 Default Segment Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_r_id7" protect="rw">
        <comment>Default Segment Read Master ID select 224~255 Default Segment Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_default_mst_w_id0" protect="rw">
        <comment>Default Segment write Master ID select 0~31 Default Segment write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_w_id1" protect="rw">
        <comment>Default Segment write Master ID select 32~63 Default Segment write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_w_id2" protect="rw">
        <comment>Default Segment write Master ID select 64~95 Default Segment write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_w_id3" protect="rw">
        <comment>Default Segment write Master ID select 96~127 Default Segment write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_w_id4" protect="rw">
        <comment>Default Segment write Master ID select 128~159 Default Segment write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_w_id5" protect="rw">
        <comment>Default Segment write Master ID select 160~191 Default Segment write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_w_id6" protect="rw">
        <comment>Default Segment write Master ID select 192~223 Default Segment write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_w_id7" protect="rw">
        <comment>Default Segment write Master ID select 224~255 Default Segment write Master ID select 224~255</comment>
      </reg>
      <hole size="15808"/>
      <reg name="seg_0_first_addr" protect="rw">
        <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte) Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_last_addr" protect="rw">
        <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte) Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_mst_r_id0" protect="rw">
        <comment>Segment 0 Read Master ID select 0~31 Segment 0 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_r_id1" protect="rw">
        <comment>Segment 0 Read Master ID select 32~63 Segment 0 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_r_id2" protect="rw">
        <comment>Segment 0 Read Master ID select 64~95 Segment 0 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_r_id3" protect="rw">
        <comment>Segment 0 Read Master ID select 96~127 Segment 0 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_r_id4" protect="rw">
        <comment>Segment 0 Read Master ID select 128~159 Segment 0 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_r_id5" protect="rw">
        <comment>Segment 0 Read Master ID select 160~191 Segment 0 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_r_id6" protect="rw">
        <comment>Segment 0 Read Master ID select 192~223 Segment 0 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_r_id7" protect="rw">
        <comment>Segment 0 Read Master ID select 224~255 Segment 0 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_0_mst_w_id0" protect="rw">
        <comment>Segment 0 Write Master ID select 0~31 Segment 0 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_w_id1" protect="rw">
        <comment>Segment 0 Write Master ID select 32~63 Segment 0 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_w_id2" protect="rw">
        <comment>Segment 0 Write Master ID select 64~95 Segment 0 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_w_id3" protect="rw">
        <comment>Segment 0 Write Master ID select 96~127 Segment 0 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_w_id4" protect="rw">
        <comment>Segment 0 Write Master ID select 128~159 Segment 0 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_w_id5" protect="rw">
        <comment>Segment 0 Write Master ID select 160~191 Segment 0 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_w_id6" protect="rw">
        <comment>Segment 0 Write Master ID select 192~223 Segment 0 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_w_id7" protect="rw">
        <comment>Segment 0 Write Master ID select 224~255 Segment 0 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_1_first_addr" protect="rw">
        <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte) Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_last_addr" protect="rw">
        <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte) Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_mst_r_id0" protect="rw">
        <comment>Segment 1 Read Master ID select 0~31 Segment 1 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_r_id1" protect="rw">
        <comment>Segment 1 Read Master ID select 32~63 Segment 1 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_r_id2" protect="rw">
        <comment>Segment 1 Read Master ID select 64~95 Segment 1 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_r_id3" protect="rw">
        <comment>Segment 1 Read Master ID select 96~127 Segment 1 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_r_id4" protect="rw">
        <comment>Segment 1 Read Master ID select 128~159 Segment 1 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_r_id5" protect="rw">
        <comment>Segment 1 Read Master ID select 160~191 Segment 1 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_r_id6" protect="rw">
        <comment>Segment 1 Read Master ID select 192~223 Segment 1 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_r_id7" protect="rw">
        <comment>Segment 1 Read Master ID select 224~255 Segment 1 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_1_mst_w_id0" protect="rw">
        <comment>Segment 1 Write Master ID select 0~31 Segment 1 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_w_id1" protect="rw">
        <comment>Segment 1 Write Master ID select 32~63 Segment 1 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_w_id2" protect="rw">
        <comment>Segment 1 Write Master ID select 64~95 Segment 1 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_w_id3" protect="rw">
        <comment>Segment 1 Write Master ID select 96~127 Segment 1 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_w_id4" protect="rw">
        <comment>Segment 1 Write Master ID select 128~159 Segment 1 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_w_id5" protect="rw">
        <comment>Segment 1 Write Master ID select 160~191 Segment 1 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_w_id6" protect="rw">
        <comment>Segment 1 Write Master ID select 192~223 Segment 1 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_w_id7" protect="rw">
        <comment>Segment 1 Write Master ID select 224~255 Segment 1 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_2_first_addr" protect="rw">
        <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte) Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_last_addr" protect="rw">
        <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte) Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_mst_r_id0" protect="rw">
        <comment>Segment 2 Read Master ID select 0~31 Segment 2 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_r_id1" protect="rw">
        <comment>Segment 2 Read Master ID select 32~63 Segment 2 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_r_id2" protect="rw">
        <comment>Segment 2 Read Master ID select 64~95 Segment 2 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_r_id3" protect="rw">
        <comment>Segment 2 Read Master ID select 96~127 Segment 2 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_r_id4" protect="rw">
        <comment>Segment 2 Read Master ID select 128~159 Segment 2 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_r_id5" protect="rw">
        <comment>Segment 2 Read Master ID select 160~191 Segment 2 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_r_id6" protect="rw">
        <comment>Segment 2 Read Master ID select 192~223 Segment 2 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_r_id7" protect="rw">
        <comment>Segment 2 Read Master ID select 224~255 Segment 2 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_2_mst_w_id0" protect="rw">
        <comment>Segment 2 Write Master ID select 0~31 Segment 2 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_w_id1" protect="rw">
        <comment>Segment 2 Write Master ID select 32~63 Segment 2 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_w_id2" protect="rw">
        <comment>Segment 2 Write Master ID select 64~95 Segment 2 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_w_id3" protect="rw">
        <comment>Segment 2 Write Master ID select 96~127 Segment 2 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_w_id4" protect="rw">
        <comment>Segment 2 Write Master ID select 128~159 Segment 2 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_w_id5" protect="rw">
        <comment>Segment 2 Write Master ID select 160~191 Segment 2 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_w_id6" protect="rw">
        <comment>Segment 2 Write Master ID select 192~223 Segment 2 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_w_id7" protect="rw">
        <comment>Segment 2 Write Master ID select 224~255 Segment 2 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_3_first_addr" protect="rw">
        <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte) Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_last_addr" protect="rw">
        <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte) Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_mst_r_id0" protect="rw">
        <comment>Segment 3 Read Master ID select 0~31 Segment 3 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_r_id1" protect="rw">
        <comment>Segment 3 Read Master ID select 32~63 Segment 3 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_r_id2" protect="rw">
        <comment>Segment 3 Read Master ID select 64~95 Segment 3 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_r_id3" protect="rw">
        <comment>Segment 3 Read Master ID select 96~127 Segment 3 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_r_id4" protect="rw">
        <comment>Segment 3 Read Master ID select 128~159 Segment 3 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_r_id5" protect="rw">
        <comment>Segment 3 Read Master ID select 160~191 Segment 3 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_r_id6" protect="rw">
        <comment>Segment 3 Read Master ID select 192~223 Segment 3 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_r_id7" protect="rw">
        <comment>Segment 3 Read Master ID select 224~255 Segment 3 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_3_mst_w_id0" protect="rw">
        <comment>Segment 3 Write Master ID select 0~31 Segment 3 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_w_id1" protect="rw">
        <comment>Segment 3 Write Master ID select 32~63 Segment 3 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_w_id2" protect="rw">
        <comment>Segment 3 Write Master ID select 64~95 Segment 3 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_w_id3" protect="rw">
        <comment>Segment 3 Write Master ID select 96~127 Segment 3 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_w_id4" protect="rw">
        <comment>Segment 3 Write Master ID select 128~159 Segment 3 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_w_id5" protect="rw">
        <comment>Segment 3 Write Master ID select 160~191 Segment 3 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_w_id6" protect="rw">
        <comment>Segment 3 Write Master ID select 192~223 Segment 3 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_w_id7" protect="rw">
        <comment>Segment 3 Write Master ID select 224~255 Segment 3 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_4_first_addr" protect="rw">
        <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte) Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_last_addr" protect="rw">
        <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte) Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_mst_r_id0" protect="rw">
        <comment>Segment 4 Read Master ID select 0~31 Segment 4 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_r_id1" protect="rw">
        <comment>Segment 4 Read Master ID select 32~63 Segment 4 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_r_id2" protect="rw">
        <comment>Segment 4 Read Master ID select 64~95 Segment 4 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_r_id3" protect="rw">
        <comment>Segment 4 Read Master ID select 96~127 Segment 4 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_r_id4" protect="rw">
        <comment>Segment 4 Read Master ID select 128~159 Segment 4 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_r_id5" protect="rw">
        <comment>Segment 4 Read Master ID select 160~191 Segment 4 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_r_id6" protect="rw">
        <comment>Segment 4 Read Master ID select 192~223 Segment 4 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_r_id7" protect="rw">
        <comment>Segment 4 Read Master ID select 224~255 Segment 4 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_4_mst_w_id0" protect="rw">
        <comment>Segment 4 Write Master ID select 0~31 Segment 4 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_w_id1" protect="rw">
        <comment>Segment 4 Write Master ID select 32~63 Segment 4 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_w_id2" protect="rw">
        <comment>Segment 4 Write Master ID select 64~95 Segment 4 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_w_id3" protect="rw">
        <comment>Segment 4 Write Master ID select 96~127 Segment 4 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_w_id4" protect="rw">
        <comment>Segment 4 Write Master ID select 128~159 Segment 4 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_w_id5" protect="rw">
        <comment>Segment 4 Write Master ID select 160~191 Segment 4 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_w_id6" protect="rw">
        <comment>Segment 4 Write Master ID select 192~223 Segment 4 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_w_id7" protect="rw">
        <comment>Segment 4 Write Master ID select 224~255 Segment 4 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_5_first_addr" protect="rw">
        <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte) Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_last_addr" protect="rw">
        <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte) Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_mst_r_id0" protect="rw">
        <comment>Segment 5 Read Master ID select 0~31 Segment 5 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_r_id1" protect="rw">
        <comment>Segment 5 Read Master ID select 32~63 Segment 5 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_r_id2" protect="rw">
        <comment>Segment 5 Read Master ID select 64~95 Segment 5 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_r_id3" protect="rw">
        <comment>Segment 5 Read Master ID select 96~127 Segment 5 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_r_id4" protect="rw">
        <comment>Segment 5 Read Master ID select 128~159 Segment 5 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_r_id5" protect="rw">
        <comment>Segment 5 Read Master ID select 160~191 Segment 5 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_r_id6" protect="rw">
        <comment>Segment 5 Read Master ID select 192~223 Segment 5 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_r_id7" protect="rw">
        <comment>Segment 5 Read Master ID select 224~255 Segment 5 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_5_mst_w_id0" protect="rw">
        <comment>Segment 5 Write Master ID select 0~31 Segment 5 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_w_id1" protect="rw">
        <comment>Segment 5 Write Master ID select 32~63 Segment 5 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_w_id2" protect="rw">
        <comment>Segment 5 Write Master ID select 64~95 Segment 5 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_w_id3" protect="rw">
        <comment>Segment 5 Write Master ID select 96~127 Segment 5 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_w_id4" protect="rw">
        <comment>Segment 5 Write Master ID select 128~159 Segment 5 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_w_id5" protect="rw">
        <comment>Segment 5 Write Master ID select 160~191 Segment 5 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_w_id6" protect="rw">
        <comment>Segment 5 Write Master ID select 192~223 Segment 5 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_w_id7" protect="rw">
        <comment>Segment 5 Write Master ID select 224~255 Segment 5 Write Master ID select 224~255</comment>
      </reg>
    </module>
    <instance address="0x51326000" name="MEM_FW_SPIFLASH1" type="MEM_FW_SPIFLASH1"/>
  </archive>
  <archive relative="mem_fw_pub_mem.xml">
    <module category="System" name="MEM_FW_PUB_MEM">
      <reg name="port0_default_r_addr_0" protect="rw">
        <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10). default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_r_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <reg name="port0_default_w_addr_0" protect="rw">
        <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10). default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_w_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <hole size="1984"/>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clock gate bypass clock gate bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clock gate bypass</comment>
        </bits>
      </reg>
      <hole size="2016"/>
      <reg name="port_int_w_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_w_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_w_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_w_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="0" rst="0x0">
          <comment>Port 0 read address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_r_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="0" rst="0x0">
          <comment>Port 0 read address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_r_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_r_raw" pos="0" rst="0x0">
          <comment>Port 0 read address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_r_fin" pos="0" rst="0x0">
          <comment>Port 0 read address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <hole size="3840"/>
      <reg name="port_0_w_debug_addr" protect="rw">
        <comment>Debug address register for port 0 write channel Debug address register for port 0 write channel</comment>
        <bits access="r" name="w_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 write channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_w_debug_id" protect="rw">
        <comment>Debug id register for port 0 write channel Debug id register for port 0 write channel</comment>
        <bits access="r" name="w_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 write channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_addr" protect="rw">
        <comment>Debug address register for port 0 read channel Debug address register for port 0 read channel</comment>
        <bits access="r" name="r_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 read channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_id" protect="rw">
        <comment>Debug id register for port 0 read channel Debug id register for port 0 read channel</comment>
        <bits access="r" name="r_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 read channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <hole size="8064"/>
      <reg name="seg_default_first_addr" protect="rw">
        <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte) Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_last_addr" protect="rw">
        <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte) Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_mst_r_id0" protect="rw">
        <comment>Default Segment Read Master ID select 0~31 Default Segment Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_r_id1" protect="rw">
        <comment>Default Segment Read Master ID select 32~63 Default Segment Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_r_id2" protect="rw">
        <comment>Default Segment Read Master ID select 64~95 Default Segment Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_r_id3" protect="rw">
        <comment>Default Segment Read Master ID select 96~127 Default Segment Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_r_id4" protect="rw">
        <comment>Default Segment Read Master ID select 128~159 Default Segment Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_r_id5" protect="rw">
        <comment>Default Segment Read Master ID select 160~191 Default Segment Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_r_id6" protect="rw">
        <comment>Default Segment Read Master ID select 192~223 Default Segment Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_r_id7" protect="rw">
        <comment>Default Segment Read Master ID select 224~255 Default Segment Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_default_mst_w_id0" protect="rw">
        <comment>Default Segment write Master ID select 0~31 Default Segment write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_w_id1" protect="rw">
        <comment>Default Segment write Master ID select 32~63 Default Segment write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_w_id2" protect="rw">
        <comment>Default Segment write Master ID select 64~95 Default Segment write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_w_id3" protect="rw">
        <comment>Default Segment write Master ID select 96~127 Default Segment write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_w_id4" protect="rw">
        <comment>Default Segment write Master ID select 128~159 Default Segment write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_w_id5" protect="rw">
        <comment>Default Segment write Master ID select 160~191 Default Segment write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_w_id6" protect="rw">
        <comment>Default Segment write Master ID select 192~223 Default Segment write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_w_id7" protect="rw">
        <comment>Default Segment write Master ID select 224~255 Default Segment write Master ID select 224~255</comment>
      </reg>
      <hole size="15808"/>
      <reg name="seg_0_first_addr" protect="rw">
        <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte) Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_last_addr" protect="rw">
        <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte) Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_mst_r_id0" protect="rw">
        <comment>Segment 0 Read Master ID select 0~31 Segment 0 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_r_id1" protect="rw">
        <comment>Segment 0 Read Master ID select 32~63 Segment 0 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_r_id2" protect="rw">
        <comment>Segment 0 Read Master ID select 64~95 Segment 0 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_r_id3" protect="rw">
        <comment>Segment 0 Read Master ID select 96~127 Segment 0 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_r_id4" protect="rw">
        <comment>Segment 0 Read Master ID select 128~159 Segment 0 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_r_id5" protect="rw">
        <comment>Segment 0 Read Master ID select 160~191 Segment 0 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_r_id6" protect="rw">
        <comment>Segment 0 Read Master ID select 192~223 Segment 0 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_r_id7" protect="rw">
        <comment>Segment 0 Read Master ID select 224~255 Segment 0 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_0_mst_w_id0" protect="rw">
        <comment>Segment 0 Write Master ID select 0~31 Segment 0 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_w_id1" protect="rw">
        <comment>Segment 0 Write Master ID select 32~63 Segment 0 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_w_id2" protect="rw">
        <comment>Segment 0 Write Master ID select 64~95 Segment 0 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_w_id3" protect="rw">
        <comment>Segment 0 Write Master ID select 96~127 Segment 0 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_w_id4" protect="rw">
        <comment>Segment 0 Write Master ID select 128~159 Segment 0 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_w_id5" protect="rw">
        <comment>Segment 0 Write Master ID select 160~191 Segment 0 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_w_id6" protect="rw">
        <comment>Segment 0 Write Master ID select 192~223 Segment 0 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_w_id7" protect="rw">
        <comment>Segment 0 Write Master ID select 224~255 Segment 0 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_1_first_addr" protect="rw">
        <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte) Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_last_addr" protect="rw">
        <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte) Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_mst_r_id0" protect="rw">
        <comment>Segment 1 Read Master ID select 0~31 Segment 1 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_r_id1" protect="rw">
        <comment>Segment 1 Read Master ID select 32~63 Segment 1 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_r_id2" protect="rw">
        <comment>Segment 1 Read Master ID select 64~95 Segment 1 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_r_id3" protect="rw">
        <comment>Segment 1 Read Master ID select 96~127 Segment 1 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_r_id4" protect="rw">
        <comment>Segment 1 Read Master ID select 128~159 Segment 1 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_r_id5" protect="rw">
        <comment>Segment 1 Read Master ID select 160~191 Segment 1 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_r_id6" protect="rw">
        <comment>Segment 1 Read Master ID select 192~223 Segment 1 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_r_id7" protect="rw">
        <comment>Segment 1 Read Master ID select 224~255 Segment 1 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_1_mst_w_id0" protect="rw">
        <comment>Segment 1 Write Master ID select 0~31 Segment 1 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_w_id1" protect="rw">
        <comment>Segment 1 Write Master ID select 32~63 Segment 1 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_w_id2" protect="rw">
        <comment>Segment 1 Write Master ID select 64~95 Segment 1 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_w_id3" protect="rw">
        <comment>Segment 1 Write Master ID select 96~127 Segment 1 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_w_id4" protect="rw">
        <comment>Segment 1 Write Master ID select 128~159 Segment 1 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_w_id5" protect="rw">
        <comment>Segment 1 Write Master ID select 160~191 Segment 1 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_w_id6" protect="rw">
        <comment>Segment 1 Write Master ID select 192~223 Segment 1 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_w_id7" protect="rw">
        <comment>Segment 1 Write Master ID select 224~255 Segment 1 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_2_first_addr" protect="rw">
        <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte) Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_last_addr" protect="rw">
        <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte) Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_mst_r_id0" protect="rw">
        <comment>Segment 2 Read Master ID select 0~31 Segment 2 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_r_id1" protect="rw">
        <comment>Segment 2 Read Master ID select 32~63 Segment 2 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_r_id2" protect="rw">
        <comment>Segment 2 Read Master ID select 64~95 Segment 2 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_r_id3" protect="rw">
        <comment>Segment 2 Read Master ID select 96~127 Segment 2 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_r_id4" protect="rw">
        <comment>Segment 2 Read Master ID select 128~159 Segment 2 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_r_id5" protect="rw">
        <comment>Segment 2 Read Master ID select 160~191 Segment 2 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_r_id6" protect="rw">
        <comment>Segment 2 Read Master ID select 192~223 Segment 2 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_r_id7" protect="rw">
        <comment>Segment 2 Read Master ID select 224~255 Segment 2 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_2_mst_w_id0" protect="rw">
        <comment>Segment 2 Write Master ID select 0~31 Segment 2 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_w_id1" protect="rw">
        <comment>Segment 2 Write Master ID select 32~63 Segment 2 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_w_id2" protect="rw">
        <comment>Segment 2 Write Master ID select 64~95 Segment 2 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_w_id3" protect="rw">
        <comment>Segment 2 Write Master ID select 96~127 Segment 2 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_w_id4" protect="rw">
        <comment>Segment 2 Write Master ID select 128~159 Segment 2 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_w_id5" protect="rw">
        <comment>Segment 2 Write Master ID select 160~191 Segment 2 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_w_id6" protect="rw">
        <comment>Segment 2 Write Master ID select 192~223 Segment 2 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_w_id7" protect="rw">
        <comment>Segment 2 Write Master ID select 224~255 Segment 2 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_3_first_addr" protect="rw">
        <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte) Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_last_addr" protect="rw">
        <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte) Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_mst_r_id0" protect="rw">
        <comment>Segment 3 Read Master ID select 0~31 Segment 3 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_r_id1" protect="rw">
        <comment>Segment 3 Read Master ID select 32~63 Segment 3 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_r_id2" protect="rw">
        <comment>Segment 3 Read Master ID select 64~95 Segment 3 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_r_id3" protect="rw">
        <comment>Segment 3 Read Master ID select 96~127 Segment 3 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_r_id4" protect="rw">
        <comment>Segment 3 Read Master ID select 128~159 Segment 3 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_r_id5" protect="rw">
        <comment>Segment 3 Read Master ID select 160~191 Segment 3 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_r_id6" protect="rw">
        <comment>Segment 3 Read Master ID select 192~223 Segment 3 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_r_id7" protect="rw">
        <comment>Segment 3 Read Master ID select 224~255 Segment 3 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_3_mst_w_id0" protect="rw">
        <comment>Segment 3 Write Master ID select 0~31 Segment 3 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_w_id1" protect="rw">
        <comment>Segment 3 Write Master ID select 32~63 Segment 3 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_w_id2" protect="rw">
        <comment>Segment 3 Write Master ID select 64~95 Segment 3 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_w_id3" protect="rw">
        <comment>Segment 3 Write Master ID select 96~127 Segment 3 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_w_id4" protect="rw">
        <comment>Segment 3 Write Master ID select 128~159 Segment 3 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_w_id5" protect="rw">
        <comment>Segment 3 Write Master ID select 160~191 Segment 3 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_w_id6" protect="rw">
        <comment>Segment 3 Write Master ID select 192~223 Segment 3 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_w_id7" protect="rw">
        <comment>Segment 3 Write Master ID select 224~255 Segment 3 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_4_first_addr" protect="rw">
        <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte) Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_last_addr" protect="rw">
        <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte) Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_mst_r_id0" protect="rw">
        <comment>Segment 4 Read Master ID select 0~31 Segment 4 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_r_id1" protect="rw">
        <comment>Segment 4 Read Master ID select 32~63 Segment 4 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_r_id2" protect="rw">
        <comment>Segment 4 Read Master ID select 64~95 Segment 4 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_r_id3" protect="rw">
        <comment>Segment 4 Read Master ID select 96~127 Segment 4 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_r_id4" protect="rw">
        <comment>Segment 4 Read Master ID select 128~159 Segment 4 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_r_id5" protect="rw">
        <comment>Segment 4 Read Master ID select 160~191 Segment 4 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_r_id6" protect="rw">
        <comment>Segment 4 Read Master ID select 192~223 Segment 4 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_r_id7" protect="rw">
        <comment>Segment 4 Read Master ID select 224~255 Segment 4 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_4_mst_w_id0" protect="rw">
        <comment>Segment 4 Write Master ID select 0~31 Segment 4 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_w_id1" protect="rw">
        <comment>Segment 4 Write Master ID select 32~63 Segment 4 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_w_id2" protect="rw">
        <comment>Segment 4 Write Master ID select 64~95 Segment 4 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_w_id3" protect="rw">
        <comment>Segment 4 Write Master ID select 96~127 Segment 4 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_w_id4" protect="rw">
        <comment>Segment 4 Write Master ID select 128~159 Segment 4 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_w_id5" protect="rw">
        <comment>Segment 4 Write Master ID select 160~191 Segment 4 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_w_id6" protect="rw">
        <comment>Segment 4 Write Master ID select 192~223 Segment 4 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_w_id7" protect="rw">
        <comment>Segment 4 Write Master ID select 224~255 Segment 4 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_5_first_addr" protect="rw">
        <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte) Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_last_addr" protect="rw">
        <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte) Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_mst_r_id0" protect="rw">
        <comment>Segment 5 Read Master ID select 0~31 Segment 5 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_r_id1" protect="rw">
        <comment>Segment 5 Read Master ID select 32~63 Segment 5 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_r_id2" protect="rw">
        <comment>Segment 5 Read Master ID select 64~95 Segment 5 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_r_id3" protect="rw">
        <comment>Segment 5 Read Master ID select 96~127 Segment 5 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_r_id4" protect="rw">
        <comment>Segment 5 Read Master ID select 128~159 Segment 5 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_r_id5" protect="rw">
        <comment>Segment 5 Read Master ID select 160~191 Segment 5 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_r_id6" protect="rw">
        <comment>Segment 5 Read Master ID select 192~223 Segment 5 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_r_id7" protect="rw">
        <comment>Segment 5 Read Master ID select 224~255 Segment 5 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_5_mst_w_id0" protect="rw">
        <comment>Segment 5 Write Master ID select 0~31 Segment 5 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_w_id1" protect="rw">
        <comment>Segment 5 Write Master ID select 32~63 Segment 5 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_w_id2" protect="rw">
        <comment>Segment 5 Write Master ID select 64~95 Segment 5 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_w_id3" protect="rw">
        <comment>Segment 5 Write Master ID select 96~127 Segment 5 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_w_id4" protect="rw">
        <comment>Segment 5 Write Master ID select 128~159 Segment 5 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_w_id5" protect="rw">
        <comment>Segment 5 Write Master ID select 160~191 Segment 5 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_w_id6" protect="rw">
        <comment>Segment 5 Write Master ID select 192~223 Segment 5 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_w_id7" protect="rw">
        <comment>Segment 5 Write Master ID select 224~255 Segment 5 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_6_first_addr" protect="rw">
        <comment>Segment 6 first address, the actual address should right shift 10-bit (1K-Byte) Segment 6 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 6 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_6_last_addr" protect="rw">
        <comment>Segment 6 last address, the actual address should right shift 10-bit (1K-Byte) Segment 6 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 6 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_6_mst_r_id0" protect="rw">
        <comment>Segment 6 Read Master ID select 0~31 Segment 6 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_6_mst_r_id1" protect="rw">
        <comment>Segment 6 Read Master ID select 32~63 Segment 6 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_6_mst_r_id2" protect="rw">
        <comment>Segment 6 Read Master ID select 64~95 Segment 6 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_6_mst_r_id3" protect="rw">
        <comment>Segment 6 Read Master ID select 96~127 Segment 6 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_6_mst_r_id4" protect="rw">
        <comment>Segment 6 Read Master ID select 128~159 Segment 6 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_6_mst_r_id5" protect="rw">
        <comment>Segment 6 Read Master ID select 160~191 Segment 6 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_6_mst_r_id6" protect="rw">
        <comment>Segment 6 Read Master ID select 192~223 Segment 6 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_6_mst_r_id7" protect="rw">
        <comment>Segment 6 Read Master ID select 224~255 Segment 6 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_6_mst_w_id0" protect="rw">
        <comment>Segment 6 Write Master ID select 0~31 Segment 6 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_6_mst_w_id1" protect="rw">
        <comment>Segment 6 Write Master ID select 32~63 Segment 6 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_6_mst_w_id2" protect="rw">
        <comment>Segment 6 Write Master ID select 64~95 Segment 6 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_6_mst_w_id3" protect="rw">
        <comment>Segment 6 Write Master ID select 96~127 Segment 6 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_6_mst_w_id4" protect="rw">
        <comment>Segment 6 Write Master ID select 128~159 Segment 6 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_6_mst_w_id5" protect="rw">
        <comment>Segment 6 Write Master ID select 160~191 Segment 6 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_6_mst_w_id6" protect="rw">
        <comment>Segment 6 Write Master ID select 192~223 Segment 6 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_6_mst_w_id7" protect="rw">
        <comment>Segment 6 Write Master ID select 224~255 Segment 6 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_7_first_addr" protect="rw">
        <comment>Segment 7 first address, the actual address should right shift 10-bit (1K-Byte) Segment 7 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 7 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_7_last_addr" protect="rw">
        <comment>Segment 7 last address, the actual address should right shift 10-bit (1K-Byte) Segment 7 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 7 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_7_mst_r_id0" protect="rw">
        <comment>Segment 7 Read Master ID select 0~31 Segment 7 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_7_mst_r_id1" protect="rw">
        <comment>Segment 7 Read Master ID select 32~63 Segment 7 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_7_mst_r_id2" protect="rw">
        <comment>Segment 7 Read Master ID select 64~95 Segment 7 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_7_mst_r_id3" protect="rw">
        <comment>Segment 7 Read Master ID select 96~127 Segment 7 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_7_mst_r_id4" protect="rw">
        <comment>Segment 7 Read Master ID select 128~159 Segment 7 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_7_mst_r_id5" protect="rw">
        <comment>Segment 7 Read Master ID select 160~191 Segment 7 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_7_mst_r_id6" protect="rw">
        <comment>Segment 7 Read Master ID select 192~223 Segment 7 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_7_mst_r_id7" protect="rw">
        <comment>Segment 7 Read Master ID select 224~255 Segment 7 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_7_mst_w_id0" protect="rw">
        <comment>Segment 7 Write Master ID select 0~31 Segment 7 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_7_mst_w_id1" protect="rw">
        <comment>Segment 7 Write Master ID select 32~63 Segment 7 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_7_mst_w_id2" protect="rw">
        <comment>Segment 7 Write Master ID select 64~95 Segment 7 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_7_mst_w_id3" protect="rw">
        <comment>Segment 7 Write Master ID select 96~127 Segment 7 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_7_mst_w_id4" protect="rw">
        <comment>Segment 7 Write Master ID select 128~159 Segment 7 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_7_mst_w_id5" protect="rw">
        <comment>Segment 7 Write Master ID select 160~191 Segment 7 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_7_mst_w_id6" protect="rw">
        <comment>Segment 7 Write Master ID select 192~223 Segment 7 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_7_mst_w_id7" protect="rw">
        <comment>Segment 7 Write Master ID select 224~255 Segment 7 Write Master ID select 224~255</comment>
      </reg>
    </module>
    <instance address="0x51330000" name="MEM_FW_PUB_MEM" type="MEM_FW_PUB_MEM"/>
  </archive>
  <archive relative="mem_fw_ap_imem.xml">
    <module category="System" name="MEM_FW_AP_IMEM">
      <reg name="port0_default_r_addr_0" protect="rw">
        <comment>default r address 0 register(1K-Byte address, bit 22 ~ bit 10). default r address 0 register(1K-Byte address, bit 22 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_r_addr_0" pos="12:0" rst="0x1fff">
          <comment>default r address 0 register(1K-Byte address, bit 22 ~ bit 10).</comment>
        </bits>
      </reg>
      <reg name="port0_default_w_addr_0" protect="rw">
        <comment>default w address 0 register(1K-Byte address, bit 22 ~ bit 10). default w address 0 register(1K-Byte address, bit 22 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_w_addr_0" pos="12:0" rst="0x1fff">
          <comment>default w address 0 register(1K-Byte address, bit 22 ~ bit 10).</comment>
        </bits>
      </reg>
      <hole size="1984"/>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clock gate bypass clock gate bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clock gate bypass</comment>
        </bits>
      </reg>
      <hole size="2016"/>
      <reg name="port_int_w_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_w_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_w_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_w_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="0" rst="0x0">
          <comment>Port 0 read address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_r_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="0" rst="0x0">
          <comment>Port 0 read address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_r_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_r_raw" pos="0" rst="0x0">
          <comment>Port 0 read address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_r_fin" pos="0" rst="0x0">
          <comment>Port 0 read address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <hole size="3840"/>
      <reg name="port_0_w_debug_addr" protect="rw">
        <comment>Debug address register for port 0 write channel Debug address register for port 0 write channel</comment>
        <bits access="r" name="w_addr_0" pos="12:0" rst="0x0">
          <comment>Port 0 write channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_w_debug_id" protect="rw">
        <comment>Debug id register for port 0 write channel Debug id register for port 0 write channel</comment>
        <bits access="r" name="w_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 write channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_addr" protect="rw">
        <comment>Debug address register for port 0 read channel Debug address register for port 0 read channel</comment>
        <bits access="r" name="r_addr_0" pos="12:0" rst="0x0">
          <comment>Port 0 read channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_id" protect="rw">
        <comment>Debug id register for port 0 read channel Debug id register for port 0 read channel</comment>
        <bits access="r" name="r_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 read channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <hole size="8064"/>
      <reg name="seg_default_first_addr" protect="rw">
        <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte) Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_last_addr" protect="rw">
        <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte) Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_mst_r_id0" protect="rw">
        <comment>Default Segment Read Master ID select 0~31 Default Segment Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_r_id1" protect="rw">
        <comment>Default Segment Read Master ID select 32~63 Default Segment Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_r_id2" protect="rw">
        <comment>Default Segment Read Master ID select 64~95 Default Segment Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_r_id3" protect="rw">
        <comment>Default Segment Read Master ID select 96~127 Default Segment Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_r_id4" protect="rw">
        <comment>Default Segment Read Master ID select 128~159 Default Segment Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_r_id5" protect="rw">
        <comment>Default Segment Read Master ID select 160~191 Default Segment Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_r_id6" protect="rw">
        <comment>Default Segment Read Master ID select 192~223 Default Segment Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_r_id7" protect="rw">
        <comment>Default Segment Read Master ID select 224~255 Default Segment Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_default_mst_w_id0" protect="rw">
        <comment>Default Segment write Master ID select 0~31 Default Segment write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_w_id1" protect="rw">
        <comment>Default Segment write Master ID select 32~63 Default Segment write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_w_id2" protect="rw">
        <comment>Default Segment write Master ID select 64~95 Default Segment write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_w_id3" protect="rw">
        <comment>Default Segment write Master ID select 96~127 Default Segment write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_w_id4" protect="rw">
        <comment>Default Segment write Master ID select 128~159 Default Segment write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_w_id5" protect="rw">
        <comment>Default Segment write Master ID select 160~191 Default Segment write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_w_id6" protect="rw">
        <comment>Default Segment write Master ID select 192~223 Default Segment write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_w_id7" protect="rw">
        <comment>Default Segment write Master ID select 224~255 Default Segment write Master ID select 224~255</comment>
      </reg>
      <hole size="15808"/>
      <reg name="seg_0_first_addr" protect="rw">
        <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte) Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_last_addr" protect="rw">
        <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte) Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_mst_r_id0" protect="rw">
        <comment>Segment 0 Read Master ID select 0~31 Segment 0 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_r_id1" protect="rw">
        <comment>Segment 0 Read Master ID select 32~63 Segment 0 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_r_id2" protect="rw">
        <comment>Segment 0 Read Master ID select 64~95 Segment 0 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_r_id3" protect="rw">
        <comment>Segment 0 Read Master ID select 96~127 Segment 0 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_r_id4" protect="rw">
        <comment>Segment 0 Read Master ID select 128~159 Segment 0 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_r_id5" protect="rw">
        <comment>Segment 0 Read Master ID select 160~191 Segment 0 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_r_id6" protect="rw">
        <comment>Segment 0 Read Master ID select 192~223 Segment 0 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_r_id7" protect="rw">
        <comment>Segment 0 Read Master ID select 224~255 Segment 0 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_0_mst_w_id0" protect="rw">
        <comment>Segment 0 Write Master ID select 0~31 Segment 0 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_w_id1" protect="rw">
        <comment>Segment 0 Write Master ID select 32~63 Segment 0 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_w_id2" protect="rw">
        <comment>Segment 0 Write Master ID select 64~95 Segment 0 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_w_id3" protect="rw">
        <comment>Segment 0 Write Master ID select 96~127 Segment 0 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_w_id4" protect="rw">
        <comment>Segment 0 Write Master ID select 128~159 Segment 0 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_w_id5" protect="rw">
        <comment>Segment 0 Write Master ID select 160~191 Segment 0 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_w_id6" protect="rw">
        <comment>Segment 0 Write Master ID select 192~223 Segment 0 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_w_id7" protect="rw">
        <comment>Segment 0 Write Master ID select 224~255 Segment 0 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_1_first_addr" protect="rw">
        <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte) Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_last_addr" protect="rw">
        <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte) Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_mst_r_id0" protect="rw">
        <comment>Segment 1 Read Master ID select 0~31 Segment 1 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_r_id1" protect="rw">
        <comment>Segment 1 Read Master ID select 32~63 Segment 1 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_r_id2" protect="rw">
        <comment>Segment 1 Read Master ID select 64~95 Segment 1 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_r_id3" protect="rw">
        <comment>Segment 1 Read Master ID select 96~127 Segment 1 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_r_id4" protect="rw">
        <comment>Segment 1 Read Master ID select 128~159 Segment 1 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_r_id5" protect="rw">
        <comment>Segment 1 Read Master ID select 160~191 Segment 1 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_r_id6" protect="rw">
        <comment>Segment 1 Read Master ID select 192~223 Segment 1 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_r_id7" protect="rw">
        <comment>Segment 1 Read Master ID select 224~255 Segment 1 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_1_mst_w_id0" protect="rw">
        <comment>Segment 1 Write Master ID select 0~31 Segment 1 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_w_id1" protect="rw">
        <comment>Segment 1 Write Master ID select 32~63 Segment 1 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_w_id2" protect="rw">
        <comment>Segment 1 Write Master ID select 64~95 Segment 1 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_w_id3" protect="rw">
        <comment>Segment 1 Write Master ID select 96~127 Segment 1 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_w_id4" protect="rw">
        <comment>Segment 1 Write Master ID select 128~159 Segment 1 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_w_id5" protect="rw">
        <comment>Segment 1 Write Master ID select 160~191 Segment 1 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_w_id6" protect="rw">
        <comment>Segment 1 Write Master ID select 192~223 Segment 1 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_w_id7" protect="rw">
        <comment>Segment 1 Write Master ID select 224~255 Segment 1 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_2_first_addr" protect="rw">
        <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte) Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_last_addr" protect="rw">
        <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte) Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_mst_r_id0" protect="rw">
        <comment>Segment 2 Read Master ID select 0~31 Segment 2 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_r_id1" protect="rw">
        <comment>Segment 2 Read Master ID select 32~63 Segment 2 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_r_id2" protect="rw">
        <comment>Segment 2 Read Master ID select 64~95 Segment 2 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_r_id3" protect="rw">
        <comment>Segment 2 Read Master ID select 96~127 Segment 2 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_r_id4" protect="rw">
        <comment>Segment 2 Read Master ID select 128~159 Segment 2 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_r_id5" protect="rw">
        <comment>Segment 2 Read Master ID select 160~191 Segment 2 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_r_id6" protect="rw">
        <comment>Segment 2 Read Master ID select 192~223 Segment 2 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_r_id7" protect="rw">
        <comment>Segment 2 Read Master ID select 224~255 Segment 2 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_2_mst_w_id0" protect="rw">
        <comment>Segment 2 Write Master ID select 0~31 Segment 2 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_w_id1" protect="rw">
        <comment>Segment 2 Write Master ID select 32~63 Segment 2 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_w_id2" protect="rw">
        <comment>Segment 2 Write Master ID select 64~95 Segment 2 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_w_id3" protect="rw">
        <comment>Segment 2 Write Master ID select 96~127 Segment 2 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_w_id4" protect="rw">
        <comment>Segment 2 Write Master ID select 128~159 Segment 2 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_w_id5" protect="rw">
        <comment>Segment 2 Write Master ID select 160~191 Segment 2 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_w_id6" protect="rw">
        <comment>Segment 2 Write Master ID select 192~223 Segment 2 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_w_id7" protect="rw">
        <comment>Segment 2 Write Master ID select 224~255 Segment 2 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_3_first_addr" protect="rw">
        <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte) Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_last_addr" protect="rw">
        <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte) Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_mst_r_id0" protect="rw">
        <comment>Segment 3 Read Master ID select 0~31 Segment 3 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_r_id1" protect="rw">
        <comment>Segment 3 Read Master ID select 32~63 Segment 3 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_r_id2" protect="rw">
        <comment>Segment 3 Read Master ID select 64~95 Segment 3 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_r_id3" protect="rw">
        <comment>Segment 3 Read Master ID select 96~127 Segment 3 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_r_id4" protect="rw">
        <comment>Segment 3 Read Master ID select 128~159 Segment 3 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_r_id5" protect="rw">
        <comment>Segment 3 Read Master ID select 160~191 Segment 3 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_r_id6" protect="rw">
        <comment>Segment 3 Read Master ID select 192~223 Segment 3 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_r_id7" protect="rw">
        <comment>Segment 3 Read Master ID select 224~255 Segment 3 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_3_mst_w_id0" protect="rw">
        <comment>Segment 3 Write Master ID select 0~31 Segment 3 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_w_id1" protect="rw">
        <comment>Segment 3 Write Master ID select 32~63 Segment 3 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_w_id2" protect="rw">
        <comment>Segment 3 Write Master ID select 64~95 Segment 3 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_w_id3" protect="rw">
        <comment>Segment 3 Write Master ID select 96~127 Segment 3 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_w_id4" protect="rw">
        <comment>Segment 3 Write Master ID select 128~159 Segment 3 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_w_id5" protect="rw">
        <comment>Segment 3 Write Master ID select 160~191 Segment 3 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_w_id6" protect="rw">
        <comment>Segment 3 Write Master ID select 192~223 Segment 3 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_w_id7" protect="rw">
        <comment>Segment 3 Write Master ID select 224~255 Segment 3 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_4_first_addr" protect="rw">
        <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte) Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_last_addr" protect="rw">
        <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte) Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_mst_r_id0" protect="rw">
        <comment>Segment 4 Read Master ID select 0~31 Segment 4 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_r_id1" protect="rw">
        <comment>Segment 4 Read Master ID select 32~63 Segment 4 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_r_id2" protect="rw">
        <comment>Segment 4 Read Master ID select 64~95 Segment 4 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_r_id3" protect="rw">
        <comment>Segment 4 Read Master ID select 96~127 Segment 4 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_r_id4" protect="rw">
        <comment>Segment 4 Read Master ID select 128~159 Segment 4 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_r_id5" protect="rw">
        <comment>Segment 4 Read Master ID select 160~191 Segment 4 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_r_id6" protect="rw">
        <comment>Segment 4 Read Master ID select 192~223 Segment 4 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_r_id7" protect="rw">
        <comment>Segment 4 Read Master ID select 224~255 Segment 4 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_4_mst_w_id0" protect="rw">
        <comment>Segment 4 Write Master ID select 0~31 Segment 4 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_w_id1" protect="rw">
        <comment>Segment 4 Write Master ID select 32~63 Segment 4 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_w_id2" protect="rw">
        <comment>Segment 4 Write Master ID select 64~95 Segment 4 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_w_id3" protect="rw">
        <comment>Segment 4 Write Master ID select 96~127 Segment 4 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_w_id4" protect="rw">
        <comment>Segment 4 Write Master ID select 128~159 Segment 4 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_w_id5" protect="rw">
        <comment>Segment 4 Write Master ID select 160~191 Segment 4 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_w_id6" protect="rw">
        <comment>Segment 4 Write Master ID select 192~223 Segment 4 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_w_id7" protect="rw">
        <comment>Segment 4 Write Master ID select 224~255 Segment 4 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_5_first_addr" protect="rw">
        <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte) Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_last_addr" protect="rw">
        <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte) Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_mst_r_id0" protect="rw">
        <comment>Segment 5 Read Master ID select 0~31 Segment 5 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_r_id1" protect="rw">
        <comment>Segment 5 Read Master ID select 32~63 Segment 5 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_r_id2" protect="rw">
        <comment>Segment 5 Read Master ID select 64~95 Segment 5 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_r_id3" protect="rw">
        <comment>Segment 5 Read Master ID select 96~127 Segment 5 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_r_id4" protect="rw">
        <comment>Segment 5 Read Master ID select 128~159 Segment 5 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_r_id5" protect="rw">
        <comment>Segment 5 Read Master ID select 160~191 Segment 5 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_r_id6" protect="rw">
        <comment>Segment 5 Read Master ID select 192~223 Segment 5 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_r_id7" protect="rw">
        <comment>Segment 5 Read Master ID select 224~255 Segment 5 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_5_mst_w_id0" protect="rw">
        <comment>Segment 5 Write Master ID select 0~31 Segment 5 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_w_id1" protect="rw">
        <comment>Segment 5 Write Master ID select 32~63 Segment 5 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_w_id2" protect="rw">
        <comment>Segment 5 Write Master ID select 64~95 Segment 5 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_w_id3" protect="rw">
        <comment>Segment 5 Write Master ID select 96~127 Segment 5 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_w_id4" protect="rw">
        <comment>Segment 5 Write Master ID select 128~159 Segment 5 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_w_id5" protect="rw">
        <comment>Segment 5 Write Master ID select 160~191 Segment 5 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_w_id6" protect="rw">
        <comment>Segment 5 Write Master ID select 192~223 Segment 5 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_w_id7" protect="rw">
        <comment>Segment 5 Write Master ID select 224~255 Segment 5 Write Master ID select 224~255</comment>
      </reg>
    </module>
    <instance address="0x51324000" name="MEM_FW_AP_IMEM" type="MEM_FW_AP_IMEM"/>
  </archive>
  <archive relative="mem_fw_aon_imem.xml">
    <module category="System" name="MEM_FW_AON_IMEM">
      <reg name="port0_default_r_addr_0" protect="rw">
        <comment>default r address 0 register(1K-Byte address, bit 16 ~ bit 10). default r address 0 register(1K-Byte address, bit 16 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_r_addr_0" pos="6:0" rst="0x7f">
          <comment>default r address 0 register(1K-Byte address, bit 16 ~ bit 10).</comment>
        </bits>
      </reg>
      <reg name="port0_default_w_addr_0" protect="rw">
        <comment>default w address 0 register(1K-Byte address, bit 16 ~ bit 10). default w address 0 register(1K-Byte address, bit 16 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_w_addr_0" pos="6:0" rst="0x7f">
          <comment>default w address 0 register(1K-Byte address, bit 16 ~ bit 10).</comment>
        </bits>
      </reg>
      <hole size="1984"/>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clock gate bypass clock gate bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clock gate bypass</comment>
        </bits>
      </reg>
      <hole size="2016"/>
      <reg name="port_int_w_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_w_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_w_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_w_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="0" rst="0x0">
          <comment>Port 0 read address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_r_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="0" rst="0x0">
          <comment>Port 0 read address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_r_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_r_raw" pos="0" rst="0x0">
          <comment>Port 0 read address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_r_fin" pos="0" rst="0x0">
          <comment>Port 0 read address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <hole size="3840"/>
      <reg name="port_0_w_debug_addr" protect="rw">
        <comment>Debug address register for port 0 write channel Debug address register for port 0 write channel</comment>
        <bits access="r" name="w_addr_0" pos="6:0" rst="0x0">
          <comment>Port 0 write channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_w_debug_id" protect="rw">
        <comment>Debug id register for port 0 write channel Debug id register for port 0 write channel</comment>
        <bits access="r" name="w_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 write channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_addr" protect="rw">
        <comment>Debug address register for port 0 read channel Debug address register for port 0 read channel</comment>
        <bits access="r" name="r_addr_0" pos="6:0" rst="0x0">
          <comment>Port 0 read channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_id" protect="rw">
        <comment>Debug id register for port 0 read channel Debug id register for port 0 read channel</comment>
        <bits access="r" name="r_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 read channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <hole size="8064"/>
      <reg name="seg_default_first_addr" protect="rw">
        <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte) Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_last_addr" protect="rw">
        <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte) Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_mst_r_id0" protect="rw">
        <comment>Default Segment Read Master ID select 0~31 Default Segment Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_r_id1" protect="rw">
        <comment>Default Segment Read Master ID select 32~63 Default Segment Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_r_id2" protect="rw">
        <comment>Default Segment Read Master ID select 64~95 Default Segment Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_r_id3" protect="rw">
        <comment>Default Segment Read Master ID select 96~127 Default Segment Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_r_id4" protect="rw">
        <comment>Default Segment Read Master ID select 128~159 Default Segment Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_r_id5" protect="rw">
        <comment>Default Segment Read Master ID select 160~191 Default Segment Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_r_id6" protect="rw">
        <comment>Default Segment Read Master ID select 192~223 Default Segment Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_r_id7" protect="rw">
        <comment>Default Segment Read Master ID select 224~255 Default Segment Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_default_mst_w_id0" protect="rw">
        <comment>Default Segment write Master ID select 0~31 Default Segment write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_w_id1" protect="rw">
        <comment>Default Segment write Master ID select 32~63 Default Segment write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_w_id2" protect="rw">
        <comment>Default Segment write Master ID select 64~95 Default Segment write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_w_id3" protect="rw">
        <comment>Default Segment write Master ID select 96~127 Default Segment write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_w_id4" protect="rw">
        <comment>Default Segment write Master ID select 128~159 Default Segment write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_w_id5" protect="rw">
        <comment>Default Segment write Master ID select 160~191 Default Segment write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_w_id6" protect="rw">
        <comment>Default Segment write Master ID select 192~223 Default Segment write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_w_id7" protect="rw">
        <comment>Default Segment write Master ID select 224~255 Default Segment write Master ID select 224~255</comment>
      </reg>
      <hole size="15808"/>
      <reg name="seg_0_first_addr" protect="rw">
        <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte) Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_last_addr" protect="rw">
        <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte) Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_mst_r_id0" protect="rw">
        <comment>Segment 0 Read Master ID select 0~31 Segment 0 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_r_id1" protect="rw">
        <comment>Segment 0 Read Master ID select 32~63 Segment 0 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_r_id2" protect="rw">
        <comment>Segment 0 Read Master ID select 64~95 Segment 0 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_r_id3" protect="rw">
        <comment>Segment 0 Read Master ID select 96~127 Segment 0 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_r_id4" protect="rw">
        <comment>Segment 0 Read Master ID select 128~159 Segment 0 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_r_id5" protect="rw">
        <comment>Segment 0 Read Master ID select 160~191 Segment 0 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_r_id6" protect="rw">
        <comment>Segment 0 Read Master ID select 192~223 Segment 0 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_r_id7" protect="rw">
        <comment>Segment 0 Read Master ID select 224~255 Segment 0 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_0_mst_w_id0" protect="rw">
        <comment>Segment 0 Write Master ID select 0~31 Segment 0 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_w_id1" protect="rw">
        <comment>Segment 0 Write Master ID select 32~63 Segment 0 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_w_id2" protect="rw">
        <comment>Segment 0 Write Master ID select 64~95 Segment 0 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_w_id3" protect="rw">
        <comment>Segment 0 Write Master ID select 96~127 Segment 0 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_w_id4" protect="rw">
        <comment>Segment 0 Write Master ID select 128~159 Segment 0 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_w_id5" protect="rw">
        <comment>Segment 0 Write Master ID select 160~191 Segment 0 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_w_id6" protect="rw">
        <comment>Segment 0 Write Master ID select 192~223 Segment 0 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_w_id7" protect="rw">
        <comment>Segment 0 Write Master ID select 224~255 Segment 0 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_1_first_addr" protect="rw">
        <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte) Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_last_addr" protect="rw">
        <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte) Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_mst_r_id0" protect="rw">
        <comment>Segment 1 Read Master ID select 0~31 Segment 1 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_r_id1" protect="rw">
        <comment>Segment 1 Read Master ID select 32~63 Segment 1 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_r_id2" protect="rw">
        <comment>Segment 1 Read Master ID select 64~95 Segment 1 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_r_id3" protect="rw">
        <comment>Segment 1 Read Master ID select 96~127 Segment 1 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_r_id4" protect="rw">
        <comment>Segment 1 Read Master ID select 128~159 Segment 1 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_r_id5" protect="rw">
        <comment>Segment 1 Read Master ID select 160~191 Segment 1 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_r_id6" protect="rw">
        <comment>Segment 1 Read Master ID select 192~223 Segment 1 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_r_id7" protect="rw">
        <comment>Segment 1 Read Master ID select 224~255 Segment 1 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_1_mst_w_id0" protect="rw">
        <comment>Segment 1 Write Master ID select 0~31 Segment 1 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_w_id1" protect="rw">
        <comment>Segment 1 Write Master ID select 32~63 Segment 1 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_w_id2" protect="rw">
        <comment>Segment 1 Write Master ID select 64~95 Segment 1 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_w_id3" protect="rw">
        <comment>Segment 1 Write Master ID select 96~127 Segment 1 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_w_id4" protect="rw">
        <comment>Segment 1 Write Master ID select 128~159 Segment 1 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_w_id5" protect="rw">
        <comment>Segment 1 Write Master ID select 160~191 Segment 1 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_w_id6" protect="rw">
        <comment>Segment 1 Write Master ID select 192~223 Segment 1 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_w_id7" protect="rw">
        <comment>Segment 1 Write Master ID select 224~255 Segment 1 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_2_first_addr" protect="rw">
        <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte) Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_last_addr" protect="rw">
        <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte) Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_mst_r_id0" protect="rw">
        <comment>Segment 2 Read Master ID select 0~31 Segment 2 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_r_id1" protect="rw">
        <comment>Segment 2 Read Master ID select 32~63 Segment 2 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_r_id2" protect="rw">
        <comment>Segment 2 Read Master ID select 64~95 Segment 2 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_r_id3" protect="rw">
        <comment>Segment 2 Read Master ID select 96~127 Segment 2 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_r_id4" protect="rw">
        <comment>Segment 2 Read Master ID select 128~159 Segment 2 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_r_id5" protect="rw">
        <comment>Segment 2 Read Master ID select 160~191 Segment 2 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_r_id6" protect="rw">
        <comment>Segment 2 Read Master ID select 192~223 Segment 2 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_r_id7" protect="rw">
        <comment>Segment 2 Read Master ID select 224~255 Segment 2 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_2_mst_w_id0" protect="rw">
        <comment>Segment 2 Write Master ID select 0~31 Segment 2 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_w_id1" protect="rw">
        <comment>Segment 2 Write Master ID select 32~63 Segment 2 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_w_id2" protect="rw">
        <comment>Segment 2 Write Master ID select 64~95 Segment 2 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_w_id3" protect="rw">
        <comment>Segment 2 Write Master ID select 96~127 Segment 2 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_w_id4" protect="rw">
        <comment>Segment 2 Write Master ID select 128~159 Segment 2 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_w_id5" protect="rw">
        <comment>Segment 2 Write Master ID select 160~191 Segment 2 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_w_id6" protect="rw">
        <comment>Segment 2 Write Master ID select 192~223 Segment 2 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_w_id7" protect="rw">
        <comment>Segment 2 Write Master ID select 224~255 Segment 2 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_3_first_addr" protect="rw">
        <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte) Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_last_addr" protect="rw">
        <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte) Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_mst_r_id0" protect="rw">
        <comment>Segment 3 Read Master ID select 0~31 Segment 3 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_r_id1" protect="rw">
        <comment>Segment 3 Read Master ID select 32~63 Segment 3 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_r_id2" protect="rw">
        <comment>Segment 3 Read Master ID select 64~95 Segment 3 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_r_id3" protect="rw">
        <comment>Segment 3 Read Master ID select 96~127 Segment 3 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_r_id4" protect="rw">
        <comment>Segment 3 Read Master ID select 128~159 Segment 3 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_r_id5" protect="rw">
        <comment>Segment 3 Read Master ID select 160~191 Segment 3 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_r_id6" protect="rw">
        <comment>Segment 3 Read Master ID select 192~223 Segment 3 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_r_id7" protect="rw">
        <comment>Segment 3 Read Master ID select 224~255 Segment 3 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_3_mst_w_id0" protect="rw">
        <comment>Segment 3 Write Master ID select 0~31 Segment 3 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_w_id1" protect="rw">
        <comment>Segment 3 Write Master ID select 32~63 Segment 3 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_w_id2" protect="rw">
        <comment>Segment 3 Write Master ID select 64~95 Segment 3 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_w_id3" protect="rw">
        <comment>Segment 3 Write Master ID select 96~127 Segment 3 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_w_id4" protect="rw">
        <comment>Segment 3 Write Master ID select 128~159 Segment 3 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_w_id5" protect="rw">
        <comment>Segment 3 Write Master ID select 160~191 Segment 3 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_w_id6" protect="rw">
        <comment>Segment 3 Write Master ID select 192~223 Segment 3 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_w_id7" protect="rw">
        <comment>Segment 3 Write Master ID select 224~255 Segment 3 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_4_first_addr" protect="rw">
        <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte) Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_last_addr" protect="rw">
        <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte) Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_mst_r_id0" protect="rw">
        <comment>Segment 4 Read Master ID select 0~31 Segment 4 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_r_id1" protect="rw">
        <comment>Segment 4 Read Master ID select 32~63 Segment 4 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_r_id2" protect="rw">
        <comment>Segment 4 Read Master ID select 64~95 Segment 4 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_r_id3" protect="rw">
        <comment>Segment 4 Read Master ID select 96~127 Segment 4 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_r_id4" protect="rw">
        <comment>Segment 4 Read Master ID select 128~159 Segment 4 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_r_id5" protect="rw">
        <comment>Segment 4 Read Master ID select 160~191 Segment 4 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_r_id6" protect="rw">
        <comment>Segment 4 Read Master ID select 192~223 Segment 4 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_r_id7" protect="rw">
        <comment>Segment 4 Read Master ID select 224~255 Segment 4 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_4_mst_w_id0" protect="rw">
        <comment>Segment 4 Write Master ID select 0~31 Segment 4 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_w_id1" protect="rw">
        <comment>Segment 4 Write Master ID select 32~63 Segment 4 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_w_id2" protect="rw">
        <comment>Segment 4 Write Master ID select 64~95 Segment 4 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_w_id3" protect="rw">
        <comment>Segment 4 Write Master ID select 96~127 Segment 4 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_w_id4" protect="rw">
        <comment>Segment 4 Write Master ID select 128~159 Segment 4 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_w_id5" protect="rw">
        <comment>Segment 4 Write Master ID select 160~191 Segment 4 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_w_id6" protect="rw">
        <comment>Segment 4 Write Master ID select 192~223 Segment 4 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_w_id7" protect="rw">
        <comment>Segment 4 Write Master ID select 224~255 Segment 4 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_5_first_addr" protect="rw">
        <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte) Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_last_addr" protect="rw">
        <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte) Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_mst_r_id0" protect="rw">
        <comment>Segment 5 Read Master ID select 0~31 Segment 5 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_r_id1" protect="rw">
        <comment>Segment 5 Read Master ID select 32~63 Segment 5 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_r_id2" protect="rw">
        <comment>Segment 5 Read Master ID select 64~95 Segment 5 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_r_id3" protect="rw">
        <comment>Segment 5 Read Master ID select 96~127 Segment 5 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_r_id4" protect="rw">
        <comment>Segment 5 Read Master ID select 128~159 Segment 5 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_r_id5" protect="rw">
        <comment>Segment 5 Read Master ID select 160~191 Segment 5 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_r_id6" protect="rw">
        <comment>Segment 5 Read Master ID select 192~223 Segment 5 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_r_id7" protect="rw">
        <comment>Segment 5 Read Master ID select 224~255 Segment 5 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_5_mst_w_id0" protect="rw">
        <comment>Segment 5 Write Master ID select 0~31 Segment 5 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_w_id1" protect="rw">
        <comment>Segment 5 Write Master ID select 32~63 Segment 5 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_w_id2" protect="rw">
        <comment>Segment 5 Write Master ID select 64~95 Segment 5 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_w_id3" protect="rw">
        <comment>Segment 5 Write Master ID select 96~127 Segment 5 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_w_id4" protect="rw">
        <comment>Segment 5 Write Master ID select 128~159 Segment 5 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_w_id5" protect="rw">
        <comment>Segment 5 Write Master ID select 160~191 Segment 5 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_w_id6" protect="rw">
        <comment>Segment 5 Write Master ID select 192~223 Segment 5 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_w_id7" protect="rw">
        <comment>Segment 5 Write Master ID select 224~255 Segment 5 Write Master ID select 224~255</comment>
      </reg>
    </module>
    <instance address="0x51312000" name="MEM_FW_AON_IMEM" type="MEM_FW_AON_IMEM"/>
  </archive>
  <archive relative="mst_ctrl_ap.xml">
    <module category="System" name="MST_CTRL_AP">
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="emmc_rd_sec" pos="4:3" rst="0x0">
          <comment>control master emmc_rd_sec rd security operation:
00: Non security operation.
01/10: assign to master arprot[1]
11:Security operation</comment>
        </bits>
        <bits access="rw" name="lzma_rd_sec" pos="2" rst="0x0">
          <comment>control master lzma_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="gouda_rd_sec" pos="1" rst="0x0">
          <comment>control master gouda_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="usb_rd_sec" pos="0" rst="0x0">
          <comment>control master usb_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="emmc_wr_sec" pos="4:3" rst="0x0">
          <comment>control master emmc_wr_sec wr security operation:
00: Non security operation.
01/10: assign to master arprot[1]
11:Security operation</comment>
        </bits>
        <bits access="rw" name="lzma_wr_sec" pos="2" rst="0x0">
          <comment>control master lzma_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="gouda_wr_sec" pos="1" rst="0x0">
          <comment>control master gouda_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="usb_wr_sec" pos="0" rst="0x0">
          <comment>control master usb_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51320000" name="MST_CTRL_AP" type="MST_CTRL_AP"/>
  </archive>
  <archive relative="mst_ctrl_aon_pub.xml">
    <module category="System" name="MST_CTRL_AON_PUB">
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="cp_sys_aon_rd_sec" pos="5" rst="0x0">
          <comment>control master cp_sys_aon_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="rf_sys_aon_rd_sec" pos="4" rst="0x0">
          <comment>control master rf_sys_aon_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="dap_aon_rd_sec" pos="3" rst="0x0">
          <comment>control master dap_aon_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="fdma_aon_rd_sec" pos="2" rst="0x1">
          <comment>control master fdma_aon_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="cp_sys_pub_rd_sec" pos="1" rst="0x0">
          <comment>control master cp_sys_pub_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="gnss_sys_pub_rd_sec" pos="0" rst="0x0">
          <comment>control master gnss_sys_pub_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="cp_sys_aon_wr_sec" pos="5" rst="0x0">
          <comment>control master cp_sys_aon_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="rf_sys_aon_wr_sec" pos="4" rst="0x0">
          <comment>control master rf_sys_aon_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="dap_aon_wr_sec" pos="3" rst="0x0">
          <comment>control master dap_aon_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="fdma_aon_wr_sec" pos="2" rst="0x1">
          <comment>control master fdma_aon_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="cp_sys_pub_wr_sec" pos="1" rst="0x0">
          <comment>control master cp_sys_pub_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="gnss_sys_pub_wr_sec" pos="0" rst="0x0">
          <comment>control master gnss_sys_pub_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51310000" name="MST_CTRL_AON_PUB" type="MST_CTRL_AON_PUB"/>
  </archive>
  <archive relative="usbc.xml">
    <module category="System" name="USBC">
      <reg name="otg_pai" protect="rw">
        <comment>OTG function address/Powe/TX interrupt register</comment>
        <bits access="r" name="ep" pos="31:16" rst="0x0">
          <comment>EP x TX Interrupt. Signals that the Transmit interrupt has been received from this endpoint</comment>
        </bits>
        <bits access="rw" name="sfcn" pos="14" rst="0x0">
          <comment>Soft Connect. If Soft Connect/Disconnect feature is enabled, then the USB D+/D- lines are enabled when this bit is set by the CPU and tri-stated when this bit is cleared by the CPU. Note: Only valid in Peripheral Mode</comment>
        </bits>
        <bits access="rw" name="hsen" pos="13" rst="0x0">
          <comment>HS Enable. When set by the CPU, the core will negotiate for High-speed mode when the device is reset by the hub. If not set, the device will only operate in Full-speed mode.</comment>
        </bits>
        <bits access="r" name="hsmd" pos="12" rst="0x0">
          <comment>HS Mode. When set, this read-only bit indicates High-speed mode successfully negotiated during USB reset. In Peripheral Mode, becomes valid when USB reset completes (as indicated by USB reset interrupt). In Host Mode, becomes valid when Reset bit is cleared. Remains valid for the duration of the session.</comment>
        </bits>
        <bits access="r" name="rst" pos="11" rst="0x0">
          <comment>Reset. This bit is set when Reset signaling is present on the bus. Note: This bit is Read/Write from the CPU in Host Mode but Read-Only in Peripheral Mode.</comment>
        </bits>
        <bits access="rw" name="rsm" pos="10" rst="0x0">
          <comment>Resume. Set by the CPU to generate Resume signaling when the function is in Suspend mode. The CPU should clear this bit after 10 ms (a maximum of 15 ms) to end Resume signaling. In Host mode, this bit is also automatically set when Resume signaling from the target is detected while the core is suspended.</comment>
        </bits>
        <bits access="r" name="susp" pos="9" rst="0x0">
          <comment>Suspend Mode. In Host mode, this bit is set by the CPU to enter Suspend mode. In Peripheral mode, this bit is set on entry into Suspend mode. It is cleared when the CPU reads the interrupt register, or sets the Resume bit above.</comment>
        </bits>
        <bits access="rw" name="suspm" pos="8" rst="0x1">
          <comment>Enable Suspend M. Set by the CPU to enable the SUSPENDM output</comment>
        </bits>
        <bits access="rw" name="func_addr" pos="6:0" rst="0x0">
          <comment>Function address</comment>
        </bits>
      </reg>
      <reg name="otg_intrx_inttxen" protect="rw">
        <comment>OTG RX interrupt register/TX interrupt enable register</comment>
        <bits access="r" name="tx_ep" pos="31:16" rst="0xffff">
          <comment>EP x TX Interrupt Mask</comment>
        </bits>
        <bits access="r" name="rx_ep" pos="15:1" rst="0x0">
          <comment>EP x RX Interrupt (x=0 to15)Signals that the Receive interrupt has been received from this endpoint.
0: Masks the Transmit interrupt from the endpoint x
1: The interrupt is allowed</comment>
        </bits>
      </reg>
      <reg name="otg_intrxen_usb" protect="rw">
        <comment>OTG RX interrupt enable/Common USB interrupt register</comment>
        <bits access="rw" name="vben" pos="31" rst="0x0">
          <comment>VBUS Error Enable.Enables the VBUS interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="sreqen" pos="30" rst="0x0">
          <comment>Session Request Enable.Enables the SREQ interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="dscen" pos="29" rst="0x0">
          <comment>Disconnect Enable.Enables the DISCON interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="conen" pos="28" rst="0x0">
          <comment>Connect Enable.Enables the CONN interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="sofen" pos="27" rst="0x1">
          <comment>Start of Frame Enable.Enables the SOF interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="rsten" pos="26" rst="0x0">
          <comment>Reset/Babble Enable.Enables the RST interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="resen" pos="25" rst="0x1">
          <comment>Resume Enable.Enables the RES interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="sspen" pos="24" rst="0x1">
          <comment>Suspend Enable.Enables the SUSP interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="r" name="vbe" pos="23" rst="0x0">
          <comment>VBUS Error. Set when VBus drops below the VBus Valid threshold during a session. Note: Only valid in Peripheral mode.</comment>
        </bits>
        <bits access="r" name="sreq" pos="22" rst="0x0">
          <comment>Session Request. Set when Session Request signaling has been detected. Note: Only valid when the core is A-device.</comment>
        </bits>
        <bits access="r" name="discon" pos="21" rst="0x0">
          <comment>Disconnect.HOST: Set when a device disconnect is detected (HOSTDISCON going high). PERIPHERAL: Set when a session ends.</comment>
        </bits>
        <bits access="r" name="conn" pos="20" rst="0x0">
          <comment>Connect. Set when a device connection is detected (HOSTDISCON signal going low). Note: Only valid in Host mode.</comment>
        </bits>
        <bits access="r" name="sof" pos="19" rst="0x0">
          <comment>Start of Frame.Set when a new frame starts.</comment>
        </bits>
        <bits access="r" name="rst" pos="18" rst="0x0">
          <comment>Reset/Babble
PERIPHERAL: Set when Reset signaling is detected on the USB. HOST: Set when babble condition is detected.</comment>
        </bits>
        <bits access="r" name="res" pos="17" rst="0x0">
          <comment>Resume. Set when Resume signaling is detected on the bus while the core is in Suspend mode.</comment>
        </bits>
        <bits access="r" name="susp" pos="16" rst="0x0">
          <comment>Suspend. Set when Suspend signaling is detected on the bus. Note: Only valid in Peripheral mode.</comment>
        </bits>
        <bits access="r" name="rx_ep" pos="15:1" rst="0x7fff">
          <comment>EP x RX Interrupt Mask (x = 1 to 15)
0: Masks the Receive interrupt from the endpoint x
1: Allows the interrupt</comment>
        </bits>
      </reg>
      <reg name="otg_fit" protect="rw">
        <comment>OTG frame number/INDEX/Test Mode register</comment>
        <bits access="rw" name="frh" pos="31" rst="0x0">
          <comment>Force Host.he Application Software sets this bit to instruct the core to enter Host mode when the Session bit is set, regardless of whether it is connected to any peripheral. The state of the CID input, Host Disconnect and Line State signals are ignored. The core will then remain in Host mode until the Session bit is cleared, even if a device is disconnected, and if the Force_Host bit remains set, will re-enter Host mode the next time the Session bit is set. While in this mode, the status of the HOSTDISCON signal from the PHY may be read from bit 7 of the DevCtl register.The operating speed is determined from the FHS and FFS bits as follows:
00 : Low speed
01 : Full speed
10: High speed
11: undefined</comment>
        </bits>
        <bits access="rw" name="fifoa" pos="30" rst="0x0">
          <comment>FIFO Aceess.The CPU sets this bit to transfer the packet in the Endpoint 0 TX FIFO to the Endpoint 0 RX FIFO. The bit is cleared automatically.</comment>
        </bits>
        <bits access="rw" name="ffs" pos="29" rst="0x0">
          <comment>Force full-speed.This bit forces the core into full-speed mode when it receives a USB reset.</comment>
        </bits>
        <bits access="rw" name="fhs" pos="28" rst="0x0">
          <comment>Force high-speed.This bit forces the core into high-speed mode when it receives a USB reset.</comment>
        </bits>
        <bits access="rw" name="tstpkt" pos="27" rst="0x0">
          <comment>Test Packet.The CPU sets this bit to enter the Test_Packet test mode. In this mode, the MUSBMHDRC repetitively transmits on the bus a 53-byte test packet, the form of which is defined in the Universal Serial Bus Specification Revision 2.0, Section 7.1.20. The test packet has a fixed format and must be loaded into the Endpoint 0 FIFO before the test mode is entered.
Note: Only valid in high-speed mode</comment>
        </bits>
        <bits access="rw" name="tstk" pos="26" rst="0x0">
          <comment>Test K-state.The CPU sets this bit to enter the Test_K test mode. In this mode, the MUSBMHDRC transmits a continuous K on the bus.
Note: Only valid in high-speed mode</comment>
        </bits>
        <bits access="rw" name="tstj" pos="25" rst="0x0">
          <comment>Test J-state.The CPU sets this bit to enter the Test_J test mode. In this mode, the MUSBMHDRC transmits a continuous J on the bus.
Note: Only valid in high-speed mode.</comment>
        </bits>
        <bits access="rw" name="tstnak" pos="24" rst="0x0">
          <comment>Test SE0/NAK.The CPU sets this bit to enter the Test_SE0_NAK test mode. In this mode, the MUSBMHDRC remains in High-speed mode but responds to any valid IN token with a NAK.
Note: Only valid in high-speed mode.</comment>
        </bits>
        <bits access="rw" name="epno" pos="19:16" rst="0x0">
          <comment>Endpoint Number.This field programs the current active endpoint</comment>
        </bits>
        <bits access="r" name="fmno" pos="10:0" rst="0x0">
          <comment>Current frame number.Shows the current frame number</comment>
        </bits>
      </reg>
      <reg name="otg_csr0" protect="rw">
        <comment>EP0 control and status register</comment>
        <bits access="rw" name="disp" pos="27" rst="0x0">
          <comment>Host:Dis Ping, The CPU writes a 1 to this bit to instruct the core not to issue PING tokens in data and status phases of a high-speed Control transfer (for use with devices that do not respond to PING)..
Device:Reserved</comment>
        </bits>
        <bits access="rw" name="dtwe" pos="26" rst="0x0">
          <comment>Host:Data Toggle Write Enable, The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see Data Toggle bit, below). This bit is automatically cleared once the new value is written.
Device:Reserved</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Host:Data toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If D10 is high, this bit  may be written with the required setting of the data toggle. If D10 is low, any value written to this bit is ignored.
Device:Reserved</comment>
        </bits>
        <bits access="rw" name="ff" pos="24" rst="0x0">
          <comment>Host:Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared. Note:  FlushFIFO has no effect unless TxPktRdy or RxPktRdy is set.
Device:Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared. Note:  FlushFIFO has no effect unless TxPktRdy or RxPktRdy is set.</comment>
        </bits>
        <bits access="rw" name="nakto" pos="23" rst="0x0">
          <comment>Host:NAK Timeout This bit will be set when Endpoint 0 is halted following the receipt of NAK responses for longer than the time set by the NAKLimit0 register. The CPU should clear this bit to allow the endpoint to continue.
Device:Serviced RX Packet Ready. The software sets this bit in order to clear the Rx Packet Ready (RRDY) bit. Writing zero has no effect.
Device:Serviced Setup End. The software sets this bit in order to clear the Setup End (STE) bit. Writing zero has no effect.</comment>
        </bits>
        <bits access="rw" name="stp" pos="22" rst="0x0">
          <comment>Host:StatusPkt The CPU sets this bit at the same time as the TxPktRdy or ReqPkt bit is set, to perform a status stage transaction. Setting this bit ensures that the data toggle is set to 1 so that a DATA1 packet is used for the Status Stage transaction.
Device:Send Stall. The software sets this bit to terminate the current transaction. The STALL handshake will be transmitted and after that this bit is cleared automatically.</comment>
        </bits>
        <bits access="rw" name="rep" pos="21" rst="0x0">
          <comment>Host:ReqPkt. The CPU sets this bit to request an IN transaction. It is cleared when RxPktRdy is set.
Device:Setup End. This bit will be set when a control transaction ends before the Data End (DE) bit has been set. An interrupt will be generated and the FIFO flushed at this time. The bit is cleared by the software setting the Serviced Setup End (SSE) bit.</comment>
        </bits>
        <bits access="rw" name="err" pos="20" rst="0x0">
          <comment>Host:Error. This bit will be set when three attempts have been made to perform a transaction with no response from the peripheral. The CPU should clear this bit. An interrupt is generated when this bit is set.
Device:Data End. The software sets this bit when:
– Setting TRDY for the last data packet.
– Clearing RRDY after unloading the last data packet.
– Setting TRDY for a zero length data packet. This bit is cleared automatically. Writing zero has no effect.</comment>
        </bits>
        <bits access="rw" name="sp" pos="19" rst="0x0">
          <comment>Host:SetupPkt The CPU sets this bit, at the same time as the TxPktRdy bit is set, to send a SETUP token instead of an OUT token for the transaction. Note: Setting this bit also clears the Data Toggle.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The software should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rsta" pos="18" rst="0x0">
          <comment>Host:TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.
Device:TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="17" rst="0x0">
          <comment>Host:TxPktRdy The CPU sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is also generated at this point (if enabled).
Device:TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>Host:RxPktRdy This bit is set when a data packet has been received. An interrupt is generated (if enabled) when this bit is set. The CPU should clear this bit when the packet has been read from the FIFO.
Device:RX Packet Ready. This bit is set when the data packet is received. An interrupt is generated when RRDY is set (unless disabled). This bit can be cleared by software by setting SRDY bit.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiple</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum payload transmitted.Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="otg_rxcnt_txtype0" protect="rw">
        <comment>OTG RX bytes received/EP0 type register</comment>
        <bits access="rw" name="naklimit" pos="27:24" rst="0x0">
          <comment>Frames to NAK</comment>
        </bits>
        <bits access="r" name="speed" pos="23:22" rst="0x0">
          <comment>Operation speed
00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="r" name="rxcnt0" pos="6:0" rst="0x0">
          <comment>EP0 bytes received</comment>
        </bits>
      </reg>
      <reg name="otg_cfg" protect="rw">
        <comment>OTG core configuration register</comment>
        <bits access="r" name="mprxe" pos="31" rst="0x1">
          <comment>Bulk Pkt Amalgation.When set, the automatic amalgamation of bulk packets is selected</comment>
        </bits>
        <bits access="r" name="mptxe" pos="30" rst="0x1">
          <comment>Bulk Pkt Spliting.When set, the automatic splitting of bulk packets is selected</comment>
        </bits>
        <bits access="r" name="be" pos="29" rst="0x0">
          <comment>Big Endian.When set, it indicates Big Endian ordering is selected.</comment>
        </bits>
        <bits access="r" name="hbrxe" pos="28" rst="0x1">
          <comment>High-bandwidth ISO Support.When set to 1 indicates High-bandwidth RX ISO Endpoint Support selected.</comment>
        </bits>
        <bits access="r" name="hbtxe" pos="27" rst="0x1">
          <comment>High-bandwidth ISO Support.When set to 1 indicates High-bandwidth TX ISO Endpoint Support selected.</comment>
        </bits>
        <bits access="r" name="dynf" pos="26" rst="0x1">
          <comment>Dynamic FIFO Sizing.When set to 1 indicates Dynamic FIFO Sizing option selected.</comment>
        </bits>
        <bits access="r" name="sc" pos="25" rst="0x1">
          <comment>Soft Connect.When set to 1 indicates Soft Connect/Disconnect option selected.</comment>
        </bits>
        <bits access="r" name="udi" pos="24" rst="0x0">
          <comment>UTMI datawidth
0: 8 bits;
1: 16 bits.</comment>
        </bits>
      </reg>
      <hole size="512"/>
      <reg name="otg_devctl" protect="rw">
        <comment>OTG device control/MISC/TX FIFO size/RX FIFO size register</comment>
        <bits access="rw" name="rxdpb" pos="28" rst="0x0">
          <comment>Double Packet Buffering. Defines whether the double-packet buffering is set for a selected endpoint. When set, the double-packet buffering is turned on.</comment>
        </bits>
        <bits access="rw" name="rxsize" pos="27:24" rst="0x0">
          <comment>Endpoint RX FIFO Size. This field defines the RX FIFO size for a selected endpoint (and therefore a maximum packet size that is allowed before any splitting within the FIFO of Bulk/High- Bandwidth packets prior to transmission).RX FIFO Size (Bytes):</comment>
        </bits>
        <bits access="rw" name="txdpb" pos="20" rst="0x0">
          <comment>Double Packet Buffering. Defines whether the double-packet buffering is set for a selected endpoint. When set, the double-packet buffering is turned on.</comment>
        </bits>
        <bits access="rw" name="txsize" pos="19:16" rst="0x0">
          <comment>Endpoint TX FIFO Size. This field defines the TX FIFO size for a selected endpoint (and therefore a maximum packet size that is allowed before any splitting within the FIFO of Bulk/High- Bandwidth packets prior to transmission).TX FIFO Size (Bytes): If DPB = 1, the size of the TX FIFO will be twice the size defined in this field.</comment>
        </bits>
        <bits access="r" name="ctrlinter" pos="9" rst="0x0">
          <comment>current interrupt is none DMA related.</comment>
        </bits>
        <bits access="r" name="dmainter" pos="8" rst="0x0">
          <comment>current interrupt is  DMA related.</comment>
        </bits>
        <bits access="r" name="bdev" pos="7" rst="0x1">
          <comment>B-Device.This bit indicates whether the core is operating as the A-Device or the B-Device. Only valid while a session is in progress.
0: A-Device
1: B-Device
Note: If the core is in Force_Host mode (i.e. a session has been started with OTG_TM.Testmode.FRH = 1), this bit will indicate the state of the HOSTDISCON input signal from the transceiver.</comment>
        </bits>
        <bits access="r" name="fsdev" pos="6" rst="0x0">
          <comment>Full Speed.Full Speed. This bit is set when a full-speed or high-speed device has been detected being connected to the port. (High-speed devices are distinguished from full-speed by checking for high-speed chirps when the device is reset.) Only valid in Host mode.</comment>
        </bits>
        <bits access="r" name="lsdev" pos="5" rst="0x0">
          <comment>Low Speed.Low Speed. This bit is set when a low-speed device has been detected being connected to the port. Only valid in Host mode.</comment>
        </bits>
        <bits access="r" name="vbus" pos="4:3" rst="0x0">
          <comment>VBUS.These bits encode the current VBUS level as follows: 00: Below SessionEnd</comment>
        </bits>
        <bits access="r" name="host" pos="2" rst="0x0">
          <comment>Host Mode.This Read-only bit is set when the core is acting as a Host.</comment>
        </bits>
        <bits access="rw" name="hreq" pos="1" rst="0x0">
          <comment>Host Request.Host Request. When set, the core will initiate the Host Negotiation when Suspend mode is entered. It is cleared when Host Negotiation is completed.</comment>
        </bits>
        <bits access="rw" name="sess" pos="0" rst="0x0">
          <comment>Session.When operating as an A-Device, this bit is set or cleared by the software to start or end a session.When operating as a B-Device, this bit is set/cleared by the core when a session starts/ends. It may also be set by the software to initiate the SRP. When the core is in Suspend mode, the bit may be cleared by the software to perform a software disconnect.</comment>
        </bits>
      </reg>
      <reg name="otg_fa" protect="rw">
        <comment>OTG TX/RX FIFO address register</comment>
        <bits access="rw" name="rxad" pos="28:16" rst="0x0">
          <comment>FIFO Start Address. This field defines the start address of the endpoint FIFO in units of 8 bytes as follows.
13’h000 0000
13’h001 0008
13’h002 0010
…… ……
13’h1FFF FFF8</comment>
        </bits>
        <bits access="rw" name="txad" pos="12:0" rst="0x0">
          <comment>FIFO Start Address. This field defines the start address of the endpoint FIFO in units of 8 bytes as follows.
13’h000 0000
13’h001 0008
13’h002 0010
…… ……
13’h1FFF FFF8</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="otg_hwver" protect="rw">
        <comment>OTG hardware version number register</comment>
        <bits access="r" name="vmaj" pos="14:10" rst="0x4">
          <comment>Major Version number.Returns 6d02</comment>
        </bits>
        <bits access="r" name="vmin" pos="9:0" rst="0x0">
          <comment>Minor Version number. Returns 10d000</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="otg_info" protect="rw">
        <comment>OTG EP/RAM/link/VPLEN INFO register</comment>
        <bits access="rw" name="vplen" pos="31:24" rst="0x3c">
          <comment>VBUS Pulse Length.
Sets the duration of the VBus pulsing charge in units of 546.1 us (the default setting corresponds to 32.77ms).
Note: When working in FS Interface mode, the timer values will be different: units of 682.62 us and the default value of 40.96 ms</comment>
        </bits>
        <bits access="rw" name="wtcon" pos="23:20" rst="0x5">
          <comment>Connect/Disconnect Delay. Sets the wait to be applied to allow for the user s connect/disconnect filter in units of 533.3ns (the default setting corresponds to 2.667us). Note: When working in FS Interface mode, the timer values will be different: units of 666.63 ns and the default value of 3.33 us</comment>
        </bits>
        <bits access="rw" name="wtid" pos="19:16" rst="0xc">
          <comment>ID Pullup Delay. Sets the delay to be applied from IDPULLUP being asserted to IDDIG being considered valid in units of 4.369ms (the default setting corresponds to 52.43ms). Note: When working in FS Interface mode, the timer values will be different: units of 5.46 ms and the default value of 65.54 ms</comment>
        </bits>
        <bits access="r" name="dma_ch" pos="15:12" rst="0x0">
          <comment>number of DMA channel</comment>
        </bits>
        <bits access="r" name="ram_bits" pos="11:8" rst="0xc">
          <comment>width of RAM DATA bus</comment>
        </bits>
        <bits access="r" name="rx_ep" pos="7:4" rst="0xf">
          <comment>number of RX_EP</comment>
        </bits>
        <bits access="r" name="tx_ep" pos="3:0" rst="0xf">
          <comment>number of TX_EP</comment>
        </bits>
      </reg>
      <reg name="otg_eof" protect="rw">
        <comment>OTG HS/FS/LS time buffer register</comment>
        <bits access="rw" name="rstx" pos="25" rst="0x0">
          <comment>Reset All FFs in the XCLK clock domain. When a 1b1 is written to this bit, the XCLK clock domain reset will be asserted within a minimum delay of 7 cycles of the AHB clock. The output NRSTXO will be asynchronously asserted and synchronously de-asserted with respect to XCLK. This register is self clearing and always reads zero.</comment>
        </bits>
        <bits access="rw" name="rst" pos="24" rst="0x0">
          <comment>Reset All FFs in the AHB clock domain. When a 1b1 is written to this bit, the AHB clock domain reset will be asserted within a minimum delay of 7 cycles of the AHB clock. The output NRSTO will be asynchronously asserted and synchronously de-asserted with respect to AHB clock. This register is self clearing and always reads zero.</comment>
        </bits>
        <bits access="rw" name="ls_eof1" pos="23:16" rst="0x72">
          <comment>LS Time Buffer. Sets for Low-speed transactions the time before EOF to stop beginning new transactions, in units of 1.067 us (the default setting corresponds to 121.6 us).</comment>
        </bits>
        <bits access="rw" name="fs_eof1" pos="15:8" rst="0x77">
          <comment>FS Time Buffer. Sets for Full-speed transactions the time before EOF to stop beginning new transactions, in units of 533.3 ns (the default setting corresponds to 63.46 us).</comment>
        </bits>
        <bits access="rw" name="hs_eof1" pos="7:0" rst="0x7c">
          <comment>HS Time Buffer. Sets for High-speed transactions the time before EOF to stop beginning new transactions, in units of 133.3 ns (the default setting corresponds to 17.07 us)</comment>
        </bits>
      </reg>
      <reg name="otg_ep0_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep0_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep1_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep1_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep2_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep2_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep3_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep3_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep4_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep4_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep5_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep5_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep6_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep6_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep7_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep7_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep8_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep8_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep9_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep9_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep10_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep10_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep11_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep11_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep12_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep12_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep13_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep13_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep14_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep14_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep15_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep15_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <hole size="128"/>
      <reg name="reg_ep1_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep1_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep1_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep1_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep2_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep2_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep2_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep2_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep3_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep3_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep3_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep3_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep4_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep4_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep4_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep4_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep5_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep5_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep5_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep5_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep6_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep6_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep6_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep6_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep7_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep7_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep7_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep7_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep8_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep8_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep8_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep8_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep9_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep9_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep9_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep9_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep10_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep10_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep10_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep10_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep11_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep11_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep11_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep11_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep12_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep12_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep12_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep12_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep13_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep13_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep13_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep13_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep14_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep14_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep14_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep14_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep15_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 ‘1: CPU sets this bit to enable the TX endpoint to do INT transfer
 ‘0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep15_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep15_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep15_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <hole size="2048"/>
      <reg name="otg_ep0_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep1_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep2_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep3_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep4_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep5_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep6_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep7_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep8_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep9_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep10_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep11_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep12_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep13_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep14_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep15_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_rxdbdis_txdbdis" protect="rw">
        <comment>OTG RX/TX double packet buffer disable register</comment>
        <bits access="r" name="txdb" pos="31:17" rst="0x0">
          <comment>EPx Receive Double Buffer Disable</comment>
        </bits>
        <bits access="r" name="rxdb" pos="15:1" rst="0x0">
          <comment>EPx Receive Double Buffer Disable</comment>
        </bits>
      </reg>
      <reg name="otg_uch_hsrtn" protect="rw">
        <comment>OTG chirp timeout control/high-speed resume register</comment>
        <bits access="rw" name="c_t_hsrtn" pos="31:16" rst="0x32">
          <comment>The delay from the end of High Speed resume signaling to enabling UTM normal operating mode. The default value corresponds to a delay of 3us</comment>
        </bits>
        <bits access="rw" name="c_t_uch" pos="15:0" rst="0x4074">
          <comment>Configurable Chirp Timeout timer, the default value corresponds to a delay of 1.1ms.</comment>
        </bits>
      </reg>
      <reg name="otg_hsbt_fifo" protect="rw">
        <comment>OTG HS BUS TURN around/FIFO timeout check/FIFO timeout count/external control registers</comment>
        <bits access="rw" name="tx_compl_mode" pos="30" rst="0x0">
          <comment>1= wait for tx data sent on usb bus</comment>
        </bits>
        <bits access="rw" name="clear_rxbuff_en" pos="29" rst="0x0">
          <comment>1= set flushFIFO, all rx FIFO pointers, status for MCU&amp;USB
Of each buff will be clear
0 = set  flushFIFO,rx pointers, status forr current buff of MCU side will be clear.</comment>
        </bits>
        <bits access="rw" name="clear_txbuff_en" pos="28" rst="0x0">
          <comment>1= set flushFIFO, all tx FIFO pointers, status for MCU&amp;USB
Of each buff will be clear
0 = set  flushFIFO, tx pointers, status forr current buff of MCU side will be clear.</comment>
        </bits>
        <bits access="rw" name="srp_en" pos="26" rst="0x0">
          <comment>1= enable OTG SRP protocol
0= disable OTG SRP protocol</comment>
        </bits>
        <bits access="rw" name="host_mode_force" pos="25" rst="0x0">
          <comment>While HOST_force_en =1
1= DEVICE mode
0 = HOST mode
(no function if HOST_force_en =0)</comment>
        </bits>
        <bits access="rw" name="host_force_en" pos="24" rst="0x0">
          <comment>Setting the mode force host or device,1=SW force enable/0= SW force disable</comment>
        </bits>
        <bits access="rw" name="fifotimeout" pos="23:16" rst="0x80">
          <comment>Setting the check number of data in FIFO</comment>
        </bits>
        <bits access="rw" name="fifocheckreg" pos="15:9" rst="0x40">
          <comment>Setting the period of check data in FIFO</comment>
        </bits>
        <bits access="rw" name="fifocheckmode_en" pos="8" rst="0x0">
          <comment>Setting the mode of fifochecck</comment>
        </bits>
        <bits access="rw" name="hsbt" pos="3:0" rst="0x0">
          <comment>adjust the setting of HS bus turn around timing out setting</comment>
        </bits>
      </reg>
      <reg name="otg_listend_int_sts" protect="rw">
        <comment>OTG TX LISTEND interrupt status/enable register</comment>
        <bits access="r" name="tx_listend_enable15" pos="31" rst="0x0">
          <comment>When ‘1’, the TX_listend_int15  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable14" pos="30" rst="0x0">
          <comment>When ‘1’, the TX_listend_int14  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable13" pos="29" rst="0x0">
          <comment>When ‘1’, the TX_listend_int13  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable12" pos="28" rst="0x0">
          <comment>When ‘1’, the TX_listend_int12  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable11" pos="27" rst="0x0">
          <comment>When ‘1’, the TX_listend_int11  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable10" pos="26" rst="0x0">
          <comment>When ‘1’, the TX_listend_int10  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable9" pos="25" rst="0x0">
          <comment>When ‘1’, the TX_listend_int9  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable8" pos="24" rst="0x0">
          <comment>When ‘1’, the TX_listend_int8  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable7" pos="23" rst="0x0">
          <comment>When ‘1’, the TX_listend_int7  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable6" pos="22" rst="0x0">
          <comment>When ‘1’, the TX_listend_int6  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable5" pos="21" rst="0x0">
          <comment>When ‘1’, the TX_listend_int5  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable4" pos="20" rst="0x0">
          <comment>When ‘1’, the TX_listend_int4  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable3" pos="19" rst="0x0">
          <comment>When ‘1’, the TX_listend_int3  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable2" pos="18" rst="0x0">
          <comment>When ‘1’, the TX_listend_int2  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable1" pos="17" rst="0x0">
          <comment>When ‘1’, the TX_listend_int1  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_int15" pos="15" rst="0x0">
          <comment>When TX EP15 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int14" pos="14" rst="0x0">
          <comment>When TX EP14 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int13" pos="13" rst="0x0">
          <comment>When TX EP13 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int12" pos="12" rst="0x0">
          <comment>When TX EP12 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int11" pos="11" rst="0x0">
          <comment>When TX EP11 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int10" pos="10" rst="0x0">
          <comment>When TX EP10 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int9" pos="9" rst="0x0">
          <comment>When TX EP9 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int8" pos="8" rst="0x0">
          <comment>When TX EP8 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int7" pos="7" rst="0x0">
          <comment>When TX EP7 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int6" pos="6" rst="0x0">
          <comment>When TX EP6 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int5" pos="5" rst="0x0">
          <comment>When TX EP5 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int4" pos="4" rst="0x0">
          <comment>When TX EP4 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int3" pos="3" rst="0x0">
          <comment>When TX EP3 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int2" pos="2" rst="0x0">
          <comment>When TX EP2 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int1" pos="1" rst="0x0">
          <comment>When TX EP1 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
      </reg>
      <reg name="otg_listend_int_clr" protect="rw">
        <comment>OTG TX LISTEND interrupt clear register</comment>
        <bits access="rw" name="tx_listend_clear15" pos="15" rst="0x0">
          <comment>When ‘1’, the TX_listend_int15  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear14" pos="14" rst="0x0">
          <comment>When ‘1’, the TX_listend_int14  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear13" pos="13" rst="0x0">
          <comment>When ‘1’, the TX_listend_int13  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear12" pos="12" rst="0x0">
          <comment>When ‘1’, the TX_listend_int12  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear11" pos="11" rst="0x0">
          <comment>When ‘1’, the TX_listend_int11  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear10" pos="10" rst="0x0">
          <comment>When ‘1’, the TX_listend_int10  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear9" pos="9" rst="0x0">
          <comment>When ‘1’, the TX_listend_int9  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear8" pos="8" rst="0x0">
          <comment>When ‘1’, the TX_listend_int8  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear7" pos="7" rst="0x0">
          <comment>When ‘1’, the TX_listend_int7  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear6" pos="6" rst="0x0">
          <comment>When ‘1’, the TX_listend_int6  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear5" pos="5" rst="0x0">
          <comment>When ‘1’, the TX_listend_int5  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear4" pos="4" rst="0x0">
          <comment>When ‘1’, the TX_listend_int4  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear3" pos="3" rst="0x0">
          <comment>When ‘1’, the TX_listend_int3  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear2" pos="2" rst="0x0">
          <comment>When ‘1’, the TX_listend_int2  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear1" pos="1" rst="0x0">
          <comment>When ‘1’, the TX_listend_int1  will be cleared</comment>
        </bits>
      </reg>
      <reg name="otg_endpoint_en" protect="rw">
        <comment>OTG endpoint enable register</comment>
        <bits access="r" name="endpoint_enable15" pos="15" rst="0x1">
          <comment>When ‘1’, the Endpoint15  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable14" pos="14" rst="0x1">
          <comment>When ‘1’, the Endpoint14  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable13" pos="13" rst="0x1">
          <comment>When ‘1’, the Endpoint13  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable12" pos="12" rst="0x1">
          <comment>When ‘1’, the Endpoint12  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable11" pos="11" rst="0x1">
          <comment>When ‘1’, the Endpoint11  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable10" pos="10" rst="0x1">
          <comment>When ‘1’, the Endpoint10  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable9" pos="9" rst="0x1">
          <comment>When ‘1’, the Endpoint9  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable8" pos="8" rst="0x1">
          <comment>When ‘1’, the Endpoint8  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable7" pos="7" rst="0x1">
          <comment>When ‘1’, the Endpoint7  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable6" pos="6" rst="0x1">
          <comment>When ‘1’, the Endpoint6  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable5" pos="5" rst="0x1">
          <comment>When ‘1’, the Endpoint5  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable4" pos="4" rst="0x1">
          <comment>When ‘1’, the Endpoint4  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable3" pos="3" rst="0x1">
          <comment>When ‘1’, the Endpoint3  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable2" pos="2" rst="0x1">
          <comment>When ‘1’, the Endpoint2  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable1" pos="1" rst="0x1">
          <comment>When ‘1’, the Endpoint1  (both TX/RX) will function</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x02100000" name="USBC" type="USBC"/>
  </archive>
  <archive relative="dbgio.xml">
    <module category="System" name="DBGIO">
      <reg name="dbgio_en" protect="rw">
        <comment>global enable global enable control register</comment>
        <bits access="rw" name="ch_en" pos="15:8" rst="0x0">
          <comment>This value requires one-hot or all zero.
[1:0] user channel; [2] train 1 ; [3] : train 2</comment>
        </bits>
        <bits access="rw" name="funnel_en" pos="4" rst="0x0"/>
        <bits access="rw" name="func_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="funnel_sta" protect="rw">
        <comment>Funnel overflow flag Funnel overflow flag register</comment>
        <bits access="r" name="funnel_afifo_empty" pos="5" rst="0x1">
          <comment>funnel async fifo empty status</comment>
        </bits>
        <bits access="rw" name="funnel_overflow_clear" pos="4" rst="0x0">
          <comment>funnel overflow flag clear.</comment>
        </bits>
        <bits access="r" name="funnel_afifo_full" pos="0" rst="0x0">
          <comment>funnel async fifo full flag</comment>
        </bits>
      </reg>
      <reg name="dbgio_int_en" protect="rw">
        <comment>interrupte enable</comment>
        <bits access="rw" name="funnel_ovf_int_en" pos="0" rst="0x0">
          <comment>fifo_overflow interrupt</comment>
        </bits>
      </reg>
      <reg name="dbgio_int_sta" protect="rw">
        <comment>interrupte status</comment>
        <bits access="r" name="funnel_overflow" pos="0" rst="0x0"/>
      </reg>
      <reg name="dbgio_ctrl" protect="rw">
        <comment>dbgio control</comment>
        <bits access="rw" name="sw_rst" pos="8" rst="0x0">
          <comment>Software reset.
0: work
1: reset</comment>
        </bits>
        <bits access="rw" name="clk_src_sel" pos="4" rst="0x0">
          <comment>Dbgio source clock select
1’h0: 200MHz
1’b1: 140MHz</comment>
        </bits>
        <bits access="rw" name="ddr_mode_en" pos="0" rst="0x0">
          <comment>Dbgio ddr mode enable</comment>
        </bits>
      </reg>
      <reg name="fsm_cut_off_len" protect="rw">
        <comment>The max length of data package control register</comment>
        <bits access="rw" name="fsm_cut_off_len" pos="15:0" rst="0x20">
          <comment>&quot;fsm_cut_off_len +1&quot; is the max length of data package between any SYNC &amp; CRC package, keep the value equals to (33N+32) where N is integer or zero.</comment>
        </bits>
      </reg>
      <reg name="fsm_data_wait_len" protect="rw">
        <comment>The max length of data wait cycle register</comment>
        <bits access="rw" name="fsm_data_wait_len" pos="15:0" rst="0x20">
          <comment>&quot;fsm_data_wait_len +1&quot; is the max length of data wait cycle time when gearbox fifo is almost empty</comment>
        </bits>
      </reg>
      <reg name="dll_cfg" protect="rw">
        <comment>DBGIO PHY DLL CFG DBGIO PHY DLL CFG registers</comment>
        <bits access="rw" name="dll_wait_cnt" pos="31:28" rst="0x4">
          <comment>Cycles to wait DLL locked signals.</comment>
        </bits>
        <bits access="rw" name="dll_datwr_cpst_en" pos="24" rst="0x0">
          <comment>write delay cell  select
0:use user defined value from CLKDATWR_DLY_VAL
1:use dll generated value which referenced form CLKDATWR_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="dll_clk_sel" pos="22" rst="0x0">
          <comment>DLL Clock source selection
0: Select 1x clock
1: Select 2x clock</comment>
        </bits>
        <bits access="rw" name="dll_en" pos="21" rst="0x0">
          <comment>DLL enable signal
0:DLL disable
1:DLL enable</comment>
        </bits>
        <bits access="rw" name="dll_clr" pos="20" rst="0x0">
          <comment>DLL clear signal
1:clear DLL</comment>
        </bits>
        <bits access="rw" name="dll_auto_clr_en" pos="19" rst="0x0">
          <comment>Don’t  support in this version</comment>
        </bits>
        <bits access="rw" name="dll_cpst_en" pos="18" rst="0x0">
          <comment>DLL output delay value enable</comment>
        </bits>
        <bits access="rw" name="dll_cpst_start" pos="17" rst="0x0">
          <comment>DLL start enable signal, this bit should be write to 1’b0 when it is enabled to 1’b1</comment>
        </bits>
        <bits access="rw" name="dll_half_mode" pos="16" rst="0x0">
          <comment>DLL lock mode:
0: full cycle lock mode
1: half cycle lock mode</comment>
        </bits>
        <bits access="rw" name="dll_init" pos="14:8" rst="0x1">
          <comment>DLL count initial value, DLL use it as the initial value to count the delay value.</comment>
        </bits>
        <bits access="rw" name="dll_cpst_threshold" pos="7:4" rst="0x0">
          <comment>DLL  change  threshold value, DLL update rd/wr/cmd delay line value if the DLL count delta bigger then DLL_CPST_THRESHOLD</comment>
        </bits>
        <bits access="rw" name="dll_phase_interval" pos="2:1" rst="0x0">
          <comment>DLL phase interval , DLL use it as the interval of phase 1 and phase2</comment>
        </bits>
        <bits access="rw" name="clk_phase_sel" pos="0" rst="0x0">
          <comment>OUPUT clock phase select</comment>
        </bits>
      </reg>
      <reg name="dll_dly" protect="rw">
        <comment>DBGIO PHY DLL DLY  DBGIO PHY DLL DLY registers</comment>
        <bits access="rw" name="dll_clkdatwr_dly_val" pos="7:0" rst="0x0">
          <comment>Clock Data Write Line Delay Value
Based Phase is invert of PHY Clock
When DLL_DATWR_CPST_EN is enable,</comment>
        </bits>
      </reg>
      <reg name="dll_dly_offset" protect="rw">
        <comment>DBGIO PHY DLL Offset Read  DBGIO PHY DLL Offset Read registers</comment>
        <bits access="rw" name="dll_clkdatwr_dly_inv" pos="5" rst="0x0">
          <comment>Clock Data Write Line Delay Invert</comment>
        </bits>
        <bits access="rw" name="dll_clkdatwr_dly_offset" pos="4:0" rst="0x0">
          <comment>Data Write Delay offset. The highest bit indicates if it is add or sub.
OFFSET [4]=0:  CLKDATWR_DLY_VAL + OFFSET [3:0]
OFFSET [4]=1:  CLKDATWR_DLY_VAL – OFFSET [3:0].
If DLL_DATWR _CPST_EN==1, the offset is added after the proportion.
E.g. If
Clock cycle (CYC)== 5ns
CLKDATWR _DLY_ VAL (VAL) ==’h40, CLKDATWR_DLY_OFFSET (OFSET) == ‘h6,
DLL_CNT(CNT) == ‘h20
 it means delay:
(VAL/’h100)*CYC + (CYC * OFSET) / CN =
 (‘h40/’h100)*5ns + (5ns * ‘h6) / ‘h20 ≈2.2ns</comment>
        </bits>
      </reg>
      <reg name="dll_sts0" protect="rw">
        <comment>DBGIO PHY DLL STS0 registers DBGIO PHY DLL STS0 registers</comment>
        <bits access="r" name="dll_phase1" pos="20" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_phase2" pos="19" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_locked" pos="18" rst="0x0">
          <comment>If use DLL, software should wait this value to 1’b1</comment>
        </bits>
        <bits access="r" name="dll_error" pos="17" rst="0x0">
          <comment>If use DLL, soft ware should wait DLL_LOCKED to 1’b1 and  at that time ,this bit is 1’b0</comment>
        </bits>
        <bits access="r" name="dll_cpst_st" pos="16" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_st" pos="10:8" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_cnt" pos="6:0" rst="0x0">
          <comment>DLL delay cell counts of 1 cycle</comment>
        </bits>
      </reg>
      <reg name="dll_sts1" protect="rw">
        <comment>DBGIO PHY DLL STS1  DBGIO PHY DLL STS1 registers</comment>
        <bits access="r" name="clkdatwr_dly_cnt" pos="7:0" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
      </reg>
      <reg name="dll_backup" protect="rw">
        <comment>DBGIO PHY DLL BACKUP DBGIO PHY DLL BACKUP registers</comment>
        <bits access="rw" name="oe_ext_optional" pos="4" rst="0x0">
          <comment>Oe_ext_optional( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_slice_en_value" pos="3" rst="0x0">
          <comment>Force slice en value( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_slice_en_force" pos="2" rst="0x0">
          <comment>Force slice enable( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_backup_value" pos="1" rst="0x1">
          <comment>Force dll use backup mode value( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_backup" pos="0" rst="0x0">
          <comment>Force dll use backup mode( Reserved  for  vender asic only)</comment>
        </bits>
      </reg>
      <reg name="use_port" protect="rw">
        <comment>Which channel be used Which channel be used</comment>
        <bits access="r" name="use_port" pos="7:0" rst="0xff">
          <comment>If one channel is used, corresponding bit will be 1, otherwise is 0.</comment>
        </bits>
      </reg>
      <reg name="use_source_sync" protect="rw">
        <comment>Which channel use source sync mode</comment>
        <bits access="r" name="use_source_sync" pos="7:0" rst="0xf8">
          <comment>If one channel uses source sync mode, corresponding bit will be 1, otherwise is 0.</comment>
        </bits>
      </reg>
      <reg name="use_ready" protect="rw">
        <comment>Which channel use handshake mode</comment>
        <bits access="r" name="use_ready" pos="7:0" rst="0x3">
          <comment>If one channel uses handshake mode, corresponding bit will be 1, otherwise is 0.</comment>
        </bits>
      </reg>
      <reg name="use_logic_analizer" protect="rw">
        <comment>Which channel use LA mode</comment>
        <bits access="r" name="use_logic_analizer" pos="7:0" rst="0x4">
          <comment>If one channel uses LA mode, corresponding bit will be 1, otherwise is 0.</comment>
        </bits>
      </reg>
      <reg name="la_sample_rate" protect="rw">
        <comment>LA channel sample rate control register</comment>
        <bits access="rw" name="la_sample_rate" pos="3:0" rst="0x7">
          <comment>Sample rate of the LA channel is &quot;(sample_rate + 1) / 16&quot;
This setting can't exceed 0xa, due to the ideal bandwidth limitation.</comment>
        </bits>
      </reg>
      <reg name="version" protect="rw">
        <comment>IP version IP version</comment>
        <bits access="r" name="version" pos="15:0" rst="0x1">
          <comment>R0p1</comment>
        </bits>
      </reg>
      <hole size="1440"/>
      <reg name="dbgio_en_set" protect="rw"/>
      <reg name="funnel_sta_set" protect="rw"/>
      <reg name="dbgio_int_en_set" protect="rw"/>
      <hole size="32"/>
      <reg name="dbgio_ctrl_set" protect="rw"/>
      <hole size="1888"/>
      <reg name="dbgio_en_clr" protect="rw"/>
      <reg name="funnel_sta_clr" protect="rw"/>
      <reg name="dbgio_int_en_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="dbgio_ctrl_clr" protect="rw"/>
    </module>
    <var name="REG_DBGIO_SET_OFFSET" value="0x100"/>
    <var name="REG_DBGIO_CLR_OFFSET" value="0x200"/>
    <instance address="0x18c01000" name="DBGIO" type="DBGIO"/>
  </archive>
  <archive relative="busmon.xml">
    <module category="System" name="BUSMON">
      <reg name="mon_ctrl" protect="rw">
        <comment>监控控制寄存器</comment>
        <bits access="rw" name="busmon_ctrl" pos="0" rst="0x0">
          <comment>Monitor运行启动位
0：停止监控或监控已完成。
1：开始监控或监控正在进行。
注:BUS Monitor总开关，除连续监控模式外，其他监控模式下，当监控完成后，该位自动清零。</comment>
        </bits>
      </reg>
      <reg name="mon_conf" protect="rw">
        <comment>监控控制寄存器</comment>
        <bits access="rw" name="mon_ext_addr_en" pos="9" rst="0x0">
          <comment>监控特定地址段范围外的写操作使能位
0：不使能；
1：使能；</comment>
        </bits>
        <bits access="rw" name="busy_en" pos="8" rst="0x0">
          <comment>BUSY信号输出设置
1：随监控启动输出
0：一直输出</comment>
        </bits>
        <bits access="rw" name="rbusy_en" pos="7" rst="0x0">
          <comment>RBUSY信号输出设置
1：随监控启动输出
0：一直输出</comment>
        </bits>
        <bits access="rw" name="wbusy_en" pos="6" rst="0x0">
          <comment>WBUSY信号输出设置
1：随监控启动输出
0：一直输出</comment>
        </bits>
        <bits access="rw" name="mon_in_addr_en" pos="5" rst="0x0">
          <comment>监控特定地址段范围内的写操作使能位
1：开启功能
0：不开启功能</comment>
        </bits>
        <bits access="rw" name="mon_num_en" pos="4" rst="0x0">
          <comment>监控访问命令数量达到设置值
1：开启功能
0：不开启功能</comment>
        </bits>
        <bits access="rw" name="mon_cont_en" pos="3" rst="0x0">
          <comment>连续监控功能：
1：开启功能
0：不开启功能</comment>
        </bits>
        <bits access="rw" name="mon_time_en" pos="2" rst="0x0">
          <comment>监控设定时间段访问量：
1：开启功能
0：不开启功能</comment>
        </bits>
        <bits access="rw" name="mon_lock_en" pos="1" rst="0x0">
          <comment>监控总线锁死
1：开启功能
0：不开启功能</comment>
        </bits>
        <bits access="rw" name="gint_en" pos="0" rst="0x0">
          <comment>监控总中断使能
0：不使能中断。
1：使能中断。
注：监控设定时间段与监控设定访问量这两个功能同时开启时，任何一个条件达到，就停止总线负荷的监控，总线挂死与特定地址特定数据的监控功能照常；
特定地址的监控功能开启时，MON_M0_ADDR_WID保留的是第一次条件触发的ID号；监控特定地址范围内与监控特定地址范围外的功能不能都使能；当监控特定地址范围内的功能使能后，任何访问四段设定地址段的写操作都会触发中断；当监控特定地址范围外的功能使能后，任何访问四段设定地址段以外的DDR地址（0x0-0x1fff_ffff）写操作都会触发中断，即监控地址段范围外的功能只限于DDR的地址，寄存器的地址不在监控之内；如果监控的地址段少于四段，需将四段地址寄存器均配齐全，多余的地址寄存器段需与前面任一有效地址配置相同值。
连续监控功能使能后，每隔设定时间段产生一个中断，并继续监控；“连续监控功能”与“监控设定时间段访问量”两个功能只能支持一个。</comment>
        </bits>
      </reg>
      <reg name="mon_time" protect="rw">
        <comment>监控控制寄存器</comment>
      </reg>
      <reg name="mon_cont" protect="rw">
        <comment>访问命令限定寄存器</comment>
      </reg>
      <reg name="mon_int_en" protect="rw">
        <comment>中断使能寄存器</comment>
        <bits access="rw" name="addr_int_en" pos="3" rst="0x0">
          <comment>MASTER0访问设定地址段中断使能
0：不使能中断。
1：使能中断。</comment>
        </bits>
        <bits access="rw" name="num_int_en" pos="2" rst="0x0">
          <comment>访问命令数达到设定数目中断使能
0：不使能中断。
1：使能中断。</comment>
        </bits>
        <bits access="rw" name="timer_int_en" pos="1" rst="0x0">
          <comment>计数时间到达设定值中断使能
0：不使能中断。
1：使能中断。</comment>
        </bits>
        <bits access="rw" name="lock_int_en" pos="0" rst="0x0">
          <comment>LOCK中断使能
0：不使能中断。
1：使能中断。</comment>
        </bits>
      </reg>
      <reg name="mon_int_flag" protect="rw">
        <comment>中断标志寄存器</comment>
        <bits access="rc" name="timer_int" pos="17" rst="0x0">
          <comment>监控设定时间段模式下，监控时间结束中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="addr_int" pos="16" rst="0x0">
          <comment>MASTER0访问特定地址段中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m4_rnum_int" pos="15" rst="0x0">
          <comment>MASTER4读访问命令达到指定数中断
0：无中断。
1：有中断</comment>
        </bits>
        <bits access="rc" name="m4_wnum_int" pos="14" rst="0x0">
          <comment>MASTER4写访问命令达到指定数中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m3_rnum_int" pos="13" rst="0x0">
          <comment>MASTER3读访问命令达到指定数中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m3_wnum_int" pos="12" rst="0x0">
          <comment>MASTER3写访问命令达到指定数中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m2_rnum_int" pos="11" rst="0x0">
          <comment>MASTER2读访问命令达到指定数中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m2_wnum_int" pos="10" rst="0x0">
          <comment>MASTER2写访问命令达到指定数中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m1_rnum_int" pos="9" rst="0x0">
          <comment>MASTER1读访问命令达到指定数中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m1_wnum_int" pos="8" rst="0x0">
          <comment>MASTER1写访问命令达到指定数中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m0_rnum_int" pos="7" rst="0x0">
          <comment>MASTER0读访问命令达到指定数中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m0_wnum_int" pos="6" rst="0x0">
          <comment>MASTER0写访问命令达到指定数中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="timer_cint" pos="5" rst="0x0">
          <comment>连续监控模式下，设定时间到达中断
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m4_lcok_int" pos="4" rst="0x0">
          <comment>MASTER4总线锁死
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m3_lcok_int" pos="3" rst="0x0">
          <comment>MASTER3总线锁死
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m2_lcok_int" pos="2" rst="0x0">
          <comment>MASTER2总线锁死
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m1_lcok_int" pos="1" rst="0x0">
          <comment>MASTER1总线锁死
0：无中断。
1：有中断。</comment>
        </bits>
        <bits access="rc" name="m0_lcok_int" pos="0" rst="0x0">
          <comment>MASTER0总线锁死
0：无中断。
1：有中断。</comment>
        </bits>
      </reg>
      <reg name="mon_m0_start_addr0" protect="rw">
        <comment>MASTER0监控第一段起始地址寄存器</comment>
      </reg>
      <reg name="mon_m0_end_addr0" protect="rw">
        <comment>MASTER0写特定地址段时ID号寄存器</comment>
      </reg>
      <reg name="mon_m0_addr_wid" protect="rw">
        <comment>MASTER0监控第一段起始地址寄存器</comment>
        <bits access="r" name="wa_id" pos="7:0" rst="0x0">
          <comment>写特定地址段的ID号
注: MON_START_ADDR, MON_END_ADDR两个寄存器用于设置MASTER0监控地址段的起始和结束地址;，其中起始地址应该大于等于结束地址；当MASTER0访问该地址段时,ADDR_INT会置位,如果该中断使能则产生中断</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="mon_lock_time" protect="rw">
        <comment>总线挂死时间寄存器</comment>
        <bits access="rw" name="lock_value" pos="15:0" rst="0xffff">
          <comment>总线挂死判定时间
注：一个访问该寄存器的设定时间内未完成访问，即认定为总线挂死</comment>
        </bits>
      </reg>
      <reg name="mon_rcommand0" protect="rw">
        <comment>通道0读命令计数器</comment>
      </reg>
      <reg name="mon_rdata0" protect="rw">
        <comment>通道0读数据计数器</comment>
      </reg>
      <reg name="mon_wcommand0" protect="rw">
        <comment>通道0读数据计数器</comment>
      </reg>
      <reg name="mon_wdata0" protect="rw">
        <comment>通道0写数据计数器</comment>
      </reg>
      <reg name="mon_rcommand1" protect="rw">
        <comment>通道1读命令计数器</comment>
      </reg>
      <reg name="mon_rdata1" protect="rw">
        <comment>通道1读数据计数器</comment>
      </reg>
      <reg name="mon_wcommand1" protect="rw">
        <comment>通道1读数据计数器</comment>
      </reg>
      <reg name="mon_wdata1" protect="rw">
        <comment>通道1写数据计数器</comment>
      </reg>
      <reg name="mon_rcommand2" protect="rw">
        <comment>通道2读命令计数器</comment>
      </reg>
      <reg name="mon_rdata2" protect="rw">
        <comment>通道2读数据计数器</comment>
      </reg>
      <reg name="mon_wcommand2" protect="rw">
        <comment>通道2读数据计数器</comment>
      </reg>
      <reg name="mon_wdata2" protect="rw">
        <comment>通道2写数据计数器</comment>
      </reg>
      <reg name="mon_rcommand3" protect="rw">
        <comment>通道3读命令计数器</comment>
      </reg>
      <reg name="mon_rdata3" protect="rw">
        <comment>通道3读数据计数器</comment>
      </reg>
      <reg name="mon_wcommand3" protect="rw">
        <comment>通道3读数据计数器</comment>
      </reg>
      <reg name="mon_wdata3" protect="rw">
        <comment>通道3写数据计数器</comment>
      </reg>
      <reg name="mon_rcommand4" protect="rw">
        <comment>通道4读命令计数器</comment>
      </reg>
      <reg name="mon_rdata4" protect="rw">
        <comment>通道4读数据计数器</comment>
      </reg>
      <reg name="mon_wcommand4" protect="rw">
        <comment>通道4读数据计数器</comment>
      </reg>
      <reg name="mon_wdata4" protect="rw">
        <comment>通道4写数据计数器</comment>
      </reg>
      <reg name="mon_m0_start_addr1" protect="rw">
        <comment>MASTER0监控第二段起始地址寄存器</comment>
      </reg>
      <reg name="mon_m0_end_addr1" protect="rw">
        <comment>MASTER0监控第二段结束地址寄存器</comment>
      </reg>
      <reg name="mon_m0_start_addr2" protect="rw">
        <comment>MASTER0监控第三段起始地址寄存器</comment>
      </reg>
      <reg name="mon_m0_end_addr2" protect="rw">
        <comment>MASTER0监控第三段结束地址寄存器</comment>
      </reg>
      <reg name="mon_m0_start_addr3" protect="rw">
        <comment>MASTER0监控第四段起始地址寄存器</comment>
      </reg>
      <reg name="mon_m0_end_addr3" protect="rw">
        <comment>MASTER0监控第四段结束地址寄存器</comment>
      </reg>
      <reg name="mon_m0_addr" protect="rw">
        <comment>MASTER0写特定地址段事件发生时的地址寄存器</comment>
      </reg>
    </module>
    <instance address="0x04802000" name="AP_BUSMON" type="BUSMON"/>
    <instance address="0x14004000" name="CP_BUSMON" type="BUSMON"/>
  </archive>
  <archive relative="psram_phy.xml">
    <module category="System" name="PSRAM_PHY">
      <reg name="psram_rf_cfg_phy" protect="rw">
        <bits access="rw" name="rf_phy_init_complete" pos="1" rst="0x0">
          <comment>phy initial complete configuration</comment>
        </bits>
        <bits access="rw" name="rf_phy_en" pos="0" rst="0x0">
          <comment>phy enable</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_clock_gate" protect="rw">
        <bits access="rw" name="rf_clk_gate_ag_rd_en" pos="4" rst="0x0">
          <comment>clk_ag_rd enable</comment>
        </bits>
        <bits access="rw" name="rf_clk_gate_ag_wr_en" pos="3" rst="0x0">
          <comment>clk_ag_wr enable</comment>
        </bits>
        <bits access="rw" name="rf_clk_gate_ag_en" pos="2" rst="0x0">
          <comment>clk_ag enable</comment>
        </bits>
        <bits access="rw" name="rf_clk_gate_fg_en" pos="1" rst="0x0">
          <comment>clk_fg enable</comment>
        </bits>
        <bits access="rw" name="rf_clk_gate_en" pos="0" rst="0x0">
          <comment>all clk enable</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_lpi" protect="rw">
        <bits access="rw" name="rf_cwakeup_s0" pos="2" rst="0x0">
          <comment>software configure axi channel slave port cwakeup</comment>
        </bits>
        <bits access="rw" name="rf_cwakeup_m0" pos="1" rst="0x0">
          <comment>software configure axi channel master port cwakeup</comment>
        </bits>
        <bits access="rw" name="rf_lpi_sel_m0" pos="0" rst="0x0">
          <comment>low power interface m0 ch or all ch  select</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_psram_type" protect="rw">
        <bits access="rw" name="rf_length_limit" pos="8" rst="0x0">
          <comment>burst  length 256byte limit for freq of 26m,52m and 109m</comment>
        </bits>
        <bits access="rw" name="rf_wrapper_limit" pos="7" rst="0x0">
          <comment>wb955 128byte wrapper limit</comment>
        </bits>
        <bits access="rw" name="rf_rwds_smpl_time" pos="6:4" rst="0x4">
          <comment>winbond memory sample rwds time</comment>
        </bits>
        <bits access="rw" name="rf_wb64_256_sel" pos="3" rst="0x0">
          <comment>psram is winbond memory 64Mb or 256Mb</comment>
        </bits>
        <bits access="rw" name="rf_datax16_sel" pos="2" rst="0x0">
          <comment>psram dq width  x8 or x16 select</comment>
        </bits>
        <bits access="rw" name="rf_ap256_sel" pos="1" rst="0x0">
          <comment>psram is ap memory 256Mb or not select</comment>
        </bits>
        <bits access="rw" name="rf_wb_sel" pos="0" rst="0x0">
          <comment>psram is winbond hyperbus or not select</comment>
        </bits>
      </reg>
      <reg name="psram_rf_wb_mrw_data" protect="rw">
        <bits access="rw" name="rf_wb_mrw_data" pos="15:0" rst="0x0">
          <comment>winbond memory mr write data</comment>
        </bits>
      </reg>
      <hole size="1888"/>
      <reg name="psram_rfdll_cfg_dll" protect="rw">
        <bits access="w" name="rfdll_reset" pos="0" rst="0x0">
          <comment>not use</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_cpst_idle" protect="rw">
        <bits access="r" name="rfdl_cpst_st_idle_ads1" pos="1" rst="0x1">
          <comment>This bit indicates ad slice 1 cpst is in IDLE status.</comment>
        </bits>
        <bits access="r" name="rfdl_cpst_st_idle_ads0" pos="0" rst="0x1">
          <comment>This bit indicates ad slice 0 cpst is in IDLE status.</comment>
        </bits>
      </reg>
      <reg name="psram_rf_status_phy_data_in" protect="rw">
        <bits access="rw" name="rf_phy_data_in" pos="15:0" rst="0x0">
          <comment>phy input data</comment>
        </bits>
      </reg>
      <hole size="1952"/>
      <reg name="psram_rf_cfg_dll_ads0" protect="rw">
        <bits access="rw" name="rf_dll_lock_wait_ads0" pos="31:28" rst="0x0">
          <comment>This field indicates the cycles to wait the DLL lock internal signals</comment>
        </bits>
        <bits access="rw" name="rf_dll_auto_err_clr_en_ads0" pos="27" rst="0x0">
          <comment>This bit use to clear dll error automaticly</comment>
        </bits>
        <bits access="rw" name="rf_dll_pd_cnt_ads0" pos="26:24" rst="0x0">
          <comment>This field is the sum of the delay cells from phase1 to phase2.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_thr_ads0" pos="23:16" rst="0x0">
          <comment>This field is the threshold to start one compensation</comment>
        </bits>
        <bits access="rw" name="rf_dll_en_ads0" pos="15" rst="0x0">
          <comment>This bit enables the DLL.</comment>
        </bits>
        <bits access="rw" name="rf_dll_clk_sel_ads0" pos="14" rst="0x0">
          <comment>select input clock of dll for ad slice</comment>
        </bits>
        <bits access="w" name="rf_dll_err_clr_ads0" pos="13" rst="0x0">
          <comment>This bit write 1 to clear ad slice</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_auto_ref_en_ads0" pos="12" rst="0x0">
          <comment>This bit is used to enable automatic compensation when all bank auto refresh.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_start_ads0" pos="11" rst="0x0">
          <comment>This bit is used to start compensation one time.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_en_ads0" pos="10" rst="0x0">
          <comment>This bit enables the DLL compensation.</comment>
        </bits>
        <bits access="rw" name="rf_dll_auto_clr_en_ads0" pos="9" rst="0x0">
          <comment>This bit enables DLL automatically clear when in low power state</comment>
        </bits>
        <bits access="rw" name="rf_dll_clr_ads0" pos="8" rst="0x0">
          <comment>This field is to reset DLL</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_dll_ads0" protect="rw">
        <bits access="r" name="rfdll_error_ads0" pos="29" rst="0x0">
          <comment>This field is set if DLL error happens</comment>
        </bits>
        <bits access="r" name="rfdll_locked_ads0" pos="28" rst="0x0">
          <comment>This field indicates DLL is locked or not</comment>
        </bits>
        <bits access="r" name="rfdll_st_ads0" pos="27:25" rst="0x0">
          <comment>This fields show the state of DLL FSM</comment>
        </bits>
        <bits access="r" name="rfdl_cpst_st_ads0" pos="24" rst="0x0">
          <comment>This bit indicates ad slice 0 cpst is in IDLE status.</comment>
        </bits>
        <bits access="r" name="rfdll_cnt_ads0" pos="7:0" rst="0x0">
          <comment>This field indicate the count of delay cells for one clk_dmc cycle</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_0_wr_ads0" protect="rw">
        <bits access="rw" name="rf_clkwr_dl_cpst_en_ads0" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_dl_cpst_minus_ads0" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_qtr_dl_cpst_offset_ads0" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_clkwr_qtr_cnt_ads0" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_qtr_dl_sel_ads0" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_raw_dl_cpst_offset_ads0" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_clkwr_raw_cnt_ads0" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_raw_dl_sel_ads0" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_1_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dqs_in_pos_dl_cpst_en_ads0" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_dl_cpst_minus_ads0" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_qtr_dl_cpst_offset_ads0" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_pos_qtr_cnt_ads0" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_qtr_dl_sel_ads0" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_raw_dl_cpst_offset_ads0" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_pos_raw_cnt_ads0" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_raw_dl_sel_ads0" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_2_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dqs_in_neg_dl_cpst_en_ads0" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_dl_cpst_minus_ads0" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_qtr_dl_cpst_offset_ads0" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_neg_qtr_cnt_ads0" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_qtr_dl_sel_ads0" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_raw_dl_cpst_offset_ads0" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_neg_raw_cnt_ads0" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_raw_dl_sel_ads0" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_3_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dqs_gate_dl_cpst_en_ads0" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_dl_cpst_minus_ads0" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_qtr_dl_cpst_offset_ads0" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_gate_qtr_cnt_ads0" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_qtr_dl_sel_ads0" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_raw_dl_cpst_offset_ads0" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_gate_raw_cnt_ads0" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_raw_dl_sel_ads0" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_4_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_out_cen_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of CEN output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_clk_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of CLK output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_5_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_out_d3_dl_sel_ads0" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D3 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d2_dl_sel_ads0" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D2 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d1_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D1 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d0_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D0 output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_6_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_out_d7_dl_sel_ads0" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D7 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d6_dl_sel_ads0" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D6 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d5_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D5 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d4_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D4 output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_7_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_in_d3_dl_sel_ads0" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D3 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d2_dl_sel_ads0" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D2 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d1_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D1 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d0_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D0 input delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_8_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_in_d7_dl_sel_ads0" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D7 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d6_dl_sel_ads0" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D6 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d5_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D5 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d4_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D4 input delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_9_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_in_dqs_dl_sel_ads0" pos="20:16" rst="0x0">
          <comment>This field controls delay value of DQS input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_dqm_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of DQM input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_dqs_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of DQS output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_max_cnt_ads0" protect="rw">
        <bits access="r" name="rfdll_max_cnt_f3_ads0" pos="31:24" rst="0x0">
          <comment>dll max count for frequency set 3</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f2_ads0" pos="23:16" rst="0x0">
          <comment>dll max count for frequency set 2</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f1_ads0" pos="15:8" rst="0x0">
          <comment>dll max count for frequency set 1</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f0_ads0" pos="7:0" rst="0x0">
          <comment>dll max count for frequency set 0</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_min_cnt_ads0" protect="rw">
        <bits access="r" name="rfdll_min_cnt_f3_ads0" pos="31:24" rst="0xff">
          <comment>dll min count for frequency set 3</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f2_ads0" pos="23:16" rst="0xff">
          <comment>dll min count for frequency set 2</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f1_ads0" pos="15:8" rst="0xff">
          <comment>dll min count for frequency set 1</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f0_ads0" pos="7:0" rst="0xff">
          <comment>dll min count for frequency set 0</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_sel_wr_ads0" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_sel_ads0" pos="20" rst="0x0">
          <comment>This field controls IO source of CS
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_sel_ads0" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_sel_ads0" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_sel_ads0" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_sel_ads0" pos="7" rst="0x0">
          <comment>This field controls IO source of D7
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_sel_ads0" pos="6" rst="0x0">
          <comment>This field controls IO source of D6
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_sel_ads0" pos="5" rst="0x0">
          <comment>This field controls IO source of D5
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_sel_ads0" pos="4" rst="0x0">
          <comment>This field controls IO source of D4
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_sel_ads0" pos="3" rst="0x0">
          <comment>This field controls IO source of D3
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_sel_ads0" pos="2" rst="0x0">
          <comment>This field controls IO source of D2
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_sel_ads0" pos="1" rst="0x0">
          <comment>This field controls IO source of D1
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_sel_ads0" pos="0" rst="0x0">
          <comment>This field controls IO source of D0
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_ie_wr_ads0" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_ie_ads0" pos="20" rst="0x0">
          <comment>This field controls IO source of CS ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_ie_ads0" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_ie_ads0" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_ie_ads0" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_ie_ads0" pos="7" rst="0x0">
          <comment>This field controls IO source of D7 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_ie_ads0" pos="6" rst="0x0">
          <comment>This field controls IO source of D6 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_ie_ads0" pos="5" rst="0x0">
          <comment>This field controls IO source of D5 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_ie_ads0" pos="4" rst="0x0">
          <comment>This field controls IO source of D4 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_ie_ads0" pos="3" rst="0x0">
          <comment>This field controls IO source of D3 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_ie_ads0" pos="2" rst="0x0">
          <comment>This field controls IO source of D2 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_ie_ads0" pos="1" rst="0x0">
          <comment>This field controls IO source of D1 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_ie_ads0" pos="0" rst="0x0">
          <comment>This field controls IO source of D0 ie
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_oe_wr_ads0" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_oe_ads0" pos="20" rst="0x0">
          <comment>This field controls IO source of CS oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_oe_ads0" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_oe_ads0" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_oe_ads0" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_oe_ads0" pos="7" rst="0x0">
          <comment>This field controls IO source of D7 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_oe_ads0" pos="6" rst="0x0">
          <comment>This field controls IO source of D6 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_oe_ads0" pos="5" rst="0x0">
          <comment>This field controls IO source of D5 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_oe_ads0" pos="4" rst="0x0">
          <comment>This field controls IO source of D4 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_oe_ads0" pos="3" rst="0x0">
          <comment>This field controls IO source of D3 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_oe_ads0" pos="2" rst="0x0">
          <comment>This field controls IO source of D2 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_oe_ads0" pos="1" rst="0x0">
          <comment>This field controls IO source of D1 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_oe_ads0" pos="0" rst="0x0">
          <comment>This field controls IO source of D0 oe
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_out_wr_ads0" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_out_ads0" pos="20" rst="0x0">
          <comment>This field set value of CEN IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_out_ads0" pos="16" rst="0x0">
          <comment>This field set value of CLK IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_out_ads0" pos="9" rst="0x0">
          <comment>This field set value of DQS IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_out_ads0" pos="8" rst="0x0">
          <comment>This field set value of DQM IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_out_ads0" pos="7" rst="0x0">
          <comment>This field set value of D7 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_out_ads0" pos="6" rst="0x0">
          <comment>This field set value of D6 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_out_ads0" pos="5" rst="0x0">
          <comment>This field set value of D5 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_out_ads0" pos="4" rst="0x0">
          <comment>This field set value of D4 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_out_ads0" pos="3" rst="0x0">
          <comment>This field set value of D3 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_out_ads0" pos="2" rst="0x0">
          <comment>This field set value of D2 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_out_ads0" pos="1" rst="0x0">
          <comment>This field set value of D1 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_out_ads0" pos="0" rst="0x0">
          <comment>This field set value of D0 IO output</comment>
        </bits>
      </reg>
      <hole size="1472"/>
      <reg name="psram_rf_cfg_dll_ads1" protect="rw">
        <comment>not use</comment>
        <bits access="rw" name="rf_dll_lock_wait_ads1" pos="31:28" rst="0x0">
          <comment>This field indicates the cycles to wait the DLL lock internal signals</comment>
        </bits>
        <bits access="rw" name="rf_dll_auto_err_clr_en_ads1" pos="27" rst="0x0">
          <comment>This bit use to clear dll error automaticly</comment>
        </bits>
        <bits access="rw" name="rf_dll_pd_cnt_ads1" pos="26:24" rst="0x0">
          <comment>This field is the sum of the delay cells from phase1 to phase2.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_thr_ads1" pos="23:16" rst="0x0">
          <comment>This field is the threshold to start one compensation</comment>
        </bits>
        <bits access="rw" name="rf_dll_en_ads1" pos="15" rst="0x0">
          <comment>This bit enables the DLL.</comment>
        </bits>
        <bits access="rw" name="rf_dll_clk_sel_ads1" pos="14" rst="0x0">
          <comment>select input clock of dll for ad slice</comment>
        </bits>
        <bits access="w" name="rf_dll_err_clr_ads1" pos="13" rst="0x0">
          <comment>This bit write 1 to clear ad slice</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_auto_ref_en_ads1" pos="12" rst="0x0">
          <comment>This bit is used to enable automatic compensation when all bank auto refresh.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_start_ads1" pos="11" rst="0x0">
          <comment>This bit is used to start compensation one time.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_en_ads1" pos="10" rst="0x0">
          <comment>This bit enables the DLL compensation.</comment>
        </bits>
        <bits access="rw" name="rf_dll_auto_clr_en_ads1" pos="9" rst="0x0">
          <comment>This bit enables DLL automatically clear when in low power state</comment>
        </bits>
        <bits access="rw" name="rf_dll_clr_ads1" pos="8" rst="0x0">
          <comment>This field is to reset DLL</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_dll_ads1" protect="rw">
        <comment>not use</comment>
        <bits access="r" name="rfdll_error_ads1" pos="29" rst="0x0">
          <comment>This field is set if DLL error happens</comment>
        </bits>
        <bits access="r" name="rfdll_locked_ads1" pos="28" rst="0x0">
          <comment>This field indicates DLL is locked or not</comment>
        </bits>
        <bits access="r" name="rfdll_st_ads1" pos="27:25" rst="0x0">
          <comment>This fields show the state of DLL FSM</comment>
        </bits>
        <bits access="r" name="rfdl_cpst_st_ads1" pos="24" rst="0x0">
          <comment>This bit indicates ad slice 0 cpst is in IDLE status.</comment>
        </bits>
        <bits access="r" name="rfdll_cnt_ads1" pos="7:0" rst="0x0">
          <comment>This field indicate the count of delay cells for one clk_dmc cycle</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_0_wr_ads1" protect="rw">
        <bits access="rw" name="rf_clkwr_dl_cpst_en_ads1" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_dl_cpst_minus_ads1" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_qtr_dl_cpst_offset_ads1" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_clkwr_qtr_cnt_ads1" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_qtr_dl_sel_ads1" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_raw_dl_cpst_offset_ads1" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_clkwr_raw_cnt_ads1" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_raw_dl_sel_ads1" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_1_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dqs_in_pos_dl_cpst_en_ads1" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_dl_cpst_minus_ads1" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_qtr_dl_cpst_offset_ads1" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_pos_qtr_cnt_ads1" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_qtr_dl_sel_ads1" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_raw_dl_cpst_offset_ads1" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_pos_raw_cnt_ads1" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_raw_dl_sel_ads1" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_2_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dqs_in_neg_dl_cpst_en_ads1" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_dl_cpst_minus_ads1" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_qtr_dl_cpst_offset_ads1" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_neg_qtr_cnt_ads1" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_qtr_dl_sel_ads1" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_raw_dl_cpst_offset_ads1" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_neg_raw_cnt_ads1" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_raw_dl_sel_ads1" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_3_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dqs_gate_dl_cpst_en_ads1" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_dl_cpst_minus_ads1" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_qtr_dl_cpst_offset_ads1" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_gate_qtr_cnt_ads1" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_qtr_dl_sel_ads1" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_raw_dl_cpst_offset_ads1" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_gate_raw_cnt_ads1" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_raw_dl_sel_ads1" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_4_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_out_cen_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of CEN output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_clk_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of CLK output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_5_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_out_d3_dl_sel_ads1" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D3 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d2_dl_sel_ads1" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D2 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d1_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D1 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d0_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D0 output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_6_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_out_d7_dl_sel_ads1" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D7 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d6_dl_sel_ads1" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D6 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d5_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D5 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d4_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D4 output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_7_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_in_d3_dl_sel_ads1" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D3 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d2_dl_sel_ads1" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D2 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d1_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D1 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d0_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D0 input delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_8_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_in_d7_dl_sel_ads1" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D7 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d6_dl_sel_ads1" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D6 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d5_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D5 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d4_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D4 input delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_9_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_in_dqs_dl_sel_ads1" pos="20:16" rst="0x0">
          <comment>This field controls delay value of DQS input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_dqm_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of DQM input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_dqs_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of DQS output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_max_cnt_ads1" protect="rw">
        <comment>not use</comment>
        <bits access="r" name="rfdll_max_cnt_f3_ads1" pos="31:24" rst="0x0">
          <comment>dll max count for frequency set 3</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f2_ads1" pos="23:16" rst="0x0">
          <comment>dll max count for frequency set 2</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f1_ads1" pos="15:8" rst="0x0">
          <comment>dll max count for frequency set 1</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f0_ads1" pos="7:0" rst="0x0">
          <comment>dll max count for frequency set 0</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_min_cnt_ads1" protect="rw">
        <bits access="r" name="rfdll_min_cnt_f3_ads1" pos="31:24" rst="0xff">
          <comment>dll min count for frequency set 3</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f2_ads1" pos="23:16" rst="0xff">
          <comment>dll min count for frequency set 2</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f1_ads1" pos="15:8" rst="0xff">
          <comment>dll min count for frequency set 1</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f0_ads1" pos="7:0" rst="0xff">
          <comment>dll min count for frequency set 0</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_sel_wr_ads1" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_sel_ads1" pos="20" rst="0x0">
          <comment>This field controls IO source of CS
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_sel_ads1" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_sel_ads1" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_sel_ads1" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_sel_ads1" pos="7" rst="0x0">
          <comment>This field controls IO source of D7
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_sel_ads1" pos="6" rst="0x0">
          <comment>This field controls IO source of D6
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_sel_ads1" pos="5" rst="0x0">
          <comment>This field controls IO source of D5
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_sel_ads1" pos="4" rst="0x0">
          <comment>This field controls IO source of D4
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_sel_ads1" pos="3" rst="0x0">
          <comment>This field controls IO source of D3
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_sel_ads1" pos="2" rst="0x0">
          <comment>This field controls IO source of D2
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_sel_ads1" pos="1" rst="0x0">
          <comment>This field controls IO source of D1
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_sel_ads1" pos="0" rst="0x0">
          <comment>This field controls IO source of D0
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_ie_wr_ads1" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_ie_ads1" pos="20" rst="0x0">
          <comment>This field controls IO source of CS ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_ie_ads1" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_ie_ads1" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_ie_ads1" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_ie_ads1" pos="7" rst="0x0">
          <comment>This field controls IO source of D7 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_ie_ads1" pos="6" rst="0x0">
          <comment>This field controls IO source of D6 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_ie_ads1" pos="5" rst="0x0">
          <comment>This field controls IO source of D5 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_ie_ads1" pos="4" rst="0x0">
          <comment>This field controls IO source of D4 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_ie_ads1" pos="3" rst="0x0">
          <comment>This field controls IO source of D3 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_ie_ads1" pos="2" rst="0x0">
          <comment>This field controls IO source of D2 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_ie_ads1" pos="1" rst="0x0">
          <comment>This field controls IO source of D1 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_ie_ads1" pos="0" rst="0x0">
          <comment>This field controls IO source of D0 ie
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_oe_wr_ads1" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_oe_ads1" pos="20" rst="0x0">
          <comment>This field controls IO source of CS oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_oe_ads1" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_oe_ads1" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_oe_ads1" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_oe_ads1" pos="7" rst="0x0">
          <comment>This field controls IO source of D7 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_oe_ads1" pos="6" rst="0x0">
          <comment>This field controls IO source of D6 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_oe_ads1" pos="5" rst="0x0">
          <comment>This field controls IO source of D5 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_oe_ads1" pos="4" rst="0x0">
          <comment>This field controls IO source of D4 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_oe_ads1" pos="3" rst="0x0">
          <comment>This field controls IO source of D3 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_oe_ads1" pos="2" rst="0x0">
          <comment>This field controls IO source of D2 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_oe_ads1" pos="1" rst="0x0">
          <comment>This field controls IO source of D1 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_oe_ads1" pos="0" rst="0x0">
          <comment>This field controls IO source of D0 oe
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_out_wr_ads1" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_out_ads1" pos="20" rst="0x0">
          <comment>This field set value of CEN IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_out_ads1" pos="16" rst="0x0">
          <comment>This field set value of CLK IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_out_ads1" pos="9" rst="0x0">
          <comment>This field set value of DQS IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_out_ads1" pos="8" rst="0x0">
          <comment>This field set value of DQM IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_out_ads1" pos="7" rst="0x0">
          <comment>This field set value of D7 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_out_ads1" pos="6" rst="0x0">
          <comment>This field set value of D6 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_out_ads1" pos="5" rst="0x0">
          <comment>This field set value of D5 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_out_ads1" pos="4" rst="0x0">
          <comment>This field set value of D4 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_out_ads1" pos="3" rst="0x0">
          <comment>This field set value of D3 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_out_ads1" pos="2" rst="0x0">
          <comment>This field set value of D2 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_out_ads1" pos="1" rst="0x0">
          <comment>This field set value of D1 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_out_ads1" pos="0" rst="0x0">
          <comment>This field set value of D0 IO output</comment>
        </bits>
      </reg>
      <hole size="1472"/>
      <reg name="psram_drf_cfg" protect="rw">
        <bits access="rw" name="drf_clkdmem_out_sel" pos="0" rst="0x0">
          <comment>This field use to  select clkdmem_out
0:clkdmem_out invert
1:clkdmem_out</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_reg_sel" protect="rw">
        <bits access="rw" name="drf_reg_sel" pos="1:0" rst="0x0">
          <comment>This field use to  select f0/f1/f2/f3 register</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_ie_sel_f0" protect="rw">
        <bits access="rw" name="drf_dqs_ie_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_oe_sel_f0" protect="rw">
        <bits access="rw" name="drf_dqs_oe_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_out_sel_f0" protect="rw">
        <bits access="rw" name="drf_dqs_out_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs out delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_gate_sel_f0" protect="rw">
        <bits access="rw" name="drf_dqs_gate_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs gate delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_ie_sel_f0" protect="rw">
        <bits access="rw" name="drf_data_ie_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select data ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_oe_sel_f0" protect="rw">
        <bits access="rw" name="drf_data_oe_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select data oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_ie_sel_f1" protect="rw">
        <bits access="rw" name="drf_dqs_ie_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_oe_sel_f1" protect="rw">
        <bits access="rw" name="drf_dqs_oe_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_out_sel_f1" protect="rw">
        <bits access="rw" name="drf_dqs_out_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs out delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_gate_sel_f1" protect="rw">
        <bits access="rw" name="drf_dqs_gate_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs gate delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_ie_sel_f1" protect="rw">
        <bits access="rw" name="drf_data_ie_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select data ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_oe_sel_f1" protect="rw">
        <bits access="rw" name="drf_data_oe_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select data oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_ie_sel_f2" protect="rw">
        <bits access="rw" name="drf_dqs_ie_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_oe_sel_f2" protect="rw">
        <bits access="rw" name="drf_dqs_oe_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_out_sel_f2" protect="rw">
        <bits access="rw" name="drf_dqs_out_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs out delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_gate_sel_f2" protect="rw">
        <bits access="rw" name="drf_dqs_gate_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs gate delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_ie_sel_f2" protect="rw">
        <bits access="rw" name="drf_data_ie_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select data ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_oe_sel_f2" protect="rw">
        <bits access="rw" name="drf_data_oe_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select data oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_ie_sel_f3" protect="rw">
        <bits access="rw" name="drf_dqs_ie_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_oe_sel_f3" protect="rw">
        <bits access="rw" name="drf_dqs_oe_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_out_sel_f3" protect="rw">
        <bits access="rw" name="drf_dqs_out_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs out delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_gate_sel_f3" protect="rw">
        <bits access="rw" name="drf_dqs_gate_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs gate delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_ie_sel_f3" protect="rw">
        <bits access="rw" name="drf_data_ie_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select data ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_oe_sel_f3" protect="rw">
        <bits access="rw" name="drf_data_oe_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select data oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_mode_f0" protect="rw">
        <bits access="rw" name="drf_dll_satu_mode_f0" pos="2" rst="0x0">
          <comment>This field use to  select dll in saturate mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_half_mode_f0" pos="1" rst="0x0">
          <comment>This field use to  select dll in half mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_clk_mode_f0" pos="0" rst="0x0">
          <comment>This field use to  select dll in x1 or x2 clk mode</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_cnt_f0" protect="rw">
        <bits access="rw" name="drf_dll_auto_cnt_f0" pos="29:20" rst="0x0">
          <comment>dll counts setting  for fast lock</comment>
        </bits>
        <bits access="rw" name="drf_dll_satu_cnt_f0" pos="19:10" rst="0x0">
          <comment>indicate the count of dll state</comment>
        </bits>
        <bits access="rw" name="drf_dll_init_cnt_f0" pos="9:0" rst="0x0">
          <comment>This field is used to configure DLL searching start value</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_mode_f1" protect="rw">
        <bits access="rw" name="drf_dll_satu_mode_f1" pos="2" rst="0x0">
          <comment>This field use to  select dll in saturate mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_half_mode_f1" pos="1" rst="0x0">
          <comment>This field use to  select dll in half mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_clk_mode_f1" pos="0" rst="0x0">
          <comment>This field use to  select dll in x1 or x2 clk mode</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_cnt_f1" protect="rw">
        <bits access="rw" name="drf_dll_auto_cnt_f1" pos="29:20" rst="0x0">
          <comment>dll counts setting  for fast lock</comment>
        </bits>
        <bits access="rw" name="drf_dll_satu_cnt_f1" pos="19:10" rst="0x0">
          <comment>indicate the count of dll state</comment>
        </bits>
        <bits access="rw" name="drf_dll_init_cnt_f1" pos="9:0" rst="0x0">
          <comment>This field is used to configure DLL searching start value</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_mode_f2" protect="rw">
        <bits access="rw" name="drf_dll_satu_mode_f2" pos="2" rst="0x0">
          <comment>This field use to  select dll in saturate mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_half_mode_f2" pos="1" rst="0x0">
          <comment>This field use to  select dll in half mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_clk_mode_f2" pos="0" rst="0x0">
          <comment>This field use to  select dll in x1 or x2 clk mode</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_cnt_f2" protect="rw">
        <bits access="rw" name="drf_dll_auto_cnt_f2" pos="29:20" rst="0x0">
          <comment>dll counts setting  for fast lock</comment>
        </bits>
        <bits access="rw" name="drf_dll_satu_cnt_f2" pos="19:10" rst="0x0">
          <comment>indicate the count of dll state</comment>
        </bits>
        <bits access="rw" name="drf_dll_init_cnt_f2" pos="9:0" rst="0x0">
          <comment>This field is used to configure DLL searching start value</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_mode_f3" protect="rw">
        <bits access="rw" name="drf_dll_satu_mode_f3" pos="2" rst="0x0">
          <comment>This field use to  select dll in saturate mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_half_mode_f3" pos="1" rst="0x0">
          <comment>This field use to  select dll in half mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_clk_mode_f3" pos="0" rst="0x0">
          <comment>This field use to  select dll in x1 or x2 clk mode</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_cnt_f3" protect="rw">
        <bits access="rw" name="drf_dll_auto_cnt_f3" pos="29:20" rst="0x0">
          <comment>dll counts setting  for fast lock</comment>
        </bits>
        <bits access="rw" name="drf_dll_satu_cnt_f3" pos="19:10" rst="0x0">
          <comment>indicate the count of dll state</comment>
        </bits>
        <bits access="rw" name="drf_dll_init_cnt_f3" pos="9:0" rst="0x0">
          <comment>This field is used to configure DLL searching start value</comment>
        </bits>
      </reg>
      <hole size="960"/>
      <reg name="psram_drf_format_control" protect="rw">
        <bits access="rw" name="drf_memory_burst" pos="1:0" rst="0x0">
          <comment>This field use to set psram memory burst</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_rcd" protect="rw">
        <bits access="rw" name="drf_t_rcd" pos="3:0" rst="0x0">
          <comment>This field use to set rcd timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_rddata_en" protect="rw">
        <bits access="rw" name="drf_t_rddata_en" pos="3:0" rst="0x0">
          <comment>This field use to set rddata_en timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_phywrlat" protect="rw">
        <bits access="rw" name="drf_t_phywrlat" pos="3:0" rst="0x0">
          <comment>This field use to set phywrlat timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_cph_wr" protect="rw">
        <bits access="rw" name="drf_t_cph_wr" pos="3:0" rst="0x0">
          <comment>This field use to set cph_wr timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_cph_rd" protect="rw">
        <bits access="rw" name="drf_t_cph_rd_optm" pos="4" rst="0x0">
          <comment>This field use to set cph_rd_optm timing</comment>
        </bits>
        <bits access="rw" name="drf_t_cph_rd" pos="2:0" rst="0x0">
          <comment>This field use to set cph_rd timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_data_oe_ext" protect="rw">
        <bits access="rw" name="drf_t_data_oe_cmd_ext" pos="7:4" rst="0x0">
          <comment>This field use to set cmd data oe extend cycle</comment>
        </bits>
        <bits access="rw" name="drf_t_data_oe_wdata_ext" pos="3:0" rst="0x0">
          <comment>This field use to set wdata oe extend cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_dqs_oe_ext" protect="rw">
        <bits access="rw" name="drf_t_dqs_oe_ext" pos="3:0" rst="0x0">
          <comment>This field use to set dqs oe extend cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_xphs" protect="rw">
        <bits access="rw" name="drf_t_xphs" pos="4:0" rst="0x0">
          <comment>This field use to set xphs timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_rddata_vld_sync" protect="rw">
        <bits access="rw" name="drf_t_rddata_vld_sync" pos="2:0" rst="0x0">
          <comment>This field use to set rddata valid sync cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_rddata_late" protect="rw">
        <bits access="rw" name="drf_t_rddata_late" pos="4:0" rst="0x0">
          <comment>This field use to set rddata late cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_rddata_valid_early" protect="rw">
        <bits access="rw" name="drf_t_rddata_valid_early" pos="1:0" rst="0x0">
          <comment>This field use to set rddata early cycle</comment>
        </bits>
      </reg>
      <reg name="drf_t_wb_rst" protect="rw">
        <bits access="rw" name="drf_t_wb_rp_rst" pos="13:8" rst="0x0">
          <comment>This field use to set winbond reset rp cycle</comment>
        </bits>
        <bits access="rw" name="drf_t_wb_rh_rst" pos="5:0" rst="0x0">
          <comment>This field use to set winbond reset rh cycle</comment>
        </bits>
      </reg>
      <hole size="1632"/>
      <reg name="psram_drf_train_cfg" protect="rw">
        <comment>not use</comment>
        <bits access="rw" name="drf_dmc_rdlvl_gate_en" pos="21" rst="0x0">
          <comment>This field use to enable dmc read gate training</comment>
        </bits>
        <bits access="rw" name="drf_phy_rdlvl_gate_en" pos="20" rst="0x0">
          <comment>This field use to enable phy read gate training</comment>
        </bits>
        <bits access="rw" name="drf_dmc_rdlvl_en" pos="17" rst="0x0">
          <comment>This field use to enable dmc read data eye training</comment>
        </bits>
        <bits access="rw" name="drf_phy_rdlvl_en" pos="16" rst="0x0">
          <comment>This field use to enable phy read data eye training</comment>
        </bits>
        <bits access="rw" name="drf_dmc_wrlvl_en" pos="13" rst="0x0">
          <comment>This field use to enable dmc write training</comment>
        </bits>
        <bits access="rw" name="drf_phy_wrlvl_en" pos="12" rst="0x0">
          <comment>This field use to enable phy write training</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_type_3" pos="11:10" rst="0x0">
          <comment>This field use to define type3 max number of cycles of idle time on DFI control</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_type_2" pos="9:8" rst="0x0">
          <comment>This field use to define type2 max number of cycles of idle time on DFI control</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_type_1" pos="7:6" rst="0x0">
          <comment>This field use to define type1 max number of cycles of idle time on DFI control</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_type_0" pos="5:4" rst="0x0">
          <comment>This field use to define type0 max number of cycles of idle time on DFI control</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_type_sel" pos="2:1" rst="0x0">
          <comment>This field use to select phyupd type</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_en" pos="0" rst="0x0">
          <comment>This field use to enable phy-initiated update</comment>
        </bits>
      </reg>
      <reg name="psram_drf_mr_data_en" protect="rw">
        <bits access="rw" name="drf_mr_data_en" pos="0" rst="0x0">
          <comment>record read memory register data enable</comment>
        </bits>
      </reg>
      <reg name="psram_drf_mr_data_0" protect="rw">
        <comment>read memory register data0</comment>
      </reg>
      <reg name="psram_drf_mr_data_1" protect="rw">
        <comment>read memory register data1</comment>
      </reg>
      <hole size="1920"/>
      <reg name="psram_rf_irq_ctrl" protect="rw">
        <bits access="rw" name="rf_irq_en_disc_rd_ads1" pos="20" rst="0x0">
          <comment>ads1 read command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_wr_ads1" pos="19" rst="0x0">
          <comment>ads1 write command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_mrr_ads1" pos="18" rst="0x0">
          <comment>ads1 mr read command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_mrw_ads1" pos="17" rst="0x0">
          <comment>ads1 mr write command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_rst_ads1" pos="16" rst="0x0">
          <comment>ads1 reset command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_rd_ads0" pos="12" rst="0x0">
          <comment>ads0 read command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_wr_ads0" pos="11" rst="0x0">
          <comment>ads0 write command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_mrr_ads0" pos="10" rst="0x0">
          <comment>ads0 mr read command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_mrw_ads0" pos="9" rst="0x0">
          <comment>ads0 mr write command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_rst_ads0" pos="8" rst="0x0">
          <comment>ads0 reset command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_rddata_timeout_ads1" pos="5" rst="0x0">
          <comment>ads1 rddata timeout int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_rddata_timeout_ads0" pos="4" rst="0x0">
          <comment>ads0 rddata timeout int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_dll_unlock_ads1" pos="1" rst="0x0">
          <comment>ads1 dll unlock int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_dll_unlock_ads0" pos="0" rst="0x0">
          <comment>ads0 dll unlock int enable</comment>
        </bits>
      </reg>
      <reg name="psram_rf_irq_status_clr" protect="rw">
        <bits access="rw" name="rf_irq_st_clr_disc_rd_ads1" pos="20" rst="0x0">
          <comment>ads1 read command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_wr_ads1" pos="19" rst="0x0">
          <comment>ads1 write command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_mrr_ads1" pos="18" rst="0x0">
          <comment>ads1 mr read command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_mrw_ads1" pos="17" rst="0x0">
          <comment>ads1 mr write command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_rst_ads1" pos="16" rst="0x0">
          <comment>ads1 reset command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_rd_ads0" pos="12" rst="0x0">
          <comment>ads0 read command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_wr_ads0" pos="11" rst="0x0">
          <comment>ads0 write command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_mrr_ads0" pos="10" rst="0x0">
          <comment>ads0 mr read command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_mrw_ads0" pos="9" rst="0x0">
          <comment>ads0 mr write command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_rst_ads0" pos="8" rst="0x0">
          <comment>ads0 reset command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_rddata_timeout_ads1" pos="5" rst="0x0">
          <comment>ads1 rddata timeout int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_rddata_timeout_ads0" pos="4" rst="0x0">
          <comment>ads0 rddata timeout int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_dll_unlock_ads1" pos="1" rst="0x0">
          <comment>ads1 dll unlock int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_dll_unlock_ads0" pos="0" rst="0x0">
          <comment>ads0 dll unlock int clear</comment>
        </bits>
      </reg>
      <reg name="psram_rf_irq_status" protect="rw">
        <bits access="r" name="rf_irq_st_disc_rd_ads1" pos="20" rst="0x0">
          <comment>ads1 read command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_wr_ads1" pos="19" rst="0x0">
          <comment>ads1 write command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_mrr_ads1" pos="18" rst="0x0">
          <comment>ads1 mr read command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_mrw_ads1" pos="17" rst="0x0">
          <comment>ads1 mr write command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_rst_ads1" pos="16" rst="0x0">
          <comment>ads1 reset command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_rd_ads0" pos="12" rst="0x0">
          <comment>ads0 read command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_wr_ads0" pos="11" rst="0x0">
          <comment>ads0 write command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_mrr_ads0" pos="10" rst="0x0">
          <comment>ads0 mr read command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_mrw_ads0" pos="9" rst="0x0">
          <comment>ads0 mr write command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_rst_ads0" pos="8" rst="0x0">
          <comment>ads0 reset command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_rddata_timeout_ads1" pos="5" rst="0x0">
          <comment>ads1 rddata timeout int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_rddata_timeout_ads0" pos="4" rst="0x0">
          <comment>ads0 rddata timeout int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_dll_unlock_ads1" pos="1" rst="0x0">
          <comment>ads1 dll unlock int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_dll_unlock_ads0" pos="0" rst="0x0">
          <comment>ads0 dll unlock int status</comment>
        </bits>
      </reg>
      <reg name="psram_rf_irq_cnt_clr" protect="rw">
        <bits access="w" name="rf_irq_cnt_clr_dll_unlock_ads1" pos="1" rst="0x0">
          <comment>ads1 dll unlock cnt clear</comment>
        </bits>
        <bits access="w" name="rf_irq_cnt_clr_dll_unlock_ads0" pos="0" rst="0x0">
          <comment>ads0 dll unlock cnt clear</comment>
        </bits>
      </reg>
      <reg name="psram_rf_irq_cnt_dll_unlock_ads0" protect="rw">
        <bits access="r" name="rf_irq_cnt_overflow_dll_unlock_ads0" pos="31" rst="0x0">
          <comment>ads0 dll unlock cnt overflow status</comment>
        </bits>
        <bits access="r" name="rf_irq_cnt_dll_unlock_ads0" pos="30:0" rst="0x0">
          <comment>ads0 dll unlock cnt value</comment>
        </bits>
      </reg>
      <reg name="psram_rf_irq_cnt_dll_unlock_ads1" protect="rw">
        <bits access="r" name="rf_irq_cnt_overflow_dll_unlock_ads1" pos="31" rst="0x0">
          <comment>ads1 dll unlock cnt overflow status</comment>
        </bits>
        <bits access="r" name="rf_irq_cnt_dll_unlock_ads1" pos="30:0" rst="0x0">
          <comment>ads1 dll unlock cnt value</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="io_rf_psram_drv_cfg" protect="rw">
        <bits access="rw" name="psram_drvn" pos="12:8" rst="0x10"/>
        <bits access="rw" name="psram_drvp" pos="7:3" rst="0x10"/>
        <bits access="rw" name="psram_slewrate" pos="2:1" rst="0x0"/>
        <bits access="rw" name="psram_fix_read0" pos="0" rst="0x1"/>
      </reg>
      <reg name="io_rf_psram_pad_en_cfg" protect="rw">
        <bits access="rw" name="psram_pad_clkn_en" pos="0" rst="0x1"/>
      </reg>
      <reg name="io_rf_psram_pull_cfg" protect="rw">
        <bits access="rw" name="psram_cen_pull1_bit" pos="11:10" rst="0x1"/>
        <bits access="rw" name="psram_clk_pull0_bit" pos="9:8" rst="0x1"/>
        <bits access="rw" name="psram_clkn_pull1_bit" pos="7:6" rst="0x1"/>
        <bits access="rw" name="psram_dm_pull1_bit" pos="5:4" rst="0x1"/>
        <bits access="rw" name="psram_dq_pull0_bit" pos="3:2" rst="0x0"/>
        <bits access="rw" name="psram_dqs_pull0_bit" pos="1:0" rst="0x1"/>
      </reg>
      <reg name="io_rf_psram_reserved" protect="rw">
        </reg>
    </module>
    <instance address="0x51601000" name="PSRAM_PHY" type="PSRAM_PHY"/>
  </archive>
  <archive relative="cp_irqh.xml">
    <module category="System" name="CP_IRQH">
      <reg name="inth_itr0" protect="rw">
        <comment>Interrupt flag Register0</comment>
      </reg>
      <reg name="inth_itr1" protect="rw">
        <comment>Interrupt flag Register0</comment>
      </reg>
      <reg name="inth_mir0" protect="rw">
        <comment>Interrupt mask Register0</comment>
      </reg>
      <reg name="inth_mir1" protect="rw">
        <comment>Interrupt mask Register1</comment>
      </reg>
      <reg name="inth_mirs0" protect="rw">
        <comment>中断屏蔽置1寄存器0</comment>
      </reg>
      <reg name="inth_mirs1" protect="rw">
        <comment>中断屏蔽置1寄存器1</comment>
      </reg>
      <reg name="inth_mirc0" protect="rw">
        <comment>中断屏蔽清0寄存器0</comment>
      </reg>
      <reg name="inth_mirc1" protect="rw">
        <comment>中断屏蔽清0寄存器1</comment>
      </reg>
      <reg name="inth_gmir" protect="rw">
        <comment>全局中断屏蔽寄存器</comment>
        <bits access="rw" name="gim" pos="0" rst="0x1">
          <comment>Global interrupt enable BIT
0：Interrupt is decided by corresponding mask bit
1：Maks all Interrupt</comment>
        </bits>
      </reg>
      <reg name="inth_sel0" protect="rw">
        <comment>中断选择寄存器0</comment>
      </reg>
      <reg name="inth_sel1" protect="rw">
        <comment>中断选择寄存器1</comment>
      </reg>
      <hole size="32"/>
      <reg name="irq_sta0" protect="rw">
        <comment>IRQ中断状态寄存器</comment>
      </reg>
      <reg name="irq_sta1" protect="rw">
        <comment>IRQ中断状态寄存器</comment>
      </reg>
      <reg name="irq_sir" protect="rw">
        <comment>IRQ中断源寄存器</comment>
        <bits access="r" name="is" pos="6:0" rst="0x7f">
          <comment>IRQ interrupt source code
0000000：IRQ0
0000001：IRQ1
0000010：IRQ2
……
0111111：IRQ63</comment>
        </bits>
      </reg>
      <reg name="irq_ctrl" protect="rw">
        <comment>IRQ中断控制寄存器</comment>
        <bits access="w" name="clr" pos="0" rst="0x0">
          <comment>Clear interrupt status bit
0：no operation
1：clear corresponding bit of IRQ_STA and ITR,at the same time change irq from high to low</comment>
        </bits>
      </reg>
      <reg name="fiq_sta0" protect="rw">
        <comment>FIQ中断状态寄存器</comment>
      </reg>
      <reg name="fiq_sta1" protect="rw">
        <comment>FIQ中断状态寄存器</comment>
      </reg>
      <reg name="fiq_sir" protect="rw">
        <comment>FIQ中断源寄存器</comment>
        <bits access="r" name="fs" pos="6:0" rst="0x7f">
          <comment>fiq interrupt source code
0000000：FIQ0
0000001：FIQ1
0000010：FIQ2
……
0111111：FIQ63</comment>
        </bits>
      </reg>
      <reg name="fiq_ctrl" protect="rw">
        <comment>FIQ中断控制寄存器</comment>
        <bits access="w" name="clr" pos="0" rst="0x0">
          <comment>Clear interrupt status bit
0：no operation
1：clear corresponding bit of IRQ_STA and ITR,at the same time change irq from high to low</comment>
        </bits>
      </reg>
      <reg name="vicprio0" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio1" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio2" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio3" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio4" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio5" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio6" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio7" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio8" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio9" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio10" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio11" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio12" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio13" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio14" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio15" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio16" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio17" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio18" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio19" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio20" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio21" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio22" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio23" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio24" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio25" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio26" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio27" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio28" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio29" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio30" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio31" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio32" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio33" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio34" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio35" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio36" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio37" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio38" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio39" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio40" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio41" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio42" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio43" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio44" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio45" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio46" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio47" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio48" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio49" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio50" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio51" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio52" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio53" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio54" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio55" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio56" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio57" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio58" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio59" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio60" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio61" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio62" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio63" protect="rw">
        <comment>中断优先级配置寄存器</comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0：Interrupt prio 0
1：Interrupt prio 1
……
7：Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x14009000" name="CP_IRQH" type="CP_IRQH"/>
    <instance address="0x1400a000" name="CP_IRQH1" type="CP_IRQH"/>
  </archive>
  <archive relative="cp_axidma.xml">
    <module category="System" name="CP_AXIDMA">
      <reg name="axidma_conf" protect="rw">
        <bits access="rw" name="gen_reg_secuirty_en" pos="6" rst="0x1">
          <comment>general used register security visit enable
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="resp_err_stop_en" pos="5" rst="0x0">
          <comment>response error stop function enable
0：enable
1：disable</comment>
        </bits>
        <bits access="rw" name="outstand" pos="4:3" rst="0x2">
          <comment>the number of outstanding that can be send out
0: 2
1: 3
2: 4</comment>
        </bits>
        <bits access="rw" name="priority" pos="2" rst="0x0">
          <comment>multe-channel transport priority mode control
0: there is no priority in the channels, using polling to DMA data
1: smaller channel number has high-priority.high-priority move data before low-priority channels</comment>
        </bits>
        <bits access="rw" name="stop_ie" pos="1" rst="0x0">
          <comment>interrupt control bit
0: no interruption occurs when all logical channels finish
1: interruption occurs when all logical channels finish</comment>
        </bits>
        <bits access="rw" name="stop" pos="0" rst="0x0">
          <comment>the control bit of logical channel transport finish
0: don't stop all the channel,or automatically clear after setting
1: stop all channel.the current transmission is stopped.the start bits of all channels are cleared</comment>
        </bits>
      </reg>
      <reg name="axidma_delay" protect="rw">
        <bits access="rw" name="delay" pos="15:0" rst="0x0">
          <comment>in the non-priority mode, the time interval between two COUNTP transmission. Take the system clock as the criterion to avoid AXIDMA long-term use of the bus.</comment>
        </bits>
      </reg>
      <reg name="axidma_status" protect="rw">
        <bits access="r" name="stop_status" pos="4" rst="0x0">
          <comment>stop status
0: not finish
1: finish</comment>
        </bits>
        <bits access="r" name="ch_num" pos="3:0" rst="0xf">
          <comment>the channel number of the final transmission
0000: channel 0 just finished the transmission
0001: channel 1 just finished the transmission
0010: channel 2 just finished the transmission
……
1011: channel 11 just finished the transmission
others: nonentity</comment>
        </bits>
      </reg>
      <reg name="axidma_irq_stat" protect="rw">
        <bits access="r" name="rst_fin_irq" pos="12" rst="0x0">
          <comment>逻辑通道传输停止中断状态位
0：逻辑通道传输停止中断未产生
1：逻辑通道传输停止产生中</comment>
        </bits>
        <bits access="r" name="ch11_irq" pos="11" rst="0x0">
          <comment>channel 11 interrupts state
0: the channel 11 has not been interrupted, or the interrupt bit has been cleared
1: channel 11 is interrupted</comment>
        </bits>
        <bits access="r" name="ch10_irq" pos="10" rst="0x0">
          <comment>channel 10 interrupts state
0: the channel 10 has not been interrupted, or the interrupt bit has been cleared
1: channel 10 is interrupted</comment>
        </bits>
        <bits access="r" name="ch9_irq" pos="9" rst="0x0">
          <comment>channel 9 interrupts state
0: the channel 9 has not been interrupted, or the interrupt bit has been cleared
1: channel 9 is interrupted</comment>
        </bits>
        <bits access="r" name="ch8_irq" pos="8" rst="0x0">
          <comment>channel 8 interrupts state
0: the channel 8 has not been interrupted, or the interrupt bit has been cleared
1: channel 8 is interrupted</comment>
        </bits>
        <bits access="r" name="ch7_irq" pos="7" rst="0x0">
          <comment>channel 7 interrupts state
0: the channel 7 has not been interrupted, or the interrupt bit has been cleared
1: channel 7 is interrupted</comment>
        </bits>
        <bits access="r" name="ch6_irq" pos="6" rst="0x0">
          <comment>channel 6 interrupts state
0: the channel 6 has not been interrupted, or the interrupt bit has been cleared
1: channel 6 is interrupted</comment>
        </bits>
        <bits access="r" name="ch5_irq" pos="5" rst="0x0">
          <comment>channel 5 interrupts state
0: the channel 5 has not been interrupted, or the interrupt bit has been cleared
1: channel 5 is interrupted</comment>
        </bits>
        <bits access="r" name="ch4_irq" pos="4" rst="0x0">
          <comment>channel 4 interrupts state
0: the channel 4 has not been interrupted, or the interrupt bit has been cleared
1: channel 4 is interrupted</comment>
        </bits>
        <bits access="r" name="ch3_irq" pos="3" rst="0x0">
          <comment>channel 3 interrupts state
0: the channel 3 has not been interrupted, or the interrupt bit has been cleared
1: channel 3 is interrupted</comment>
        </bits>
        <bits access="r" name="ch2_irq" pos="2" rst="0x0">
          <comment>channel 2 interrupts state
0: the channel 2 has not been interrupted, or the interrupt bit has been cleared
1: channel 2 is interrupted</comment>
        </bits>
        <bits access="r" name="ch1_irq" pos="1" rst="0x0">
          <comment>channel 1 interrupts state
0: the channel 1 has not been interrupted, or the interrupt bit has been cleared
1: channel 1 is interrupted</comment>
        </bits>
        <bits access="r" name="ch0_irq" pos="0" rst="0x0">
          <comment>channel 0 interrupts state
0: the channel 0 has not been interrupted, or the interrupt bit has been cleared
1: channel 0 is interrupted</comment>
        </bits>
      </reg>
      <reg name="axidma_arm_req_stat" protect="rw">
        <bits access="r" name="irq23" pos="23" rst="0x0">
          <comment>state of IRQ 23 generate requests of moving data
0: IRQ 23 does not generate requests of moving data
1: IRQ 23 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq22" pos="22" rst="0x0">
          <comment>state of IRQ 22 generate requests of moving data
0: IRQ 22 does not generate requests of moving data
1: IRQ 22 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq21" pos="21" rst="0x0">
          <comment>state of IRQ 21 generate requests of moving data
0: IRQ 21 does not generate requests of moving data
1: IRQ 21 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq20" pos="20" rst="0x0">
          <comment>state of IRQ 20 generate requests of moving data
0: IRQ 20 does not generate requests of moving data
1: IRQ 20 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq19" pos="19" rst="0x0">
          <comment>state of IRQ 19 generate requests of moving data
0: IRQ 19 does not generate requests of moving data
1: IRQ 19 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq18" pos="18" rst="0x0">
          <comment>state of IRQ 18 generate requests of moving data
0: IRQ 18 does not generate requests of moving data
1: IRQ 18 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq17" pos="17" rst="0x0">
          <comment>state of IRQ 17 generate requests of moving data
0: IRQ 17 does not generate requests of moving data
1: IRQ 17 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq16" pos="16" rst="0x0">
          <comment>state of IRQ 16 generate requests of moving data
0: IRQ 16 does not generate requests of moving data
1: IRQ 16 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq15" pos="15" rst="0x0">
          <comment>state of IRQ 15 generate requests of moving data
0: IRQ 15 does not generate requests of moving data
1: IRQ 15 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq14" pos="14" rst="0x0">
          <comment>state of IRQ 14 generate requests of moving data
0: IRQ 14 does not generate requests of moving data
1: IRQ 14 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq13" pos="13" rst="0x0">
          <comment>state of IRQ 13 generate requests of moving data
0: IRQ 13 does not generate requests of moving data
1: IRQ 13 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq12" pos="12" rst="0x0">
          <comment>state of IRQ 12 generate requests of moving data
0: IRQ 12 does not generate requests of moving data
1: IRQ 12 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq11" pos="11" rst="0x0">
          <comment>state of IRQ 11 generate requests of moving data
0: IRQ 11 does not generate requests of moving data
1: IRQ 11 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq10" pos="10" rst="0x0">
          <comment>state of IRQ 10 generate requests of moving data
0: IRQ 10 does not generate requests of moving data
1: IRQ 10 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq9" pos="9" rst="0x0">
          <comment>state of IRQ 9 generate requests of moving data
0: IRQ 9 does not generate requests of moving data
1: IRQ 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq8" pos="8" rst="0x0">
          <comment>state of IRQ 8 generate requests of moving data
0: IRQ 8 does not generate requests of moving data
1: IRQ 8 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq7" pos="7" rst="0x0">
          <comment>state of IRQ 7 generate requests of moving data
0: IRQ 7 does not generate requests of moving data
1: IRQ 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq6" pos="6" rst="0x0">
          <comment>state of IRQ 6 generate requests of moving data
0: IRQ 6 does not generate requests of moving data
1: IRQ 6 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq5" pos="5" rst="0x0">
          <comment>state of IRQ 5 generate requests of moving data
0: IRQ 5 does not generate requests of moving data
1: IRQ 5 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq4" pos="4" rst="0x0">
          <comment>state of IRQ 4 generate requests of moving data
0: IRQ 4 does not generate requests of moving data
1: IRQ 4 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq3" pos="3" rst="0x0">
          <comment>state of IRQ 3 generate requests of moving data
0: IRQ 3 does not generate requests of moving data
1: IRQ 3 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq2" pos="2" rst="0x0">
          <comment>state of IRQ 2 generate requests of moving data
0: IRQ 2 does not generate requests of moving data
1: IRQ 2 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq1" pos="1" rst="0x0">
          <comment>state of IRQ 1 generate requests of moving data
0: IRQ 1 does not generate requests of moving data
1: IRQ 1 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq0" pos="0" rst="0x0">
          <comment>state of IRQ 0 generate requests of moving data
0: IRQ 0 does not generate requests of moving data
1: IRQ 0 generate requests of moving data</comment>
        </bits>
      </reg>
      <reg name="axidma_arm_ack_stat" protect="rw">
        <bits access="r" name="ack23" pos="23" rst="0x0">
          <comment>state of ACK 23 generate requests of moving data
0: ACK 23 does not generate requests of moving data
1: ACK 23 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack22" pos="22" rst="0x0">
          <comment>state of ACK 22 generate requests of moving data
0: ACK 22 does not generate requests of moving data
1: ACK 22 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack21" pos="21" rst="0x0">
          <comment>state of ACK 21 generate requests of moving data
0: ACK 21 does not generate requests of moving data
1: ACK 21 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack20" pos="20" rst="0x0">
          <comment>state of ACK 20 generate requests of moving data
0: ACK 20 does not generate requests of moving data
1: ACK 20 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack19" pos="19" rst="0x0">
          <comment>state of ACK 19 generate requests of moving data
0: ACK 19 does not generate requests of moving data
1: ACK 19 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack18" pos="18" rst="0x0">
          <comment>state of ACK 18 generate requests of moving data
0: ACK 18 does not generate requests of moving data
1: ACK 18 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack17" pos="17" rst="0x0">
          <comment>state of ACK 17 generate requests of moving data
0: ACK 17 does not generate requests of moving data
1: ACK 17 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack16" pos="16" rst="0x0">
          <comment>state of ACK 16 generate requests of moving data
0: ACK 16 does not generate requests of moving data
1: ACK 16 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack15" pos="15" rst="0x0">
          <comment>state of ACK 15 generate requests of moving data
0: ACK 15 does not generate requests of moving data
1: ACK 15 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack14" pos="14" rst="0x0">
          <comment>state of ACK 14 generate requests of moving data
0: ACK 14 does not generate requests of moving data
1: ACK 14 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack13" pos="13" rst="0x0">
          <comment>state of ACK 13 generate requests of moving data
0: ACK 13 does not generate requests of moving data
1: ACK 13 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack12" pos="12" rst="0x0">
          <comment>state of ACK 12 generate requests of moving data
0: ACK 12 does not generate requests of moving data
1: ACK 12 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack11" pos="11" rst="0x0">
          <comment>state of ACK 11 generate requests of moving data
0: ACK 11 does not generate requests of moving data
1: ACK 11 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack10" pos="10" rst="0x0">
          <comment>state of ACK 10 generate requests of moving data
0: ACK 10 does not generate requests of moving data
1: ACK 10 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack9" pos="9" rst="0x0">
          <comment>state of ACK 9 generate requests of moving data
0: ACK 9 does not generate requests of moving data
1: ACK 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack8" pos="8" rst="0x0">
          <comment>state of ACK 8 generate requests of moving data
0: ACK 8 does not generate requests of moving data
1: ACK 8 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack7" pos="7" rst="0x0">
          <comment>state of ACK 7 generate requests of moving data
0: ACK 7 does not generate requests of moving data
1: ACK 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack6" pos="6" rst="0x0">
          <comment>state of ACK 6 generate requests of moving data
0: ACK 6 does not generate requests of moving data
1: ACK 6 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack5" pos="5" rst="0x0">
          <comment>state of ACK 5 generate requests of moving data
0: ACK 5 does not generate requests of moving data
1: ACK 5 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack4" pos="4" rst="0x0">
          <comment>state of ACK 4 generate requests of moving data
0: ACK 4 does not generate requests of moving data
1: ACK 4 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack3" pos="3" rst="0x0">
          <comment>state of ACK 3 generate requests of moving data
0: ACK 3 does not generate requests of moving data
1: ACK 3 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack2" pos="2" rst="0x0">
          <comment>state of ACK 2 generate requests of moving data
0: ACK 2 does not generate requests of moving data
1: ACK 2 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack1" pos="1" rst="0x0">
          <comment>state of ACK 1 generate requests of moving data
0: ACK 1 does not generate requests of moving data
1: ACK 1 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack0" pos="0" rst="0x0">
          <comment>state of ACK 0 generate requests of moving data
0: ACK 0 does not generate requests of moving data
1: ACK 0 generate requests of moving data</comment>
        </bits>
      </reg>
      <reg name="axidma_zsp_req_stat0" protect="rw">
        <bits access="rw" name="req7" pos="30:28" rst="0x0">
          <comment>REQ 7搬数请求状态
000：REQ 7未产生搬数请求
001：REQ 7产生1次搬数请求
……
111：REQ 7产生7次搬数请求</comment>
        </bits>
        <bits access="rw" name="req6" pos="26:24" rst="0x0">
          <comment>REQ 6搬数请求状态
000：REQ 6未产生搬数请求
001：REQ 6产生1次搬数请求
……
111：REQ 6产生7次搬数请求</comment>
        </bits>
        <bits access="rw" name="req5" pos="22:20" rst="0x0">
          <comment>REQ 5搬数请求状态
000：REQ 5未产生搬数请求
001：REQ 5产生1次搬数请求
……
111：REQ 5产生7次搬数请求</comment>
        </bits>
        <bits access="rw" name="req4" pos="18:16" rst="0x0">
          <comment>REQ 4搬数请求状态
000：REQ 4未产生搬数请求
001：REQ 4产生1次搬数请求
……
111：REQ 4产生7次搬数请求</comment>
        </bits>
        <bits access="rw" name="req3" pos="14:12" rst="0x0">
          <comment>REQ 3搬数请求状态
000：REQ 3未产生搬数请求
001：REQ 3产生1次搬数请求
……
111：REQ 3产生7次搬数请求</comment>
        </bits>
        <bits access="rw" name="req2" pos="10:8" rst="0x0">
          <comment>REQ 2搬数请求状态
000：REQ 2未产生搬数请求
001：REQ 2产生1次搬数请求
……
111：REQ 2产生7次搬数请求</comment>
        </bits>
        <bits access="rw" name="req1" pos="6:4" rst="0x0">
          <comment>REQ 1搬数请求状态
000：REQ 1未产生搬数请求
001：REQ 1产生1次搬数请求
……
111：REQ 1产生7次搬数请求</comment>
        </bits>
        <bits access="rw" name="req0" pos="2:0" rst="0x0">
          <comment>REQ 0搬数请求状态
000：REQ 0未产生搬数请求
001：REQ 0产生1次搬数请求
……
111：REQ 0产生7次搬数请求</comment>
        </bits>
      </reg>
      <reg name="axidma_zsp_req_stat1" protect="rw">
        <bits access="rw" name="req11" pos="14:12" rst="0x0">
          <comment>REQ 11搬数请求状态
000：REQ 11未产生搬数请求
001：REQ 11产生1次搬数请求
……
111：REQ 11产生7次搬数请求</comment>
        </bits>
        <bits access="rw" name="req10" pos="10:8" rst="0x0">
          <comment>REQ 10搬数请求状态
000：REQ 10未产生搬数请求
001：REQ 10产生1次搬数请求
……
111：REQ 10产生7次搬数请求</comment>
        </bits>
        <bits access="rw" name="req9" pos="6:4" rst="0x0">
          <comment>REQ 9搬数请求状态
000：REQ 9未产生搬数请求
001：REQ 9产生1次搬数请求
……
111：REQ 9产生7次搬数请求</comment>
        </bits>
        <bits access="rw" name="req8" pos="2:0" rst="0x0">
          <comment>REQ 0搬数请求状态
000：REQ 8未产生搬数请求
001：REQ 8产生1次搬数请求
……
111：REQ 8产生7次搬数请求</comment>
        </bits>
      </reg>
      <reg name="axidma_ch_irq_distr" protect="rw">
        <bits access="rw" name="ch11_irq_en0" pos="11" rst="0x0">
          <comment>channel 11 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch10_irq_en0" pos="10" rst="0x0">
          <comment>channel 10 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch9_irq_en0" pos="9" rst="0x0">
          <comment>channel 9 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch8_irq_en0" pos="8" rst="0x0">
          <comment>channel 8 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch7_irq_en0" pos="7" rst="0x0">
          <comment>channel 7 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch6_irq_en0" pos="6" rst="0x0">
          <comment>channel 6 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch5_irq_en0" pos="5" rst="0x0">
          <comment>channel 5 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch4_irq_en0" pos="4" rst="0x0">
          <comment>channel 4 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch3_irq_en0" pos="3" rst="0x0">
          <comment>channel 3 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch2_irq_en0" pos="2" rst="0x0">
          <comment>channel 2 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch1_irq_en0" pos="1" rst="0x0">
          <comment>channel 1 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch0_irq_en0" pos="0" rst="0x0">
          <comment>channel 0 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
      </reg>
      <hole size="224"/>
      <reg name="axidma_c0_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x0">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x0">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c0_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c0_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c0_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c1_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x1">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x1">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c1_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c1_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c1_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c2_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x2">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x2">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c2_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c2_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c2_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c3_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x3">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x3">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c3_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c3_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c3_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c4_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x4">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x4">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c4_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c4_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c4_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c5_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x5">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x5">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c5_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c5_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c5_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c6_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x6">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x6">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c6_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c6_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c6_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c7_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x7">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x7">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c7_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c7_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c7_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c8_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x8">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x8">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c8_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c8_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c8_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c9_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x9">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x9">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c9_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c9_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c9_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c10_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0xa">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0xa">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c10_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c10_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c10_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c11_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0：disable
1：enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0：security
1：unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0xb">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
……
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0xb">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
……
01111: IRQ15 trigger transmission
……
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c11_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c11_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0：unset
1：set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c11_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
……
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_set" protect="rw">
        <comment>AXIDMA 各通道运行位置位寄存器</comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_clr" protect="rw">
        <comment>AXIDMA 各通道运行位清除寄存器</comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x12040000" name="CP_AXIDMA" type="CP_AXIDMA"/>
  </archive>
  <archive relative="f8.xml">
    <module category="System" name="F8">
      <reg name="f8_up_conf" protect="rw">
        <comment>F8 模块上行配置寄存器</comment>
        <bits access="rw" name="f8_ar_sel" pos="4:2" rst="0x0">
          <comment>F8算法类型和只做搬数选择：
000：只搬数，不做加解密
001：AES加解密，并搬数
010：snow3G加解密，并搬数
011：zuc加解密，并搬数
100：Kasumi加解密，并搬数
101-111：Reversed</comment>
        </bits>
        <bits access="rw" name="f8_irq_en" pos="1" rst="0x0">
          <comment>F8算法中断使能位
0：F8 算法/搬数在整个多块group结束后，不产生中断；
1：F8 算法/搬数在整个多块group结束后，产生中断</comment>
        </bits>
        <bits access="rw" name="f8_start" pos="0" rst="0x0">
          <comment>F8算法启动控制位
0：不启动F8 算法，或完成后自动清零；
1：启动F8算法</comment>
        </bits>
      </reg>
      <reg name="f8_up_group_addr" protect="rw">
        <comment>F8上行group首地址寄存器</comment>
      </reg>
      <reg name="f8_up_group_cnt" protect="rw">
        <comment>F8上行group个数寄存器</comment>
      </reg>
      <reg name="f8_up_status" protect="rw">
        <comment>F8上行状态寄存器</comment>
        <bits access="rc" name="f8_up_stat" pos="0" rst="0x0">
          <comment>0：F8算法/搬数，未完成或未开始
1：F8算法/搬数，已完成</comment>
        </bits>
      </reg>
      <reg name="f8_dp_conf" protect="rw">
        <comment>F8 模块下行配置寄存器</comment>
        <bits access="rw" name="f8_ar_sel" pos="4:2" rst="0x0">
          <comment>F8算法类型和只做搬数选择：
000：只搬数，不做加解密
001：AES加解密，并搬数
010：snow3G加解密，并搬数
011：zuc加解密，并搬数
100：Kasumi加解密，并搬数
101-111：Reversed</comment>
        </bits>
        <bits access="rw" name="f8_irq_en" pos="1" rst="0x0">
          <comment>F8算法中断使能位
0：F8 算法/搬数在整个多块group结束后，不产生中断；
1：F8 算法/搬数在整个多块group结束后，产生中断</comment>
        </bits>
        <bits access="rw" name="f8_start" pos="0" rst="0x0">
          <comment>F8算法启动控制位
0：不启动F8 算法，或完成后自动清零；
1：启动F8算法</comment>
        </bits>
      </reg>
      <reg name="f8_dp_group_addr" protect="rw">
        <comment>F8下行group首地址寄存器</comment>
      </reg>
      <reg name="f8_dp_group_cnt" protect="rw">
        <comment>F8下行group个数寄存器</comment>
      </reg>
      <reg name="f8_dp_status" protect="rw">
        <comment>F8下行状态寄存器</comment>
        <bits access="rc" name="f8_dp_stat" pos="0" rst="0x0">
          <comment>0：F8算法/搬数，未完成或未开始
1：F8算法/搬数，已完成</comment>
        </bits>
      </reg>
      <reg name="f9_conf" protect="rw">
        <comment>F9配置寄存器</comment>
        <bits access="rw" name="w_cmd_cnt" pos="7:6" rst="0x1">
          <comment>AXI写outstanding能力设置,不能配置为2‘b11</comment>
        </bits>
        <bits access="rw" name="r_cmd_cnt" pos="5:4" rst="0x1">
          <comment>AXI读outstanding能力设置,不能配置为2‘b11</comment>
        </bits>
        <bits access="rw" name="f9_ar_sel" pos="3:2" rst="0x0">
          <comment>F9算法类型选择：
00：AES完整性算法
01：AES完整性算法
10：snow3G完整性算法
11：zuc完整性算法</comment>
        </bits>
        <bits access="rw" name="f9_irq_en" pos="1" rst="0x0">
          <comment>F9算法中断使能位
0：F9 算法/搬数在整个多块group结束后，不产生中断；
1：F9 算法/搬数在整个多块group结束后，产生中断</comment>
        </bits>
        <bits access="rw" name="f9_start" pos="0" rst="0x0">
          <comment>F9算法启动控制位
0：不启动F9 算法，或完成后自动清零；
1：启动F9算法</comment>
        </bits>
      </reg>
      <reg name="f9_group_addr" protect="rw">
        <comment>F9 group首地址寄存器</comment>
      </reg>
      <reg name="f9_status" protect="rw">
        <comment>F9状态寄存器</comment>
        <bits access="rc" name="f9_stat" pos="0" rst="0x0">
          <comment>0：F9未完成或未开始
1：F9已完成</comment>
        </bits>
      </reg>
      <reg name="f9_result" protect="rw">
        <comment>F9 结果寄存器</comment>
      </reg>
      <reg name="f8_cmd_conf" protect="rw">
        <comment>F8 信令配置寄存器</comment>
        <bits access="rw" name="f8_ar_sel" pos="4:2" rst="0x0">
          <comment>F8算法类型和只做搬数选择：
000：只搬数，不做加解密
001：AES加解密，并搬数
010：snow3G加解密，并搬数
011：zuc加解密，并搬数
100：Kasumi加解密，并搬数
101-111：Reversed</comment>
        </bits>
        <bits access="rw" name="f8_irq_en" pos="1" rst="0x0">
          <comment>F8算法中断使能位
0：F8 信令加解密单次group完成后，不产生中断；
1：F8 信令加解密单次group完成后，产生中断</comment>
        </bits>
        <bits access="rw" name="f8_start" pos="0" rst="0x0">
          <comment>F8算法启动控制位
0：不启动F8 算法，或完成后自动清零；
1：启动F8算法</comment>
        </bits>
      </reg>
      <reg name="f8_cmd_addr" protect="rw">
        <comment>F8信令group首地址寄存器</comment>
      </reg>
      <reg name="f8_cmd_status" protect="rw">
        <comment>F8信令状态寄存器</comment>
        <bits access="rc" name="f8_cmd_stat" pos="0" rst="0x0">
          <comment>0：F8信令未完成或未开始
1：F8信令已完成</comment>
        </bits>
      </reg>
      <reg name="status_sr" protect="rw">
        <comment>状态指示寄存器</comment>
        <bits access="rc" name="f9_status" pos="3" rst="0x0">
          <comment>0：F9信令未完成或未开始
1：F9信令已完成</comment>
        </bits>
        <bits access="rc" name="f8_cmd_status" pos="2" rst="0x0">
          <comment>0：F8信令未完成或未开始
1：F8信令已完成</comment>
        </bits>
        <bits access="rc" name="f8_up_status" pos="1" rst="0x0">
          <comment>0：F8上行未完成或未开始
1：F8上行已完成</comment>
        </bits>
        <bits access="rc" name="f8_dp_status" pos="0" rst="0x0">
          <comment>0：F8下行未完成或未开始
1：F8下行已完成</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x12000000" name="F8" type="F8"/>
  </archive>
  <archive relative="idle_timer.xml">
    <module category="System" name="IDLE_TIMER">
      <reg name="idl_ctrl_sys1" protect="rw">
        <comment>CP sleep enable register(Enable CP sleep when writing 0x49444c45 to this register, accessed by software only.)</comment>
        <bits access="rw" name="idct_ctrl_sys1" pos="0" rst="0x0">
          <comment>Enable CP sleep
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_ctrl_sys2" protect="rw">
        <comment>AP sleep enable register(Auto cleared by hardware after the system awakup)</comment>
        <bits access="rw" name="idct_ctrl_sys2" pos="0" rst="0x0">
          <comment>Enable AP sleep(Auto cleared to be 0 when the system is awaked)
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_en" protect="rw">
        <comment>System sleep enable register</comment>
        <bits access="rw" name="idl_ap_en" pos="1" rst="0x0">
          <comment>Enable AP sleep
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="idl_cp_en" pos="0" rst="0x0">
          <comment>Enable CP sleep
0:  disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_m_timer" protect="rw">
        <comment>Slssp counter wrap value.</comment>
      </reg>
      <reg name="idl_wcn_en" protect="rw">
        <comment>WCN lp enable register</comment>
        <bits access="rw" name="wcn_res_val" pos="4" rst="0x1">
          <comment>Default value when the enable bit was disabled.</comment>
        </bits>
        <bits access="rw" name="wcn_idle_cg" pos="3" rst="0x1">
          <comment>Enable bit of wcn idle_cg
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="wcn_pd_pll" pos="2" rst="0x1">
          <comment>Enable bit of wcn pd_pll
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="wcn_pd_xtal" pos="1" rst="0x1">
          <comment>Enable bit of wcn pd_xtal
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="wcn_chip_pd" pos="0" rst="0x1">
          <comment>Enable bit of wcn chip_pd
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_ctrl_timer" protect="rw">
        <comment>Timer sleep enable (writing 0x49444c45 to this register to enable timer sleep.)</comment>
        <bits access="rw" name="idct_ctrl_timer" pos="0" rst="0x0">
          <comment>Enable Timer sleep(Auto clear to be 0 when timer is awaked)
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_m2_sys" protect="rw">
        <comment>Sleep threshold register</comment>
        <bits access="rw" name="m1_sys" pos="31:16" rst="0x6">
          <comment>Threshold register M1:
when the signal pow_on_ack is low, both gsm and lte timer are sleeped, and the difference between current ref_32k counter
and sleep wrap value is larger than this register, system sleep state machine can shift to SLP state.</comment>
        </bits>
        <bits access="rw" name="m2_sys" pos="15:0" rst="0x8">
          <comment>Threshold register M2:
when idct_sys1 and idct_sys2 are set to be1, the difference between current ref_32k counter and sleep wrap value is larger than this register, system sleep state machine can shift to SLP_PRE state.</comment>
        </bits>
      </reg>
      <reg name="idl_tc_start" protect="rw">
        <comment>Take over TCU enable register</comment>
        <bits access="rw" name="tc_start_mod" pos="1:0" rst="0x0">
          <comment>Enable mode(TCU suspend and this bits are clear to be 0 when take over is started)
00: disbale or already release TCU.
01:  take over TCU immediately
10: take over at gsm frame interrupt.
11:  no effect.</comment>
        </bits>
      </reg>
      <reg name="idl_tc_end" protect="rw">
        <comment>Restart TCU register</comment>
        <bits access="rw" name="tc_end_framc" pos="20:4" rst="0x1">
          <comment>restart TCU when gsm counter reach this register</comment>
        </bits>
        <bits access="rw" name="tc_end_mod" pos="1:0" rst="0x0">
          <comment>restart mode(this bits clear to be 0 when TCU restarts)
00: disable
01: restart TCU immediately
10: restart TCU when gsm frame interrupt occurred.
11:  restart TCU when gsm framc equal to TC_END_FRAMC.</comment>
        </bits>
      </reg>
      <reg name="idl_awk_timer" protect="rw">
        <comment>TIMER wakeup register</comment>
        <bits access="rw" name="wake_timer" pos="0" rst="0x0">
          <comment>Timer wakeup enable(software accessed only)
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="gsm_lp_pu_done" protect="rw">
        <comment>Lp_pu_done register</comment>
        <bits access="rw" name="lp_pu_done" pos="0" rst="0x0">
          <comment>TCU restart enable(software accessed only)
Output to the port gsm_lp_pu_done directly, wakeup TCU in low power mode when writing 1 to this bit.</comment>
        </bits>
      </reg>
      <reg name="gsm_frame_inten" protect="rw">
        <comment>gsm frame interrupt enable set register</comment>
        <bits access="rw" name="gsm_frame_irq_en" pos="0" rst="0x0">
          <comment>gsm_frame_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="gsm_frame_int_sta" protect="rw">
        <comment>gsm frame interrupt state register</comment>
        <bits access="rw" name="gsm_frame_int_sta" pos="0" rst="0x0">
          <comment>cleared by writing 1 to correspond bit</comment>
        </bits>
      </reg>
      <reg name="ltem1_frame_inten" protect="rw">
        <comment>LTEM1 frame interrupt enable register</comment>
        <bits access="rw" name="ltem1_frame3_irq_en" pos="2" rst="0x0">
          <comment>ltem1_frame3_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem1_frame2_irq_en" pos="1" rst="0x0">
          <comment>ltem1_frame2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem1_frame1_irq_en" pos="0" rst="0x0">
          <comment>ltem1_frame1_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="ltem1_frame_int_sta" protect="rw">
        <comment>LTEM1 interrupt state register</comment>
        <bits access="rc" name="ltem1_frame_int_sta" pos="2:0" rst="0x0">
          <comment>cleared by writing 1 to correspond bit</comment>
        </bits>
      </reg>
      <reg name="ltem2_frame_inten" protect="rw">
        <comment>LTEM2 frame interrupt enable register</comment>
        <bits access="rw" name="ltem2_frame3_irq_en" pos="2" rst="0x0">
          <comment>ltem2_frame3_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem2_frame2_irq_en" pos="1" rst="0x0">
          <comment>ltem2_frame2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem2_frame1_irq_en" pos="0" rst="0x0">
          <comment>ltem2_frame1_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="ltem2_frame_int_sta" protect="rw">
        <comment>LTEM2 interrupt state register</comment>
        <bits access="rc" name="ltem2_frame_int_sta" pos="2:0" rst="0x0">
          <comment>cleared by writing 1 to correspond bit</comment>
        </bits>
      </reg>
      <reg name="idl_sta" protect="rw">
        <comment>IDLE state register</comment>
        <bits access="r" name="idle_ltem3_timer_stat" pos="6" rst="0x0">
          <comment>ltem3 timer state
0: running at 122.88M
1:  running at 32K</comment>
        </bits>
        <bits access="r" name="idle_nb_timer_stat" pos="5" rst="0x0">
          <comment>NB timer state
0: running at 61.44M
1:  running at 32K</comment>
        </bits>
        <bits access="r" name="h_stat" pos="4" rst="0x0">
          <comment>H circuit state
0:  not work
1:  at wok</comment>
        </bits>
        <bits access="r" name="idle_ltem2_timer_stat" pos="3" rst="0x0">
          <comment>ltem2 timer state
0: running at 122.88M
1:  running at 32K</comment>
        </bits>
        <bits access="r" name="idle_ltem1_timer_stat" pos="2" rst="0x0">
          <comment>ltem1 timer state
0: running at 122.88M
1:  running at 32K</comment>
        </bits>
        <bits access="r" name="idle_gsm_timer_stat" pos="1" rst="0x0">
          <comment>GSM timer state
0: running at 26M
1:  running at 32K</comment>
        </bits>
        <bits access="r" name="idle_sys_stat" pos="0" rst="0x0">
          <comment>SYS state
0:  normal working
1:  low power mode</comment>
        </bits>
      </reg>
      <reg name="idl_h_ctrl" protect="rw">
        <comment>H circuit control register</comment>
        <bits access="rw" name="h_run_time" pos="6:3" rst="0xf">
          <comment>Runtime of H circuit, the length is 2^h_run_time(number of 32k clocks)</comment>
        </bits>
        <bits access="rw" name="h_auto_en" pos="2" rst="0x0">
          <comment>Automatic computing mode enable(loop computing until disabled)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="h_ctrl_en" pos="1" rst="0x0">
          <comment>Invocation pattern(compute only one time, automatic clear to be 0 when finished.)
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_h_val" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x0">
          <comment>The length of sys clock in  2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_h_gsm" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x1f40000">
          <comment>The cycles number of 26M in 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_h_ltem" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x7800142">
          <comment>The cycles number of 122.88M in of 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_awk_en" protect="rw">
        <comment>wakeup enable register</comment>
        <bits access="rw" name="nb_lp_pu_reach_en" pos="20" rst="0x0">
          <comment>signal nb_lp_pu_reach wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gsm_lp_pu_reach_en" pos="19" rst="0x0">
          <comment>signal gsm_lp_pu_reach wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk_self_en" pos="18" rst="0x0">
          <comment>sofware wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk_osw2_en" pos="17" rst="0x0">
          <comment>OSW2 wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk_osw1_en" pos="16" rst="0x0">
          <comment>OSW1 wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk15_en" pos="15" rst="0x0">
          <comment>pad_gpio1 wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk14_en" pos="14" rst="0x0">
          <comment>uart3_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk13_en" pos="13" rst="0x0">
          <comment>pad_uart3_rxd wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk12_en" pos="12" rst="0x0">
          <comment>gpt2_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk11_en" pos="11" rst="0x0">
          <comment>mailbox_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk10_en" pos="10" rst="0x0">
          <comment>gpio2_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk9_en" pos="9" rst="0x0">
          <comment>uart2_irq wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="awk8_en" pos="8" rst="0x0">
          <comment>pad_uart2_rxd wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk7_en" pos="7" rst="0x0">
          <comment>pmic_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk6_en" pos="6" rst="0x0">
          <comment>usb_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk5_en" pos="5" rst="0x0">
          <comment>pad_uart1_rxd wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk4_en" pos="4" rst="0x0">
          <comment>Uart1_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk3_en" pos="3" rst="0x0">
          <comment>Gpio1_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk2_en" pos="2" rst="0x0">
          <comment>Keyboard wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk1_en" pos="1" rst="0x0">
          <comment>gpt1_irq wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="awk0_en" pos="0" rst="0x0">
          <comment>Pad_gpio6 wakeup enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="idl_awk_st" protect="rw">
        <comment>wakeup state(can be cleared by writing 1 to correspond bits)</comment>
        <bits access="r" name="pow_dfe_sta" pos="25" rst="0x1">
          <comment>pow_dfe_ack state
0: pow_dfe_ack is 0 when system exit IDLE
1:  pow_dfe_ack is 1 when system exit IDLE</comment>
        </bits>
        <bits access="rc" name="thr_sta" pos="24" rst="0x0">
          <comment>Threshold M1 state
1: pow_ack not meet threshold M1 or pow_ack not feedback in sleep period
0: meet threshold M1</comment>
        </bits>
        <bits access="rc" name="pow_sta" pos="23" rst="0x0">
          <comment>pow_ack state
0: pow_ack is 0 when system exit IDLE
1:  pow_ack is 1 when system exit IDLE</comment>
        </bits>
        <bits access="rc" name="idle_stat" pos="22" rst="0x0">
          <comment>system exit idle state
0: sys not enter idle
1: sys enter idle state</comment>
        </bits>
        <bits access="rc" name="awk_up_stat" pos="21" rst="0x0">
          <comment>IDLE sleep wakeup state
0: awaked before the sleep warp time
1: awaked at the sleep warp time</comment>
        </bits>
        <bits access="rc" name="nb_lp_pu_reach_stat" pos="20" rst="0x0">
          <comment>Signal nb_lp_pu_reach wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="gsm_lp_pu_reach_stat" pos="19" rst="0x0">
          <comment>Signal gsm_lp_pu_reach wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk_self_stat" pos="18" rst="0x0">
          <comment>software wakeup state
0: software wakeupup signal not generated
1: software wakeupup system.</comment>
        </bits>
        <bits access="rc" name="awk_osw2_stat" pos="17" rst="0x0">
          <comment>OSW2 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk_osw1_stat" pos="16" rst="0x0">
          <comment>OSW1 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk15_awk_stat" pos="15" rst="0x0">
          <comment>AWK15 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk14_awk_stat" pos="14" rst="0x0">
          <comment>AWK14 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk13_awk_stat" pos="13" rst="0x0">
          <comment>AWK13 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk12_awk_stat" pos="12" rst="0x0">
          <comment>AWK12 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk11_awk_stat" pos="11" rst="0x0">
          <comment>AWk11 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk10_awk_stat" pos="10" rst="0x0">
          <comment>AWk10 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk9_awk_stat" pos="9" rst="0x0">
          <comment>AWK9 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk8_awk_stat" pos="8" rst="0x0">
          <comment>AWK8 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk7_awk_stat" pos="7" rst="0x0">
          <comment>AWK7 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk6_awk_stat" pos="6" rst="0x0">
          <comment>AWK6 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk5_awk_stat" pos="5" rst="0x0">
          <comment>AWK5 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk4_awk_stat" pos="4" rst="0x0">
          <comment>AWK4 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk3_awk_stat" pos="3" rst="0x0">
          <comment>AWk3 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk2_awk_stat" pos="2" rst="0x0">
          <comment>AWk2 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk1_awk_stat" pos="1" rst="0x0">
          <comment>AWK1 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk0_awk_stat" pos="0" rst="0x0">
          <comment>AWK0 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
      </reg>
      <reg name="idl_awk_self" protect="rw">
        <comment>software wakeup signal</comment>
        <bits access="rw" name="wake_self" pos="0" rst="0x0">
          <comment>0: not effect
1:  wakeup system
(accessed by software only, this bit shold clear bu software when system is awaked.)</comment>
        </bits>
      </reg>
      <reg name="idl_osw1_en" protect="rw">
        <comment>OSW1 TIMER enable</comment>
        <bits access="rw" name="osw1_en" pos="31" rst="0x0">
          <comment>1:  enable
0: disable</comment>
        </bits>
        <bits access="rw" name="osw1_time" pos="30:0" rst="0x7fffffff">
          <comment>osw1 wrap value</comment>
        </bits>
      </reg>
      <reg name="idl_osw1_cont" protect="rw">
        <comment>OSW1 Timer current value</comment>
      </reg>
      <reg name="idl_fn_gsm" protect="rw">
        <comment>IDLE GSM frame register</comment>
      </reg>
      <reg name="idl_fn_ltem1" protect="rw">
        <comment>IDLE LTEM1frame register</comment>
        <bits access="r" name="idfn_rad_ltem" pos="31:4" rst="0x0">
          <comment>Number of frames ltem1 sleeped.</comment>
        </bits>
        <bits access="r" name="idfn_sub_ltem" pos="3:0" rst="0x0">
          <comment>Number of sub-frames ltem1 sleeped.</comment>
        </bits>
      </reg>
      <reg name="idl_fn_ltem2" protect="rw">
        <comment>IDLE LTEM2 frame register</comment>
        <bits access="r" name="idfn_rad_ltem" pos="31:4" rst="0x0">
          <comment>Number of frames ltem2 sleeped</comment>
        </bits>
        <bits access="r" name="idfn_sub_ltem" pos="3:0" rst="0x0">
          <comment>Number of sub-frames ltem2 sleeped.</comment>
        </bits>
      </reg>
      <reg name="idl_ltem_rfl" protect="rw">
        <comment>IDLE LTE frame length register</comment>
        <bits access="rw" name="ltem_idle_radioframe_parameter" pos="20:0" rst="0x12c000">
          <comment>LTE sleep frame length, suggest keep the default value.</comment>
        </bits>
      </reg>
      <reg name="idl_ltem_sfl" protect="rw">
        <comment>IDLE LTE sub-frame length register</comment>
        <bits access="rw" name="ltem_idle_frame_parameter" pos="16:0" rst="0x1e000">
          <comment>LTE sleep sub-frame length, suggest keep
the default value.</comment>
        </bits>
      </reg>
      <reg name="idl_sig_en" protect="rw">
        <comment>signal of low power related enable register</comment>
        <bits access="rw" name="idle_cg_en" pos="3" rst="0x1">
          <comment>Idle_cg_en enable
1: enable.
0: disable.</comment>
        </bits>
        <bits access="rw" name="pd_pll_en" pos="2" rst="0x1">
          <comment>Pd_pll_en enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="pd_xtal_en" pos="1" rst="0x1">
          <comment>pd_xtal_en enable
1: enable.
0: disable.</comment>
        </bits>
        <bits access="rw" name="chip_pd_en" pos="0" rst="0x1">
          <comment>chip_pd_en enable
1:  enable.
0: disable.</comment>
        </bits>
      </reg>
      <reg name="idl_sig_timer" protect="rw">
        <comment>low power related time control register</comment>
        <bits access="rw" name="t4" pos="31:24" rst="0x1">
          <comment>The time from enable clock to obtain clock</comment>
        </bits>
        <bits access="rw" name="t3" pos="23:16" rst="0xa">
          <comment>The time of PLL from power saving state to output normal clock.</comment>
        </bits>
        <bits access="rw" name="t2" pos="15:8" rst="0xa0">
          <comment>The time of OSC circuit from power saving
state to normal state.</comment>
        </bits>
        <bits access="rw" name="t1" pos="7:0" rst="0x1">
          <comment>The time of PMIC boost stabilization.</comment>
        </bits>
      </reg>
      <reg name="idl_32k_ref" protect="rw">
        <comment>32K reference counter</comment>
      </reg>
      <reg name="idl_cp_inten" protect="rw">
        <comment>cp interrupt enable register</comment>
        <bits access="rw" name="cp_em_latch_irq" pos="18" rst="0x0">
          <comment>em_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_cpu_latch_irq" pos="17" rst="0x0">
          <comment>cpu_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_rtc_latch_irq" pos="16" rst="0x0">
          <comment>rtc_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_load_end_irq" pos="15" rst="0x0">
          <comment>load_end_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_timer_idle_irq" pos="14" rst="0x0">
          <comment>timer_idle_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_target_irq" pos="13" rst="0x0">
          <comment>target_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_nb_pu_reach_irq" pos="12" rst="0x0">
          <comment>nb_pu_reach_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="nb_tc_end_irq" pos="11" rst="0x0">
          <comment>nb_tc_end_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="nb_tc_start_irq" pos="10" rst="0x0">
          <comment>nb_tc_start_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="sys_wak_irq" pos="9" rst="0x0">
          <comment>sys_awk _irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_timer_awk_irq" pos="8" rst="0x0">
          <comment>Timer_awk_irq_enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_gsm_pu_reach_irq" pos="7" rst="0x0">
          <comment>gsm_pu_reach_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="gsm_tc_end_irq" pos="6" rst="0x0">
          <comment>gsm_tc_end_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="gsm_tc_start_irq" pos="5" rst="0x0">
          <comment>gsm_tc_start_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="osw1_irq" pos="4" rst="0x0">
          <comment>osw1_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="idl_tstamp_irq" pos="3" rst="0x0">
          <comment>tstamp_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="idle_frame_irq" pos="2" rst="0x0">
          <comment>idle_frame_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="idle_h_irq" pos="1" rst="0x1">
          <comment>idle_h_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="layout_irq" pos="0" rst="0x0">
          <comment>layout_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="idl_cp_inten_set" protect="rw">
        <comment>cp interrupt enable set register</comment>
        <bits access="rs" name="idl_cp_int_en_set" pos="18:0" rst="0x0">
          <comment>set  cp interrupt enable register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_cp_inten_clr" protect="rw">
        <comment>cp interrupt enable clear register</comment>
        <bits access="rc" name="idl_cp_int_en_clr" pos="18:0" rst="0x0">
          <comment>clear  cp interrupt enable register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_cp_int_sta" protect="rw">
        <comment>cp interrupt state</comment>
        <bits access="rc" name="idl_cp_int_sta" pos="18:0" rst="0x0">
          <comment>clear interrupt state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_ap_inten" protect="rw">
        <comment>ap interrupt enable register</comment>
        <bits access="rw" name="ap_em_latch_irq" pos="10" rst="0x0">
          <comment>em_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_cpu_latch_irq" pos="9" rst="0x0">
          <comment>cpu_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_rtc_latch_irq" pos="8" rst="0x0">
          <comment>rtc_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_load_end_irq" pos="7" rst="0x0">
          <comment>load_end_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_timer_idle_irq" pos="6" rst="0x0">
          <comment>timer_idle_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_target_irq" pos="5" rst="0x0">
          <comment>target_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_nb_pu_reach_irq" pos="4" rst="0x0">
          <comment>nb_pu_reach_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="sys_wak_irq" pos="3" rst="0x0">
          <comment>sys_awk _irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_timer_awk_irq" pos="2" rst="0x0">
          <comment>Timer_awk_irq_enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_gsm_pu_reach_irq" pos="1" rst="0x0">
          <comment>gsm_pu_reach_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="osw2_irq" pos="0" rst="0x0">
          <comment>osw2_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="idl_ap_inten_set" protect="rw">
        <comment>ap interrupt enable set register</comment>
        <bits access="rs" name="idl_ap_int_en_set" pos="10:0" rst="0x0">
          <comment>set  ap interrupt enable register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_ap_inten_clr" protect="rw">
        <comment>ap interrupt enable clear register</comment>
        <bits access="rc" name="idl_ap_int_en_clr" pos="10:0" rst="0x0">
          <comment>clear  ap interrupt enable register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_ap_int_sta" protect="rw">
        <comment>ap interrupt state</comment>
        <bits access="rc" name="idl_ap_int_sta" pos="10:0" rst="0x0">
          <comment>clear ap interrupt state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_hfn" protect="rw">
        <comment>LTEM1 high-level frame number register</comment>
        <bits access="rw" name="ltem1_cfsr_hfn" pos="21:0" rst="0x0">
          <comment>Ltem1 high-level frame number value</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_fn" protect="rw">
        <bits access="rw" name="ltem1_cfsr_rad" pos="13:4" rst="0x0">
          <comment>LTE-M1 frame number</comment>
        </bits>
        <bits access="rw" name="ltem1_cfsr_sub" pos="3:0" rst="0x0">
          <comment>LTE-M1 sub-frame number</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsrs" protect="rw">
        <comment>LTE-M1 frame offset register</comment>
        <bits access="rw" name="active_time1_cfsr" pos="25" rst="0x0">
          <comment>frame adjust time
0: adjust at next frame interrupt
1: adjust frame immetiately</comment>
        </bits>
        <bits access="rw" name="adjust_direct1_cfsr" pos="24" rst="0x0">
          <comment>frame adjust direction
0: postive
1: negative</comment>
        </bits>
        <bits access="rw" name="ltem1_cfsrs" pos="23:0" rst="0x0">
          <comment>LTE-M1 frame offest value
(Adjust frame offset B, there are two case: if adjust direction is 0, write b+1 to this register then current frame plus this value when frame interrupt occurred. otherwise write b-1 into this register then current frame minus this value when frame interrupt occurred.)</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_rdh" protect="rw">
        <comment>LTE-M1 high-level frame read register</comment>
        <bits access="r" name="ltem1_cfsr_rdh" pos="21:0" rst="0x0">
          <comment>LTE-M1 high-level frame value</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_rdl" protect="rw">
        <comment>LTE-M1 frame read register</comment>
        <bits access="r" name="ltem1_cfsr_rdl_rad" pos="13:4" rst="0x0">
          <comment>LTE-M1 radio frame value</comment>
        </bits>
        <bits access="r" name="ltem1_cfsr_rdl_sub" pos="3:0" rst="0x0">
          <comment>LTE-M1 sub-frame value</comment>
        </bits>
      </reg>
      <reg name="ltem1_framc" protect="rw">
        <comment>LTE-M1 counter</comment>
        <bits access="r" name="ltem1_framc" pos="15:0" rst="0x1">
          <comment>LTE-M1 counter value</comment>
        </bits>
      </reg>
      <reg name="ltem1_framl" protect="rw">
        <comment>LTE-M1 frame length register</comment>
        <bits access="rw" name="ltem1_framl" pos="15:0" rst="0x7800">
          <comment>LTE-M1 frame length</comment>
        </bits>
      </reg>
      <reg name="ltem1_framls" protect="rw">
        <comment>LTE-M1 frame length adjust register</comment>
        <bits access="rw" name="active_time1_framls" pos="16" rst="0x0">
          <comment>adjust time
0: adjust immetiately
1:  adjust at next ltem frame interrupt</comment>
        </bits>
        <bits access="rw" name="ltem1_framls" pos="15:0" rst="0x0">
          <comment>LTE-M1 adjuste frame length.
current Ltem frame length load the register when write happens,then return the LFRAML at the time of lte frame interrupt arrivals.</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_tph" protect="rw">
        <comment>LTE-M1 radio frame value time stamp register</comment>
        <bits access="rw" name="ltem1_cfsr_tph" pos="21:0" rst="0x0">
          <comment>LTE-M1 high-level frame value time stamp register</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_tpl" protect="rw">
        <comment>LTE-M1 sub-frame time stamp register</comment>
        <bits access="rw" name="ltem1_cfsr_tpl" pos="13:0" rst="0x0">
          <comment>LTE-M1 frame stamp value</comment>
        </bits>
      </reg>
      <reg name="ltem1_framc_tp" protect="rw">
        <comment>LTE-M1 counter time stamp register</comment>
        <bits access="rw" name="ltem1_framc_tp" pos="15:0" rst="0x1">
          <comment>LTE-M1 stamp counter</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_hfn" protect="rw">
        <comment>LTE-M2 high-level frame register</comment>
        <bits access="rw" name="ltem2_cfsr_hfn" pos="21:0" rst="0x0">
          <comment>LTE-M2 high-level frame value</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_fn" protect="rw">
        <bits access="rw" name="ltem2_cfsr_rad" pos="13:4" rst="0x0">
          <comment>LTE-M2 radio frame value</comment>
        </bits>
        <bits access="rw" name="ltem2_cfsr_sub" pos="3:0" rst="0x0">
          <comment>LTE-M2 sub-frame value</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsrs" protect="rw">
        <comment>LTE-M2 frame offset adjust register</comment>
        <bits access="rw" name="active_time2_cfsr" pos="25" rst="0x0">
          <comment>adjust time.
0: adjust at next frame interrupt
1: adjust frame immetiately</comment>
        </bits>
        <bits access="rw" name="adjust_direct2_cfsr" pos="24" rst="0x0">
          <comment>adjust direction
0: postive
1: negative</comment>
        </bits>
        <bits access="rw" name="ltem2_cfsrs" pos="23:0" rst="0x0">
          <comment>Frame offest value(Adjust frame offset B, there are two case: if adjust direction is 0, write b+1 to this register then current frame plus this value at the time of frame interrupt genereted. otherwise write b-1 into this register then current frame minus this value at the time of frame interrupt generated.)</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_rdh" protect="rw">
        <comment>LTE-M2 high-level frame read register</comment>
        <bits access="r" name="ltem2_cfsr_rdh" pos="21:0" rst="0x0">
          <comment>LTE-M2 super read frame value</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_rdl" protect="rw">
        <comment>LTE-M2 frame read register</comment>
        <bits access="r" name="ltem2_cfsr_rdl_rad" pos="13:4" rst="0x0">
          <comment>LTE-M2 radio frame read value</comment>
        </bits>
        <bits access="r" name="ltem2_cfsr_rdl_sub" pos="3:0" rst="0x0">
          <comment>LTE-M2 sub-frame read value</comment>
        </bits>
      </reg>
      <reg name="ltem2_framc" protect="rw">
        <comment>LTE-M counter</comment>
        <bits access="r" name="ltem2_lframc" pos="15:0" rst="0x1">
          <comment>LTE-M counter</comment>
        </bits>
      </reg>
      <reg name="ltem2_framl" protect="rw">
        <comment>LTE-M2 frame length</comment>
        <bits access="rw" name="ltem2_lframl" pos="15:0" rst="0x7800">
          <comment>LTE-M2 frame length value</comment>
        </bits>
      </reg>
      <reg name="ltem2_framls" protect="rw">
        <comment>LTE-M2 frame length adjust register</comment>
        <bits access="rw" name="active_time2_framls" pos="16" rst="0x0">
          <comment>adjust time
0: adjust immetiately
1:  adjust at next ltem frame interrupt</comment>
        </bits>
        <bits access="rw" name="ltem2_framls" pos="15:0" rst="0x0">
          <comment>LTE-M2 adjuste frame length.
current Ltem frame length load the register when write happens,then backed the LFRAML at the time of lte frame interrupt occurred.</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_tph" protect="rw">
        <comment>LTE-M2 radio frame time stamp register</comment>
        <bits access="rw" name="ltem2_cfsr_tph" pos="21:0" rst="0x0">
          <comment>LTE-M2 high-level frame time stamp register</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_tpl" protect="rw">
        <comment>LTE-M2 sub-frame time stamp register</comment>
        <bits access="rw" name="ltem2_cfsr_tpl" pos="13:0" rst="0x0">
          <comment>LTE-M2 frame stamp value</comment>
        </bits>
      </reg>
      <reg name="ltem2_framc_tp" protect="rw">
        <comment>LTE-M2 counter time stamp register</comment>
        <bits access="rw" name="ltem2_framc_tp" pos="15:0" rst="0x1">
          <comment>LTE-M2 stamp counter</comment>
        </bits>
      </reg>
      <reg name="gsm_cfsr" protect="rw">
        <comment>GSM frame register</comment>
        <bits access="rw" name="gsm_cfsr" pos="23:0" rst="0x0">
          <comment>GSM frame value</comment>
        </bits>
      </reg>
      <reg name="gsm_cfsrs" protect="rw">
        <comment>GSM frame offset adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="24" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="gsm_cfsrs" pos="23:0" rst="0x0">
          <comment>frame offest value
(Adjust frame offset B. there are two case: if adjust direction is 0, write b+1 into this register then current frame plus this value when frame interrupt occurred. otherwise write b-1 into this register then current frame minus this value when frame interrupt occurred.)</comment>
        </bits>
      </reg>
      <reg name="gsm_cfsro" protect="rw">
        <comment>GSM frame overflow register</comment>
        <bits access="rw" name="gsm_cfsr_overflow" pos="23:0" rst="0x297000">
          <comment>GSM frame overflow value</comment>
        </bits>
      </reg>
      <reg name="ltem1_fhl" protect="rw">
        <comment>LTE-M high-level frame locked register</comment>
        <bits access="r" name="ltem_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="ltem1_fll" protect="rw">
        <comment>LTE-M frame locked register</comment>
        <bits access="r" name="ltem_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="ltem1_fcl" protect="rw">
        <comment>LTE-M counter locked register</comment>
        <bits access="r" name="ltem_fcl" pos="15:0" rst="0x1">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="ltem2_fhl" protect="rw">
        <comment>LTE-M high-level frame lock register</comment>
        <bits access="r" name="ltem_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="ltem2_fll" protect="rw">
        <comment>LTE-M frame locked register</comment>
        <bits access="r" name="ltem_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="ltem2_fcl" protect="rw">
        <comment>LTE-M counter locked register</comment>
        <bits access="r" name="ltem_fcl" pos="15:0" rst="0x1">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gsm_fl" protect="rw">
        <comment>GSM frame lock register</comment>
        <bits access="r" name="fl" pos="23:0" rst="0x0">
          <comment>GSM frame locked value</comment>
        </bits>
      </reg>
      <reg name="gsm_fcl" protect="rw">
        <comment>GSM counter lock register</comment>
        <bits access="r" name="gsm_fcl" pos="16:0" rst="0x1">
          <comment>GSM counter locked value</comment>
        </bits>
      </reg>
      <reg name="idl_tpctrl" protect="rw">
        <comment>time stamp register</comment>
        <bits access="rw" name="idle_mod_sel" pos="10:8" rst="0x0">
          <comment>lock signal
000: ltem1 frame interrupt.
001: ltem2 frame interrupt.
010: gsm frame interrupt.
011: negative of 32k clock.
100: nb frame interrput.
others: gsm frame interrupt.</comment>
        </bits>
        <bits access="rw" name="idle_inner_confg" pos="5:4" rst="0x0">
          <comment>lock way
00: disable lock
01: bit 0 control the time stamp, bit 0 auto clear to be 0 after time stamp finsihed.
10: time stamp when lock signal comes after that bit 5 and 4 clear to be 0.
11: time stamp loop</comment>
        </bits>
        <bits access="rw" name="idle_inner_ctrl" pos="0" rst="0x0">
          <comment>1: time stamp immediately.
0: not effect</comment>
        </bits>
      </reg>
      <reg name="layoutt" protect="rw">
        <comment>current task planning time register</comment>
      </reg>
      <reg name="layoutctrl" protect="rw">
        <comment>task planning time register</comment>
        <bits access="rw" name="chip_count" pos="22:8" rst="0x0">
          <comment>Layoutt register descending unit.
15’h0000: 1
15’h0001:  2
15’h0002: 3
……
15’h7fff: 32768</comment>
        </bits>
        <bits access="rw" name="timer_select" pos="1" rst="0x0">
          <comment>Layout count time selection
0: ltem1 timer
1: ltem2 timer</comment>
        </bits>
        <bits access="rw" name="enable" pos="0" rst="0x0">
          <comment>task planning
1:  start task planing
0: end timing
(The control bit is clear automatically after the timer is finished, and the software can be clear to bestop counting.)</comment>
        </bits>
      </reg>
      <reg name="ltem1_fint_dly1" protect="rw">
        <comment>LTEM1 frame interrupt delay register 1</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M1 frame interrupt delay, take ltem1_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem1_fint_dly2" protect="rw">
        <comment>LTEM1 frame interrupt delay register 2</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M1 frame interrupt delay, take ltem1_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem2_fint_dly1" protect="rw">
        <comment>LTEM2 frame interrupt delay register 1</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M2 frame interrupt delay, take ltem2_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem2_fint_dly2" protect="rw">
        <comment>LTEM2 frame interrupt delay register 2</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M2 frame interrupt delay, take ltem2_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem1_fint_en" protect="rw">
        <comment>sub-frame interrupt enable register</comment>
        <bits access="rw" name="lte_m1_fint_enable" pos="9:0" rst="0x3ff">
          <comment>Each bit corresponds to 10 sub-frame, sub-frame interrupt will be sent to CPU when correspond bit is enabled.</comment>
        </bits>
      </reg>
      <reg name="timer_en" protect="rw">
        <comment>TIMER enable register</comment>
        <bits access="rw" name="gnss_ltem_timer_enable" pos="5" rst="0x0">
          <comment>GNSS_LTE-M timer enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="nb_timer_enable" pos="4" rst="0x0">
          <comment>NB timer enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ltem_timer_enable" pos="3" rst="0x0">
          <comment>LTE-M timer enable
0: disable
1: enable
(note: this timer is the reference lte timer.)</comment>
        </bits>
        <bits access="rw" name="gsm_timer_enable" pos="2" rst="0x0">
          <comment>GSM timer enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="lte_m2_timer_enable" pos="1" rst="0x0">
          <comment>LTE-M2 timer enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="lte_m1_timer_enable" pos="0" rst="0x1">
          <comment>LTE-M1 timer enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="idle_frame_sta" protect="rw">
        <comment>IDLE frame interrupt state register(can be clear by writing 1 to correspond bit)</comment>
        <bits access="rc" name="gnss_lte_m_frame_state" pos="5" rst="0x0">
          <comment>GNSS_LTE-M frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
        <bits access="rc" name="nb_frame_state" pos="4" rst="0x0">
          <comment>NB frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
        <bits access="rc" name="lte_m_frame_state" pos="3" rst="0x0">
          <comment>reference lte frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
        <bits access="rc" name="gsm_frame_state" pos="2" rst="0x0">
          <comment>GSM frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
        <bits access="rc" name="lte_m2_frame_state" pos="1" rst="0x0">
          <comment>LTE-M2 frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
        <bits access="rc" name="lte_m1_frame_state" pos="0" rst="0x0">
          <comment>LTE-M1 frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
      </reg>
      <reg name="idle_frame_ltem1" protect="rw">
        <comment>IDLE LTE-M1 frame configuration register</comment>
        <bits access="rw" name="frame_conf" pos="24" rst="0x0">
          <comment>enable(this bit cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="frame_cfsr" pos="21:0" rst="0x0">
          <comment>interrupt frame number
interrupt occurred when current frame reach this register.</comment>
        </bits>
      </reg>
      <reg name="idle_frame_ltem2" protect="rw">
        <comment>IDLE LTE-M2 frame configuration register</comment>
        <bits access="rw" name="frame_conf" pos="24" rst="0x0">
          <comment>enable(this bit is cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="frame_cfsr" pos="21:0" rst="0x0">
          <comment>interrupt occurred when current frame reach this register.</comment>
        </bits>
      </reg>
      <reg name="idle_frame_gsm" protect="rw">
        <comment>IDLE GSM frame configuration register</comment>
        <bits access="rw" name="frame_conf" pos="24" rst="0x0">
          <comment>enable(this bit cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="frame_cfsr" pos="23:0" rst="0x0">
          <comment>interrupt occurred when current frame reach this register and counter equal to IDLE_FRAMC_GSM</comment>
        </bits>
      </reg>
      <reg name="idle_frame_lte" protect="rw">
        <comment>IDLE REF_LTE frame configuration register</comment>
      </reg>
      <reg name="idle_frame_lte_conf" protect="rw">
        <comment>IDLE REF LTE frame enable register</comment>
        <bits access="r" name="resrved" pos="31:1" rst="0x0"/>
        <bits access="rw" name="frame_ref_lte_conf" pos="0" rst="0x0">
          <comment>enable(this bit cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="ltem_ref_fn" protect="rw">
        <comment>REF_LTE frame register</comment>
      </reg>
      <reg name="ltem_ref_fnl" protect="rw">
        <comment>REF_LTE frame locked register</comment>
      </reg>
      <reg name="ltem_ref_fcl" protect="rw">
        <comment>REF_LTE counter locked register</comment>
        <bits access="r" name="ref_ltem_fcl" pos="14:0" rst="0x1">
          <comment>reference lte counter locked value</comment>
        </bits>
      </reg>
      <reg name="ref_32k_fnl" protect="rw">
        <comment>REF_32K CONT clocked register</comment>
      </reg>
      <reg name="ltem_ref_fc" protect="rw">
        <comment>REF_LTE counter register</comment>
        <bits access="r" name="ltem_ref_fc" pos="14:0" rst="0x1">
          <comment>reference lte counter</comment>
        </bits>
      </reg>
      <reg name="gsm_framl" protect="rw">
        <comment>GSM frame length</comment>
        <bits access="rw" name="gsm_framl" pos="16:0" rst="0x1d4c0">
          <comment>GSM frame length value</comment>
        </bits>
      </reg>
      <reg name="idl_osw2_en" protect="rw">
        <comment>OSW2 configuration register</comment>
        <bits access="rw" name="osw2_en" pos="31" rst="0x0">
          <comment>1: enable OSW2 timer
0: disable</comment>
        </bits>
        <bits access="rw" name="osw2_time" pos="30:0" rst="0x7fffffff">
          <comment>OSW2 Timing start value</comment>
        </bits>
      </reg>
      <reg name="idl_osw2_cont" protect="rw">
        <comment>OSW2 counter register</comment>
      </reg>
      <reg name="idle_framc_gsm" protect="rw">
        <comment>IDLE GSM frame interrupt counter setting register</comment>
        <bits access="rw" name="framc_cfsr" pos="16:0" rst="0x1">
          <comment>IDLE GSM frame interrupt generated when GSM frame counter reach GSM_FRAME_GSM and GSM counter equal to this register.</comment>
        </bits>
      </reg>
      <reg name="ltem1_fint_dly3" protect="rw">
        <comment>LTEM1 interrupt delay setting register 3</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M1 frame interrupt delay,
take ltem1_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem2_fint_dly3" protect="rw">
        <comment>LTEM2 interrupt delay setting register 3</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M2 frame interrupt delay, take ltem2_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="idle_time_sel" protect="rw">
        <comment>idle time select register</comment>
        <bits access="rw" name="time_sel" pos="0" rst="0x0">
          <comment>1: select pd_xtal, 0: select chip_pd</comment>
        </bits>
      </reg>
      <reg name="idle_time" protect="rw">
        <comment>IDLE time register</comment>
      </reg>
      <reg name="idl_h_gsm_lp" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x1f40000">
          <comment>The cycles number of 26M in 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_h_ltem_lp" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x7800142">
          <comment>The cycles number of 122.88M in of 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_tc_start_nb" protect="rw">
        <comment>Take over NB TCU enable register</comment>
        <bits access="rw" name="tc_start_mod" pos="1:0" rst="0x0">
          <comment>Enable mode(NB TCU suspend and this bits are cleared by hardware when take over started)
00: disbale or already release TCU.
01:  take over TCU immediately
10: take over at gsm frame interrupt.
11:  no effect.</comment>
        </bits>
      </reg>
      <reg name="idl_tc_end_nb" protect="rw">
        <comment>Restart NB TCU register</comment>
        <bits access="rw" name="tc_end_framc" pos="20:4" rst="0x1">
          <comment>restart TCU when gsm counter reach this register</comment>
        </bits>
        <bits access="rw" name="tc_end_mod" pos="1:0" rst="0x0">
          <comment>restart mode(this bits cleared when TCU restarts)
00: disable
01: restart TCU immediately
10: restart TCU when gsm frame interrupt occurred.
11:  restart TCU when gsm framc equal to TC_END_FRAMC.</comment>
        </bits>
      </reg>
      <reg name="nb_lp_pu_done" protect="rw">
        <comment>Nb_lp_pu_done register</comment>
        <bits access="rw" name="lp_pu_done" pos="0" rst="0x0">
          <comment>TCU restart enable(accessed by software only.)
Output to the port nb_lp_pu_done directly, wakeup TCU in low power mode when writing 1 to this bit.</comment>
        </bits>
      </reg>
      <reg name="idl_h_nb" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x3c000a1">
          <comment>The cycles number of 61.44M in the length of 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_h_nb_lp" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x3c000a1">
          <comment>The cycles number of 61.44M in the length of 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_fn_nb" protect="rw">
        <comment>IDLE NB frame register</comment>
      </reg>
      <reg name="nb_frame_inten" protect="rw">
        <comment>NB frame interrupt enable register</comment>
        <bits access="rw" name="nb_frame_irq_en" pos="0" rst="0x0">
          <comment>nb_frame_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="nb_frame_int_sta" protect="rw">
        <comment>NB frame interrupt state register</comment>
        <bits access="rw" name="gsm_frame_int_sta" pos="0" rst="0x0">
          <comment>cleared by writing 1 to correspond bit</comment>
        </bits>
      </reg>
      <reg name="nb_cfsr" protect="rw">
        <comment>NB frame register</comment>
        <bits access="rw" name="gsm_cfsr" pos="23:0" rst="0x0">
          <comment>NB frame value</comment>
        </bits>
      </reg>
      <reg name="nb_framl" protect="rw">
        <comment>NB frame length</comment>
        <bits access="rw" name="nb_framl" pos="16:0" rst="0xf000">
          <comment>NB frame length value</comment>
        </bits>
      </reg>
      <reg name="nb_cfsrs" protect="rw">
        <comment>NB frame offset adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="24" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="nb_cfsrs" pos="23:0" rst="0x0">
          <comment>frame offest value
(Adjust frame offset B. there are two case: if adjust direction is 0, write b+1 to this register then current frame plus this value when frame interrupt occurred. otherwise write b- 1 to this register then current frame minus this value when frame interrupt occurred.)</comment>
        </bits>
      </reg>
      <reg name="nb_cfsro" protect="rw">
        <comment>NB frame overflow register</comment>
        <bits access="rw" name="nb_cfsr_overflow" pos="23:0" rst="0xffffff">
          <comment>NB frame overflow value</comment>
        </bits>
      </reg>
      <reg name="nb_fl" protect="rw">
        <comment>NB frame lock register</comment>
        <bits access="r" name="fl" pos="23:0" rst="0x0">
          <comment>NB frame locked value</comment>
        </bits>
      </reg>
      <reg name="nb_fcl" protect="rw">
        <comment>NB counter lock register</comment>
        <bits access="r" name="nb_fcl" pos="16:0" rst="0x1">
          <comment>NB counter locked value</comment>
        </bits>
      </reg>
      <reg name="idle_frame_nb" protect="rw">
        <comment>IDLE NB frame configuration register</comment>
        <bits access="rw" name="frame_conf" pos="24" rst="0x0">
          <comment>enable(this bit cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="frame_cfsr" pos="23:0" rst="0x0">
          <comment>interrupt occurred when current frame reach this register and counter equal to IDLE_FRAMC_NB</comment>
        </bits>
      </reg>
      <reg name="idle_framc_nb" protect="rw">
        <comment>IDLE NB frame interrupt counter setting register</comment>
        <bits access="rw" name="framc_cfsr" pos="16:0" rst="0x1">
          <comment>IDLE NB frame interrupt generated when NB frame counter reach IDLE_FRAME_NB and NB counter equal to this register.</comment>
        </bits>
      </reg>
      <reg name="idl_awk_en_set" protect="rw">
        <comment>wakeup enable set register</comment>
        <bits access="rs" name="awk_en_set" pos="20:0" rst="0x0">
          <comment>set wakeup enable register  by writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_awk_en_clr" protect="rw">
        <comment>wakeup enable clear register</comment>
        <bits access="rc" name="awk_en_clear" pos="20:0" rst="0x0">
          <comment>clear wakeup enable register  by writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="gsm_framc" protect="rw">
        <comment>GSM framc read  register</comment>
        <bits access="rw" name="rd_enable" pos="20" rst="0x0">
          <comment>Read enable register.
This bit should be set first when read the value of GSM counter, then rd_enable bit cleared by hardware after locked the GSM counter.</comment>
        </bits>
        <bits access="r" name="framc" pos="16:0" rst="0x1">
          <comment>GSM framc</comment>
        </bits>
      </reg>
      <reg name="nb_framc" protect="rw">
        <comment>NB framc read  register</comment>
        <bits access="rw" name="rd_enable" pos="20" rst="0x0">
          <comment>Read enable register.
This bit should be set first when read the value of NB counter, then rd_enable bit cleared by hardware after locked the NB counter.</comment>
        </bits>
        <bits access="r" name="framc" pos="16:0" rst="0x1">
          <comment>NB framc</comment>
        </bits>
      </reg>
      <reg name="eliminat_jitter" protect="rw">
        <comment>Eliminate jitter configuration register</comment>
        <bits access="rw" name="eliminat_time" pos="23:16" rst="0x1">
          <comment>Eliminate jitter delay register</comment>
        </bits>
        <bits access="rw" name="elimiate_en" pos="15:0" rst="0x0">
          <comment>Emilinate the jitter from awake signal when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="gsm_en_sel" protect="rw">
        <bits access="rw" name="select" pos="0" rst="0x0">
          <comment>GGE low power Scheme selection signal
0: use RDA8909 LP  Scheme
1: use IDLE module of LP Scheme</comment>
        </bits>
      </reg>
      <reg name="nb_en_sel" protect="rw">
        <bits access="rw" name="select" pos="0" rst="0x0">
          <comment>NB low power Scheme selection signal
0: use RDA8909 LP  Scheme
1: use IDLE module of LP Scheme</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sw" protect="rw">
        <bits access="rw" name="dsipll" pos="6" rst="0x0">
          <comment>1:disbale PLL
0:enable PLL</comment>
        </bits>
        <bits access="rw" name="mempll" pos="5" rst="0x0">
          <comment>1:disable PLL
0:enbale PLL</comment>
        </bits>
        <bits access="rw" name="usbpll" pos="4" rst="0x0">
          <comment>1:disable PLL
0:enable PLL</comment>
        </bits>
        <bits access="rw" name="audiopll" pos="3" rst="0x0">
          <comment>1:disable PLL
0:enable PLL</comment>
        </bits>
        <bits access="rw" name="apll" pos="2" rst="0x0">
          <comment>1:disable PLL
0:enable PLL</comment>
        </bits>
        <bits access="rw" name="bbpll2" pos="1" rst="0x0">
          <comment>1:disable PLL
0:enable PLL</comment>
        </bits>
        <bits access="rw" name="bbpll1" pos="0" rst="0x0">
          <comment>1:disable PLL
0:enable PLL</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sw_set" protect="rw">
        <bits access="rs" name="pdpllswset" pos="6:0" rst="0x0">
          <comment>set corresponding bits of  PD_PLL_SW
0:Invariance of corresponding bits
1:set 1 of corresponding bits</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sw_clr" protect="rw">
        <bits access="rc" name="pdpllswclr" pos="6:0" rst="0x0">
          <comment>clean corresponding bits of PD_PLL_SW
0:Invariance of corresponding bits
1:clean corresponding bits</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sel" protect="rw">
        <bits access="rw" name="dsipll" pos="6" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit6 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="mempll" pos="5" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit5 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="usbpll" pos="4" rst="0x0">
          <comment>select hardware signal or software register to control the PLL switch
1:software register(bit4 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="audiopll" pos="3" rst="0x0">
          <comment>select hardware signal or software register to control the PLL switch
1:software register(bit3 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="apll" pos="2" rst="0x0">
          <comment>select hardware signal or software register to control the PLL switch
1:software register(bit2 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="bbpll2" pos="1" rst="0x0">
          <comment>select hardware signal or software register to control the PLL switch
1:software register(bit1 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="bbpll1" pos="0" rst="0x0">
          <comment>select hardware signal or software register to control the PLL switch
1:software register(bit0 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sel_set" protect="rw">
        <bits access="rs" name="pdpllselset" pos="6:0" rst="0x0">
          <comment>set corresponding bits of PD_PLL_SEL
0:Invariance of corresponding bits
1:set 1 of corresponding bits</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sel_clr" protect="rw">
        <bits access="rc" name="pdpllselclr" pos="6:0" rst="0x0">
          <comment>clean corresponding bits of PD_PLL_SEL
0:Invariance of corresponding bits
1:clean corresponding bits</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sw" protect="rw">
        <bits access="rw" name="dsipll" pos="6" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="mempll" pos="5" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="usbpll" pos="4" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="audiopll" pos="3" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="apll" pos="2" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="bbpll2" pos="1" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="bbpll1" pos="0" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sw_set" protect="rw">
        <bits access="rs" name="idlecgswset" pos="6:0" rst="0x0">
          <comment>set corresponding bits of IDLE_CG_SW
0:Invariance of corresponding bits
1:set 1 of corresponding bits</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sw_clr" protect="rw">
        <bits access="rc" name="idlecgswclr" pos="6:0" rst="0x0">
          <comment>clean corresponding bits of IDLE_CG_SW
0:Invariance of corresponding bits
1:clean corresponding bits</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sel" protect="rw">
        <bits access="rw" name="dsipll" pos="6" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit6 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="mempll" pos="5" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit5 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="usbpll" pos="4" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit4 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="audiopll" pos="3" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit3 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="apll" pos="2" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit2 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="bbpll2" pos="1" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit1 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="bbpll1" pos="0" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit0 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sel_set" protect="rw">
        <bits access="rs" name="idlecgselset" pos="6:0" rst="0x0">
          <comment>set corresponding bits of IDLE_CG_SEL
0:Invariance of corresponding bits
1:set 1 of corresponding bits</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sel_clr" protect="rw">
        <bits access="rc" name="idlecgselclr" pos="6:0" rst="0x0">
          <comment>clean corresponding bits of IDLE_CG_SEL
0:Invariance of corresponding bits
1:clean corresponding bits</comment>
        </bits>
      </reg>
      <reg name="rf_idle_enable_sw" protect="rw">
        <bits access="rw" name="rfidleenablesw" pos="0" rst="0x0">
          <comment>1:control the RF_DIG enter in IDLE
0:control the RF_DIG exit to the IDLE</comment>
        </bits>
      </reg>
      <reg name="rf_idle_enable_sel" protect="rw">
        <bits access="rw" name="rfidleenablesel" pos="0" rst="0x1">
          <comment>select the hardware signal or software register to control the RF_DIG enter in or extit to IDLE model.
1:software register(RF_IDLE_ENABLE_SW)
0:hardware signal( pow_on signal invert of IDLE module)</comment>
        </bits>
      </reg>
      <reg name="idle_res0" protect="rw">
        <comment>IDLE moduel reserved register 0</comment>
      </reg>
      <reg name="idle_res1" protect="rw">
        <comment>IDLE moduel reserved register 1</comment>
      </reg>
      <reg name="idle_res2" protect="rw">
        <comment>IDLE moduel reserved register 2</comment>
      </reg>
      <reg name="idle_res3" protect="rw">
        <comment>IDLE moduel reserved register 3</comment>
      </reg>
      <reg name="idle_res4" protect="rw">
        <comment>IDLE moduel reserved register 4</comment>
      </reg>
      <reg name="idle_res5" protect="rw">
        <comment>IDLE moduel reserved register 5</comment>
      </reg>
      <reg name="idle_res6" protect="rw">
        <comment>IDLE moduel reserved register 6</comment>
      </reg>
      <reg name="idle_res7" protect="rw">
        <comment>IDLE moduel reserved register 7</comment>
      </reg>
      <reg name="mem_ema_cfg" protect="rw">
        <bits access="rw" name="rftpd_rmb" pos="9:6" rst="0x2">
          <comment>RFTPD type EMA signal</comment>
        </bits>
        <bits access="rw" name="rftpd_rmeb" pos="5" rst="0x0">
          <comment>RFTPD type EMA signal</comment>
        </bits>
        <bits access="rw" name="rftpd_rma" pos="4:1" rst="0x2">
          <comment>RFTPD type EMA signal</comment>
        </bits>
        <bits access="rw" name="rftpd_rmea" pos="0" rst="0x0">
          <comment>RFTPD type EMA signal</comment>
        </bits>
      </reg>
      <reg name="uart_ctrl" protect="rw">
        <bits access="rw" name="rst_ctrl_uart" pos="1" rst="0x1">
          <comment>UART module reset control:
0: reset；
1: reset release。</comment>
        </bits>
        <bits access="rw" name="enable_clk_uart" pos="0" rst="0x1">
          <comment>UART module clock control:
0: disable；
1: enable。</comment>
        </bits>
      </reg>
      <reg name="ddr_latch" protect="rw">
        <bits access="rw" name="psram_latch" pos="1" rst="0x0">
          <comment>PSRAM IO LATCH:
0: release PSRAM PAD
1: no release PSRAM PAD.This bit will be set &quot;1&quot; by hardware when AP power domain was shut-down.Software should write this bit to &quot;0&quot; after PSRAM initialization when AP wake-up from deep sleep.</comment>
        </bits>
        <bits access="rw" name="lpddr_latch" pos="0" rst="0x0">
          <comment>LPDDR IO LATCH:
0: release LPDDR PAD
1: no release LPDDR PAD.This bit will be set &quot;1&quot; by hardware when AP power domain was shut-down.Software should write this bit to &quot;0&quot; after LPDDR initialization when AP wake-up from deep sleep.</comment>
        </bits>
      </reg>
      <reg name="pad_ctrl" protect="rw">
        <bits access="rw" name="pad_misc_idle_wpdi" pos="27" rst="0x0"/>
        <bits access="rw" name="pad_osc_32k_drv" pos="26:25" rst="0x2"/>
        <bits access="rw" name="pad_osc_32k_se" pos="24" rst="0x0"/>
        <bits access="rw" name="pad_osc_32k_wpus" pos="23" rst="0x0"/>
        <bits access="rw" name="pad_gpio_6_pull_frc" pos="22" rst="0x0"/>
        <bits access="rw" name="pad_gpio_6_drv" pos="21:20" rst="0x2"/>
        <bits access="rw" name="pad_gpio_6_pull_dowe" pos="19" rst="0x0"/>
        <bits access="rw" name="pad_gpio_6_pull_up" pos="18" rst="0x0"/>
        <bits access="rw" name="pad_gpio_6_se" pos="17" rst="0x0"/>
        <bits access="rw" name="pad_gpio_6_wpus" pos="16" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_out" pos="15" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_out_frc" pos="14" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_pull_frc" pos="13" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_drv" pos="12:11" rst="0x2"/>
        <bits access="rw" name="pad_chip_pd_pull_dowe" pos="10" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_pull_up" pos="9" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_se" pos="8" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_wpus" pos="7" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_rxd_pull_frc" pos="6" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_rxd_drv" pos="5:4" rst="0x2"/>
        <bits access="rw" name="pad_uart_1_rxd_pull_dowe" pos="3" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_rxd_pull_up" pos="2" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_rxd_se" pos="1" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_rxd_wpus" pos="0" rst="0x0"/>
      </reg>
      <reg name="idle_res8" protect="rw">
        <comment>IDLE moduel reserved register 8</comment>
      </reg>
      <reg name="idle_res9" protect="rw">
        <comment>IDLE moduel reserved register 9</comment>
      </reg>
      <reg name="idle_res10" protect="rw">
        <comment>IDLE moduel reserved register 10</comment>
      </reg>
      <reg name="idle_res11" protect="rw">
        <comment>IDLE moduel reserved register 11</comment>
      </reg>
      <reg name="pad_ctrl_uart_txd" protect="rw">
        <bits access="rw" name="pad_uart_1_txd_out" pos="8" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_out_frc" pos="7" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_pull_frc" pos="6" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_drv" pos="5:4" rst="0x2"/>
        <bits access="rw" name="pad_uart_1_txd_pull_dowe" pos="3" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_pull_up" pos="2" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_se" pos="1" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_wpus" pos="0" rst="0x0"/>
      </reg>
      <reg name="mon_sel" protect="rw">
        <bits access="rw" name="mon15_sel" pos="31:30" rst="0x0">
          <comment>mon15_sel:
00: select nb_en.
01: select awk_sys_valid.
10: select awake[7].
11: select target_timer_stat[1].</comment>
        </bits>
        <bits access="rw" name="mon14_sel" pos="29:28" rst="0x0">
          <comment>mon14_sel:
00: select gsm_en.
01: select wcn_chip_pd.
10: select awake[6].
11: select target_timer_stat[0].</comment>
        </bits>
        <bits access="rw" name="mon13_sel" pos="27:26" rst="0x0">
          <comment>mon13_sel:
00: select wake_timer.
01: select wcn_pd_xtal.
10: select awake[5].
11: select target_timer_enable.</comment>
        </bits>
        <bits access="rw" name="mon12_sel" pos="25:24" rst="0x0">
          <comment>mon12_sel:
00: select timer_en_nb.
01: select wcn_pd_pll.
10: select awake[4].
11: select nb_frame_int.</comment>
        </bits>
        <bits access="rw" name="mon11_sel" pos="23:22" rst="0x0">
          <comment>mon11_sel:
00: select timer_en_gsm.
01: select wcn_idle_cg.
10: select awake[3].
11: nb_lp_pu_done.</comment>
        </bits>
        <bits access="rw" name="mon10_sel" pos="21:20" rst="0x0">
          <comment>mon10_sel:
00: select timer_en_ltem2.
01: select nb_en_sel.
10: select awake[2].
11: select nb_lp_sf_slowrunning.</comment>
        </bits>
        <bits access="rw" name="mon9_sel" pos="19:18" rst="0x0">
          <comment>mon9_sel:
00: select timer_en_ltem1.
01: select gsm_en_sel.
10: select awake[1].
11: select nb_fint.</comment>
        </bits>
        <bits access="rw" name="mon8_sel" pos="17:16" rst="0x0">
          <comment>mon8_sel:
00: select idst_nb_timer.
01: select idle_chip_pd.
10: select awake[0].
11: select gsm_frame_int.</comment>
        </bits>
        <bits access="rw" name="mon7_sel" pos="15:14" rst="0x0">
          <comment>mon7_sel:
00: select idst_gsm_timer
01: select idle_pd_xtal.
10: select awk_self.
11: gsm_lp_pu_done.</comment>
        </bits>
        <bits access="rw" name="mon6_sel" pos="13:12" rst="0x0">
          <comment>mon6_sel:
00: select idst_ltem2_timer.
01: select idle_pd_pll.
10: select idst_gsm_ltem_timer.
11: select gsm_lp_sf_slowrunning.</comment>
        </bits>
        <bits access="rw" name="mon5_sel" pos="11:10" rst="0x0">
          <comment>mon5_sel:
00: select idst_ltem1_timer.
01: select idle_idle_cg.
10: select awk_gsm_ltem_timner.
11: select gsm_fint.</comment>
        </bits>
        <bits access="rw" name="mon4_sel" pos="9:8" rst="0x0">
          <comment>mon4_sel:
00: select idct_nb_timer.
01: select pow_on.
10: select idst_sys.
11: select rstctrl_uart.</comment>
        </bits>
        <bits access="rw" name="mon3_sel" pos="7:6" rst="0x0">
          <comment>mon3_sel:
00: select idct_gsm_timer.
01: select idct_sys_valid.
10: select nb_lp_pu_reach.
11: select clken_uart.</comment>
        </bits>
        <bits access="rw" name="mon2_sel" pos="5:4" rst="0x0">
          <comment>mon2_sel:
00: select idct_ltem2_timer.
01: select idct_ap.
10: select gsm_lp_pu_reach.
11: select psram_latch_reg.</comment>
        </bits>
        <bits access="rw" name="mon1_sel" pos="3:2" rst="0x0">
          <comment>mon1_sel:
00: select idct_ltem1_timer
01: select idct_cp.
10: select osw2_awk
11: select lpddr_latch_reg</comment>
        </bits>
        <bits access="rw" name="mon0_sel" pos="1:0" rst="0x1">
          <comment>mon0_sel:
00: select idct_timer.
01: select ltem1_fint.
10: select osw1_awk.
11: select ltem2_fint</comment>
        </bits>
      </reg>
      <reg name="mon_sel_set" protect="rw">
        <comment>set corresponding bits of MON_SEL
0:Invariance of corresponding bits
1:set corresponding bits</comment>
      </reg>
      <reg name="mon_sel_clr" protect="rw">
        <comment>clear corresponding bits of MON_SEL
0:Invariance of corresponding bits
1:clear corresponding bits</comment>
      </reg>
      <reg name="target_timer" protect="rw">
        <comment>Interrupt generated when the reference 32K counter reach to this register value.</comment>
      </reg>
      <reg name="target_timer_en" protect="rw">
        <bits access="rw" name="disable_target_timer" pos="0" rst="0x0">
          <comment>1: disable target timer.
0: enable</comment>
        </bits>
      </reg>
      <reg name="target_value_lock" protect="rw">
        <comment>The locked value of reference 32K when interrupt generated.</comment>
      </reg>
      <reg name="target_timer_stat" protect="rw">
        <bits access="r" name="timer_stat_32k" pos="1" rst="0x0">
          <comment>Indicat the state of target timer in 32K clock domain</comment>
        </bits>
        <bits access="r" name="timer_stat_122m" pos="0" rst="0x0">
          <comment>Indicate the state of target timer in 122.88M clock domain</comment>
        </bits>
      </reg>
      <reg name="slow_sys_clk_sel_hwen" protect="rw">
        <bits access="rw" name="slow_sys_clk_sel_hwen" pos="0" rst="0x0">
          <comment>0:SLOW_CLK and system clk selected by software bit conrtol
1:SLOW_CLK and system clk select by hareware signal control</comment>
        </bits>
      </reg>
      <reg name="slow_clk_sel_hwen" protect="rw">
        <bits access="rw" name="slow_clk_sel_hwen" pos="0" rst="0x0">
          <comment>0:SLOW_CLK selected(between 26M and 32k) by software bit control
1:SLOW_CLK selected(between 26M and 32k) by hareware signal control</comment>
        </bits>
      </reg>
      <reg name="sleep_prot_time" protect="rw">
        <bits access="rw" name="prot_time" pos="7:0" rst="0x9">
          <comment>The minimum threshold of deep sleep, to ensure PMIC have complete deep sleep in and deep sleep out.</comment>
        </bits>
      </reg>
      <reg name="h_val_sel" protect="rw">
        <bits access="rw" name="h_val_sel" pos="0" rst="0x0">
          <comment>change H_VAL's time
1:pd_xtal
0:chip_pd</comment>
        </bits>
      </reg>
      <reg name="tp_sta" protect="rw">
        <bits access="r" name="tp_sta2" pos="2" rst="0x0">
          <comment>1:tstamp_i[1]
0:tstamp_i[0]</comment>
        </bits>
        <bits access="r" name="tp_sta1" pos="1" rst="0x0">
          <comment>1:perip tstamp
0:inner tstamp</comment>
        </bits>
        <bits access="rc" name="tp_sta0" pos="0" rst="0x0">
          <comment>1:tstamp saved
0:nothing</comment>
        </bits>
      </reg>
      <reg name="ltem1_framls_rel" protect="rw">
        <comment>LTE-M framl ref adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="ltem1_framls_ref" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="ltem1_framls_abs" protect="rw">
        <comment>LTE-M framl abs adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="ltem1_framls_abs" pos="15:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="ltem2_framls_rel" protect="rw">
        <comment>LTE-M framl ref adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="ltem2_framls_ref" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="ltem2_framls_abs" protect="rw">
        <comment>LTE-M framl abs adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0:postive
1:negative</comment>
        </bits>
        <bits access="rw" name="ltem2_framls_abs" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="ltem1_load_en" protect="rw">
        <comment>LTE-M1 LOAD change register</comment>
        <bits access="rw" name="ltem1_load_en" pos="0" rst="0x0">
          <comment>0:load_timer from lps
1:TP load</comment>
        </bits>
      </reg>
      <reg name="ltem2_load_en" protect="rw">
        <comment>LTE-M2 LOAD change register</comment>
        <bits access="rw" name="ltem2_load_en" pos="0" rst="0x0">
          <comment>0:load_timer from lps
1:TP load</comment>
        </bits>
      </reg>
      <reg name="ltem2_fint_en" protect="rw">
        <comment>sub-frame interrupt enable register</comment>
        <bits access="rw" name="lte_m2_fint_enable" pos="9:0" rst="0x3ff">
          <comment>Each bit corresponds to 10 sub-frame, sub-frame interrupt will be sent to CPU when correspond bit is enabled.</comment>
        </bits>
      </reg>
      <reg name="gnss_tstamp_en" protect="rw">
        <comment>sub-frame interrupt enable register</comment>
        <bits access="rw" name="em_latch_en" pos="2" rst="0x0">
          <comment>1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="cpu_latch_en" pos="1" rst="0x0">
          <comment>1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="rtc_latch_en" pos="0" rst="0x0">
          <comment>1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem1_fhl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 high-level frame locked register</comment>
        <bits access="r" name="gnss_rtc_ltem1_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem1_fll" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 frame locked register</comment>
        <bits access="r" name="gnss_rtc_ltem1_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem1_fcl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 counter locked register</comment>
        <bits access="r" name="gnss_rtc_ltem1_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem2_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_rtc_ltem2_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem2_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_rtc_ltem2_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem2_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_rtc_ltem2_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem3_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_rtc_ltem3_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem3_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_rtc_ltem3_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem3_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_rtc_ltem3_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem1_fhl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 high-level frame locked register</comment>
        <bits access="r" name="gnss_cpu_ltem1_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem1_fll" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 frame locked register</comment>
        <bits access="r" name="gnss_cpu_ltem1_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem1_fcl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 counter locked register</comment>
        <bits access="r" name="gnss_cpu_ltem1_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem2_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_cpu_ltem2_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem2_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_cpu_ltem2_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem2_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_cpu_ltem2_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem3_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_cpu_ltem3_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem3_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_cpu_ltem3_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem3_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_cpu_ltem3_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem1_fhl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 high-level frame locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem1_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem1_fll" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 frame locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem1_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem1_fcl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 counter locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem1_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem2_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem2_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem2_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem2_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem2_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem2_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem3_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem3_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem3_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem3_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem3_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem3_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem1_fhl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 high-level frame locked register</comment>
        <bits access="r" name="gnss_em_ltem1_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem1_fll" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 frame locked register</comment>
        <bits access="r" name="gnss_em_ltem1_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem1_fcl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 counter locked register</comment>
        <bits access="r" name="gnss_em_ltem1_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem2_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_em_ltem2_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem2_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_em_ltem2_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem2_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_em_ltem2_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem3_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_em_ltem3_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem3_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_em_ltem3_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem3_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_em_ltem3_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="ltem3_load_en" protect="rw">
        <comment>LTE-M3 LOAD change register</comment>
        <bits access="rw" name="ltem3_load_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="idl_fn_ltem3" protect="rw">
        <comment>IDLE LTEM3 frame register</comment>
        <bits access="r" name="idfn_rad_ltem3" pos="31:4" rst="0x0">
          <comment>Number of frames ltem3 sleeped</comment>
        </bits>
        <bits access="r" name="idfn_sub_ltem3" pos="3:0" rst="0x0">
          <comment>Number of sub-frames ltem3 sleeped.</comment>
        </bits>
      </reg>
      <reg name="ltem3_frame_inten" protect="rw">
        <comment>LTEM3 frame interrupt enable register</comment>
        <bits access="rw" name="ltem3_frame3_irq_en" pos="2" rst="0x0">
          <comment>ltem3_frame3_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem3_frame2_irq_en" pos="1" rst="0x0">
          <comment>ltem3_frame2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem3_frame1_irq_en" pos="0" rst="0x0">
          <comment>ltem3_frame1_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="ltem3_frame_int_sta" protect="rw">
        <comment>LTEM3 interrupt state register</comment>
        <bits access="rc" name="ltem3_frame_int_sta" pos="2:0" rst="0x0">
          <comment>cleared by writing 1 to correspond bit</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_hfn" protect="rw">
        <comment>LTEM3 high-level frame number register</comment>
        <bits access="rw" name="ltem3_cfsr_hfn" pos="21:0" rst="0x0">
          <comment>LTEM3 high-level frame number value</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_fn" protect="rw">
        <bits access="rw" name="ltem3_cfsr_rad" pos="13:4" rst="0x0">
          <comment>LTE-M3 frame number</comment>
        </bits>
        <bits access="rw" name="ltem3_cfsr_sub" pos="3:0" rst="0x0">
          <comment>LTE-M3 sub-frame number</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsrs" protect="rw">
        <comment>LTE-M3 frame offset register</comment>
        <bits access="rw" name="active_time3_cfsr" pos="25" rst="0x0">
          <comment>frame adjust time
0: adjust at next frame interrupt
1: adjust frame immetiately</comment>
        </bits>
        <bits access="rw" name="adjust_direct3_cfsr" pos="24" rst="0x0">
          <comment>frame adjust direction
0: postive
1: negative</comment>
        </bits>
        <bits access="rw" name="ltem3_cfsrs" pos="23:0" rst="0x0">
          <comment>LTE-M3 frame offest value
(Adjust frame offset B, there are two case: if adjust direction is 0, write b+1 to this register then current frame plus this value when frame interrupt occurred. otherwise write b-1 into this register then current frame minus this value when frame interrupt occurred.)</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_rdh" protect="rw">
        <comment>LTE-M3 high-level frame read register</comment>
        <bits access="r" name="ltem3_cfsr_rdh" pos="21:0" rst="0x0">
          <comment>LTE-M3 high-level frame value</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_rdl" protect="rw">
        <comment>LTE-M3 frame read register</comment>
        <bits access="r" name="ltem3_cfsr_rdl_rad" pos="13:4" rst="0x0">
          <comment>LTE-M3 radio frame value</comment>
        </bits>
        <bits access="r" name="ltem3_cfsr_rdl_sub" pos="3:0" rst="0x0">
          <comment>LTE-M3 sub-frame value</comment>
        </bits>
      </reg>
      <reg name="ltem3_framc" protect="rw">
        <comment>LTE-M3 counter</comment>
        <bits access="r" name="lframc3" pos="15:0" rst="0x1">
          <comment>LTE-M3 counter value</comment>
        </bits>
      </reg>
      <reg name="ltem3_framl" protect="rw">
        <comment>LTE-M3 frame length register</comment>
        <bits access="rw" name="lframl3" pos="15:0" rst="0x7800">
          <comment>LTE-M3 frame length</comment>
        </bits>
      </reg>
      <reg name="ltem3_framls" protect="rw">
        <comment>LTE-M3 frame length adjust register</comment>
        <bits access="rw" name="active_time3_framls" pos="16" rst="0x0">
          <comment>adjust time
0: adjust immetiately
1:  adjust at next ltem frame interrupt</comment>
        </bits>
        <bits access="rw" name="lframls3" pos="15:0" rst="0x0">
          <comment>LTE-M3 adjuste frame length.
current Ltem frame length load the register when write happens,then return the LFRAML at the time of lte frame interrupt arrivals.</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_tph" protect="rw">
        <comment>LTE-M3 radio frame value time stamp register</comment>
        <bits access="rw" name="ltem3_cfsr_tph" pos="21:0" rst="0x0">
          <comment>LTE-M3 high-level frame value time stamp register</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_tpl" protect="rw">
        <comment>LTE-M3 sub-frame time stamp register</comment>
        <bits access="rw" name="ltem3_cfsr_tpl" pos="13:0" rst="0x0">
          <comment>LTE-M3 frame stamp value</comment>
        </bits>
      </reg>
      <reg name="ltem3_framc_tp" protect="rw">
        <comment>LTE-M3 counter time stamp register</comment>
        <bits access="rw" name="ltem3_framc_tp" pos="15:0" rst="0x1">
          <comment>LTE-M3 stamp counter</comment>
        </bits>
      </reg>
      <reg name="ltem3_framls_rel" protect="rw">
        <comment>LTE-M framl ref adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="ltem3_framls_ref" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="ltem3_framls_abs" protect="rw">
        <comment>LTE-M framl abs adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="ltem3_framls_abs" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="lte3_fint_dly1" protect="rw">
        <comment>LTEM3 frame interrupt delay register 1</comment>
        <bits access="rw" name="delay3_time1" pos="15:0" rst="0x1">
          <comment>LTE-M3 frame interrupt delay, take ltem2_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem3_fint_dly2" protect="rw">
        <comment>LTEM3 frame interrupt delay register 2</comment>
        <bits access="rw" name="delay3_time2" pos="15:0" rst="0x1">
          <comment>LTE-M3 frame interrupt delay, take ltem3_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem3_fint_dly3" protect="rw">
        <comment>LTEM1 interrupt delay setting register 3</comment>
        <bits access="rw" name="delay3_time3" pos="15:0" rst="0x1">
          <comment>LTE-M3 frame interrupt delay,
take ltem3_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem3_fint_en" protect="rw">
        <comment>sub-frame interrupt enable register</comment>
        <bits access="rw" name="lte_m3_fint_enable" pos="9:0" rst="0x3ff">
          <comment>Each bit corresponds to 10 sub-frame, sub-frame interrupt will be sent to CPU when correspond bit is enabled.</comment>
        </bits>
      </reg>
      <reg name="ltem3_fhl" protect="rw">
        <comment>LTE-M high-level frame locked register</comment>
        <bits access="r" name="ltem3_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="ltem3_fll" protect="rw">
        <comment>LTE-M frame locked register</comment>
        <bits access="r" name="ltem3_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="ltem3_fcl" protect="rw">
        <comment>LTE-M counter locked register</comment>
        <bits access="r" name="ltem3_fcl" pos="15:0" rst="0x1">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="idle_frame_ltem3" protect="rw">
        <comment>IDLE LTE-M3 frame configuration register</comment>
        <bits access="rw" name="frame3_conf" pos="24" rst="0x0">
          <comment>enable(this bit cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="frame3_cfsr" pos="21:0" rst="0x0">
          <comment>interrupt frame number
interrupt occurred when current frame reach this register.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51507000" name="IDLE_TIMER" type="IDLE_TIMER"/>
  </archive>
  <archive relative="monitor.xml">
    <module category="System" name="MONITOR">
      <reg name="mon_sel0" protect="rw">
        <bits access="rw" name="mon_sel0" pos="10:0" rst="0x0">
          <comment>用于选择各个子系统中的监控信号并通过第0根监控信号送出</comment>
        </bits>
      </reg>
      <reg name="mon_sel1" protect="rw">
        <bits access="rw" name="mon_sel1" pos="10:0" rst="0x1">
          <comment>用于选择各个子系统中的监控信号并通过第1根监控信号送出</comment>
        </bits>
      </reg>
      <reg name="mon_sel2" protect="rw">
        <bits access="rw" name="mon_sel2" pos="10:0" rst="0x2">
          <comment>用于选择各个子系统中的监控信号并通过第2根监控信号送出</comment>
        </bits>
      </reg>
      <reg name="mon_sel3" protect="rw">
        <bits access="rw" name="mon_sel3" pos="10:0" rst="0x3">
          <comment>用于选择各个子系统中的监控信号并通过第3根监控信号送出</comment>
        </bits>
      </reg>
      <reg name="mon_sel4" protect="rw">
        <bits access="rw" name="mon_sel4" pos="10:0" rst="0x4">
          <comment>用于选择各个子系统中的监控信号并通过第4根监控信号送出</comment>
        </bits>
      </reg>
      <reg name="mon_sel5" protect="rw">
        <bits access="rw" name="mon_sel5" pos="10:0" rst="0x5">
          <comment>用于选择各个子系统中的监控信号并通过第5根监控信号送出</comment>
        </bits>
      </reg>
      <reg name="mon_sel6" protect="rw">
        <bits access="rw" name="mon_sel6" pos="10:0" rst="0x6">
          <comment>用于选择各个子系统中的监控信号并通过第6根监控信号送出</comment>
        </bits>
      </reg>
      <reg name="mon_sel7" protect="rw">
        <bits access="rw" name="mon_sel7" pos="10:0" rst="0x7">
          <comment>用于选择各个子系统中的监控信号并通过第7根监控信号送出</comment>
        </bits>
      </reg>
      <reg name="mon_con0" protect="rw">
        <bits access="rw" name="mon_con0" pos="2:0" rst="0x0">
          <comment>monitor_o[0]选择：
3'h0: 子系统0
3'h1: 子系统1
3'h2: 子系统2
3'h3: 子系统3
3'h4: 子系统4
3'h5: 子系统5
3'h6: 子系统6
3'h7: 子系统7</comment>
        </bits>
      </reg>
      <reg name="mon_con1" protect="rw">
        <bits access="rw" name="mon_con1" pos="2:0" rst="0x0">
          <comment>monitor_o[1]选择：
3'h0: 子系统0
3'h1: 子系统1
3'h2: 子系统2
3'h3: 子系统3
3'h4: 子系统4
3'h5: 子系统5
3'h6: 子系统6
3'h7: 子系统7</comment>
        </bits>
      </reg>
      <reg name="mon_con2" protect="rw">
        <bits access="rw" name="mon_con2" pos="2:0" rst="0x0">
          <comment>monitor_o[2]选择：
3'h0: 子系统0
3'h1: 子系统1
3'h2: 子系统2
3'h3: 子系统3
3'h4: 子系统4
3'h5: 子系统5
3'h6: 子系统6
3'h7: 子系统7</comment>
        </bits>
      </reg>
      <reg name="mon_con3" protect="rw">
        <bits access="rw" name="mon_con3" pos="2:0" rst="0x0">
          <comment>monitor_o[3]选择：
3'h0: 子系统0
3'h1: 子系统1
3'h2: 子系统2
3'h3: 子系统3
3'h4: 子系统4
3'h5: 子系统5
3'h6: 子系统6
3'h7: 子系统7</comment>
        </bits>
      </reg>
      <reg name="mon_con4" protect="rw">
        <bits access="rw" name="mon_con4" pos="2:0" rst="0x0">
          <comment>monitor_o[4]选择：
3'h0: 子系统0
3'h1: 子系统1
3'h2: 子系统2
3'h3: 子系统3
3'h4: 子系统4
3'h5: 子系统5
3'h6: 子系统6
3'h7: 子系统7</comment>
        </bits>
      </reg>
      <reg name="mon_con5" protect="rw">
        <bits access="rw" name="mon_con5" pos="2:0" rst="0x0">
          <comment>monitor_o[5]选择：
3'h0: 子系统0
3'h1: 子系统1
3'h2: 子系统2
3'h3: 子系统3
3'h4: 子系统4
3'h5: 子系统5
3'h6: 子系统6
3'h7: 子系统7</comment>
        </bits>
      </reg>
      <reg name="mon_con6" protect="rw">
        <bits access="rw" name="mon_con6" pos="2:0" rst="0x0">
          <comment>monitor_o[6]选择：
3'h0: 子系统0
3'h1: 子系统1
3'h2: 子系统2
3'h3: 子系统3
3'h4: 子系统4
3'h5: 子系统5
3'h6: 子系统6
3'h7: 子系统7</comment>
        </bits>
      </reg>
      <reg name="mon_con7" protect="rw">
        <bits access="rw" name="mon_con7" pos="2:0" rst="0x0">
          <comment>monitor_o[7]选择：
3'h0: 子系统0
3'h1: 子系统1
3'h2: 子系统2
3'h3: 子系统3
3'h4: 子系统4
3'h5: 子系统5
3'h6: 子系统6
3'h7: 子系统7</comment>
        </bits>
      </reg>
      <reg name="mon_enable" protect="rw">
        <bits access="rw" name="mon_enable" pos="0" rst="0x0">
          <comment>监控使能
1：使能监控
0：不使能监控</comment>
        </bits>
      </reg>
      <reg name="monitor_o" protect="rw">
        <bits access="r" name="monitor_signal" pos="7:0" rst="0x0">
          <comment>monitor output signal value.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51502000" name="MONITOR" type="MONITOR"/>
  </archive>
  <archive relative="sysmail.xml">
    <module category="System" name="CP_MAILBOX">
      <reg name="intgr0" protect="rw">
        <comment>power domain shutdown/on controled by hardware signal or sofeware register.</comment>
      </reg>
      <reg name="intstr0" protect="rw">
        <comment>sysmail0 interrupt bit set register</comment>
      </reg>
      <reg name="intcr0" protect="rw">
        <comment>sysmail0 interrupt clean register</comment>
      </reg>
      <reg name="intmr0" protect="rw">
        <comment>sysmail0 interrupt mask register</comment>
      </reg>
      <reg name="intsr0" protect="rw">
        <comment>sysmail0 interrupt status register</comment>
      </reg>
      <reg name="intmsr0" protect="rw">
        <comment>sysmail0 interrupt mask status register</comment>
      </reg>
      <hole size="64"/>
      <reg name="intgr1" protect="rw">
        <comment>sysmail1 Interrupt generate register</comment>
      </reg>
      <reg name="intstr1" protect="rw">
        <comment>sysmail1 interrupt bit set register</comment>
      </reg>
      <reg name="intcr1" protect="rw">
        <comment>sysmail1 interrupt clean register</comment>
      </reg>
      <reg name="intmr1" protect="rw">
        <comment>sysmail1 interrupt mask register</comment>
      </reg>
      <reg name="intsr1" protect="rw">
        <comment>sysmail1 interrupt status register</comment>
      </reg>
      <reg name="intmsr1" protect="rw">
        <comment>sysmail1 interrupt mask  status register</comment>
      </reg>
      <hole size="64"/>
      <reg name="intgr2" protect="rw">
        <comment>sysmail2 Interrupt generate register</comment>
      </reg>
      <reg name="intstr2" protect="rw">
        <comment>sysmail2 interrupt bit set register</comment>
      </reg>
      <reg name="intcr2" protect="rw">
        <comment>sysmail2 interrupt clean register</comment>
      </reg>
      <reg name="intmr2" protect="rw">
        <comment>sysmail2 interrupt mask register</comment>
      </reg>
      <reg name="intsr2" protect="rw">
        <comment>sysmail2 interrupt status register</comment>
      </reg>
      <reg name="intmsr2" protect="rw">
        <comment>sysmail2 interrupt mask  status register</comment>
      </reg>
      <hole size="64"/>
      <reg name="intgr3" protect="rw">
        <comment>sysmail3 Interrupt generate register</comment>
      </reg>
      <reg name="intstr3" protect="rw">
        <comment>sysmail3 interrupt bit set register</comment>
      </reg>
      <reg name="intcr3" protect="rw">
        <comment>sysmail3 interrupt clean register</comment>
      </reg>
      <reg name="intmr3" protect="rw">
        <comment>sysmail3 interrupt mask register</comment>
      </reg>
      <reg name="intsr3" protect="rw">
        <comment>sysmail3 interrupt status register</comment>
      </reg>
      <reg name="intmsr3" protect="rw">
        <comment>sysmail3 interrupt mask  status register</comment>
      </reg>
      <hole size="64"/>
      <reg name="intgr4" protect="rw">
        <comment>sysmail4 Interrupt generate register</comment>
      </reg>
      <reg name="intstr4" protect="rw">
        <comment>sysmail4 interrupt bit set register</comment>
      </reg>
      <reg name="intcr4" protect="rw">
        <comment>sysmail4 interrupt clean register</comment>
      </reg>
      <reg name="intmr4" protect="rw">
        <comment>sysmail4 interrupt mask register</comment>
      </reg>
      <reg name="intsr4" protect="rw">
        <comment>sysmail4 interrupt status register</comment>
      </reg>
      <reg name="intmsr4" protect="rw">
        <comment>sysmail4 interrupt mask  status register</comment>
      </reg>
      <hole size="64"/>
      <reg name="intgr5" protect="rw">
        <comment>sysmail5 Interrupt generate register</comment>
      </reg>
      <reg name="intstr5" protect="rw">
        <comment>sysmail5 interrupt bit set register</comment>
      </reg>
      <reg name="intcr5" protect="rw">
        <comment>sysmail5 interrupt clean register</comment>
      </reg>
      <reg name="intmr5" protect="rw">
        <comment>sysmail5 interrupt mask register</comment>
      </reg>
      <reg name="intsr5" protect="rw">
        <comment>sysmail5 interrupt status register</comment>
      </reg>
      <reg name="intmsr5" protect="rw">
        <comment>sysmail5 interrupt mask  status register</comment>
      </reg>
      <hole size="576"/>
      <reg name="sysmail0" protect="rw">
        </reg>
      <reg name="sysmail1" protect="rw">
        </reg>
      <reg name="sysmail2" protect="rw">
        </reg>
      <reg name="sysmail3" protect="rw">
        </reg>
      <reg name="sysmail4" protect="rw">
        </reg>
      <reg name="sysmail5" protect="rw">
        </reg>
      <reg name="sysmail6" protect="rw">
        </reg>
      <reg name="sysmail7" protect="rw">
        </reg>
      <reg name="sysmail8" protect="rw">
        </reg>
      <reg name="sysmail9" protect="rw">
        </reg>
      <reg name="sysmail10" protect="rw">
        </reg>
      <reg name="sysmail11" protect="rw">
        </reg>
      <reg name="sysmail12" protect="rw">
        </reg>
      <reg name="sysmail13" protect="rw">
        </reg>
      <reg name="sysmail14" protect="rw">
        </reg>
      <reg name="sysmail15" protect="rw">
        </reg>
      <reg name="sysmail16" protect="rw">
        </reg>
      <reg name="sysmail17" protect="rw">
        </reg>
      <reg name="sysmail18" protect="rw">
        </reg>
      <reg name="sysmail19" protect="rw">
        </reg>
      <reg name="sysmail20" protect="rw">
        </reg>
      <reg name="sysmail21" protect="rw">
        </reg>
      <reg name="sysmail22" protect="rw">
        </reg>
      <reg name="sysmail23" protect="rw">
        </reg>
      <reg name="sysmail24" protect="rw">
        </reg>
      <reg name="sysmail25" protect="rw">
        </reg>
      <reg name="sysmail26" protect="rw">
        </reg>
      <reg name="sysmail27" protect="rw">
        </reg>
      <reg name="sysmail28" protect="rw">
        </reg>
      <reg name="sysmail29" protect="rw">
        </reg>
      <reg name="sysmail30" protect="rw">
        </reg>
      <reg name="sysmail31" protect="rw">
        </reg>
      <hole size="1024"/>
      <reg name="sysmail32" protect="rw">
        </reg>
      <reg name="sysmail33" protect="rw">
        </reg>
      <reg name="sysmail34" protect="rw">
        </reg>
      <reg name="sysmail35" protect="rw">
        </reg>
      <reg name="sysmail36" protect="rw">
        </reg>
      <reg name="sysmail37" protect="rw">
        </reg>
      <reg name="sysmail38" protect="rw">
        </reg>
      <reg name="sysmail39" protect="rw">
        </reg>
      <reg name="sysmail40" protect="rw">
        </reg>
      <reg name="sysmail41" protect="rw">
        </reg>
      <reg name="sysmail42" protect="rw">
        </reg>
      <reg name="sysmail43" protect="rw">
        </reg>
      <reg name="sysmail44" protect="rw">
        </reg>
      <reg name="sysmail45" protect="rw">
        </reg>
      <reg name="sysmail46" protect="rw">
        </reg>
      <reg name="sysmail47" protect="rw">
        </reg>
      <reg name="sysmail48" protect="rw">
        </reg>
      <reg name="sysmail49" protect="rw">
        </reg>
      <reg name="sysmail50" protect="rw">
        </reg>
      <reg name="sysmail51" protect="rw">
        </reg>
      <reg name="sysmail52" protect="rw">
        </reg>
      <reg name="sysmail53" protect="rw">
        </reg>
      <reg name="sysmail54" protect="rw">
        </reg>
      <reg name="sysmail55" protect="rw">
        </reg>
      <reg name="sysmail56" protect="rw">
        </reg>
      <reg name="sysmail57" protect="rw">
        </reg>
      <reg name="sysmail58" protect="rw">
        </reg>
      <reg name="sysmail59" protect="rw">
        </reg>
      <reg name="sysmail60" protect="rw">
        </reg>
      <reg name="sysmail61" protect="rw">
        </reg>
      <reg name="sysmail62" protect="rw">
        </reg>
      <reg name="sysmail63" protect="rw">
        </reg>
      <hole size="1024"/>
      <reg name="sysmail64" protect="rw">
        </reg>
      <reg name="sysmail65" protect="rw">
        </reg>
      <reg name="sysmail66" protect="rw">
        </reg>
      <reg name="sysmail67" protect="rw">
        </reg>
      <reg name="sysmail68" protect="rw">
        </reg>
      <reg name="sysmail69" protect="rw">
        </reg>
      <reg name="sysmail70" protect="rw">
        </reg>
      <reg name="sysmail71" protect="rw">
        </reg>
      <reg name="sysmail72" protect="rw">
        </reg>
      <reg name="sysmail73" protect="rw">
        </reg>
      <reg name="sysmail74" protect="rw">
        </reg>
      <reg name="sysmail75" protect="rw">
        </reg>
      <reg name="sysmail76" protect="rw">
        </reg>
      <reg name="sysmail77" protect="rw">
        </reg>
      <reg name="sysmail78" protect="rw">
        </reg>
      <reg name="sysmail79" protect="rw">
        </reg>
      <reg name="sysmail80" protect="rw">
        </reg>
      <reg name="sysmail81" protect="rw">
        </reg>
      <reg name="sysmail82" protect="rw">
        </reg>
      <reg name="sysmail83" protect="rw">
        </reg>
      <reg name="sysmail84" protect="rw">
        </reg>
      <reg name="sysmail85" protect="rw">
        </reg>
      <reg name="sysmail86" protect="rw">
        </reg>
      <reg name="sysmail87" protect="rw">
        </reg>
      <reg name="sysmail88" protect="rw">
        </reg>
      <reg name="sysmail89" protect="rw">
        </reg>
      <reg name="sysmail90" protect="rw">
        </reg>
      <reg name="sysmail91" protect="rw">
        </reg>
      <reg name="sysmail92" protect="rw">
        </reg>
      <reg name="sysmail93" protect="rw">
        </reg>
      <reg name="sysmail94" protect="rw">
        </reg>
      <reg name="sysmail95" protect="rw">
        </reg>
    </module>
    <instance address="0x51506000" name="MAILBOX" type="CP_MAILBOX"/>
  </archive>
  <archive relative="pusch.xml">
    <module category="System" name="PUSCH">
      <reg name="ack_offset" protect="rw">
        <comment>ACK偏移索引</comment>
        <bits access="rw" name="ack_offset" pos="3:0" rst="0x0">
          <comment>ACK偏移索引</comment>
        </bits>
      </reg>
      <reg name="ri_offset" protect="rw">
        <comment>RI的MCS偏移索引</comment>
        <bits access="rw" name="ri_offset" pos="3:0" rst="0x0">
          <comment>RI的MCS偏移索引</comment>
        </bits>
      </reg>
      <reg name="cqi_offset" protect="rw">
        <comment>CQI的MCS偏移索引</comment>
        <bits access="rw" name="cqi_offset" pos="3:0" rst="0x0">
          <comment>CQI的MCS偏移索引</comment>
        </bits>
      </reg>
      <reg name="tbsize_init" protect="rw">
        <comment>初始传输块大小数据量寄存器</comment>
        <bits access="rw" name="tbsize_init" pos="13:0" rst="0x0">
          <comment>PUSCH模块使能时表示PUSCH传输块大小，即传输块CRC添加前的数据量，单位为bit</comment>
        </bits>
      </reg>
      <reg name="tbsize" protect="rw">
        <comment>传输块大小数据量寄存器</comment>
        <bits access="rw" name="tbsize" pos="13:0" rst="0x0">
          <comment>PUSCH模块使能时表示PUSCH传输块大小，即传输块CRC添加前的数据量，单位为bit</comment>
        </bits>
      </reg>
      <reg name="modulate" protect="rw">
        <comment>调制方式寄存器</comment>
        <bits access="rw" name="modulate" pos="1:0" rst="0x0">
          <comment>00：BPSK
01：QPSK
10：16QAM
11：64QAM</comment>
        </bits>
      </reg>
      <reg name="redun_ver" protect="rw">
        <comment>冗余版本号</comment>
        <bits access="rw" name="redun_ver" pos="1:0" rst="0x0">
          <comment>冗余版本号</comment>
        </bits>
      </reg>
      <reg name="lcrb" protect="rw">
        <comment>PUSCH及初传PUSCH占用的带宽（子载波个数）</comment>
        <bits access="rw" name="ini_sub_num" pos="26:16" rst="0x0">
          <comment>初传PUSCH占用的带宽（子载波个数）</comment>
        </bits>
        <bits access="rw" name="sub_num" pos="10:0" rst="0x0">
          <comment>当前PUSCH占用的带宽（子载波个数）</comment>
        </bits>
      </reg>
      <reg name="symbol_num" protect="rw">
        <comment>PUSCH及初传PUSCH占用的符号个数</comment>
        <bits access="rw" name="ru_num" pos="11:8" rst="0x0">
          <comment>RU个数</comment>
        </bits>
        <bits access="rw" name="ini_sym_num" pos="7:4" rst="0x0">
          <comment>初传PUSCH占用符号数：对于CAT1/CATM，
表示1个子帧占用的PUSCH DATA的符号个
数；对于CAT-NB，表示1个RU占用的符号个数</comment>
        </bits>
        <bits access="rw" name="sym_num" pos="3:0" rst="0x0">
          <comment>当前PUSCH占用符号数：对于CAT1/CATM，表示1个子帧占用的
PUSCH DATA的符号个数；对于CAT-NB，
表示1个RU占用的符号个数</comment>
        </bits>
      </reg>
      <reg name="cqi_bit1" protect="rw">
        <comment>CQI信息比特数据寄存器</comment>
      </reg>
      <reg name="cqi_bit2" protect="rw">
        <comment>CQI信息比特数据寄存器</comment>
      </reg>
      <reg name="cqi_bit8_bitlen" protect="rw">
        <comment>CQI信息比特数据及比特长度寄存器</comment>
        <bits access="rw" name="o_cqi_bitlen_min" pos="22:16" rst="0x0">
          <comment>编码前CQI信息最小比特长度</comment>
        </bits>
        <bits access="rw" name="o_cqi_bitlen" pos="14:8" rst="0x0">
          <comment>编码前CQI信息比特长度，最大为65</comment>
        </bits>
        <bits access="rw" name="cqi_bit8" pos="0" rst="0x0">
          <comment>编码前CQI信息比特位64</comment>
        </bits>
      </reg>
      <reg name="ri_bit_bitlen" protect="rw">
        <comment>RI信息比特数据及比特长度寄存器</comment>
        <bits access="rw" name="o_ri_bitlen" pos="16" rst="0x0">
          <comment>编码前RI信息比特长度</comment>
        </bits>
        <bits access="rw" name="ri_bit" pos="0" rst="0x0">
          <comment>编码前RI信息</comment>
        </bits>
      </reg>
      <reg name="ack_bit_bitlen" protect="rw">
        <comment>ACK信息比特数据及比特长度寄存器</comment>
        <bits access="rw" name="o_ack_bitlen" pos="26:24" rst="0x0">
          <comment>编码前ACK信息比特长度，最大为4</comment>
        </bits>
        <bits access="rw" name="ack_bit" pos="3:0" rst="0x0">
          <comment>编码前ACK信息</comment>
        </bits>
      </reg>
      <reg name="ack_mux_bundling" protect="rw">
        <comment>ACK编码复用绑定选择及扰码序列指示寄存器</comment>
        <bits access="rw" name="bundling_flag" pos="2" rst="0x0">
          <comment>0：FDD或TDD的HARQ-ACK复用模式
1：TDD的HARQ-ACK绑定模式</comment>
        </bits>
        <bits access="rw" name="bundling_idx" pos="1:0" rst="0x0">
          <comment>TDD HARQ-ACK绑定模式时，扰码序列的选择索引值</comment>
        </bits>
      </reg>
      <reg name="pucch_format" protect="rw">
        <comment>PUCCH格式寄存器</comment>
        <bits access="rw" name="format" pos="2:0" rst="0x0">
          <comment>PUCCH格式
000~010：RESERVED
011：格式2
100：格式2a
101：格式2b
110~111：RESERVED</comment>
        </bits>
      </reg>
      <reg name="prach_u" protect="rw">
        <comment>U和U逆寄存器</comment>
        <bits access="rw" name="u_inv_value" pos="25:16" rst="0x0">
          <comment>U逆的值</comment>
        </bits>
        <bits access="rw" name="u_value" pos="9:0" rst="0x0">
          <comment>U值</comment>
        </bits>
      </reg>
      <reg name="prach_cv" protect="rw">
        <comment>CV寄存器</comment>
        <bits access="rw" name="cv_value" pos="9:0" rst="0x0">
          <comment>CV值</comment>
        </bits>
      </reg>
      <reg name="gold_init" protect="rw">
        <comment>生成GOLD序列时第二个序列的初始值寄存器</comment>
        <bits access="rw" name="gold_init" pos="30:0" rst="0x0">
          <comment>生成GOLD序列时，第二个序列的初始值</comment>
        </bits>
      </reg>
      <reg name="pusch_ctrl" protect="rw">
        <comment>控制寄存器</comment>
        <bits access="rw" name="pusch2dft_trig_en" pos="17" rst="0x0">
          <comment>1：使能PUSCH模块运算完毕后硬件启动ULDFT模块
0：不使能PUSCH模块运算完毕后硬件启动ULDFT模块</comment>
        </bits>
        <bits access="rw" name="func_sel" pos="16:15" rst="0x0">
          <comment>00：启动PUSCH运算
01：启动PUCCH UCI编码加扰运算
10：启动PRACH运算
11：启动NPUSCH格式1（NPUSCH格式2不调用PUSCH IP）</comment>
        </bits>
        <bits access="rw" name="uci_en" pos="14" rst="0x0">
          <comment>与FUNC_SEL联合配置，选择PUSCH UCI或PUCCH UCI，FUNC_SEL为‘00’时选择PUSCH UCI，FUNC_SEL为‘01’时选择PUCCH UCI：
0：不启动UCI编码运算
1：启动UCI编码运算</comment>
        </bits>
        <bits access="rw" name="buf_index" pos="13:12" rst="0x0">
          <comment>PUSCH_BUFFER中MEM序号指示
00：PUSCH_BUF1；
01：PUSCH_BUF2；
10：PUSCH_BUF3；
11：PRACH_BUF；</comment>
        </bits>
        <bits access="rw" name="pusch_buf_en" pos="11" rst="0x0">
          <comment>0：不启动PUSCH_BUFFER功能；
1：启动PUSCH_BUFFER功能；</comment>
        </bits>
        <bits access="rw" name="zc_index" pos="9" rst="0x0">
          <comment>PRACH中ZC序列长度指示
0：ZC序列长度为139；
1：ZC序列长度为839；</comment>
        </bits>
        <bits access="rw" name="inver_en" pos="7" rst="0x0">
          <comment>0：PUSCH中的CRC不对输入数据进行Byte反转
1：PUSCH中的CRC对输入数据进行Byte反转</comment>
        </bits>
        <bits access="rw" name="pusch_irqen" pos="5" rst="0x0">
          <comment>0：LTE模式下模块中断不使能
1：LTE模式下模块中断使能</comment>
        </bits>
        <bits access="rw" name="scr_en" pos="4" rst="0x0">
          <comment>0：不启动PUSCH的信道加扰
1：启动PUSCH的信道加扰</comment>
        </bits>
        <bits access="rw" name="int_en" pos="3" rst="0x0">
          <comment>0：不启动PUSCH的信道交织
1：启动PUSCH的信道交织</comment>
        </bits>
        <bits access="rw" name="tb_rm_en" pos="2" rst="0x0">
          <comment>0：不启动PUSCH的Turbo编码和速率匹配
1：启动PUSCH的Turbo编码和速率匹配</comment>
        </bits>
        <bits access="rw" name="crc_en" pos="1" rst="0x0">
          <comment>0：不启动PUSCH的CRC
1：启动PUSCH的CRC</comment>
        </bits>
        <bits access="rw" name="fun_en" pos="0" rst="0x0">
          <comment>0：不启动功能模块（LTE模式）
1：启动功能模块（LTE模式）</comment>
        </bits>
      </reg>
      <reg name="pusch_irq_flag" protect="rw">
        <comment>中断标志寄存器</comment>
        <bits access="rc" name="irq_flag" pos="0" rst="0x0">
          <comment>中断标志
0：功能模块未完成
1：功能模块完成，中断指示</comment>
        </bits>
      </reg>
      <reg name="pucch_res" protect="rw">
        <comment>PUCCH format2/2a/2b UCI编码加扰结果</comment>
        <bits access="r" name="res_uci" pos="21:0" rst="0x0">
          <comment>PUCCH format2/2a/2b UCI编码加扰结果</comment>
        </bits>
      </reg>
      <hole size="523584"/>
      <reg name="mem1" protect="rw">
        </reg>
      <hole size="131040"/>
      <reg name="mem2" protect="rw">
        </reg>
      <hole size="131040"/>
      <reg name="mem3" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="pusch_buf1" protect="rw">
        </reg>
      <hole size="131040"/>
      <reg name="pusch_buf2" protect="rw">
        </reg>
      <hole size="131040"/>
      <reg name="pusch_buf3" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="prach_buf" protect="rw">
        </reg>
    </module>
    <instance address="0x18800000" name="PUSCH" type="PUSCH"/>
  </archive>
  <archive relative="ldtc1.xml">
    <module category="System" name="LDTC1">
      <reg name="csys_para_nxt" protect="rw">
        <comment>CTRL系统参数寄存器</comment>
        <bits access="rw" name="schd_sib1" pos="30:26" rst="0x0">
          <comment>Schedule SIB1 BR R13（PBML使能时需要配置）</comment>
        </bits>
        <bits access="rw" name="phi_res" pos="25:24" rst="0x0">
          <comment>PHICH resource（PBML使能时需要配置）</comment>
        </bits>
        <bits access="rw" name="phi_dur" pos="23" rst="0x0">
          <comment>PHICH duration（PBML使能时需要配置）</comment>
        </bits>
        <bits access="rw" name="bw_ind_ul" pos="22:20" rst="0x0">
          <comment>上行带宽指示：
0：1.4Mhz
1：3Mhz；
2：5Mhz；
3：10Mhz；
4：15Mhz；
5：20Mhz
6~7：预留（保护成配置5）</comment>
        </bits>
        <bits access="rw" name="ng_ind" pos="19:18" rst="0x0">
          <comment>Ng的指示：
0：1/6
1：1/2
2：1
3：2</comment>
        </bits>
        <bits access="rw" name="tm_mode" pos="17:14" rst="0x0">
          <comment>传输模式：
1~:9：tm1,tm2,…,tm9</comment>
        </bits>
        <bits access="rw" name="ss_conf" pos="13:10" rst="0x0">
          <comment>TDD模式时，特殊子帧配置：0~9（无效保
护成9）</comment>
        </bits>
        <bits access="rw" name="uldl_conf" pos="9:7" rst="0x0">
          <comment>上下行配置：0~6（无效保护成6）</comment>
        </bits>
        <bits access="rw" name="bw_ind" pos="6:4" rst="0x0">
          <comment>带宽指示：
0：1.4Mhz
1：3Mhz；
2：5Mhz；
3：10Mhz；
4：15Mhz；
5：20Mhz
6~7：预留（保护成配置5）</comment>
        </bits>
        <bits access="rw" name="ant_tx" pos="3:2" rst="0x0">
          <comment>发射天线数：
0：1发射天线
1：2发射天线
2：4发射天线
3：预留（保护成配置2）</comment>
        </bits>
        <bits access="rw" name="cp_ind" pos="1" rst="0x0">
          <comment>CP类型：
0：常规CP
1：扩展CP</comment>
        </bits>
        <bits access="rw" name="fdd_tdd" pos="0" rst="0x0">
          <comment>FDD或TDD指示：
0：TDD
1：FDD</comment>
        </bits>
      </reg>
      <reg name="cnid_cell_nxt" protect="rw">
        <comment>CTRL小区ID寄存器</comment>
        <bits access="rw" name="nid_cell" pos="8:0" rst="0x0">
          <comment>小区ID：0~503</comment>
        </bits>
      </reg>
      <reg name="dsys_para_nxt" protect="rw">
        <comment>CTRL系统参数寄存器</comment>
        <bits access="rw" name="bw_ind_ul" pos="22:20" rst="0x0">
          <comment>上行带宽指示：
0：1.4Mhz
1：3Mhz；
2：5Mhz；
3：10Mhz；
4：15Mhz；
5：20Mhz
6~7：预留（保护成配置5）</comment>
        </bits>
        <bits access="rw" name="ng_ind" pos="19:18" rst="0x0">
          <comment>Ng的指示：
0：1/6
1：1/2
2：1
3：2</comment>
        </bits>
        <bits access="rw" name="tm_mode" pos="17:14" rst="0x0">
          <comment>传输模式：
1~:9：tm1,tm2,…,tm9</comment>
        </bits>
        <bits access="rw" name="ss_conf" pos="13:10" rst="0x0">
          <comment>TDD模式时，特殊子帧配置：0~9（无效保护成9）</comment>
        </bits>
        <bits access="rw" name="uldl_conf" pos="9:7" rst="0x0">
          <comment>上下行配置：0~6（无效保护成6）</comment>
        </bits>
        <bits access="rw" name="bw_ind" pos="6:4" rst="0x0">
          <comment>带宽指示：
0：1.4Mhz
1：3Mhz；
2：5Mhz；
3：10Mhz；
4：15Mhz；
5：20Mhz
6~7：预留（保护成配置5）</comment>
        </bits>
        <bits access="rw" name="ant_tx" pos="3:2" rst="0x0">
          <comment>发射天线数：
0：1发射天线
1：2发射天线
2：4发射天线
3：预留（保护成配置2）</comment>
        </bits>
        <bits access="rw" name="cp_ind" pos="1" rst="0x0">
          <comment>CP类型：
0：常规CP
1：扩展CP</comment>
        </bits>
        <bits access="rw" name="fdd_tdd" pos="0" rst="0x0">
          <comment>FDD或TDD指示：
0：TDD
1：FDD</comment>
        </bits>
      </reg>
      <reg name="dnid_cell_nxt" protect="rw">
        <comment>CTRL小区ID寄存器</comment>
        <bits access="rw" name="nid_cell" pos="8:0" rst="0x0">
          <comment>MBSFN ID：0~255
小区ID：0~503</comment>
        </bits>
      </reg>
      <reg name="ra_t_rnti" protect="rw">
        <comment>RA-RNTI/TEMP-C-RNTI寄存器</comment>
        <bits access="rw" name="t_rnti" pos="31:16" rst="0x0">
          <comment>Temp-C-RNTI</comment>
        </bits>
        <bits access="rw" name="ra_rnti" pos="15:0" rst="0x0">
          <comment>RA_RNTI</comment>
        </bits>
      </reg>
      <reg name="c_sps_rnti" protect="rw">
        <comment>C-RNTI/SPS-C-RNTI寄存器</comment>
        <bits access="rw" name="sps_rnti" pos="31:16" rst="0x0">
          <comment>SPS_RNTI</comment>
        </bits>
        <bits access="rw" name="c_rnti" pos="15:0" rst="0x0">
          <comment>C_RNTI</comment>
        </bits>
      </reg>
      <reg name="tpc_rnti" protect="rw">
        <comment>TPC-PUCCH-RNTI/TPC-PUSCH-RNTI寄存器</comment>
        <bits access="rw" name="tpcs_rnti" pos="31:16" rst="0x0">
          <comment>TPC-PUCSH-RNTI</comment>
        </bits>
        <bits access="rw" name="tpcc_rnti" pos="15:0" rst="0x0">
          <comment>TPC-PUCCH-RNTI</comment>
        </bits>
      </reg>
      <reg name="g_rnti" protect="rw">
        <comment>G_RNTI寄存器</comment>
        <bits access="rw" name="g_rnti" pos="15:0" rst="0x0">
          <comment>G_RNTI</comment>
        </bits>
      </reg>
      <reg name="csi_rsmap0_nxt" protect="rw">
        <comment>CSI的RS分布配置寄存器0</comment>
        <bits access="rw" name="csirs_group2" pos="23:12" rst="0x0">
          <comment>第2组时域上，一个PRB的CSI-RS的分布指
示，同CSIRS_GROUP1。</comment>
        </bits>
        <bits access="rw" name="csirs_group1" pos="11:0" rst="0x0">
          <comment>第1组时域上，一个PRB的CSI-RS的分布指
示，第0比特到11比特分别指示PRB中RE#0
到RE#11。如果第0比特为1表示RE#0为
CSI-RS，反之则否。</comment>
        </bits>
      </reg>
      <reg name="csi_rsmap1_nxt" protect="rw">
        <comment>CSI的RS分布配置寄存器1</comment>
        <bits access="rw" name="csirs_jump" pos="30:24" rst="0x0">
          <comment>子帧内含CSI-RS的OFDM符号对业务1（PDSCH业务）的处理指示。Norm-CP时，24到30比特分别表示OFDM#5、6、8、9、10、12和13；Ext-CP时，24到29比特分别表示OFDM#4、5、7、8、10和11；以Norm-CP的第24比特进行说明，如果为1表示OFDM#5上视业务1为不存在；如果为0表示OFDM#5上业务1的数据应避开CSI-RS所占的子载波位置。</comment>
        </bits>
        <bits access="rw" name="csirs_group4" pos="23:12" rst="0x0">
          <comment>第4组时域上，一个PRB的CSI-RS的分布指示，同CSIRS_GROUP1。</comment>
        </bits>
        <bits access="rw" name="csirs_group3" pos="11:0" rst="0x0">
          <comment>第3组时域上，一个PRB的CSI-RS的分布指示，同CSIRS_GROUP1。</comment>
        </bits>
      </reg>
      <reg name="pmi_cfg" protect="rw">
        <comment>PMI配置寄存器</comment>
        <bits access="rw" name="pmi_cbsr" pos="15:0" rst="0x0">
          <comment>PMI 码本限制集(codebookSubsetRestriction)：
0：PMI表对应bit的行需要计算
1：PMI表对应bit的行不需要计算</comment>
        </bits>
      </reg>
      <reg name="pcfi_cfg_nxt" protect="rw">
        <comment>PDCCH配置寄存器</comment>
        <bits access="rw" name="cfi_val" pos="3:0" rst="0x7">
          <comment>每个BIT分布标识：
Bit0:1个OFDM符号CFI
Bit1:2个OFDM符号CFI
Bit2:3个OFDM符号CFI
Bit3:4个OFDM符号CFI
0：无效
1：有效</comment>
        </bits>
      </reg>
      <reg name="phi_cfg_nxt" protect="rw">
        <comment>PHICH配置寄存器</comment>
        <bits access="rw" name="hi_cond" pos="23:22" rst="0x0">
          <comment>HI的OFDM条件选择：0~3</comment>
        </bits>
        <bits access="rw" name="phi1_en" pos="21" rst="0x0">
          <comment>PHICH1使能：
0：使能
1：不使能</comment>
        </bits>
        <bits access="rw" name="phi1_seqnum" pos="20:18" rst="0x0">
          <comment>PHICH1序列号：0~7</comment>
        </bits>
        <bits access="rw" name="phi1_grpnum" pos="17:11" rst="0x0">
          <comment>PHICH1组号：0~99</comment>
        </bits>
        <bits access="rw" name="phi0_en" pos="10" rst="0x0">
          <comment>PHICH0使能：
0：使能
1：不使能</comment>
        </bits>
        <bits access="rw" name="phi0_seqnum" pos="9:7" rst="0x0">
          <comment>PHICH0序列号：0~7</comment>
        </bits>
        <bits access="rw" name="phi0_grpnum" pos="6:0" rst="0x0">
          <comment>PHICH0组号：0~99</comment>
        </bits>
      </reg>
      <reg name="pdcch_cfg_nxt" protect="rw">
        <comment>PDCCH配置寄存器</comment>
        <bits access="rw" name="dcilen_ue1" pos="31:26" rst="0x0">
          <comment>UE空间DCI第二个长度：max57</comment>
        </bits>
        <bits access="rw" name="dcilen_ue0" pos="25:20" rst="0x0">
          <comment>UE空间DCI第一个长度：max57</comment>
        </bits>
        <bits access="rw" name="dcilen_comm1" pos="19:14" rst="0x0">
          <comment>COMM空间DCI第二个长度：max57</comment>
        </bits>
        <bits access="rw" name="dcilen_comm0" pos="13:8" rst="0x0">
          <comment>COMM空间DCI第一个长度：max57</comment>
        </bits>
        <bits access="rw" name="dcilen_sel" pos="7" rst="0x0">
          <comment>DCILEN选择：
0：硬件表格
1：软件配置</comment>
        </bits>
        <bits access="rw" name="pus_enh" pos="6" rst="0x0">
          <comment>PUSCH增强使能：
0：DCI0
1：DCI0C</comment>
        </bits>
        <bits access="rw" name="csi_sel" pos="5" rst="0x0">
          <comment>CSI长度选择：
0：1
1：2</comment>
        </bits>
        <bits access="rw" name="antsel_en" pos="4" rst="0x0">
          <comment>天线选择使能：
0：天线选择不使能
1：天线选择使能</comment>
        </bits>
        <bits access="rw" name="srs_act" pos="3" rst="0x0">
          <comment>SRS激活：
0：无DCI中SRS_REQ域
1：有DCI中SRS_REQ域</comment>
        </bits>
        <bits access="rw" name="pdcch_det_num" pos="2:0" rst="0x4">
          <comment>PDCCH盲检个数：
0:1
1:2
2:3
3:4
…
7：8</comment>
        </bits>
      </reg>
      <reg name="pdsch0_cfg_nxt" protect="rw">
        <comment>PDSCH –C/RA/T相关输入信息寄存器</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>选择使用上报的PMI，还是选择使用DCI下发的PMI：
0：选择使用DCI下发的PMI
1：选择使用上报的PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ进程:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>预编码指示：tx2:0~3，tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>传输方案：
0：单天线
1：发射分集
2：空间复用
3：PORT7
4：PORT8
5：PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid的值(UE业务加扰用)：0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="modu" pos="15:14" rst="0x0">
          <comment>调制格式：
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tbsize" pos="13:0" rst="0x0">
          <comment>传输块长度：max12216</comment>
        </bits>
      </reg>
      <reg name="pdsch1_cfg_nxt" protect="rw">
        <comment>PDSCH -SI相关输入信息寄存器</comment>
        <bits access="rw" name="ra_type" pos="16" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="15:14" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="tbsize" pos="13:0" rst="0x0">
          <comment>传输块长度：max2216</comment>
        </bits>
      </reg>
      <reg name="pdsch2_cfg_nxt" protect="rw">
        <comment>PDSCH -PAGING相关输入信息寄存器</comment>
        <bits access="rw" name="ra_type" pos="16" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="15:14" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="tbsize" pos="13:0" rst="0x0">
          <comment>传输块长度：max2216</comment>
        </bits>
      </reg>
      <reg name="frame_ccnt_nxt" protect="rw">
        <comment>CTRL帧号寄存器</comment>
        <bits access="rw" name="ssfn_cnt" pos="31:16" rst="0x0">
          <comment>超帧号：0~65535</comment>
        </bits>
        <bits access="rw" name="rf_cnt" pos="13:4" rst="0x0">
          <comment>无线帧号:0~1023</comment>
        </bits>
        <bits access="rw" name="sf_cnt" pos="3:0" rst="0x0">
          <comment>子帧号:0~9</comment>
        </bits>
      </reg>
      <reg name="frame_dcnt_nxt" protect="rw">
        <comment>DATA帧号寄存器</comment>
        <bits access="rw" name="ssfn_cnt" pos="31:16" rst="0x0">
          <comment>超帧号：0~65535</comment>
        </bits>
        <bits access="rw" name="rf_cnt" pos="13:4" rst="0x0">
          <comment>无线帧号:0~1023</comment>
        </bits>
        <bits access="rw" name="sf_cnt" pos="3:0" rst="0x0">
          <comment>子帧号:0~9</comment>
        </bits>
      </reg>
      <reg name="ldtc1_cserv_nxt" protect="rw">
        <comment>LDTC CTRL业务配置寄存器</comment>
        <bits access="rw" name="sc_n_rnti_en" pos="10" rst="0x0">
          <comment>SC-N-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="sc_rnti_en" pos="9" rst="0x0">
          <comment>SC-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="g_rnti_en" pos="8" rst="0x0">
          <comment>G-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="tpcc_rnti_en" pos="7" rst="0x0">
          <comment>TPC-PUCCH-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="tpcs_rnti_en" pos="6" rst="0x0">
          <comment>TPC-PUSCH-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="t_rnti_en" pos="5" rst="0x0">
          <comment>Temp-C-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="sps_rnti_en" pos="4" rst="0x0">
          <comment>SPS-C-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="c_rnti_en" pos="3" rst="0x0">
          <comment>C-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="ra_rnti_en" pos="2" rst="0x0">
          <comment>RA-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="p_rnti_en" pos="1" rst="0x0">
          <comment>P-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="si_rnti_en" pos="0" rst="0x0">
          <comment>SI-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="ldtc1_dserv_nxt" protect="rw">
        <comment>LDTC DATA业务配置寄存器</comment>
        <bits access="rw" name="sc_rnti_en" pos="7" rst="0x0">
          <comment>SC-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="g_rnti_en" pos="6" rst="0x0">
          <comment>G-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="t_rnti_en" pos="5" rst="0x0">
          <comment>Temp-C-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="sps_rnti_en" pos="4" rst="0x0">
          <comment>SPS-C-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="c_rnti_en" pos="3" rst="0x0">
          <comment>C-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="ra_rnti_en" pos="2" rst="0x0">
          <comment>RA-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="p_rnti_en" pos="1" rst="0x0">
          <comment>P-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="si_rnti_en" pos="0" rst="0x0">
          <comment>SI-RNTI使能：
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="ldtc1_cctrl_nxt" protect="rw">
        <comment>LDTC CTRL控制寄存器</comment>
        <bits access="rw" name="dma_s_en" pos="14" rst="0x0">
          <comment>SINR DMA触发使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="dma_m_en" pos="13" rst="0x0">
          <comment>PMI DMA触发使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="int_s_en" pos="12" rst="0x0">
          <comment>SINR中断使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="int_m_en" pos="11" rst="0x0">
          <comment>PMI中断使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="int_c_en" pos="10" rst="0x0">
          <comment>PDCCH中断使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="int_b_en" pos="9" rst="0x0">
          <comment>PBCH中断使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="mbms_sf" pos="8" rst="0x0">
          <comment>MBMS子帧指示：
0：非MBMS子帧
1：MBMS子帧</comment>
        </bits>
        <bits access="rw" name="cqfqt_ppsel" pos="7:6" rst="0x0">
          <comment>CTRL QFQT乒乓选择：
0：第1块乒
1：第2块乓
2：第3块</comment>
        </bits>
        <bits access="rw" name="pbch_first" pos="5" rst="0x0">
          <comment>PBCH计算的起始：
0：非起始
1：起始</comment>
        </bits>
        <bits access="rw" name="sinr_en" pos="4" rst="0x0">
          <comment>SINR使能：
0：使能
1：不使能</comment>
        </bits>
        <bits access="rw" name="pmi_en" pos="3" rst="0x0">
          <comment>PMI计算使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="hi_en" pos="2" rst="0x0">
          <comment>HI计算使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="pdcch_en" pos="1" rst="0x0">
          <comment>PDCCH使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="pbch_en" pos="0" rst="0x0">
          <comment>PBCH使能：
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="ldtc1_dctrl_nxt" protect="rw">
        <comment>LDTC DATA控制寄存器</comment>
        <bits access="rw" name="dma_d_en" pos="8" rst="0x0">
          <comment>PDSCH DMA触发使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="int_d_en" pos="7" rst="0x0">
          <comment>PDSCH中断使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="dqfqt_ppsel" pos="6:5" rst="0x0">
          <comment>DATA QFQT乒乓选择：
0：第1块乒
1：第2块乓
2：第3块</comment>
        </bits>
        <bits access="rw" name="csirs_en" pos="4" rst="0x0">
          <comment>CSIRS使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="sihqbuf_sel" pos="3" rst="0x0">
          <comment>SI的HQBUF选择：
0：选择HQBUF0
1：选择HQBUF1</comment>
        </bits>
        <bits access="rw" name="si_first" pos="2" rst="0x0">
          <comment>PDSCH计算的起始：
0：非起始
1：起始</comment>
        </bits>
        <bits access="rw" name="pds_first" pos="1" rst="0x0">
          <comment>PDS计算的起始：
0：非起始
1：起始</comment>
        </bits>
        <bits access="rw" name="pdsch_en" pos="0" rst="0x0">
          <comment>PDSCH使能：
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="ldtc1_cstart" protect="rw">
        <comment>LDTC CTRL启动寄存器</comment>
        <bits access="rw" name="ldtc_cstart" pos="0" rst="0x0">
          <comment>启动LDTC模块：
0：不启动或者已经启动并清除
1：启动</comment>
        </bits>
      </reg>
      <reg name="ldtc1_dstart" protect="rw">
        <comment>LDTC DATA启动寄存器</comment>
        <bits access="rw" name="ldtc_dstart" pos="0" rst="0x0">
          <comment>启动LDTC模块：
0：不启动或者已经启动并清除
1：启动</comment>
        </bits>
      </reg>
      <reg name="ctrl_flag" protect="rw">
        <comment>CTRL标志寄存器</comment>
        <bits access="rc" name="dci_valid" pos="15:8" rst="0x0">
          <comment>DCI当前子帧检出有效标识：
0：无DCI检出；
1：对应比特的DCI当前子帧检出有效</comment>
        </bits>
        <bits access="rc" name="mib_valid" pos="7:4" rst="0x0">
          <comment>MIB当前子帧检出有效标识：
0：无MIB检出；
1：对应比特的MIB当前子帧检出有效</comment>
        </bits>
        <bits access="rc" name="int_sflag" pos="3" rst="0x0">
          <comment>SINR完成标志：
0：无中断
1：中断</comment>
        </bits>
        <bits access="rc" name="int_mflag" pos="2" rst="0x0">
          <comment>PMI完成标志：
0：无中断
1：中断</comment>
        </bits>
        <bits access="rc" name="int_cflag" pos="1" rst="0x0">
          <comment>PDCCH完成标志：
0：无中断
1：中断</comment>
        </bits>
        <bits access="rc" name="int_bflag" pos="0" rst="0x0">
          <comment>PBCH完成标志：
0：无中断
1：中断</comment>
        </bits>
      </reg>
      <reg name="data_flag" protect="rw">
        <comment>DATA标志寄存器</comment>
        <bits access="rc" name="paging_zero_flag" pos="6" rst="0x0">
          <comment>PAGING译码结果数据（含CRC校验位），全零标志：
0：数据不为全零
1：数据为全零</comment>
        </bits>
        <bits access="rc" name="paging_crc_flag" pos="5" rst="0x1">
          <comment>PAGING译码CRC标志：
0：CRC校验正确
1：CRC校验错误</comment>
        </bits>
        <bits access="rc" name="si_zero_flag" pos="4" rst="0x0">
          <comment>SI译码结果数据（含CRC校验位），全零标志：
0：数据不为全零
1：数据为全零</comment>
        </bits>
        <bits access="rc" name="si_crc_flag" pos="3" rst="0x1">
          <comment>SI译码CRC标志：
0：CRC校验正确
1：CRC校验错误</comment>
        </bits>
        <bits access="rc" name="pdsch_zero_flag" pos="2" rst="0x0">
          <comment>PDSCH 译码结果数据（含CRC校验位），全零标志：
0：数据不为全零
1：数据为全零</comment>
        </bits>
        <bits access="rc" name="pdsch_crc_flag" pos="1" rst="0x1">
          <comment>PDSCH 译码CRC标志：
0：CRC校验正确
1：CRC校验错误</comment>
        </bits>
        <bits access="rc" name="int_dflag" pos="0" rst="0x0">
          <comment>PDSCH完成标志：
0：无中断
1：中断</comment>
        </bits>
      </reg>
      <reg name="buf_flag" protect="rw">
        <comment>BUF指示寄存器</comment>
        <bits access="r" name="dfh_ind" pos="3" rst="0x0">
          <comment>FH的data使用指示：
0：使用FH0
1：使用FH1</comment>
        </bits>
        <bits access="r" name="cfh_ind" pos="2" rst="0x0">
          <comment>FH的ctrl使用指示：
0：使用FH0
1：使用FH1</comment>
        </bits>
        <bits access="r" name="dschout_ind" pos="1" rst="0x0">
          <comment>DSCHOUT使用指示：
0：使用DSCHOUT0
1：使用DSCHOUT1</comment>
        </bits>
        <bits access="r" name="fftbuf_ind" pos="0" rst="0x0">
          <comment>FFTBUF使用指示：
0：使用FFTBUF0
1：使用FFTBUF1</comment>
        </bits>
      </reg>
      <reg name="alg_comm_para" protect="rw">
        <comment>ALG_COMM_PARA通用参数寄存器</comment>
        <bits access="rw" name="pdc_th" pos="16:11" rst="0x0">
          <comment>PDCCH归一化策略门限个数</comment>
        </bits>
        <bits access="rw" name="g_scale" pos="10:8" rst="0x4">
          <comment>G的Q值调整因子：
0：Q15
1：Q16
…
7：Q22</comment>
        </bits>
        <bits access="rw" name="cc_ir" pos="7" rst="0x0">
          <comment>HQ 合并方式选择：
0：CC合并
1：IR合并</comment>
        </bits>
        <bits access="rw" name="hqbit_sel" pos="6" rst="0x0">
          <comment>HQ BUF的比特位宽的大小：
0：4bit
1：6bit</comment>
        </bits>
        <bits access="rw" name="sdgn_sel" pos="5" rst="0x0">
          <comment>SD使用G或者noise进行信号检测计算：
0：用noise计算
1：用GM矩阵</comment>
        </bits>
        <bits access="rw" name="subbw_sel" pos="4" rst="0x0">
          <comment>PMI/PWR子带宽带选择：
0：小带宽
1：大带宽
具体见下表描述</comment>
        </bits>
        <bits access="rw" name="ctcg_sel" pos="3" rst="0x0">
          <comment>CTCG起始位置选择：
0：从OFDM4(包括OFDM4)前有效CRS为样本
1：从OFDM8(包括OFDM8)前有效CRS为样本</comment>
        </bits>
        <bits access="rw" name="crs_g_len" pos="2" rst="0x0">
          <comment>CRS G的长度选择：
0：1PRB
1：2PRB</comment>
        </bits>
        <bits access="rw" name="crs_fh_len" pos="1" rst="0x0">
          <comment>CRS频域估计滑动窗长（3或6 PRB）
0：3PRB
1：6PRB</comment>
        </bits>
        <bits access="rw" name="ue_bund" pos="0" rst="0x0">
          <comment>UE RS时，处理PRB的个数，取值为1,3
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="che_fh_para" protect="rw">
        <comment>CHE频域参数寄存器</comment>
        <bits access="rw" name="fh10_bitsel_type" pos="7" rst="0x1">
          <comment>乘累加后由16bit数据截取为10bit数据的截取方式选择
0：按接口寄存器配置直接截位
1：最大值归一化截位</comment>
        </bits>
        <bits access="rw" name="fh10_bitsel" pos="6:4" rst="0x0">
          <comment>乘累加后由16bit数据截取为10bit数据的比特选择：
0x0：截取选择15~6
0x1：截取选择14~5
0x2：截取选择13~4
0x3：截取选择12~3
0x4：截取选择11~2
0x5：截取选择10~1
0x6：截取选择9~0
其他：reserved，不可配置</comment>
        </bits>
        <bits access="rw" name="fh16_bitsel" pos="3:0" rst="0x6">
          <comment>乘累加后截取16bit数据的比特选择：
0x0：截取选择28~13
0x1：截取选择27~12
0x2：截取选择26~11
0x3：截取选择25~10
0x4：截取选择24~9
0x5：截取选择23~8
0x6：截取选择22~7
0x7：截取选择21~6
0x8：截取选择20~5
0x9：截取选择19~4
0xa：截取选择18~3
0xb：截取选择17~2
0xc：截取选择16~1
0xd：截取选择15~0
其他：Reserved</comment>
        </bits>
      </reg>
      <reg name="che_th_para" protect="rw">
        <comment>CHE时域参数寄存器</comment>
        <bits access="rw" name="th16_bitsel" pos="3:0" rst="0x5">
          <comment>时域估计乘累加后截取比特选择：
0x0：截取选择25~10
0x1：截取选择24~9
0x2：截取选择23~8
0x3：截取选择22~7
0x4：截取选择21~6
0x5：截取选择20~5
0x6：截取选择19~4
0x7：截取选择18~3
0x8：截取选择17~2
0x9：截取选择16~1
0xa：截取选择15~0</comment>
        </bits>
      </reg>
      <reg name="rbbm_pds00_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pds01_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pds02_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pds03_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
        <bits access="rw" name="rbbm_nxt_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit[99:96]表示不同的prb，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="rbbm_pds10_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pds11_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pds12_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pds13_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
        <bits access="rw" name="rbbm_nxt_13" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit[99:96]表示不同的prb，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="rbbm_si00_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_si01_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_si02_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_si03_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
        <bits access="rw" name="rbbm_nxt_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit表示不同的prb，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="rbbm_si10_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_si11_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_si12_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_si13_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
        <bits access="rw" name="rbbm_nxt_13" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit[99:96]表示不同的prb，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="rbbm_pag00_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pag01_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pag02_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pag03_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
        <bits access="rw" name="rbbm_nxt_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit[99:96]表示不同的prb，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="rbbm_pag10_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pag11_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pag12_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
      </reg>
      <reg name="rbbm_pag13_nxt" protect="rw">
        <comment>资源占用信息寄存器</comment>
        <bits access="rw" name="rbbm_nxt_13" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit[99:96]表示不同的prb，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="pmi_pds0_nxt" protect="rw">
        <comment>码本索引寄存器</comment>
        <bits access="rw" name="pmi_8" pos="31:28" rst="0x0">
          <comment>子带8的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_7" pos="27:24" rst="0x0">
          <comment>子带7的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_6" pos="23:20" rst="0x0">
          <comment>子带6的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_5" pos="19:16" rst="0x0">
          <comment>子带5的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_4" pos="15:12" rst="0x0">
          <comment>子带4的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_3" pos="11:8" rst="0x0">
          <comment>子带3的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_2" pos="7:4" rst="0x0">
          <comment>子带2的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_1" pos="3:0" rst="0x0">
          <comment>子带1的码本索引</comment>
        </bits>
      </reg>
      <reg name="pmi_pds1_nxt" protect="rw">
        <comment>码本索引寄存器</comment>
        <bits access="rw" name="pmi_16" pos="31:28" rst="0x0">
          <comment>子带16的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_15" pos="27:24" rst="0x0">
          <comment>子带15的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_14" pos="23:20" rst="0x0">
          <comment>子带14的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_13" pos="19:16" rst="0x0">
          <comment>子带13的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_12" pos="15:12" rst="0x0">
          <comment>子带12的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_11" pos="11:8" rst="0x0">
          <comment>子带11的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_10" pos="7:4" rst="0x0">
          <comment>子带10的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_9" pos="3:0" rst="0x0">
          <comment>子带9的码本索引</comment>
        </bits>
      </reg>
      <reg name="pmi_pds2_nxt" protect="rw">
        <comment>码本索引寄存器</comment>
        <bits access="rw" name="pmi_24" pos="31:28" rst="0x0">
          <comment>子带24的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_23" pos="27:24" rst="0x0">
          <comment>子带23的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_22" pos="23:20" rst="0x0">
          <comment>子带22的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_21" pos="19:16" rst="0x0">
          <comment>子带21的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_20" pos="15:12" rst="0x0">
          <comment>子带20的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_19" pos="11:8" rst="0x0">
          <comment>子带19的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_18" pos="7:4" rst="0x0">
          <comment>子带18的码本索引</comment>
        </bits>
        <bits access="rw" name="pmi_17" pos="3:0" rst="0x0">
          <comment>子带17的码本索引</comment>
        </bits>
      </reg>
      <reg name="pmi_pds3_nxt" protect="rw">
        <comment>码本索引寄存器</comment>
        <bits access="rw" name="pmi_25" pos="3:0" rst="0x0">
          <comment>子带25的码本索引</comment>
        </bits>
      </reg>
      <reg name="spwr_wb" protect="rw">
        <comment>CRS获得的宽带信号功率寄存器</comment>
      </reg>
      <reg name="npwr_wb" protect="rw">
        <comment>CRS获得的宽带噪声功率寄存器</comment>
      </reg>
      <reg name="spwr_wb_agc" protect="rw">
        <comment>CRS获得的宽带信号功率AGC寄存器</comment>
        <bits access="r" name="spwr_wb_agc" pos="9:0" rst="0x0">
          <comment>接收天线1上CRS获得的宽带信号功率AGC</comment>
        </bits>
      </reg>
      <reg name="npwr_wb_agc" protect="rw">
        <comment>CRS获得的宽带噪声功率AGC寄存器</comment>
        <bits access="r" name="npwr_wb_agc" pos="9:0" rst="0x0">
          <comment>接收天线1上CRS获得的宽带噪声功率AGC</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_factor0" protect="rw">
        <comment>DATA截位因子寄存器0</comment>
        <bits access="rw" name="pdcch_scale_sel" pos="19" rst="0x0">
          <comment>PDCCH的截位方式：
0：固定截位
1：按照最大值动态截位</comment>
        </bits>
        <bits access="rw" name="pbch_scale_sel" pos="18" rst="0x0">
          <comment>PBCH的截位方式：
0：固定截位
1：按照下面均值范围动态截位</comment>
        </bits>
        <bits access="rw" name="pbch_scale1" pos="17:9" rst="0x0">
          <comment>截位范围值1</comment>
        </bits>
        <bits access="rw" name="pbch_scale0" pos="8:0" rst="0x0">
          <comment>截位范围值0</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_factor1" protect="rw">
        <comment>DATA截位因子寄存器2</comment>
        <bits access="rw" name="pdsch_scale_sel" pos="12" rst="0x0">
          <comment>PDSCH的截位方式：
0：固定截位
1：按照下面均值范围动态截位</comment>
        </bits>
        <bits access="rw" name="pdsch_scale0" pos="11:0" rst="0x0">
          <comment>截位范围值0</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_factor2" protect="rw">
        <comment>DATA截位因子寄存器3</comment>
        <bits access="rw" name="pdsch_scale2" pos="23:12" rst="0x0">
          <comment>截位范围值2</comment>
        </bits>
        <bits access="rw" name="pdsch_scale1" pos="11:0" rst="0x0">
          <comment>截位范围值1</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_factor3" protect="rw">
        <comment>DATA截位因子寄存器4</comment>
        <bits access="rw" name="pdsch_scale4" pos="23:12" rst="0x0">
          <comment>截位范围值4</comment>
        </bits>
        <bits access="rw" name="pdsch_scale3" pos="11:0" rst="0x0">
          <comment>截位范围值3</comment>
        </bits>
      </reg>
      <reg name="sd_data_factor0" protect="rw">
        <comment>DATA调整因子(CRS)寄存器0</comment>
        <bits access="rw" name="cr_data_factor" pos="31:16" rst="0x2000">
          <comment>值，用于当OFDM符号上有CELL RS时，对data调整</comment>
        </bits>
        <bits access="rw" name="ucr_data_factor" pos="15:0" rst="0x2000">
          <comment>值，用于当OFDM符号上无CELL RS时，对data调整</comment>
        </bits>
      </reg>
      <reg name="sd_data_factor1" protect="rw">
        <comment>DATA调整因子(URS)寄存器1</comment>
        <bits access="rw" name="cr_data_factor" pos="31:16" rst="0x2000">
          <comment>值，用于当OFDM符号上有CELL RS时，对data调整</comment>
        </bits>
        <bits access="rw" name="ucr_data_factor" pos="15:0" rst="0x2000">
          <comment>值，用于当OFDM符号上无CELL RS时，对data调整</comment>
        </bits>
      </reg>
      <reg name="sd_data_factor2" protect="rw">
        <comment>DATA调整因子(URS)寄存器2</comment>
        <bits access="rw" name="cr_data_factor" pos="31:16" rst="0x2000">
          <comment>值，用于当OFDM符号上有CELL RS时，对data调整</comment>
        </bits>
        <bits access="rw" name="ucr_data_factor" pos="15:0" rst="0x2000">
          <comment>值，用于当OFDM符号上无CELL RS时，对data调整</comment>
        </bits>
      </reg>
      <reg name="cnoise_nxt" protect="rw">
        <comment>CTRL噪声值寄存器</comment>
      </reg>
      <reg name="cnoise_agc_nxt" protect="rw">
        <comment>CTRL噪声绝对AGC值</comment>
        <bits access="rw" name="noise_agc" pos="9:0" rst="0x0">
          <comment>噪声绝对AGC值（有符号）</comment>
        </bits>
      </reg>
      <reg name=" cnoise_th" protect="rw">
        <comment>CTRL噪声门限寄存器</comment>
        <bits access="rw" name="noise_th" pos="15:0" rst="0x0">
          <comment>噪声门限（PDCCH、PBCH）</comment>
        </bits>
      </reg>
      <reg name="dnoise_nxt" protect="rw">
        <comment>DATA噪声值寄存器</comment>
      </reg>
      <reg name="dnoise_agc_nxt" protect="rw">
        <comment>DATA噪声绝对AGC值</comment>
        <bits access="rw" name="noise_agc" pos="9:0" rst="0x0">
          <comment>噪声绝对AGC值（有符号）</comment>
        </bits>
      </reg>
      <reg name="dnoise_th" protect="rw">
        <comment>DATA噪声门限寄存器</comment>
        <bits access="rw" name="noise_th2" pos="31:16" rst="0x0">
          <comment>噪声门限（辅业务）</comment>
        </bits>
        <bits access="rw" name="noise_th1" pos="15:0" rst="0x0">
          <comment>噪声门限（主业务）</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_bcout0" protect="rw">
        <comment>SDOUT截位因子PBCH输出寄存器0</comment>
        <bits access="r" name="cscale_out" pos="11:8" rst="0x0">
          <comment>PDCCH截位INDX值</comment>
        </bits>
        <bits access="r" name="bscale_out3" pos="7:6" rst="0x0">
          <comment>PBCH截位INDX值3</comment>
        </bits>
        <bits access="r" name="bscale_out2" pos="5:4" rst="0x0">
          <comment>PBCH截位INDX值2</comment>
        </bits>
        <bits access="r" name="bscale_out1" pos="3:2" rst="0x0">
          <comment>PBCH截位INDX值1</comment>
        </bits>
        <bits access="r" name="bscale_out0" pos="1:0" rst="0x0">
          <comment>PBCH截位INDX值0</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_dout0" protect="rw">
        <comment>SDOUT截位因子PDSCH输出寄存器0</comment>
        <bits access="r" name="dscale_out7" pos="23:21" rst="0x0">
          <comment>截位INDX值7</comment>
        </bits>
        <bits access="r" name="dscale_out6" pos="20:18" rst="0x0">
          <comment>截位INDX值6</comment>
        </bits>
        <bits access="r" name="dscale_out5" pos="17:15" rst="0x0">
          <comment>截位INDX值5</comment>
        </bits>
        <bits access="r" name="dscale_out4" pos="14:12" rst="0x0">
          <comment>截位INDX值4</comment>
        </bits>
        <bits access="r" name="dscale_out3" pos="11:9" rst="0x0">
          <comment>截位INDX值3</comment>
        </bits>
        <bits access="r" name="dscale_out2" pos="8:6" rst="0x0">
          <comment>截位INDX值2</comment>
        </bits>
        <bits access="r" name="dscale_out1" pos="5:3" rst="0x0">
          <comment>截位INDX值1</comment>
        </bits>
        <bits access="r" name="dscale_out0" pos="2:0" rst="0x0">
          <comment>截位INDX值0</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_dout1" protect="rw">
        <comment>SDOUT截位因子PDSCH输出寄存器1</comment>
        <bits access="r" name="dscale_out15" pos="23:21" rst="0x0">
          <comment>截位INDX值15</comment>
        </bits>
        <bits access="r" name="dscale_out14" pos="20:18" rst="0x0">
          <comment>截位INDX值14</comment>
        </bits>
        <bits access="r" name="dscale_out13" pos="17:15" rst="0x0">
          <comment>截位INDX值13</comment>
        </bits>
        <bits access="r" name="dscale_out12" pos="14:12" rst="0x0">
          <comment>截位INDX值12</comment>
        </bits>
        <bits access="r" name="dscale_out11" pos="11:9" rst="0x0">
          <comment>截位INDX值11</comment>
        </bits>
        <bits access="r" name="dscale_out10" pos="8:6" rst="0x0">
          <comment>截位INDX值10</comment>
        </bits>
        <bits access="r" name="dscale_out9" pos="5:3" rst="0x0">
          <comment>截位INDX值9</comment>
        </bits>
        <bits access="r" name="dscale_out8" pos="2:0" rst="0x0">
          <comment>截位INDX值8</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_dout2" protect="rw">
        <comment>SDOUT截位因子PDSCH输出寄存器2</comment>
        <bits access="r" name="dscale_out23" pos="23:21" rst="0x0">
          <comment>截位INDX值23</comment>
        </bits>
        <bits access="r" name="dscale_out22" pos="20:18" rst="0x0">
          <comment>截位INDX值22</comment>
        </bits>
        <bits access="r" name="dscale_out21" pos="17:15" rst="0x0">
          <comment>截位INDX值21</comment>
        </bits>
        <bits access="r" name="dscale_out20" pos="14:12" rst="0x0">
          <comment>截位INDX值20</comment>
        </bits>
        <bits access="r" name="dscale_out19" pos="11:9" rst="0x0">
          <comment>截位INDX值19</comment>
        </bits>
        <bits access="r" name="dscale_out18" pos="8:6" rst="0x0">
          <comment>截位INDX值18</comment>
        </bits>
        <bits access="r" name="dscale_out17" pos="5:3" rst="0x0">
          <comment>截位INDX值17</comment>
        </bits>
        <bits access="r" name="dscale_out16" pos="2:0" rst="0x0">
          <comment>截位INDX值16</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_dout3" protect="rw">
        <comment>SDOUT截位因子PDSCH输出寄存器3</comment>
        <bits access="r" name="dscale_out31" pos="23:21" rst="0x0">
          <comment>截位INDX值31</comment>
        </bits>
        <bits access="r" name="dscale_out30" pos="20:18" rst="0x0">
          <comment>截位INDX值30</comment>
        </bits>
        <bits access="r" name="dscale_out29" pos="17:15" rst="0x0">
          <comment>截位INDX值29</comment>
        </bits>
        <bits access="r" name="dscale_out28" pos="14:12" rst="0x0">
          <comment>截位INDX值28</comment>
        </bits>
        <bits access="r" name="dscale_out27" pos="11:9" rst="0x0">
          <comment>截位INDX值27</comment>
        </bits>
        <bits access="r" name="dscale_out26" pos="8:6" rst="0x0">
          <comment>截位INDX值26</comment>
        </bits>
        <bits access="r" name="dscale_out25" pos="5:3" rst="0x0">
          <comment>截位INDX值25</comment>
        </bits>
        <bits access="r" name="dscale_out24" pos="2:0" rst="0x0">
          <comment>截位INDX值24</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_dout4" protect="rw">
        <comment>SDOUT截位因子PDSCH输出寄存器4</comment>
        <bits access="r" name="dscale_out34" pos="8:6" rst="0x0">
          <comment>截位INDX值34</comment>
        </bits>
        <bits access="r" name="dscale_out33" pos="5:3" rst="0x0">
          <comment>截位INDX值33</comment>
        </bits>
        <bits access="r" name="dscale_out32" pos="2:0" rst="0x0">
          <comment>截位INDX值32</comment>
        </bits>
      </reg>
      <reg name="hq_hb_sta" protect="rw">
        <comment>HARQBUF存储占用指示寄存器</comment>
        <bits access="rc" name="hb15_sta" pos="15" rst="0x0">
          <comment>第15块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb14_sta" pos="14" rst="0x0">
          <comment>第14块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb13_sta" pos="13" rst="0x0">
          <comment>第13块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb12_sta" pos="12" rst="0x0">
          <comment>第12块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb11_sta" pos="11" rst="0x0">
          <comment>第11块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb10_sta" pos="10" rst="0x0">
          <comment>第10块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb9_sta" pos="9" rst="0x0">
          <comment>第9块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb8_sta" pos="8" rst="0x0">
          <comment>第8块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb7_sta" pos="7" rst="0x0">
          <comment>第7块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb6_sta" pos="6" rst="0x0">
          <comment>第6块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb5_sta" pos="5" rst="0x0">
          <comment>第5块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb4_sta" pos="4" rst="0x0">
          <comment>第4块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb3_sta" pos="3" rst="0x0">
          <comment>第3块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb2_sta" pos="2" rst="0x0">
          <comment>第2块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb1_sta" pos="1" rst="0x0">
          <comment>第1块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
        <bits access="rc" name="hb0_sta" pos="0" rst="0x0">
          <comment>第0块HARQBUFFER存储状态指示
0:该块资源已经被释放；
1:该块资源正在被占用；</comment>
        </bits>
      </reg>
      <reg name="hq_hb_proc0" protect="rw">
        <comment>HARQBUF存储进程指示0寄存器</comment>
        <bits access="r" name="hb7_proc" pos="31:28" rst="0x0">
          <comment>第7块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb6_proc" pos="27:24" rst="0x0">
          <comment>第6块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb5_proc" pos="23:20" rst="0x0">
          <comment>第5块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb4_proc" pos="19:16" rst="0x0">
          <comment>第4块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb3_proc" pos="15:12" rst="0x0">
          <comment>第3块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb2_proc" pos="11:8" rst="0x0">
          <comment>第2块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb1_proc" pos="7:4" rst="0x0">
          <comment>第1块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb0_proc" pos="3:0" rst="0x0">
          <comment>第0块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
      </reg>
      <reg name="hq_hb_proc1" protect="rw">
        <comment>HARQBUF存储进程指示1寄存器</comment>
        <bits access="r" name="hb15_proc" pos="31:28" rst="0x0">
          <comment>第15块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb14_proc" pos="27:24" rst="0x0">
          <comment>第14块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb13_proc" pos="23:20" rst="0x0">
          <comment>第13块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb12_proc" pos="19:16" rst="0x0">
          <comment>第12块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb11_proc" pos="15:12" rst="0x0">
          <comment>第11块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb10_proc" pos="11:8" rst="0x0">
          <comment>第10块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb9_proc" pos="7:4" rst="0x0">
          <comment>第9块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
        <bits access="r" name="hb8_proc" pos="3:0" rst="0x0">
          <comment>第8块HARQBUFFER存储进程指示:0~15</comment>
        </bits>
      </reg>
      <reg name="turbo_para" protect="rw">
        <comment>TURBO参数寄存器</comment>
        <bits access="rw" name="norm_en2" pos="17" rst="0x0">
          <comment>归一化选择：64QAM
0：2倍均值
1：最大值</comment>
        </bits>
        <bits access="rw" name="norm_en1" pos="16" rst="0x0">
          <comment>归一化选择：16QAM
0：2倍均值
1：最大值</comment>
        </bits>
        <bits access="rw" name="norm_en0" pos="15" rst="0x0">
          <comment>归一化选择：QPSK
0：2倍均值
1：最大值</comment>
        </bits>
        <bits access="rw" name="shift_en2" pos="14" rst="0x0">
          <comment>移位使能：64QAM
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="shift_en1" pos="13" rst="0x1">
          <comment>移位使能：16QAM
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="shift_en0" pos="12" rst="0x1">
          <comment>移位使能：QPSK
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="shift_iternum2" pos="11:8" rst="0x5">
          <comment>移位迭代次数2</comment>
        </bits>
        <bits access="rw" name="shift_iternum1" pos="7:4" rst="0x2">
          <comment>移位迭代次数1</comment>
        </bits>
        <bits access="rw" name="iter_num_max" pos="3:0" rst="0x8">
          <comment>最大译码迭代次数减1
（最大译码次数为9）：0~8</comment>
        </bits>
      </reg>
      <reg name="turbo_iter" protect="rw">
        <comment>TURBO迭代次数输出寄存器</comment>
        <bits access="r" name="real_iter3" pos="15:12" rst="0x0">
          <comment>PAG实际迭代次数-1</comment>
        </bits>
        <bits access="r" name="real_iter2" pos="11:8" rst="0x0">
          <comment>SI实际迭代次数-1</comment>
        </bits>
        <bits access="r" name="real_iter1" pos="7:4" rst="0x0">
          <comment>PDS第二块实际迭代次数-1</comment>
        </bits>
        <bits access="r" name="real_iter0" pos="3:0" rst="0x0">
          <comment>PDS第一块实际迭代次数-1</comment>
        </bits>
      </reg>
      <reg name="vit_par" protect="rw">
        <comment>VIT参数寄存器</comment>
        <bits access="rw" name="mask_en" pos="5" rst="0x0">
          <comment>掩码使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="crc_type" pos="4" rst="0x0">
          <comment>CRC类型：
0：CRC16
1：CRC24A</comment>
        </bits>
        <bits access="rw" name="dmav_en" pos="3" rst="0x0">
          <comment>DMA触发使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="intv_en" pos="2" rst="0x0">
          <comment>中断使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="vit_itnum" pos="1:0" rst="0x1">
          <comment>VIT迭代次数
0:1
1:2
2:3
3:4</comment>
        </bits>
      </reg>
      <reg name="vit_faconf" protect="rw">
        <comment>VIT FA配置寄存器</comment>
        <bits access="rw" name="crc_mask" pos="31:16" rst="0x0">
          <comment>掩码</comment>
        </bits>
        <bits access="rw" name="fa_en" pos="8" rst="0x0">
          <comment>PDCCH的false alarm使能</comment>
        </bits>
        <bits access="rw" name="fa_th" pos="7:0" rst="0x80">
          <comment>PDCCH的false alarm的重构差异百分比门限(U8Q7)</comment>
        </bits>
      </reg>
      <reg name="vit_len" protect="rw">
        <comment>VIT单独调用长度寄存器</comment>
        <bits access="rw" name="vit_len" pos="9:0" rst="0x0">
          <comment>VIT长度</comment>
        </bits>
      </reg>
      <reg name="vit_start" protect="rw">
        <comment>VIT单独调用启动寄存器</comment>
        <bits access="rw" name="vit_start" pos="0" rst="0x0">
          <comment>VIT启动：
0：不启动或者完成
1：启动</comment>
        </bits>
      </reg>
      <reg name="vit_flag" protect="rw">
        <comment>VIT标志寄存器</comment>
        <bits access="rc" name="pdsch_zero_flag" pos="2" rst="0x0">
          <comment>VIT CRC译码结果数据（含CRC校验位），全零标志：
0：数据不为全零
1：数据为全零</comment>
        </bits>
        <bits access="rc" name="vit_crc_flag" pos="1" rst="0x1">
          <comment>VIT CRC校验正确完成标志：
0：正确
1：错误</comment>
        </bits>
        <bits access="rc" name="int_vflag" pos="0" rst="0x0">
          <comment>PBCH完成标志：
0：无中断
1：中断</comment>
        </bits>
      </reg>
      <reg name="vit_faout" protect="rw">
        <comment>VIT FA输出寄存器</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm软信息为0的个数</comment>
        </bits>
        <bits access="r" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm的输出重构差异个数</comment>
        </bits>
      </reg>
      <reg name="cfi_out" protect="rw">
        <comment>CFICH输出寄存器</comment>
        <bits access="r" name="cfi_out" pos="2:0" rst="0x0">
          <comment>CFI输出的值：
1~4（1.4M固定加了1后的结果）</comment>
        </bits>
      </reg>
      <reg name="hi_out" protect="rw">
        <comment>PHICH输出寄存器</comment>
        <bits access="r" name="hi1_out" pos="1" rst="0x0">
          <comment>HI1输出的值</comment>
        </bits>
        <bits access="r" name="hi0_out" pos="0" rst="0x0">
          <comment>HI0输出的值</comment>
        </bits>
      </reg>
      <reg name="sw_cin_nxt" protect="rw">
        <comment>软件输入CTRL寄存器</comment>
      </reg>
      <reg name="sw_din_nxt" protect="rw">
        <comment>软件输入DATA寄存器</comment>
      </reg>
      <reg name="sw_cout" protect="rw">
        <comment>软件输出CTRL寄存器</comment>
      </reg>
      <reg name="sw_dout" protect="rw">
        <comment>软件输出DATA寄存器</comment>
      </reg>
      <reg name="pds_rep_num" protect="rw">
        <comment>PDSCH重复次数寄存器</comment>
        <bits access="r" name="pds15_rep_num" pos="31:30" rst="0x0">
          <comment>PDSCH 第15个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds14_rep_num" pos="29:28" rst="0x0">
          <comment>PDSCH 第14个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds13_rep_num" pos="27:26" rst="0x0">
          <comment>PDSCH 第13个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds12_rep_num" pos="25:24" rst="0x0">
          <comment>PDSCH 第12个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds11_rep_num" pos="23:22" rst="0x0">
          <comment>PDSCH 第11个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds10_rep_num" pos="21:20" rst="0x0">
          <comment>PDSCH 第10个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds9_rep_num" pos="19:18" rst="0x0">
          <comment>PDSCH 第9个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds8_rep_num" pos="17:16" rst="0x0">
          <comment>PDSCH 第8个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds7_rep_num" pos="15:14" rst="0x0">
          <comment>PDSCH 第7个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds6_rep_num" pos="13:12" rst="0x0">
          <comment>PDSCH 第6个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds5_rep_num" pos="11:10" rst="0x0">
          <comment>PDSCH 第5个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds4_rep_num" pos="9:8" rst="0x0">
          <comment>PDSCH 第4个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds3_rep_num" pos="7:6" rst="0x0">
          <comment>PDSCH 第3个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds2_rep_num" pos="5:4" rst="0x0">
          <comment>PDSCH 第2个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds1_rep_num" pos="3:2" rst="0x0">
          <comment>PDSCH 第1个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="pds0_rep_num" pos="1:0" rst="0x0">
          <comment>PDSCH 第0个进程重传次数指示</comment>
        </bits>
      </reg>
      <reg name="si_rep_num" protect="rw">
        <comment>SI重复次数寄存器</comment>
        <bits access="r" name="si1_rep_num" pos="3:2" rst="0x0">
          <comment>SI第1个进程重传次数指示</comment>
        </bits>
        <bits access="r" name="si0_rep_num" pos="1:0" rst="0x0">
          <comment>SI第0个进程重传次数指示</comment>
        </bits>
      </reg>
      <reg name="pbch_rep_num" protect="rw">
        <comment>PBCH重复次数寄存器</comment>
        <bits access="r" name="pbch_rep_num" pos="1:0" rst="0x0">
          <comment>PBCH重传次数指示</comment>
        </bits>
      </reg>
      <reg name="rtctrl_cfg" protect="rw">
        <comment>运行时间控制寄存器</comment>
        <bits access="rw" name="rtctrl_cfg" pos="17:0" rst="0xc350">
          <comment>运行时间控制寄存器</comment>
        </bits>
      </reg>
      <reg name="cabis_enbl_nxt" protect="rw">
        <comment>ABIS使能配置寄存器</comment>
        <bits access="rw" name="abis_portsel2" pos="11:10" rst="0x0">
          <comment>邻区2天线干扰的情况选择：
0：发射天线数为2的情况下：port0和port1都干扰；发射天线数为4的情况下：port0、port1、port2、port3都干扰
1：发射天线数为2的情况下：只有port0干扰；发射天线数为4的情况下：port0、port2、port3都干扰
2：发射天线数为2的情况下：只有port1干扰；发射天线数为4的情况下：port1、port2、port3都干扰</comment>
        </bits>
        <bits access="rw" name="abis_portsel1" pos="9:8" rst="0x0">
          <comment>邻区1天线干扰的情况选择：
0：发射天线数为2的情况下：port0和port1都干扰；发射天线数为4的情况下：port0、port1、port2、port3都干扰
1：发射天线数为2的情况下：只有port0干扰；发射天线数为4的情况下：port0、port2、port3都干扰
2：发射天线数为2的情况下：只有port1干扰；发射天线数为4的情况下：port1、port2、port3都干扰</comment>
        </bits>
        <bits access="rw" name="abis_portsel0" pos="7:6" rst="0x0">
          <comment>服务小区天线选择：
0：发射天线数为2的情况下：port0和port1都干扰；发射天线数为4的情况下：port0、port1、port2、port3都干扰
1：发射天线数为2的情况下：只有port0干扰；发射天线数为4的情况下：port0、port2、port3都干扰
2：发射天线数为2的情况下：只有port1干扰；发射天线数为4的情况下：port1、port2、port3都干扰</comment>
        </bits>
        <bits access="rw" name="cmc_en" pos="5" rst="0x0">
          <comment>MultiCell计算使能
0：SingalCell
1：MultiCell</comment>
        </bits>
        <bits access="rw" name="cabis_sel" pos="4" rst="0x0">
          <comment>ABIS移位因子方式选择：
0：选择软件配置
1：选择DLFFT直接传递</comment>
        </bits>
        <bits access="rw" name="cabis_en" pos="3" rst="0x0">
          <comment>ABIS使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="cabis_sdden" pos="2" rst="0x0">
          <comment>ABIS的SD PDSCH清零使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="cabis_sdcen" pos="1" rst="0x0">
          <comment>ABIS的SD MPDCCH清零使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="cabis_sdben" pos="0" rst="0x0">
          <comment>ABIS的SD PBCH清零使能：
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="cabis_cfg_nxt" protect="rw">
        <comment>ABIS小区配置寄存器</comment>
        <bits access="rw" name="cabis_num" pos="29:28" rst="0x0">
          <comment>检测到干扰邻区的个数：
00：0个干扰邻区
01：1个干扰邻区
10：2个干扰邻区
其他：默认0个干扰邻区</comment>
        </bits>
        <bits access="rw" name="cabis_txnum_next2" pos="27:26" rst="0x0">
          <comment>干扰邻区2发射天线数：
00：1port
01：2port
10：4port
其他：默认1port</comment>
        </bits>
        <bits access="rw" name="cabis_txnum_next1" pos="25:24" rst="0x0">
          <comment>干扰邻区1发射天线数：
00：1port
01：2port
10：4port
其他：默认1port</comment>
        </bits>
        <bits access="rw" name="cabis_nrb_next2" pos="23:21" rst="0x0">
          <comment>干扰邻区2 系统带宽值：
000：6prb
001：15prb
010：25prb
011：50prb
100：75prb
101：100prb
其他：默认6prb</comment>
        </bits>
        <bits access="rw" name="cabis_nrb_next1" pos="20:18" rst="0x0">
          <comment>干扰邻区1 系统带宽值：
000：6prb
001：15prb
010：25prb
011：50prb
100：75prb
101：100prb
其他：默认6prb</comment>
        </bits>
        <bits access="rw" name="cabis_cellid_next2" pos="17:9" rst="0x0">
          <comment>干扰邻区2 CELL ID值</comment>
        </bits>
        <bits access="rw" name="cabis_cellid_next1" pos="8:0" rst="0x0">
          <comment>干扰邻区1 CELL ID值</comment>
        </bits>
      </reg>
      <reg name="cabis_dly1_nxt" protect="rw">
        <comment>小区时延值寄存器1</comment>
        <bits access="rw" name="cabis_dly_next1" pos="18:0" rst="0x0">
          <comment>干扰邻区1相对本区时延值（单位TS）</comment>
        </bits>
      </reg>
      <reg name="cabis_dly2_nxt" protect="rw">
        <comment>小区时延值寄存器2</comment>
        <bits access="rw" name="cabis_dly_next2" pos="18:0" rst="0x0">
          <comment>干扰邻区2相对本区时延值（单位TS）</comment>
        </bits>
      </reg>
      <reg name="cabis_shft_nxt" protect="rw">
        <comment>ABIS干扰移位寄存器</comment>
        <bits access="r" name="cabis_shft_next3" pos="11:8" rst="0x0">
          <comment>ABIS干扰类型3（邻区1+2）移位值</comment>
        </bits>
        <bits access="r" name="cabis_shft_next2" pos="7:4" rst="0x0">
          <comment>ABIS干扰类型2（邻区2）移位值</comment>
        </bits>
        <bits access="r" name="cabis_shft_next1" pos="3:0" rst="0x0">
          <comment>ABIS干扰类型1（邻区1）移位值</comment>
        </bits>
      </reg>
      <reg name="dabis_enbl_nxt" protect="rw">
        <comment>ABIS使能配置寄存器</comment>
        <bits access="rw" name="abis_portsel2" pos="10:9" rst="0x0">
          <comment>邻区2天线干扰的情况选择：
0：发射天线数为2的情况下：port0和port1都干扰；发射天线数为4的情况下：port0、port1、port2、port3都干扰
1：发射天线数为2的情况下：只有port0干扰；发射天线数为4的情况下：port0、port2、port3都干扰
2：发射天线数为2的情况下：只有port1干扰；发射天线数为4的情况下：port1、port2、port3都干扰</comment>
        </bits>
        <bits access="rw" name="abis_portsel1" pos="8:7" rst="0x0">
          <comment>邻区1天线干扰的情况选择：
0：发射天线数为2的情况下：port0和port1都干扰；发射天线数为4的情况下：port0、port1、port2、port3都干扰
1：发射天线数为2的情况下：只有port0干扰；发射天线数为4的情况下：port0、port2、port3都干扰
2：发射天线数为2的情况下：只有port1干扰；发射天线数为4的情况下：port1、port2、port3都干扰</comment>
        </bits>
        <bits access="rw" name="abis_portsel0" pos="6:5" rst="0x0">
          <comment>服务小区天线选择：
0：发射天线数为2的情况下：port0和port1都干扰；发射天线数为4的情况下：port0、port1、port2、port3都干扰
1：发射天线数为2的情况下：只有port0干扰；发射天线数为4的情况下：port0、port2、port3都干扰
2：发射天线数为2的情况下：只有port1干扰；发射天线数为4的情况下：port1、port2、port3都干扰</comment>
        </bits>
        <bits access="rw" name="dabis_sel" pos="4" rst="0x0">
          <comment>ABIS移位因子方式选择：
0：选择软件配置
1：选择DLFFT直接传递</comment>
        </bits>
        <bits access="rw" name="dabis_en" pos="3" rst="0x0">
          <comment>ABIS使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="dabis_sdden" pos="2" rst="0x0">
          <comment>ABIS的SD PDSCH清零使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="dabis_sdcen" pos="1" rst="0x0">
          <comment>ABIS的SD MPDCCH清零使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="dabis_sdben" pos="0" rst="0x0">
          <comment>ABIS的SD PBCH清零使能：
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="dabis_cfg_nxt" protect="rw">
        <comment>ABIS小区配置寄存器</comment>
        <bits access="rw" name="dabis_num" pos="29:28" rst="0x0">
          <comment>检测到干扰邻区的个数：
00：0个干扰邻区
01：1个干扰邻区
10：2个干扰邻区
其他：默认0个干扰邻区</comment>
        </bits>
        <bits access="rw" name="dabis_txnum_next2" pos="27:26" rst="0x0">
          <comment>干扰邻区2发射天线数：
00：1port
01：2port
10：4port
其他：默认1port</comment>
        </bits>
        <bits access="rw" name="dabis_txnum_next1" pos="25:24" rst="0x0">
          <comment>干扰邻区2发射天线数：
00：1port
01：2port
10：4port
其他：默认1port</comment>
        </bits>
        <bits access="rw" name="dabis_nrb_next2" pos="23:21" rst="0x0">
          <comment>干扰邻区2 系统带宽值：
000：6prb
001：15prb
010：25prb
011：50prb
100：75prb
101：100prb
其他：默认6prb</comment>
        </bits>
        <bits access="rw" name="dabis_nrb_next1" pos="20:18" rst="0x0">
          <comment>干扰邻区1 系统带宽值：
000：6prb
001：15prb
010：25prb
011：50prb
100：75prb
101：100prb
其他：默认6prb</comment>
        </bits>
        <bits access="rw" name="dabis_cellid_next2" pos="17:9" rst="0x0">
          <comment>干扰邻区2 CELL ID值</comment>
        </bits>
        <bits access="rw" name="dabis_cellid_next1" pos="8:0" rst="0x0">
          <comment>干扰邻区1 CELL ID值</comment>
        </bits>
      </reg>
      <reg name="dabis_dly1_nxt" protect="rw">
        <comment>小区时延值寄存器</comment>
        <bits access="rw" name="dabis_dly_next1" pos="18:0" rst="0x0">
          <comment>干扰邻区1相对本区时延值（单位TS）</comment>
        </bits>
      </reg>
      <reg name="dabis_dly2_nxt" protect="rw">
        <comment>小区时延值寄存器</comment>
        <bits access="rw" name="dabis_dly_next2" pos="18:0" rst="0x0">
          <comment>干扰邻区2相对本区时延值（单位TS）</comment>
        </bits>
      </reg>
      <reg name="dabis_shft_nxt" protect="rw">
        <comment>ABIS干扰移位寄存器</comment>
        <bits access="r" name="dabis_shft_next3" pos="11:8" rst="0x0">
          <comment>ABIS干扰类型3（邻区1+2）移位值</comment>
        </bits>
        <bits access="r" name="dabis_shft_next2" pos="7:4" rst="0x0">
          <comment>ABIS干扰类型2（邻区2）移位值</comment>
        </bits>
        <bits access="r" name="dabis_shft_next1" pos="3:0" rst="0x0">
          <comment>ABIS干扰类型1（邻区1）移位值</comment>
        </bits>
      </reg>
      <reg name="reis_conf" protect="rw">
        <comment>REIS配置寄存器</comment>
        <bits access="rw" name="reis_en" pos="4" rst="0x0">
          <comment>REIS使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="reis_num" pos="3:0" rst="0x0">
          <comment>REIS的NUM个数</comment>
        </bits>
      </reg>
      <reg name="reis_pos0" protect="rw">
        <comment>REIS位置寄存器0</comment>
        <bits access="rw" name="reis_shift1" pos="31:28" rst="0x0">
          <comment>REIS1的移位指示</comment>
        </bits>
        <bits access="rw" name="reis_re1" pos="26:16" rst="0x0">
          <comment>REIS1的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
        <bits access="rw" name="reis_shift0" pos="15:12" rst="0x0">
          <comment>REIS0的移位指示</comment>
        </bits>
        <bits access="rw" name="reis_re0" pos="10:0" rst="0x0">
          <comment>REIS0的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
      </reg>
      <reg name="reis_pos1" protect="rw">
        <comment>REIS位置寄存器1</comment>
        <bits access="rw" name="reis_shift3" pos="31:28" rst="0x0">
          <comment>REIS3的移位指示</comment>
        </bits>
        <bits access="rw" name="reis_re3" pos="26:16" rst="0x0">
          <comment>REIS3的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
        <bits access="rw" name="reis_shift2" pos="15:12" rst="0x0">
          <comment>REIS2的移位指示</comment>
        </bits>
        <bits access="rw" name="reis_re2" pos="10:0" rst="0x0">
          <comment>REIS2的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
      </reg>
      <reg name="reis_pos2" protect="rw">
        <comment>REIS位置寄存器2</comment>
        <bits access="rw" name="reis_shift5" pos="31:28" rst="0x0">
          <comment>REIS5的移位指示</comment>
        </bits>
        <bits access="rw" name="reis_re5" pos="26:16" rst="0x0">
          <comment>REIS5的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
        <bits access="rw" name="reis_shift4" pos="15:12" rst="0x0">
          <comment>REIS4的移位指示</comment>
        </bits>
        <bits access="rw" name="reis_re4" pos="10:0" rst="0x0">
          <comment>REIS4的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
      </reg>
      <reg name="reis_pos3" protect="rw">
        <comment>REIS位置寄存器3</comment>
        <bits access="rw" name="reis_shift7" pos="31:28" rst="0x0">
          <comment>REIS7的移位指示</comment>
        </bits>
        <bits access="rw" name="reis_re7" pos="26:16" rst="0x0">
          <comment>REIS7的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
        <bits access="rw" name="reis_shift6" pos="15:12" rst="0x0">
          <comment>REIS6的移位指示</comment>
        </bits>
        <bits access="rw" name="reis_re6" pos="10:0" rst="0x0">
          <comment>REIS6的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
      </reg>
      <reg name="rbis_par" protect="rw">
        <comment>RBIS参数寄存器</comment>
        <bits access="rw" name="rbis_portsel" pos="31" rst="0x0">
          <comment>发射天线数为2的情况下，ABIS判决的PORT选择：
0：使用port0
1：使用port1</comment>
        </bits>
        <bits access="rw" name="rbis_en" pos="30" rst="0x0">
          <comment>RBIS使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rbis_sdden" pos="29" rst="0x0">
          <comment>RBIS的SD PDSCH清零使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rbis_sdcen" pos="28" rst="0x0">
          <comment>RBIS的SD MPDCCH清零使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rbis_sdben" pos="27" rst="0x0">
          <comment>RBIS的SD PBCH清零使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rbis_posen" pos="26" rst="0x0">
          <comment>RBIS使用直接位置指示：
0：不使用直接位置
1：使用直接位置</comment>
        </bits>
        <bits access="rw" name="rbis_num" pos="25:23" rst="0x0">
          <comment>RBIS检测个数：
0：1
1：2
2：3
3：4
4：5</comment>
        </bits>
        <bits access="rw" name="rbis_dipos" pos="22:16" rst="0x0">
          <comment>RBIS的直接位置</comment>
        </bits>
        <bits access="rw" name="rbis_factor" pos="15:0" rst="0x0">
          <comment>RBIS因子</comment>
        </bits>
      </reg>
      <reg name="rbis_posout0" protect="rw">
        <comment>RBIS检测到干扰所在位置输出寄存器0</comment>
        <bits access="r" name="rbis_posout3" pos="27:21" rst="0x0">
          <comment>RBIS检测出的干扰位置：0~99</comment>
        </bits>
        <bits access="r" name="rbis_posout2" pos="20:14" rst="0x0">
          <comment>RBIS检测出的干扰位置：0~99</comment>
        </bits>
        <bits access="r" name="rbis_posout1" pos="13:7" rst="0x0">
          <comment>RBIS检测出的干扰位置：0~99</comment>
        </bits>
        <bits access="r" name="rbis_posout0" pos="6:0" rst="0x0">
          <comment>RBIS检测出的干扰位置：0~99</comment>
        </bits>
      </reg>
      <reg name="rbis_posout1" protect="rw">
        <comment>RBIS检测到干扰所在位置输出寄存器1</comment>
        <bits access="r" name="rbis_posout4" pos="6:0" rst="0x0">
          <comment>RBIS检测出的干扰位置：0~99</comment>
        </bits>
      </reg>
      <reg name="rbis_ave" protect="rw">
        <comment>RBIS检测到均值输出寄存器</comment>
      </reg>
      <reg name="rbis_max" protect="rw">
        <comment>RBIS检测到均值输出寄存器</comment>
        <bits access="r" name="rbis_max" pos="24:0" rst="0x0">
          <comment>RBIS检测出的最大值</comment>
        </bits>
      </reg>
      <reg name="pbml_cfg_nxt" protect="rw">
        <comment>加权值寄存器</comment>
        <bits access="rw" name="pbml_en" pos="20" rst="0x0">
          <comment>PBML使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="llr_cal_len" pos="19:14" rst="0x0">
          <comment>需要修正的LLR信息长度</comment>
        </bits>
        <bits access="rw" name="llr_pos_sta" pos="13:8" rst="0x0">
          <comment>需要修正的LLR信息起始位置</comment>
        </bits>
        <bits access="rw" name="llr_alpha" pos="7:0" rst="0x0">
          <comment>LLR修正加权值：
0~255</comment>
        </bits>
      </reg>
      <reg name="ctrl_state" protect="rw">
        <comment>控制链路状态输出寄存器</comment>
        <bits access="r" name="ctrl_state" pos="25:0" rst="0x1">
          <comment>控制链路状态输出寄存器</comment>
        </bits>
      </reg>
      <reg name="data_state" protect="rw">
        <comment>数据链路状态输出寄存器</comment>
        <bits access="r" name="data_state" pos="25:0" rst="0x1">
          <comment>数据链路状态输出寄存器</comment>
        </bits>
      </reg>
      <reg name="frame_ccnt_out" protect="rw">
        <comment>CTRL帧号输出寄存器</comment>
        <bits access="r" name="ssfn_cnt" pos="31:16" rst="0x0">
          <comment>超帧号：0~65535</comment>
        </bits>
        <bits access="r" name="rf_cnt" pos="13:4" rst="0x0">
          <comment>无线帧号：0~1023</comment>
        </bits>
        <bits access="r" name="sf_cnt" pos="3:0" rst="0x0">
          <comment>子帧号：0~9</comment>
        </bits>
      </reg>
      <reg name="frame_dcnt_out" protect="rw">
        <comment>DATA帧号输出寄存器</comment>
        <bits access="r" name="ssfn_cnt" pos="31:16" rst="0x0">
          <comment>超帧号：0~65535</comment>
        </bits>
        <bits access="r" name="rf_cnt" pos="13:4" rst="0x0">
          <comment>无线帧号：0~1023</comment>
        </bits>
        <bits access="r" name="sf_cnt" pos="3:0" rst="0x0">
          <comment>子帧号：0~9</comment>
        </bits>
      </reg>
      <reg name="pds0_harqin0_info" protect="rw">
        <comment>PDSCH HARQIN寄存器</comment>
        <bits access="r" name="pds_len0" pos="25:16" rst="0x0">
          <comment>主业务CB0在HARQIN MEM0的长度</comment>
        </bits>
        <bits access="r" name="pds_ini0" pos="9:0" rst="0x0">
          <comment>主业务CB0在HARQIN MEM0的起始</comment>
        </bits>
      </reg>
      <reg name="pds0_harqin1_info" protect="rw">
        <comment>PDSCH HARQIN寄存器</comment>
        <bits access="r" name="pds_e0" pos="31:16" rst="0x0">
          <comment>主业务CB0的总长度</comment>
        </bits>
        <bits access="r" name="pds_ini1" pos="12:0" rst="0x0">
          <comment>主业务CB0在HARQIN MEM1的起始</comment>
        </bits>
      </reg>
      <reg name="pds1_harqin0_info" protect="rw">
        <comment>PDSCH HARQIN寄存器</comment>
        <bits access="r" name="pds_len0" pos="25:16" rst="0x0">
          <comment>主业务CB1在HARQIN MEM0的长度</comment>
        </bits>
        <bits access="r" name="pds_ini0" pos="9:0" rst="0x0">
          <comment>主业务CB1在HARQIN MEM0的起始</comment>
        </bits>
      </reg>
      <reg name="pds1_harqin1_info" protect="rw">
        <comment>PDSCH HARQIN寄存器</comment>
        <bits access="r" name="pds_e0" pos="31:16" rst="0x0">
          <comment>主业务CB1的总长度</comment>
        </bits>
        <bits access="r" name="pds_ini1" pos="12:0" rst="0x0">
          <comment>主业务CB1在HARQIN MEM1的起始</comment>
        </bits>
      </reg>
      <reg name="si_harqin0_info" protect="rw">
        <comment>SI HARQIN寄存器</comment>
        <bits access="r" name="si_len0" pos="25:16" rst="0x0">
          <comment>SI业务CB1在HARQIN MEM0的长度</comment>
        </bits>
        <bits access="r" name="si_ini0" pos="9:0" rst="0x0">
          <comment>SI业务CB1在HARQIN MEM0的起始</comment>
        </bits>
      </reg>
      <reg name="si_harqin1_info" protect="rw">
        <comment>SI HARQIN寄存器</comment>
        <bits access="r" name="si_e0" pos="31:16" rst="0x0">
          <comment>SI业务CB1的总长度</comment>
        </bits>
        <bits access="r" name="si_ini1" pos="12:0" rst="0x0">
          <comment>SI业务CB1在HARQIN MEM1的起始</comment>
        </bits>
      </reg>
      <reg name="pag_harqin0_info" protect="rw">
        <comment>PAGING HARQIN寄存器</comment>
        <bits access="r" name="pag_len0" pos="25:16" rst="0x0">
          <comment>PAGING业务CB1在HARQIN MEM0的长度</comment>
        </bits>
        <bits access="r" name="pag_ini0" pos="9:0" rst="0x0">
          <comment>PAGING业务CB1在HARQIN MEM0的起始</comment>
        </bits>
      </reg>
      <reg name="pag_harqin1_info" protect="rw">
        <comment>PAGING HARQIN寄存器</comment>
        <bits access="r" name="pag_e0" pos="31:16" rst="0x0">
          <comment>PAGING业务CB1的总长度</comment>
        </bits>
        <bits access="r" name="pag_ini1" pos="12:0" rst="0x0">
          <comment>PAGING业务CB1在HARQIN MEM1的起始</comment>
        </bits>
      </reg>
      <reg name="cabis_shft_out" protect="rw">
        <comment>ABIS干扰移位输出寄存器</comment>
        <bits access="r" name="cabis_shft3" pos="11:8" rst="0x0">
          <comment>ABIS干扰类型3（邻区1+2）移位值</comment>
        </bits>
        <bits access="r" name="cabis_shft2" pos="7:4" rst="0x0">
          <comment>ABIS干扰类型2（邻区2）移位值</comment>
        </bits>
        <bits access="r" name="cabis_shft1" pos="3:0" rst="0x0">
          <comment>ABIS干扰类型1（邻区1）移位值</comment>
        </bits>
      </reg>
      <reg name="dabis_shft_out" protect="rw">
        <comment>ABIS干扰移位输出寄存器</comment>
        <bits access="r" name="dabis_shft3" pos="11:8" rst="0x0">
          <comment>ABIS干扰类型3（邻区1+2）移位值</comment>
        </bits>
        <bits access="r" name="dabis_shft2" pos="7:4" rst="0x0">
          <comment>ABIS干扰类型2（邻区2）移位值</comment>
        </bits>
        <bits access="r" name="dabis_shft1" pos="3:0" rst="0x0">
          <comment>ABIS干扰类型1（邻区1）移位值</comment>
        </bits>
      </reg>
      <reg name="mc_dly1_nxt" protect="rw">
        <comment>小区时延值寄存器</comment>
        <bits access="rw" name="mc_dly1" pos="18:0" rst="0x0">
          <comment>干扰邻区1相对本区时延值（单位TS）</comment>
        </bits>
      </reg>
      <reg name="mc_dly2_nxt" protect="rw">
        <comment>小区时延值寄存器</comment>
        <bits access="rw" name="mc_dly2" pos="18:0" rst="0x0">
          <comment>干扰邻区2相对本区时延值（单位TS）</comment>
        </bits>
      </reg>
      <reg name="mc_dlyth_nxt" protect="rw">
        <comment>小区时延门限值寄存器</comment>
        <bits access="rw" name="mc_dlyth" pos="9:0" rst="0x0">
          <comment>干扰邻区相对本区时延门限值（单位TS）</comment>
        </bits>
      </reg>
      <hole size="8384096"/>
      <reg name="cfhmem1" protect="rw">
        <bits access="rw" name="cfhmem1" pos="29:0" rst="0x0"/>
      </reg>
      <hole size="524256"/>
      <reg name="cfhmem2" protect="rw">
        <bits access="rw" name="cfhmem2" pos="29:0" rst="0x0"/>
      </reg>
      <hole size="524256"/>
      <reg name="crsmem1" protect="rw">
        <bits access="rw" name="crsmem1_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="crsmem1_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="crsmem2" protect="rw">
        <bits access="rw" name="crsmem2_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="crsmem2_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="clsmem" protect="rw">
        <bits access="rw" name="clsmem_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="clsmem_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="458720"/>
      <reg name="ursmem" protect="rw">
        <bits access="rw" name="ursmem_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="ursmem_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="ulsmem" protect="rw">
        <bits access="rw" name="ulsmem_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="ulsmem_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="pwr_mem1" protect="rw">
        </reg>
      <hole size="3552"/>
      <reg name="pwr_mem1_sb_sinr" protect="rw">
        </reg>
      <hole size="768"/>
      <reg name="pwr_mem1_wb_sinr" protect="rw">
        </reg>
      <hole size="61120"/>
      <reg name="cell_qfmem1" protect="rw">
        <bits access="rw" name="cell_qfmem1_re" pos="31:19" rst="0x0"/>
        <bits access="rw" name="cell_qfmem1_im" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="98272"/>
      <reg name="cell_qfmem2" protect="rw">
        <bits access="rw" name="cell_qfmem2_re" pos="31:19" rst="0x0"/>
        <bits access="rw" name="cell_qfmem2_im" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="163808"/>
      <reg name="ct_qtmem1" protect="rw">
        <bits access="rw" name="ct_qtmem1_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem1_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem1_p01_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem1_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem1_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem1_p01_tap3" protect="rw">
        <bits access="rw" name="ct_qtmem1_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem1_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="1184"/>
      <reg name="ct_qtmem1_p23_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem1_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem1_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="14240"/>
      <reg name="ct_qtmem2" protect="rw">
        <bits access="rw" name="ct_qtmem2_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem2_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem2_p01_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem2_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem2_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem2_p01_tap3" protect="rw">
        <bits access="rw" name="ct_qtmem2_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem2_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="1184"/>
      <reg name="ct_qtmem2_p23_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem2_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem2_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="47008"/>
      <reg name="dt_qtmem1" protect="rw">
        <bits access="rw" name="dt_qtmem1_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="dt_qtmem1_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="dt_qtmem2" protect="rw">
        <bits access="rw" name="dt_qtmem2_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="dt_qtmem2_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="98272"/>
      <reg name="agc_cls_mem" protect="rw">
        <bits access="rw" name="agc_cls_mem_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_cls_mem_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="agc_uls_mem" protect="rw">
        <bits access="rw" name="agc_uls_mem_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_uls_mem_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="agc_cfh_mem1" protect="rw">
        <bits access="rw" name="agc_cfh_mem1_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_cfh_mem1_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="agc_cfh_mem2" protect="rw">
        <bits access="rw" name="agc_cfh_mem2_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_cfh_mem2_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="agc_ufh_mem1" protect="rw">
        <bits access="rw" name="agc_ufh_mem1_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_ufh_mem1_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="agc_ufh_mem2" protect="rw">
        <bits access="rw" name="agc_ufh_mem2_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_ufh_mem2_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="gold_ mem1" protect="rw">
        </reg>
      <hole size="2016"/>
      <reg name="gold_ mem2" protect="rw">
        </reg>
      <hole size="18400"/>
      <reg name="ufhmem" protect="rw">
        <bits access="rw" name="ufhmem" pos="29:0" rst="0x0"/>
      </reg>
      <hole size="294880"/>
      <reg name="csi_in_mem" protect="rw">
        <bits access="rw" name="csimem_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="csimem_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="pmi_mem" protect="rw">
        </reg>
      <hole size="352"/>
      <reg name="pmi_mem_sb" protect="rw">
        <bits access="rw" name="pmi_sb4" pos="31:28" rst="0x0"/>
        <bits access="rw" name="pmi_sb3" pos="27:24" rst="0x0"/>
        <bits access="rw" name="pmi_sb2" pos="23:20" rst="0x0"/>
        <bits access="rw" name="pmi_sb1" pos="19:16" rst="0x0"/>
        <bits access="rw" name="pmi_prb99" pos="15:12" rst="0x0"/>
        <bits access="rw" name="pmi_prb98" pos="11:8" rst="0x0"/>
        <bits access="rw" name="pmi_prb97" pos="7:4" rst="0x0"/>
        <bits access="rw" name="pmi_prb96" pos="3:0" rst="0x0"/>
      </reg>
      <hole size="228960"/>
      <reg name="cell_qfmem3" protect="rw">
        <bits access="rw" name="cell_qfmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="cell_qfmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="ct_qtmem3" protect="rw">
        <bits access="rw" name="ct_qtmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem3_p01_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem3_p01_tap3" protect="rw">
        <bits access="rw" name="ct_qtmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="1184"/>
      <reg name="ct_qtmem3_p23_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="63392"/>
      <reg name="dt_qtmem3" protect="rw">
        <bits access="rw" name="dt_qtmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="dt_qtmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="4849632"/>
      <reg name="sdmemch0" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="sdmemch1" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="sdmemcg0" protect="rw">
        <bits access="rw" name="sdmemcg0" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="sdmemcg1" protect="rw">
        <bits access="rw" name="sdmemcg1" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="sdmemdh0" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="sdmemdh1" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="sdmemdg0" protect="rw">
        <bits access="rw" name="sdmemdg0" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="sdmemdg1" protect="rw">
        <bits access="rw" name="sdmemdg1" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="sdmemdg2" protect="rw">
        <bits access="r" name="sdmemdg2" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="sdmemdg3" protect="rw">
        <bits access="r" name="sdmemdg3" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="6717408"/>
      <reg name="pdcch_memin" protect="rw">
        <bits access="rw" name="pdcch_memin_2" pos="31:21" rst="0x0"/>
        <bits access="rw" name="pdcch_memin_1" pos="15:5" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="pdcch_memgold" protect="rw">
        </reg>
      <hole size="16352"/>
      <reg name="pdcch_mempbch0" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="pdcch_mempbch1" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="pdcch_mempbch2" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="dci0_out1" protect="rw">
        <comment>DCI0输出寄存器1</comment>
      </reg>
      <reg name="dci0_out2" protect="rw">
        <comment>DCI0输出寄存器2</comment>
      </reg>
      <reg name="dci0_pwr" protect="rw">
        <comment>DCI0功率寄存器</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI功率</comment>
        </bits>
      </reg>
      <reg name="dci0_fa" protect="rw">
        <comment>DCI0  LLR寄存器</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm软信息为0的个数</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm的输出重构差异个数</comment>
        </bits>
      </reg>
      <reg name="dci0_info1" protect="rw">
        <comment>DCI0 信息寄存器1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>天线选择：
0：天线0
1：天线1</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI1A下：
0：非ORDER
1：ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI指示：
0：授权
1：激活
2：释放
3：无效</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI格式类型：
0:DCI0
1:DCI1
2:DCI1A
3:DCI1B
4:DCI1C
5:DCI1D
6:DCI2
7:DCI2A
8:DCI2B
9:DCI2C
10:DCI3/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>检出DCI 所用的RNTI指示：
0：RNTI0：SI-RNTI；
1：RNTI1：P-RNTI；
2：RNTI2：RA-RNTI；
3：RNTI3：C-RNTI；
4：RNTI4：SPS-RNTI；
5：RNTI5：T-RNTI；
6：RNTI6：TPCS-RNTI；
7：RNTI7：TPCC-RNTI
8：RNTI8：G-RNTI
9：RNTI9：SC-RNTI
10：RNTI10：SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>检出DCI是在COMM还是UE空间检出：
0：公共空间
1：UE空间</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>检出DCI数据的起始地址(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>检出DCI所在的L等级指示：
000：L=1;
001：L=2;
010：L=4;
011：L=8;
100：L=12;
101：L=16;
110：L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>检出DCI 长度(max38)</comment>
        </bits>
      </reg>
      <reg name="dci0_info2" protect="rw">
        <comment>DCI0 信息寄存器2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>选择使用上报的PMI，还是选择使用DCI下发的PMI：
0：选择使用DCI下发的PMI
1：选择使用上报的PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ进程:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>预编码指示：tx2:0~3，tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>传输方案：
0：单天线
1：发射分集
2：空间复用
3：PORT7
4：PORT8
5：PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid的值(UE业务加扰用)：0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>调制格式：
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>传输块长度：max12216</comment>
        </bits>
      </reg>
      <reg name="dci0_info3" protect="rw">
        <comment>DCI0 信息寄存器3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI0C中的重复次数指示</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment>调制编码方案</comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI2/DCI2A/DCI2B/DCI2C：2码字激活标志：
0：1码字激活
1：2码字激活</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI0的循环移位指示</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI0的CQI指示</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI2/DCI2A：TB到CW的映射是否交叉映射：
0：正常映射
1：交织映射</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS请求：
SRQ高层配置了的情况下：DCI0、DCI1A、DCI2B TDD、DCI2C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment>新数据反转指示</comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI1D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI域</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment>功控参数</comment>
        </bits>
      </reg>
      <reg name="dci0_info4" protect="rw">
        <comment>DCI0 信息寄存器4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment>填充域</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>资源分配类型：
0：TYPE0
1：TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0的跳频标志指示</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1的资源块分配RBA</comment>
        </bits>
      </reg>
      <reg name="dci0_info5" protect="rw">
        <comment>DCI0 信息寄存器5</comment>
      </reg>
      <reg name="dci0_info6" protect="rw">
        <comment>DCI0 信息寄存器6</comment>
      </reg>
      <reg name="dci0_info7" protect="rw">
        <comment>DCI0 信息寄存器7</comment>
      </reg>
      <reg name="dci0_info8" protect="rw">
        <comment>DCI0 信息寄存器8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci0_info9" protect="rw">
        <comment>DCI0 信息寄存器9</comment>
      </reg>
      <reg name="dci0_info10" protect="rw">
        <comment>DCI0 信息寄存器10</comment>
      </reg>
      <reg name="dci0_info11" protect="rw">
        <comment>DCI0 信息寄存器11</comment>
      </reg>
      <reg name="dci0_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>后0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci1_out1" protect="rw">
        <comment>DCI1输出寄存器1</comment>
      </reg>
      <reg name="dci1_out2" protect="rw">
        <comment>DCI1输出寄存器2</comment>
      </reg>
      <reg name="dci1_pwr" protect="rw">
        <comment>DCI1功率寄存器</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI功率</comment>
        </bits>
      </reg>
      <reg name="dci1_fa" protect="rw">
        <comment>DCI1  LLR寄存器</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm软信息为0的个数</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm的输出重构差异个数</comment>
        </bits>
      </reg>
      <reg name="dci1_info1" protect="rw">
        <comment>DCI1 信息寄存器1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>天线选择：
0：天线0
1：天线1</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI1A下：
0：非ORDER
1：ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI指示：
0：授权
1：激活
2：释放
3：无效</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI格式类型：
0:DCI1
1:DCI1
2:DCI1A
3:DCI1B
4:DCI1C
5:DCI1D
6:DCI2
7:DCI2A
8:DCI2B
9:DCI2C
10:DCI3/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>检出DCI 所用的RNTI指示：
0：RNTI0：SI-RNTI；
1：RNTI1：P-RNTI；
2：RNTI2：RA-RNTI；
3：RNTI3：C-RNTI；
4：RNTI4：SPS-RNTI；
5：RNTI5：T-RNTI；
6：RNTI6：TPCS-RNTI；
7：RNTI7：TPCC-RNTI
8：RNTI8：G-RNTI
9：RNTI9：SC-RNTI
10：RNTI10：SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>检出DCI是在COMM还是UE空间检出：
0：公共空间
1：UE空间</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>检出DCI数据的起始地址(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>检出DCI所在的L等级指示：
000：L=1;
001：L=2;
010：L=4;
011：L=8;
100：L=12;
101：L=16;
110：L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>检出DCI 长度(max38)</comment>
        </bits>
      </reg>
      <reg name="dci1_info2" protect="rw">
        <comment>DCI1 信息寄存器2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>选择使用上报的PMI，还是选择使用DCI下发的PMI：
0：选择使用DCI下发的PMI
1：选择使用上报的PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ进程:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>预编码指示：tx2:0~3，tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>传输方案：
0：单天线
1：发射分集
2：空间复用
3：PORT7
4：PORT8
5：PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid的值(UE业务加扰用)：0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>调制格式：
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>传输块长度：max12216</comment>
        </bits>
      </reg>
      <reg name="dci1_info3" protect="rw">
        <comment>DCI1 信息寄存器3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI1C中的重复次数指示</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment>调制编码方案</comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI2/DCI2A/DCI2B/DCI2C：2码字激活标志：
0：1码字激活
1：2码字激活</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI1的循环移位指示</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI1的CQI指示</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI2/DCI2A：TB到CW的映射是否交叉映射：
0：正常映射
1：交织映射</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS请求：
SRQ高层配置了的情况下：DCI1、DCI1A、DCI2B TDD、DCI2C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment>新数据反转指示</comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI1D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI域</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment>功控参数</comment>
        </bits>
      </reg>
      <reg name="dci1_info4" protect="rw">
        <comment>DCI1 信息寄存器4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment>填充域</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>资源分配类型：
0：TYPE0
1：TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0的跳频标志指示</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1的资源块分配RBA</comment>
        </bits>
      </reg>
      <reg name="dci1_info5" protect="rw">
        <comment>DCI1 信息寄存器5</comment>
      </reg>
      <reg name="dci1_info6" protect="rw">
        <comment>DCI1 信息寄存器6</comment>
      </reg>
      <reg name="dci1_info7" protect="rw">
        <comment>DCI1 信息寄存器7</comment>
      </reg>
      <reg name="dci1_info8" protect="rw">
        <comment>DCI1 信息寄存器8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci1_info9" protect="rw">
        <comment>DCI1 信息寄存器9</comment>
      </reg>
      <reg name="dci1_info10" protect="rw">
        <comment>DCI1 信息寄存器10</comment>
      </reg>
      <reg name="dci1_info11" protect="rw">
        <comment>DCI1 信息寄存器11</comment>
      </reg>
      <reg name="dci1_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>后0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci2_out1" protect="rw">
        <comment>DCI2输出寄存器1</comment>
      </reg>
      <reg name="dci2_out2" protect="rw">
        <comment>DCI2输出寄存器2</comment>
      </reg>
      <reg name="dci2_pwr" protect="rw">
        <comment>DCI2功率寄存器</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI功率</comment>
        </bits>
      </reg>
      <reg name="dci2_fa" protect="rw">
        <comment>DCI2  LLR寄存器</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm软信息为0的个数</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm的输出重构差异个数</comment>
        </bits>
      </reg>
      <reg name="dci2_info1" protect="rw">
        <comment>DCI2 信息寄存器1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>天线选择：
0：天线0
1：天线1</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI2A下：
0：非ORDER
1：ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI指示：
0：授权
1：激活
2：释放
3：无效</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI格式类型：
0:DCI2
1:DCI2
2:DCI2A
3:DCI2B
4:DCI2C
5:DCI2D
6:DCI2
7:DCI2A
8:DCI2B
9:DCI2C
10:DCI3/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>检出DCI 所用的RNTI指示：
0：RNTI0：SI-RNTI；
1：RNTI1：P-RNTI；
2：RNTI2：RA-RNTI；
3：RNTI3：C-RNTI；
4：RNTI4：SPS-RNTI；
5：RNTI5：T-RNTI；
6：RNTI6：TPCS-RNTI；
7：RNTI7：TPCC-RNTI
8：RNTI8：G-RNTI
9：RNTI9：SC-RNTI
10：RNTI10：SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>检出DCI是在COMM还是UE空间检出：
0：公共空间
1：UE空间</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>检出DCI数据的起始地址(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>检出DCI所在的L等级指示：
000：L=1;
001：L=2;
010：L=4;
011：L=8;
100：L=12;
101：L=16;
110：L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>检出DCI 长度(max38)</comment>
        </bits>
      </reg>
      <reg name="dci2_info2" protect="rw">
        <comment>DCI2 信息寄存器2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>选择使用上报的PMI，还是选择使用DCI下发的PMI：
0：选择使用DCI下发的PMI
1：选择使用上报的PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ进程:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>预编码指示：tx2:0~3，tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>传输方案：
0：单天线
1：发射分集
2：空间复用
3：PORT7
4：PORT8
5：PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid的值(UE业务加扰用)：0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>调制格式：
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>传输块长度：max12216</comment>
        </bits>
      </reg>
      <reg name="dci2_info3" protect="rw">
        <comment>DCI2 信息寄存器3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI2C中的重复次数指示</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment>调制编码方案</comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI2/DCI2A/DCI2B/DCI2C：2码字激活标志：
0：1码字激活
1：2码字激活</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI2的循环移位指示</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI2的CQI指示</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI2/DCI2A：TB到CW的映射是否交叉映射：
0：正常映射
1：交织映射</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS请求：
SRQ高层配置了的情况下：DCI2、DCI2A、DCI2B TDD、DCI2C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment>新数据反转指示</comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI2D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI域</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment>功控参数</comment>
        </bits>
      </reg>
      <reg name="dci2_info4" protect="rw">
        <comment>DCI2 信息寄存器4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment>填充域</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>资源分配类型：
0：TYPE0
1：TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0的跳频标志指示</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1的资源块分配RBA</comment>
        </bits>
      </reg>
      <reg name="dci2_info5" protect="rw">
        <comment>DCI2 信息寄存器5</comment>
      </reg>
      <reg name="dci2_info6" protect="rw">
        <comment>DCI2 信息寄存器6</comment>
      </reg>
      <reg name="dci2_info7" protect="rw">
        <comment>DCI2 信息寄存器7</comment>
      </reg>
      <reg name="dci2_info8" protect="rw">
        <comment>DCI2 信息寄存器8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci2_info9" protect="rw">
        <comment>DCI2 信息寄存器9</comment>
      </reg>
      <reg name="dci2_info10" protect="rw">
        <comment>DCI2 信息寄存器10</comment>
      </reg>
      <reg name="dci2_info11" protect="rw">
        <comment>DCI2 信息寄存器11</comment>
      </reg>
      <reg name="dci2_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>后0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci3_out1" protect="rw">
        <comment>DCI3输出寄存器1</comment>
      </reg>
      <reg name="dci3_out2" protect="rw">
        <comment>DCI3输出寄存器2</comment>
      </reg>
      <reg name="dci3_pwr" protect="rw">
        <comment>DCI3功率寄存器</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI功率</comment>
        </bits>
      </reg>
      <reg name="dci3_fa" protect="rw">
        <comment>DCI3  LLR寄存器</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm软信息为0的个数</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm的输出重构差异个数</comment>
        </bits>
      </reg>
      <reg name="dci3_info1" protect="rw">
        <comment>DCI3 信息寄存器1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>天线选择：
0：天线0
1：天线1</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI3A下：
0：非ORDER
1：ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI指示：
0：授权
1：激活
2：释放
3：无效</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI格式类型：
0:DCI3
1:DCI3
2:DCI3A
3:DCI3B
4:DCI3C
5:DCI3D
6:DCI3
7:DCI3A
8:DCI3B
9:DCI3C
10:DCI3/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>检出DCI 所用的RNTI指示：
0：RNTI0：SI-RNTI；
1：RNTI1：P-RNTI；
2：RNTI2：RA-RNTI；
3：RNTI3：C-RNTI；
4：RNTI4：SPS-RNTI；
5：RNTI5：T-RNTI；
6：RNTI6：TPCS-RNTI；
7：RNTI7：TPCC-RNTI
8：RNTI8：G-RNTI
9：RNTI9：SC-RNTI
10：RNTI10：SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>检出DCI是在COMM还是UE空间检出：
0：公共空间
1：UE空间</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>检出DCI数据的起始地址(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>检出DCI所在的L等级指示：
000：L=1;
001：L=2;
010：L=4;
011：L=8;
100：L=12;
101：L=16;
110：L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>检出DCI 长度(max38)</comment>
        </bits>
      </reg>
      <reg name="dci3_info2" protect="rw">
        <comment>DCI3 信息寄存器2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>选择使用上报的PMI，还是选择使用DCI下发的PMI：
0：选择使用DCI下发的PMI
1：选择使用上报的PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ进程:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>预编码指示：tx2:0~3，tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>传输方案：
0：单天线
1：发射分集
2：空间复用
3：PORT7
4：PORT8
5：PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid的值(UE业务加扰用)：0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>调制格式：
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>传输块长度：max12216</comment>
        </bits>
      </reg>
      <reg name="dci3_info3" protect="rw">
        <comment>DCI3 信息寄存器3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI3C中的重复次数指示</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment>调制编码方案</comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI3/DCI3A/DCI3B/DCI3C：2码字激活标志：
0：1码字激活
1：2码字激活</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI3的循环移位指示</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI3的CQI指示</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI3/DCI3A：TB到CW的映射是否交叉映射：
0：正常映射
1：交织映射</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS请求：
SRQ高层配置了的情况下：DCI3、DCI3A、DCI3B TDD、DCI3C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment>新数据反转指示</comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI3D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI域</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment>功控参数</comment>
        </bits>
      </reg>
      <reg name="dci3_info4" protect="rw">
        <comment>DCI3 信息寄存器4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment>填充域</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>资源分配类型：
0：TYPE0
1：TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0的跳频标志指示</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1的资源块分配RBA</comment>
        </bits>
      </reg>
      <reg name="dci3_info5" protect="rw">
        <comment>DCI3 信息寄存器5</comment>
      </reg>
      <reg name="dci3_info6" protect="rw">
        <comment>DCI3 信息寄存器6</comment>
      </reg>
      <reg name="dci3_info7" protect="rw">
        <comment>DCI3 信息寄存器7</comment>
      </reg>
      <reg name="dci3_info8" protect="rw">
        <comment>DCI3 信息寄存器8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci3_info9" protect="rw">
        <comment>DCI3 信息寄存器9</comment>
      </reg>
      <reg name="dci3_info10" protect="rw">
        <comment>DCI3 信息寄存器10</comment>
      </reg>
      <reg name="dci3_info11" protect="rw">
        <comment>DCI3 信息寄存器11</comment>
      </reg>
      <reg name="dci3_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>后0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci4_out1" protect="rw">
        <comment>DCI4输出寄存器1</comment>
      </reg>
      <reg name="dci4_out2" protect="rw">
        <comment>DCI4输出寄存器2</comment>
      </reg>
      <reg name="dci4_pwr" protect="rw">
        <comment>DCI4功率寄存器</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI功率</comment>
        </bits>
      </reg>
      <reg name="dci4_fa" protect="rw">
        <comment>DCI4  LLR寄存器</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm软信息为0的个数</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm的输出重构差异个数</comment>
        </bits>
      </reg>
      <reg name="dci4_info1" protect="rw">
        <comment>DCI4 信息寄存器1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>天线选择：
0：天线0
1：天线1</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI4A下：
0：非ORDER
1：ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI指示：
0：授权
1：激活
2：释放
3：无效</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI格式类型：
0:DCI4
1:DCI4
2:DCI4A
3:DCI4B
4:DCI4C
5:DCI4D
6:DCI4
7:DCI4A
8:DCI4B
9:DCI4C
10:DCI4/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>检出DCI 所用的RNTI指示：
0：RNTI0：SI-RNTI；
1：RNTI1：P-RNTI；
2：RNTI2：RA-RNTI；
3：RNTI3：C-RNTI；
4：RNTI4：SPS-RNTI；
5：RNTI5：T-RNTI；
6：RNTI6：TPCS-RNTI；
7：RNTI7：TPCC-RNTI
8：RNTI8：G-RNTI
9：RNTI9：SC-RNTI
10：RNTI10：SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>检出DCI是在COMM还是UE空间检出：
0：公共空间
1：UE空间</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>检出DCI数据的起始地址(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>检出DCI所在的L等级指示：
000：L=1;
001：L=2;
010：L=4;
011：L=8;
100：L=12;
101：L=16;
110：L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>检出DCI 长度(max38)</comment>
        </bits>
      </reg>
      <reg name="dci4_info2" protect="rw">
        <comment>DCI4 信息寄存器2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>选择使用上报的PMI，还是选择使用DCI下发的PMI：
0：选择使用DCI下发的PMI
1：选择使用上报的PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ进程:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>预编码指示：tx2:0~3，tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>传输方案：
0：单天线
1：发射分集
2：空间复用
3：PORT7
4：PORT8
5：PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid的值(UE业务加扰用)：0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>调制格式：
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>传输块长度：max12216</comment>
        </bits>
      </reg>
      <reg name="dci4_info3" protect="rw">
        <comment>DCI4 信息寄存器3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI4C中的重复次数指示</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment>调制编码方案</comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI4/DCI4A/DCI4B/DCI4C：2码字激活标志：
0：1码字激活
1：2码字激活</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI4的循环移位指示</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI4的CQI指示</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI4/DCI4A：TB到CW的映射是否交叉映射：
0：正常映射
1：交织映射</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS请求：
SRQ高层配置了的情况下：DCI4、DCI4A、DCI4B TDD、DCI4C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment>新数据反转指示</comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI4D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI域</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment>功控参数</comment>
        </bits>
      </reg>
      <reg name="dci4_info4" protect="rw">
        <comment>DCI4 信息寄存器4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment>填充域</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>资源分配类型：
0：TYPE0
1：TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0的跳频标志指示</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1的资源块分配RBA</comment>
        </bits>
      </reg>
      <reg name="dci4_info5" protect="rw">
        <comment>DCI4 信息寄存器5</comment>
      </reg>
      <reg name="dci4_info6" protect="rw">
        <comment>DCI4 信息寄存器6</comment>
      </reg>
      <reg name="dci4_info7" protect="rw">
        <comment>DCI4 信息寄存器7</comment>
      </reg>
      <reg name="dci4_info8" protect="rw">
        <comment>DCI4 信息寄存器8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci4_info9" protect="rw">
        <comment>DCI4 信息寄存器9</comment>
      </reg>
      <reg name="dci4_info10" protect="rw">
        <comment>DCI4 信息寄存器10</comment>
      </reg>
      <reg name="dci4_info11" protect="rw">
        <comment>DCI4 信息寄存器11</comment>
      </reg>
      <reg name="dci4_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>后0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci5_out1" protect="rw">
        <comment>DCI5输出寄存器1</comment>
      </reg>
      <reg name="dci5_out2" protect="rw">
        <comment>DCI5输出寄存器2</comment>
      </reg>
      <reg name="dci5_pwr" protect="rw">
        <comment>DCI5功率寄存器</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI功率</comment>
        </bits>
      </reg>
      <reg name="dci5_fa" protect="rw">
        <comment>DCI5  LLR寄存器</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm软信息为0的个数</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm的输出重构差异个数</comment>
        </bits>
      </reg>
      <reg name="dci5_info1" protect="rw">
        <comment>DCI5 信息寄存器1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>天线选择：
0：天线0
1：天线1</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI5A下：
0：非ORDER
1：ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI指示：
0：授权
1：激活
2：释放
3：无效</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI格式类型：
0:DCI5
1:DCI5
2:DCI5A
3:DCI5B
4:DCI5C
5:DCI5D
6:DCI5
7:DCI5A
8:DCI5B
9:DCI5C
10:DCI5/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>检出DCI 所用的RNTI指示：
0：RNTI0：SI-RNTI；
1：RNTI1：P-RNTI；
2：RNTI2：RA-RNTI；
3：RNTI3：C-RNTI；
4：RNTI4：SPS-RNTI；
5：RNTI5：T-RNTI；
6：RNTI6：TPCS-RNTI；
7：RNTI7：TPCC-RNTI
8：RNTI8：G-RNTI
9：RNTI9：SC-RNTI
10：RNTI10：SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>检出DCI是在COMM还是UE空间检出：
0：公共空间
1：UE空间</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>检出DCI数据的起始地址(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>检出DCI所在的L等级指示：
000：L=1;
001：L=2;
010：L=4;
011：L=8;
100：L=12;
101：L=16;
110：L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>检出DCI 长度(max38)</comment>
        </bits>
      </reg>
      <reg name="dci5_info2" protect="rw">
        <comment>DCI5 信息寄存器2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>选择使用上报的PMI，还是选择使用DCI下发的PMI：
0：选择使用DCI下发的PMI
1：选择使用上报的PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ进程:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>预编码指示：tx2:0~3，tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>传输方案：
0：单天线
1：发射分集
2：空间复用
3：PORT7
4：PORT8
5：PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid的值(UE业务加扰用)：0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>调制格式：
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>传输块长度：max12216</comment>
        </bits>
      </reg>
      <reg name="dci5_info3" protect="rw">
        <comment>DCI5 信息寄存器3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI5C中的重复次数指示</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment>调制编码方案</comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI5/DCI5A/DCI5B/DCI5C：2码字激活标志：
0：1码字激活
1：2码字激活</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI5的循环移位指示</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI5的CQI指示</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI5/DCI5A：TB到CW的映射是否交叉映射：
0：正常映射
1：交织映射</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS请求：
SRQ高层配置了的情况下：DCI5、DCI5A、DCI5B TDD、DCI5C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment>新数据反转指示</comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI5D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI域</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment>功控参数</comment>
        </bits>
      </reg>
      <reg name="dci5_info4" protect="rw">
        <comment>DCI5 信息寄存器4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment>填充域</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>资源分配类型：
0：TYPE0
1：TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0的跳频标志指示</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1的资源块分配RBA</comment>
        </bits>
      </reg>
      <reg name="dci5_info5" protect="rw">
        <comment>DCI5 信息寄存器5</comment>
      </reg>
      <reg name="dci5_info6" protect="rw">
        <comment>DCI5 信息寄存器6</comment>
      </reg>
      <reg name="dci5_info7" protect="rw">
        <comment>DCI5 信息寄存器7</comment>
      </reg>
      <reg name="dci5_info8" protect="rw">
        <comment>DCI5 信息寄存器8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci5_info9" protect="rw">
        <comment>DCI5 信息寄存器9</comment>
      </reg>
      <reg name="dci5_info10" protect="rw">
        <comment>DCI5 信息寄存器10</comment>
      </reg>
      <reg name="dci5_info11" protect="rw">
        <comment>DCI5 信息寄存器11</comment>
      </reg>
      <reg name="dci5_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>后0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci6_out1" protect="rw">
        <comment>DCI6输出寄存器1</comment>
      </reg>
      <reg name="dci6_out2" protect="rw">
        <comment>DCI6输出寄存器2</comment>
      </reg>
      <reg name="dci6_pwr" protect="rw">
        <comment>DCI6功率寄存器</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI功率</comment>
        </bits>
      </reg>
      <reg name="dci6_fa" protect="rw">
        <comment>DCI6  LLR寄存器</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm软信息为0的个数</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm的输出重构差异个数</comment>
        </bits>
      </reg>
      <reg name="dci6_info1" protect="rw">
        <comment>DCI6 信息寄存器1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>天线选择：
0：天线0
1：天线1</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI6A下：
0：非ORDER
1：ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI指示：
0：授权
1：激活
2：释放
3：无效</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI格式类型：
0:DCI6
1:DCI6
2:DCI6A
3:DCI6B
4:DCI6C
5:DCI6D
6:DCI6
7:DCI6A
8:DCI6B
9:DCI6C
10:DCI6/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>检出DCI 所用的RNTI指示：
0：RNTI0：SI-RNTI；
1：RNTI1：P-RNTI；
2：RNTI2：RA-RNTI；
3：RNTI3：C-RNTI；
4：RNTI4：SPS-RNTI；
5：RNTI5：T-RNTI；
6：RNTI6：TPCS-RNTI；
7：RNTI7：TPCC-RNTI
8：RNTI8：G-RNTI
9：RNTI9：SC-RNTI
10：RNTI10：SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>检出DCI是在COMM还是UE空间检出：
0：公共空间
1：UE空间</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>检出DCI数据的起始地址(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>检出DCI所在的L等级指示：
000：L=1;
001：L=2;
010：L=4;
011：L=8;
100：L=12;
101：L=16;
110：L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>检出DCI 长度(max38)</comment>
        </bits>
      </reg>
      <reg name="dci6_info2" protect="rw">
        <comment>DCI6 信息寄存器2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>选择使用上报的PMI，还是选择使用DCI下发的PMI：
0：选择使用DCI下发的PMI
1：选择使用上报的PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ进程:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>预编码指示：tx2:0~3，tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>传输方案：
0：单天线
1：发射分集
2：空间复用
3：PORT7
4：PORT8
5：PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid的值(UE业务加扰用)：0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>调制格式：
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>传输块长度：max12216</comment>
        </bits>
      </reg>
      <reg name="dci6_info3" protect="rw">
        <comment>DCI6 信息寄存器3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI6C中的重复次数指示</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment>调制编码方案</comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI6/DCI6A/DCI6B/DCI6C：2码字激活标志：
0：1码字激活
1：2码字激活</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI6的循环移位指示</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI6的CQI指示</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI6/DCI6A：TB到CW的映射是否交叉映射：
0：正常映射
1：交织映射</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS请求：
SRQ高层配置了的情况下：DCI6、DCI6A、DCI6B TDD、DCI6C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment>新数据反转指示</comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI6D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI域</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment>功控参数</comment>
        </bits>
      </reg>
      <reg name="dci6_info4" protect="rw">
        <comment>DCI6 信息寄存器4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment>填充域</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>资源分配类型：
0：TYPE0
1：TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0的跳频标志指示</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1的资源块分配RBA</comment>
        </bits>
      </reg>
      <reg name="dci6_info5" protect="rw">
        <comment>DCI6 信息寄存器5</comment>
      </reg>
      <reg name="dci6_info6" protect="rw">
        <comment>DCI6 信息寄存器6</comment>
      </reg>
      <reg name="dci6_info7" protect="rw">
        <comment>DCI6 信息寄存器7</comment>
      </reg>
      <reg name="dci6_info8" protect="rw">
        <comment>DCI6 信息寄存器8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci6_info9" protect="rw">
        <comment>DCI6 信息寄存器9</comment>
      </reg>
      <reg name="dci6_info10" protect="rw">
        <comment>DCI6 信息寄存器10</comment>
      </reg>
      <reg name="dci6_info11" protect="rw">
        <comment>DCI6 信息寄存器11</comment>
      </reg>
      <reg name="dci6_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>后0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci7_out1" protect="rw">
        <comment>DCI7输出寄存器1</comment>
      </reg>
      <reg name="dci7_out2" protect="rw">
        <comment>DCI7输出寄存器2</comment>
      </reg>
      <reg name="dci7_pwr" protect="rw">
        <comment>DCI7功率寄存器</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI功率</comment>
        </bits>
      </reg>
      <reg name="dci7_fa" protect="rw">
        <comment>DCI7  LLR寄存器</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm软信息为0的个数</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm的输出重构差异个数</comment>
        </bits>
      </reg>
      <reg name="dci7_info1" protect="rw">
        <comment>DCI7 信息寄存器1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>天线选择：
0：天线0
1：天线1</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI7A下：
0：非ORDER
1：ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI指示：
0：授权
1：激活
2：释放
3：无效</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI格式类型：
0:DCI7
1:DCI7
2:DCI7A
3:DCI7B
4:DCI7C
5:DCI7D
6:DCI7
7:DCI7A
8:DCI7B
9:DCI7C
10:DCI7/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>检出DCI 所用的RNTI指示：
0：RNTI0：SI-RNTI；
1：RNTI1：P-RNTI；
2：RNTI2：RA-RNTI；
3：RNTI3：C-RNTI；
4：RNTI4：SPS-RNTI；
5：RNTI5：T-RNTI；
6：RNTI6：TPCS-RNTI；
7：RNTI7：TPCC-RNTI
8：RNTI8：G-RNTI
9：RNTI9：SC-RNTI
10：RNTI10：SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>检出DCI是在COMM还是UE空间检出：
0：公共空间
1：UE空间</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>检出DCI数据的起始地址(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>检出DCI所在的L等级指示：
000：L=1;
001：L=2;
010：L=4;
011：L=8;
100：L=12;
101：L=16;
110：L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>检出DCI 长度(max38)</comment>
        </bits>
      </reg>
      <reg name="dci7_info2" protect="rw">
        <comment>DCI7 信息寄存器2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>选择使用上报的PMI，还是选择使用DCI下发的PMI：
0：选择使用DCI下发的PMI
1：选择使用上报的PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ进程:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>预编码指示：tx2:0~3，tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>传输方案：
0：单天线
1：发射分集
2：空间复用
3：PORT7
4：PORT8
5：PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>资源分配类型：
0：集中式
1：分布式</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid的值(UE业务加扰用)：0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>冗余版本：0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>调制格式：
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>传输块长度：max12216</comment>
        </bits>
      </reg>
      <reg name="dci7_info3" protect="rw">
        <comment>DCI7 信息寄存器3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI7C中的重复次数指示</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment>调制编码方案</comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI7/DCI7A/DCI7B/DCI7C：2码字激活标志：
0：1码字激活
1：2码字激活</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI7的循环移位指示</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI7的CQI指示</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI7/DCI7A：TB到CW的映射是否交叉映射：
0：正常映射
1：交织映射</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS请求：
SRQ高层配置了的情况下：DCI7、DCI7A、DCI7B TDD、DCI7C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment>新数据反转指示</comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI7D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI域</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment>功控参数</comment>
        </bits>
      </reg>
      <reg name="dci7_info4" protect="rw">
        <comment>DCI7 信息寄存器4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment>填充域</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>资源分配类型：
0：TYPE0
1：TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0的跳频标志指示</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1的资源块分配RBA</comment>
        </bits>
      </reg>
      <reg name="dci7_info5" protect="rw">
        <comment>DCI7 信息寄存器5</comment>
      </reg>
      <reg name="dci7_info6" protect="rw">
        <comment>DCI7 信息寄存器6</comment>
      </reg>
      <reg name="dci7_info7" protect="rw">
        <comment>DCI7 信息寄存器7</comment>
      </reg>
      <reg name="dci7_info8" protect="rw">
        <comment>DCI7 信息寄存器8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>前0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <reg name="dci7_info9" protect="rw">
        <comment>DCI7 信息寄存器9</comment>
      </reg>
      <reg name="dci7_info10" protect="rw">
        <comment>DCI7 信息寄存器10</comment>
      </reg>
      <reg name="dci7_info11" protect="rw">
        <comment>DCI7 信息寄存器11</comment>
      </reg>
      <reg name="dci7_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>后0.5ms资源bitmap指示：对应bit表示不同的prb[99:96]，每个bit的意义如下：
0：某个prb不占用
1：某个prb占用</comment>
        </bits>
      </reg>
      <hole size="86016"/>
      <reg name="pdcch_memdem" protect="rw">
        <bits access="rw" name="pdcch_memdem_2" pos="31:21" rst="0x0"/>
        <bits access="rw" name="pdcch_memdem_1" pos="15:5" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="pdcch_memreg" protect="rw">
        </reg>
      <hole size="65504"/>
      <reg name="pdcch_mempbchin" protect="rw">
        <bits access="rw" name="pbch_memin_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="pbch_memin_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="8160"/>
      <reg name="mib0_out" protect="rw">
        <comment>MIB0输出寄存器1</comment>
        <bits access="r" name="mib0_out" pos="23:0" rst="0x0">
          <comment>MIB0的值</comment>
        </bits>
      </reg>
      <reg name="mib0_info" protect="rw">
        <comment>MIB0INFO寄存器</comment>
        <bits access="r" name="mib0_info" pos="1:0" rst="0x0">
          <comment>MIB 子帧信息</comment>
        </bits>
      </reg>
      <reg name="mib1_out" protect="rw">
        <comment>MIB1输出寄存器1</comment>
        <bits access="r" name="mib1_out" pos="23:0" rst="0x0">
          <comment>MIB1的值</comment>
        </bits>
      </reg>
      <reg name="mib1_info" protect="rw">
        <comment>MIB1INFO寄存器</comment>
        <bits access="r" name="mib1_info" pos="1:0" rst="0x0">
          <comment>MIB 子帧信息</comment>
        </bits>
      </reg>
      <reg name="mib2_out" protect="rw">
        <comment>MIB2输出寄存器1</comment>
        <bits access="r" name="mib2_out" pos="23:0" rst="0x0">
          <comment>MIB2的值</comment>
        </bits>
      </reg>
      <reg name="mib2_info" protect="rw">
        <comment>MIB2INFO寄存器</comment>
        <bits access="r" name="mib2_info" pos="1:0" rst="0x0">
          <comment>MIB 子帧信息</comment>
        </bits>
      </reg>
      <reg name="mib3_out" protect="rw">
        <comment>MIB3输出寄存器1</comment>
        <bits access="r" name="mib3_out" pos="23:0" rst="0x0">
          <comment>MIB3的值</comment>
        </bits>
      </reg>
      <reg name="mib3_info" protect="rw">
        <comment>MIB3INFO寄存器</comment>
        <bits access="r" name="mib3_info" pos="1:0" rst="0x0">
          <comment>MIB 子帧信息</comment>
        </bits>
      </reg>
      <hole size="7921408"/>
      <reg name="hqmem11" protect="rw">
        <bits access="rw" name="hqmem11_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="hqmem11_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="98272"/>
      <reg name="hqmem12" protect="rw">
        </reg>
      <hole size="950240"/>
      <reg name="hqmem21" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="hqmem22" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="hqmem23" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="hqmem24" protect="rw">
        </reg>
      <hole size="6553568"/>
      <reg name="tbmemin0" protect="rw">
        <bits access="rw" name="tbmemin0" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="229344"/>
      <reg name="tbmemout0" protect="rw">
        </reg>
      <hole size="294880"/>
      <reg name="tbmemin1" protect="rw">
        <bits access="rw" name="tbmemin1" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="229344"/>
      <reg name="tbmemout1" protect="rw">
        </reg>
      <hole size="294880"/>
      <reg name="pdsmemout0" protect="rw">
        </reg>
      <hole size="12256"/>
      <reg name="pdsmemout0_si" protect="rw">
        </reg>
      <hole size="2208"/>
      <reg name="pdsmemout0_pch" protect="rw">
        </reg>
      <hole size="18208"/>
      <reg name="pdsmemout1" protect="rw">
        </reg>
      <hole size="12256"/>
      <reg name="pdsmemout1_si" protect="rw">
        </reg>
      <hole size="2208"/>
      <reg name="pdsmemout1_pch" protect="rw">
        </reg>
      <hole size="7292704"/>
      <reg name="fftbuf0" protect="rw">
        </reg>
      <hole size="524256"/>
      <reg name="fftbuf1" protect="rw">
        </reg>
      <hole size="7864288"/>
      <reg name="hqbuf" protect="rw">
        </reg>
    </module>
    <instance address="0x19000000" name="LDTC1" type="LDTC1"/>
  </archive>
  <archive relative="dlfft.xml">
    <module category="System" name="DLFFT">
      <reg name="dlfft_frame_config_next" protect="rw">
        <comment>帧号配置寄存器</comment>
        <bits access="rw" name="crs_pow_ofdm0_next" pos="19" rst="0x1">
          <comment>CATM模式下CELL RS功率计算是否包含OFDM0：
0：不包含OFDM0
1：包含OFDM0</comment>
        </bits>
        <bits access="rw" name="fft_norm_sel_next" pos="18" rst="0x0">
          <comment>FFT运算每级归一化模式选择：
0：顶满次高位归一化
1：顶满最高位归一化</comment>
        </bits>
        <bits access="rw" name="fft_norm_en_next" pos="17" rst="0x0">
          <comment>0：FFT运算每级归一化不使能，FFT倒数第二级截位使能；
1：FFT运算每级归一化使能，FFT倒数第二级截位不使能；</comment>
        </bits>
        <bits access="rw" name="dlfft_only_en_next" pos="16" rst="0x0">
          <comment>0：DLFFT触发LDTC1或LDTC控制信号
1：DLFFT不触发LDTC1或LDTC控制信号</comment>
        </bits>
        <bits access="rw" name="fft_dma_inten_next" pos="15" rst="0x1">
          <comment>1：DLFFT输入搬数完成中断使能（到TXRX的中断，每个OFDM符号输入数据搬数完成后发出）
0：DLFFT输入搬数完成中断不使能</comment>
        </bits>
        <bits access="rw" name="master_card_next" pos="14" rst="0x0">
          <comment>0:主卡选择
1:辅卡选择</comment>
        </bits>
        <bits access="rw" name="sys_frame_num_next" pos="13:4" rst="0x0">
          <comment>系统帧号，取值范围0~1023</comment>
        </bits>
        <bits access="rw" name="sub_frame_num_next" pos="3:0" rst="0x0">
          <comment>子帧帧号，取值范围0~9</comment>
        </bits>
      </reg>
      <reg name="cat1_rs_ctrl_next" protect="rw">
        <comment>CAT1模式RS控制寄存器</comment>
        <bits access="rw" name="crs_pow_index_next" pos="21:19" rst="0x0">
          <comment>CELL RS功率最大值&amp;AGC值输出选择：
000：选择第一套输出寄存器
001：选择第二套输出寄存器
010：选择第三套输出寄存器
011：选择第四套输出寄存器
100：选择第五套输出寄存器
其他：默认选择第一套</comment>
        </bits>
        <bits access="rw" name="cat1_crs_pow_ofdm0_next" pos="18" rst="0x1">
          <comment>CAT1模式下CELL RS功率计算是否包含OFDM0：
0：不包含OFDM0
1：包含OFDM0</comment>
        </bits>
        <bits access="rw" name="mbms_mode_sel_next" pos="17:16" rst="0x0">
          <comment>MBMS业务子帧类型选择：
2’b00：MBMS业务子帧中没有CELLRS信息的符号
2’b01：MBMS业务子帧中有1个CELLRS信息的符号
2’b10：MBMS业务子帧中有2个CELLRS信息的符号
2’b11：硬件会默认为00来进行处理</comment>
        </bits>
        <bits access="rw" name="mbms_en_next" pos="15" rst="0x0">
          <comment>0：MBMS业务子帧不使能
1：MBMS业务子帧使能</comment>
        </bits>
        <bits access="rw" name="cellid_next" pos="14:6" rst="0x0">
          <comment>CELLID序号指示</comment>
        </bits>
        <bits access="rw" name="cp_sel_next" pos="5" rst="0x0">
          <comment>CP类型指示：
0：NORM CP
1：EX CP</comment>
        </bits>
        <bits access="rw" name="cellport_sel_next" pos="4:3" rst="0x0">
          <comment>CELLRS PORT类型指示：
2’b00：port0
2’b01：port0/1
2’b10：port0/1/2/3
2’b11：保留，当CELLPORT_SEL配置为2’b11：硬件会默认为2’b00（prot0）来进行处理</comment>
        </bits>
        <bits access="rw" name="ueport_sel_next" pos="2" rst="0x0">
          <comment>UERS PORT类型指示：
0：port5
1：port7/8</comment>
        </bits>
        <bits access="rw" name="cellrs_en_next" pos="1" rst="0x0">
          <comment>0：CELLRS抽取不使能
1：CELLRS抽取使能</comment>
        </bits>
        <bits access="rw" name="uers_en_next" pos="0" rst="0x0">
          <comment>0：UERS抽取不使能
1：UERS抽取使能</comment>
        </bits>
      </reg>
      <reg name="cat1_csi_para_next" protect="rw">
        <comment>CAT1模式CSIRS参数寄存器</comment>
        <bits access="rw" name="csirs_bitmap_next" pos="19:8" rst="0x0">
          <comment>若RS类型为CSIRS，则指示CSIRS BITMAP信息</comment>
        </bits>
        <bits access="rw" name="csirs_ofdm1_next" pos="7:4" rst="0x0">
          <comment>指示CSIRS抽取时第二个CSIRS信息的OFDM符号</comment>
        </bits>
        <bits access="rw" name="csirs_ofdm0_next" pos="3:0" rst="0x0">
          <comment>指示CSIRS抽取时第一个CSIRS信息的OFDM符号</comment>
        </bits>
      </reg>
      <reg name="cat1_agc_next" protect="rw">
        <comment>CAT1模式AGC参数寄存器</comment>
        <bits access="rw" name="agc1_next" pos="19:10" rst="0x0">
          <comment>MBMS业务子帧时非含CELLRS信息的OFDM符号的输入AGC值</comment>
        </bits>
        <bits access="rw" name="agc0_next" pos="9:0" rst="0x0">
          <comment>非MBMS业务子帧时输入AGC值或MBMS业务子帧时含CELLRS信息的OFDM符号的输入AGC值</comment>
        </bits>
      </reg>
      <reg name="cat1_dlfft_ctrl_next" protect="rw">
        <comment>DLFFT控制参数寄存器</comment>
        <bits access="rw" name="pbch_en_next" pos="1" rst="0x0">
          <comment>0：PBCH抽取不使能
1：PBCH抽取使能</comment>
        </bits>
        <bits access="rw" name="csirs_en_next" pos="0" rst="0x0">
          <comment>0：CSIRS抽取不使能
1：CSIRS抽取使能</comment>
        </bits>
      </reg>
      <reg name="cat1_sys_config_next" protect="rw">
        <comment>CAT1模式系统参数寄存器</comment>
        <bits access="rw" name="prb_index_next" pos="10:8" rst="0x0">
          <comment>系统带宽PRB索引值：
000：6prb
001：15prb
010：25prb
011：50prb
100：75prb
101：100prb
111：默认6prb</comment>
        </bits>
        <bits access="rw" name="up_down_config" pos="7:5" rst="0x0">
          <comment>上下行配比，取值范围0~6</comment>
        </bits>
        <bits access="rw" name="mode_sel_next" pos="4" rst="0x0">
          <comment>0：TDD MODE
1：FDD MODE</comment>
        </bits>
        <bits access="rw" name="s_frame_config" pos="3:0" rst="0x0">
          <comment>特殊子帧配置 ，取值范围 0~9</comment>
        </bits>
      </reg>
      <reg name="cat1_fft_gate_next" protect="rw">
        <comment>CAT1模式FFT倒数第二级饱和门限参数寄存器</comment>
        <bits access="rw" name="fft_gate_next" pos="12:0" rst="0x0">
          <comment>FFT倒数第二级判饱和的门限个数值（和系统带宽有关），范围0~4096</comment>
        </bits>
      </reg>
      <reg name="catm_nb_sys_config_next" protect="rw">
        <comment>CATM/NB模式系统参数配置寄存器</comment>
        <bits access="rw" name="prb_index_next" pos="11:9" rst="0x0">
          <comment>NBIOT时，指示NB所在的PRB位置，取值范围0~5</comment>
        </bits>
        <bits access="rw" name="cp_sel_next" pos="8" rst="0x0">
          <comment>CP类型指示：
0：普通CP
1：扩展CP</comment>
        </bits>
        <bits access="rw" name="up_down_config_next" pos="7:5" rst="0x0">
          <comment>上下行配比，取值范围0~6</comment>
        </bits>
        <bits access="rw" name="mode_sel_next" pos="4" rst="0x0">
          <comment>0：TDD MODE
1：FDD MODE</comment>
        </bits>
        <bits access="rw" name="s_frame_config_next" pos="3:0" rst="0x0">
          <comment>特殊子帧配置 ，取值范围 0~9</comment>
        </bits>
      </reg>
      <reg name="catm_nb_rs_config_next" protect="rw">
        <comment>CATM/NB模式RS抽取配置寄存器</comment>
        <bits access="rw" name="crs_pow_index_next" pos="15:13" rst="0x0">
          <comment>CELL RS功率最大值&amp;AGC值输出选择：
000：选择第一套输出寄存器
001：选择第二套输出寄存器
010：选择第三套输出寄存器
011：选择第四套输出寄存器
100：选择第五套输出寄存器
其他：默认选择第一套</comment>
        </bits>
        <bits access="rw" name="crs_nrs_sel_next" pos="12" rst="0x0">
          <comment>0：NB模式时抽取NRS信号
1：NB模式时抽取CRS信号</comment>
        </bits>
        <bits access="rw" name="id_value_next" pos="11:3" rst="0x0">
          <comment>表示CELLRS或NRS的ID序号值</comment>
        </bits>
        <bits access="rw" name="rsport_sel_next" pos="2:1" rst="0x0">
          <comment>CELLRS或NRS PORT类型指示：
2’b00：port0
2’b01：port0/1
2’b10：port0/1/2/3
2’b11：默认为2’b10处理</comment>
        </bits>
      </reg>
      <reg name="catm_nb_nbw_next" protect="rw">
        <comment>CATM/NB模式零频配置寄存器</comment>
        <bits access="rw" name="nbw_cover_zero_sel_next" pos="0" rst="0x0">
          <comment>窄带带宽是否包含零频点指示：
0：不包含零频点（包含零位置）
1：包含零频点（跳开零位置）</comment>
        </bits>
      </reg>
      <reg name="catm_agc_next" protect="rw">
        <comment>CATM模式AGC参数寄存器</comment>
        <bits access="rw" name="catm_agc_next" pos="9:0" rst="0x0">
          <comment>CATM模式输入AGC值</comment>
        </bits>
      </reg>
      <reg name="abis_config_next" protect="rw">
        <comment>ABIS参数配置寄存器</comment>
        <bits access="rw" name="frame_intra_sel_next" pos="31" rst="0x0">
          <comment>0：传给LDTC1的LLR移位值为0
1：传给LDTC1的LLR移位值为历史值</comment>
        </bits>
        <bits access="rw" name="ctcg_sel_next" pos="30" rst="0x0">
          <comment>CTCG起始位置选择：
0：从OFDM4(包括OFDM4)前有效CRS为样本
1：从OFDM8(包括OFDM8)前有效CRS为样本</comment>
        </bits>
        <bits access="rw" name="num_neibour_next" pos="29:28" rst="0x0">
          <comment>检测到干扰邻区的个数：
00：0个干扰邻区
01：1个干扰邻区
10：2个干扰邻区
其他：默认0个干扰邻区</comment>
        </bits>
        <bits access="rw" name="txnum_neibour_next2" pos="27:26" rst="0x0">
          <comment>干扰邻区2发射天线数：
00：1port
01：2port
10：4port
其他：默认1port</comment>
        </bits>
        <bits access="rw" name="txnum_neibour_next1" pos="25:24" rst="0x0">
          <comment>干扰邻区1发射天线数：
00：1port
01：2port
10：4port
其他：默认1port</comment>
        </bits>
        <bits access="rw" name="nrb_neibour_next2" pos="23:21" rst="0x0">
          <comment>干扰邻区2 系统带宽值：
000：6prb
001：15prb
010：25prb
011：50prb
100：75prb
101：100prb
其他：默认6prb</comment>
        </bits>
        <bits access="rw" name="nrb_neibour_next1" pos="20:18" rst="0x0">
          <comment>干扰邻区1 系统带宽值：
000：6prb
001：15prb
010：25prb
011：50prb
100：75prb
101：100prb
其他：默认6prb</comment>
        </bits>
        <bits access="rw" name="cellid_neibour_next2" pos="17:9" rst="0x0">
          <comment>干扰邻区2 CELL ID值</comment>
        </bits>
        <bits access="rw" name="cellid_neibour_next1" pos="8:0" rst="0x0">
          <comment>干扰邻区1 CELL ID值</comment>
        </bits>
      </reg>
      <reg name="delay_next1" protect="rw">
        <comment>干扰邻区1相对本区时延值寄存器</comment>
        <bits access="rw" name="delay_next1" pos="18:0" rst="0x0">
          <comment>干扰邻区1相对本区时延值（单位TS）</comment>
        </bits>
      </reg>
      <reg name="delay_next2" protect="rw">
        <comment>干扰邻区2相对本区时延值寄存器</comment>
        <bits access="rw" name="delay_next2" pos="18:0" rst="0x0">
          <comment>干扰邻区2相对本区时延值（单位TS）</comment>
        </bits>
      </reg>
      <reg name="pb_next" protect="rw">
        <comment>CRS符号与非CRS符号功率比值寄存器</comment>
        <bits access="rw" name="abis_llr_shift_modify_next" pos="12:8" rst="0x0"/>
        <bits access="rw" name="abis_start_ofdm_next" pos="7:4" rst="0x0">
          <comment>ABIS开始搜索干扰的起始OFDM符号数（取值范围0~13）</comment>
        </bits>
        <bits access="rw" name="pb_next" pos="1:0" rst="0x0">
          <comment>CRS符号与非CRS符号功率比值</comment>
        </bits>
      </reg>
      <reg name="noise_delta_next" protect="rw">
        <comment>噪声功率值寄存器</comment>
      </reg>
      <reg name="noise_agc_next" protect="rw">
        <comment>噪声AGC值寄存器</comment>
        <bits access="rw" name="noise_agc_next" pos="9:0" rst="0x0">
          <comment>输入噪声功率AGC值</comment>
        </bits>
      </reg>
      <reg name="dlfft_mode_next" protect="rw">
        <comment>模块工作模式选择寄存器</comment>
        <bits access="rw" name="dlfft_info_sel_next" pos="14" rst="0x0">
          <comment>0：选择DLFFT_INFO_OUT1输出
1：选择DLFFT_INFO_OUT2输出</comment>
        </bits>
        <bits access="rw" name="dlfft_info_next" pos="13:4" rst="0x0">
          <comment>DLFFT INFO信息输入</comment>
        </bits>
        <bits access="rw" name="crs_pow_clr_next" pos="3" rst="0x0">
          <comment>0：帧与帧之间比较CRS_POW_MAX值大小并输出POW最大值和对应AGC值
1：帧与帧之间不比较CRS_POW_MAX值大小，只输出当前帧的POW最大值和对应AGC值</comment>
        </bits>
        <bits access="rw" name="soft_irt_en_next" pos="2" rst="0x0">
          <comment>0：SOFT_IRT功能不使能
1：SOFT_IRT功能使能</comment>
        </bits>
        <bits access="rw" name="dlfft_mode_sel_next" pos="1:0" rst="0x0">
          <comment>00：CAT1模式
01：CATM模式
10：NB-IOT模式
11：默认CAT1模式</comment>
        </bits>
      </reg>
      <reg name="fft_lnum_next" protect="rw">
        <comment>FFT截位因子参数寄存器</comment>
        <bits access="rw" name="fft_lnum11_next" pos="21:20" rst="0x0">
          <comment>FFT第十一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_next" pos="19:18" rst="0x0">
          <comment>FFT第十级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_next" pos="17:16" rst="0x0">
          <comment>FFT第九级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~18bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_next" pos="15:14" rst="0x0">
          <comment>FFT第八级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~19bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_next" pos="13:12" rst="0x0">
          <comment>FFT第七级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~20bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_next" pos="11:10" rst="0x0">
          <comment>FFT第六级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~21bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_next" pos="9:8" rst="0x0">
          <comment>FFT第五级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~22bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_next" pos="7:6" rst="0x0">
          <comment>FFT第四级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~23bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_next" pos="5:4" rst="0x0">
          <comment>FFT第三级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~24bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_next" pos="3:2" rst="0x0">
          <comment>FFT第二级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~25bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_next" pos="1:0" rst="0x0">
          <comment>FFT第一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~26bit</comment>
        </bits>
      </reg>
      <reg name="dlfft_frame_config_curr" protect="rw">
        <comment>帧号配置寄存器</comment>
        <bits access="r" name="crs_pow_ofdm0_curr" pos="19" rst="0x1">
          <comment>ATM模式下CELL RS功率计算是否包含OFDM0：
0：不包含OFDM0
1：包含OFDM0</comment>
        </bits>
        <bits access="r" name="fft_norm_sel_curr" pos="18" rst="0x0">
          <comment>FFT运算每级归一化模式选择：
0：顶满次高位归一化
1：顶满最高位归一化</comment>
        </bits>
        <bits access="r" name="fft_norm_en_curr" pos="17" rst="0x0">
          <comment>0：FFT运算每级归一化不使能，FFT倒数第二级截位使能；
1：FFT运算每级归一化使能，FFT倒数第二级截位不使能；</comment>
        </bits>
        <bits access="r" name="dlfft_only_en_curr" pos="16" rst="0x0">
          <comment>0：DLFFT触发LDTC1或LDTC控制信号
1：DLFFT不触发LDTC1或LDTC控制信号</comment>
        </bits>
        <bits access="r" name="fft_dma_inten_curr" pos="15" rst="0x1">
          <comment>1：DLFFT输入搬数完成中断使能（到TXRX的中断，每个OFDM符号输入数据搬数完成后发出）
0：DLFFT输入搬数完成中断不使能</comment>
        </bits>
        <bits access="r" name="master_card_curr" pos="14" rst="0x0">
          <comment>0:主卡选择
1:辅卡选择</comment>
        </bits>
        <bits access="r" name="sys_frame_num_curr" pos="13:4" rst="0x0">
          <comment>系统帧号，取值范围0~1023</comment>
        </bits>
        <bits access="r" name="sub_frame_num_curr" pos="3:0" rst="0x0">
          <comment>子帧帧号，取值范围0~9</comment>
        </bits>
      </reg>
      <reg name="cat1_rs_ctrl_curr" protect="rw">
        <comment>CAT1模式RS控制寄存器</comment>
        <bits access="r" name="crs_pow_index_curr" pos="21:19" rst="0x0">
          <comment>CELL RS功率最大值&amp;AGC值输出选择：
000：选择第一套输出寄存器
001：选择第二套输出寄存器
010：选择第三套输出寄存器
011：选择第四套输出寄存器
100：选择第五套输出寄存器
其他：默认选择第一套</comment>
        </bits>
        <bits access="r" name="crs_pow_ofdm0_curr" pos="18" rst="0x1">
          <comment>CELL RS功率计算是否包含OFDM0：
0：不包含OFDM0
1：包含OFDM0</comment>
        </bits>
        <bits access="r" name="mbms_mode_sel_curr" pos="17:16" rst="0x0">
          <comment>MBMS业务子帧类型选择：
2’b00：MBMS业务子帧中没有CELLRS信息的符号
2’b01：MBMS业务子帧中有1个CELLRS信息的符号
2’b10：MBMS业务子帧中有2个CELLRS信息的符号
2’b11：硬件会默认为00来进行处理</comment>
        </bits>
        <bits access="r" name="mbms_en_curr" pos="15" rst="0x0">
          <comment>0：MBMS业务子帧不使能
1：MBMS业务子帧使能</comment>
        </bits>
        <bits access="r" name="cellid_curr" pos="14:6" rst="0x0">
          <comment>CELLID序号指示</comment>
        </bits>
        <bits access="r" name="cp_sel_curr" pos="5" rst="0x0">
          <comment>CP类型指示：
0：NORM CP
1：EX CP</comment>
        </bits>
        <bits access="r" name="cellport_sel_curr" pos="4:3" rst="0x0">
          <comment>CELLRS PORT类型指示：
2’b00：port0
2’b01：port0/1
2’b10：port0/1/2/3
2’b11：保留，当CELLPORT_SEL配置为2’b11：硬件会默认为2’b00（prot0）来进行处理</comment>
        </bits>
        <bits access="r" name="ueport_sel_curr" pos="2" rst="0x0">
          <comment>UERS PORT类型指示：
0：port5
1：port7/8</comment>
        </bits>
        <bits access="r" name="cellrs_en_curr" pos="1" rst="0x0">
          <comment>0：CELLRS抽取不使能
1：CELLRS抽取使能</comment>
        </bits>
        <bits access="r" name="uers_en_curr" pos="0" rst="0x0">
          <comment>0：UERS抽取不使能
1：UERS抽取使能</comment>
        </bits>
      </reg>
      <reg name="cat1_csi_para_curr" protect="rw">
        <comment>CAT1模式CSIRS参数寄存器</comment>
        <bits access="r" name="csirs_bitmap_curr" pos="19:8" rst="0x0">
          <comment>若RS类型为CSIRS，则指示CSIRS BITMAP信息</comment>
        </bits>
        <bits access="r" name="csirs_ofdm1_curr" pos="7:4" rst="0x0">
          <comment>指示CSIRS抽取时第二个CSIRS信息的OFDM符号</comment>
        </bits>
        <bits access="r" name="csirs_ofdm0_curr" pos="3:0" rst="0x0">
          <comment>指示CSIRS抽取时第一个CSIRS信息的OFDM符号</comment>
        </bits>
      </reg>
      <reg name="cat1_agc_curr" protect="rw">
        <comment>CAT1模式AGC参数寄存器</comment>
        <bits access="r" name="agc1_curr" pos="19:10" rst="0x0">
          <comment>MBMS业务子帧时非含CELLRS信息的OFDM符号的输入AGC值</comment>
        </bits>
        <bits access="r" name="agc0_curr" pos="9:0" rst="0x0">
          <comment>非MBMS业务子帧时输入AGC值或MBMS业务子帧时含CELLRS信息的OFDM符号的输入AGC值</comment>
        </bits>
      </reg>
      <reg name="cat1_dlfft_ctrl_curr" protect="rw">
        <comment>DLFFT控制参数寄存器</comment>
        <bits access="r" name="pbch_en_curr" pos="1" rst="0x0">
          <comment>0：PBCH抽取不使能
1：PBCH抽取使能</comment>
        </bits>
        <bits access="r" name="csirs_en_curr" pos="0" rst="0x0">
          <comment>0：CSIRS抽取不使能
1：CSIRS抽取使能</comment>
        </bits>
      </reg>
      <reg name="cat1_sys_config_curr" protect="rw">
        <comment>CAT1模式系统参数寄存器</comment>
        <bits access="r" name="prb_index_curr" pos="10:8" rst="0x0">
          <comment>系统带宽PRB索引值：
000：6prb
001：15prb
010：25prb
011：50prb
100：75prb
101：100prb
111：默认6prb</comment>
        </bits>
        <bits access="r" name="up_down_config" pos="7:5" rst="0x0">
          <comment>上下行配比，取值范围0~6</comment>
        </bits>
        <bits access="r" name="mode_sel_curr" pos="4" rst="0x0">
          <comment>0：TDD MODE
1：FDD MODE</comment>
        </bits>
        <bits access="r" name="s_frame_config" pos="3:0" rst="0x0">
          <comment>特殊子帧配置 ，取值范围 0~9</comment>
        </bits>
      </reg>
      <reg name="cat1_fft_gate_curr" protect="rw">
        <comment>CAT1模式FFT倒数第二级饱和门限参数寄存器</comment>
        <bits access="r" name="fft_gate_curr" pos="12:0" rst="0x0">
          <comment>FFT倒数第二级判饱和的门限个数值（和系统带宽有关），范围0~4096</comment>
        </bits>
      </reg>
      <reg name="catm_nb_sys_config_curr" protect="rw">
        <comment>CATM/NB模式系统参数配置寄存器</comment>
        <bits access="r" name="prb_index_curr" pos="11:9" rst="0x0">
          <comment>NBIOT时，指示NB所在的PRB位置，取值范围0~5</comment>
        </bits>
        <bits access="r" name="cp_sel_curr" pos="8" rst="0x0">
          <comment>CP类型指示：
0：普通CP
1：扩展CP</comment>
        </bits>
        <bits access="r" name="up_down_config_curr" pos="7:5" rst="0x0">
          <comment>上下行配比，取值范围0~6</comment>
        </bits>
        <bits access="r" name="mode_sel_curr" pos="4" rst="0x0">
          <comment>0：TDD MODE
1：FDD MODE</comment>
        </bits>
        <bits access="r" name="s_frame_config_curr" pos="3:0" rst="0x0">
          <comment>特殊子帧配置 ，取值范围 0~9</comment>
        </bits>
      </reg>
      <reg name="catm_nb_rs_config_curr" protect="rw">
        <comment>CATM/NB模式RS抽取配置寄存器</comment>
        <bits access="r" name="crs_pow_index_curr" pos="15:13" rst="0x0">
          <comment>CELL RS功率最大值&amp;AGC值输出选择：
000：选择第一套输出寄存器
001：选择第二套输出寄存器
010：选择第三套输出寄存器
011：选择第四套输出寄存器
100：选择第五套输出寄存器
其他：默认选择第一套</comment>
        </bits>
        <bits access="r" name="crs_nrs_sel_curr" pos="12" rst="0x0">
          <comment>0：NB模式时抽取NRS信号
1：NB模式时抽取CRS信号</comment>
        </bits>
        <bits access="r" name="id_value_curr" pos="11:3" rst="0x0">
          <comment>表示CELLRS或NRS的ID序号值</comment>
        </bits>
        <bits access="r" name="rsport_sel_curr" pos="2:1" rst="0x0">
          <comment>CELLRS或NRS PORT类型指示：
2’b00：port0
2’b01：port0/1
2’b10：port0/1/2/3
2’b11：默认为2’b10处理</comment>
        </bits>
      </reg>
      <reg name="catm_nb_nbw_curr" protect="rw">
        <comment>CATM/NB模式零频配置寄存器</comment>
        <bits access="r" name="nbw_cover_zero_sel_curr" pos="0" rst="0x0">
          <comment>窄带带宽是否包含零频点指示：
0：不包含零频点（包含零位置）
1：包含零频点（跳开零位置）</comment>
        </bits>
      </reg>
      <reg name="catm_agc_curr" protect="rw">
        <comment>CATM模式AGC参数寄存器</comment>
        <bits access="r" name="catm_agc_curr" pos="9:0" rst="0x0">
          <comment>CATM模式输入AGC值</comment>
        </bits>
      </reg>
      <reg name="abis_config_curr" protect="rw">
        <comment>ABIS参数配置寄存器</comment>
        <bits access="r" name="frame_intra_sel_curr" pos="31" rst="0x0">
          <comment>0：传给LDTC1的LLR移位值为0
1：传给LDTC1的LLR移位值为历史值</comment>
        </bits>
        <bits access="r" name="ctcg_sel_curr" pos="30" rst="0x0">
          <comment>CTCG起始位置选择：
0：从OFDM4(包括OFDM4)前有效CRS为样本
1：从OFDM8(包括OFDM8)前有效CRS为样本</comment>
        </bits>
        <bits access="r" name="num_neibour_curr" pos="29:28" rst="0x0">
          <comment>检测到干扰邻区的个数：
00：0个干扰邻区
01：1个干扰邻区
10：2个干扰邻区
其他：默认0个干扰邻区</comment>
        </bits>
        <bits access="r" name="txnum_neibour_curr2" pos="27:26" rst="0x0">
          <comment>干扰邻区2发射天线数：
00：1port
01：2port
10：4port
其他：默认1port</comment>
        </bits>
        <bits access="r" name="txnum_neibour_curr1" pos="25:24" rst="0x0">
          <comment>干扰邻区1发射天线数：
00：1port
01：2port
10：4port
其他：默认1port</comment>
        </bits>
        <bits access="r" name="nrb_neibour_curr2" pos="23:21" rst="0x0">
          <comment>干扰邻区2 系统带宽值：
000：6prb
001：15prb
010：25prb
011：50prb
100：75prb
101：100prb
其他：默认6prb</comment>
        </bits>
        <bits access="r" name="nrb_neibour_curr1" pos="20:18" rst="0x0">
          <comment>干扰邻区1 系统带宽值：
000：6prb
001：15prb
010：25prb
011：50prb
100：75prb
101：100prb
其他：默认6prb</comment>
        </bits>
        <bits access="r" name="cellid_neibour_curr2" pos="17:9" rst="0x0">
          <comment>干扰邻区2 CELL ID值</comment>
        </bits>
        <bits access="r" name="cellid_neibour_curr1" pos="8:0" rst="0x0">
          <comment>干扰邻区1 CELL ID值</comment>
        </bits>
      </reg>
      <reg name="delay_curr1" protect="rw">
        <comment>干扰邻区1相对本区时延值寄存器</comment>
        <bits access="r" name="delay_curr1" pos="18:0" rst="0x0">
          <comment>干扰邻区1相对本区时延值（单位TS）</comment>
        </bits>
      </reg>
      <reg name="delay_curr2" protect="rw">
        <comment>干扰邻区2相对本区时延值寄存器</comment>
        <bits access="r" name="delay_curr2" pos="18:0" rst="0x0">
          <comment>干扰邻区2相对本区时延值（单位TS）</comment>
        </bits>
      </reg>
      <reg name="pb_curr" protect="rw">
        <comment>CRS符号与非CRS符号功率比值寄存器</comment>
        <bits access="r" name="abis_llr_shift_modify_curr" pos="12:8" rst="0x0">
          <comment>ABIS LLR修正值（取值范围-8~8）</comment>
        </bits>
        <bits access="r" name="abis_start_ofdm_curr" pos="7:4" rst="0x0">
          <comment>ABIS开始搜索干扰的起始OFDM符号数（取值范围0~13）</comment>
        </bits>
        <bits access="r" name="pb_curr" pos="1:0" rst="0x0">
          <comment>CRS符号与非CRS符号功率比值</comment>
        </bits>
      </reg>
      <reg name="noise_delta_curr" protect="rw">
        <comment>噪声功率值寄存器</comment>
      </reg>
      <reg name="noise_agc_curr" protect="rw">
        <comment>噪声AGC值寄存器</comment>
        <bits access="r" name="noise_agc_curr" pos="9:0" rst="0x0">
          <comment>噪声AGC值</comment>
        </bits>
      </reg>
      <reg name="dlfft_mode_curr" protect="rw">
        <comment>模块工作模式选择寄存器</comment>
        <bits access="r" name="dlfft_info_sel_curr" pos="14" rst="0x0">
          <comment>0：选择DLFFT_INFO_OUT1输出
1：选择DLFFT_INFO_OUT2输出</comment>
        </bits>
        <bits access="r" name="dlfft_info_curr" pos="13:4" rst="0x0">
          <comment>DLFFT INFO信息输入</comment>
        </bits>
        <bits access="r" name="crs_pow_clr_curr" pos="3" rst="0x0">
          <comment>0：帧与帧之间比较CRS_POW_MAX值大小并输出POW最大值和对应AGC值
1：帧与帧之间不比较CRS_POW_MAX值大小，只输出当前帧的POW最大值和对应AGC值</comment>
        </bits>
        <bits access="r" name="soft_irt_en_curr" pos="2" rst="0x0">
          <comment>0：SOFT_IRT功能不使能
1：SOFT_IRT功能使能</comment>
        </bits>
        <bits access="r" name="dlfft_mode_sel_curr" pos="1:0" rst="0x0">
          <comment>00：CAT1模式
01：CATM模式
10：NB-IOT模式
11：默认CAT1模式</comment>
        </bits>
      </reg>
      <reg name="fft_lnum_curr" protect="rw">
        <comment>FFT截位因子参数寄存器</comment>
        <bits access="r" name="fft_lnum11_curr" pos="21:20" rst="0x0">
          <comment>FFT第十一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="r" name="fft_lnum10_curr" pos="19:18" rst="0x0">
          <comment>FFT第十级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="r" name="fft_lnum9_curr" pos="17:16" rst="0x0">
          <comment>FFT第九级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~18bit</comment>
        </bits>
        <bits access="r" name="fft_lnum8_curr" pos="15:14" rst="0x0">
          <comment>FFT第八级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~19bit</comment>
        </bits>
        <bits access="r" name="fft_lnum7_curr" pos="13:12" rst="0x0">
          <comment>FFT第七级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~20bit</comment>
        </bits>
        <bits access="r" name="fft_lnum6_curr" pos="11:10" rst="0x0">
          <comment>FFT第六级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~21bit</comment>
        </bits>
        <bits access="r" name="fft_lnum5_curr" pos="9:8" rst="0x0">
          <comment>FFT第五级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~22bit</comment>
        </bits>
        <bits access="r" name="fft_lnum4_curr" pos="7:6" rst="0x0">
          <comment>FFT第四级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~23bit</comment>
        </bits>
        <bits access="r" name="fft_lnum3_curr" pos="5:4" rst="0x0">
          <comment>FFT第三级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~24bit</comment>
        </bits>
        <bits access="r" name="fft_lnum2_curr" pos="3:2" rst="0x0">
          <comment>FFT第二级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~25bit</comment>
        </bits>
        <bits access="r" name="fft_lnum1_curr" pos="1:0" rst="0x0">
          <comment>FFT第一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~26bit</comment>
        </bits>
      </reg>
      <reg name="dlfft_inten" protect="rw">
        <comment>DLFFT中断使能控制寄存器</comment>
        <bits access="rw" name="spare3_err_inten" pos="12" rst="0x0">
          <comment>1：备用错误中断3使能
0：备用错误中断3不使能</comment>
        </bits>
        <bits access="rw" name="spare2_err_inten" pos="11" rst="0x0">
          <comment>1：备用错误中断2使能
0：备用错误中断2不使能</comment>
        </bits>
        <bits access="rw" name="iddet_err_inten" pos="10" rst="0x0">
          <comment>1：IDDET Online&amp;Offline冲突错误中断使能
0：IDDET Online&amp;Offline冲突错误中断不使能</comment>
        </bits>
        <bits access="rw" name="rxcapt_err_inten" pos="9" rst="0x0">
          <comment>1：RXCAPT错误中断使能
0：RXCAPT错误中断不使能</comment>
        </bits>
        <bits access="rw" name="rf_nodata_inten" pos="8" rst="0x0">
          <comment>1：RF无数据中断使能
0：RF无数据中断不使能</comment>
        </bits>
        <bits access="rw" name="rf_abnormal_up_inten" pos="7" rst="0x0">
          <comment>1：检测上行RF驱动配置异常中断使能
0：检测上行RF驱动配置异常中断不使能</comment>
        </bits>
        <bits access="rw" name="rf_abnormal_down_inten" pos="6" rst="0x0">
          <comment>1：检测下行RF驱动配置异常中断使能
0：检测下行RF驱动配置异常中断不使能</comment>
        </bits>
        <bits access="rw" name="rf_short_inten" pos="5" rst="0x0">
          <comment>1：检测RF少收数据中断使能
0：检测RF少收数据中断不使能</comment>
        </bits>
        <bits access="rw" name="rf_over_inten" pos="4" rst="0x0">
          <comment>1：检测RF多收数据中断使能
0：检测RF多收数据中断不使能</comment>
        </bits>
        <bits access="rw" name="axi_dma_inten" pos="3" rst="0x0">
          <comment>1：AXIDMA中断使能（送给
AXIDMA，DLFFT的最后一个
OFDM完成后发出）
0：AXIDMA中断不使能</comment>
        </bits>
        <bits access="rw" name="fft_err_inten" pos="2" rst="0x0">
          <comment>1：DLFFT访问TXRX or LDTC or LDTC1存储器ERROR中断使能
0：DLFFT访问TXRX or LDTCor LDTC1存储器ERROR中断不使能</comment>
        </bits>
        <bits access="rw" name="fft_core_inten" pos="1" rst="0x0">
          <comment>1：DLFFT中断使能（到核的中断，最后一个OFDM完成后发出）
0：DLFFT中断不使能</comment>
        </bits>
        <bits access="rw" name="fft_dma_inten" pos="0" rst="0x0">
          <comment>1：DLFFT输入搬数完成中断使能（到TXRX的中断，每个OFDM符号输入数据搬数完成后发出）
0：DLFFT输入搬数完成中断不使能</comment>
        </bits>
      </reg>
      <reg name="catm_nb_fft_gate" protect="rw">
        <comment>CATM/NB模式FFT倒数第二级饱和门限参数寄存器</comment>
        <bits access="rw" name="fft_gate" pos="12:0" rst="0x0">
          <comment>FFT倒数第二级判饱和的门限个数值，范围0~4096</comment>
        </bits>
      </reg>
      <reg name="dlfft_start" protect="rw">
        <comment>模块启动寄存器</comment>
        <bits access="rw" name="catm_nb_dlfft_start" pos="1" rst="0x0">
          <comment>0: CATM/NB模式本模块不启动
1: CATM/NB模式本模块启动</comment>
        </bits>
        <bits access="rw" name="cat1_dlfft_start" pos="0" rst="0x0">
          <comment>0: CAT1模式本模块不启动
1: CAT1模式本模块启动</comment>
        </bits>
      </reg>
      <reg name="dlfft_intf" protect="rw">
        <comment>中断标志寄存器</comment>
        <bits access="rc" name="spare3_errf" pos="19" rst="0x0">
          <comment>1：备用错误中断3标志置位
0：备用错误中断3标志未置位</comment>
        </bits>
        <bits access="rc" name="spare2_errf" pos="18" rst="0x0">
          <comment>1：备用错误中断2标志置位
0：备用错误中断2标志未置位</comment>
        </bits>
        <bits access="rc" name="iddet_errf" pos="17" rst="0x0">
          <comment>1：IDDET Online&amp;Offline冲突错误中断标志置位
0：IDDET Online&amp;Offline冲突错误中断标志未置位</comment>
        </bits>
        <bits access="rc" name="rxcapt_errf" pos="16" rst="0x0">
          <comment>1：RXCAPT错误中断标志置位
0：RXCAPT错误中断标志未置位</comment>
        </bits>
        <bits access="rc" name="measpwr_debug_errf" pos="15" rst="0x0">
          <comment>1：MEASPWR错误中断标志置位
0： MEASPWR错误中断标志未置位</comment>
        </bits>
        <bits access="rc" name="rf_nodata_errf" pos="14" rst="0x0">
          <comment>1：RF无数据中断标志置位
0：RF无数据中断标志未置位</comment>
        </bits>
        <bits access="rc" name="sd_rd_errf" pos="13" rst="0x0">
          <comment>1：SD访问DLFFT存储器错误中断标志置位
0：SD访问DLFFT存储器错误中断标志未置位</comment>
        </bits>
        <bits access="rc" name="coeff2ldtc_errf" pos="12" rst="0x0">
          <comment>1：COEFF访问LDTC中断标志置位
0：COEFF访问LDTC中断标志未置位</comment>
        </bits>
        <bits access="rc" name="coeff2ldtc1_errf" pos="11" rst="0x0">
          <comment>1：COEFF访问LDTC1中断标志置位
0：COEFF访问LDTC1中断标志未置位</comment>
        </bits>
        <bits access="rc" name="rf_abnormal_up_errf" pos="10" rst="0x0">
          <comment>1：上行RF驱动配置异常中断标志置位
0：上行RF驱动配置异常中断标志未置位</comment>
        </bits>
        <bits access="rc" name="rf_abnormal_down_errf" pos="9" rst="0x0">
          <comment>1：下行RF驱动配置异常中断标志置位
0：下行RF驱动配置异常中断标志未置位</comment>
        </bits>
        <bits access="rc" name="rf_short_errf" pos="8" rst="0x0">
          <comment>1：RF少收数据中断标志置位
0：RF少收数据中断标志未置位</comment>
        </bits>
        <bits access="rc" name="rf_over_errf" pos="7" rst="0x0">
          <comment>1：RF多收数据中断标志置位
0：RF多收数据中断标志未置位</comment>
        </bits>
        <bits access="rc" name="axi_dma_intf" pos="6" rst="0x0">
          <comment>1：AXIDMA中断标志置位（送给AXIDMA，DLFFT的最后一个OFDM完成后发出）
0：AXIDMA中断未置位</comment>
        </bits>
        <bits access="rc" name="csi_wr_errf" pos="5" rst="0x0">
          <comment>1：写CSI存储器时钟开启失败标志置位
0：写CSI存储器时钟开启失败标志未置位</comment>
        </bits>
        <bits access="rc" name="mmse_wr_errf" pos="4" rst="0x0">
          <comment>1：写MMSE存储器时钟开启失败标志置位
0：写MMSE存储器时钟开启失败标志未置位</comment>
        </bits>
        <bits access="rc" name="ldtc_wr_errf" pos="3" rst="0x0">
          <comment>1：写LDTC存储器时钟开启失败标志置位
0：写LDTC存储器时钟开启失败标志未置位</comment>
        </bits>
        <bits access="rc" name="txrx_rd_errf" pos="2" rst="0x0">
          <comment>1：读TXRX存储器时钟开启失败标志置位
0：读TXRX存储器时钟开启失败标志未置位</comment>
        </bits>
        <bits access="rc" name="fft_core_intf" pos="1" rst="0x0">
          <comment>1：DLFFT中断标志置位（到核的中断标志，最后一个OFDM完成后进行置位）
0：DLFFT中断标志未置位</comment>
        </bits>
        <bits access="rc" name="fft_dma_intf" pos="0" rst="0x0">
          <comment>1：DLFFT输入搬数完成中断标志置位（到TXRX的中断标志，每个OFDM   符号输入数据搬数完成后进行置位）
0：DLFFT输入搬数完成中断标志未置位</comment>
        </bits>
      </reg>
      <reg name="ofdm_count" protect="rw">
        <comment>OFDM符号计数寄存器</comment>
        <bits access="r" name="ofdm_count" pos="3:0" rst="0x0">
          <comment>指示当前的OFDM符号数，范围0~13</comment>
        </bits>
      </reg>
      <reg name="master_card" protect="rw">
        <comment>主辅卡输出寄存器</comment>
        <bits access="r" name="dlfft_info_out2" pos="20:11" rst="0x0">
          <comment>DLFFT INFO信息输出 2</comment>
        </bits>
        <bits access="r" name="dlfft_info_out1" pos="10:1" rst="0x0">
          <comment>DLFFT INFO信息输出 1</comment>
        </bits>
        <bits access="r" name="master_card_out" pos="0" rst="0x0">
          <comment>0：主卡完成
1：辅卡完成</comment>
        </bits>
      </reg>
      <reg name="llr_out1" protect="rw">
        <comment>ABIS干扰类型1移位值输出寄存器</comment>
        <bits access="r" name="llr_out1" pos="3:0" rst="0xf">
          <comment>ABIS干扰类型1（邻区1）移位值</comment>
        </bits>
      </reg>
      <reg name="llr_out2" protect="rw">
        <comment>ABIS干扰类型2移位值输出寄存器</comment>
        <bits access="r" name="llr_out2" pos="3:0" rst="0xf">
          <comment>ABIS干扰类型2（邻区2）移位值</comment>
        </bits>
      </reg>
      <reg name="llr_out3" protect="rw">
        <comment>ABIS干扰类型3移位值输出寄存器</comment>
        <bits access="r" name="llr_out3" pos="3:0" rst="0xf">
          <comment>ABIS干扰类型3（邻区1+2）移位值</comment>
        </bits>
      </reg>
      <reg name="crs_pow_max1" protect="rw">
        <comment>CELLRS功率最大值输出寄存器</comment>
      </reg>
      <reg name="crs_pow_agc1" protect="rw">
        <comment>CELLRS功率最大值AGC输出寄存器</comment>
        <bits access="r" name="crs_pow_agc1" pos="9:0" rst="0x0">
          <comment>CELLRS功率最大值AGC输出值</comment>
        </bits>
      </reg>
      <reg name="crs_pow_max2" protect="rw">
        <comment>CELLRS功率最大值输出寄存器</comment>
      </reg>
      <reg name="crs_pow_agc2" protect="rw">
        <comment>CELLRS功率最大值AGC输出寄存器</comment>
        <bits access="r" name="crs_pow_agc2" pos="9:0" rst="0x0">
          <comment>CELLRS功率最大值AGC输出值</comment>
        </bits>
      </reg>
      <reg name="crs_pow_max3" protect="rw">
        <comment>CELLRS功率最大值输出寄存器</comment>
      </reg>
      <reg name="crs_pow_agc3" protect="rw">
        <comment>CELLRS功率最大值AGC输出寄存器</comment>
        <bits access="r" name="crs_pow_agc3" pos="9:0" rst="0x0">
          <comment>CELLRS功率最大值AGC输出值</comment>
        </bits>
      </reg>
      <reg name="crs_pow_max4" protect="rw">
        <comment>CELLRS功率最大值输出寄存器</comment>
      </reg>
      <reg name="crs_pow_agc4" protect="rw">
        <comment>CELLRS功率最大值AGC输出寄存器</comment>
        <bits access="r" name="crs_pow_agc4" pos="9:0" rst="0x0">
          <comment>CELLRS功率最大值AGC输出值</comment>
        </bits>
      </reg>
      <reg name="crs_pow_max5" protect="rw">
        <comment>CELLRS功率最大值输出寄存器</comment>
      </reg>
      <reg name="crs_pow_agc5" protect="rw">
        <comment>CELLRS功率最大值AGC输出寄存器</comment>
        <bits access="r" name="crs_pow_agc5" pos="9:0" rst="0x0">
          <comment>CELLRS功率最大值AGC输出值</comment>
        </bits>
      </reg>
      <reg name="fsm_state" protect="rw">
        <comment>模块状态机输出寄存器</comment>
      </reg>
      <reg name="txrx_norm_gene1" protect="rw">
        <comment>TXRX模块归一化因子输出寄存器1</comment>
        <bits access="r" name="ofdm7_norm_gene" pos="31:28" rst="0x0">
          <comment>OFDM 7的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm6_norm_gene" pos="27:24" rst="0x0">
          <comment>OFDM 6的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm5_norm_gene" pos="23:20" rst="0x0">
          <comment>OFDM 5的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm4_norm_gene" pos="19:16" rst="0x0">
          <comment>OFDM 4的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm3_norm_gene" pos="15:12" rst="0x0">
          <comment>OFDM 3的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm2_norm_gene" pos="11:8" rst="0x0">
          <comment>OFDM 2的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm1_norm_gene" pos="7:4" rst="0x0">
          <comment>OFDM 1的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm0_norm_gene" pos="3:0" rst="0x0">
          <comment>OFDM 0的TXRX模块归一化因子输出</comment>
        </bits>
      </reg>
      <reg name="txrx_norm_gene2" protect="rw">
        <comment>TXRX模块归一化因子输出寄存器1</comment>
        <bits access="r" name="ofdm13_norm_gene" pos="23:20" rst="0x0">
          <comment>OFDM 13的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm12_norm_gene" pos="19:16" rst="0x0">
          <comment>OFDM 12的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm11_norm_gene" pos="15:12" rst="0x0">
          <comment>OFDM 11的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm10_norm_gene" pos="11:8" rst="0x0">
          <comment>OFDM 10的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm9_norm_gene" pos="7:4" rst="0x0">
          <comment>OFDM 9的TXRX模块归一化因子输出</comment>
        </bits>
        <bits access="r" name="ofdm8_norm_gene" pos="3:0" rst="0x0">
          <comment>OFDM 8的TXRX模块归一化因子输出</comment>
        </bits>
      </reg>
      <reg name="txrx_soft_offset" protect="rw">
        <comment>TXRX模块SOFT IRT因子输出寄存器</comment>
        <bits access="r" name="txrx_soft_offset1" pos="9:5" rst="0x0">
          <comment>TXRX模块SOFT IRT因子1输出</comment>
        </bits>
        <bits access="r" name="txrx_soft_offset0" pos="4:0" rst="0x0">
          <comment>TXRX模块SOFT IRT因子0输出</comment>
        </bits>
      </reg>
      <reg name="ofdm_assert" protect="rw">
        <comment>OFDM符号计数寄存器</comment>
        <bits access="r" name="txrx_enable_assert" pos="4" rst="0x0">
          <comment>ASSERT发生时采到的TXRX_ENABLE信号值</comment>
        </bits>
        <bits access="r" name="ofdm_assert" pos="3:0" rst="0x0">
          <comment>ASSERT发生时当前的OFDM符号数，范围0~13</comment>
        </bits>
      </reg>
      <reg name="fsm_state_assert" protect="rw">
        <comment>状态机输出寄存器</comment>
      </reg>
      <reg name=" abis_real_time_flag" protect="rw">
        <comment>ABIS实时计算标志寄存器</comment>
        <bits access="r" name="abis_real_time_flag3" pos="2" rst="0x0">
          <comment>0：ABIS当前帧无法完成LLR_OUT3实时计算
1：ABIS当前帧完成LLR_OUT3实时计算</comment>
        </bits>
        <bits access="r" name="abis_real_time_flag2" pos="1" rst="0x0">
          <comment>0：ABIS当前帧无法完成LLR_OUT2实时计算
1：ABIS当前帧完成LLR_OUT2实时计算</comment>
        </bits>
        <bits access="r" name="abis_real_time_flag1" pos="0" rst="0x0">
          <comment>0：ABIS当前帧无法完成LLR_OUT1实时计算
1：ABIS当前帧完成LLR_OUT1实时计算</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x18a00000" name="DLFFT" type="DLFFT"/>
  </archive>
  <archive relative="coeff.xml">
    <module category="System" name="COEFF">
      <reg name="qfqt_start" protect="rw">
        <comment>启动寄存器</comment>
        <bits access="rw" name="meas_en" pos="10" rst="0x0">
          <comment>Coeff输出至meas使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="ldtc_en" pos="9" rst="0x0">
          <comment>Coeff输出至ldtc\ldtc1使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="buf_sel" pos="8:7" rst="0x0">
          <comment>Coeff输出至ldtc\ldtc1 buf选择位
00：输出ldtc buf1
01：输出ldtc buf2
10：输出ldtc buf3
11：无效值</comment>
        </bits>
        <bits access="rw" name="cat_sel" pos="6" rst="0x0">
          <comment>CAT1和CATM模式选择
0：CATM模
1：CAT1模</comment>
        </bits>
        <bits access="rw" name="fast_mod" pos="5" rst="0x0">
          <comment>快速输出模式
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="port_sel" pos="4" rst="0x0">
          <comment>Port选择位
0：选择Port78
1：选择Port5</comment>
        </bits>
        <bits access="rw" name="qfqt_inten" pos="2" rst="0x0">
          <comment>中断使能信号：
0：QFQT中断不使能
1：QFQT中断使能</comment>
        </bits>
        <bits access="rw" name="cp_type" pos="1" rst="0x0">
          <comment>模式选择：
0: NCP
1: ECP</comment>
        </bits>
        <bits access="rw" name="qfqt_en" pos="0" rst="0x0">
          <comment>模块使能信号：
0: QFQT模块不使能
1: QFQT模块使能</comment>
        </bits>
      </reg>
      <reg name="qfqt_state" protect="rw">
        <comment>中断状态寄存器</comment>
        <bits access="rc" name="which_err" pos="3:2" rst="0x0">
          <comment>读写buf冲突的来源
00：来自ldtc buf1
01：来自ldtc buf2
10：来自ldtc buf3
11：来自meas buf</comment>
        </bits>
        <bits access="rc" name="err_state" pos="1" rst="0x0">
          <comment>冲突标志</comment>
        </bits>
        <bits access="rc" name="qfqt_intf" pos="0" rst="0x0">
          <comment>中断状态
0: 未完成系数矩阵求逆
1: 完成系数矩阵求逆</comment>
        </bits>
      </reg>
      <reg name="qf_conf" protect="rw">
        <comment>QF参数配置寄存器(在配置QT_CONF之前进行配置)</comment>
        <bits access="rw" name="sys_band_sel" pos="17:15" rst="0x0">
          <comment>系统带宽选择
000: 6PRB
001: 15PRB
010: 25PRB
011: 50PRB
100: 75PRB
101: 100PRB
Others: RESERVED 6PRB</comment>
        </bits>
        <bits access="rw" name="coeff_qf_snr" pos="14:4" rst="0x1">
          <comment>信噪比</comment>
        </bits>
        <bits access="rw" name="cha_mod" pos="1:0" rst="0x0">
          <comment>信道类型
00: EPA
01: EVA
10: ETU
11: RESERVED EPA</comment>
        </bits>
      </reg>
      <reg name="qt_conf" protect="rw">
        <comment>QT参数配置寄存器(在配置QF_CONF之后进行配置)</comment>
        <bits access="rw" name="doppler" pos="17:16" rst="0x0">
          <comment>多普勒值
00：5
01：70
10：300
11:   850</comment>
        </bits>
        <bits access="rw" name="tdd_fdd" pos="15" rst="0x0">
          <comment>TDD、FDD模式选择
0：TDD
1：FDD</comment>
        </bits>
        <bits access="rw" name="coeff_qt_snr" pos="14:4" rst="0x1">
          <comment>信噪比</comment>
        </bits>
        <bits access="rw" name="ss_sel" pos="3:0" rst="0x0">
          <comment>特殊子帧指示
0000：SS0
0001：SS1
0010：SS2
0011：SS3
0100：SS4
0101：SS5
0110：SS6
0111：SS7
1000：SS8
1001：SS9</comment>
        </bits>
      </reg>
      <reg name="sw_in" protect="rw">
        <comment>软件输入寄存器</comment>
        <bits access="rw" name="sw_in" pos="15:0" rst="0x0">
          <comment>软件输入寄存器</comment>
        </bits>
      </reg>
      <reg name="sw_out" protect="rw">
        <comment>软件输出寄存器</comment>
        <bits access="r" name="sw_out" pos="15:0" rst="0x0">
          <comment>软件输出寄存器</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x18200000" name="COEFF" type="COEFF"/>
  </archive>
  <archive relative="rfad.xml">
    <module category="System" name="RFAD">
      <reg name="mod_en" protect="rw">
        <comment>模块使能寄存器</comment>
        <bits access="rw" name="mod_up_en" pos="1" rst="0x0">
          <comment>上行定时电路使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="mod_dn_en" pos="0" rst="0x0">
          <comment>下行定时电路使能
1：使能
0：不使能</comment>
        </bits>
      </reg>
      <reg name="ram_addr_map_cfg" protect="rw">
        <comment>RAM地址映射寄存器</comment>
        <bits access="rw" name="ram3_start_addr_up" pos="31:24" rst="0x0">
          <comment>上行RAM3（指令RAM）的偏移地址
（RAM3起始地址为256+偏移地址）</comment>
        </bits>
        <bits access="rw" name="ram2_start_addr_up" pos="23:16" rst="0x0">
          <comment>上行RAM2（SPI RAM）的起始地址</comment>
        </bits>
        <bits access="rw" name="ram3_start_addr_dn" pos="15:8" rst="0x0">
          <comment>下行RAM3（指令RAM）的偏移地址
（RAM3起始地址为256+偏移地址）</comment>
        </bits>
        <bits access="rw" name="ram2_start_addr_dn" pos="7:0" rst="0x0">
          <comment>下行RAM2（SPI RAM）的起始地址</comment>
        </bits>
      </reg>
      <reg name="gpo_immdata" protect="rw">
        <comment>GPO立即起效寄存器</comment>
        <bits access="rw" name="up_sel" pos="16" rst="0x0">
          <comment>上下行使能控制选择
1：本次操作为上行控制
0：本次操作为下行控制</comment>
        </bits>
        <bits access="rw" name="spi_sel" pos="15" rst="0x0">
          <comment>SPI选择控制
1：本次发送数据为SPI
0：本次发送数据为GPO</comment>
        </bits>
        <bits access="rw" name="spi_rw" pos="14" rst="0x0">
          <comment>SPI读写控制
1：本次SPI操作为读操作
0：本次SPI操作为写操作</comment>
        </bits>
        <bits access="rw" name="gpo" pos="13:0" rst="0x0">
          <comment>控制射频芯片的直接线</comment>
        </bits>
      </reg>
      <reg name="spi_immdata" protect="rw">
        <comment>直接发送的RFSPI数据寄存器</comment>
      </reg>
      <reg name="spi_cfg" protect="rw">
        <comment>SPI 控制寄存器</comment>
        <bits access="rw" name="distance" pos="29:26" rst="0x3">
          <comment>两次相邻SPI操作，SEN无效需要保证的最小时间（SCLK时钟个数的一半）</comment>
        </bits>
        <bits access="rw" name="frq_div_rd" pos="25:23" rst="0x1">
          <comment>SPI读时钟产生分频系数控制：
000：4
001：6（default）
010：8
011：10
100：12
101：14
110：16
111：18</comment>
        </bits>
        <bits access="rw" name="frq_div_wr" pos="22:20" rst="0x1">
          <comment>SPI写时钟产生分频系数控制：
000：4
001：6（default）
010：8
011：10
100：12
101：14
110：16
111：18</comment>
        </bits>
        <bits access="rw" name="cs_inv" pos="19" rst="0x0">
          <comment>半双工读数据时片选信号反相使能（包括4-W，3-W制的半双工读）
0：不反相
1：反相</comment>
        </bits>
        <bits access="rw" name="dux" pos="18" rst="0x0">
          <comment>双工模式选择（此位仅在 17bit选为4线制时有效）
0：半双工
1：全双工</comment>
        </bits>
        <bits access="rw" name="ms" pos="17" rst="0x0">
          <comment>SPI接收数据时模式选择位：
0：3线模式（只支持半双工读）；
1：4线模式；</comment>
        </bits>
        <bits access="rw" name="rd_inter" pos="16:15" rst="0x2">
          <comment>SPI半双工读数据时选择间隔第几个SPI采样时钟的数据有效
00:0个时钟
01:1个时钟
10:2个时钟
11:3个时钟</comment>
        </bits>
        <bits access="rw" name="rd_edge" pos="14" rst="0x0">
          <comment>读数据采样沿
0：相反沿采数据，与发送沿为相反沿（全双工时必须为0）
1：同沿采数据，与发送沿为同一个沿</comment>
        </bits>
        <bits access="rw" name="sec" pos="13" rst="0x0">
          <comment>片选使能控制选择
0：片选在时钟之前有效（Normal SPI）
1：片选在时钟之后有效（DigRF SPI）</comment>
        </bits>
        <bits access="rw" name="cpha" pos="12" rst="0x1">
          <comment>SPI时钟相位控制：
0: 数据采样发生在时钟的奇数沿；
（外部芯片在奇数沿采数，1开始记数）;
1: 数据采样发生在时钟的偶数沿；
（外部芯片在偶数沿采数）;</comment>
        </bits>
        <bits access="rw" name="cpol" pos="11" rst="0x0">
          <comment>SPI时钟极性控制：
0: SPI接口在IDLE状态时，时钟为低电平；
1: SPI接口在IDLE状态时，时钟为高电平；</comment>
        </bits>
        <bits access="rw" name="spol" pos="10" rst="0x0">
          <comment>SPI片选极性控制：
0: SPI片选低有效；
1: SPI片选高有效</comment>
        </bits>
        <bits access="rw" name="rx_data_len" pos="9:5" rst="0xf">
          <comment>SPI接收数据长度（只包括数据位）：
00000: 1-bits
00001: 2-bits
…...........
11111: 32-bits</comment>
        </bits>
        <bits access="rw" name="tx_data_len" pos="4:0" rst="0x1f">
          <comment>SPI发送数据长度：（包括读写比特、地址位和数据位）：
00000: 1-bits
00001: 2-bits
…...........
11111: 32-bits</comment>
        </bits>
      </reg>
      <reg name="spi_rxdata" protect="rw">
        <comment>SPI 接收数据寄存器</comment>
      </reg>
      <reg name="debug_data" protect="rw">
        <comment>DEBUG寄存器</comment>
        <bits access="r" name="framc_err_up_flag" pos="31" rst="0x0">
          <comment>上行定时错误标识
1：有错误
0：无错误</comment>
        </bits>
        <bits access="r" name="insert_err_up_flag" pos="30" rst="0x0">
          <comment>上行禁止插队错误标识
1：有错误
0：无错误</comment>
        </bits>
        <bits access="r" name="addr_err_up" pos="29" rst="0x0">
          <comment>0：RAM地址超界错误未发生
1：RAM地址超界错误已发生</comment>
        </bits>
        <bits access="r" name="time_err_up" pos="28" rst="0x0">
          <comment>0：定时时间超限错误未发生
1：定时时间超限错误已发生
（子帧号不是0xf且大于0xA）</comment>
        </bits>
        <bits access="r" name="ram_rd_addr_up" pos="24:16" rst="0x0">
          <comment>上行RAM读地址</comment>
        </bits>
        <bits access="r" name="framc_err_dn_flag" pos="15" rst="0x0">
          <comment>下行定时错误标识
1：有错误
0：无错误</comment>
        </bits>
        <bits access="r" name="insert_err_dn_flag" pos="14" rst="0x0">
          <comment>下行禁止插队错误标识
1：有错误
0：无错误</comment>
        </bits>
        <bits access="r" name="addr_err_dn" pos="13" rst="0x0">
          <comment>0：RAM地址超界错误未发生
1：RAM地址超界错误已发生</comment>
        </bits>
        <bits access="r" name="time_err_dn" pos="12" rst="0x0">
          <comment>0：定时时间超限错误未发生
1：定时时间超限错误已发生
（子帧号不是0xf且大于0xA）</comment>
        </bits>
        <bits access="r" name="ram_rd_addr_dn" pos="8:0" rst="0x0">
          <comment>下行RAM读地址</comment>
        </bits>
      </reg>
      <reg name="rf_gpo_ctrl" protect="rw">
        <comment>RF GPO control register</comment>
      </reg>
      <reg name="framl_rfad" protect="rw">
        <comment>RFAD帧长控制寄存器</comment>
        <bits access="rw" name="dont_insert_en" pos="18" rst="0x0">
          <comment>禁止插队机制使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="up_en" pos="17" rst="0x0">
          <comment>上行帧长使能</comment>
        </bits>
        <bits access="rw" name="dn_en" pos="16" rst="0x0">
          <comment>下行帧长使能</comment>
        </bits>
        <bits access="rw" name="framc_rfad" pos="15:0" rst="0x7800">
          <comment>RFAD帧长值</comment>
        </bits>
      </reg>
      <reg name="framc_err_up" protect="rw">
        <comment>上行定时错误时FRAMC值寄存器</comment>
        <bits access="r" name="framc_err_up_flag" pos="24" rst="0x0">
          <comment>上行定时错误标识
1：有错误
0：无错误</comment>
        </bits>
        <bits access="r" name="framc_err_up" pos="23:0" rst="0x0">
          <comment>上行定时错误时FRAMC值</comment>
        </bits>
      </reg>
      <reg name="data_time_err_up" protect="rw">
        <comment>上行定时错误时定时时间寄存器</comment>
        <bits access="r" name="ram_rd_addr_up" pos="31:24" rst="0x0">
          <comment>上行定时错误时定时事件地址</comment>
        </bits>
        <bits access="r" name="data_time_err_up" pos="23:0" rst="0x0">
          <comment>上行定时错误时定时时间值</comment>
        </bits>
      </reg>
      <reg name="framc_err_dn" protect="rw">
        <comment>下行定时错误时FRAMC值寄存器</comment>
        <bits access="r" name="framc_err_dn_flag" pos="24" rst="0x0">
          <comment>下行定时错误标识
1：有错误
0：无错误</comment>
        </bits>
        <bits access="r" name="framc_err_dn" pos="23:0" rst="0x0">
          <comment>下行定时错误时FRAMC值</comment>
        </bits>
      </reg>
      <reg name="data_time_err_dn" protect="rw">
        <comment>下行定时错误时定时时间寄存器</comment>
        <bits access="r" name="ram_rd_addr_dn" pos="31:24" rst="0x0">
          <comment>下行定时错误时定时事件地址</comment>
        </bits>
        <bits access="r" name="data_time_err_dn" pos="23:0" rst="0x0">
          <comment>下行定时错误时定时时间值</comment>
        </bits>
      </reg>
      <reg name="framl_err" protect="rw">
        <comment>定时错误时FRAML值状态寄存器</comment>
        <bits access="r" name="framl_err_up" pos="31:16" rst="0x0">
          <comment>上行定时错误时FRAML值</comment>
        </bits>
        <bits access="r" name="framl_err_dn" pos="15:0" rst="0x0">
          <comment>下行定时错误时FRAML值</comment>
        </bits>
      </reg>
      <reg name="dont_insert _err_up" protect="rw">
        <comment>上行禁止插队错误状态寄存器</comment>
        <bits access="r" name="ram_rd_addr_up" pos="31:24" rst="0x0">
          <comment>上行插队错误时定时事件地址</comment>
        </bits>
        <bits access="r" name="framc_err_up" pos="23:0" rst="0x0">
          <comment>上行插队错误时FRAMC值</comment>
        </bits>
      </reg>
      <reg name="dont_insert _err_dn" protect="rw">
        <comment>下行禁止插队错误状态寄存器</comment>
        <bits access="r" name="ram_rd_addr_dn" pos="31:24" rst="0x0">
          <comment>下行插队错误时定时事件地址</comment>
        </bits>
        <bits access="r" name="framc_err_dn" pos="23:0" rst="0x0">
          <comment>下行插队错误时FRAMC值</comment>
        </bits>
      </reg>
      <hole size="32256"/>
      <reg name="down_mem" protect="rw">
        <comment>下行存储器</comment>
      </reg>
      <hole size="32736"/>
      <reg name="up_mem" protect="rw">
        <comment>上行存储器</comment>
      </reg>
    </module>
    <instance address="0x18100000" name="RFAD" type="RFAD"/>
  </archive>
  <archive relative="ul_dft.xml">
    <module category="System" name="UL_DFT">
      <reg name="dft_ctrl_next" protect="rw">
        <comment>DFT/IDFT控制寄存器</comment>
        <bits access="rw" name="anti_drop_en_next" pos="12" rst="0x0">
          <comment>0：ANTI_DROP功能不使能
1：ANTI_DROP功能使能</comment>
        </bits>
        <bits access="rw" name="anti_drop_lnum_next" pos="11" rst="0x0">
          <comment>ANTI_DROP功能截位因子:
0：右移8bit
1：右移7bit</comment>
        </bits>
        <bits access="rw" name="dft_npts_next" pos="10:5" rst="0x0">
          <comment>DFT/IDFT点数选择的index，0~43分别指示44种点数，index与实际点数的对应关系如下表说明 （不可配置其他值）</comment>
        </bits>
        <bits access="rw" name="pus_modu_sel_next" pos="4:3" rst="0x0">
          <comment>00: BPSK调制方式
01: QPSK调制方式
10: 16QAM调制方式
11: 64QAM调制方式</comment>
        </bits>
        <bits access="rw" name="dft_en_next" pos="2" rst="0x0">
          <comment>0：DFT/IDFT功能不使能
1：DFT/IDFT功能使能</comment>
        </bits>
        <bits access="rw" name="pus_mod_en_next" pos="1" rst="0x0">
          <comment>0：PUSCH调制功能不使能
1：PUSCH调制功能使能</comment>
        </bits>
        <bits access="rw" name="dft_idft_sel_next" pos="0" rst="0x0">
          <comment>0: 选择DFT运算
1: 选择IDFT运算</comment>
        </bits>
      </reg>
      <reg name="puc_mod_data_next" protect="rw">
        <comment>PUCCH调制输入数据寄存器</comment>
        <bits access="rw" name="puc_mod_data_next" pos="21:0" rst="0x0">
          <comment>PUCCH调制输入数据d(n)</comment>
        </bits>
      </reg>
      <reg name="srs_map_cfg_next" protect="rw">
        <comment>SRS资源映射参数配置寄存器</comment>
        <bits access="rw" name="k_tc_num_next" pos="26" rst="0x0">
          <comment>SRS填零间隔指示：
0：每2个子载波填1个零；
1：每4个子载波填3个零；</comment>
        </bits>
        <bits access="rw" name="k_tc_next" pos="25:24" rst="0x0">
          <comment>起始子载波位置（梳齿位置），取值范围：
00：0；
01：1；
10：2；
11：3；</comment>
        </bits>
        <bits access="rw" name="srs_map_len_next" pos="22:16" rst="0x0">
          <comment>SRS频域映射长度值</comment>
        </bits>
        <bits access="rw" name="srs_map_start2_next" pos="14:8" rst="0x0">
          <comment>第二个SRS符号频域映射起始位置</comment>
        </bits>
        <bits access="rw" name="srs_map_start1_next" pos="6:0" rst="0x0">
          <comment>第一个SRS符号频域映射起始位置</comment>
        </bits>
      </reg>
      <reg name="srs_zc_len_next" protect="rw">
        <comment>SRS的ZC序列长度寄存器</comment>
        <bits access="rw" name="srs_num_next" pos="24" rst="0x0">
          <comment>0：发送特殊子帧时，SRS符号个数为1个
1：发送特殊子帧时，SRS符号个数为2个</comment>
        </bits>
        <bits access="rw" name="srs_map_ofdm2_next" pos="23:20" rst="0x0">
          <comment>第二个SRS发送的OFDM符号位置</comment>
        </bits>
        <bits access="rw" name="sra_map_ofdm1_next" pos="19:16" rst="0x0">
          <comment>第一个SRS发送的OFDM符号位置</comment>
        </bits>
        <bits access="rw" name="special_frame_start_next" pos="15:12" rst="0x0">
          <comment>只发SRS（特殊子帧）时，子帧起始发送的OFDM符号位置</comment>
        </bits>
        <bits access="rw" name="srs_zc_len_next" pos="10:0" rst="0x0">
          <comment>SRS的ZC序列长度值</comment>
        </bits>
      </reg>
      <reg name="puc_map_cfg_next" protect="rw">
        <comment>PUCCH资源映射参数寄存器</comment>
        <bits access="rw" name="tx_fir_en_next" pos="31" rst="0x0">
          <comment>0：TX滤波不使能
1：TX滤波使能</comment>
        </bits>
        <bits access="rw" name="tx_nb_start2_next" pos="30:24" rst="0x0">
          <comment>窄带在系统带宽内的起始位置2</comment>
        </bits>
        <bits access="rw" name="tx_nb_start1_next" pos="22:16" rst="0x0">
          <comment>窄带在系统带宽内的起始位置1</comment>
        </bits>
        <bits access="rw" name="puc_map_start2_next" pos="14:8" rst="0x0">
          <comment>第二个时隙PUCCH映射起始位置</comment>
        </bits>
        <bits access="rw" name="puc_map_start1_next" pos="6:0" rst="0x0">
          <comment>第一个时隙PUCCH映射起始位置</comment>
        </bits>
      </reg>
      <reg name="pus_map_cfg_next" protect="rw">
        <comment>PUSCH资源映射参数寄存器</comment>
        <bits access="rw" name="pus_map_sel_next" pos="31" rst="0x0">
          <comment>PUSCH映射分配类型：
0：资源映射0.5ms；
1：资源映射1ms；</comment>
        </bits>
        <bits access="rw" name="pus_map_len2_next" pos="30:24" rst="0x0">
          <comment>第二段PUSCH频域映射长度值</comment>
        </bits>
        <bits access="rw" name="pus_map_len1_next" pos="22:16" rst="0x0">
          <comment>第一段PUSCH频域映射长度值</comment>
        </bits>
        <bits access="rw" name="pus_map_start2_next" pos="14:8" rst="0x0">
          <comment>第二段PUSCH频域映射起始位置</comment>
        </bits>
        <bits access="rw" name="pus_map_start1_next" pos="6:0" rst="0x0">
          <comment>第一段PUSCH频域映射起始位置</comment>
        </bits>
      </reg>
      <reg name="hard_para_next1" protect="rw">
        <comment>硬化计算参数配置寄存器1</comment>
        <bits access="rw" name="pus_dmrs_w_flag" pos="15" rst="0x0">
          <comment>PUSCH DMRS正交码索引取反标志位：
1：取反
0：不取反</comment>
        </bits>
        <bits access="rw" name="pucpus_shortened_mode_next" pos="14:11" rst="0x0">
          <comment>PUSCH/PUCCH符号打孔处理指示：
0000：normal
0001：type0_shortend
0010：type1_shortend
0011：type2_shortend
0100：type3_shortend
0101：type4_shortend
0110：type5_shortend
0111:  type6_shortend
1000:  type7_shortend
1001:  other</comment>
        </bits>
        <bits access="rw" name="group_hop_flag_next" pos="10" rst="0x0">
          <comment>1：u值跳变
0：u值不跳变</comment>
        </bits>
        <bits access="rw" name="seq_hop_flag_next" pos="9" rst="0x0">
          <comment>1：v值跳变
0：v值不跳变</comment>
        </bits>
        <bits access="rw" name="ta_overlap_next" pos="8:3" rst="0x0">
          <comment>连续两个发送帧覆盖TA部分索引值，取值范围0~32</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_field_next" pos="2:0" rst="0x0">
          <comment>dmrsValue参考信号解调的循环偏移值，取值范围0~7</comment>
        </bits>
      </reg>
      <reg name="hard_para _next2" protect="rw">
        <comment>硬化计算参数配置寄存器2</comment>
        <bits access="rw" name="delta_apc_srs_next" pos="31:16" rst="0x0">
          <comment>SRS的小数APC（ ）调整因子</comment>
        </bits>
        <bits access="rw" name="delta_apc_scr_next" pos="15:0" rst="0x0">
          <comment>PUSCH/PUCCH/PRACH的小数APC（ ）调整因子</comment>
        </bits>
      </reg>
      <reg name="hard_para _next3" protect="rw">
        <comment>硬化计算参数配置寄存器3</comment>
        <bits access="rw" name="n1_pucch_next" pos="31:20" rst="0x0">
          <comment>PUCCH格式1/1a/1b的资源索引值，取值范围0~4095</comment>
        </bits>
        <bits access="rw" name="srs_cycle_shift_next" pos="19:16" rst="0x0">
          <comment>SRS循环移位值</comment>
        </bits>
        <bits access="rw" name="subframe_slot_cnt_next" pos="14:10" rst="0x0">
          <comment>对CAT1/CATM/CAT-NB子载波15kHz，每次调用对应1ms内2个时隙，该参数表示子帧号；对CAT-NB子载波3.75kHz，每次调用对应2ms内1个时隙，该参数表示时隙号</comment>
        </bits>
        <bits access="rw" name="nf_next" pos="9:0" rst="0x0">
          <comment>无线帧号，取值范围0~1023</comment>
        </bits>
      </reg>
      <reg name="ofdm_offset_next" protect="rw">
        <comment>OFDM OFFSET配置寄存器</comment>
        <bits access="rw" name="ofdm_offset_last_next" pos="31:16" rst="0x0">
          <comment>最后一个OFDM符号的offset值</comment>
        </bits>
        <bits access="rw" name="ofdm_offset_first_next" pos="15:0" rst="0x0">
          <comment>第一个OFDM符号的offset值</comment>
        </bits>
      </reg>
      <reg name="dft_fft_inten_next" protect="rw">
        <comment>中断使能寄存器</comment>
        <bits access="rw" name="err_inten_next" pos="15" rst="0x0">
          <comment>0：ULDFT访问TXRX或PUSCH存储器ERROR中断不使能
1：ULDFT访问TXRX或PUSCH存储器ERROR中断不使能</comment>
        </bits>
        <bits access="rw" name="dma_inten_next" pos="14" rst="0x0">
          <comment>1：AXIDMA中断使能
0：AXIDMA中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten13_next" pos="13" rst="0x0">
          <comment>1：OFDM符号13中断使能
0：OFDM符号13中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten12_next" pos="12" rst="0x0">
          <comment>1：OFDM符号12中断使能
0：OFDM符号12中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten11_next" pos="11" rst="0x0">
          <comment>1：OFDM符号11中断使能
0：OFDM符号11中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten10_next" pos="10" rst="0x0">
          <comment>1：OFDM符号10中断使能
0：OFDM符号10中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten9_next" pos="9" rst="0x0">
          <comment>1：OFDM符号9中断使能
0：OFDM符号9中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten8_next" pos="8" rst="0x0">
          <comment>1：OFDM符号8中断使能
0：OFDM符号8中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten7_next" pos="7" rst="0x0">
          <comment>1：OFDM符号7中断使能
0：OFDM符号7中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten6_next" pos="6" rst="0x0">
          <comment>1：OFDM符号6中断使能
0：OFDM符号6中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten5_next" pos="5" rst="0x0">
          <comment>1：OFDM符号5中断使能
0：OFDM符号5中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten4_next" pos="4" rst="0x0">
          <comment>1：OFDM符号4中断使能
0：OFDM符号4中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten3_next" pos="3" rst="0x0">
          <comment>1：OFDM符号3中断使能
0：OFDM符号3中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten2_next" pos="2" rst="0x0">
          <comment>1：OFDM符号2中断使能
0：OFDM符号2中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten1_next" pos="1" rst="0x0">
          <comment>1：OFDM符号1中断使能
0：OFDM符号1中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten0_next" pos="0" rst="0x0">
          <comment>1：OFDM符号0中断使能
0：OFDM符号0中断未使能</comment>
        </bits>
      </reg>
      <reg name="dft_fft_intf_next" protect="rw">
        <comment>中断标志寄存器</comment>
        <bits access="rc" name="dft_fft_intf13_next" pos="15" rst="0x0">
          <comment>1：OFDM符号13中断标志置位
0：OFDM符号13中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf12_next" pos="14" rst="0x0">
          <comment>1：OFDM符号12中断标志置位
0：OFDM符号12中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf11_next" pos="13" rst="0x0">
          <comment>1：OFDM符号11中断标志置位
0：OFDM符号11中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf10_next" pos="12" rst="0x0">
          <comment>1：OFDM符号10中断标志置位
0：OFDM符号10中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf9_next" pos="11" rst="0x0">
          <comment>1：OFDM符号9中断标志置位
0：OFDM符号9中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf8_next" pos="10" rst="0x0">
          <comment>1：OFDM符号8中断标志置位
0：OFDM符号8中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf7_next" pos="9" rst="0x0">
          <comment>1：OFDM符号7中断标志置位
0：OFDM符号7中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf6_next" pos="8" rst="0x0">
          <comment>1：OFDM符号6中断标志置位
0：OFDM符号6中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf5_next" pos="7" rst="0x0">
          <comment>1：OFDM符号5中断标志置位
0：OFDM符号5中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf4_next" pos="6" rst="0x0">
          <comment>1：OFDM符号4中断标志置位
0：OFDM符号4中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf3_next" pos="5" rst="0x0">
          <comment>1：OFDM符号3中断标志置位
0：OFDM符号3中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf2_next" pos="4" rst="0x0">
          <comment>1：OFDM符号2中断标志置位
0：OFDM符号2中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf1_next" pos="3" rst="0x0">
          <comment>1：OFDM符号1中断标志置位
0：OFDM符号1中断标志未置位</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf0_next" pos="2" rst="0x0">
          <comment>1：OFDM符号0中断标志置位
0：OFDM符号0中断标志未置位</comment>
        </bits>
        <bits access="rc" name="pus_rd_errf" pos="1" rst="0x0">
          <comment>1：读pusch存储器时钟开启失败标志置位
0：读pusch存储器时钟开启失败标志未置位</comment>
        </bits>
        <bits access="rc" name="txrx_wr_errf" pos="0" rst="0x0">
          <comment>1：写txrx存储器时钟开启失败标志置位
0：写txrx存储器时钟开启失败标志未置位</comment>
        </bits>
      </reg>
      <reg name="ofdm_zero_next" protect="rw">
        <comment>OFDM符号填零发送寄存器</comment>
        <bits access="rw" name="ofdm_zero_next" pos="13:0" rst="0x0">
          <comment>指示填零发送的OFDM符号数：
14’b0：没有填零发送
14’b1：符号0填零发送
14’b11：符号0，1填零发送
14’b111：符号0，1，2填零发送
……</comment>
        </bits>
      </reg>
      <reg name="dft_fft_ctrl_next" protect="rw">
        <comment>DFT/IDFT&amp;FFT/IFFT控制寄存器</comment>
        <bits access="rw" name="dftfft_soft_start" pos="30" rst="0x0">
          <comment>0：软件未触发ULDFT启动
1：软件触发ULDFT启动</comment>
        </bits>
        <bits access="rw" name="dft_trig_mode" pos="29" rst="0x0">
          <comment>0：ULDFT启动模式为软件触发
1：ULDFT启动模式为PUSCH模块触发</comment>
        </bits>
        <bits access="rw" name="launch_en_next" pos="28" rst="0x0">
          <comment>0：启窗不使能
1：启窗使能</comment>
        </bits>
        <bits access="rw" name="srs_en_next" pos="27" rst="0x0">
          <comment>0：SRS产生不使能
1：SRS产生使能</comment>
        </bits>
        <bits access="rw" name="clear_en_next" pos="26" rst="0x0">
          <comment>0：FFT输入MEM清零功能不使能
1：FFT输入MEM清零功能使能</comment>
        </bits>
        <bits access="rw" name="fft_ifft_sel_next" pos="25" rst="0x0">
          <comment>1：选择IFFT运算
0：选择FFT运算</comment>
        </bits>
        <bits access="rw" name="fft_cal_next" pos="24" rst="0x0">
          <comment>1：FFT/IFFT运算使能
0：FFT/IFFT运算不使能</comment>
        </bits>
        <bits access="rw" name="pwradj_en_next" pos="23" rst="0x0">
          <comment>0：功率调整不使能
1：功率调整使能</comment>
        </bits>
        <bits access="rw" name="prach_format_sel_next" pos="22:20" rst="0x0">
          <comment>指示PRACH格式类型：
000：PRACH格式0
001：PRACH格式1
010：PRACH格式2
011：PRACH格式3
100：PRACH格式4
其他：保留</comment>
        </bits>
        <bits access="rw" name="pucch_format_sel_next" pos="19:17" rst="0x0">
          <comment>指示PUCCH格式类型：
000：PUCCH格式1
001：PUCCH格式1a
010：PUCCH格式1b
011：PUCCH格式2
100：PUCCH格式2a
101：PUCCH格式2b
其他：保留</comment>
        </bits>
        <bits access="rw" name="npusch_formatsel_next" pos="16" rst="0x0">
          <comment>0：NPUSCH format 1
1：NPUSCH format2</comment>
        </bits>
        <bits access="rw" name="ofdm_num_next" pos="15:12" rst="0x0">
          <comment>指示OFDM符号的个数</comment>
        </bits>
        <bits access="rw" name="datadrive_en_next" pos="10" rst="0x0">
          <comment>0：DATADRIVE不使能
1：DATADRIVE使能</comment>
        </bits>
        <bits access="rw" name="pus_buf_sel_next" pos="9:8" rst="0x0">
          <comment>指示UL_DFT读PUSCH BUFFER块选择：
00：PUSCH BUFFER1
01：PUSCH BUFFER2
10：PUSCH BUFFER3
11：PUSCH PRA_BUF</comment>
        </bits>
        <bits access="rw" name="chan_mode_next" pos="6:4" rst="0x0">
          <comment>指示上行信道发送模式
000：PUSCH
001：PUCCH
010：PRACH
011：SRS
100：NPUSCH
101：NPRACH
其他：保留</comment>
        </bits>
        <bits access="rw" name="fft_npts" pos="3:1" rst="0x0">
          <comment>FFT/IFFT点数选择
111：保留（不可配）
110：保留（不可配）
101：保留（不可配）
100：2048点
011：1024点
010：512点
001：256点
000：128点</comment>
        </bits>
        <bits access="rw" name="dftfft_irqen_next" pos="0" rst="0x0">
          <comment>0: 中断不使能
1: 中断使能</comment>
        </bits>
      </reg>
      <reg name=" fft_lnum_srs_next" protect="rw">
        <comment>SRS的FFT截位因子参数寄存器</comment>
        <bits access="rw" name="fft_lnum11_srs_next" pos="21:20" rst="0x0">
          <comment>FFT第十一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_srs_next" pos="19:18" rst="0x0">
          <comment>FFT第十级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_srs_next" pos="17:16" rst="0x0">
          <comment>FFT第九级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_srs_next" pos="15:14" rst="0x0">
          <comment>FFT第八级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_srs_next" pos="13:12" rst="0x0">
          <comment>FFT第七级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_srs_next" pos="11:10" rst="0x0">
          <comment>FFT第六级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_srs_next" pos="9:8" rst="0x0">
          <comment>FFT第五级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_srs_next" pos="7:6" rst="0x0">
          <comment>FFT第四级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_srs_next" pos="5:4" rst="0x0">
          <comment>FFT第三级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_srs_next" pos="3:2" rst="0x0">
          <comment>FFT第二级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_srs_next" pos="1:0" rst="0x0">
          <comment>FFT第一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
      </reg>
      <reg name="fft_lnum_scr_next" protect="rw">
        <comment>PUSCH/PUCCH/PRACH的FFT截位因子参数寄存器</comment>
        <bits access="rw" name="fft_lnum11_scr_next" pos="21:20" rst="0x0">
          <comment>FFT第十一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_scr_next" pos="19:18" rst="0x0">
          <comment>FFT第十级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_scr_next" pos="17:16" rst="0x0">
          <comment>FFT第九级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_scr_next" pos="15:14" rst="0x0">
          <comment>FFT第八级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_scr_next" pos="13:12" rst="0x0">
          <comment>FFT第七级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_scr_next" pos="11:10" rst="0x0">
          <comment>FFT第六级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_scr_next" pos="9:8" rst="0x0">
          <comment>FFT第五级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_scr_next" pos="7:6" rst="0x0">
          <comment>FFT第四级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_scr_next" pos="5:4" rst="0x0">
          <comment>FFT第三级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_scr_next" pos="3:2" rst="0x0">
          <comment>FFT第二级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_scr_next" pos="1:0" rst="0x0">
          <comment>FFT第一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
      </reg>
      <reg name="npus_map_cfg_next" protect="rw">
        <comment>NPUSCH参数寄存器</comment>
        <bits access="rw" name="npus_rep_cnt_next" pos="23:17" rst="0x0">
          <comment>NPUSCH当前重复传输的第几次，取值范围0~127</comment>
        </bits>
        <bits access="rw" name="n_ru_sc_next" pos="16:15" rst="0x0">
          <comment>子载波个数：
00：1个子载波
01：3个子载波
10：6个子载波
11：12个子载波</comment>
        </bits>
        <bits access="rw" name="isc_start_index_next" pos="14:9" rst="0x0">
          <comment>NPUSCH 的起始子载波位置，取值范围0~47</comment>
        </bits>
        <bits access="rw" name="n_slot_cnt_next" pos="8:1" rst="0x0">
          <comment>当前传输的第几个Nslots单位，取值范围1~160</comment>
        </bits>
        <bits access="rw" name="npus_sub_space_next" pos="0" rst="0x0">
          <comment>0: 3.75KHz
1: 15KHz</comment>
        </bits>
      </reg>
      <reg name="npus_dmrs_cfg_next" protect="rw">
        <comment>NPUSCH DMRS参数寄存器</comment>
        <bits access="rw" name="first_ru_slot_next" pos="26:22" rst="0x0">
          <comment>首个RU的首个时隙号，取值范围0~19</comment>
        </bits>
        <bits access="rw" name="slot_n_next" pos="21:7" rst="0x0">
          <comment>用于子载波个数为1生成DMRS时，表示第几个时隙，取值范围0~20480</comment>
        </bits>
        <bits access="rw" name="base_seq_next" pos="6:2" rst="0x0">
          <comment>BASE_SEQ_NEXT值，取值范围0~30</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_next" pos="1:0" rst="0x0">
          <comment>CYCLIC_SHIFT值，取值范围0~3</comment>
        </bits>
      </reg>
      <reg name="npra _cfg_next" protect="rw">
        <comment>NPRACH参数寄存器</comment>
        <bits access="rw" name="sym_group_rep_cnt_next" pos="16:9" rst="0x0">
          <comment>t值，取值范围0~128</comment>
        </bits>
        <bits access="rw" name="nprach_sc_offset_next" pos="8:6" rst="0x0">
          <comment>frequency location of the first sub-carrier allocated to NPRACH：
000：frequency location为0；
001：frequency location为2；
010：frequency location为12
011：frequency location为18
100：frequency location为24
101：frequency location为34
110：frequency location为36
111：默认为0</comment>
        </bits>
        <bits access="rw" name="init_sc_next" pos="5:0" rst="0x0">
          <comment>being the subcarrier selected by the MAC layer from  ，取值范围0-47</comment>
        </bits>
      </reg>
      <reg name="inout_para" protect="rw">
        <comment>FFT/IFFT输入输出数据控制及参数寄存器</comment>
        <bits access="rw" name="fir_bit_sel" pos="28:25" rst="0x0">
          <comment>采样滤波器输出截取选择</comment>
        </bits>
        <bits access="rw" name="delta_ss" pos="24:20" rst="0x0">
          <comment>计算组跳频参数，取值范围0~29</comment>
        </bits>
        <bits access="rw" name="n2_pucch" pos="19:9" rst="0x0">
          <comment>PUCCH格式2/2a/2b的资源索引值，取值范围0~1184</comment>
        </bits>
        <bits access="rw" name="cyclic_shift" pos="8:6" rst="0x0">
          <comment>参考信号的循环偏移参数值，取值范围0~7</comment>
        </bits>
        <bits access="rw" name="cp_mode" pos="2" rst="0x0">
          <comment>指示CP类型：
0：普通CP
1：扩展CP</comment>
        </bits>
        <bits access="rw" name="tdd_fdd_mode_sel" pos="1" rst="0x0">
          <comment>0：TDD  mode
1：FDD  mode</comment>
        </bits>
        <bits access="rw" name="inout_ctrl" pos="0" rst="0x0">
          <comment>1: 使能按地址位反序输入数据，按拼接好的顺序输出数据
0: 正常输入输出数据</comment>
        </bits>
      </reg>
      <reg name="id_para" protect="rw">
        <comment>ID配置寄存器</comment>
        <bits access="rw" name="ncs_u_gold_mode" pos="29" rst="0x0">
          <comment>NCS和U所需的GOLD序列时初始值C_INI的计算模式选择：
1：if no value for   or   is configured by higher layers or the PUSCH transmission corresponds to a Random Access Response Grant or a retransmission of the same transport block as part of the contention based random access procedure
0：otherwise</comment>
        </bits>
        <bits access="rw" name="csh_dmrs_id" pos="28:19" rst="0x0">
          <comment>NCS_U_GOLD_MODE为1时，表示 + 的值，取值范围0~532；NCS_U_GOLD_MODE为0时，表示高层所配 的值，取值范围0~509；</comment>
        </bits>
        <bits access="rw" name="rs_id" pos="18:9" rst="0x0">
          <comment>NCS_U_GOLD_MODE为1时，表示 + 的值，取值范围0~532；NCS_U_GOLD_MODE为0时，表示高层所配 的值，取值范围0~509；</comment>
        </bits>
        <bits access="rw" name="cell_id" pos="8:0" rst="0x0">
          <comment>小区ID值，取值范围0~503</comment>
        </bits>
      </reg>
      <reg name="pucch_dummy_id" protect="rw">
        <comment>PUCCH虚拟ID寄存器</comment>
        <bits access="rw" name="puc_dummy_id" pos="8:0" rst="0x0">
          <comment>RS使用的虚拟ID</comment>
        </bits>
      </reg>
      <reg name="puc_rbmap_config" protect="rw">
        <comment>PUCCH资源映射配置寄存器</comment>
        <bits access="rw" name="ncs1_puc" pos="14:12" rst="0x0">
          <comment>nCsAn混合资源块内格式1/1a/1b使用循环移位数，取值范围0~7</comment>
        </bits>
        <bits access="rw" name="ce_mode_flag" pos="10" rst="0x0">
          <comment>CE_mode指示：
0：CE_modeA
1：CE_modeB</comment>
        </bits>
        <bits access="rw" name="delta_shift_puc" pos="9:8" rst="0x0">
          <comment>索引值：
00： 为1
01： 为2
10： 为3
11：取00值， 为1</comment>
        </bits>
        <bits access="rw" name="nrb2" pos="6:0" rst="0x0">
          <comment>cqiNrb PUCCH格式2/2a/2b占用资源块数，取值范围0~98</comment>
        </bits>
      </reg>
      <reg name="sysband_config" protect="rw">
        <comment>系统带宽配置寄存器</comment>
        <bits access="rw" name="sys_band" pos="2:0" rst="0x0">
          <comment>CAT1模式下 上行系统带宽索引值：
000：系统带宽为6PRB
001：系统带宽为15PRB
010：系统带宽为25PRB
011：系统带宽为50PRB
100：系统带宽为75PRB
101：系统带宽为100PRB
其他：默认系统带宽为6PRB</comment>
        </bits>
      </reg>
      <reg name="dftfft_launch" protect="rw">
        <comment>参数传递寄存器</comment>
        <bits access="rw" name="dma_start_en" pos="1" rst="0x0">
          <comment>0：DMA控制本模块启动不使能
1：DMA控制本模块启动使能</comment>
        </bits>
        <bits access="rw" name="dftfft_launch" pos="0" rst="0x0">
          <comment>0: 软件参数配置未结束
1: 软件参数配置结束</comment>
        </bits>
      </reg>
      <reg name="dft_fft_sw_stop" protect="rw">
        <comment>软件暂停和停止硬件配置寄存器</comment>
        <bits access="rw" name="sw_pause_ofdm" pos="17:4" rst="0x0">
          <comment>SW_PAUSE_EN=1时，软件暂停硬件的OFDM符号序号：
14`b0：不暂停
14`b1：OFDM符号0暂停
14`b11：OFDM符号0、1暂停
14`b111：OFDM符号0、1、2暂停
……</comment>
        </bits>
        <bits access="rw" name="sw_pause_way" pos="3" rst="0x0">
          <comment>SW_PAUSE_EN=1时，软件暂停硬件的策略选择：
0：SW_PAUSE_OFDM设置的OFDM符号的之前暂停
1：SW_PAUSE_OFDM设置的OFDM符号的之后暂停</comment>
        </bits>
        <bits access="rw" name="sw_pause_en" pos="2" rst="0x0">
          <comment>软件暂停硬件使能信号：
0：软件暂停硬件不使能
1：软件暂停硬件使能</comment>
        </bits>
        <bits access="rw" name="sw_tmp_en" pos="1" rst="0x0">
          <comment>软件立即暂停使能信号：
0：软件立即暂停硬件不使能
1：软件立即暂停硬件使能</comment>
        </bits>
        <bits access="rw" name="sw_stop_en" pos="0" rst="0x0">
          <comment>软件停止硬件使能信号：
0：软件停止硬件不使能
1：软件停止硬件使能，硬件完成当前OFDM处理后，停止当前子帧的操作</comment>
        </bits>
      </reg>
      <reg name="dft_fft_sw_stop_flag" protect="rw">
        <comment>软件暂停标志寄存器</comment>
        <bits access="rc" name="sw_pause_flag" pos="1" rst="0x0">
          <comment>软件暂停硬件标志信号：
0：软件未成功暂停硬件
1：软件成功暂停硬件</comment>
        </bits>
        <bits access="rc" name="sw_stop_flag" pos="0" rst="0x0">
          <comment>软件停止硬件标志信号：
0：软件未成功停止硬件
1：软件成功停止硬件</comment>
        </bits>
      </reg>
      <reg name="dft_ctrl_curr1" protect="rw">
        <comment>DFT/IDFT控制寄存器</comment>
        <bits access="rw" name="anti_drop_en_curr" pos="12" rst="0x0">
          <comment>0：ANTI_DROP功能不使能
1：ANTI_DROP功能使能</comment>
        </bits>
        <bits access="rw" name="anti_drop_lnum_curr" pos="11" rst="0x0">
          <comment>ANTI_DROP功能截位因子:
0：右移8bit
1：右移7bit</comment>
        </bits>
        <bits access="rw" name="dft_npts_curr" pos="10:5" rst="0x0">
          <comment>DFT/IDFT点数选择的index，0~43分别指示44种点数，index与实际点数的对应关系如下表说明 （不可配置其他值）</comment>
        </bits>
        <bits access="rw" name="pus_modu_sel_curr" pos="4:3" rst="0x0">
          <comment>00: BPSK调制方式
01: QPSK调制方式
10: 16QAM调制方式
11: 64QAM调制方式</comment>
        </bits>
        <bits access="rw" name="dft_en_curr" pos="2" rst="0x0">
          <comment>0：DFT/IDFT功能不使能
1：DFT/IDFT功能使能</comment>
        </bits>
        <bits access="rw" name="pus_mod_en_curr" pos="1" rst="0x0">
          <comment>0：PUSCH调制功能不使能
1：PUSCH调制功能使能</comment>
        </bits>
        <bits access="rw" name="dft_idft_sel_curr" pos="0" rst="0x0">
          <comment>0: 选择DFT运算
1: 选择IDFT运算</comment>
        </bits>
      </reg>
      <reg name="puc_mod_data_curr1" protect="rw">
        <comment>PUCCH调制输入数据寄存器</comment>
        <bits access="rw" name="puc_mod_data_curr" pos="21:0" rst="0x0">
          <comment>PUCCH调制输入数据d(n)</comment>
        </bits>
      </reg>
      <reg name="srs_map_cfg_curr1" protect="rw">
        <comment>SRS资源映射参数配置寄存器</comment>
        <bits access="rw" name="k_tc_num_curr" pos="26" rst="0x0">
          <comment>SRS填零间隔指示：
0：每2个子载波填1个零；
1：每4个子载波填3个零；</comment>
        </bits>
        <bits access="rw" name="k_tc_curr" pos="25:24" rst="0x0">
          <comment>起始子载波位置（梳齿位置），取值范围：
00：0；
01：1；
10：2；
11：3；</comment>
        </bits>
        <bits access="rw" name="srs_map_len_curr" pos="22:16" rst="0x0">
          <comment>SRS频域映射长度值</comment>
        </bits>
        <bits access="rw" name="srs_map_start2_curr" pos="14:8" rst="0x0">
          <comment>第二个SRS符号频域映射起始位置</comment>
        </bits>
        <bits access="rw" name="srs_map_start1_curr" pos="6:0" rst="0x0">
          <comment>第一个SRS符号频域映射起始位置</comment>
        </bits>
      </reg>
      <reg name="srs_zc_len_curr1" protect="rw">
        <comment>SRS的ZC序列长度寄存器</comment>
        <bits access="rw" name="srs_num_curr" pos="24" rst="0x0">
          <comment>0：发送特殊子帧时，SRS符号个数为1个
1：发送特殊子帧时，SRS符号个数为2个</comment>
        </bits>
        <bits access="rw" name="srs_map_ofdm2_curr" pos="23:20" rst="0x0">
          <comment>第二个SRS发送的OFDM符号位置</comment>
        </bits>
        <bits access="rw" name="sra_map_ofdm1_curr" pos="19:16" rst="0x0">
          <comment>第一个SRS发送的OFDM符号位置</comment>
        </bits>
        <bits access="rw" name="special_frame_start_curr" pos="15:12" rst="0x0">
          <comment>只发SRS（特殊子帧）时，子帧起始发送的OFDM符号位置</comment>
        </bits>
        <bits access="rw" name="srs_zc_len_curr" pos="10:0" rst="0x0">
          <comment>SRS的ZC序列长度值</comment>
        </bits>
      </reg>
      <reg name="puc_map_cfg_curr1" protect="rw">
        <comment>PUCCH资源映射参数寄存器</comment>
        <bits access="rw" name="tx_fir_en_curr" pos="31" rst="0x0">
          <comment>0：TX滤波不使能
1：TX滤波使能</comment>
        </bits>
        <bits access="rw" name="tx_nb_start2_curr" pos="30:24" rst="0x0">
          <comment>窄带在系统带宽内的起始位置2</comment>
        </bits>
        <bits access="rw" name="tx_nb_start1_curr" pos="22:16" rst="0x0">
          <comment>窄带在系统带宽内的起始位置1</comment>
        </bits>
        <bits access="rw" name="puc_map_start2_curr" pos="14:8" rst="0x0">
          <comment>第二个时隙PUCCH映射起始位置</comment>
        </bits>
        <bits access="rw" name="puc_map_start1_curr" pos="6:0" rst="0x0">
          <comment>第一个时隙PUCCH映射起始位置</comment>
        </bits>
      </reg>
      <reg name="pus_map_cfg_curr1" protect="rw">
        <comment>PUSCH资源映射参数寄存器</comment>
        <bits access="rw" name="pus_map_sel_curr" pos="31" rst="0x0">
          <comment>PUSCH映射分配类型：
0：资源映射0.5ms；
1：资源映射1ms；</comment>
        </bits>
        <bits access="rw" name="pus_map_len2_curr" pos="30:24" rst="0x0">
          <comment>第二段PUSCH频域映射长度值</comment>
        </bits>
        <bits access="rw" name="pus_map_len1_curr" pos="22:16" rst="0x0">
          <comment>第一段PUSCH频域映射长度值</comment>
        </bits>
        <bits access="rw" name="pus_map_start2_curr" pos="14:8" rst="0x0">
          <comment>第二段PUSCH频域映射起始位置</comment>
        </bits>
        <bits access="rw" name="pus_map_start1_curr" pos="6:0" rst="0x0">
          <comment>第一段PUSCH频域映射起始位置</comment>
        </bits>
      </reg>
      <reg name="hard_para_curr11" protect="rw">
        <comment>硬化计算参数配置寄存器1</comment>
        <bits access="rw" name="pucpus_shortened_mode_curr" pos="14:11" rst="0x0">
          <comment>PUSCH/PUCCH符号打孔处理指示：
0000：normal
0001：type0_shortend
0010：type1_shortend
0011：type2_shortend
0100：type3_shortend
0101：type4_shortend
0110：type5_shortend
0111:  type6_shortend
1000:  type7_shortend
1001:  other</comment>
        </bits>
        <bits access="rw" name="group_hop_flag_curr" pos="10" rst="0x0">
          <comment>1：u值跳变
0：u值不跳变</comment>
        </bits>
        <bits access="rw" name="seq_hop_flag_curr" pos="9" rst="0x0">
          <comment>1：v值跳变
0：v值不跳变</comment>
        </bits>
        <bits access="rw" name="ta_overlap_curr" pos="8:3" rst="0x0">
          <comment>连续两个发送帧覆盖TA部分索引值，取值范围0~32</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_field_curr" pos="2:0" rst="0x0">
          <comment>dmrsValue参考信号解调的循环偏移值，取值范围0~7</comment>
        </bits>
      </reg>
      <reg name="hard_para _curr21" protect="rw">
        <comment>硬化计算参数配置寄存器2</comment>
        <bits access="rw" name="delta_apc_srs_curr" pos="31:16" rst="0x0">
          <comment>SRS的小数APC（ ）调整因子</comment>
        </bits>
        <bits access="rw" name="delta_apc_scr_curr" pos="15:0" rst="0x0">
          <comment>PUSCH/PUCCH/PRACH的小数APC（ ）调整因子</comment>
        </bits>
      </reg>
      <reg name="hard_para _curr31" protect="rw">
        <comment>硬化计算参数配置寄存器3</comment>
        <bits access="rw" name="n1_pucch_curr" pos="31:20" rst="0x0">
          <comment>PUCCH格式1/1a/1b的资源索引值，取值范围0~4095</comment>
        </bits>
        <bits access="rw" name="srs_cycle_shift_curr" pos="19:16" rst="0x0">
          <comment>SRS循环移位值</comment>
        </bits>
        <bits access="rw" name="subframe_slot_cnt_curr" pos="14:10" rst="0x0">
          <comment>对CAT1/CATM/CAT-NB子载波15kHz，每次调用对应1ms内2个时隙，该参数表示子帧号；对CAT-NB子载波3.75kHz，每次调用对应2ms内1个时隙，该参数表示时隙号</comment>
        </bits>
        <bits access="rw" name="nf_curr" pos="9:0" rst="0x0">
          <comment>无线帧号，取值范围0~1023</comment>
        </bits>
      </reg>
      <reg name="ofdm_offset_curr1" protect="rw">
        <comment>OFDM OFFSET配置寄存器</comment>
        <bits access="rw" name="ofdm_offset_last_curr" pos="31:16" rst="0x0">
          <comment>最后一个OFDM符号的offset值</comment>
        </bits>
        <bits access="rw" name="ofdm_offset_first_curr" pos="15:0" rst="0x0">
          <comment>第一个OFDM符号的offset值</comment>
        </bits>
      </reg>
      <reg name="dft_fft_inten_curr1" protect="rw">
        <comment>中断使能寄存器</comment>
        <bits access="rw" name="err_inten_curr" pos="15" rst="0x0">
          <comment>0：ULDFT访问TXRX或PUSCH存储器ERROR中断不使能
1：ULDFT访问TXRX或PUSCH存储器ERROR中断不使能</comment>
        </bits>
        <bits access="rw" name="dma_inten_curr" pos="14" rst="0x0">
          <comment>1：AXIDMA中断使能
0：AXIDMA中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten13_curr" pos="13" rst="0x0">
          <comment>1：OFDM符号13中断使能
0：OFDM符号13中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten12_curr" pos="12" rst="0x0">
          <comment>1：OFDM符号12中断使能
0：OFDM符号12中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten11_curr" pos="11" rst="0x0">
          <comment>1：OFDM符号11中断使能
0：OFDM符号11中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten10_curr" pos="10" rst="0x0">
          <comment>1：OFDM符号10中断使能
0：OFDM符号10中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten9_curr" pos="9" rst="0x0">
          <comment>1：OFDM符号9中断使能
0：OFDM符号9中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten8_curr" pos="8" rst="0x0">
          <comment>1：OFDM符号8中断使能
0：OFDM符号8中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten7_curr" pos="7" rst="0x0">
          <comment>1：OFDM符号7中断使能
0：OFDM符号7中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten6_curr" pos="6" rst="0x0">
          <comment>1：OFDM符号6中断使能
0：OFDM符号6中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten5_curr" pos="5" rst="0x0">
          <comment>1：OFDM符号5中断使能
0：OFDM符号5中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten4_curr" pos="4" rst="0x0">
          <comment>1：OFDM符号4中断使能
0：OFDM符号4中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten3_curr" pos="3" rst="0x0">
          <comment>1：OFDM符号3中断使能
0：OFDM符号3中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten2_curr" pos="2" rst="0x0">
          <comment>1：OFDM符号2中断使能
0：OFDM符号2中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten1_curr" pos="1" rst="0x0">
          <comment>1：OFDM符号1中断使能
0：OFDM符号1中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten0_curr" pos="0" rst="0x0">
          <comment>1：OFDM符号0中断使能
0：OFDM符号0中断未使能</comment>
        </bits>
      </reg>
      <reg name="ofdm_zero_curr1" protect="rw">
        <comment>OFDM符号填零发送寄存器</comment>
        <bits access="rw" name="ofdm_zero_curr" pos="13:0" rst="0x0">
          <comment>指示填零发送的OFDM符号数：
14’b0：没有填零发送
14’b1：符号0填零发送
14’b11：符号0，1填零发送
14’b111：符号0，1，2填零发送
……</comment>
        </bits>
      </reg>
      <reg name="dft_fft_ctrl_curr1" protect="rw">
        <comment>DFT/IDFT&amp;FFT/IFFT控制寄存器</comment>
        <bits access="rw" name="dftfft_soft_start" pos="30" rst="0x0">
          <comment>0：软件未触发ULDFT启动
1：软件触发ULDFT启动</comment>
        </bits>
        <bits access="rw" name="dft_trig_mode" pos="29" rst="0x0">
          <comment>0：ULDFT启动模式为软件触发
1：ULDFT启动模式为PUSCH模块触发</comment>
        </bits>
        <bits access="rw" name="launch_en_curr" pos="28" rst="0x0">
          <comment>0：启窗不使能
1：启窗使能</comment>
        </bits>
        <bits access="rw" name="srs_en_curr" pos="27" rst="0x0">
          <comment>0：SRS产生不使能
1：SRS产生使能</comment>
        </bits>
        <bits access="rw" name="clear_en_curr" pos="26" rst="0x0">
          <comment>0：FFT输入MEM清零功能不使能
1：FFT输入MEM清零功能使能</comment>
        </bits>
        <bits access="rw" name="fft_ifft_sel_curr" pos="25" rst="0x0">
          <comment>1：选择IFFT运算
0：选择FFT运算</comment>
        </bits>
        <bits access="rw" name="fft_cal_curr" pos="24" rst="0x0">
          <comment>1：FFT/IFFT运算使能
0：FFT/IFFT运算不使能</comment>
        </bits>
        <bits access="rw" name="pwradj_en_curr" pos="23" rst="0x0">
          <comment>0：功率调整不使能
1：功率调整使能</comment>
        </bits>
        <bits access="rw" name="prach_format_sel_curr" pos="22:20" rst="0x0">
          <comment>指示PRACH格式类型：
000：PRACH格式0
001：PRACH格式1
010：PRACH格式2
011：PRACH格式3
100：PRACH格式4
其他：保留</comment>
        </bits>
        <bits access="rw" name="pucch_format_sel_curr" pos="19:17" rst="0x0">
          <comment>指示PUCCH格式类型：
000：PUCCH格式1
001：PUCCH格式1a
010：PUCCH格式1b
011：PUCCH格式2
100：PUCCH格式2a
101：PUCCH格式2b
其他：保留</comment>
        </bits>
        <bits access="rw" name="npusch_formatsel_curr" pos="16" rst="0x0">
          <comment>0：NPUSCH format 1
1：NPUSCH format2</comment>
        </bits>
        <bits access="rw" name="ofdm_num_curr" pos="15:12" rst="0x0">
          <comment>指示OFDM符号的个数</comment>
        </bits>
        <bits access="rw" name="datadrive_en_curr" pos="10" rst="0x0">
          <comment>0：DATADRIVE不使能
1：DATADRIVE使能</comment>
        </bits>
        <bits access="rw" name="pus_buf_sel_curr" pos="9:8" rst="0x0">
          <comment>指示UL_DFT读PUSCH BUFFER块选择：
00：PUSCH BUFFER1
01：PUSCH BUFFER2
10：PUSCH BUFFER3
11：PUSCH PRA_BUF</comment>
        </bits>
        <bits access="rw" name="chan_mode_curr" pos="6:4" rst="0x0">
          <comment>指示上行信道发送模式
000：PUSCH
001：PUCCH
010：PRACH
011：SRS
100：NPUSCH
101：NPRACH
其他：保留</comment>
        </bits>
        <bits access="rw" name="fft_npts" pos="3:1" rst="0x0">
          <comment>FFT/IFFT点数选择
111：保留（不可配）
110：保留（不可配）
101：保留（不可配）
100：2048点
011：1024点
010：512点
001：256点
000：128点</comment>
        </bits>
        <bits access="rw" name="dftfft_irqen_curr" pos="0" rst="0x0">
          <comment>0: 中断不使能
1: 中断使能</comment>
        </bits>
      </reg>
      <reg name=" fft_lnum_srs_curr1" protect="rw">
        <comment>SRS的FFT截位因子参数寄存器</comment>
        <bits access="rw" name="fft_lnum11_srs_curr" pos="21:20" rst="0x0">
          <comment>FFT第十一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_srs_curr" pos="19:18" rst="0x0">
          <comment>FFT第十级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_srs_curr" pos="17:16" rst="0x0">
          <comment>FFT第九级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_srs_curr" pos="15:14" rst="0x0">
          <comment>FFT第八级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_srs_curr" pos="13:12" rst="0x0">
          <comment>FFT第七级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_srs_curr" pos="11:10" rst="0x0">
          <comment>FFT第六级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_srs_curr" pos="9:8" rst="0x0">
          <comment>FFT第五级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_srs_curr" pos="7:6" rst="0x0">
          <comment>FFT第四级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_srs_curr" pos="5:4" rst="0x0">
          <comment>FFT第三级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_srs_curr" pos="3:2" rst="0x0">
          <comment>FFT第二级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_srs_curr" pos="1:0" rst="0x0">
          <comment>FFT第一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
      </reg>
      <reg name="fft_lnum_scr_curr1" protect="rw">
        <comment>PUSCH/PUCCH/PRACH的FFT截位因子参数寄存器</comment>
        <bits access="rw" name="fft_lnum11_scr_curr" pos="21:20" rst="0x0">
          <comment>FFT第十一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_scr_curr" pos="19:18" rst="0x0">
          <comment>FFT第十级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_scr_curr" pos="17:16" rst="0x0">
          <comment>FFT第九级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_scr_curr" pos="15:14" rst="0x0">
          <comment>FFT第八级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_scr_curr" pos="13:12" rst="0x0">
          <comment>FFT第七级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_scr_curr" pos="11:10" rst="0x0">
          <comment>FFT第六级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_scr_curr" pos="9:8" rst="0x0">
          <comment>FFT第五级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_scr_curr" pos="7:6" rst="0x0">
          <comment>FFT第四级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_scr_curr" pos="5:4" rst="0x0">
          <comment>FFT第三级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_scr_curr" pos="3:2" rst="0x0">
          <comment>FFT第二级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_scr_curr" pos="1:0" rst="0x0">
          <comment>FFT第一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
      </reg>
      <reg name="npus_map_cfg_curr1" protect="rw">
        <comment>NPUSCH参数寄存器</comment>
        <bits access="rw" name="npus_rep_cnt_curr" pos="23:17" rst="0x0">
          <comment>NPUSCH当前重复传输的第几次，取值范围0~127</comment>
        </bits>
        <bits access="rw" name="n_ru_sc_curr" pos="16:15" rst="0x0">
          <comment>子载波个数：
00：1个子载波
01：3个子载波
10：6个子载波
11：12个子载波</comment>
        </bits>
        <bits access="rw" name="isc_start_index_curr" pos="14:9" rst="0x0">
          <comment>NPUSCH 的起始子载波位置，取值范围0~47</comment>
        </bits>
        <bits access="rw" name="n_slot_cnt_curr" pos="8:1" rst="0x0">
          <comment>当前传输的第几个Nslots单位，取值范围1~160</comment>
        </bits>
        <bits access="rw" name="npus_sub_space_curr" pos="0" rst="0x0">
          <comment>0: 3.75KHz
1: 15KHz</comment>
        </bits>
      </reg>
      <reg name="npus_dmrs_cfg_curr1" protect="rw">
        <comment>NPUSCH DMRS参数寄存器</comment>
        <bits access="rw" name="first_ru_slot_curr" pos="26:22" rst="0x0">
          <comment>首个RU的首个时隙号，取值范围0~19</comment>
        </bits>
        <bits access="rw" name="slot_n_curr" pos="21:7" rst="0x0">
          <comment>用于子载波个数为1生成DMRS时，表示第几个时隙，取值范围0~20480</comment>
        </bits>
        <bits access="rw" name="base_seq_curr" pos="6:2" rst="0x0">
          <comment>BASE_SEQ_CURR值，取值范围0~30</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_curr" pos="1:0" rst="0x0">
          <comment>CYCLIC_SHIFT值，取值范围0~3</comment>
        </bits>
      </reg>
      <reg name="npra _cfg_curr1" protect="rw">
        <comment>NPRACH参数寄存器</comment>
        <bits access="rw" name="sym_group_rep_cnt_curr" pos="16:9" rst="0x0">
          <comment>t值，取值范围0~128</comment>
        </bits>
        <bits access="rw" name="nprach_sc_offset_curr" pos="8:6" rst="0x0">
          <comment>frequency location of the first sub-carrier allocated to NPRACH：
000：frequency location为0；
001：frequency location为2；
010：frequency location为12
011：frequency location为18
100：frequency location为24
101：frequency location为34
110：frequency location为36
111：默认为0</comment>
        </bits>
        <bits access="rw" name="init_sc_curr" pos="5:0" rst="0x0">
          <comment>being the subcarrier selected by the MAC layer from  ，取值范围0-47</comment>
        </bits>
      </reg>
      <reg name="dft_ctrl_curr2" protect="rw">
        <comment>DFT/IDFT控制寄存器</comment>
        <bits access="rw" name="anti_drop_en_curr" pos="12" rst="0x0">
          <comment>0：ANTI_DROP功能不使能
1：ANTI_DROP功能使能</comment>
        </bits>
        <bits access="rw" name="anti_drop_lnum_curr" pos="11" rst="0x0">
          <comment>ANTI_DROP功能截位因子:
0：右移8bit
1：右移7bit</comment>
        </bits>
        <bits access="rw" name="dft_npts_curr" pos="10:5" rst="0x0">
          <comment>DFT/IDFT点数选择的index，0~43分别指示44种点数，index与实际点数的对应关系如下表说明 （不可配置其他值）</comment>
        </bits>
        <bits access="rw" name="pus_modu_sel_curr" pos="4:3" rst="0x0">
          <comment>00: BPSK调制方式
01: QPSK调制方式
10: 16QAM调制方式
11: 64QAM调制方式</comment>
        </bits>
        <bits access="rw" name="dft_en_curr" pos="2" rst="0x0">
          <comment>0：DFT/IDFT功能不使能
1：DFT/IDFT功能使能</comment>
        </bits>
        <bits access="rw" name="pus_mod_en_curr" pos="1" rst="0x0">
          <comment>0：PUSCH调制功能不使能
1：PUSCH调制功能使能</comment>
        </bits>
        <bits access="rw" name="dft_idft_sel_curr" pos="0" rst="0x0">
          <comment>0: 选择DFT运算
1: 选择IDFT运算</comment>
        </bits>
      </reg>
      <reg name="puc_mod_data_curr2" protect="rw">
        <comment>PUCCH调制输入数据寄存器</comment>
        <bits access="rw" name="puc_mod_data_curr" pos="21:0" rst="0x0">
          <comment>PUCCH调制输入数据d(n)</comment>
        </bits>
      </reg>
      <reg name="srs_map_cfg_curr2" protect="rw">
        <comment>SRS资源映射参数配置寄存器</comment>
        <bits access="rw" name="k_tc_num_curr" pos="26" rst="0x0">
          <comment>SRS填零间隔指示：
0：每2个子载波填1个零；
1：每4个子载波填3个零；</comment>
        </bits>
        <bits access="rw" name="k_tc_curr" pos="25:24" rst="0x0">
          <comment>起始子载波位置（梳齿位置），取值范围：
00：0；
01：1；
10：2；
11：3；</comment>
        </bits>
        <bits access="rw" name="srs_map_len_curr" pos="22:16" rst="0x0">
          <comment>SRS频域映射长度值</comment>
        </bits>
        <bits access="rw" name="srs_map_start2_curr" pos="14:8" rst="0x0">
          <comment>第二个SRS符号频域映射起始位置</comment>
        </bits>
        <bits access="rw" name="srs_map_start1_curr" pos="6:0" rst="0x0">
          <comment>第一个SRS符号频域映射起始位置</comment>
        </bits>
      </reg>
      <reg name="srs_zc_len_curr2" protect="rw">
        <comment>SRS的ZC序列长度寄存器</comment>
        <bits access="rw" name="srs_num_curr" pos="24" rst="0x0">
          <comment>0：发送特殊子帧时，SRS符号个数为1个
1：发送特殊子帧时，SRS符号个数为2个</comment>
        </bits>
        <bits access="rw" name="srs_map_ofdm2_curr" pos="23:20" rst="0x0">
          <comment>第二个SRS发送的OFDM符号位置</comment>
        </bits>
        <bits access="rw" name="sra_map_ofdm1_curr" pos="19:16" rst="0x0">
          <comment>第一个SRS发送的OFDM符号位置</comment>
        </bits>
        <bits access="rw" name="special_frame_start_curr" pos="15:12" rst="0x0">
          <comment>只发SRS（特殊子帧）时，子帧起始发送的OFDM符号位置</comment>
        </bits>
        <bits access="rw" name="srs_zc_len_curr" pos="10:0" rst="0x0">
          <comment>SRS的ZC序列长度值</comment>
        </bits>
      </reg>
      <reg name="puc_map_cfg_curr2" protect="rw">
        <comment>PUCCH资源映射参数寄存器</comment>
        <bits access="rw" name="tx_fir_en_curr" pos="31" rst="0x0">
          <comment>0：TX滤波不使能
1：TX滤波使能</comment>
        </bits>
        <bits access="rw" name="tx_nb_start2_curr" pos="30:24" rst="0x0">
          <comment>窄带在系统带宽内的起始位置2</comment>
        </bits>
        <bits access="rw" name="tx_nb_start1_curr" pos="22:16" rst="0x0">
          <comment>窄带在系统带宽内的起始位置1</comment>
        </bits>
        <bits access="rw" name="puc_map_start2_curr" pos="14:8" rst="0x0">
          <comment>第二个时隙PUCCH映射起始位置</comment>
        </bits>
        <bits access="rw" name="puc_map_start1_curr" pos="6:0" rst="0x0">
          <comment>第一个时隙PUCCH映射起始位置</comment>
        </bits>
      </reg>
      <reg name="pus_map_cfg_curr2" protect="rw">
        <comment>PUSCH资源映射参数寄存器</comment>
        <bits access="rw" name="pus_map_sel_curr" pos="31" rst="0x0">
          <comment>PUSCH映射分配类型：
0：资源映射0.5ms；
1：资源映射1ms；</comment>
        </bits>
        <bits access="rw" name="pus_map_len2_curr" pos="30:24" rst="0x0">
          <comment>第二段PUSCH频域映射长度值</comment>
        </bits>
        <bits access="rw" name="pus_map_len1_curr" pos="22:16" rst="0x0">
          <comment>第一段PUSCH频域映射长度值</comment>
        </bits>
        <bits access="rw" name="pus_map_start2_curr" pos="14:8" rst="0x0">
          <comment>第二段PUSCH频域映射起始位置</comment>
        </bits>
        <bits access="rw" name="pus_map_start1_curr" pos="6:0" rst="0x0">
          <comment>第一段PUSCH频域映射起始位置</comment>
        </bits>
      </reg>
      <reg name="hard_para_curr12" protect="rw">
        <comment>硬化计算参数配置寄存器1</comment>
        <bits access="rw" name="pucpus_shortened_mode_curr" pos="14:11" rst="0x0">
          <comment>PUSCH/PUCCH符号打孔处理指示：
0000：normal
0001：type0_shortend
0010：type1_shortend
0011：type2_shortend
0100：type3_shortend
0101：type4_shortend
0110：type5_shortend
0111:  type6_shortend
1000:  type7_shortend
1001:  other</comment>
        </bits>
        <bits access="rw" name="group_hop_flag_curr" pos="10" rst="0x0">
          <comment>1：u值跳变
0：u值不跳变</comment>
        </bits>
        <bits access="rw" name="seq_hop_flag_curr" pos="9" rst="0x0">
          <comment>1：v值跳变
0：v值不跳变</comment>
        </bits>
        <bits access="rw" name="ta_overlap_curr" pos="8:3" rst="0x0">
          <comment>连续两个发送帧覆盖TA部分索引值，取值范围0~32</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_field_curr" pos="2:0" rst="0x0">
          <comment>dmrsValue参考信号解调的循环偏移值，取值范围0~7</comment>
        </bits>
      </reg>
      <reg name="hard_para _curr22" protect="rw">
        <comment>硬化计算参数配置寄存器2</comment>
        <bits access="rw" name="delta_apc_srs_curr" pos="31:16" rst="0x0">
          <comment>SRS的小数APC（ ）调整因子</comment>
        </bits>
        <bits access="rw" name="delta_apc_scr_curr" pos="15:0" rst="0x0">
          <comment>PUSCH/PUCCH/PRACH的小数APC（ ）调整因子</comment>
        </bits>
      </reg>
      <reg name="hard_para _curr32" protect="rw">
        <comment>硬化计算参数配置寄存器3</comment>
        <bits access="rw" name="n1_pucch_curr" pos="31:20" rst="0x0">
          <comment>PUCCH格式1/1a/1b的资源索引值，取值范围0~4095</comment>
        </bits>
        <bits access="rw" name="srs_cycle_shift_curr" pos="19:16" rst="0x0">
          <comment>SRS循环移位值</comment>
        </bits>
        <bits access="rw" name="subframe_slot_cnt_curr" pos="14:10" rst="0x0">
          <comment>对CAT1/CATM/CAT-NB子载波15kHz，每次调用对应1ms内2个时隙，该参数表示子帧号；对CAT-NB子载波3.75kHz，每次调用对应2ms内1个时隙，该参数表示时隙号</comment>
        </bits>
        <bits access="rw" name="nf_curr" pos="9:0" rst="0x0">
          <comment>无线帧号，取值范围0~1023</comment>
        </bits>
      </reg>
      <reg name="ofdm_offset_curr2" protect="rw">
        <comment>OFDM OFFSET配置寄存器</comment>
        <bits access="rw" name="ofdm_offset_last_curr" pos="31:16" rst="0x0">
          <comment>最后一个OFDM符号的offset值</comment>
        </bits>
        <bits access="rw" name="ofdm_offset_first_curr" pos="15:0" rst="0x0">
          <comment>第一个OFDM符号的offset值</comment>
        </bits>
      </reg>
      <reg name="dft_fft_inten_curr2" protect="rw">
        <comment>中断使能寄存器</comment>
        <bits access="rw" name="err_inten_curr" pos="15" rst="0x0">
          <comment>0：ULDFT访问TXRX或PUSCH存储器ERROR中断不使能
1：ULDFT访问TXRX或PUSCH存储器ERROR中断不使能</comment>
        </bits>
        <bits access="rw" name="dma_inten_curr" pos="14" rst="0x0">
          <comment>1：AXIDMA中断使能
0：AXIDMA中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten13_curr" pos="13" rst="0x0">
          <comment>1：OFDM符号13中断使能
0：OFDM符号13中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten12_curr" pos="12" rst="0x0">
          <comment>1：OFDM符号12中断使能
0：OFDM符号12中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten11_curr" pos="11" rst="0x0">
          <comment>1：OFDM符号11中断使能
0：OFDM符号11中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten10_curr" pos="10" rst="0x0">
          <comment>1：OFDM符号10中断使能
0：OFDM符号10中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten9_curr" pos="9" rst="0x0">
          <comment>1：OFDM符号9中断使能
0：OFDM符号9中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten8_curr" pos="8" rst="0x0">
          <comment>1：OFDM符号8中断使能
0：OFDM符号8中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten7_curr" pos="7" rst="0x0">
          <comment>1：OFDM符号7中断使能
0：OFDM符号7中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten6_curr" pos="6" rst="0x0">
          <comment>1：OFDM符号6中断使能
0：OFDM符号6中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten5_curr" pos="5" rst="0x0">
          <comment>1：OFDM符号5中断使能
0：OFDM符号5中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten4_curr" pos="4" rst="0x0">
          <comment>1：OFDM符号4中断使能
0：OFDM符号4中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten3_curr" pos="3" rst="0x0">
          <comment>1：OFDM符号3中断使能
0：OFDM符号3中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten2_curr" pos="2" rst="0x0">
          <comment>1：OFDM符号2中断使能
0：OFDM符号2中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten1_curr" pos="1" rst="0x0">
          <comment>1：OFDM符号1中断使能
0：OFDM符号1中断未使能</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten0_curr" pos="0" rst="0x0">
          <comment>1：OFDM符号0中断使能
0：OFDM符号0中断未使能</comment>
        </bits>
      </reg>
      <reg name="ofdm_zero_curr2" protect="rw">
        <comment>OFDM符号填零发送寄存器</comment>
        <bits access="rw" name="ofdm_zero_curr" pos="13:0" rst="0x0">
          <comment>指示填零发送的OFDM符号数：
14’b0：没有填零发送
14’b1：符号0填零发送
14’b11：符号0，1填零发送
14’b111：符号0，1，2填零发送
……</comment>
        </bits>
      </reg>
      <reg name="dft_fft_ctrl_curr2" protect="rw">
        <comment>DFT/IDFT&amp;FFT/IFFT控制寄存器</comment>
        <bits access="rw" name="dftfft_soft_start" pos="30" rst="0x0">
          <comment>0：软件未触发ULDFT启动
1：软件触发ULDFT启动</comment>
        </bits>
        <bits access="rw" name="dft_trig_mode" pos="29" rst="0x0">
          <comment>0：ULDFT启动模式为软件触发
1：ULDFT启动模式为PUSCH模块触发</comment>
        </bits>
        <bits access="rw" name="launch_en_curr" pos="28" rst="0x0">
          <comment>0：启窗不使能
1：启窗使能</comment>
        </bits>
        <bits access="rw" name="srs_en_curr" pos="27" rst="0x0">
          <comment>0：SRS产生不使能
1：SRS产生使能</comment>
        </bits>
        <bits access="rw" name="clear_en_curr" pos="26" rst="0x0">
          <comment>0：FFT输入MEM清零功能不使能
1：FFT输入MEM清零功能使能</comment>
        </bits>
        <bits access="rw" name="fft_ifft_sel_curr" pos="25" rst="0x0">
          <comment>1：选择IFFT运算
0：选择FFT运算</comment>
        </bits>
        <bits access="rw" name="fft_cal_curr" pos="24" rst="0x0">
          <comment>1：FFT/IFFT运算使能
0：FFT/IFFT运算不使能</comment>
        </bits>
        <bits access="rw" name="pwradj_en_curr" pos="23" rst="0x0">
          <comment>0：功率调整不使能
1：功率调整使能</comment>
        </bits>
        <bits access="rw" name="prach_format_sel_curr" pos="22:20" rst="0x0">
          <comment>指示PRACH格式类型：
000：PRACH格式0
001：PRACH格式1
010：PRACH格式2
011：PRACH格式3
100：PRACH格式4
其他：保留</comment>
        </bits>
        <bits access="rw" name="pucch_format_sel_curr" pos="19:17" rst="0x0">
          <comment>指示PUCCH格式类型：
000：PUCCH格式1
001：PUCCH格式1a
010：PUCCH格式1b
011：PUCCH格式2
100：PUCCH格式2a
101：PUCCH格式2b
其他：保留</comment>
        </bits>
        <bits access="rw" name="npusch_formatsel_curr" pos="16" rst="0x0">
          <comment>0：NPUSCH format 1
1：NPUSCH format2</comment>
        </bits>
        <bits access="rw" name="ofdm_num_curr" pos="15:12" rst="0x0">
          <comment>指示OFDM符号的个数</comment>
        </bits>
        <bits access="rw" name="datadrive_en_curr" pos="10" rst="0x0">
          <comment>0：DATADRIVE不使能
1：DATADRIVE使能</comment>
        </bits>
        <bits access="rw" name="pus_buf_sel_curr" pos="9:8" rst="0x0">
          <comment>指示UL_DFT读PUSCH BUFFER块选择：
00：PUSCH BUFFER1
01：PUSCH BUFFER2
10：PUSCH BUFFER3
11：PUSCH PRA_BUF</comment>
        </bits>
        <bits access="rw" name="chan_mode_curr" pos="6:4" rst="0x0">
          <comment>指示上行信道发送模式
000：PUSCH
001：PUCCH
010：PRACH
011：SRS
100：NPUSCH
101：NPRACH
其他：保留</comment>
        </bits>
        <bits access="rw" name="fft_npts" pos="3:1" rst="0x0">
          <comment>FFT/IFFT点数选择
111：保留（不可配）
110：保留（不可配）
101：保留（不可配）
100：2048点
011：1024点
010：512点
001：256点
000：128点</comment>
        </bits>
        <bits access="rw" name="dftfft_irqen_curr" pos="0" rst="0x0">
          <comment>0: 中断不使能
1: 中断使能</comment>
        </bits>
      </reg>
      <reg name=" fft_lnum_srs_curr2" protect="rw">
        <comment>SRS的FFT截位因子参数寄存器</comment>
        <bits access="rw" name="fft_lnum11_srs_curr" pos="21:20" rst="0x0">
          <comment>FFT第十一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_srs_curr" pos="19:18" rst="0x0">
          <comment>FFT第十级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_srs_curr" pos="17:16" rst="0x0">
          <comment>FFT第九级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_srs_curr" pos="15:14" rst="0x0">
          <comment>FFT第八级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_srs_curr" pos="13:12" rst="0x0">
          <comment>FFT第七级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_srs_curr" pos="11:10" rst="0x0">
          <comment>FFT第六级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_srs_curr" pos="9:8" rst="0x0">
          <comment>FFT第五级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_srs_curr" pos="7:6" rst="0x0">
          <comment>FFT第四级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_srs_curr" pos="5:4" rst="0x0">
          <comment>FFT第三级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_srs_curr" pos="3:2" rst="0x0">
          <comment>FFT第二级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_srs_curr" pos="1:0" rst="0x0">
          <comment>FFT第一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
      </reg>
      <reg name="fft_lnum_scr_curr2" protect="rw">
        <comment>PUSCH/PUCCH/PRACH的FFT截位因子参数寄存器</comment>
        <bits access="rw" name="fft_lnum11_scr_curr" pos="21:20" rst="0x0">
          <comment>FFT第十一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_scr_curr" pos="19:18" rst="0x0">
          <comment>FFT第十级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_scr_curr" pos="17:16" rst="0x0">
          <comment>FFT第九级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_scr_curr" pos="15:14" rst="0x0">
          <comment>FFT第八级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_scr_curr" pos="13:12" rst="0x0">
          <comment>FFT第七级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_scr_curr" pos="11:10" rst="0x0">
          <comment>FFT第六级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_scr_curr" pos="9:8" rst="0x0">
          <comment>FFT第五级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_scr_curr" pos="7:6" rst="0x0">
          <comment>FFT第四级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_scr_curr" pos="5:4" rst="0x0">
          <comment>FFT第三级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_scr_curr" pos="3:2" rst="0x0">
          <comment>FFT第二级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_scr_curr" pos="1:0" rst="0x0">
          <comment>FFT第一级截位因子指示：
2’b00：截取25~14bit
2’b01：截取26~15bit
2’b10：截取27~16bit
2’b11：截取28~17bit</comment>
        </bits>
      </reg>
      <reg name="npus_map_cfg_curr2" protect="rw">
        <comment>NPUSCH参数寄存器</comment>
        <bits access="rw" name="npus_rep_cnt_curr" pos="23:17" rst="0x0">
          <comment>NPUSCH当前重复传输的第几次，取值范围0~127</comment>
        </bits>
        <bits access="rw" name="n_ru_sc_curr" pos="16:15" rst="0x0">
          <comment>子载波个数：
00：1个子载波
01：3个子载波
10：6个子载波
11：12个子载波</comment>
        </bits>
        <bits access="rw" name="isc_start_index_curr" pos="14:9" rst="0x0">
          <comment>NPUSCH 的起始子载波位置，取值范围0~47</comment>
        </bits>
        <bits access="rw" name="n_slot_cnt_curr" pos="8:1" rst="0x0">
          <comment>当前传输的第几个Nslots单位，取值范围1~160</comment>
        </bits>
        <bits access="rw" name="npus_sub_space_curr" pos="0" rst="0x0">
          <comment>0: 3.75KHz
1: 15KHz</comment>
        </bits>
      </reg>
      <reg name="npus_dmrs_cfg_curr2" protect="rw">
        <comment>NPUSCH DMRS参数寄存器</comment>
        <bits access="rw" name="first_ru_slot_curr" pos="26:22" rst="0x0">
          <comment>首个RU的首个时隙号，取值范围0~19</comment>
        </bits>
        <bits access="rw" name="slot_n_curr" pos="21:7" rst="0x0">
          <comment>用于子载波个数为1生成DMRS时，表示第几个时隙，取值范围0~20480</comment>
        </bits>
        <bits access="rw" name="base_seq_curr" pos="6:2" rst="0x0">
          <comment>BASE_SEQ_CURR值，取值范围0~30</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_curr" pos="1:0" rst="0x0">
          <comment>CYCLIC_SHIFT值，取值范围0~3</comment>
        </bits>
      </reg>
      <reg name="npra _cfg_curr2" protect="rw">
        <comment>NPRACH参数寄存器</comment>
        <bits access="rw" name="sym_group_rep_cnt_curr" pos="16:9" rst="0x0">
          <comment>t值，取值范围0~128</comment>
        </bits>
        <bits access="rw" name="nprach_sc_offset_curr" pos="8:6" rst="0x0">
          <comment>frequency location of the first sub-carrier allocated to NPRACH：
000：frequency location为0；
001：frequency location为2；
010：frequency location为12
011：frequency location为18
100：frequency location为24
101：frequency location为34
110：frequency location为36
111：默认为0</comment>
        </bits>
        <bits access="rw" name="init_sc_curr" pos="5:0" rst="0x0">
          <comment>being the subcarrier selected by the MAC layer from  ，取值范围0-47</comment>
        </bits>
      </reg>
      <reg name="fsm_state" protect="rw">
        <comment>状态机只读寄存器</comment>
        <bits access="r" name="ocp_pi" pos="31" rst="0x0">
          <comment>TXRX PING存储器空满指示
1：存储器满
0：存储器空</comment>
        </bits>
        <bits access="r" name="ocp_pa" pos="30" rst="0x0">
          <comment>TXRX PANG存储器空满指示
1：存储器满
0：存储器空</comment>
        </bits>
        <bits access="r" name="frame_state" pos="29:16" rst="0x0">
          <comment>子帧级状态机指示</comment>
        </bits>
        <bits access="r" name="ofdm_state" pos="15:0" rst="0x0">
          <comment>符号级状态机指示</comment>
        </bits>
      </reg>
      <reg name="ofdm_count" protect="rw">
        <comment>OFDM符号计数只读寄存器</comment>
        <bits access="r" name="ofdm_count" pos="3:0" rst="0x0">
          <comment>OFDM符号计数，取值范围0~13</comment>
        </bits>
      </reg>
      <reg name="fsm_state_assert" protect="rw">
        <comment>ASSERT状态机只读寄存器</comment>
        <bits access="r" name="ocp_pi_assert" pos="31" rst="0x0">
          <comment>ASSERT TXRX PING存储器空满指示
1：存储器满
0：存储器空</comment>
        </bits>
        <bits access="r" name="ocp_pa_assert" pos="30" rst="0x0">
          <comment>ASSERT TXRX PANG存储器空满指示
1：存储器满
0：存储器空</comment>
        </bits>
        <bits access="r" name="frame_state_assert" pos="29:16" rst="0x0">
          <comment>ASSERT子帧级状态机指示</comment>
        </bits>
        <bits access="r" name="ofdm_state_assert" pos="15:0" rst="0x0">
          <comment>ASSERT符号级状态机指示</comment>
        </bits>
      </reg>
      <reg name="ofdm_assert" protect="rw">
        <comment>OFDM符号计数只读寄存器</comment>
        <bits access="r" name="ofdm_assert" pos="3:0" rst="0x0">
          <comment>ASSERT OFDM符号计数，取值范围0~13</comment>
        </bits>
      </reg>
      <hole size="30624"/>
      <reg name="uldft_mem1" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem2" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem3" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem4" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem5" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem6" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem7" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem8" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem9" protect="rw">
        </reg>
      <hole size="16352"/>
      <reg name="uldft_mem10" protect="rw">
        </reg>
    </module>
    <instance address="0x18700000" name="UL_DFT" type="UL_DFT"/>
  </archive>
  <archive relative="txrx.xml">
    <module category="System" name="TXRX">
      <reg name="int_flag" protect="rw">
        <comment>中断标志寄存器</comment>
        <bits access="rc" name="tx_trace_fin" pos="5" rst="0x0">
          <comment>发送完成TRACE中断标志
0：此中断未产生
1：此中断产生</comment>
        </bits>
        <bits access="rc" name="rx_trace_fin" pos="4" rst="0x0">
          <comment>接收完成TRACE中断标志
0：此中断未产生
1：此中断产生</comment>
        </bits>
        <bits access="rc" name="tx_fin" pos="3" rst="0x0">
          <comment>发送完成中断标志
0：此中断未产生
1：此中断产生</comment>
        </bits>
        <bits access="rc" name="tx_ofdm" pos="2" rst="0x0">
          <comment>发送符号中断标志
0：此中断未产生
1：此中断产生</comment>
        </bits>
        <bits access="rc" name="rx_fin" pos="1" rst="0x0">
          <comment>接收完成中断标志
0：此中断未产生
1：此中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm" pos="0" rst="0x0">
          <comment>接收符号中断标志
0：此中断未产生
1：此中断产生</comment>
        </bits>
      </reg>
      <reg name="int_mask" protect="rw">
        <comment>中断屏蔽寄存器</comment>
        <bits access="rw" name="tx_trace_fin" pos="5" rst="0x0">
          <comment>发送完成TRACE屏蔽位
0：不屏蔽此中断
1：屏蔽此中断</comment>
        </bits>
        <bits access="rw" name="rx_trace_fin" pos="4" rst="0x0">
          <comment>接收完成TRACE屏蔽位
0：不屏蔽此中断
1：屏蔽此中断</comment>
        </bits>
        <bits access="rw" name="tx_finish_mask" pos="3" rst="0x0">
          <comment>发送完成中断屏蔽位
0：不屏蔽此中断
1：屏蔽此中断</comment>
        </bits>
        <bits access="rw" name="tx_ofdm_mask" pos="2" rst="0x0">
          <comment>发送符号中断屏蔽位
0：不屏蔽此中断
1：屏蔽此中断</comment>
        </bits>
        <bits access="rw" name="rx_finish_mask" pos="1" rst="0x0">
          <comment>接收完成中断屏蔽位
0：不屏蔽此中断
1：屏蔽此中断</comment>
        </bits>
        <bits access="rw" name="rx_ofdm_mask" pos="0" rst="0x0">
          <comment>接收符号中断屏蔽位
0：不屏蔽此中断
1：屏蔽此中断</comment>
        </bits>
      </reg>
      <reg name="int_flag_ofdm_rx" protect="rw">
        <comment>OFDM中断标志位寄存器</comment>
        <bits access="rc" name="rx_ofdm_int_14" pos="14" rst="0x0">
          <comment>0：下行OFDM符号14中断未产生
1：下行OFDM符号14中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_13" pos="13" rst="0x0">
          <comment>0：下行OFDM符号13中断未产生
1：下行OFDM符号13中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_12" pos="12" rst="0x0">
          <comment>0：下行OFDM符号12中断未产生
1：下行OFDM符号12中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_11" pos="11" rst="0x0">
          <comment>0：下行OFDM符号11中断未产生
1：下行OFDM符号11中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_10" pos="10" rst="0x0">
          <comment>0：下行OFDM符号10中断未产生
1：下行OFDM符号10中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_9" pos="9" rst="0x0">
          <comment>0：下行OFDM符号9中断未产生
1：下行OFDM符号9中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_8" pos="8" rst="0x0">
          <comment>0：下行OFDM符号8中断未产生
1：下行OFDM符号8中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_7" pos="7" rst="0x0">
          <comment>0：下行OFDM符号7中断未产生
1：下行OFDM符号7中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_6" pos="6" rst="0x0">
          <comment>0：下行OFDM符号6中断未产生
1：下行OFDM符号6中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_5" pos="5" rst="0x0">
          <comment>0：下行OFDM符号5中断未产生
1：下行OFDM符号5中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_4" pos="4" rst="0x0">
          <comment>0：下行OFDM符号4中断未产生
1：下行OFDM符号4中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_3" pos="3" rst="0x0">
          <comment>0：下行OFDM符号3中断未产生
1：下行OFDM符号3中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_2" pos="2" rst="0x0">
          <comment>0：下行OFDM符号2中断未产生
1：下行OFDM符号2中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_1" pos="1" rst="0x0">
          <comment>0：下行OFDM符号1中断未产生
1：下行OFDM符号1中断产生</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_0" pos="0" rst="0x0">
          <comment>0：下行OFDM符号0中断未产生
1：下行OFDM符号0中断产生</comment>
        </bits>
      </reg>
      <reg name="int_mask_ofdm_rx" protect="rw">
        <comment>接收符号中断使能寄存器</comment>
        <bits access="rw" name="rx_inten" pos="16" rst="0x0">
          <comment>符号级中断使能信号（此比特为1时，符号级中断使能有效；反之，符号级中断使能无效）：
0：中断不使能
1：中断使能</comment>
        </bits>
        <bits access="rw" name="rx_last_int_en" pos="15" rst="0x0">
          <comment>0：最后一个OFDM符号中断不使能
1：最后一个OFDM符号中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en14" pos="14" rst="0x0">
          <comment>0：OFDM符号14中断不使能
1：OFDM符号14中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en13" pos="13" rst="0x0">
          <comment>0：OFDM符号13中断不使能
1：OFDM符号13中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en12" pos="12" rst="0x0">
          <comment>0：OFDM符号12中断不使能
1：OFDM符号12中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en11" pos="11" rst="0x0">
          <comment>0：OFDM符号11中断不使能
1：OFDM符号11中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en10" pos="10" rst="0x0">
          <comment>0：OFDM符号10中断不使能
1：OFDM符号10中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en9" pos="9" rst="0x0">
          <comment>0：OFDM符号9中断不使能
1：OFDM符号9中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en8" pos="8" rst="0x0">
          <comment>0：OFDM符号8中断不使能
1：OFDM符号8中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en7" pos="7" rst="0x0">
          <comment>0：OFDM符号7中断不使能
1：OFDM符号7中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en6" pos="6" rst="0x0">
          <comment>0：OFDM符号6中断不使能
1：OFDM符号6中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en5" pos="5" rst="0x0">
          <comment>0：OFDM符号5中断不使能
1：OFDM符号5中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en4" pos="4" rst="0x0">
          <comment>0：OFDM符号4中断不使能
1：OFDM符号4中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en3" pos="3" rst="0x0">
          <comment>0：OFDM符号3中断不使能
1：OFDM符号3中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en2" pos="2" rst="0x0">
          <comment>0：OFDM符号2中断不使能
1：OFDM符号2中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en1" pos="1" rst="0x0">
          <comment>0：OFDM符号1中断不使能
1：OFDM符号1中断使能</comment>
        </bits>
        <bits access="rw" name="rx_int_en0" pos="0" rst="0x0">
          <comment>0：OFDM符号0中断不使能
1：OFDM符号0中断使能</comment>
        </bits>
      </reg>
      <reg name="sys_cfg" protect="rw">
        <comment>系统级配置寄存器</comment>
        <bits access="rw" name="rx_dcoc_sel" pos="5" rst="0x0">
          <comment>接收DCOC值基准选择
1：软件配置基准值
0：按符号计算基准值</comment>
        </bits>
        <bits access="rw" name="rx_ovt" pos="4" rst="0x0">
          <comment>0：接收数据最高比特不翻转
1：接收数据最高比特翻转</comment>
        </bits>
        <bits access="rw" name="tx_ovt" pos="3" rst="0x0">
          <comment>0：发送数据最高比特不翻转
1：发送数据最高比特翻转</comment>
        </bits>
        <bits access="rw" name="tx_dfe_en" pos="2" rst="0x0">
          <comment>DFE模式使能信号
0：非DFE模式
1：DFE模式</comment>
        </bits>
        <bits access="rw" name="tx_nb_en" pos="1" rst="0x0">
          <comment>窄带模式使能信号
0：非窄带模式
1：窄带模式</comment>
        </bits>
        <bits access="rw" name="cat1_en" pos="0" rst="0x0">
          <comment>CAT1模式使能信号
0：非CAT1模式
1：CAT1模式</comment>
        </bits>
      </reg>
      <reg name="stop_cfg" protect="rw">
        <comment>立即停止配置寄存器</comment>
        <bits access="rw" name="tx_stop_en" pos="1" rst="0x0">
          <comment>上行立即停止功能
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rx_stop_en" pos="0" rst="0x0">
          <comment>下行立即停止功能
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="rx_cfg" protect="rw">
        <comment>接收全局配置寄存器</comment>
        <bits access="rw" name="rx_soft_afc_en" pos="31" rst="0x0">
          <comment>SOFT AFC 功能使能
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rx_rssi_cfg" pos="30" rst="0x0">
          <comment>RSSI计算窗长
1：半个符号的data段
0：一个符号的data段</comment>
        </bits>
        <bits access="rw" name="rssi_save_sel" pos="27:25" rst="0x0">
          <comment>RSSI 值存储位置选择
0: 存储在RSSI_MAX1
1: 存储在RSSI_MAX2
2: 存储在RSSI_MAX3
3: 存储在RSSI_MAX4
4: 存储在RSSI_MAX5
Other:不可配置</comment>
        </bits>
        <bits access="rw" name="rx_hf_fir_en" pos="23" rst="0x0">
          <comment>半带滤波计算使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="rx_otdoa_en" pos="22" rst="0x0">
          <comment>OTDOA通路使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="offset_ctrl_flag" pos="21" rst="0x0">
          <comment>offset使用类型标识指示
1：RX使用offset值进行cp长度调整，并传值给相关模块；
0：使用offset余数值传给相关模块；</comment>
        </bits>
        <bits access="rw" name="rx_iddet_en" pos="19" rst="0x0">
          <comment>1：IDDET通路使能
0：IDDET通路不使能</comment>
        </bits>
        <bits access="rw" name="rx_dlfft_en" pos="18" rst="0x0">
          <comment>与DLFFT交互机制使能控制（下行 DATA_DRIVE机制）
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rx_cp_type" pos="17:16" rst="0x0">
          <comment>00：普通CP
01：扩展CP
10：无CP（仅用于IDDET场景）</comment>
        </bits>
        <bits access="rw" name="hf_fir_bitsel" pos="11:8" rst="0x0">
          <comment>半带FIR乘累加后比特选择：
4’h0：33-22
4’h1：32-21
4’h2：31-20
4’h3：30-19
4’h4：29-18
4’h5：28-17
4’h6：27-16
4’h7：26-15
4’h8：25-14
4’h9：24-13
4’ha：23-12
4’hb：22-11
4’hc：21-10
4’hd：20-9
4’he：19-8
4’hf：18-7</comment>
        </bits>
        <bits access="rw" name="rx_trace_en" pos="7" rst="0x0">
          <comment>接收TRACE功能使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="offset_zero_flag" pos="6" rst="0x0">
          <comment>余数传0标识（measpwr/dlfft offset）：
1：传0；
0：根据offset和offset_ctrl_flag，传余数</comment>
        </bits>
        <bits access="rw" name="rx_meas_en" pos="5" rst="0x0">
          <comment>测量任务使能控制
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rx_norm_en" pos="4" rst="0x0">
          <comment>接收通路归一化计算使能
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rx_ave_en" pos="3" rst="0x0">
          <comment>接收均值计算使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rx_sat_en" pos="2" rst="0x0">
          <comment>接收通路数据统计使能
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rx_rssi_en" pos="1" rst="0x0">
          <comment>RSSI计算使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="glb_rxen" pos="0" rst="0x0">
          <comment>全局接收通路使能
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="rx_1st_ofdm_len_offset" protect="rw">
        <comment>接收首个OFDM符号长度修正值</comment>
        <bits access="rw" name="rx_ist_ofdm_len_offset" pos="9:0" rst="0x0">
          <comment>接收首个OFDM符号长度修正值</comment>
        </bits>
      </reg>
      <reg name="rx_afc_factor" protect="rw">
        <comment>SOFT AFC调整因子寄存器</comment>
        <bits access="rw" name="rx_afc_update" pos="16" rst="0x0">
          <comment>AFC软件频偏调整使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="rx_afc_factor" pos="15:0" rst="0x0">
          <comment>AFC软件频偏调整因子
（因子有正负，步长10hz，）</comment>
        </bits>
      </reg>
      <reg name="rx_rssi_max_cfg" protect="rw">
        <comment>RSSI MAX参数寄存器</comment>
        <bits access="rw" name="next_en" pos="5" rst="0x0">
          <comment>下一次接收的标志
1：下次接收标志使能
0：下次接收标志不使能
（硬件在AD_ON上升沿清0）</comment>
        </bits>
        <bits access="rw" name="rssi_max_clear" pos="4" rst="0x0">
          <comment>RSSI最大值清除标志（硬件立即清0）
1：清除标志使能
0：清除标志不使能</comment>
        </bits>
        <bits access="rw" name="rssi_max_start" pos="3:0" rst="0x0">
          <comment>计算RSSI最大值的起点符号号码</comment>
        </bits>
      </reg>
      <reg name="rx_norm_cfg" protect="rw">
        <comment>接收归一化配置寄存器</comment>
        <bits access="rw" name="rx_norm_cfg" pos="2:0" rst="0x1">
          <comment>指示当前接收使用第几个最大值来进行归一化操作
配置范围1~5</comment>
        </bits>
      </reg>
      <reg name="rx_sat_val" protect="rw">
        <comment>接收饱和数值寄存器</comment>
        <bits access="rw" name="sat_val_max" pos="27:16" rst="0x0">
          <comment>饱和数最大值
当比较点的值大于等于该值时，被判定为饱和数</comment>
        </bits>
        <bits access="rw" name="sat_val_min" pos="11:0" rst="0x0">
          <comment>饱和数最小值
当比较点的值小于等于该值时，被判定为饱和数</comment>
        </bits>
      </reg>
      <reg name="rx_pre_cfg" protect="rw">
        <comment>接收PRE功能配置寄存器</comment>
        <bits access="rw" name="rx_freq_factor" pos="22:12" rst="0x0">
          <comment>接收序列点乘参数</comment>
        </bits>
        <bits access="rw" name="rx_bw_sel" pos="10:8" rst="0x0">
          <comment>接收系统带宽
3’h5: 20M       (对应降采样率1/16)
3’h4: 15M       (对应降采样率1/16)
3’h3: 10M       (对应降采样率1/8)
3’h2: 5M        (对应降采样率1/4)
3’h1: 3M        (对应降采样率1/2)
3’h0: 1.4M
Other:不可配置</comment>
        </bits>
        <bits access="rw" name="freq_en" pos="7" rst="0x0">
          <comment>接收点乘计算使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="fir_en" pos="6" rst="0x0">
          <comment>FIR滤波使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="rx_bitsel" pos="4:0" rst="0x8">
          <comment>接收FIR乘累加后比特选择：
5’b00000：34-23
5’b00001：33-22
5’b00010：32-21
5’b00011：31-20
5’b00100：30-19
5’b00101：29-18
5’b00110：28-17
5’b00111：27-16
5’b01000：26-15
5’b01001：25-14
5’b01010：24-13
5’b01011：23-12
5’b01100：22-11
5’b01101：21-10
5’b01110：20-9
5’b01111：19-8
5’b10000：18-7
5’b10001：17-6
5’b10010：16-5
Other：不能配置</comment>
        </bits>
      </reg>
      <reg name="rx_aux_cfg" protect="rw">
        <comment>接收辅助控制寄存器</comment>
      </reg>
      <reg name="rx_phy_factor" protect="rw">
        <comment>接收软件配置因子寄存器</comment>
      </reg>
      <reg name="rx_dc_cfg" protect="rw">
        <comment>接收直流值配置寄存器</comment>
        <bits access="rw" name="rx_dc_update" pos="31" rst="0x0">
          <comment>DCOC值更新使能
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rx_dc_i" pos="27:16" rst="0x0">
          <comment>接收直流值I</comment>
        </bits>
        <bits access="rw" name="rx_dc_q" pos="11:0" rst="0x0">
          <comment>接收直流值Q</comment>
        </bits>
      </reg>
      <reg name="rx_gain1_cfg" protect="rw">
        <comment>接收增益1配置寄存器</comment>
        <bits access="rw" name="rx_gain1_en" pos="16" rst="0x0">
          <comment>GAIN1使能
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rx_gain1" pos="9:0" rst="0x0">
          <comment>接收GAIN1值</comment>
        </bits>
      </reg>
      <reg name="rx_gain2_cfg" protect="rw">
        <comment>接收增益2配置寄存器</comment>
        <bits access="rw" name="rx_gain2_en" pos="16" rst="0x0">
          <comment>GAIN2使能
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rx_gain2" pos="9:0" rst="0x0">
          <comment>接收GAIN2值</comment>
        </bits>
      </reg>
      <reg name="rx_out_cfg" protect="rw">
        <comment>接收数据输出配置寄存器</comment>
        <bits access="rw" name="iddet_dat_start" pos="21:20" rst="0x3">
          <comment>IDDET数据截位起点
2’h0:bit7
2'h1:bit8
2‘h2:bit9
2'h3:bit10</comment>
        </bits>
        <bits access="rw" name="iddet_dat_fin" pos="18:16" rst="0x0">
          <comment>IDDET数据截位终点
3’h0:bit0
3'h1:bit1
3‘h2:bit2
3'h3:bit3
3’h4:bit4
other:reserved</comment>
        </bits>
        <bits access="rw" name="otdoa_dat_start" pos="13:12" rst="0x3">
          <comment>OTDOA数据截位起点
2’h0:bit7
2'h1:bit8
2‘h2:bit9
2'h3:bit10</comment>
        </bits>
        <bits access="rw" name="otdoa_dat_fin" pos="10:8" rst="0x0">
          <comment>OTDOA数据截位终点
3’h0:bit0
3'h1:bit1
3‘h2:bit2
3'h3:bit3
3’h4:bit4
other:reserved</comment>
        </bits>
        <bits access="rw" name="meas_dat_start" pos="5:4" rst="0x3">
          <comment>MEASPWR数据截位起点
2’h0:bit7
2'h1:bit8
2‘h2:bit9
2'h3:bit10</comment>
        </bits>
        <bits access="rw" name="meas_dat_fin" pos="2:0" rst="0x0">
          <comment>MEASPWR数据截位终点
3’h0:bit0
3'h1:bit1
3‘h2:bit2
3'h3:bit3
3’h4:bit4
other:reserved</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="tx_cfg" protect="rw">
        <comment>发送全局配置寄存器</comment>
        <bits access="rw" name="tx_loop" pos="4" rst="0x0">
          <comment>发送回环使能（调试使用）
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="tx_data_drive" pos="3" rst="0x0">
          <comment>上行DATA_DRIVE机制
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="tx_cp_type" pos="2" rst="0x0">
          <comment>1：扩展CP
0：普通CP</comment>
        </bits>
        <bits access="rw" name="glb_txen" pos="0" rst="0x0">
          <comment>发送通路使能
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="tx_1st_ofdm_len_offset" protect="rw">
        <comment>发送首个OFDM符号长度修正值</comment>
        <bits access="rw" name="tx_1st_ofdm_len_offset" pos="6:0" rst="0x0">
          <comment>发送首个OFDM符号长度修正值配置(-32~31个点)</comment>
        </bits>
      </reg>
      <reg name="tx_ofdm0_len" protect="rw">
        <comment>发送PING数据和CP长度寄存器</comment>
        <bits access="rw" name="tx_ofdm0_len" pos="11:0" rst="0x89">
          <comment>发送PING数据和CP长度（长度从0开始）</comment>
        </bits>
      </reg>
      <reg name="tx_ofdm1_len" protect="rw">
        <comment>发送PANG数据和CP长度寄存器</comment>
        <bits access="rw" name="tx_ofdm1_len" pos="11:0" rst="0x88">
          <comment>发送PANG数据和CP长度（长度从0开始）</comment>
        </bits>
      </reg>
      <reg name="tx_post_cfg" protect="rw">
        <comment>发送POST功能配置寄存器</comment>
        <bits access="r" name="prach_en" pos="23" rst="0x0">
          <comment>PRACH使能控制
1：使能
0：不使能
（来自DFT模块，子帧级更新，软件只读）</comment>
        </bits>
        <bits access="r" name="prach_format" pos="22:20" rst="0x0">
          <comment>PRACH 格式控制
3‘hx：格式x（x为0~4）
（来自DFT模块，子帧级更新，软件只读）</comment>
        </bits>
        <bits access="r" name="tx_nb_start" pos="18:12" rst="0x0">
          <comment>发送序列点乘参数：NB在系统带宽中的起始值
（来自DFT模块，子帧级更新，软件只读）</comment>
        </bits>
        <bits access="r" name="tx_fir_en" pos="11" rst="0x0">
          <comment>发送滤波使能；
1：使能
0：不使能
（来自DFT模块，子帧级更新，软件只读）</comment>
        </bits>
        <bits access="rw" name="tx_bw_sel" pos="10:8" rst="0x0">
          <comment>发送带宽
3’h5: 20M       (对应升采样率16)
3’h4: 15M       (对应升采样率16)
3’h3: 10M       (对应升采样率8)
3’h2: 5M        (对应升采样率4)
3’h1: 3M        (对应升采样率2)
3’h0: 1.4M
Other:不可配置</comment>
        </bits>
        <bits access="rw" name="tx_freq_en" pos="7" rst="0x0">
          <comment>发送频偏点乘使能：
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="tx_bitsel" pos="4:0" rst="0x8">
          <comment>发送FIR乘累加后比特选择：
5’b00000：34-23
5’b00001：33-22
5’b00010：32-21
5’b00011：31-20
5’b00100：30-19
5’b00101：29-18
5’b00110：28-17
5’b00111：27-16
5’b01000：26-15
5’b01001：25-14
5’b01010：24-13
5’b01011：23-12
5’b01100：22-11
5’b01101：21-10
5’b01110：20-9
5’b01111：19-8
5’b10000：18-7
5’b10001：17-6
5’b10010：16-5
Other：不能配置</comment>
        </bits>
      </reg>
      <reg name="tx_fill0_num" protect="rw">
        <comment>发送冗余数据数量寄存器</comment>
        <bits access="rw" name="tx_fill0_num" pos="7:0" rst="0x0">
          <comment>发送冗余数据0个数
8’hff : 255个
8’hfe: 254个
…………
8’h01: 1个
8’h00: 0个（不发送冗余数据）</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="rx_phy_factor_cur" protect="rw">
        <comment>接收软件配置因子当前值寄存器</comment>
      </reg>
      <reg name="rx_sat_cnt" protect="rw">
        <comment>接收饱和数据统计寄存器</comment>
      </reg>
      <reg name="rx_norm_data" protect="rw">
        <comment>接收归一化因子寄存器</comment>
        <bits access="r" name="rx_norm_data" pos="3:0" rst="0x0">
          <comment>接收归一化因子寄存器</comment>
        </bits>
      </reg>
      <reg name="rssi_max1" protect="rw">
        <comment>RSSI 最大值寄存器1</comment>
      </reg>
      <reg name="rssi_max2" protect="rw">
        <comment>RSSI 最大值寄存器2</comment>
      </reg>
      <reg name="rssi_max3" protect="rw">
        <comment>RSSI 最大值寄存器3</comment>
      </reg>
      <reg name="rssi_max4" protect="rw">
        <comment>RSSI 最大值寄存器4</comment>
      </reg>
      <reg name="rssi_max5" protect="rw">
        <comment>RSSI 最大值寄存器5</comment>
      </reg>
      <reg name="rx_dc_cal_value" protect="rw">
        <comment>接收直流计算输出值寄存器</comment>
        <bits access="r" name="rx_dc_cal_value_i" pos="31:16" rst="0x0">
          <comment>接收直流计算输出值I</comment>
        </bits>
        <bits access="r" name="rx_dc_cal_value_q" pos="15:0" rst="0x0">
          <comment>接收直流计算输出值Q</comment>
        </bits>
      </reg>
      <hole size="224"/>
      <reg name="rx_ofdm_stat" protect="rw">
        <comment>接收OFDM符号指示寄存器</comment>
        <bits access="r" name="rx_mem_addr" pos="27:16" rst="0x0">
          <comment>当前RX_MEM的写地址</comment>
        </bits>
        <bits access="r" name="ad_on" pos="13" rst="0x0">
          <comment>AD_ON驱动控制信号</comment>
        </bits>
        <bits access="r" name="rx_running" pos="12" rst="0x0">
          <comment>接收运行指示信号
0：运行中
1：未运行</comment>
        </bits>
        <bits access="r" name="rx_dlfft_en" pos="11" rst="0x0">
          <comment>DLFFT功能使能信号</comment>
        </bits>
        <bits access="r" name="rx_otdoa_en" pos="10" rst="0x0">
          <comment>OTDOA功能使能信号</comment>
        </bits>
        <bits access="r" name="rx_iddet_en" pos="9" rst="0x0">
          <comment>IDDET功能使能信号</comment>
        </bits>
        <bits access="r" name="rx_meas_en" pos="8" rst="0x0">
          <comment>MEAS功能使能信号</comment>
        </bits>
        <bits access="r" name="cp_err" pos="7" rst="0x0">
          <comment>一次接收过程中CP类型修改
0：无修改
1：有修改</comment>
        </bits>
        <bits access="r" name="rx_no_data_err" pos="6" rst="0x0">
          <comment>无接收数据异常指示
0：无异常
1：有异常</comment>
        </bits>
        <bits access="r" name="ping_pang_stat" pos="4" rst="0x0">
          <comment>接收的PING_PANG状态指示</comment>
        </bits>
        <bits access="r" name="rx_ofdm_stat" pos="3:0" rst="0x0">
          <comment>指示当前接收的是第几个OFDM符号</comment>
        </bits>
      </reg>
      <reg name="tx_fifo_stat" protect="rw">
        <comment>发送FIFO位置寄存器</comment>
        <bits access="r" name="tx_mem_addr" pos="27:16" rst="0x0">
          <comment>当前TX_MEM的读地址</comment>
        </bits>
        <bits access="r" name="da_on" pos="13" rst="0x0">
          <comment>DA_ON驱动控制信号</comment>
        </bits>
        <bits access="r" name="tx_running" pos="12" rst="0x0">
          <comment>接收运行指示信号
0：未运行
1：运行中</comment>
        </bits>
        <bits access="r" name="tx_fifo_stat" pos="4" rst="0x0">
          <comment>发送FIFO位置寄存器
0：在ping存储器
1：在pang存储器</comment>
        </bits>
        <bits access="r" name="tx_ofdm_stat" pos="3:0" rst="0x0">
          <comment>指示当前发送的是第几个OFDM符号</comment>
        </bits>
      </reg>
      <reg name="rx_err_stat" protect="rw">
        <comment>接收错误时刻状态寄存器</comment>
        <bits access="r" name="frame_num" pos="31:28" rst="0x0">
          <comment>帧号（子帧）</comment>
        </bits>
        <bits access="r" name="ts_cnt" pos="27:12" rst="0x0">
          <comment>子帧内的TS计数值</comment>
        </bits>
        <bits access="r" name="ofdm_num_rx" pos="11:8" rst="0x0">
          <comment>符号计数</comment>
        </bits>
        <bits access="r" name="ad_on" pos="5" rst="0x0">
          <comment>AD_ON驱动控制信号</comment>
        </bits>
        <bits access="r" name="rx_running" pos="4" rst="0x0">
          <comment>接收运行指示信号0：未运行1：运行中</comment>
        </bits>
        <bits access="r" name="dlfft_mem_sel" pos="3" rst="0x0">
          <comment>输入的mem选择信号</comment>
        </bits>
        <bits access="r" name="pingpang_flag" pos="2" rst="0x0">
          <comment>输出的乒乓信号</comment>
        </bits>
        <bits access="r" name="cp_type_rx" pos="1:0" rst="0x0">
          <comment>CP 类型</comment>
        </bits>
      </reg>
      <reg name="tx_err_stat" protect="rw">
        <comment>发送错误时刻状态寄存器</comment>
        <bits access="r" name="frame_num" pos="31:28" rst="0x0">
          <comment>帧号（子帧）</comment>
        </bits>
        <bits access="r" name="ts_cnt" pos="27:12" rst="0x0">
          <comment>子帧内的TS计数值</comment>
        </bits>
        <bits access="r" name="ofdm_num_tx" pos="11:8" rst="0x0">
          <comment>符号计数</comment>
        </bits>
        <bits access="r" name="da_on" pos="6" rst="0x0">
          <comment>DA_ON驱动控制信号</comment>
        </bits>
        <bits access="r" name="tx_running" pos="5" rst="0x0">
          <comment>接收运行指示信号
0：未运行
1：运行中</comment>
        </bits>
        <bits access="r" name="ram_pi_sel" pos="4" rst="0x0">
          <comment>PING RAM选择信号</comment>
        </bits>
        <bits access="r" name="dft_wr_pi_err" pos="3" rst="0x0">
          <comment>DFT写PING错误信号</comment>
        </bits>
        <bits access="r" name="dft_wr_pa_err" pos="2" rst="0x0">
          <comment>DFT写PANG错误信号</comment>
        </bits>
        <bits access="r" name="pi_empty_err" pos="1" rst="0x0">
          <comment>PING读取时空错误信号</comment>
        </bits>
        <bits access="r" name="pa_empty_err" pos="0" rst="0x0">
          <comment>PANG读取时空错误信号</comment>
        </bits>
      </reg>
      <reg name="st_cnt_framc" protect="rw">
        <comment>RF子帧FRAMC锁存值寄存器</comment>
        <bits access="r" name="adon_pos_framc" pos="31:16" rst="0x0">
          <comment>ADON上升沿时的FRAMC值</comment>
        </bits>
        <bits access="r" name="rf_1st_int_framc" pos="15:0" rst="0x0">
          <comment>第一个接收子帧中断时的FRAMC值</comment>
        </bits>
      </reg>
      <reg name="st_cnt_ add" protect="rw">
        <comment>RF子帧FRAMC偏差寄存器</comment>
        <bits access="r" name="rf_int_num" pos="31:16" rst="0x0">
          <comment>本次接收的子帧中断个数</comment>
        </bits>
        <bits access="r" name="rf_int_sub_add" pos="15:0" rst="0x0">
          <comment>当前的子帧中断和首次子帧中断的FRAMC差值</comment>
        </bits>
      </reg>
      <reg name="ad_on_time" protect="rw">
        <comment>AD_ON变化时间寄存器</comment>
        <bits access="r" name="ad_on_neg_time1" pos="31:24" rst="0x0">
          <comment>奇数次AD_ON下降沿时间</comment>
        </bits>
        <bits access="r" name="ad_on_pos_time1" pos="23:16" rst="0x0">
          <comment>奇数次AD_ON上升沿时间</comment>
        </bits>
        <bits access="r" name="ad_on_neg_time0" pos="15:8" rst="0x0">
          <comment>偶数次AD_ON下降沿时间</comment>
        </bits>
        <bits access="r" name="ad_on_pos_time0" pos="7:0" rst="0x0">
          <comment>偶数次AD_ON上升沿时间</comment>
        </bits>
      </reg>
      <reg name="da_on_time" protect="rw">
        <comment>DA_ON变化时间寄存器</comment>
        <bits access="r" name="da_on_neg_time1" pos="31:24" rst="0x0">
          <comment>奇数次DA_ON下降沿时间</comment>
        </bits>
        <bits access="r" name="da_on_pos_time1" pos="23:16" rst="0x0">
          <comment>奇数次DA_ON上升沿时间</comment>
        </bits>
        <bits access="r" name="da_on_neg_time0" pos="15:8" rst="0x0">
          <comment>偶数次DA_ON下降沿时间</comment>
        </bits>
        <bits access="r" name="da_on_pos_time0" pos="7:0" rst="0x0">
          <comment>偶数次DA_ON上升沿时间</comment>
        </bits>
      </reg>
      <reg name="fftbuf1_time" protect="rw">
        <comment>FFTBUF1中断时间寄存器</comment>
        <bits access="r" name="fftbuf1_time4" pos="31:24" rst="0x0">
          <comment>第4次FFTBUF1中断时间</comment>
        </bits>
        <bits access="r" name="fftbuf1_time3" pos="23:16" rst="0x0">
          <comment>第3次FFTBUF1中断时间</comment>
        </bits>
        <bits access="r" name="fftbuf1_time2" pos="15:8" rst="0x0">
          <comment>第2次FFTBUF1中断时间</comment>
        </bits>
        <bits access="r" name="fftbuf1_time1" pos="7:0" rst="0x0">
          <comment>第1次FFTBUF1中断时间</comment>
        </bits>
      </reg>
      <reg name="fftbuf2_time" protect="rw">
        <comment>FFTBUF2中断时间寄存器</comment>
        <bits access="r" name="fftbuf2_time4" pos="31:24" rst="0x0">
          <comment>第4次FFTBUF2中断时间</comment>
        </bits>
        <bits access="r" name="fftbuf2_time3" pos="23:16" rst="0x0">
          <comment>第3次FFTBUF2中断时间</comment>
        </bits>
        <bits access="r" name="fftbuf2_time2" pos="15:8" rst="0x0">
          <comment>第2次FFTBUF2中断时间</comment>
        </bits>
        <bits access="r" name="fftbuf2_time1" pos="7:0" rst="0x0">
          <comment>第1次FFTBUF2中断时间</comment>
        </bits>
      </reg>
      <reg name="fft2ldtc_time" protect="rw">
        <comment>FFT2LDTC中断时间寄存器</comment>
        <bits access="r" name="fft2ldtc_time4" pos="31:24" rst="0x0">
          <comment>第4次FFT2LDTC中断时间</comment>
        </bits>
        <bits access="r" name="fft2ldtc_time3" pos="23:16" rst="0x0">
          <comment>第3次FFT2LDTC中断时间</comment>
        </bits>
        <bits access="r" name="fft2ldtc_time2" pos="15:8" rst="0x0">
          <comment>第2次FFT2LDTC中断时间</comment>
        </bits>
        <bits access="r" name="fft2ldtc_time1" pos="7:0" rst="0x0">
          <comment>第1次FFT2LDTC中断时间</comment>
        </bits>
      </reg>
      <reg name="tx_fir3_coe1_cfg" protect="rw">
        <comment>TX FIR3 系数配置寄存器</comment>
        <bits access="rw" name="tx_fir_coe_a21" pos="31:24" rst="0x0">
          <comment>滤波器A2系数值低8bit</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a1" pos="23:12" rst="0x0">
          <comment>滤波器A1系数值</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a0" pos="11:0" rst="0x0">
          <comment>滤波器A0系数值</comment>
        </bits>
      </reg>
      <reg name="tx_fir3_coe2_cfg" protect="rw">
        <comment>TX FIR3 系数配置寄存器</comment>
        <bits access="rw" name="tx_fir_coe_a51" pos="31:28" rst="0x0">
          <comment>滤波器A5系数值低4bit</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a4" pos="27:16" rst="0x0">
          <comment>滤波器A4系数值</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a3" pos="15:4" rst="0x0">
          <comment>滤波器A3系数值</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a22" pos="3:0" rst="0x0">
          <comment>滤波器A2高4bit系数值</comment>
        </bits>
      </reg>
      <reg name="tx_fir3_coe3_cfg" protect="rw">
        <comment>TX FIR3 系数配置寄存器</comment>
        <bits access="rw" name="tx_fir_coe_a7" pos="31:20" rst="0x0">
          <comment>滤波器A7系数值</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a6" pos="19:8" rst="0x0">
          <comment>滤波器A6系数值</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a52" pos="7:0" rst="0x0">
          <comment>滤波器A5高8bit系数值</comment>
        </bits>
      </reg>
      <reg name="tx_fir3_cfg" protect="rw">
        <comment>TX FIR3 配置寄存器</comment>
        <bits access="rw" name="reg_samp_rate" pos="12:7" rst="0x0">
          <comment>FIR3滤波器相关系数</comment>
        </bits>
        <bits access="rw" name="reg_grp_delay" pos="6:2" rst="0x0">
          <comment>FIR3滤波器相关系数</comment>
        </bits>
        <bits access="rw" name="autock_en" pos="1" rst="0x0">
          <comment>滤波器时钟使能位</comment>
        </bits>
        <bits access="rw" name="fir3_en" pos="0" rst="0x0">
          <comment>滤波器使能位</comment>
        </bits>
      </reg>
      <reg name="tx_vld_cnt_cfg" protect="rw">
        <comment>TX FIR3 配置寄存器</comment>
        <bits access="rw" name="tx_vld_cnt" pos="2:0" rst="0x0">
          <comment>数据有效信号计数</comment>
        </bits>
      </reg>
      <hole size="751616"/>
      <reg name="mem5" protect="rw">
        </reg>
      <hole size="32768"/>
      <reg name="mem3" protect="rw">
        <bits access="rw" name="mem3_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem3_2" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="mem4" protect="rw">
        <bits access="rw" name="mem4_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem4_2" pos="15:4" rst="0x0"/>
      </reg>
    </module>
    <instance address="0x18000000" name="TXRX" type="TXRX"/>
  </archive>
  <archive relative="measpwr.xml">
    <module category="System" name="MEASPWR">
      <reg name="measpwr_rxdata_ctrl1" protect="rw">
        <comment>MEASPWR的接收数据控制寄存器1</comment>
        <bits access="rw" name="fdd_tdd" pos="31" rst="0x1">
          <comment>FDD_TDD指示：
0：FDD
1：TDD</comment>
        </bits>
        <bits access="rw" name="rx_offset1" pos="18:0" rst="0x0">
          <comment>TXRX模块的AD_ON拉高接收数据的起点位置，
0~30720*10-1（10ms）(AD ON距离服务小区帧头的距离)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_ctrl2" protect="rw">
        <comment>MEASPWR的接收数据控制寄存器2</comment>
        <bits access="rw" name="rx_len" pos="15:0" rst="0x0">
          <comment>MEASPWR使用的有效数据的长度1~30720*6(6ms)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_val_ctrl" protect="rw">
        <comment>MEASPWR的有效数据控制寄存器</comment>
        <bits access="w" name="invalid_flag" pos="20" rst="0x0">
          <comment>Offset2无效指示
0：offset2配置有效
1：offset2配置无效</comment>
        </bits>
        <bits access="rw" name="rx_offset2" pos="17:0" rst="0x0">
          <comment>MEASPWR使用的有效数据的起点位置 （0~30720*6-1）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id1" protect="rw">
        <comment>MEASPWR的ID1时延控制寄存器</comment>
        <bits access="rw" name="rx_offset3_id1" pos="19:0" rst="0x0">
          <comment>ID1基于服务小区的同步偏差值 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id2" protect="rw">
        <comment>MEASPWR的ID2时延控制寄存器</comment>
        <bits access="rw" name="rx_offset3_id2" pos="19:0" rst="0x0">
          <comment>ID2基于服务小区的同步偏差值 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id3" protect="rw">
        <comment>MEASPWR的ID3时延控制寄存器</comment>
        <bits access="rw" name="rx_offset3_id3" pos="19:0" rst="0x0">
          <comment>s</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id4" protect="rw">
        <comment>MEASPWR的ID4时延控制寄存器</comment>
        <bits access="rw" name="rx_offset3_id4" pos="19:0" rst="0x0">
          <comment>ID4基于服务小区的同步偏差值 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id5" protect="rw">
        <comment>MEASPWR的ID5时延控制寄存器</comment>
        <bits access="rw" name="rx_offset3_id5" pos="19:0" rst="0x0">
          <comment>ID5基于服务小区的同步偏差值 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id6" protect="rw">
        <comment>MEASPWR的ID6时延控制寄存器</comment>
        <bits access="rw" name="rx_offset3_id6" pos="19:0" rst="0x0">
          <comment>ID6基于服务小区的同步偏差值 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id7" protect="rw">
        <comment>MEASPWR的ID7时延控制寄存器</comment>
        <bits access="rw" name="rx_offset3_id7" pos="19:0" rst="0x0">
          <comment>ID7基于服务小区的同步偏差值 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id8" protect="rw">
        <comment>MEASPWR的ID8时延控制寄存器</comment>
        <bits access="rw" name="rx_offset3_id8" pos="19:0" rst="0x0">
          <comment>ID8基于服务小区的同步偏差值 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_nb_offset4" protect="rw">
        <comment>MEASPWR NB OFSET4寄存器</comment>
        <bits access="rw" name="nb_offet4" pos="14:0" rst="0x0">
          <comment>Nb下offset4值</comment>
        </bits>
      </reg>
      <reg name="measpwr_total_subf" protect="rw">
        <comment>MEASPWR计算总子帧数寄存器</comment>
        <bits access="rw" name="total_subf_num_id3_8" pos="20:12" rst="0x0">
          <comment>所有ID3~ID8计算的总子帧个数
0：1
1：2
2：3
……
511:512</comment>
        </bits>
        <bits access="rw" name="total_subf_num_id1_2" pos="8:0" rst="0x0">
          <comment>所有ID1和ID2计算的总子帧个数
0：1
1：2
2：3
……
511:512</comment>
        </bits>
      </reg>
      <reg name="measpwr_ifft_para" protect="rw">
        <comment>IFFT截位因子配置寄存器</comment>
        <bits access="rw" name="ifft_cut7" pos="13:12" rst="0x0">
          <comment>IFFT第七级截位因子：
同下</comment>
        </bits>
        <bits access="rw" name="ifft_cut6" pos="11:10" rst="0x0">
          <comment>IFFT第六级截位因子：
同下</comment>
        </bits>
        <bits access="rw" name="ifft_cut5" pos="9:8" rst="0x0">
          <comment>IFFT第五级截位因子：
同下</comment>
        </bits>
        <bits access="rw" name="ifft_cut4" pos="7:6" rst="0x0">
          <comment>IFFT第四级截位因子：
同下</comment>
        </bits>
        <bits access="rw" name="ifft_cut3" pos="5:4" rst="0x0">
          <comment>IFFT第三级截位因子：
同下</comment>
        </bits>
        <bits access="rw" name="ifft_cut2" pos="3:2" rst="0x0">
          <comment>IFFT第二级截位因子：
同下</comment>
        </bits>
        <bits access="rw" name="ifft_cut1" pos="1:0" rst="0x0">
          <comment>IFFT第一级截位因子：
2’b00:截取bit[25:14]
2’b01:截取bit[26:15]
2’b10:截取bit[27:16]
2’b11:截取bit[28:17]</comment>
        </bits>
      </reg>
      <reg name="measpwr_ifft_gate" protect="rw">
        <comment>MEASPWR IFFT倒数第二级饱和门限个数值寄存器</comment>
        <bits access="rw" name="ifft_gate" pos="6:0" rst="0x0">
          <comment>IFFT倒数第二级饱和门限个数值</comment>
        </bits>
      </reg>
      <reg name="measpwr_int_en" protect="rw">
        <comment>MEASPWR中断使能寄存器</comment>
        <bits access="rw" name="id8_interrupt_enable" pos="31:28" rst="0x0">
          <comment>ID8 的中断使能，1有效，0无效
bit[28]：样本结束中断使能
bit[29]：门限值到达中断使能
bit[30]：AFC结果输出中断使能
bit[31]:agc_compare门限到达中断使能</comment>
        </bits>
        <bits access="rw" name="id7_interrupt_enable" pos="27:24" rst="0x0">
          <comment>ID7 的中断使能，1有效，0无效
bit[24]：样本结束中断使能
bit[25]：门限值到达中断使能
bit[26]：AFC结果输出中断使能
bit[27]:agc_compare门限到达中断使能</comment>
        </bits>
        <bits access="rw" name="id6_interrupt_enable" pos="23:20" rst="0x0">
          <comment>ID6 的中断使能，1有效，0无效
bit[20]：样本结束中断使能
bit[21]：门限值到达中断使能
bit[22]：AFC结果输出中断使能
bit[23]:agc_compare门限到达中断使能</comment>
        </bits>
        <bits access="rw" name="id5_interrupt_enable" pos="19:16" rst="0x0">
          <comment>ID5 的中断使能，1有效，0无效
bit[16]：样本结束中断使能
bit[17]：门限值到达中断使能
bit[18]：AFC结果输出中断使能
bit[19]:agc_compare门限到达中断使能</comment>
        </bits>
        <bits access="rw" name="id4_interrupt_enable" pos="15:12" rst="0x0">
          <comment>ID4 的中断使能，1有效，0无效
bit[12]：样本结束中断使能
bit[13]：门限值到达中断使能
bit[14]：AFC结果输出中断使能
bit[15]:agc_compare门限到达中断使能</comment>
        </bits>
        <bits access="rw" name="id3_interrupt_enable" pos="11:8" rst="0x0">
          <comment>ID3 的中断使能，1有效，0无效
bit[8]：样本结束中断使能
bit[9]：门限值到达中断使能
bit[10]：AFC结果输出中断使能
bit[11]:agc_compare门限到达中断使能</comment>
        </bits>
        <bits access="rw" name="id2_interrupt_enable" pos="7:4" rst="0x0">
          <comment>ID2 的中断使能，1有效，0无效
bit[4]：样本结束中断使能
bit[5]：门限值到达中断使能
bit[6]：AFC结果输出中断使能
bit[7]:agc_compare门限到达中断使能</comment>
        </bits>
        <bits access="rw" name="id1_interrupt_enable" pos="3:0" rst="0x0">
          <comment>ID1 的中断使能，1有效，0无效
bit[0]：样本结束中断使能
bit[1]：门限值到达中断使能
bit[2]：AFC结果输出中断使能
bit[3]:agc_compare门限到达中断使能</comment>
        </bits>
      </reg>
      <reg name="measpwr_int_sta" protect="rw">
        <comment>MEASPWR中断状态寄存器</comment>
        <bits access="rc" name="id8_interrupt_state" pos="31:28" rst="0x0">
          <comment>ID8 的中断状态，1有效，0无效
bit[28]：样本结束中断状态
bit[29]：门限值到达中断状态
bit[30]：AFC结果输出中断状态
bit[31]:agc_compare门限到达状态</comment>
        </bits>
        <bits access="rc" name="id7_interrupt_state" pos="27:24" rst="0x0">
          <comment>ID7 的中断状态，1有效，0无效
bit[24]：样本结束中断状态
bit[25]：门限值到达中断状态
bit[26]：AFC结果输出中断状态
bit[27]:agc_compare门限到达状态</comment>
        </bits>
        <bits access="rc" name="id6_interrupt_state" pos="23:20" rst="0x0">
          <comment>ID6 的中断状态，1有效，0无效
bit[20]：样本结束中断状态
bit[21]：门限值到达中断状态
bit[22]：AFC结果输出中断状态
bit[23]:agc_compare门限到达状态</comment>
        </bits>
        <bits access="rc" name="id5_interrupt_state" pos="19:16" rst="0x0">
          <comment>ID5 的中断状态，1有效，0无效
bit[16]：样本结束中断状态
bit[17]：门限值到达中断状态
bit[18]：AFC结果输出中断状态
bit[19]:agc_compare门限到达状态</comment>
        </bits>
        <bits access="rc" name="id4_interrupt_state" pos="15:12" rst="0x0">
          <comment>ID4 的中断状态，1有效，0无效
bit[12]：样本结束中断状态
bit[13]：门限值到达中断状态
bit[14]：AFC结果输出中断状态
bit[15]:agc_compare门限到达状态</comment>
        </bits>
        <bits access="rc" name="id3_interrupt_state" pos="11:8" rst="0x0">
          <comment>ID3 的中断状态，1有效，0无效
bit[8]：样本结束中断状态
bit[9]：门限值到达中断状态
bit[10]：AFC结果输出中断状态
bit[11]:agc_compare门限到达状态</comment>
        </bits>
        <bits access="rc" name="id2_interrupt_state" pos="7:4" rst="0x0">
          <comment>ID2 的中断状态，1有效，0无效
bit[4]：样本结束中断状态
bit[5]：门限值到达中断状态
bit[6]：AFC结果输出中断状态
bit[7]:agc_compare门限到达状态</comment>
        </bits>
        <bits access="rc" name="id1_interrupt_state" pos="3:0" rst="0x0">
          <comment>ID1 的中断状态，1有效，0无效
bit[0]：样本结束中断状态
bit[1]：门限值到达中断状态
bit[2]：AFC结果输出中断状态
bit[3]:agc_compare门限到达状态</comment>
        </bits>
      </reg>
      <reg name="measpwr_id1_id2_func_ctrl" protect="rw">
        <comment>ID1和ID2的MEASPWR功能控制寄存器</comment>
        <bits access="rw" name="id1_id2_trmsf_en" pos="8" rst="0x0">
          <comment>TRMS频域计算功能使能</comment>
        </bits>
        <bits access="rw" name="id1_id2_sigma_en" pos="7" rst="0x0">
          <comment>SIGMA功能使能</comment>
        </bits>
        <bits access="rw" name="id1_id2_doppler_en" pos="6" rst="0x0">
          <comment>DOPPLER功能使能</comment>
        </bits>
        <bits access="rw" name="id1_id2_sinr_en" pos="5" rst="0x0">
          <comment>SINR功能使能</comment>
        </bits>
        <bits access="rw" name="id1_id2_afc_com_en" pos="4" rst="0x0">
          <comment>AFC普通模式功能使能</comment>
        </bits>
        <bits access="rw" name="id1_id2_afc_hst_en" pos="3" rst="0x0">
          <comment>AFC高速模式使能</comment>
        </bits>
        <bits access="rw" name="id1_id2_trms_en" pos="2" rst="0x0">
          <comment>TRMS功能使能</comment>
        </bits>
        <bits access="rw" name="id1_id2_rsrp_en" pos="1" rst="0x0">
          <comment>RSRP功能使能</comment>
        </bits>
        <bits access="rw" name="id1_id2_irt_en" pos="0" rst="0x0">
          <comment>IRT功能使能</comment>
        </bits>
      </reg>
      <reg name="measpwr_id3_id8_func_ctrl" protect="rw">
        <comment>ID3~ID8的MEASPWR功能控制寄存器</comment>
        <bits access="rw" name="id3_id8_trmsf_en" pos="8" rst="0x0">
          <comment>TRMS频域计算功能使能</comment>
        </bits>
        <bits access="rw" name="id3_id8_sigma_en" pos="7" rst="0x0">
          <comment>SIGMA功能使能</comment>
        </bits>
        <bits access="rw" name="id3_id8_doppler_en" pos="6" rst="0x0">
          <comment>DOPPLER功能使能</comment>
        </bits>
        <bits access="rw" name="id3_id8_sinr_en" pos="5" rst="0x0">
          <comment>SINR功能使能</comment>
        </bits>
        <bits access="rw" name="id3_id8_afc_com_en" pos="4" rst="0x0">
          <comment>AFC普通模式功能使能</comment>
        </bits>
        <bits access="rw" name="id3_id8_afc_hst_en" pos="3" rst="0x0">
          <comment>AFC高速模式使能</comment>
        </bits>
        <bits access="rw" name="id3_id8_trms_en" pos="2" rst="0x0">
          <comment>TRMS功能使能</comment>
        </bits>
        <bits access="rw" name="id3_id8_rsrp_en" pos="1" rst="0x0">
          <comment>RSRP功能使能</comment>
        </bits>
        <bits access="rw" name="id3_id8_irt_en" pos="0" rst="0x0">
          <comment>IRT功能使能</comment>
        </bits>
      </reg>
      <reg name="measpwr_agc_compare" protect="rw">
        <comment>MEASPWR AGC差值门限值寄存器</comment>
        <bits access="rw" name="agc_compare" pos="9:0" rst="0x1ff">
          <comment>子帧间agc差值门限值，当前子帧agc比前一帧agc大于此值时，将清零前面的计算值，重新开始计算。（无符号数）</comment>
        </bits>
      </reg>
      <reg name="measpwr_nb_para" protect="rw">
        <comment>MEASPWR 窄带参数寄存器</comment>
        <bits access="rw" name="id38_nb_ind" pos="11:8" rst="0x0">
          <comment>ID3-8的窄带参数：0-15（只有CATM需要）</comment>
        </bits>
        <bits access="rw" name="id2_nb_ind" pos="7:4" rst="0x0">
          <comment>ID2的窄带参数：0-15（只有CATM需要）</comment>
        </bits>
        <bits access="rw" name="id1_nb_ind" pos="3:0" rst="0x0">
          <comment>ID1的窄带参数：0-15（只有CATM需要）</comment>
        </bits>
      </reg>
      <reg name="measpwr_band_para" protect="rw">
        <comment>MEASPWR ID2的带宽参数寄存器</comment>
        <bits access="rw" name="meas_bw_id38" pos="14:12" rst="0x0">
          <comment>ID3-8测量带宽参数
0：1.4m
1：3m
2：5m
3：10m
4：15m
5：20m</comment>
        </bits>
        <bits access="rw" name="sys_bw_id38" pos="10:8" rst="0x0">
          <comment>ID3-8系统带宽参数
0：1.4m
1：3m
2：5m
3：10m
4：15m
5：20m</comment>
        </bits>
        <bits access="rw" name="meas_bw_id12" pos="6:4" rst="0x0">
          <comment>ID1-2测量带宽参数
0：1.4m
1：3m
2：5m
3：10m
4：15m
5：20m</comment>
        </bits>
        <bits access="rw" name="sys_bw_id12" pos="2:0" rst="0x0">
          <comment>ID1-2系统带宽参数
0：1.4m
1：3m
2：5m
3：10m
4：15m
5：20m</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="measpwr_afc_para" protect="rw">
        <comment>AFC配置寄存器</comment>
        <bits access="rw" name="afc_factor" pos="23:8" rst="0x0">
          <comment>Afc_factor</comment>
        </bits>
        <bits access="rw" name="afc_related_flag" pos="4" rst="0x0">
          <comment>AFC计算子帧间连续标志
0：不连续
1：连续
连续表示子帧间数据关联进行共轭计算；不连续表示子帧内4个符号进行共轭计算，子帧间无关联。</comment>
        </bits>
        <bits access="rw" name="afc_renum" pos="2:0" rst="0x0">
          <comment>AFC计算频域相关个数
000：1
001：2
010：3
011：4
100：6：
101：12
Other:1</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect1" protect="rw">
        <comment>AFC软纠配置寄存器</comment>
        <bits access="rw" name="afc_soft_fa_ctor1" pos="15:0" rst="0x0">
          <comment>ID1 AFC软纠配置因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigpwr_para" protect="rw">
        <comment>Sigpwr配置寄存器</comment>
        <bits access="rw" name="sigpwr_alpha" pos="28:12" rst="0x0">
          <comment>SIGPWR alpha参数</comment>
        </bits>
        <bits access="rw" name="sigpwr_ofdmnum" pos="9:8" rst="0x0">
          <comment>SIGPWR计算时域相关个数
00：1
01：2
11：4
Other：1</comment>
        </bits>
        <bits access="rw" name="sigpwr_renum" pos="7:0" rst="0x0">
          <comment>ID1-2 SIGPWR计算频域相关个数(按实际数据个数配置）</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma_para" protect="rw">
        <comment>SIGMA配置寄存器</comment>
        <bits access="rw" name="sigma_alpha" pos="24:8" rst="0x0">
          <comment>SIGMA alpha参数</comment>
        </bits>
        <bits access="rw" name="sigma_win" pos="6:0" rst="0x0">
          <comment>SIGMA计算滑动窗长个数，有效取值为1~80</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler_para" protect="rw">
        <comment>DOPPLER配置寄存器</comment>
        <bits access="rw" name="doppler_alpha1" pos="29:13" rst="0x0">
          <comment>Id1-2 Doppler alpha参数</comment>
        </bits>
        <bits access="rw" name="doppler_scale" pos="11:8" rst="0x0">
          <comment>Doppler_scale（Q12的有符号数）</comment>
        </bits>
        <bits access="rw" name="doppler_win" pos="6:0" rst="0x0">
          <comment>DOPPLER计算滑动窗长个数，有效取值为1~80</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms_para1" protect="rw">
        <comment>TRMS配置寄存器1</comment>
        <bits access="rw" name="t_th" pos="23:16" rst="0x0">
          <comment>Trms选径门限（无符号的，8q0，正数）</comment>
        </bits>
        <bits access="rw" name="noise_sel" pos="12" rst="0x0">
          <comment>噪声区域选择
0：使用TRMS的Dis_Limit去计算噪声
1：使用RSRP的Dis_Limit去计算噪声</comment>
        </bits>
        <bits access="rw" name="d_flag2" pos="9" rst="0x0">
          <comment>ID3-8抽值标志:
0:连续抽取，相当于注1的L_U16ExtractStepTab_true间隔为1
1：按照注1的L_U16ExtractStepTab_true间隔进行抽取</comment>
        </bits>
        <bits access="rw" name="d_flag" pos="8" rst="0x0">
          <comment>ID1-2抽值标志:
0:连续抽取，相当于注1的L_U16ExtractStepTab_true间隔为1
1：按照注1的L_U16ExtractStepTab_true间隔进行抽取</comment>
        </bits>
        <bits access="rw" name="dis_limit" pos="7:0" rst="0x0">
          <comment>信号区域(单边长度，即半径N，信号区域为2N+1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms_para2" protect="rw">
        <comment>TRMS配置寄存器2</comment>
        <bits access="rw" name="s_th" pos="31:16" rst="0x0">
          <comment>ID1-2信号门限因子（有符号的，16q15，正数）</comment>
        </bits>
        <bits access="rw" name="n_th" pos="15:0" rst="0x0">
          <comment>ID1-2噪声门限因子（有符号的，16q10，正数）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp_para1" protect="rw">
        <comment>RSRP配置寄存器1</comment>
        <bits access="rw" name="d_flag2" pos="25" rst="0x1">
          <comment>ID3-8抽值标志</comment>
        </bits>
        <bits access="rw" name="d_flag" pos="24" rst="0x1">
          <comment>ID1-2抽值标志</comment>
        </bits>
        <bits access="rw" name="beta" pos="23:8" rst="0x0">
          <comment>ID1-2噪声门限因子beta值（有符号的16Q10，只能配置为正数）</comment>
        </bits>
        <bits access="rw" name="dis_limit" pos="7:0" rst="0x0">
          <comment>信号区域</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp_para2" protect="rw">
        <comment>RSRP配置寄存器2</comment>
        <bits access="rw" name="mode1_compensate2" pos="25:17" rst="0x0">
          <comment>ID3-8RSRP的补偿值</comment>
        </bits>
        <bits access="rw" name="mode1_compensate" pos="16:8" rst="0x0">
          <comment>ID1-2RSRP的补偿值</comment>
        </bits>
        <bits access="rw" name="rsrp_agcadjust" pos="7:0" rst="0x0">
          <comment>L_S32RsrpdB_Temp = L_S32RsrpdB  - AGC_Base*16 - RSRPAgcAdjust*16 + L_U16DownSamplingCompensate*16；</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp_para3" protect="rw">
        <comment>RSRP配置寄存器3</comment>
        <bits access="rw" name="s_th" pos="23:8" rst="0x0">
          <comment>ID1-2信号门限因子</comment>
        </bits>
        <bits access="rw" name="rssi_q" pos="6:0" rst="0x0">
          <comment>RSSI Q值；(有符号)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp_para4" protect="rw">
        <comment>RSRP配置寄存器4</comment>
        <bits access="rw" name="powq_value" pos="15:8" rst="0x0">
          <comment>FFT和IFFT的Q值变化；</comment>
        </bits>
        <bits access="rw" name="pow_pa" pos="7:0" rst="0x0">
          <comment>经过FFT和IFFT的放大倍数；</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt_para1" protect="rw">
        <comment>IRT参数配置寄存器1</comment>
        <bits access="rw" name="val_sel" pos="20" rst="0x0">
          <comment>IRT负时延前向保护标志
0：不保护（原8910方案）
1：保护</comment>
        </bits>
        <bits access="rw" name="pow_max_num" pos="19:16" rst="0x0">
          <comment>pow最大值个数</comment>
        </bits>
        <bits access="rw" name="n_scale" pos="15:12" rst="0x0">
          <comment>Scale计算使用径数</comment>
        </bits>
        <bits access="rw" name="dis_limit" pos="11:4" rst="0x0">
          <comment>信号区域</comment>
        </bits>
        <bits access="rw" name="irt_ofdm_num" pos="1:0" rst="0x0">
          <comment>IRT计算时域单次累加样本个数
00：1
01：2
11：4</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt_para2" protect="rw">
        <comment>IRT 参数配置寄存器2</comment>
        <bits access="rw" name="s_th" pos="31:16" rst="0x0">
          <comment>ID1-2信号门限因子</comment>
        </bits>
        <bits access="rw" name="n_th" pos="15:0" rst="0x0">
          <comment>ID1-2噪声门限因子（有符号的，16q10，正数）</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt_scale_th1" protect="rw">
        <comment>IRT ID1-2 Scale1门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th2" protect="rw">
        <comment>IRT  ID1-2 Scale2门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th4" protect="rw">
        <comment>IRT  ID1-2 Scale4门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th8" protect="rw">
        <comment>IRT  ID1-2 Scale8门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th16" protect="rw">
        <comment>IRT  ID1-2 Scale16门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th32" protect="rw">
        <comment>IRT  ID1-2 Scale32门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th64" protect="rw">
        <comment>IRT  ID1-2 Scale64门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th128" protect="rw">
        <comment>IRT  ID1-2 Scale128门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th256" protect="rw">
        <comment>IRT  ID1-2 Scale256门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th512" protect="rw">
        <comment>IRT  ID1-2 Scale512门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_rssi_para" protect="rw">
        <comment>RSSI参数配置寄存器</comment>
        <bits access="rw" name="rssi_compensate2" pos="19:12" rst="0x0">
          <comment>ID3-8 Rssi补偿值</comment>
        </bits>
        <bits access="rw" name="rssi_compensate" pos="11:4" rst="0x0">
          <comment>ID1-2 Rssi补偿值</comment>
        </bits>
        <bits access="rw" name="rssi_sel" pos="0" rst="0x1">
          <comment>所有ID的RSSI的计算方式选择：
0：MEASPWR使用的有效数据中有效的OFDM符号计算RSSI
1：MEASPWR使用的有效数据长度的数据计算</comment>
        </bits>
      </reg>
      <reg name="measpwr_agc" protect="rw">
        <comment>MEASPWR的接收数据的AGC寄存器</comment>
        <bits access="rw" name="agc_rx" pos="9:0" rst="0x0">
          <comment>接收天线的AGC，有符号数</comment>
        </bits>
      </reg>
      <reg name="measpwr_id1_para1" protect="rw">
        <comment>MEASPWR ID1参数寄存器1</comment>
        <bits access="rw" name="lnum_mod" pos="31:28" rst="0x0">
          <comment>FFT的采用定点数截位方式一的前几级级数：
4`b0000：各级都采用截位方式二
4`b0001：第一级采用截位方式一，后面几级都采用截位方式二
4`b0010：第一、二级采用截位方式一，后面几级都采用截位方式二
….</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="27:24" rst="0x0">
          <comment>OFFLINE模式0步进次数</comment>
        </bits>
        <bits access="rw" name="afc_out_num" pos="23:16" rst="0x0">
          <comment>AFC输出步进参数，以实际值减一配置</comment>
        </bits>
        <bits access="rw" name="crs_rssi_sel" pos="15:14" rst="0x0">
          <comment>Crs_rssi归属选择
00：归属一
01：归属二
10：归属三
11：reserved</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="13" rst="0x0">
          <comment>下行首子帧首符号有效指示
0：无效
1：有效</comment>
        </bits>
        <bits access="rw" name="nid" pos="12:4" rst="0x0">
          <comment>NID值：取值为 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="3" rst="0x0">
          <comment>发射天线为2时使用的port指示
0：port 0 and port 1
1：only port 1</comment>
        </bits>
        <bits access="rw" name="afc_out_sel" pos="2" rst="0x0">
          <comment>AFC结果输出时间选择
0：同IRT
1：以bit[8:1]配置的子帧数为间隔</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="1" rst="0x0">
          <comment>发射天线数：
0：1发射天线
1：2发射天线</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="0" rst="0x0">
          <comment>CP类型：
0：常规CP
1：扩展CP</comment>
        </bits>
      </reg>
      <reg name="measpwr_id1_para2" protect="rw">
        <comment>MEASPWR ID1参数寄存器2</comment>
        <bits access="rw" name="qf_mem_sel" pos="31" rst="0x0">
          <comment>Hmmse QF mem选择：
0：固定QF mem
1：动态QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="30" rst="0x0">
          <comment>IRT scale门限不使能控制
0：使能门限判断
1：不使能门限判断</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="29:28" rst="0x0">
          <comment>AFC\POW数据输入选择
00：hls
01：hmmse
10：freqfirst
11：hls</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="26" rst="0x0">
          <comment>Crs_rssi清零控制</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="25:16" rst="0x0">
          <comment>有效子帧映射，从bit[25:16]一次对应子帧9-0</comment>
        </bits>
        <bits access="rw" name="offline0_step" pos="15:7" rst="0x0">
          <comment>OFFLINE模式0步进长度</comment>
        </bits>
        <bits access="rw" name="sinr_map" pos="6:4" rst="0x0">
          <comment>SINR归属频段设置
000：NA（不使能窄带SINR）
001：频段1
010：频段2
011：频段3
100：频段4
Other：NA</comment>
        </bits>
        <bits access="rw" name="afc_related_en" pos="3" rst="0x0">
          <comment>AFC关联使能
0：与前一子帧数据关联
1：与前一子帧数据不关联</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment>最后一个数据窗标记</comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>滑动窗清零控制
0：不清零
1：清零</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>重新开始控制位：
0：与前面子帧连续
1：开始全新计算
该位被置1后，在下一子帧将前面的计算结果全部清零，重新开始计算和子帧计数</comment>
        </bits>
      </reg>
      <reg name="measpwr_id2_para1" protect="rw">
        <comment>MEASPWR ID2参数寄存器1</comment>
        <bits access="rw" name="lnum_mod" pos="31:28" rst="0x0">
          <comment>FFT的采用定点数截位方式一的前几级级数：
4`b0000：各级都采用截位方式二
4`b0001：第一级采用截位方式一，后面几级都采用截位方式二
4`b0010：第一、二级采用截位方式一，后面几级都采用截位方式二
….</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="27:24" rst="0x0">
          <comment>OFFLINE模式0步进次数</comment>
        </bits>
        <bits access="rw" name="afc_out_num" pos="23:16" rst="0x0">
          <comment>AFC输出步进参数，以实际值减一配置</comment>
        </bits>
        <bits access="rw" name="crs_rssi_sel" pos="15:14" rst="0x0">
          <comment>Crs_rssi归属选择
00：归属一
01：归属二
10：归属三
11：reserved</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="13" rst="0x0">
          <comment>下行首子帧首符号有效指示
0：无效
1：有效</comment>
        </bits>
        <bits access="rw" name="nid" pos="12:4" rst="0x0">
          <comment>NID值：取值为 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="3" rst="0x0">
          <comment>发射天线为2时使用的port指示
0：port 0 and port 1
1：only port 1</comment>
        </bits>
        <bits access="rw" name="afc_out_sel" pos="2" rst="0x0">
          <comment>AFC结果输出时间选择
0：同IRT
1：以bit[8:1]配置的子帧数为间隔</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="1" rst="0x0">
          <comment>发射天线数：
0：1发射天线
1：2发射天线</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="0" rst="0x0">
          <comment>CP类型：
0：常规CP
1：扩展CP</comment>
        </bits>
      </reg>
      <reg name="measpwr_id2_para2" protect="rw">
        <comment>MEASPWR ID2参数寄存器2</comment>
        <bits access="rw" name="qf_mem_sel" pos="31" rst="0x0">
          <comment>Hmmse QF mem选择：
0：固定QF mem
1：动态QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="30" rst="0x0">
          <comment>IRT scale门限不使能控制
0：使能门限判断
1：不使能门限判断</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="29:28" rst="0x0">
          <comment>AFC\POW数据输入选择
00：hls
01：hmmse
10：freqfirst
11：hls</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="26" rst="0x0">
          <comment>Crs_rssi清零控制</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="25:16" rst="0x0">
          <comment>有效子帧映射，从bit[25:16]一次对应子帧9-0</comment>
        </bits>
        <bits access="rw" name="offline0_step" pos="15:7" rst="0x0">
          <comment>OFFLINE模式0步进长度</comment>
        </bits>
        <bits access="r" name="reserve2" pos="6:4" rst="0x0"/>
        <bits access="rw" name="afc_related_en" pos="3" rst="0x0">
          <comment>AFC关联使能
0：与前一子帧数据关联
1：与前一子帧数据不关联</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment>最后一个数据窗标记</comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>滑动窗清零控制
0：不清零
1：清零</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>重新开始控制位：
0：与前面子帧连续
1：开始全新计算
该位被置1后，在下一子帧将前面的计算结果全部清零，重新开始计算和子帧计数</comment>
        </bits>
      </reg>
      <reg name="measpwr_id3_para1" protect="rw">
        <comment>MEASPWR ID3参数寄存器1</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT的采用定点数截位方式一的前几级级数：
4`b0000：各级都采用截位方式二
4`b0001：第一级采用截位方式一，后面几级都采用截位方式二
4`b0010：第一、二级采用截位方式一，后面几级都采用截位方式二
….</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE模式0步进次数</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>下行首子帧首符号有效指示
0：无效
1：有效</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID值：取值为 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>发射天线为2时使用的port指示
0：port 0 and port 1
1：only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>发射天线数：
0：1发射天线
1：2发射天线</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP类型：
0：常规CP
1：扩展CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi清零控制</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment>最后一个数据窗标记</comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>滑动窗清零控制
0：不清零
1：清零</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>重新开始控制位：
0：与前面子帧连续
1：开始全新计算
该位被置1后，在下一子帧将前面的计算结果全部清零，重新开始计算和子帧计数</comment>
        </bits>
      </reg>
      <reg name="measpwr_id4_para1" protect="rw">
        <comment>MEASPWR ID4参数寄存器1</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT的采用定点数截位方式一的前几级级数：
4`b0000：各级都采用截位方式二
4`b0001：第一级采用截位方式一，后面几级都采用截位方式二
4`b0010：第一、二级采用截位方式一，后面几级都采用截位方式二
….</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE模式0步进次数</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>下行首子帧首符号有效指示
0：无效
1：有效</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID值：取值为 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>发射天线为2时使用的port指示
0：port 0 and port 1
1：only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>发射天线数：
0：1发射天线
1：2发射天线</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP类型：
0：常规CP
1：扩展CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi清零控制</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment>最后一个数据窗标记</comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>滑动窗清零控制
0：不清零
1：清零</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>重新开始控制位：
0：与前面子帧连续
1：开始全新计算
该位被置1后，在下一子帧将前面的计算结果全部清零，重新开始计算和子帧计数</comment>
        </bits>
      </reg>
      <reg name="measpwr_id5_para1" protect="rw">
        <comment>MEASPWR ID5参数寄存器1</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT的采用定点数截位方式一的前几级级数：
4`b0000：各级都采用截位方式二
4`b0001：第一级采用截位方式一，后面几级都采用截位方式二
4`b0010：第一、二级采用截位方式一，后面几级都采用截位方式二
….</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE模式0步进次数</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>下行首子帧首符号有效指示
0：无效
1：有效</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID值：取值为 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>发射天线为2时使用的port指示
0：port 0 and port 1
1：only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>发射天线数：
0：1发射天线
1：2发射天线</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP类型：
0：常规CP
1：扩展CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi清零控制</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment>最后一个数据窗标记</comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>滑动窗清零控制
0：不清零
1：清零</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>重新开始控制位：
0：与前面子帧连续
1：开始全新计算
该位被置1后，在下一子帧将前面的计算结果全部清零，重新开始计算和子帧计数</comment>
        </bits>
      </reg>
      <reg name="measpwr_id6_para1" protect="rw">
        <comment>MEASPWR ID6参数寄存器1</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT的采用定点数截位方式一的前几级级数：
4`b0000：各级都采用截位方式二
4`b0001：第一级采用截位方式一，后面几级都采用截位方式二
4`b0010：第一、二级采用截位方式一，后面几级都采用截位方式二
….</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE模式0步进次数</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>下行首子帧首符号有效指示
0：无效
1：有效</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID值：取值为 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>发射天线为2时使用的port指示
0：port 0 and port 1
1：only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>发射天线数：
0：1发射天线
1：2发射天线</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP类型：
0：常规CP
1：扩展CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi清零控制</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment>最后一个数据窗标记</comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>滑动窗清零控制
0：不清零
1：清零</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>重新开始控制位：
0：与前面子帧连续
1：开始全新计算
该位被置1后，在下一子帧将前面的计算结果全部清零，重新开始计算和子帧计数</comment>
        </bits>
      </reg>
      <reg name="measpwr_id7_para1" protect="rw">
        <comment>MEASPWR ID7参数寄存器1</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT的采用定点数截位方式一的前几级级数：
4`b0000：各级都采用截位方式二
4`b0001：第一级采用截位方式一，后面几级都采用截位方式二
4`b0010：第一、二级采用截位方式一，后面几级都采用截位方式二
….</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE模式0步进次数</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>下行首子帧首符号有效指示
0：无效
1：有效</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID值：取值为 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>发射天线为2时使用的port指示
0：port 0 and port 1
1：only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>发射天线数：
0：1发射天线
1：2发射天线</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP类型：
0：常规CP
1：扩展CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi清零控制</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment>最后一个数据窗标记</comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>滑动窗清零控制
0：不清零
1：清零</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>重新开始控制位：
0：与前面子帧连续
1：开始全新计算
该位被置1后，在下一子帧将前面的计算结果全部清零，重新开始计算和子帧计数</comment>
        </bits>
      </reg>
      <reg name="measpwr_id8_para1" protect="rw">
        <comment>MEASPWR ID8参数寄存器1</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT的采用定点数截位方式一的前几级级数：
4`b0000：各级都采用截位方式二
4`b0001：第一级采用截位方式一，后面几级都采用截位方式二
4`b0010：第一、二级采用截位方式一，后面几级都采用截位方式二
….</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE模式0步进次数</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>下行首子帧首符号有效指示
0：无效
1：有效</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID值：取值为 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>发射天线为2时使用的port指示
0：port 0 and port 1
1：only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>发射天线数：
0：1发射天线
1：2发射天线</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP类型：
0：常规CP
1：扩展CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi清零控制</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment>最后一个数据窗标记</comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>滑动窗清零控制
0：不清零
1：清零</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>重新开始控制位：
0：与前面子帧连续
1：开始全新计算
该位被置1后，在下一子帧将前面的计算结果全部清零，重新开始计算和子帧计数</comment>
        </bits>
      </reg>
      <reg name="measpwr_id_para" protect="rw">
        <comment>MEASPWR ID控制寄存器</comment>
        <bits access="rw" name="offline_mod_sel" pos="28" rst="0x0">
          <comment>Offline模式选择
0：模式0多次自动计算模式
1：模式1单次直接配置模式</comment>
        </bits>
        <bits access="rw" name="offlin_data_sel" pos="24" rst="0x0">
          <comment>offline数据选择：
0：使用当前数据
1：使用原始数据</comment>
        </bits>
        <bits access="rw" name="nid12_info" pos="19:4" rst="0x0">
          <comment>NID1-2参数信息</comment>
        </bits>
        <bits access="rw" name="irt_soft_en" pos="3" rst="0x0">
          <comment>IRT软纠正使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="afc_soft_en" pos="2" rst="0x0">
          <comment>AFC软纠正使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="mode_sel" pos="1:0" rst="0x0">
          <comment>模式选择：
0：CATM
1：CAT1
2：NB
其他：NB_LTE下启动FFT功能</comment>
        </bits>
      </reg>
      <reg name="measpwr_id_ctrl" protect="rw">
        <comment>MEASPWR ID控制寄存器</comment>
        <bits access="rs" name="invalid_flag" pos="29" rst="0x0">
          <comment>NID_MAP无效指示
0：配置有效
1：配置无效</comment>
        </bits>
        <bits access="rs" name="nid38_info" pos="28:19" rst="0x0">
          <comment>NID3-8参数信息</comment>
        </bits>
        <bits access="rs" name="offline_sel" pos="8" rst="0x0">
          <comment>Offline与online模式选择：
0：online模式
1：offline模式</comment>
        </bits>
        <bits access="rs" name="nid8" pos="7" rst="0x0">
          <comment>指示当前窗有效ID，1
有效，0无效</comment>
        </bits>
        <bits access="rs" name="nid7" pos="6" rst="0x0">
          <comment>指示当前窗有效ID，1
有效，0无效</comment>
        </bits>
        <bits access="rs" name="nid6" pos="5" rst="0x0">
          <comment>指示当前窗有效ID，1
有效，0无效</comment>
        </bits>
        <bits access="rs" name="nid5" pos="4" rst="0x0">
          <comment>指示当前窗有效ID，1
有效，0无效</comment>
        </bits>
        <bits access="rs" name="nid4" pos="3" rst="0x0">
          <comment>指示当前窗有效ID，1
有效，0无效</comment>
        </bits>
        <bits access="rs" name="nid3" pos="2" rst="0x0">
          <comment>指示当前窗有效ID，1
有效，0无效</comment>
        </bits>
        <bits access="rs" name="nid2" pos="1" rst="0x0">
          <comment>指示当前窗有效ID，1
有效，0无效</comment>
        </bits>
        <bits access="rs" name="nid1" pos="0" rst="0x0">
          <comment>指示当前窗有效ID，1
有效，0无效</comment>
        </bits>
      </reg>
      <reg name="measpwr_ctrl" protect="rw">
        <comment>MEASPWR控制寄存器</comment>
        <bits access="rs" name="nid8_en" pos="7" rst="0x0">
          <comment>启动NID8</comment>
        </bits>
        <bits access="rs" name="nid7_en" pos="6" rst="0x0">
          <comment>启动NID7</comment>
        </bits>
        <bits access="rs" name="nid6_en" pos="5" rst="0x0">
          <comment>启动NID6</comment>
        </bits>
        <bits access="rs" name="nid5_en" pos="4" rst="0x0">
          <comment>启动NID5</comment>
        </bits>
        <bits access="rs" name="nid4_en" pos="3" rst="0x0">
          <comment>启动NID4</comment>
        </bits>
        <bits access="rs" name="nid3_en" pos="2" rst="0x0">
          <comment>启动NID3</comment>
        </bits>
        <bits access="rs" name="nid2_en" pos="1" rst="0x0">
          <comment>启动NID2</comment>
        </bits>
        <bits access="rs" name="nid1_en" pos="0" rst="0x0">
          <comment>启动NID1</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc1_out" protect="rw">
        <comment>ID1 AFC输出寄存器</comment>
        <bits access="r" name="afc_out1" pos="15:0" rst="0x0">
          <comment>AFC输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc2_out" protect="rw">
        <comment>ID2 AFC输出寄存器</comment>
        <bits access="r" name="afc_out2" pos="15:0" rst="0x0">
          <comment>AFC输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc3_out" protect="rw">
        <comment>ID3 AFC输出寄存器</comment>
        <bits access="r" name="afc_out3" pos="15:0" rst="0x0">
          <comment>AFC输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc4_out" protect="rw">
        <comment>ID4 AFC输出寄存器</comment>
        <bits access="r" name="afc_out4" pos="15:0" rst="0x0">
          <comment>AFC输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc5_out" protect="rw">
        <comment>ID5 AFC输出寄存器</comment>
        <bits access="r" name="afc_out5" pos="15:0" rst="0x0">
          <comment>AFC输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc1_rsrp" protect="rw">
        <comment>ID1基于AFC的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp1" pos="15:0" rst="0x0">
          <comment>基于AFC的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc2_rsrp" protect="rw">
        <comment>ID2基于AFC的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp2" pos="15:0" rst="0x0">
          <comment>基于AFC的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc3_rsrp" protect="rw">
        <comment>ID3基于AFC的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp3" pos="15:0" rst="0x0">
          <comment>基于AFC的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc4_rsrp" protect="rw">
        <comment>ID4基于AFC的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp4" pos="15:0" rst="0x0">
          <comment>基于AFC的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc5_rsrp" protect="rw">
        <comment>ID5基于AFC的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp5" pos="15:0" rst="0x0">
          <comment>基于AFC的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigpwr1_out1" protect="rw">
        <comment>频段1 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr1_out2" protect="rw">
        <comment>频段2 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr1_out3" protect="rw">
        <comment>频段3 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr1_out4" protect="rw">
        <comment>频段4 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr1_out5" protect="rw">
        <comment>频段5 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr1_out6" protect="rw">
        <comment>频段6 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr2_ out" protect="rw">
        <comment>ID2 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr3_ out" protect="rw">
        <comment>ID3 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr4_out4" protect="rw">
        <comment>ID4 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr5_out5" protect="rw">
        <comment>ID5 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma1_out1" protect="rw">
        <comment>频段1 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out1" protect="rw">
        <comment>频段1基准AGC输出寄存器</comment>
        <bits access="r" name="sinr1_log_out1" pos="26:16" rst="0x0">
          <comment>频段1的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc1_out1" pos="9:0" rst="0x0">
          <comment>频段1的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma1_out2" protect="rw">
        <comment>频段2 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out2" protect="rw">
        <comment>频段2基准AGC输出寄存器</comment>
        <bits access="r" name="sinr1_log_out2" pos="26:16" rst="0x0">
          <comment>频段2的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc1_out2" pos="9:0" rst="0x0">
          <comment>频段2的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma1_out3" protect="rw">
        <comment>频段3 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out3" protect="rw">
        <comment>频段3基准AGC输出寄存器</comment>
        <bits access="r" name="sinr1_log_out3" pos="26:16" rst="0x0">
          <comment>频段3的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc1_out3" pos="9:0" rst="0x0">
          <comment>频段3的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma1_out4" protect="rw">
        <comment>频段4 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out4" protect="rw">
        <comment>频段4基准AGC输出寄存器</comment>
        <bits access="r" name="sinr1_log_out4" pos="26:16" rst="0x0">
          <comment>频段4的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc1_out4" pos="9:0" rst="0x0">
          <comment>频段4的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma1_out5" protect="rw">
        <comment>窄带总SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out5" protect="rw">
        <comment>窄带基准AGC输出寄存器</comment>
        <bits access="r" name="sinr1_log_out5" pos="26:16" rst="0x0">
          <comment>频段5的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc1_out5" pos="9:0" rst="0x0">
          <comment>窄带总的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma1_out6" protect="rw">
        <comment>ID1 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out6" protect="rw">
        <comment>ID1基准AGC输出寄存器</comment>
        <bits access="r" name="sinr1_log_out6" pos="26:16" rst="0x0">
          <comment>频段6的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc1_out6" pos="9:0" rst="0x0">
          <comment>ID1的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma2_out" protect="rw">
        <comment>ID2 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma2_agc_out" protect="rw">
        <comment>ID2基准AGC输出寄存器</comment>
        <bits access="r" name="sinr2_log_out" pos="26:16" rst="0x0">
          <comment>ID2的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc2_out" pos="9:0" rst="0x0">
          <comment>ID2的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma3_out" protect="rw">
        <comment>ID3 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma3_agc_out" protect="rw">
        <comment>ID3基准AGC输出寄存器</comment>
        <bits access="r" name="sinr3_log_out" pos="26:16" rst="0x0">
          <comment>ID3的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc3_out" pos="9:0" rst="0x0">
          <comment>ID3的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma4_out" protect="rw">
        <comment>ID4 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma4_agc_out" protect="rw">
        <comment>ID4基准AGC输出寄存器</comment>
        <bits access="r" name="sinr4_log_out" pos="26:16" rst="0x0">
          <comment>ID4的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc4_out" pos="9:0" rst="0x0">
          <comment>ID4的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma5_out" protect="rw">
        <comment>ID5 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma5_agc_out" protect="rw">
        <comment>ID5基准AGC输出寄存器</comment>
        <bits access="r" name="sinr5_log_out" pos="26:16" rst="0x0">
          <comment>ID5的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc5_out" pos="9:0" rst="0x0">
          <comment>ID5的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sinr1_out1" protect="rw">
        <comment>频段1的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr1_out2" protect="rw">
        <comment>频段2的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr1_out3" protect="rw">
        <comment>频3的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr1_out4" protect="rw">
        <comment>频段4的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr1_out5" protect="rw">
        <comment>窄带总的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr1_out6" protect="rw">
        <comment>ID1的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr2_out" protect="rw">
        <comment>ID2的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr3_out" protect="rw">
        <comment>ID3的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr4_out" protect="rw">
        <comment>ID4的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr5_out" protect="rw">
        <comment>ID5的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_ doppler1_out" protect="rw">
        <comment>ID1 DOPPLER输出寄存器</comment>
        <bits access="r" name="hls_agc_base1" pos="25:16" rst="0x0">
          <comment>hls_agc_base输出</comment>
        </bits>
        <bits access="r" name="doppler1_out" pos="10:0" rst="0x0">
          <comment>DOPPLER输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_ doppler2_out" protect="rw">
        <comment>ID1 DOPPLER输出寄存器</comment>
        <bits access="r" name="hls_agc_base2" pos="25:16" rst="0x0">
          <comment>hls_agc_base输出</comment>
        </bits>
        <bits access="r" name="doppler2_out" pos="10:0" rst="0x0">
          <comment>DOPPLER输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp1_out" protect="rw">
        <comment>RSRP线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp1_db" protect="rw">
        <comment>RSRP功率值寄存器</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRP功率dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp1_scale" protect="rw">
        <comment>RSRP 的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp1_scale_db" protect="rw">
        <comment>RSRP 的Scale的dB值寄存器</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>Scale的dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq1_db" protect="rw">
        <comment>RSRP 的RSRQ的dB值寄存器</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQ的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi1_out" protect="rw">
        <comment>RSRP 的RSSI的线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rssi1_db" protect="rw">
        <comment>RSRP 的RSSI的dB值寄存器</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSI的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp2_out" protect="rw">
        <comment>RSRP线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp2_db" protect="rw">
        <comment>RSRP功率值寄存器</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRP功率dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp2_scale" protect="rw">
        <comment>RSRP 的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp2_scale_db" protect="rw">
        <comment>RSRP 的Scale的dB值寄存器</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>Scale的dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq2_db" protect="rw">
        <comment>RSRP 的RSRQ的dB值寄存器</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQ的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi2_out" protect="rw">
        <comment>RSRP 的RSSI的线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rssi2_db" protect="rw">
        <comment>RSRP 的RSSI的dB值寄存器</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSI的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp3_out" protect="rw">
        <comment>RSRP线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp3_db" protect="rw">
        <comment>RSRP功率值寄存器</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRP功率dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp3_scale" protect="rw">
        <comment>RSRP 的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp3_scale_db" protect="rw">
        <comment>RSRP 的Scale的dB值寄存器</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>Scale的dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq3_db" protect="rw">
        <comment>RSRP 的RSRQ的dB值寄存器</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQ的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi3_out" protect="rw">
        <comment>RSRP 的RSSI的线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rssi3_db" protect="rw">
        <comment>RSRP 的RSSI的dB值寄存器</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSI的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp4_out" protect="rw">
        <comment>RSRP线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp4_db" protect="rw">
        <comment>RSRP功率值寄存器</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRP功率dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp4_scale" protect="rw">
        <comment>RSRP 的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp4_scale_db" protect="rw">
        <comment>RSRP 的Scale的dB值寄存器</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>Scale的dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq4_db" protect="rw">
        <comment>RSRP 的RSRQ的dB值寄存器</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQ的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi4_out" protect="rw">
        <comment>RSRP 的RSSI的线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rssi4_db" protect="rw">
        <comment>RSRP 的RSSI的dB值寄存器</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSI的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp5_out" protect="rw">
        <comment>RSRP线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp5_db" protect="rw">
        <comment>RSRP功率值寄存器</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRP功率dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp5_scale" protect="rw">
        <comment>RSRP 的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp5_scale_db" protect="rw">
        <comment>RSRP 的Scale的dB值寄存器</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>Scale的dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq5_db" protect="rw">
        <comment>RSRP 的RSRQ的dB值寄存器</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQ的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi5_out" protect="rw">
        <comment>RSRP 的RSSI的线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rssi5_db" protect="rw">
        <comment>RSRP 的RSSI的dB值寄存器</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSI的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp6_out" protect="rw">
        <comment>RSRP线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp6_db" protect="rw">
        <comment>RSRP功率值寄存器</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRP功率dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp6_scale" protect="rw">
        <comment>RSRP 的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp6_scale_db" protect="rw">
        <comment>RSRP 的Scale的dB值寄存器</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>Scale的dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq6_db" protect="rw">
        <comment>RSRP 的RSRQ的dB值寄存器</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQ的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi6_out" protect="rw">
        <comment>RSRP 的RSSI的线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rssi6_db" protect="rw">
        <comment>RSRP 的RSSI的dB值寄存器</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSI的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp7_out" protect="rw">
        <comment>RSRP线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp7_db" protect="rw">
        <comment>RSRP功率值寄存器</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRP功率dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp7_scale" protect="rw">
        <comment>RSRP 的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp7_scale_db" protect="rw">
        <comment>RSRP 的Scale的dB值寄存器</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>Scale的dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq7_db" protect="rw">
        <comment>RSRP 的RSRQ的dB值寄存器</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQ的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi7_out" protect="rw">
        <comment>RSRP 的RSSI的线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rssi7_db" protect="rw">
        <comment>RSRP 的RSSI的dB值寄存器</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSI的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp8_out" protect="rw">
        <comment>RSRP线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp8_db" protect="rw">
        <comment>RSRP功率值寄存器</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRP功率dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp8_scale" protect="rw">
        <comment>RSRP 的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_rsrp8_scale_db" protect="rw">
        <comment>RSRP 的Scale的dB值寄存器</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>Scale的dB值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq8_db" protect="rw">
        <comment>RSRP 的RSRQ的dB值寄存器</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQ的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi8_out" protect="rw">
        <comment>RSRP 的RSSI的线性值寄存器</comment>
      </reg>
      <reg name="measpwr_rssi8_db" protect="rw">
        <comment>RSRP 的RSSI的dB值寄存器</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSI的dB值（通道以及OFDM符号拉齐之后的结果）</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt1_delay" protect="rw">
        <comment>IRT的delay值寄存器</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt1outflag" protect="rw">
        <comment>IRT scale标志寄存器</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale值是否达到门限标志
1：达到门限
0：未达门限</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale对应的样本数</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt1_scale" protect="rw">
        <comment>IRT的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_irt2_delay" protect="rw">
        <comment>IRT的delay值寄存器</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt2outflag" protect="rw">
        <comment>IRT scale标志寄存器</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale值是否达到门限标志
1：达到门限
0：未达门限</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale对应的样本数</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt2_scale" protect="rw">
        <comment>IRT的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_irt3_delay" protect="rw">
        <comment>IRT的delay值寄存器</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt3outflag" protect="rw">
        <comment>IRT scale标志寄存器</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale值是否达到门限标志
1：达到门限
0：未达门限</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale对应的样本数</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt3_scale" protect="rw">
        <comment>IRT的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_irt4_delay" protect="rw">
        <comment>IRT的delay值寄存器</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt4outflag" protect="rw">
        <comment>IRT scale标志寄存器</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale值是否达到门限标志
1：达到门限
0：未达门限</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale对应的样本数</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt4_scale" protect="rw">
        <comment>IRT的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_irt5_delay" protect="rw">
        <comment>IRT的delay值寄存器</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt5outflag" protect="rw">
        <comment>IRT scale标志寄存器</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale值是否达到门限标志
1：达到门限
0：未达门限</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale对应的样本数</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt5_scale" protect="rw">
        <comment>IRT的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_irt6_delay" protect="rw">
        <comment>IRT的delay值寄存器</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt6outflag" protect="rw">
        <comment>IRT scale标志寄存器</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale值是否达到门限标志
1：达到门限
0：未达门限</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale对应的样本数</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt6_scale" protect="rw">
        <comment>IRT的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_irt7_delay" protect="rw">
        <comment>IRT的delay值寄存器</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt7outflag" protect="rw">
        <comment>IRT scale标志寄存器</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale值是否达到门限标志
1：达到门限
0：未达门限</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale对应的样本数</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt7_scale" protect="rw">
        <comment>IRT的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_irt8_delay" protect="rw">
        <comment>IRT的delay值寄存器</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt8outflag" protect="rw">
        <comment>IRT scale标志寄存器</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale值是否达到门限标志
1：达到门限
0：未达门限</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale对应的样本数</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt8_scale" protect="rw">
        <comment>IRT的Scale值寄存器</comment>
      </reg>
      <reg name="measpwr_trms1_out" protect="rw">
        <comment>ID1 TRMS的Scale值寄存器</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms2_out" protect="rw">
        <comment>ID1 TRMS的Scale值寄存器</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_id_info" protect="rw">
        <comment>ID信息输出寄存器1</comment>
        <bits access="r" name="id2_info" pos="31:16" rst="0x0">
          <comment>ID2信息输出</comment>
        </bits>
        <bits access="r" name="id1_info" pos="15:0" rst="0x0">
          <comment>ID1信息输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_para" protect="rw">
        <comment>RBIS参数寄存器</comment>
        <bits access="rw" name="rbis_correct" pos="29" rst="0x0">
          <comment>ID1-2 RBIS CORRECT使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rbis_judge" pos="28" rst="0x0">
          <comment>ID1-2 RBIS JUDGE使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rbis_en" pos="27" rst="0x0">
          <comment>ID1-2 RBIS使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rbis_posen" pos="26" rst="0x0">
          <comment>ID1-2 RBIS使用直接位置指示：
0：不使用直接位置
1：使用直接位置</comment>
        </bits>
        <bits access="rw" name="rbis_num" pos="25:23" rst="0x0">
          <comment>ID1-2 RBIS检测个数：
0：1
1：2
2：3
3：4
4：5</comment>
        </bits>
        <bits access="rw" name="rbis_dipos" pos="22:16" rst="0x0">
          <comment>ID1-2 RBIS的直接位置</comment>
        </bits>
        <bits access="rw" name="rbis_factor" pos="15:0" rst="0x0">
          <comment>ID1-2 RBIS因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_out1" protect="rw">
        <comment>RBIS ID1 输出寄存器1</comment>
        <bits access="r" name="rbis_out3" pos="30:24" rst="0x0">
          <comment>ID1第4强RBI所处PRB索引输出</comment>
        </bits>
        <bits access="r" name="rbis_out2" pos="22:16" rst="0x0">
          <comment>ID1第3强RBI所处PRB索引输出</comment>
        </bits>
        <bits access="r" name="rbis_out1" pos="14:8" rst="0x0">
          <comment>ID1第2强RBI所处PRB索引输出</comment>
        </bits>
        <bits access="r" name="rbis_out0" pos="6:0" rst="0x0">
          <comment>ID1第1强RBI所处PRB索引输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_out2" protect="rw">
        <comment>RBIS ID1输出寄存器2</comment>
        <bits access="r" name="rbis_num" pos="10:8" rst="0x0">
          <comment>ID1 RBIS JUDGE个数输出</comment>
        </bits>
        <bits access="r" name="rbis_out4" pos="6:0" rst="0x0">
          <comment>ID1第5强RBI所处PRB索引输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_ave" protect="rw">
        <comment>RBIS ID1 AVE输出寄存器</comment>
      </reg>
      <reg name="measpwr_rbis_max" protect="rw">
        <comment>RBIS ID1 MAX输出寄存器</comment>
        <bits access="r" name="rbis_max" pos="24:0" rst="0x0">
          <comment>ID1 RBIS检测出的最大值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rx_irt" protect="rw">
        <comment>RX_IRT输出寄存器</comment>
        <bits access="r" name="id2_offset4" pos="30:21" rst="0x0">
          <comment>ID2 offset4值</comment>
        </bits>
        <bits access="r" name="id2_rx_irt" pos="20:16" rst="0x0">
          <comment>ID2 RX IRT值</comment>
        </bits>
        <bits access="r" name="id1_offset4" pos="14:5" rst="0x0">
          <comment>ID1 offset4值</comment>
        </bits>
        <bits access="r" name="id1_rx_irt" pos="4:0" rst="0x0">
          <comment>ID1 RX IRT值</comment>
        </bits>
      </reg>
      <reg name="measpwr_debug1" protect="rw">
        <comment>DEBUG输出寄存器 1</comment>
        <bits access="r" name="debug_rev_flag" pos="23" rst="0x0">
          <comment>debug_rev_flag</comment>
        </bits>
        <bits access="r" name="debug_update_flag" pos="22" rst="0x0">
          <comment>debug_update_flag</comment>
        </bits>
        <bits access="r" name="id_update" pos="21" rst="0x0">
          <comment>id_update</comment>
        </bits>
        <bits access="r" name="offset2_update" pos="20" rst="0x0">
          <comment>offset2_update</comment>
        </bits>
        <bits access="r" name="din_id_sel" pos="18:16" rst="0x0">
          <comment>din_id_sel</comment>
        </bits>
        <bits access="r" name="datagen_state" pos="14:4" rst="0x0">
          <comment>datagen_state</comment>
        </bits>
        <bits access="r" name="datain_state" pos="2:0" rst="0x0">
          <comment>datain_state</comment>
        </bits>
      </reg>
      <reg name="measpwr_debug2" protect="rw">
        <comment>DEBUG输出寄存器 2</comment>
        <bits access="r" name="inmem_in_act" pos="31" rst="0x0">
          <comment>inmem_in_act</comment>
        </bits>
        <bits access="r" name="invalid_data_cont" pos="30:16" rst="0x0">
          <comment>invalid_data_cont</comment>
        </bits>
        <bits access="r" name="inmem_cont" pos="15:0" rst="0x0">
          <comment>inmem_cont</comment>
        </bits>
      </reg>
      <reg name="measpwr_debug3" protect="rw">
        <comment>DEBUG输出寄存器 3</comment>
        <bits access="r" name="datain_state_cur" pos="26:24" rst="0x0">
          <comment>datain_state_cur</comment>
        </bits>
        <bits access="r" name="func_id_sel" pos="22:20" rst="0x0">
          <comment>func_id_sel</comment>
        </bits>
        <bits access="r" name="pow_state" pos="16:12" rst="0x0">
          <comment>pow_state</comment>
        </bits>
        <bits access="r" name="func_state" pos="8:0" rst="0x0">
          <comment>func_state</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigpwr6_out" protect="rw">
        <comment>ID6 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr7_out" protect="rw">
        <comment>ID7 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr8_out" protect="rw">
        <comment>ID8 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma6_out" protect="rw">
        <comment>ID6 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma6_agc_out" protect="rw">
        <comment>ID6基准AGC输出寄存器</comment>
        <bits access="r" name="sinr6_log_out" pos="26:16" rst="0x0">
          <comment>ID6的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc6_out" pos="9:0" rst="0x0">
          <comment>ID6的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma7_out" protect="rw">
        <comment>ID7 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma7_agc_out" protect="rw">
        <comment>ID7基准AGC输出寄存器</comment>
        <bits access="r" name="sinr7_log_out" pos="26:16" rst="0x0">
          <comment>ID7的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc7_out" pos="9:0" rst="0x0">
          <comment>ID7的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma8_out" protect="rw">
        <comment>ID8 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma8_agc_out" protect="rw">
        <comment>ID8基准AGC输出寄存器</comment>
        <bits access="r" name="sinr8_log_out" pos="26:16" rst="0x0">
          <comment>ID8的SINR LOG值</comment>
        </bits>
        <bits access="r" name="baseagc8_out" pos="9:0" rst="0x0">
          <comment>ID8的SIGMA对应的AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sinr6_out" protect="rw">
        <comment>ID6的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr7_out" protect="rw">
        <comment>ID7的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sinr8_out" protect="rw">
        <comment>ID8的SINR输出寄存器</comment>
      </reg>
      <reg name="measpwr_afc_soft_reect2" protect="rw">
        <comment>AFC软纠配置寄存器</comment>
        <bits access="rw" name="afc_soft_fa_ctor2" pos="15:0" rst="0x0">
          <comment>ID2 AFC软纠配置因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect3" protect="rw">
        <comment>AFC软纠配置寄存器</comment>
        <bits access="rw" name="afc_soft_fa_ctor3" pos="15:0" rst="0x0">
          <comment>ID3 AFC软纠配置因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect4" protect="rw">
        <comment>AFC软纠配置寄存器</comment>
        <bits access="rw" name="afc_soft_fa_ctor4" pos="15:0" rst="0x0">
          <comment>ID4 AFC软纠配置因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect5" protect="rw">
        <comment>AFC软纠配置寄存器</comment>
        <bits access="rw" name="afc_soft_fa_ctor5" pos="15:0" rst="0x0">
          <comment>ID5 AFC软纠配置因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect6" protect="rw">
        <comment>AFC软纠配置寄存器</comment>
        <bits access="rw" name="afc_soft_fa_ctor6" pos="15:0" rst="0x0">
          <comment>ID6 AFC软纠配置因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect7" protect="rw">
        <comment>AFC软纠配置寄存器</comment>
        <bits access="rw" name="afc_soft_fa_ctor7" pos="15:0" rst="0x0">
          <comment>ID7 AFC软纠配置因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect8" protect="rw">
        <comment>AFC软纠配置寄存器</comment>
        <bits access="rw" name="afc_soft_fa_ctor8" pos="15:0" rst="0x0">
          <comment>ID8 AFC软纠配置因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler_para2" protect="rw">
        <comment>DOPPLER配置寄存器</comment>
        <bits access="rw" name="doppler_alpha2" pos="16:0" rst="0x0">
          <comment>Id3-8 Doppler alpha参数</comment>
        </bits>
      </reg>
      <reg name="measpwr_trmsf_para" protect="rw">
        <comment>频域TRMS配置寄存器</comment>
        <bits access="rw" name="trmsf_scale" pos="27:24" rst="0x0">
          <comment>trmsf_scale(Q12的有效符号）</comment>
        </bits>
        <bits access="rw" name="trmsf_space" pos="21:20" rst="0x0">
          <comment>频域TRMS数据计算间隔</comment>
        </bits>
        <bits access="rw" name="trmsf_alpha" pos="16:0" rst="0x0">
          <comment>频域TRMS alpha参数</comment>
        </bits>
      </reg>
      <reg name="measpwr_id3_para2" protect="rw">
        <comment>MEASPWR ID3的参数寄存器2</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE模式0步进长度</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem选择：
0：固定QF mem
1：动态QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale门限不使能控制
0：使能门限判断
1：不使能门限判断</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW数据输入选择
00：hls
01：hmmse
10：freqfirst
11：hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>有效子帧映射，从bit[9:0]依次对应子帧9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_id4_para2" protect="rw">
        <comment>MEASPWR ID4的参数寄存器2</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE模式0步进长度</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem选择：
0：固定QF mem
1：动态QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale门限不使能控制
0：使能门限判断
1：不使能门限判断</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW数据输入选择
00：hls
01：hmmse
10：freqfirst
11：hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>有效子帧映射，从bit[9:0]依次对应子帧9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_id5_para2" protect="rw">
        <comment>MEASPWR ID5的参数寄存器2</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE模式0步进长度</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem选择：
0：固定QF mem
1：动态QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale门限不使能控制
0：使能门限判断
1：不使能门限判断</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW数据输入选择
00：hls
01：hmmse
10：freqfirst
11：hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>有效子帧映射，从bit[9:0]依次对应子帧9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_id6_para2" protect="rw">
        <comment>MEASPWR ID6的参数寄存器2</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE模式0步进长度</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem选择：
0：固定QF mem
1：动态QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale门限不使能控制
0：使能门限判断
1：不使能门限判断</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW数据输入选择
00：hls
01：hmmse
10：freqfirst
11：hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>有效子帧映射，从bit[9:0]依次对应子帧9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_id7_para2" protect="rw">
        <comment>MEASPWR ID7的参数寄存器2</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE模式0步进长度</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem选择：
0：固定QF mem
1：动态QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale门限不使能控制
0：使能门限判断
1：不使能门限判断</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW数据输入选择
00：hls
01：hmmse
10：freqfirst
11：hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>有效子帧映射，从bit[9:0]依次对应子帧9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_id8_para2" protect="rw">
        <comment>MEASPWR ID8的参数寄存器2</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE模式0步进长度</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem选择：
0：固定QF mem
1：动态QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale门限不使能控制
0：使能门限判断
1：不使能门限判断</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW数据输入选择
00：hls
01：hmmse
10：freqfirst
11：hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>有效子帧映射，从bit[9:0]依次对应子帧9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc1_hst" protect="rw">
        <comment>ID1 AFC HST输出寄存器</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc2_hst" protect="rw">
        <comment>ID2 AFC HST输出寄存器</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc3_hst" protect="rw">
        <comment>ID3 AFC HST输出寄存器</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc4_hst" protect="rw">
        <comment>ID4 AFC HST输出寄存器</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc5_hst" protect="rw">
        <comment>ID5 AFC HST输出寄存器</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc6_hst" protect="rw">
        <comment>ID6 AFC HST输出寄存器</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc7_hst" protect="rw">
        <comment>ID7 AFC HST输出寄存器</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc8_hst" protect="rw">
        <comment>ID8 AFC HST输出寄存器</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigpwr1_bef" protect="rw">
        <comment>ID1 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr2_bef" protect="rw">
        <comment>ID2 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr3_bef" protect="rw">
        <comment>ID3 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr4_bef" protect="rw">
        <comment>ID4 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr5_bef" protect="rw">
        <comment>ID5 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr6_bef" protect="rw">
        <comment>ID6 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr7_bef" protect="rw">
        <comment>ID7 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr8_bef" protect="rw">
        <comment>ID8 SIGPWR输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma1_bef" protect="rw">
        <comment>ID1 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma2_bef" protect="rw">
        <comment>ID2 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma3_bef" protect="rw">
        <comment>ID3 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma4_bef" protect="rw">
        <comment>ID4 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma5_bef" protect="rw">
        <comment>ID5 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma6_bef" protect="rw">
        <comment>ID6 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma7_bef" protect="rw">
        <comment>ID7 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_sigma8_bef" protect="rw">
        <comment>ID8 SIGMA输出寄存器</comment>
      </reg>
      <reg name="measpwr_doppler3_out" protect="rw">
        <comment>ID3 DOPPLER输出寄存器</comment>
        <bits access="r" name="hls_agc_base3" pos="25:16" rst="0x0">
          <comment>hls_agc_base输出</comment>
        </bits>
        <bits access="r" name="doppler3_out" pos="10:0" rst="0x0">
          <comment>DOPPLER输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler4_out" protect="rw">
        <comment>ID4 DOPPLER输出寄存器</comment>
        <bits access="r" name="hls_agc_base4" pos="25:16" rst="0x0">
          <comment>hls_agc_base输出</comment>
        </bits>
        <bits access="r" name="doppler4_out" pos="10:0" rst="0x0">
          <comment>DOPPLER输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler5_out" protect="rw">
        <comment>ID5 DOPPLER输出寄存器</comment>
        <bits access="r" name="hls_agc_base5" pos="25:16" rst="0x0">
          <comment>hls_agc_base输出</comment>
        </bits>
        <bits access="r" name="doppler5_out" pos="10:0" rst="0x0">
          <comment>DOPPLER输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler6_out" protect="rw">
        <comment>ID6 DOPPLER输出寄存器</comment>
        <bits access="r" name="hls_agc_base6" pos="25:16" rst="0x0">
          <comment>hls_agc_base输出</comment>
        </bits>
        <bits access="r" name="doppler6_out" pos="10:0" rst="0x0">
          <comment>DOPPLER输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler7_out" protect="rw">
        <comment>ID7 DOPPLER输出寄存器</comment>
        <bits access="r" name="hls_agc_base7" pos="25:16" rst="0x0">
          <comment>hls_agc_base输出</comment>
        </bits>
        <bits access="r" name="doppler7_out" pos="10:0" rst="0x0">
          <comment>DOPPLER输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler8_out" protect="rw">
        <comment>ID8 DOPPLER输出寄存器</comment>
        <bits access="r" name="hls_agc_base8" pos="25:16" rst="0x0">
          <comment>hls_agc_base输出</comment>
        </bits>
        <bits access="r" name="doppler8_out" pos="10:0" rst="0x0">
          <comment>DOPPLER输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler1_bef1" protect="rw">
        <comment>ID1 DOPPLER平滑前输出寄存器1</comment>
      </reg>
      <reg name="measpwr_doppler1_bef2" protect="rw">
        <comment>ID1 DOPPLER平滑前输出寄存器2</comment>
      </reg>
      <reg name="measpwr_doppler2_bef1" protect="rw">
        <comment>ID2 DOPPLER平滑前输出寄存器1</comment>
      </reg>
      <reg name="measpwr_doppler2_bef2" protect="rw">
        <comment>ID2 DOPPLER平滑前输出寄存器2</comment>
      </reg>
      <reg name="measpwr_trmsf1_out" protect="rw">
        <comment>ID1 TRMS频域输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf2_out" protect="rw">
        <comment>ID2 TRMS频域输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf3_out" protect="rw">
        <comment>ID3 TRMS频域输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf4_out" protect="rw">
        <comment>ID4 TRMS频域输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf5_out" protect="rw">
        <comment>ID5 TRMS频域输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf6_out" protect="rw">
        <comment>ID6 TRMS频域输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf7_out" protect="rw">
        <comment>ID7 TRMS频域输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf8_out" protect="rw">
        <comment>ID8 TRMS频域输出寄存器</comment>
      </reg>
      <hole size="32"/>
      <reg name="measpwr_trmsf1_bef1" protect="rw">
        <comment>ID1 TRMS频域PART1输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf1_bef2" protect="rw">
        <comment>ID1 TRMS频域PART2输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf2_bef1" protect="rw">
        <comment>ID2 TRMS频域PART1输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf2_bef2" protect="rw">
        <comment>ID2 TRMS频域PART2输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf3_bef1" protect="rw">
        <comment>ID3 TRMS频域PART1输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf3_bef2" protect="rw">
        <comment>ID3 TRMS频域PART2输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf4_bef1" protect="rw">
        <comment>ID4 TRMS频域PART1输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf4_bef2" protect="rw">
        <comment>ID4 TRMS频域PART2输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf5_bef1" protect="rw">
        <comment>ID5 TRMS频域PART1输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf5_bef2" protect="rw">
        <comment>ID5 TRMS频域PART2输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf6_bef1" protect="rw">
        <comment>ID6 TRMS频域PART1输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf6_bef2" protect="rw">
        <comment>ID6 TRMS频域PART2输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf7_bef1" protect="rw">
        <comment>ID7 TRMS频域PART1输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf7_bef2" protect="rw">
        <comment>ID7 TRMS频域PART2输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf8_bef1" protect="rw">
        <comment>ID8 TRMS频域PART1输出寄存器</comment>
      </reg>
      <reg name="measpwr_trmsf8_bef2" protect="rw">
        <comment>ID8 TRMS频域PART2输出寄存器</comment>
      </reg>
      <reg name="measpwr_pow1_max" protect="rw">
        <comment>ID1 POW最大值寄存器</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POW最大值（最大值的bit[23:0]）</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment>最大值位置</comment>
        </bits>
      </reg>
      <reg name="measpwr_pow2_max" protect="rw">
        <comment>ID2 POW最大值寄存器</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POW最大值（最大值的bit[23:0]）</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment>最大值位置</comment>
        </bits>
      </reg>
      <reg name="measpwr_pow3_max" protect="rw">
        <comment>ID3 POW最大值寄存器</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POW最大值（最大值的bit[23:0]）</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment>最大值位置</comment>
        </bits>
      </reg>
      <reg name="measpwr_pow4_max" protect="rw">
        <comment>ID4 POW最大值寄存器</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POW最大值（最大值的bit[23:0]）</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment>最大值位置</comment>
        </bits>
      </reg>
      <reg name="measpwr_pow5_max" protect="rw">
        <comment>ID5 POW最大值寄存器</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POW最大值（最大值的bit[23:0]）</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment>最大值位置</comment>
        </bits>
      </reg>
      <reg name="measpwr_pow6_max" protect="rw">
        <comment>ID6 POW最大值寄存器</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POW最大值（最大值的bit[23:0]）</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment>最大值位置</comment>
        </bits>
      </reg>
      <reg name="measpwr_pow7_max" protect="rw">
        <comment>ID7 POW最大值寄存器</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POW最大值（最大值的bit[23:0]）</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment>最大值位置</comment>
        </bits>
      </reg>
      <reg name="measpwr_pow8_max" protect="rw">
        <comment>ID8 POW最大值寄存器</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POW最大值（最大值的bit[23:0]）</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment>最大值位置</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms3_out" protect="rw">
        <comment>ID3 TRMS的Scale值寄存器</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms4_out" protect="rw">
        <comment>ID4 TRMS的Scale值寄存器</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms5_out" protect="rw">
        <comment>ID5 TRMS的Scale值寄存器</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms6_out" protect="rw">
        <comment>ID6 TRMS的Scale值寄存器</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms7_out" protect="rw">
        <comment>ID7 TRMS的Scale值寄存器</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms8_out" protect="rw">
        <comment>ID8 TRMS的Scale值寄存器</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment>时延估计值</comment>
        </bits>
      </reg>
      <reg name="measpwr_reis_conf" protect="rw">
        <comment>REIS配置寄存器</comment>
        <bits access="rw" name="reis_dc_en" pos="5" rst="0x0">
          <comment>REIS_DC使能</comment>
        </bits>
        <bits access="rw" name="reis_en" pos="4" rst="0x0">
          <comment>REIS使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="reis_num" pos="3:0" rst="0x0">
          <comment>REIS的NUM个数</comment>
        </bits>
      </reg>
      <reg name="measpwr_reis_pos0" protect="rw">
        <comment>REIS位置寄存器0</comment>
        <bits access="rw" name="reis_re1" pos="26:16" rst="0x0">
          <comment>REIS1的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
        <bits access="rw" name="reis_re0" pos="10:0" rst="0x0">
          <comment>REIS0的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
      </reg>
      <reg name="measpwr_reis_pos1" protect="rw">
        <comment>REIS位置寄存器1</comment>
        <bits access="rw" name="reis_re3" pos="26:16" rst="0x0">
          <comment>REIS3的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
        <bits access="rw" name="reis_re2" pos="10:0" rst="0x0">
          <comment>REIS2的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
      </reg>
      <reg name="measpwr_reis_pos2" protect="rw">
        <comment>REIS位置寄存器0</comment>
        <bits access="rw" name="reis_re5" pos="26:16" rst="0x0">
          <comment>REIS5的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
        <bits access="rw" name="reis_re4" pos="10:0" rst="0x0">
          <comment>REIS4的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
      </reg>
      <reg name="measpwr_reis_pos3" protect="rw">
        <comment>REIS位置寄存器0</comment>
        <bits access="rw" name="reis_re7" pos="26:16" rst="0x0">
          <comment>REIS7的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
        <bits access="rw" name="reis_re6" pos="10:0" rst="0x0">
          <comment>REIS6的RE位置（20M带宽1200个RE的绝对位置）</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_sel" protect="rw">
        <comment>OFFLINE模式0选择寄存器</comment>
        <bits access="rw" name="pos_delay_sel" pos="8" rst="0x0">
          <comment>Pos\delay判决选择标志
0：pos
1:delay</comment>
        </bits>
        <bits access="rw" name="jump_flag" pos="5:4" rst="0x0">
          <comment>门限目标选择：
00：IRT_Scale
01：RSRP_Scale
10：SINR
11：POWMAX_Scale</comment>
        </bits>
        <bits access="rw" name="decision_flag" pos="1:0" rst="0x0">
          <comment>排序目标选择：
00：IRT_Scale
01：Sigpwr
10：SINR
11：IRT_Scale</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_th" protect="rw">
        <comment>OFFLINE模式0门限值寄存器</comment>
      </reg>
      <reg name="measpwr_offline0_pos" protect="rw">
        <comment>OFFLINE模式0最大值位置寄存器</comment>
        <bits access="r" name="id8_max_position" pos="31:28" rst="0x0">
          <comment>Id8最佳TBin位置</comment>
        </bits>
        <bits access="r" name="id7_max_position" pos="27:24" rst="0x0">
          <comment>Id7最佳TBin位置</comment>
        </bits>
        <bits access="r" name="id6_max_position" pos="23:20" rst="0x0">
          <comment>Id6最佳TBin位置</comment>
        </bits>
        <bits access="r" name="id5_max_position" pos="19:16" rst="0x0">
          <comment>Id5最佳TBin位置</comment>
        </bits>
        <bits access="r" name="id4_max_position" pos="15:12" rst="0x0">
          <comment>Id4最佳TBin位置</comment>
        </bits>
        <bits access="r" name="id3_max_position" pos="11:8" rst="0x0">
          <comment>Id3最佳TBin位置</comment>
        </bits>
        <bits access="r" name="id2_max_position" pos="7:4" rst="0x0">
          <comment>Id2最佳TBin位置</comment>
        </bits>
        <bits access="r" name="id1_max_position" pos="3:0" rst="0x0">
          <comment>Id1最佳TBin位置</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_id" protect="rw">
        <comment>OFFLINE模式0门限跳出位置寄存器</comment>
        <bits access="r" name="tbin_position_valid_flag" pos="11:4" rst="0x0">
          <comment>最佳Tbin位置有效标志，分别对应ID1~ID8
0：无效
1：有效</comment>
        </bits>
        <bits access="r" name="offline_jump_id" pos="3:0" rst="0xf">
          <comment>Offline门限值跳出位置寄存器
如果未达到门限则该寄存器输出为0xF</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_para" protect="rw">
        <comment>OFFLINE模式1参数寄存器</comment>
        <bits access="rw" name="first_ofdm" pos="12" rst="0x0">
          <comment>首符号定义
0：符号0
1：符号4或3</comment>
        </bits>
        <bits access="rw" name="offline1_mod_sel" pos="9:8" rst="0x0">
          <comment>Offline模式1模式选择
00：｛0｝子帧
01：｛0、5｝子帧
10：｛5、0｝子帧
11：｛9，0｝子帧</comment>
        </bits>
        <bits access="rw" name="offline1_num" pos="5" rst="0x0">
          <comment>Offline模式1单次计算子帧数
0：1个
1：2个</comment>
        </bits>
        <bits access="rw" name="offline1_time" pos="4:0" rst="0x0">
          <comment>Offline模式1计算次数</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc1" protect="rw">
        <comment>OFFLINE模式1AGC寄存器1</comment>
        <bits access="rw" name="offline1_agc3" pos="29:20" rst="0x0">
          <comment>子帧3 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc2" pos="19:10" rst="0x0">
          <comment>子帧2 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc1" pos="9:0" rst="0x0">
          <comment>子帧1 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc2" protect="rw">
        <comment>OFFLINE模式1AGC寄存器2</comment>
        <bits access="rw" name="offline1_agc6" pos="29:20" rst="0x0">
          <comment>子帧6 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc5" pos="19:10" rst="0x0">
          <comment>子帧5 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc4" pos="9:0" rst="0x0">
          <comment>子帧4 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc3" protect="rw">
        <comment>OFFLINE模式1AGC寄存器3</comment>
        <bits access="rw" name="offline1_agc9" pos="29:20" rst="0x0">
          <comment>子帧9 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc8" pos="19:10" rst="0x0">
          <comment>子帧8 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc7" pos="9:0" rst="0x0">
          <comment>子帧7 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc4" protect="rw">
        <comment>OFFLINE模式1AGC寄存器4</comment>
        <bits access="rw" name="offline1_agc12" pos="29:20" rst="0x0">
          <comment>子帧12 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc11" pos="19:10" rst="0x0">
          <comment>子帧11 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc10" pos="9:0" rst="0x0">
          <comment>子帧10 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc5" protect="rw">
        <comment>OFFLINE模式1AGC寄存器5</comment>
        <bits access="rw" name="offline1_agc15" pos="29:20" rst="0x0">
          <comment>子帧15 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc14" pos="19:10" rst="0x0">
          <comment>子帧14 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc13" pos="9:0" rst="0x0">
          <comment>子帧13 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc6" protect="rw">
        <comment>OFFLINE模式1AGC寄存器6</comment>
        <bits access="rw" name="offline1_agc18" pos="29:20" rst="0x0">
          <comment>子帧18 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc17" pos="19:10" rst="0x0">
          <comment>子帧17 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc16" pos="9:0" rst="0x0">
          <comment>子帧16 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi1_out1" protect="rw">
        <comment>ID1 CRS_RSSI1最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi1_out2" protect="rw">
        <comment>ID1 CRS_RSSI2最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi1_out3" protect="rw">
        <comment>ID1 CRS_RSSI3最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi2_out1" protect="rw">
        <comment>ID2 CRS_RSSI1最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi2_out2" protect="rw">
        <comment>ID2 CRS_RSSI2最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi2_out3" protect="rw">
        <comment>ID2 CRS_RSSI3最大值寄存器</comment>
      </reg>
      <hole size="32"/>
      <reg name="measpwr_crs_rssi3_out" protect="rw">
        <comment>ID3 CRS_RSSI最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi4_out" protect="rw">
        <comment>ID4 CRS_RSSI最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi5_out" protect="rw">
        <comment>ID5 CRS_RSSI最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi6_out" protect="rw">
        <comment>ID6 CRS_RSSI最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi7_out" protect="rw">
        <comment>ID7 CRS_RSSI最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi8_out" protect="rw">
        <comment>ID8 CRS_RSSI最大值寄存器</comment>
      </reg>
      <reg name="measpwr_crs_rssi1_agc1" protect="rw">
        <comment>ID1 CRS_RSSI1AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi1_agc2" protect="rw">
        <comment>ID1 CRS_RSSI2AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi1_agc3" protect="rw">
        <comment>ID1 CRS_RSSI3AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi2_agc1" protect="rw">
        <comment>ID2 CRS_RSSI1AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi2_agc2" protect="rw">
        <comment>ID2 CRS_RSSI2AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi2_agc3" protect="rw">
        <comment>ID2 CRS_RSSI3AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi3_agc" protect="rw">
        <comment>ID3 CRS_RSSI AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi4_agc" protect="rw">
        <comment>ID4 CRS_RSSI AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi5_agc" protect="rw">
        <comment>ID5 CRS_RSSI AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi6_agc" protect="rw">
        <comment>ID6 CRS_RSSI AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi7_agc" protect="rw">
        <comment>ID7 CRS_RSSI AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi8_agc" protect="rw">
        <comment>ID8 CRS_RSSI AGC寄存器</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssi最大值对应的agc</comment>
        </bits>
      </reg>
      <reg name="measpwr_hmmse_win" protect="rw">
        <comment>HMMSE频域估计窗长指示寄存器</comment>
        <bits access="rw" name="fh_wl_ind" pos="0" rst="0x0">
          <comment>频域估计窗长指示
0：频域估计窗长为3PRB；
1：频域估计窗长为6PRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_hmmse_bitsel" protect="rw">
        <comment>HMMSE截位参数寄存器</comment>
        <bits access="rw" name="fh_bitsel" pos="3:0" rst="0x6">
          <comment>乘累加后截取13bit数据的比特选择：
0x0：截取选择29~17
0x1：截取选择28~16
0x2：截取选择27~15
0x3：截取选择26~14
0x4：截取选择25~13
0x5：截取选择24~12
0x6：截取选择23~11
0x7：截取选择22~10
0x8：截取选择21~9
0x9：截取选择20~8
0xa：截取选择19~7
0xb：截取选择18~6
0xc：截取选择17~5
0xd：截取选择16~4
0xe：截取选择15~3
0xf：截取选择14~2</comment>
        </bits>
      </reg>
      <reg name="measpwr_hmmse_flag" protect="rw">
        <comment>HMMSE QF MEM使用寄存器</comment>
        <bits access="r" name="used_wl_ind" pos="4" rst="0x0">
          <comment>USED_WL_IND</comment>
        </bits>
        <bits access="r" name="qf_mem_mark" pos="1:0" rst="0x0">
          <comment>QF MEM实际使用指示
00：乒mem；
01：乓mem
Other：固定mem</comment>
        </bits>
      </reg>
      <reg name="measpwr_id_info2" protect="rw">
        <comment>ID信息输出寄存器2</comment>
        <bits access="r" name="id38_info" pos="9:0" rst="0x0">
          <comment>ID38信息输出</comment>
        </bits>
      </reg>
      <reg name="measpwr_inmem_mode" protect="rw">
        <comment>INMEM使用模式选择寄存器</comment>
        <bits access="rw" name="inmem_mode" pos="1:0" rst="0x0">
          <comment>INMEM使用模式选择：
00： measpwr功能使用
01：OTDOA功能使用
10：等分共享
11：大小共享</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc1_rsrp_hst" protect="rw">
        <comment>ID1基于AFC HST的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp1_hst" pos="15:0" rst="0x0">
          <comment>基于AFC HST的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc2_rsrp_hst" protect="rw">
        <comment>ID2基于AFC HST的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp2_hst" pos="15:0" rst="0x0">
          <comment>基于AFC HST的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc3_rsrp_hst" protect="rw">
        <comment>ID3基于AFC HST的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp3_hst" pos="15:0" rst="0x0">
          <comment>基于AFC HST的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc4_rsrp_hst" protect="rw">
        <comment>ID4基于AFC HST的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp4_hst" pos="15:0" rst="0x0">
          <comment>基于AFC HST的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc5_rsrp_hst" protect="rw">
        <comment>ID5基于AFC HST的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp5_hst" pos="15:0" rst="0x0">
          <comment>基于AFC HST的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc6_rsrp_hst" protect="rw">
        <comment>ID6基于AFC HST的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp6_hst" pos="15:0" rst="0x0">
          <comment>基于AFC HST的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc7_rsrp_hst" protect="rw">
        <comment>ID7基于AFC HST的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp7_hst" pos="15:0" rst="0x0">
          <comment>基于AFC HST的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc8_rsrp_hst" protect="rw">
        <comment>ID8基于AFC HST的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp8_hst" pos="15:0" rst="0x0">
          <comment>基于AFC HST的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_powmax1_scale" protect="rw">
        <comment>ID1 POWMAX SCALE值寄存器</comment>
      </reg>
      <reg name="measpwr_powmax2_scale" protect="rw">
        <comment>ID2 POWMAX SCALE值寄存器</comment>
      </reg>
      <reg name="measpwr_powmax3_scale" protect="rw">
        <comment>ID3 POWMAX SCALE值寄存器</comment>
      </reg>
      <reg name="measpwr_powmax4_scale" protect="rw">
        <comment>ID4 POWMAX SCALE值寄存器</comment>
      </reg>
      <reg name="measpwr_powmax5_scale" protect="rw">
        <comment>ID5 POWMAX SCALE值寄存器</comment>
      </reg>
      <reg name="measpwr_powmax6_scale" protect="rw">
        <comment>ID6 POWMAX SCALE值寄存器</comment>
      </reg>
      <reg name="measpwr_powmax7_scale" protect="rw">
        <comment>ID7 POWMAX SCALE值寄存器</comment>
      </reg>
      <reg name="measpwr_powmax8_scale" protect="rw">
        <comment>ID8 POWMAX SCALE值寄存器</comment>
      </reg>
      <reg name="measpwr_afc6_out" protect="rw">
        <comment>ID6 AFC输出寄存器</comment>
        <bits access="r" name="afc_out6" pos="15:0" rst="0x0">
          <comment>AFC输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc7_out" protect="rw">
        <comment>ID7 AFC输出寄存器</comment>
        <bits access="r" name="afc_out7" pos="15:0" rst="0x0">
          <comment>AFC输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc8_out" protect="rw">
        <comment>ID8 AFC输出寄存器</comment>
        <bits access="r" name="afc_out8" pos="15:0" rst="0x0">
          <comment>AFC输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc6_rsrp" protect="rw">
        <comment>ID6基于AFC的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp6" pos="15:0" rst="0x0">
          <comment>基于AFC的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc7_rsrp" protect="rw">
        <comment>ID7基于AFC的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp7" pos="15:0" rst="0x0">
          <comment>基于AFC的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc8_rsrp" protect="rw">
        <comment>ID8基于AFC的RSRP db值输出寄存器</comment>
        <bits access="r" name="afc_rsrp8" pos="15:0" rst="0x0">
          <comment>基于AFC的RSRP db输出结果</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler3_bef1" protect="rw">
        <comment>ID3 DOPPLER平滑前输出寄存器1</comment>
      </reg>
      <reg name="measpwr_doppler3_bef2" protect="rw">
        <comment>ID3 DOPPLER平滑前输出寄存器2</comment>
      </reg>
      <reg name="measpwr_doppler4_bef1" protect="rw">
        <comment>ID4 DOPPLER平滑前输出寄存器1</comment>
      </reg>
      <reg name="measpwr_doppler4_bef2" protect="rw">
        <comment>ID4 DOPPLER平滑前输出寄存器2</comment>
      </reg>
      <reg name="measpwr_doppler5_bef1" protect="rw">
        <comment>ID5 DOPPLER平滑前输出寄存器1</comment>
      </reg>
      <reg name="measpwr_doppler5_bef2" protect="rw">
        <comment>ID5 DOPPLER平滑前输出寄存器2</comment>
      </reg>
      <reg name="measpwr_doppler6_bef1" protect="rw">
        <comment>ID6 DOPPLER平滑前输出寄存器1</comment>
      </reg>
      <reg name="measpwr_doppler6_bef2" protect="rw">
        <comment>ID6 DOPPLER平滑前输出寄存器2</comment>
      </reg>
      <reg name="measpwr_doppler7_bef1" protect="rw">
        <comment>ID7 DOPPLER平滑前输出寄存器1</comment>
      </reg>
      <reg name="measpwr_doppler7_bef2" protect="rw">
        <comment>ID7 DOPPLER平滑前输出寄存器2</comment>
      </reg>
      <reg name="measpwr_doppler8_bef1" protect="rw">
        <comment>ID8 DOPPLER平滑前输出寄存器1</comment>
      </reg>
      <reg name="measpwr_doppler8_bef2" protect="rw">
        <comment>ID8 DOPPLER平滑前输出寄存器2</comment>
      </reg>
      <reg name="measpwr_offline1_agc7" protect="rw">
        <comment>OFFLINE模式1AGC寄存器7</comment>
        <bits access="rw" name="offline1_agc20" pos="19:10" rst="0x0">
          <comment>子帧20AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc19" pos="9:0" rst="0x0">
          <comment>子帧19AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_int_join" protect="rw">
        <comment>MEASPWR中断关联寄存器</comment>
        <bits access="rw" name="interrupt_join_flag" pos="7:0" rst="0x0">
          <comment>中断关联标志，bit[7:0]分别对应id8-id1
0:不关联
1：关联</comment>
        </bits>
      </reg>
      <reg name="measpwr_int_mark" protect="rw">
        <comment>MEASPWR中断记录寄存器</comment>
        <bits access="r" name="id8_interrupt_mark" pos="31:28" rst="0x0">
          <comment>同ID1</comment>
        </bits>
        <bits access="r" name="id7_interrupt_mark" pos="27:24" rst="0x0">
          <comment>同ID1</comment>
        </bits>
        <bits access="r" name="id6_interrupt_mark" pos="23:20" rst="0x0">
          <comment>同ID1</comment>
        </bits>
        <bits access="r" name="id5_interrupt_mark" pos="19:16" rst="0x0">
          <comment>同ID1</comment>
        </bits>
        <bits access="r" name="id4_interrupt_mark" pos="15:12" rst="0x0">
          <comment>同ID1</comment>
        </bits>
        <bits access="r" name="id3_interrupt_mark" pos="11:8" rst="0x0">
          <comment>同ID1</comment>
        </bits>
        <bits access="r" name="id2_interrupt_mark" pos="7:4" rst="0x0">
          <comment>同ID1</comment>
        </bits>
        <bits access="r" name="id1_interrupt_mark" pos="3:0" rst="0x0">
          <comment>ID1的中断标志，1有效，0无效
bit[0]：样本结束\offine结束中断标志
bit[1]：门限值达到中断标志
bit[2]：AFC结果输出中断标志
bit[3]：Agc_compare门限达到标志</comment>
        </bits>
      </reg>
      <reg name="measpwr_int_flag" protect="rw">
        <comment>MEASPWR中断标志寄存器</comment>
        <bits access="r" name="interrupt_flag" pos="7:0" rst="0x0">
          <comment>中断标志，bit[7:0]分别对应id8-id1
0：无效
1：有效</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos1" protect="rw">
        <comment>OFFLINE模式0判决位置寄存器1</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID1判决位置3</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID1判决位置2</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID1判决位置1</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos2" protect="rw">
        <comment>OFFLINE模式0判决位置寄存器2</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID2判决位置3</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID2判决位置2</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID2判决位置1</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos3" protect="rw">
        <comment>OFFLINE模式0判决位置寄存器3</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID3判决位置3</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID3判决位置2</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID3判决位置1</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos4" protect="rw">
        <comment>OFFLINE模式0判决位置寄存器4</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID4判决位置3</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID4判决位置2</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID4判决位置1</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos5" protect="rw">
        <comment>OFFLINE模式0判决位置寄存器5</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID5判决位置3</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID5判决位置2</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID5判决位置1</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos6" protect="rw">
        <comment>OFFLINE模式0判决位置寄存器6</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID6判决位置3</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID6判决位置2</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID6判决位置1</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos7" protect="rw">
        <comment>OFFLINE模式0判决位置寄存器7</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID7判决位置3</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID7判决位置2</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID7判决位置1</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos8" protect="rw">
        <comment>OFFLINE模式0判决位置寄存器8</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID8判决位置3</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID8判决位置2</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID8判决位置1</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_para2" protect="rw">
        <comment>RBIS参数寄存器2</comment>
        <bits access="rw" name="rbis_correct" pos="29" rst="0x0">
          <comment>ID3-8 RBIS CORRECT使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rbis_judge" pos="28" rst="0x0">
          <comment>ID3-8 RBIS JUDGE使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rbis_en" pos="27" rst="0x0">
          <comment>ID3-8 RBIS使能：
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="rbis_posen" pos="26" rst="0x0">
          <comment>ID3-8 RBIS使用直接位置指示：
0：不使用直接位置
1：使用直接位置</comment>
        </bits>
        <bits access="rw" name="rbis_num" pos="25:23" rst="0x0">
          <comment>ID3-8 RBIS检测个数：
0：1
1：2
2：3
3：4
4：5</comment>
        </bits>
        <bits access="rw" name="rbis_dipos" pos="22:16" rst="0x0">
          <comment>ID3-8 RBIS的直接位置</comment>
        </bits>
        <bits access="rw" name="rbis_factor" pos="15:0" rst="0x0">
          <comment>ID3-8 RBIS因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis2_out1" protect="rw">
        <comment>RBIS ID2 输出寄存器1</comment>
        <bits access="r" name="rbis_out3" pos="30:24" rst="0x0">
          <comment>ID2第4强RBI所处PRB索引</comment>
        </bits>
        <bits access="r" name="rbis_out2" pos="22:16" rst="0x0">
          <comment>ID2第3强RBI所处PRB索引</comment>
        </bits>
        <bits access="r" name="rbis_out1" pos="14:8" rst="0x0">
          <comment>ID2第2强RBI所处PRB索引</comment>
        </bits>
        <bits access="r" name="rbis_out0" pos="6:0" rst="0x0">
          <comment>ID2第1强RBI所处PRB索引</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis2_out2" protect="rw">
        <comment>RBIS ID2输出寄存器2</comment>
        <bits access="r" name="rbis_num" pos="10:8" rst="0x0">
          <comment>ID2 RBIS JUDGE个数</comment>
        </bits>
        <bits access="r" name="rbis_out4" pos="6:0" rst="0x0">
          <comment>ID2第5强RBI所处PRB索引</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis2_ave" protect="rw">
        <comment>RBIS ID2 AVE输出寄存器</comment>
      </reg>
      <reg name="measpwr_rbis2_max" protect="rw">
        <comment>RBIS ID2 MAX输出寄存器</comment>
        <bits access="r" name="rbis_max" pos="24:0" rst="0x0">
          <comment>ID2 RBIS检测出的最大值</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis3_out1" protect="rw">
        <comment>RBIS ID3-8 输出寄存器1</comment>
        <bits access="r" name="rbis_out3" pos="30:24" rst="0x0">
          <comment>ID3-8第4强RBI所处PRB索引</comment>
        </bits>
        <bits access="r" name="rbis_out2" pos="22:16" rst="0x0">
          <comment>ID3-8第3强RBI所处PRB索引</comment>
        </bits>
        <bits access="r" name="rbis_out1" pos="14:8" rst="0x0">
          <comment>ID3-8第2强RBI所处PRB索引</comment>
        </bits>
        <bits access="r" name="rbis_out0" pos="6:0" rst="0x0">
          <comment>ID3-8第1强RBI所处PRB索引</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis3_out2" protect="rw">
        <comment>RBIS ID3-8输出寄存器2</comment>
        <bits access="r" name="rbis_num" pos="10:8" rst="0x0">
          <comment>ID3-8 RBIS JUDGE个数</comment>
        </bits>
        <bits access="r" name="rbis_out4" pos="6:0" rst="0x0">
          <comment>ID3-8第5强RBI所处PRB索引</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis3_ave" protect="rw">
        <comment>RBIS ID3-8 AVE输出寄存器</comment>
      </reg>
      <reg name="measpwr_rbis3_max" protect="rw">
        <comment>RBIS ID3-8 MAX输出寄存器</comment>
        <bits access="r" name="rbis_max" pos="24:0" rst="0x0">
          <comment>ID3-8 RBIS检测出的最大值</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt_scale2_th1" protect="rw">
        <comment>IRT ID3-8 Scale1门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th2" protect="rw">
        <comment>IRT  ID3-8 Scale2门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th4" protect="rw">
        <comment>IRT  ID3-8 Scale4门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th8" protect="rw">
        <comment>IRT  ID3-8 Scale8门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th16" protect="rw">
        <comment>IRT  ID3-8 Scale16门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th32" protect="rw">
        <comment>IRT  ID3-8 Scale32门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th64" protect="rw">
        <comment>IRT  ID3-8 Scale64门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th128" protect="rw">
        <comment>IRT  ID3-8 Scale128门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th256" protect="rw">
        <comment>IRT  ID3-8 Scale256门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th512" protect="rw">
        <comment>IRT  ID3-8 Scale512门限参数值寄存器</comment>
      </reg>
      <reg name="measpwr_sigpwr_para2" protect="rw">
        <comment>Sigpwr配置寄存器2</comment>
        <bits access="rw" name="sigpwr_renum" pos="7:0" rst="0x0">
          <comment>ID3-8 SIGPWR计算频域相关个数（按实际数据个数配置）</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt_para3" protect="rw">
        <comment>IRT参数配置寄存器2</comment>
        <bits access="rw" name="s_th" pos="31:16" rst="0x0">
          <comment>ID3-8信号门限因子</comment>
        </bits>
        <bits access="rw" name="n_th" pos="15:0" rst="0x0">
          <comment>id3-8噪声门限因子（有符号的，16q10，正数）</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms_para3" protect="rw">
        <comment>TRMS配置寄存器3</comment>
        <bits access="rw" name="s_th" pos="31:16" rst="0x0">
          <comment>ID3-8信号门限因子（有符号的，16q15，正数）</comment>
        </bits>
        <bits access="rw" name="n_th" pos="15:0" rst="0x0">
          <comment>ID3-8噪声门限因子（有符号的，16q10，正数）</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp_para5" protect="rw">
        <comment>RSRP配置寄存器5</comment>
        <bits access="rw" name="beta" pos="31:16" rst="0x0">
          <comment>id3-8噪声门限因子beta值（有符号的16Q10，只能配置为正数）</comment>
        </bits>
        <bits access="rw" name="s_th" pos="15:0" rst="0x0">
          <comment>ID3-8信号门限因子</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_in1" protect="rw">
        <comment>RBIS ID1 输入寄存器1</comment>
        <bits access="rw" name="rbis_in3" pos="30:24" rst="0x0">
          <comment>ID1第4强RBI所处PRB索引</comment>
        </bits>
        <bits access="rw" name="rbis_in2" pos="22:16" rst="0x0">
          <comment>ID1第3强RBI所处PRB索引</comment>
        </bits>
        <bits access="r" name="reserced3" pos="15" rst="0x0"/>
        <bits access="rw" name="rbis_in1" pos="14:8" rst="0x0">
          <comment>ID1第2强RBI所处PRB索引</comment>
        </bits>
        <bits access="rw" name="rbis_in0" pos="6:0" rst="0x0">
          <comment>ID1第1强RBI所处PRB索引</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_in2" protect="rw">
        <comment>RBIS ID1 输入寄存器2</comment>
        <bits access="rw" name="rbis_in_num" pos="10:8" rst="0x0">
          <comment>ID1 RBIS JUDGE个数</comment>
        </bits>
        <bits access="rw" name="rbis_in4" pos="6:0" rst="0x0">
          <comment>ID1第5强RBI所处PRB索引</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis2_in1" protect="rw">
        <comment>RBIS ID2输入寄存器1</comment>
        <bits access="rw" name="rbis_in3" pos="30:24" rst="0x0">
          <comment>ID2第4强RBI所处PRB索引</comment>
        </bits>
        <bits access="rw" name="rbis_in2" pos="22:16" rst="0x0">
          <comment>ID2第3强RBI所处PRB索引</comment>
        </bits>
        <bits access="r" name="reserced3" pos="15" rst="0x0"/>
        <bits access="rw" name="rbis_in1" pos="14:8" rst="0x0">
          <comment>ID2第2强RBI所处PRB索引</comment>
        </bits>
        <bits access="rw" name="rbis_in0" pos="6:0" rst="0x0">
          <comment>ID2第1强RBI所处PRB索引</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis2_in2" protect="rw">
        <comment>RBIS ID2输入寄存器2</comment>
        <bits access="rw" name="rbis_in_num" pos="10:8" rst="0x0">
          <comment>ID2 RBIS JUDGE个数</comment>
        </bits>
        <bits access="rw" name="rbis_in4" pos="6:0" rst="0x0">
          <comment>ID2第5强RBI所处PRB索引</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis3_in1" protect="rw">
        <comment>RBIS ID3-8输入寄存器1</comment>
        <bits access="rw" name="rbis_in3" pos="30:24" rst="0x0">
          <comment>ID3-8第4强RBI所处PRB索引</comment>
        </bits>
        <bits access="rw" name="rbis_in2" pos="22:16" rst="0x0">
          <comment>ID3-8第3强RBI所处PRB索引</comment>
        </bits>
        <bits access="r" name="reserced3" pos="15" rst="0x0"/>
        <bits access="rw" name="rbis_in1" pos="14:8" rst="0x0">
          <comment>ID3-8第2强RBI所处PRB索引</comment>
        </bits>
        <bits access="rw" name="rbis_in0" pos="6:0" rst="0x0">
          <comment>ID3-8第1强RBI所处PRB索引</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis3_in2" protect="rw">
        <comment>RBIS ID3-8输入寄存器2</comment>
        <bits access="rw" name="rbis_in_num" pos="10:8" rst="0x0">
          <comment>ID3-8 RBIS JUDGE个数</comment>
        </bits>
        <bits access="rw" name="rbis_in4" pos="6:0" rst="0x0">
          <comment>ID3-8第5强RBI所处PRB索引</comment>
        </bits>
      </reg>
      <hole size="1034944"/>
      <reg name="mem_in_1" protect="rw">
        <bits access="rw" name="mem_in_1" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem_in_2" protect="rw">
        <bits access="rw" name="mem_in_2" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem_in_3" protect="rw">
        <bits access="rw" name="mem_in_3" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem_in_4" protect="rw">
        <bits access="rw" name="mem_in_4" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem_in_5" protect="rw">
        <bits access="rw" name="mem_in_5" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="mem_in_6" protect="rw">
        <bits access="rw" name="mem_in_6" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="mem_in_7" protect="rw">
        <bits access="rw" name="mem_in_7" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="mem_in_8" protect="rw">
        <bits access="rw" name="mem_in_8" pos="23:0" rst="0x0"/>
      </reg>
    </module>
    <instance address="0x18500000" name="MEASPWR" type="MEASPWR"/>
  </archive>
  <archive relative="iddet.xml">
    <module category="System" name="IDDET">
      <reg name="iddet_start" protect="rw">
        <comment>启动寄存器</comment>
        <bits access="rw" name="rd_pre_pwr" pos="27" rst="0x0">
          <comment>产生DMA请求把以前计算出的累加功率搬入IDDET，用于续接计算。
0:不产生请求
1:产生请求</comment>
        </bits>
        <bits access="rw" name="save_last_pwr" pos="26" rst="0x0">
          <comment>产生DMA请求把最后一个样本计算出的累加功率存入外部MEM，在续接计算时使用。
0:不产生请求
1:产生请求</comment>
        </bits>
        <bits access="rw" name="sample_len" pos="25:12" rst="0x0">
          <comment>非连续模式下样本长度不足5ms+2OFDM时的样本长度：
取值范围：1~9856点</comment>
        </bits>
        <bits access="rw" name="sample_num" pos="11:8" rst="0x0">
          <comment>非连续模式下接收数据样本数
4’b000: 数据不足5ms+2OFDM
4’b0001: 1个样本
……
4’b1111: 15个样本</comment>
        </bits>
        <bits access="rw" name="rec_continuity" pos="7" rst="0x1">
          <comment>0: 接收数据非连续
1:接收数据连续</comment>
        </bits>
        <bits access="rw" name="flow_sel" pos="6:4" rst="0x0">
          <comment>3’b001: PSS粗同步
3’b010: PSS精同步
3’b011: SSS同步
3’b100: 频率精同步和小区有效性判断
3’b101:重同步
3’b110:频点盲搜</comment>
        </bits>
        <bits access="rw" name="txrx_offset_en" pos="3" rst="0x0">
          <comment>TXRX接收数据OFFSET使能
1:OFFSET使能
0:OFFSET不使能</comment>
        </bits>
        <bits access="rw" name="data_move_out" pos="2" rst="0x0">
          <comment>1: TXRX接收数据搬出DMA请求使能;
0: TXRX接收数据搬出DMA请求不使能</comment>
        </bits>
        <bits access="rw" name="iddet_stop" pos="1" rst="0x0">
          <comment>1: IDDET模块暂停中
0: IDDET 模块已暂停或暂停未使能</comment>
        </bits>
        <bits access="rw" name="iddet_start" pos="0" rst="0x0">
          <comment>1: IDDET模块启动
0: IDDET 模块不启动</comment>
        </bits>
      </reg>
      <reg name="pss1_ctrl" protect="rw">
        <comment>PSS1_CTRL粗同步控制寄存器</comment>
        <bits access="rw" name="rssi_en" pos="16" rst="0x1">
          <comment>RSSI计算使能</comment>
        </bits>
        <bits access="rw" name="output_num" pos="15:12" rst="0x3">
          <comment>PSS输出主节点数.取值范围1~12，纠本地频偏使能时输出5个节点，每个频偏一个；纠本地频偏不使能时最多输出12个节点</comment>
        </bits>
        <bits access="rw" name="max_num" pos="10:8" rst="0x1">
          <comment>最大值个数保存,取值范围1~5</comment>
        </bits>
        <bits access="rw" name="flow_mode_sel" pos="7" rst="0x0">
          <comment>0: ICS流程;1: IDDET流程</comment>
        </bits>
        <bits access="rw" name="ppm_en" pos="6" rst="0x1">
          <comment>0: 定时漂移不使能 0: 定时漂移不使能</comment>
        </bits>
        <bits access="rw" name="id_mode_sel" pos="5:4" rst="0x0">
          <comment>0: ID2未知  1: ID2已知为0  2: ID2已知为1  3: ID2已知为2</comment>
        </bits>
        <bits access="rw" name="localpss_freq_en" pos="3:2" rst="0x3">
          <comment>0: 纠本地频偏不使能  1: 本地频偏尝试为1
2: 本地频偏尝试为3  3: 本地频偏尝试为5</comment>
        </bits>
        <bits access="rw" name="dagc_en" pos="1" rst="0x1">
          <comment>0: 数字AGC不使能  1: 数字AGC使能</comment>
        </bits>
        <bits access="rw" name="dc_en" pos="0" rst="0x1">
          <comment>0: 输入消直以及搬数使能不使能   1: 输入消直以及搬数使能使能</comment>
        </bits>
      </reg>
      <reg name="pss2_ctrl" protect="rw">
        <comment>PSS2_CTRL精同步控制寄存器</comment>
        <bits access="rw" name="rssi_en" pos="8" rst="0x1">
          <comment>RSSI计算使能</comment>
        </bits>
        <bits access="rw" name="pos_num" pos="7:4" rst="0x3">
          <comment>精同步计算点数 取值范围1~12</comment>
        </bits>
        <bits access="rw" name="ppm_en" pos="3" rst="0x1">
          <comment>1:定时漂移使能
0:定时漂移不使能</comment>
        </bits>
        <bits access="rw" name="localpss_freq_en" pos="2" rst="0x1">
          <comment>1: 纠本地频偏使能
0: 纠本地频偏不使能</comment>
        </bits>
        <bits access="rw" name="dagc_en" pos="1" rst="0x1">
          <comment>1: 数字AGC使能
0: 数字AGC不使能</comment>
        </bits>
        <bits access="rw" name="dc_en" pos="0" rst="0x1">
          <comment>1: 接收数据消直使能
0: 接收数据消直不使能</comment>
        </bits>
      </reg>
      <reg name="sss_ctrl" protect="rw">
        <comment>SSS_CTRL无线帧同步控制寄存器</comment>
        <bits access="rw" name="rssi_en" pos="27" rst="0x1">
          <comment>RSSI计算使能</comment>
        </bits>
        <bits access="rw" name="pos_slide_num" pos="26:25" rst="0x0">
          <comment>输入位置滑动计算次数
0:不进行左右滑动
1:左右分别滑动1个点
2:左右分别滑动2个点
3:左右分别滑动4个点</comment>
        </bits>
        <bits access="rw" name="sort_sel" pos="24" rst="0x0">
          <comment>0:峰均比排序
1:峰值排序</comment>
        </bits>
        <bits access="rw" name="normalsort_num" pos="23:20" rst="0x0">
          <comment>每个节点输出最大值个数
1~10</comment>
        </bits>
        <bits access="rw" name="nid1" pos="19:12" rst="0x0">
          <comment>NID1值，ID已知时起效  取值范围为0~168</comment>
        </bits>
        <bits access="rw" name="pos_num" pos="11:8" rst="0x3">
          <comment>无线帧同步计算点数  ICS和IDDET时取值范围为1~12</comment>
        </bits>
        <bits access="rw" name="ppm_en" pos="7" rst="0x1">
          <comment>1:定时漂移使能
0:定时漂移不使能</comment>
        </bits>
        <bits access="rw" name="flow_mode_sel" pos="6" rst="0x0">
          <comment>0:ICS流程
1: ID DETECT流程</comment>
        </bits>
        <bits access="rw" name="id_mode_sel" pos="5" rst="0x0">
          <comment>1: ID已知   0: ID未知</comment>
        </bits>
        <bits access="rw" name="fdd_tdd_sel" pos="4" rst="0x0">
          <comment>1: FDD模式  0: TDD模式</comment>
        </bits>
        <bits access="rw" name="ic_en" pos="3" rst="0x1">
          <comment>1: 干扰消除使能
0: 干扰消除不使能</comment>
        </bits>
        <bits access="rw" name="freq_en" pos="2" rst="0x1">
          <comment>1: 干扰消除使能
0: 干扰消除不使能</comment>
        </bits>
        <bits access="rw" name="dagc_en" pos="1" rst="0x1">
          <comment>1: 数字AGC使能
0: 数字AGC不使能</comment>
        </bits>
        <bits access="rw" name="dc_en" pos="0" rst="0x1">
          <comment>1: 接收数据消直使能
0: 接收数据消直不使能</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_ctrl" protect="rw">
        <comment>频率精同步和小区有效性判断控制寄存器</comment>
        <bits access="rw" name="rssi_en" pos="18" rst="0x1">
          <comment>RSSI计算使能</comment>
        </bits>
        <bits access="rw" name="pos_slide_num" pos="17:16" rst="0x0">
          <comment>输入位置滑动计算次数
0:不进行左右滑动
1:左右分别滑动1个点
2:左右分别滑动2个点
3:左右分别滑动4个点</comment>
        </bits>
        <bits access="rw" name="pos_num" pos="15:12" rst="0x3">
          <comment>频率精同步和小区有效性判断计算点数 取值范围为1~12</comment>
        </bits>
        <bits access="rw" name="slide_num" pos="10:8" rst="0x4">
          <comment>频率精同步时，PSS与SSS滑动相关的滑动步长M：取值为0~4</comment>
        </bits>
        <bits access="rw" name="fdd_tdd_sel" pos="5" rst="0x0">
          <comment>1: FDD模式
0: TDD模式</comment>
        </bits>
        <bits access="rw" name="freq_en" pos="4" rst="0x1">
          <comment>1: 频偏纠正使能
0: 频偏纠正不使能</comment>
        </bits>
        <bits access="rw" name="freqitm_en" pos="3" rst="0x1">
          <comment>1: 频率精同步使能
0: 频率精同步不使能</comment>
        </bits>
        <bits access="rw" name="ppm_en" pos="2" rst="0x1">
          <comment>1:定时漂移使能
0:定时漂移不使能</comment>
        </bits>
        <bits access="rw" name="dagc_en" pos="1" rst="0x1">
          <comment>1: 数字AGC使能
0: 数字AGC不使能</comment>
        </bits>
        <bits access="rw" name="dc_en" pos="0" rst="0x1">
          <comment>1: 接收数据消直使能
0: 接收数据消直不使能</comment>
        </bits>
      </reg>
      <reg name="resync_ctrl" protect="rw">
        <comment>RESYNC_CTRL重同步控制寄存器</comment>
        <bits access="rw" name="rssi_en" pos="21" rst="0x1">
          <comment>RSSI计算使能</comment>
        </bits>
        <bits access="rw" name="data_len" pos="20:18" rst="0x1">
          <comment>一个样本输入数据长度
0:1ms
1:2ms
2:3ms
3:4ms
4:5ms</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="17:16" rst="0x0">
          <comment>00:子帧未知  01: 子帧0   10: 子帧5</comment>
        </bits>
        <bits access="rw" name="max_num" pos="14:12" rst="0x1">
          <comment>最大值个数保存 取值范围1~5</comment>
        </bits>
        <bits access="rw" name="id1" pos="11:4" rst="0x0">
          <comment>ID1值  取值范围0~167</comment>
        </bits>
        <bits access="rw" name="id2" pos="3:2" rst="0x0">
          <comment>ID2值  取值范围0~2</comment>
        </bits>
        <bits access="rw" name="dagc_en" pos="1" rst="0x1">
          <comment>0: 数字AGC不使能
1: 数字AGC使能</comment>
        </bits>
        <bits access="rw" name="dc_en" pos="0" rst="0x1">
          <comment>0: 输入消直以及搬数使能不使能
1: 输入消直以及搬数使能使能</comment>
        </bits>
      </reg>
      <reg name="shift_ctrl0" protect="rw">
        <comment>频率移位控制寄存器0</comment>
        <bits access="rw" name="pwr_acc_s3" pos="31:28" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s3" pos="27:24" rst="0x0">
          <comment>接收数据RSSI移位值 取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s2" pos="23:20" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s2" pos="19:16" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s1" pos="15:12" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s1" pos="11:8" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s0" pos="7:4" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s0" pos="3:0" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
      </reg>
      <reg name="shift_ctrl1" protect="rw">
        <comment>频率移位控制寄存器1</comment>
        <bits access="rw" name="pwr_acc_s7" pos="31:28" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s7" pos="27:24" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s6" pos="23:20" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s6" pos="19:16" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s5" pos="15:12" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s5" pos="11:8" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s4" pos="7:4" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s4" pos="3:0" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
      </reg>
      <reg name="shift_ctrl2" protect="rw">
        <comment>频率移位控制寄存器2</comment>
        <bits access="rw" name="pwr_acc_s9" pos="15:12" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s9" pos="11:8" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s8" pos="7:4" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s8" pos="3:0" rst="0x0">
          <comment>接收数据RSSI移位值  取值范围-8~7</comment>
        </bits>
      </reg>
      <reg name="int_ctrl" protect="rw">
        <comment>INT_CTRL中断控制寄存器</comment>
        <bits access="rw" name="discon_section_fin_irq_en" pos="10" rst="0x1">
          <comment>1:非连续接收单次计算完成断使能
0:完成状态已清除或未产生中断不使能</comment>
        </bits>
        <bits access="rw" name="freq_search_irq_en" pos="9" rst="0x1">
          <comment>1: 频率盲搜1个子段搜索完成中断使能
0: 频率盲搜1个子段搜索完成中断不使能</comment>
        </bits>
        <bits access="rw" name="rssi_en" pos="8" rst="0x1">
          <comment>1:RSSI值计算完成中断使能
0: RSSI值计算完成中断不使能</comment>
        </bits>
        <bits access="rw" name="stop" pos="7" rst="0x1">
          <comment>1:暂停中断使能
0: 暂停中断不使能</comment>
        </bits>
        <bits access="rw" name="error_irq_en" pos="6" rst="0x1">
          <comment>1: AXIDMA搬数错误中断使能
0: AXIDMA搬数错误中断不使能</comment>
        </bits>
        <bits access="rw" name="txrx_suspend_irq_en" pos="5" rst="0x1">
          <comment>1:TXRX接收数据暂停中断使能
0: TXRX接收数据暂停中断不使能</comment>
        </bits>
        <bits access="rw" name="resync_fin_irq_en" pos="4" rst="0x1">
          <comment>1:重同步完成中断使能
0:重同步完成中断不使能</comment>
        </bits>
        <bits access="rw" name="freq_idident_fin_irq_en" pos="3" rst="0x1">
          <comment>1:频率精同步和小区有效性判断完成中断使能
0: 频率精同步和小区有效性判断完成中断不使能</comment>
        </bits>
        <bits access="rw" name="sss_fin_irq_en" pos="2" rst="0x1">
          <comment>1:SSS同步完成中断使能
0: SSS同步完成中断不使能</comment>
        </bits>
        <bits access="rw" name="pssitm_fin_irq_en" pos="1" rst="0x1">
          <comment>1:PSS精同步完成中断使能
0: PSS精同步完成中断不使能</comment>
        </bits>
        <bits access="rw" name="pssgru_fin_irq_en" pos="0" rst="0x1">
          <comment>1:PSS粗同步完成中断使能
0: PSS粗同步完成中断不使能</comment>
        </bits>
      </reg>
      <reg name="pos_offset" protect="rw">
        <comment>PSS精同步/SSS同步接收数据起始位置配置寄存器</comment>
        <bits access="rw" name="pss1_rssi_th" pos="31:16" rst="0x0">
          <comment>粗同步RSSI门限值</comment>
        </bits>
        <bits access="rw" name="pssitm_sss_offset_pos" pos="14:0" rst="0x0">
          <comment>PSS粗同步TXRX输入第一个数据的位置为0，PSS精同步和SSS同步TXRX
输入第一个数据相对0位置的值：0~19200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl1" protect="rw">
        <comment>SAM_NUM_CTRL 样本自适应控制寄存器</comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>计算样本  取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl2" protect="rw">
        <comment>SAM_NUM_CTRL 样本自适应控制寄存器</comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>计算样本  取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl3" protect="rw">
        <comment>SAM_NUM_CTRL 样本自适应控制寄存器</comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>计算样本  取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl4" protect="rw">
        <comment>SAM_NUM_CTRL 样本自适应控制寄存器</comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>计算样本  取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl5" protect="rw">
        <comment>SAM_NUM_CTRL 样本自适应控制寄存器</comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>计算样本  取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl6" protect="rw">
        <comment>SAM_NUM_CTRL 样本自适应控制寄存器</comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>计算样本  取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl7" protect="rw">
        <comment>SAM_NUM_CTRL 样本自适应控制寄存器</comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>计算样本  取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl8" protect="rw">
        <comment>SAM_NUM_CTRL 样本自适应控制寄存器</comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>计算样本  取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl9" protect="rw">
        <comment>SAM_NUM_CTRL 样本自适应控制寄存器</comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>计算样本  取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl10" protect="rw">
        <comment>SAM_NUM_CTRL 样本自适应控制寄存器</comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>计算样本  取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="end_threshold1" protect="rw">
        <comment>样本组对应峰均比判别门限寄存器</comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>样本组对应峰均比判别门限值1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>样本组对应峰均比判别门限值0</comment>
        </bits>
      </reg>
      <reg name="end_threshold2" protect="rw">
        <comment>样本组对应峰均比判别门限寄存器</comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>样本组对应峰均比判别门限值1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>样本组对应峰均比判别门限值0</comment>
        </bits>
      </reg>
      <reg name="end_threshold3" protect="rw">
        <comment>样本组对应峰均比判别门限寄存器</comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>样本组对应峰均比判别门限值1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>样本组对应峰均比判别门限值0</comment>
        </bits>
      </reg>
      <reg name="end_threshold4" protect="rw">
        <comment>样本组对应峰均比判别门限寄存器</comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>样本组对应峰均比判别门限值1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>样本组对应峰均比判别门限值0</comment>
        </bits>
      </reg>
      <reg name="end_threshold5" protect="rw">
        <comment>样本组对应峰均比判别门限寄存器</comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>样本组对应峰均比判别门限值1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>样本组对应峰均比判别门限值0</comment>
        </bits>
      </reg>
      <reg name="end_threshold6" protect="rw">
        <comment>样本组对应峰均比判别门限寄存器</comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>样本组对应峰均比判别门限值1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>样本组对应峰均比判别门限值0</comment>
        </bits>
      </reg>
      <reg name="end_threshold7" protect="rw">
        <comment>样本组对应峰均比判别门限寄存器</comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>样本组对应峰均比判别门限值1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>样本组对应峰均比判别门限值0</comment>
        </bits>
      </reg>
      <reg name="end_threshold8" protect="rw">
        <comment>样本组对应峰均比判别门限寄存器</comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>样本组对应峰均比判别门限值1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>样本组对应峰均比判别门限值0</comment>
        </bits>
      </reg>
      <reg name="end_threshold9" protect="rw">
        <comment>样本组对应峰均比判别门限寄存器</comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>样本组对应峰均比判别门限值1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>样本组对应峰均比判别门限值0</comment>
        </bits>
      </reg>
      <reg name="end_threshold10" protect="rw">
        <comment>样本组对应峰均比判别门限寄存器</comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>样本组对应峰均比判别门限值1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>样本组对应峰均比判别门限值0</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para1" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para2" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para3" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para4" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para5" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para6" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para7" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para8" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para9" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para10" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para11" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para12" protect="rw">
        <comment>PSS精同步ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para1" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para2" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para3" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para4" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para5" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para6" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para7" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para8" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para9" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para10" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para11" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="sss_id_para12" protect="rw">
        <comment>SSS ID配置寄存器</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应频偏：取值范围-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSS粗同步计算出的每个ID对应的定时漂移：取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：1：子帧5  0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para1" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para2" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para3" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para4" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para5" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para6" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para7" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para8" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para9" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para10" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para11" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para12" protect="rw">
        <comment>频率精同步和ID有效性判断 ID配置寄存器</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>频率精同步和小区有效性判断参数NID1  取值范围0-167</comment>
        </bits>
      </reg>
      <reg name="id_postion1" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion2" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion3" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion4" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion5" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion6" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion7" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion8" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion9" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion10" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion11" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion12" protect="rw">
        <comment>PSS精同步/SSS同步/频率精同步和ID有效性判断ID位置配置寄存器</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>每个ID的位置  取值范围0~9599</comment>
        </bits>
      </reg>
      <reg name="pss_sss_find" protect="rw">
        <comment>PSS_SSS_FIND配置寄存器</comment>
        <bits access="rw" name="find_win" pos="27:24" rst="0x0">
          <comment>SSSMAX查找半径长度： 可配置为小于10</comment>
        </bits>
        <bits access="rw" name="nois_win" pos="21:20" rst="0x0">
          <comment>噪声窗长度选择： 0:31  1:61  2:127</comment>
        </bits>
        <bits access="rw" name="assist_win" pos="19:18" rst="0x0">
          <comment>在IDDET PSS流程中，需要在过门限的最强节点的ASSIST_WIN半径内，将找出，MAX_NUM点中是否有未排在前POS_NUM的节点，如果有，把这些节点当做辅节点在最后输出，并保证这些点和POS_NUM中的节点不重复。</comment>
        </bits>
        <bits access="rw" name="wipe_win" pos="17:16" rst="0x0">
          <comment>多径窗半径长度：2’b00:2  2’b01:4  2’b10:8 others:2</comment>
        </bits>
        <bits access="rw" name="p2p_win" pos="15:9" rst="0x0">
          <comment>主峰与主峰的间隔半径，同时表示辅峰查找范围半径：可配置为0-127</comment>
        </bits>
        <bits access="rw" name="noisth_en" pos="8" rst="0x0">
          <comment>噪声门限使能</comment>
        </bits>
        <bits access="rw" name="nois_th" pos="7:0" rst="0x0">
          <comment>均值的乘以此系数作为噪声门限（Q3）（有符号的非零数）</comment>
        </bits>
      </reg>
      <reg name="freq_pssgru1" protect="rw">
        <comment>PSS粗同步频偏尝试配置寄存器1</comment>
        <bits access="rw" name="freq_pssgru2" pos="29:20" rst="0x0">
          <comment>PSS粗同步频偏尝试2   移位位数取值范围-1024~1023</comment>
        </bits>
        <bits access="rw" name="freq_pssgru1" pos="19:10" rst="0x38">
          <comment>PSS粗同步频偏尝试1   移位位数取值范围-1024~1023</comment>
        </bits>
        <bits access="rw" name="freq_pssgru0" pos="9:0" rst="0x2f">
          <comment>PSS粗同步频偏尝试0   移位位数取值范围-1024~1023</comment>
        </bits>
      </reg>
      <reg name="freq_pssgru2" protect="rw">
        <comment>PSS粗同步频偏尝试配置寄存器2</comment>
        <bits access="rw" name="freq_pssgru4" pos="19:10" rst="0x11">
          <comment>PSS粗同步频偏尝试4   移位位数取值范围-1024~1023</comment>
        </bits>
        <bits access="rw" name="freq_pssgru3" pos="9:0" rst="0x8">
          <comment>PSS粗同步频偏尝试3   移位位数取值范围-1024~1023</comment>
        </bits>
      </reg>
      <reg name="freq_pssitm1" protect="rw">
        <comment>PSS精同步频偏尝试配置寄存器1</comment>
        <bits access="rw" name="freq_pssitm" pos="12:0" rst="0x1448">
          <comment>PSS精同步频偏尝试  取值范围-4096~4095</comment>
        </bits>
      </reg>
      <reg name="freq_pssitm2" protect="rw">
        <comment>PSS精同步频偏尝试配置寄存器2</comment>
        <bits access="rw" name="freq_pssitm" pos="12:0" rst="0x1c18">
          <comment>PSS精同步频偏尝试  取值范围-4096~4095</comment>
        </bits>
      </reg>
      <reg name="freq_pssitm3" protect="rw">
        <comment>PSS精同步频偏尝试配置寄存器3</comment>
        <bits access="rw" name="freq_pssitm" pos="12:0" rst="0x3e8">
          <comment>PSS精同步频偏尝试  取值范围-4096~4095</comment>
        </bits>
      </reg>
      <reg name="freq_pssitm4" protect="rw">
        <comment>PSS精同步频偏尝试配置寄存器4</comment>
        <bits access="rw" name="freq_pssitm" pos="12:0" rst="0xbb8">
          <comment>PSS精同步频偏尝试  取值范围-4096~4095</comment>
        </bits>
      </reg>
      <reg name="rssi_target" protect="rw">
        <comment>RSSI目标值配置寄存器</comment>
      </reg>
      <reg name="ppm_gru_cfg1" protect="rw">
        <comment>粗同步定时偏移配置寄存器1</comment>
        <bits access="rw" name="ppm1" pos="13:8" rst="0x32">
          <comment>PSS粗同步定时漂移移位值  取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="ppm0" pos="5:0" rst="0x2e">
          <comment>PSS粗同步定时漂移移位值  取值范围为-32~31</comment>
        </bits>
      </reg>
      <reg name="ppm_gru_cfg2" protect="rw">
        <comment>粗同步定时偏移配置寄存器2</comment>
        <bits access="rw" name="ppm1" pos="13:8" rst="0x3a">
          <comment>PSS粗同步定时漂移移位值  取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="ppm0" pos="5:0" rst="0x36">
          <comment>PSS粗同步定时漂移移位值  取值范围为-32~31</comment>
        </bits>
      </reg>
      <reg name="ppm_gru_cfg3" protect="rw">
        <comment>粗同步定时偏移配置寄存器3</comment>
        <bits access="rw" name="ppm1" pos="13:8" rst="0x2">
          <comment>PSS粗同步定时漂移移位值  取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="ppm0" pos="5:0" rst="0x3e">
          <comment>PSS粗同步定时漂移移位值  取值范围为-32~31</comment>
        </bits>
      </reg>
      <reg name="ppm_gru_cfg4" protect="rw">
        <comment>粗同步定时偏移配置寄存器4</comment>
        <bits access="rw" name="ppm1" pos="13:8" rst="0xa">
          <comment>PSS粗同步定时漂移移位值  取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="ppm0" pos="5:0" rst="0x6">
          <comment>PSS粗同步定时漂移移位值  取值范围为-32~31</comment>
        </bits>
      </reg>
      <reg name="ppm_gru_cfg5" protect="rw">
        <comment>粗同步定时偏移配置寄存器5</comment>
        <bits access="rw" name="ppm1" pos="13:8" rst="0x12">
          <comment>PSS粗同步定时漂移移位值  取值范围为-32~31</comment>
        </bits>
        <bits access="rw" name="ppm0" pos="5:0" rst="0xe">
          <comment>PSS粗同步定时漂移移位值  取值范围为-32~31</comment>
        </bits>
      </reg>
      <reg name="ppm_delt_cfg" protect="rw">
        <comment>PSS精同步SSS同步定时偏移增量配置寄存器</comment>
        <bits access="rw" name="delt_ppm3" pos="15:12" rst="0x3">
          <comment>定时偏移增量  取值范围为-8~7</comment>
        </bits>
        <bits access="rw" name="delt_ppm2" pos="11:8" rst="0x1">
          <comment>定时偏移增量  取值范围为-8~7</comment>
        </bits>
        <bits access="rw" name="delt_ppm1" pos="7:4" rst="0xf">
          <comment>定时偏移增量  取值范围为-8~7</comment>
        </bits>
        <bits access="rw" name="delt_ppm0" pos="3:0" rst="0xd">
          <comment>定时偏移增量  取值范围为-8~7</comment>
        </bits>
      </reg>
      <reg name="fft_cut" protect="rw">
        <comment>FFT截位因子寄存器</comment>
        <bits access="rw" name="lnum_mod2" pos="7:4" rst="0x0">
          <comment>指示 FFT/IFFT 中采用定点数截位方式一的前几级级数(干扰消除)：
4`b0000：各级都采用截位方式二；
4`b0001：第一级采用截位方式一，后面几级都采用截位方式二；
4`b0010：第一、二级采用截位方式一，后面几级都采用截位方式二；
…</comment>
        </bits>
        <bits access="rw" name="lnum_mod1" pos="3:0" rst="0x0">
          <comment>指示 FFT/IFFT 中采用定点数截位方式一的前几级级数（PSS/SSS同步）：
4`b0000：各级都采用截位方式二；
4`b0001：第一级采用截位方式一，后面几级都采用截位方式二；
4`b0010：第一、二级采用截位方式一，后面几级都采用截位方式二；
…</comment>
        </bits>
      </reg>
      <reg name="ic_id_para" protect="rw">
        <comment>干扰消除的ID配置寄存</comment>
        <bits access="rw" name="freq_off_en" pos="28" rst="0x0">
          <comment>干扰小区频偏纠正使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="freq_off" pos="27:12" rst="0x0">
          <comment>干扰小区频偏纠正因子</comment>
        </bits>
        <bits access="rw" name="cptype" pos="11" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP   0：NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="10" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5   0：子帧0</comment>
        </bits>
        <bits access="rw" name="nid2" pos="9:8" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>SSS序列的参数</comment>
        </bits>
      </reg>
      <reg name="ic_cfg" protect="rw">
        <comment>IC_CFG配置寄存器</comment>
        <bits access="rw" name="ic_ppm" pos="23:18" rst="0x0">
          <comment>干扰小区定时漂移因子</comment>
        </bits>
        <bits access="rw" name="sssic_pos" pos="17:4" rst="0x0">
          <comment>SSS同步时的干扰消除首位置： 在9600点中的位置</comment>
        </bits>
        <bits access="rw" name="ic_shift" pos="3:0" rst="0x0">
          <comment>截位因子
0：不移位
1：右移1位
2：右移2位
…
-1：左移1位
-2：左移2位
…</comment>
        </bits>
      </reg>
      <reg name="freqitm_out0" protect="rw">
        <comment>ID频率精同步输出寄存器 0</comment>
        <bits access="r" name="freq_itm_out0" pos="15:0" rst="0x0">
          <comment>频率精同步输出结果0</comment>
        </bits>
      </reg>
      <reg name="valid_node" protect="rw">
        <comment>PSS粗同步、PSS精同步、SSS同步过门限有效个数寄存器</comment>
        <bits access="r" name="valid_node1" pos="7:4" rst="0x0">
          <comment>SSS同步过门限送给小区有效性判断个数
0：前0个输出有效
1：前1个输出有效
…
12：前12个输出有效</comment>
        </bits>
        <bits access="r" name="valid_node0" pos="3:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步过门限有效个数
0：前0个输出有效
1：前1个输出有效
…
12：前12个输出有效</comment>
        </bits>
      </reg>
      <reg name="sample_sum" protect="rw">
        <comment>计算样本总数寄存器</comment>
        <bits access="rw" name="sample_sum" pos="7:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步、频率精同步和小区有效性判断计算结束时使用的样本总数
取值范围0~200</comment>
        </bits>
      </reg>
      <reg name="rssi" protect="rw">
        <comment>RSSI值输出寄存器</comment>
        <bits access="r" name="rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步滑动RSSI值，PSS精同步、SSS同步、频率精同步和小区有效性判断第一个
位置RSSI值</comment>
        </bits>
      </reg>
      <reg name="id_power_noise1" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise2" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise3" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise4" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise5" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise6" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise7" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise8" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise9" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise10" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise11" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_power_noise12" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="id_position_freq1" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq2" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq3" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq4" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq5" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq6" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq7" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq8" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq9" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq10" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq11" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_position_freq12" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="id_info1" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info2" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info3" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info4" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info5" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info6" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info7" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info8" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info9" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info10" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info11" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="id_info12" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET模式下排序后存放位置索引
取值范围0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>无线帧同步、频率精同步偏移位置
取值范围0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="assist_id_power_noise1" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="assist_id_power_noise2" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="assist_id_power_noise3" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="assist_id_power_noise4" protect="rw">
        <comment>功率噪声输出寄存器</comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出噪声</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出功率</comment>
        </bits>
      </reg>
      <reg name="assist_id_position_freq1" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="assist_id_position_freq2" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="assist_id_position_freq3" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="assist_id_position_freq4" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment>频偏尝试值</comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSS粗同步、PSS精同步、SSS同步输出ID位置</comment>
        </bits>
      </reg>
      <reg name="assist_id_info1" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="assist_id_info2" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="assist_id_info3" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="assist_id_info4" protect="rw">
        <comment>ID信息输出寄存器</comment>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment>定时漂移尝试值</comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1值
取值范围0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>ID对应的CP类型：
1：EXTEND CP
0：NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID对应的子帧号(SSS本地信号产生使用)：
1：子帧5
0：子帧0</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2值
取值范围0-2</comment>
        </bits>
      </reg>
      <reg name="int_flag" protect="rw">
        <comment>INT_FLAG标志寄存器</comment>
        <bits access="rc" name="discon_section_finish" pos="11" rst="0x0">
          <comment>1:非连续接收单次计算完成
0:完成状态已清除或未产生</comment>
        </bits>
        <bits access="rc" name="freq_search" pos="10" rst="0x0">
          <comment>1:频率盲搜所有子带以及所有频段搜索完成
0:完成状态已清除或未产生</comment>
        </bits>
        <bits access="rc" name="freq_search_sbi" pos="9" rst="0x0">
          <comment>1:频率盲搜1个子段搜索完成
0:完成状态已清除或未产生</comment>
        </bits>
        <bits access="rc" name="rssi" pos="8" rst="0x0">
          <comment>1:RSSI值计算完成
0: RSSI值计算完成状态已清除或未产生</comment>
        </bits>
        <bits access="rc" name="stop" pos="7" rst="0x0">
          <comment>1:暂停完成
0: 暂停状态已清除或未产生</comment>
        </bits>
        <bits access="rc" name="error_state" pos="6" rst="0x0">
          <comment>1:AXIDMA未能及时搬数产生错误
0:错误状态已清除或未产生</comment>
        </bits>
        <bits access="rc" name="txrx_suspend" pos="5" rst="0x0">
          <comment>1:TXRX接收数据暂停
0:暂停状态已清除或未产生</comment>
        </bits>
        <bits access="rc" name="resync_finish" pos="4" rst="0x0">
          <comment>1:重同步完成
0: 完成状态清除或未完成</comment>
        </bits>
        <bits access="rc" name="freq_idident_finish" pos="3" rst="0x0">
          <comment>1:频率精同步和小区有效性判断完成
0:完成状态清除或未完成</comment>
        </bits>
        <bits access="rc" name="sss_finish" pos="2" rst="0x0">
          <comment>1:SSS同步完成
0:完成状态清除或未完成</comment>
        </bits>
        <bits access="rc" name="pssitm_finish" pos="1" rst="0x0">
          <comment>1:PSS精同步完成
0:完成状态清除或未完成</comment>
        </bits>
        <bits access="rc" name="pssgru_finish" pos="0" rst="0x0">
          <comment>1:PSS粗同步完成
0:完成状态清除或未完成</comment>
        </bits>
      </reg>
      <reg name="sta_flag" protect="rw">
        <comment>IDDET状态寄存器</comment>
        <bits access="r" name="freq_search_run" pos="5" rst="0x0">
          <comment>频点状态指示
1：正在进行
0：未启动或已经结束</comment>
        </bits>
        <bits access="r" name="resyn_run" pos="4" rst="0x0">
          <comment>重同步状态指示
1：正在进行
0：未启动或已经结束</comment>
        </bits>
        <bits access="r" name="freqitm_idident_run" pos="3" rst="0x0">
          <comment>频率精同步和小区有效性判断状态指示
1：正在进行
0：未启动或已经结束</comment>
        </bits>
        <bits access="r" name="sss_run" pos="2" rst="0x0">
          <comment>无线帧同步状态指示
1：正在进行
0：未启动或已经结束</comment>
        </bits>
        <bits access="r" name="pss_itm_run" pos="1" rst="0x0">
          <comment>PSS精同步状态指示
1：正在进行
0：未启动或已经结束</comment>
        </bits>
        <bits access="r" name="pss_gru_run" pos="0" rst="0x0">
          <comment>PSS粗同步状态指示
1：正在进行
0：未启动或已经结束</comment>
        </bits>
      </reg>
      <reg name="soft_use" protect="rw">
        <comment>软件使用寄存器</comment>
      </reg>
      <reg name="pre_sample_count" protect="rw">
        <comment>前次计算样本个数寄存器</comment>
        <bits access="rw" name="pre_sample_count" pos="9:0" rst="0x0">
          <comment>前次计算样本个数  0~1023</comment>
        </bits>
      </reg>
      <reg name="freq_search_ctrl" protect="rw">
        <comment>频率盲搜控制寄存器</comment>
        <bits access="rw" name="sort_mode" pos="26" rst="0x0">
          <comment>0:使用功率排序
1:使用功率窗比值排序</comment>
        </bits>
        <bits access="rw" name="fft_en" pos="25" rst="0x0">
          <comment>单独FFT使能：
0: 单独FFT不使能
1: 单独FFT(固定1024点)使能,且只做一次FFT，就结束</comment>
        </bits>
        <bits access="rw" name="sort_en" pos="24" rst="0x0">
          <comment>单独排序使能:
0: 单独排序不使能
1: 单独排序使能,且只做排序，就结束</comment>
        </bits>
        <bits access="rw" name="sort_end_addr" pos="23:14" rst="0x0">
          <comment>排序的结束地址1~999</comment>
        </bits>
        <bits access="rw" name="sort_start_addr" pos="13:4" rst="0x0">
          <comment>排序的起始地址0~999</comment>
        </bits>
        <bits access="rw" name="freq_sel" pos="3:2" rst="0x0">
          <comment>接收数据频率选择
0: 5M
1: 10M
2: 20M
其他: 5M</comment>
        </bits>
        <bits access="rw" name="last_5ms" pos="1" rst="0x0">
          <comment>0: 不是最后5ms数据
1: 最后5ms数据</comment>
        </bits>
        <bits access="rw" name="first_5ms" pos="0" rst="0x0">
          <comment>0: 不是首个5ms数据
1: 首个5ms数据</comment>
        </bits>
      </reg>
      <reg name="freq_search_config1" protect="rw">
        <comment>频率盲搜配置寄存器1</comment>
        <bits access="rw" name="pwrwin_32to20bitsel" pos="30:27" rst="0x9">
          <comment>功率窗比值时的截位因子配置;
0:截取[19:0],进行保护为20bit的功率
1:截取[20:1],进行保护为20bit的功率
……
12:截取[31:12],进行保护为20bit的功率
其他:同12的配置;</comment>
        </bits>
        <bits access="rw" name="pwr_32to16bitsel" pos="26:23" rst="0x0">
          <comment>接收的数据频域计算之后,功率的截位因子配置;I^2+Q^2=PWR(32bit)
0:截取[31:15],进行保护为16bit的功率
1:截取[31:14],进行保护为16bit的功率
……
15:截取[31:0],进行保护为16bit的功率</comment>
        </bits>
        <bits access="rw" name="cur_sbi_num" pos="22:17" rst="0x0">
          <comment>当前频段的子带编号
取值范围0~49</comment>
        </bits>
        <bits access="rw" name="sbi_max" pos="16:11" rst="0x0">
          <comment>当前频段的子带总数   取值范围0~50</comment>
        </bits>
        <bits access="rw" name="freq_20m_en" pos="10" rst="0x0">
          <comment>20MHz功率窗比值计算使能
0: 不使能
1: 使能</comment>
        </bits>
        <bits access="rw" name="freq_15m_en" pos="9" rst="0x0">
          <comment>15MHz功率窗比值计算使能
0: 不使能
1: 使能</comment>
        </bits>
        <bits access="rw" name="freq_10m_en" pos="8" rst="0x0">
          <comment>10MHz功率窗比值计算使能
0: 不使能
1: 使能</comment>
        </bits>
        <bits access="rw" name="freq_5m_en" pos="7" rst="0x0">
          <comment>5MHz功率窗比值计算使能
0: 不使能
1: 使能</comment>
        </bits>
        <bits access="rw" name="freq_3m_en" pos="6" rst="0x0">
          <comment>3MHz功率窗比值计算使能
0: 不使能
1: 使能</comment>
        </bits>
        <bits access="rw" name="freq_1_4m_en" pos="5" rst="0x0">
          <comment>1.4MHz功率窗比值计算使能
0: 不使能
1: 使能</comment>
        </bits>
        <bits access="rw" name="freq_200k_en" pos="4" rst="0x0">
          <comment>200KHz功率窗比值计算使能
0: 不使能
1: 使能</comment>
        </bits>
        <bits access="rw" name="m" pos="3:0" rst="0x5">
          <comment>功率谱滑动平均窗长,取值为1~11</comment>
        </bits>
      </reg>
      <reg name="freq_search_config2" protect="rw">
        <comment>频率盲搜配置寄存器2</comment>
        <bits access="rw" name="selectbinnum_right" pos="17:9" rst="0x0">
          <comment>Selectbinnum右边配置，0~511</comment>
        </bits>
        <bits access="rw" name="selectbinnum_left" pos="8:0" rst="0x0">
          <comment>selectbinnum左边配置，0~511</comment>
        </bits>
      </reg>
      <reg name="band_win_start_conf1" protect="rw">
        <comment>功率窗比值带宽表START值配置寄存器1</comment>
        <bits access="rw" name="band_5mhz" pos="27:21" rst="0x18">
          <comment>取值范围0~99</comment>
        </bits>
        <bits access="rw" name="band_3mhz" pos="20:14" rst="0xf">
          <comment>取值范围0~99</comment>
        </bits>
        <bits access="rw" name="band_1_4mhz" pos="13:7" rst="0x7">
          <comment>取值范围0~99</comment>
        </bits>
        <bits access="rw" name="band_200khz" pos="6:0" rst="0x2">
          <comment>取值范围0~99</comment>
        </bits>
      </reg>
      <reg name="band_win_start_conf2" protect="rw">
        <comment>功率窗比值带宽表START值配置寄存器2</comment>
        <bits access="rw" name="band_20mhz" pos="20:14" rst="0x5b">
          <comment>取值范围0~99</comment>
        </bits>
        <bits access="rw" name="band_15mhz" pos="13:7" rst="0x45">
          <comment>取值范围0~99</comment>
        </bits>
        <bits access="rw" name="band_10mhz" pos="6:0" rst="0x2e">
          <comment>取值范围0~99</comment>
        </bits>
      </reg>
      <reg name="band_win_end_conf1" protect="rw">
        <comment>功率窗比值带宽表END值配置寄存器1</comment>
        <bits access="rw" name="band_20mhz" pos="27:24" rst="0x9">
          <comment>取值范围0~15</comment>
        </bits>
        <bits access="rw" name="band_15mhz" pos="23:20" rst="0x6">
          <comment>取值范围0~15</comment>
        </bits>
        <bits access="rw" name="band_10mhz" pos="19:16" rst="0x4">
          <comment>取值范围0~15</comment>
        </bits>
        <bits access="rw" name="band_5mhz" pos="15:12" rst="0x1">
          <comment>取值范围0~15</comment>
        </bits>
        <bits access="rw" name="band_3mhz" pos="11:8" rst="0x0">
          <comment>取值范围0~15</comment>
        </bits>
        <bits access="rw" name="band_1_4mhz" pos="7:4" rst="0x0">
          <comment>取值范围0~15</comment>
        </bits>
        <bits access="rw" name="band_200khz" pos="3:0" rst="0x0">
          <comment>取值范围0~15</comment>
        </bits>
      </reg>
      <reg name="band_win_end_conf2" protect="rw">
        <comment>功率窗比值带宽表END值配置寄存器2</comment>
      </reg>
      <reg name="agc_conf" protect="rw">
        <comment>AGC配置寄存器</comment>
        <bits access="rw" name="agc" pos="6:0" rst="0x0">
          <comment>取值范围0~127</comment>
        </bits>
      </reg>
      <reg name="sbi_sum_ len" protect="rw">
        <comment>硬件已经计算的子带的总长度寄存器</comment>
        <bits access="rw" name="sbi_sum_len" pos="9:0" rst="0x0">
          <comment>当前频段的子带中，硬件已经计算的子带的长度的和值</comment>
        </bits>
      </reg>
      <reg name="target_agc" protect="rw">
        <comment>硬件已经计算的子带的目标AGC寄存器</comment>
        <bits access="rw" name="target_agc" pos="9:0" rst="0x0">
          <comment>当前频段的子带中，硬件已经计算的子带的目标AGC</comment>
        </bits>
      </reg>
      <reg name="freqitm_out1" protect="rw">
        <comment>ID频率精同步输出寄存器 1</comment>
        <bits access="r" name="freq_itm_out2" pos="31:16" rst="0x0">
          <comment>频率精同步输出结果2</comment>
        </bits>
        <bits access="r" name="freq_itm_out1" pos="15:0" rst="0x0">
          <comment>频率精同步输出结果1</comment>
        </bits>
      </reg>
      <reg name="pss1_resyn_rssi_range" protect="rw">
        <comment>PSS1_RESYN_CTRL粗同步重同步RSSI计算范围配置寄存器</comment>
        <bits access="rw" name="pss1_rssi_end" pos="29:16" rst="0x12bf">
          <comment>PSS粗同步、重同步RSSI计算范围结束值，粗同步取值范围：0~4799，重同步取值范围：0~9599</comment>
        </bits>
        <bits access="rw" name="pss1_rssi_start" pos="13:0" rst="0x0">
          <comment>PSS粗同步、重同步RSSI计算范围起始值，粗同步取值范围：0~4799，重同步取值范围：0~9599</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi0" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi1" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi2" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi3" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi4" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi5" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi6" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi7" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi8" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi9" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi10" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi11" protect="rw">
        <comment>位置输出寄存器</comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSS粗同步最大值RSSI值</comment>
        </bits>
      </reg>
      <hole size="27136"/>
      <reg name="mem8_9_mem10_11" protect="rw">
        <comment>1、 PSS粗同步、重同步功率；
2、 PSS粗同步、重同步RSSI值</comment>
      </reg>
      <hole size="32736"/>
      <reg name="mem12" protect="rw">
        <comment>1、 PSS精同步功率
2、 SSS同步功率</comment>
      </reg>
      <hole size="32736"/>
      <reg name="mem15" protect="rw">
        <comment>频率精同步和小区有效性判断功率</comment>
      </reg>
      <hole size="32736"/>
      <reg name="memqf" protect="rw">
        <comment>QF值保存</comment>
      </reg>
      <hole size="131040"/>
      <reg name="mem1_8_mem1_11" protect="rw">
        <comment>非乒乓模式MEM1-8
乒乓模式MEM1-11
RF输入数据导出（只读）</comment>
        <bits access="rw" name="mem1_8_mem1_11_1" pos="25:16" rst="0x0"/>
        <bits access="rw" name="mem1_8_mem1_11_2" pos="9:0" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="mem_freq_pwr_before_agc" protect="rw">
        <comment>用于存放频率盲搜中，每个子带的AGC拉齐之前的功率</comment>
        <bits access="rw" name="mem_freq_pwr_before_agc_1" pos="31:16" rst="0x0">
          <comment>第1个子带的PWR1</comment>
        </bits>
        <bits access="rw" name="mem_freq_pwr_before_agc_0" pos="15:0" rst="0x0">
          <comment>第1个子带的PWR0</comment>
        </bits>
      </reg>
      <hole size="32736"/>
      <reg name="mem_freq_len_agc" protect="rw">
        <comment>用于存放频率盲搜中，每个子带的长度以及AGC值</comment>
        <bits access="rw" name="mem_freq_len_agc_1" pos="18:10" rst="0x0">
          <comment>第1个子带的长度</comment>
        </bits>
        <bits access="rw" name="mem_freq_len_agc_0" pos="9:0" rst="0x0">
          <comment>第1个子带的AGC</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x18600000" name="IDDET" type="IDDET"/>
  </archive>
  <archive relative="csirs.xml">
    <module category="System" name="CSIRS">
      <reg name="csi_start" protect="rw">
        <comment>CSI启动寄存器</comment>
        <bits access="rw" name="data_drive_en" pos="2" rst="0x0">
          <comment>data_drive模式使能。
0：非data_drive
1：data_drive</comment>
        </bits>
        <bits access="rw" name="dma_start_en" pos="1" rst="0x0">
          <comment>DMA启动CSI模块的使能。
0：不使能
1：使能</comment>
        </bits>
        <bits access="rw" name="csi_en" pos="0" rst="0x0">
          <comment>CSI模块使能信号。
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="csi_cfg_nxt" protect="rw">
        <comment>下个子帧的CSI配置寄存器</comment>
        <bits access="rw" name="cp" pos="25" rst="0x0">
          <comment>cp指示。
0：常规
1：扩展</comment>
        </bits>
        <bits access="rw" name="fh_bit_sel" pos="24:20" rst="0x0">
          <comment>FH输出截位方案。
5’d0：截取fh[11:0]
5’d1：截取fh[12:1]
5’d2：截取fh[13:2]
……
5’d16：截取fh[27:16]
others：截取fh[28:17]</comment>
        </bits>
        <bits access="rw" name="csi_crs_ind" pos="19" rst="0x0">
          <comment>CSI-RS和CRS的指示。
0：CSI-RS
1：CRS</comment>
        </bits>
        <bits access="rw" name="ls_en" pos="18" rst="0x0">
          <comment>LS/FH/功率计算使能信号。
0：不使能，不计算LS/FH/功率
1：使能，要计算</comment>
        </bits>
        <bits access="rw" name="sw_ri" pos="17" rst="0x0">
          <comment>软件配置的宽带RI，在ri_sel=1时用来计算PMI。
0：RI=1
1：RI=2</comment>
        </bits>
        <bits access="rw" name="ri_sel" pos="16" rst="0x0">
          <comment>计算PMI所用的RI的来源选择。
0：使用硬件计算的宽带RI
1：使用软件配置的RI</comment>
        </bits>
        <bits access="rw" name="pmi_en" pos="15" rst="0x0">
          <comment>PMI估算使能信号。
0：不使能，不计算PMI
1：使能，要计算PMI</comment>
        </bits>
        <bits access="rw" name="ri_en" pos="14" rst="0x0">
          <comment>RI估算使能信号。
0：不使能，不计算RI
1：使能，要计算RI</comment>
        </bits>
        <bits access="rw" name="old_ri_ind" pos="13" rst="0x0">
          <comment>估算RI时是否使用RI历史值的指示。
0：不使用历史值，默认为RI=1
1：使用上个周期的宽带RI值</comment>
        </bits>
        <bits access="rw" name="total_nrb" pos="12:6" rst="0x0">
          <comment>系统带宽。取值6/15/25/50/75/100PRB</comment>
        </bits>
        <bits access="rw" name="sub_nrb" pos="5:2" rst="0x0">
          <comment>子带带宽。与系统带宽一一对应。total_nrb=6/15/25/50/75/100时，sub_nrb=6/2/2/3/4/4 PRB。</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="1:0" rst="0x0">
          <comment>发射天线数。CSI-RS可配置1、2、4、8天线，CRS可配置2、4天线。
0：1天线（只计算功率，不计算RI和PMI）
1：2天线
2：4天线
3：8天线</comment>
        </bits>
      </reg>
      <reg name="csi_ri_threshold_nxt" protect="rw">
        <comment>下个子帧的RI估计门限寄存器</comment>
        <bits access="rw" name="th2_cfg" pos="30:16" rst="0x0">
          <comment>〖((1-th2)/(1+th2))〗^2的值。估计RI时使用的判决门限，取值为大于0小于1的小数。用Q15表示。th2的典型值为40。</comment>
        </bits>
        <bits access="rw" name="th1_cfg" pos="14:0" rst="0x0">
          <comment>〖((1-th1)/(1+th1))〗^2的值。估计RI时使用的判决门限，取值为大于0小于1的小数。用Q15表示。th1的典型值为60。</comment>
        </bits>
      </reg>
      <reg name="csi_code_index1_nxt" protect="rw">
        <comment>下个子帧的码本索引寄存器1</comment>
        <bits access="rw" name="code_index1_mask2" pos="31:16" rst="0x0">
          <comment>RI=2时的2、4天线的码本索引号及8天线的码本索引号i1的bitmap。bit0~bit15分别对应索引号0~15，为“1”的比特位对应的索引号有效，需要计算该索引对应的预编码矩阵。</comment>
        </bits>
        <bits access="rw" name="code_index1_mask1" pos="15:0" rst="0x0">
          <comment>RI=1时的2、4天线的码本索引号及8天线的码本索引号i1的bitmap。bit0~bit15分别对应索引号0~15，为“1”的比特位对应的索引号有效，需要计算该索引对应的预编码矩阵。</comment>
        </bits>
      </reg>
      <reg name="csi_code_index2_nxt" protect="rw">
        <comment>下个子帧的码本索引寄存器2</comment>
        <bits access="rw" name="code_index2_mask2" pos="31:16" rst="0x0">
          <comment>RI=2时的8天线的码本索引号i2的bitmap。bit0~bit15分别对应索引号0~15，为“1”的比特位对应的索引号有效，需要计算该索引对应的预编码矩阵。</comment>
        </bits>
        <bits access="rw" name="code_index2_mask1" pos="15:0" rst="0x0">
          <comment>RI=1时的8天线的码本索引号i2的bitmap。bit0~bit15分别对应索引号0~15，为“1”的比特位对应的索引号有效，需要计算该索引对应的预编码矩阵。</comment>
        </bits>
      </reg>
      <reg name="csi_inten_nxt" protect="rw">
        <comment>下个子帧的中断使能寄存器</comment>
        <bits access="rw" name="phy_factor" pos="7:4" rst="0x0">
          <comment>物理层主卡标志位</comment>
        </bits>
        <bits access="rw" name="csi_inten" pos="0" rst="0x0">
          <comment>处理完成中断使能。
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="csi_cinit1_nxt" protect="rw">
        <comment>下个子帧的OFDM0的C序列初始值寄存器</comment>
        <bits access="rw" name="cinit0" pos="30:0" rst="0x0">
          <comment>OFDM符号0的C序列的初始值，用来计算本地CSI-RS。</comment>
        </bits>
      </reg>
      <reg name="csi_cinit2_nxt" protect="rw">
        <comment>下个子帧的OFDM1的C序列初始值寄存器</comment>
        <bits access="rw" name="cinit1" pos="30:0" rst="0x0">
          <comment>OFDM符号1的C序列的初始值，用来计算本地CSI-RS。</comment>
        </bits>
      </reg>
      <reg name="csi_intf" protect="rw">
        <comment>中断标志寄存器</comment>
        <bits access="rc" name="phy_factor" pos="7:4" rst="0x0">
          <comment>模块主卡标志输出</comment>
        </bits>
        <bits access="rc" name="csi_intf" pos="0" rst="0x0">
          <comment>处理完成中断标志。
0：未处理完
1：处理完成</comment>
        </bits>
      </reg>
      <reg name="csi_sw_stop" protect="rw">
        <comment>软件暂停和停止使能寄存器</comment>
        <bits access="rw" name="sw_pause_way" pos="2" rst="0x0">
          <comment>当sw_pause_en=1时，软件暂停硬件的策略选择。
0：在开始处理之前暂停
1：在子帧处理结束之后暂停</comment>
        </bits>
        <bits access="rw" name="sw_pause_en" pos="1" rst="0x0">
          <comment>软件暂停硬件的使能。
0：不暂停
1：暂停，硬件完成当前子帧处理后或开始处理之前，暂停处理，等该使能置为0后再继续</comment>
        </bits>
        <bits access="rw" name="sw_stop_en" pos="0" rst="0x0">
          <comment>软件停止硬件的使能。
0：不停止
1：停止，硬件在处理子帧前或完成当前子帧处理后，停止处理</comment>
        </bits>
      </reg>
      <reg name="csi_sw_stop_flag" protect="rw">
        <comment>软件暂停和停止标志寄存器</comment>
        <bits access="rc" name="sw_pause_flag" pos="1" rst="0x0">
          <comment>软件暂停硬件标志。
0：软件未成功暂停硬件
1：软件成功暂停硬件</comment>
        </bits>
        <bits access="rc" name="sw_stop_flag" pos="0" rst="0x0">
          <comment>软件停止硬件标志。
0：软件未成功停止硬件
1：软件成功停止硬件</comment>
        </bits>
      </reg>
      <reg name="csi_ri_rpt" protect="rw">
        <comment>宽带RI上报寄存器</comment>
        <bits access="r" name="ri_total_rpt" pos="0" rst="0x0">
          <comment>系统带宽内总的RI，即对所有PRB的RI按多数原则统计得到的值。
0：RI=1
1：RI=2</comment>
        </bits>
      </reg>
      <reg name="csi_pmi_rpt" protect="rw">
        <comment>宽带PMI上报寄存器</comment>
        <bits access="r" name="pmi_total_rpt" pos="7:0" rst="0x0">
          <comment>系统带宽内总的PMI，即对所有PRB的PMI按多数原则统计得到的值</comment>
        </bits>
      </reg>
      <reg name="csi_rx1_sig_rpt" protect="rw">
        <comment>接收天线1的宽带信号功率上报寄存器</comment>
        <bits access="r" name="rx1_sig_rpt" pos="27:0" rst="0x0">
          <comment>接收天线1的宽带信号功率和，即对所有子带信号功率累加得到。</comment>
        </bits>
      </reg>
      <reg name="csi_rx2_sig_rpt" protect="rw">
        <comment>接收天线2的宽带信号功率上报寄存器</comment>
        <bits access="r" name="rx2_sig_rpt" pos="27:0" rst="0x0">
          <comment>接收天线2的宽带信号功率和，即对所有子带信号功率累加得到。</comment>
        </bits>
      </reg>
      <reg name="csi_rx1_noise_rpt" protect="rw">
        <comment>接收天线1的宽带噪声功率上报寄存器</comment>
        <bits access="r" name="rx1_noise_rpt" pos="29:0" rst="0x0">
          <comment>接收天线1的宽带噪声功率和，即对所有子带噪声功率累加得到。</comment>
        </bits>
      </reg>
      <reg name="csi_rx2_noise_rpt" protect="rw">
        <comment>接收天线2的宽带噪声功率上报寄存器</comment>
        <bits access="r" name="rx2_noise_rpt" pos="29:0" rst="0x0">
          <comment>接收天线2的宽带噪声功率和，即对所有子带噪声功率累加得到。</comment>
        </bits>
      </reg>
      <reg name="csi_cfg_cur" protect="rw">
        <comment>当前处理子帧的CSI配置寄存器</comment>
        <bits access="rw" name="cp" pos="25" rst="0x0">
          <comment>cp指示。
0：常规
1：扩展</comment>
        </bits>
        <bits access="rw" name="fh_bit_sel" pos="24:20" rst="0x0">
          <comment>FH输出截位方案。
5’d0：截取fh[11:0]
5’d1：截取fh[12:1]
5’d2：截取fh[13:2]
……
5’d16：截取fh[27:16]
others：截取fh[28:17]</comment>
        </bits>
        <bits access="rw" name="csi_crs_ind" pos="19" rst="0x0">
          <comment>CSI-RS和CRS的指示。
0：CSI-RS
1：CRS</comment>
        </bits>
        <bits access="rw" name="ls_en" pos="18" rst="0x0">
          <comment>LS/FH/功率计算使能信号。
0：不使能，不计算LS/FH/功率
1：使能，要计算</comment>
        </bits>
        <bits access="rw" name="sw_ri" pos="17" rst="0x0">
          <comment>软件配置的宽带RI，在ri_sel=1时用来计算PMI。
0：RI=1
1：RI=2</comment>
        </bits>
        <bits access="rw" name="ri_sel" pos="16" rst="0x0">
          <comment>计算PMI所用的RI的来源选择。
0：使用硬件计算的宽带RI
1：使用软件配置的RI</comment>
        </bits>
        <bits access="rw" name="pmi_en" pos="15" rst="0x0">
          <comment>PMI估算使能信号。
0：不使能，不计算PMI
1：使能，要计算PMI</comment>
        </bits>
        <bits access="rw" name="ri_en" pos="14" rst="0x0">
          <comment>RI估算使能信号。
0：不使能，不计算RI
1：使能，要计算RI</comment>
        </bits>
        <bits access="rw" name="old_ri_ind" pos="13" rst="0x0">
          <comment>估算RI时是否使用RI历史值的指示。
0：不使用历史值，默认为RI=1
1：使用上个周期的宽带RI值</comment>
        </bits>
        <bits access="rw" name="total_nrb" pos="12:6" rst="0x0">
          <comment>系统带宽。取值6/15/25/50/75/100PRB</comment>
        </bits>
        <bits access="rw" name="sub_nrb" pos="5:2" rst="0x0">
          <comment>子带带宽。与系统带宽一一对应。total_nrb=6/15/25/50/75/100时，sub_nrb=6/2/2/3/4/4 PRB。</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="1:0" rst="0x0">
          <comment>发射天线数。CSI-RS可配置1、2、4、8天线，CRS可配置2、4天线。
0：1天线（只计算功率，不计算RI和PMI）
1：2天线
2：4天线
3：8天线</comment>
        </bits>
      </reg>
      <reg name="csi_ri_threshold_cur" protect="rw">
        <comment>当前处理子帧的RI估计门限寄存器</comment>
        <bits access="rw" name="th2_cfg" pos="30:16" rst="0x0">
          <comment>〖((1-th2)/(1+th2))〗^2的值。估计RI时使用的判决门限，取值为大于0小于1的小数。用Q15表示。th2的典型值为40。</comment>
        </bits>
        <bits access="rw" name="th1_cfg" pos="14:0" rst="0x0">
          <comment>〖((1-th1)/(1+th1))〗^2的值。估计RI时使用的判决门限，取值为大于0小于1的小数。用Q15表示。th1的典型值为60。</comment>
        </bits>
      </reg>
      <reg name="csi_code_index1_cur" protect="rw">
        <comment>当前处理子帧的码本索引寄存器1</comment>
        <bits access="rw" name="code_index1_mask2" pos="31:16" rst="0x0">
          <comment>RI=2时的2、4天线的码本索引号及8天线的码本索引号i1的bitmap。bit0~bit15分别对应索引号0~15，为“1”的比特位对应的索引号有效，需要计算该索引对应的预编码矩阵。</comment>
        </bits>
        <bits access="rw" name="code_index1_mask1" pos="15:0" rst="0x0">
          <comment>RI=1时的2、4天线的码本索引号及8天线的码本索引号i1的bitmap。bit0~bit15分别对应索引号0~15，为“1”的比特位对应的索引号有效，需要计算该索引对应的预编码矩阵。</comment>
        </bits>
      </reg>
      <reg name="csi_code_index2_cur" protect="rw">
        <comment>当前处理子帧的码本索引寄存器2</comment>
        <bits access="rw" name="code_index2_mask2" pos="31:16" rst="0x0">
          <comment>RI=2时的8天线的码本索引号i2的bitmap。bit0~bit15分别对应索引号0~15，为“1”的比特位对应的索引号有效，需要计算该索引对应的预编码矩阵。</comment>
        </bits>
        <bits access="rw" name="code_index2_mask1" pos="15:0" rst="0x0">
          <comment>RI=1时的8天线的码本索引号i2的bitmap。bit0~bit15分别对应索引号0~15，为“1”的比特位对应的索引号有效，需要计算该索引对应的预编码矩阵。</comment>
        </bits>
      </reg>
      <reg name="csi_inten_cur" protect="rw">
        <comment>当前处理子帧的中断使能寄存器</comment>
        <bits access="rw" name="csi_inten" pos="0" rst="0x0">
          <comment>处理完成中断使能。
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="csi_cinit1_cur" protect="rw">
        <comment>当前处理子帧的OFDM0的C序列初始值寄存器</comment>
        <bits access="rw" name="cinit0" pos="30:0" rst="0x0">
          <comment>OFDM符号0的C序列的初始值，用来计算本地CSI-RS。</comment>
        </bits>
      </reg>
      <reg name="csi_cinit2_cur" protect="rw">
        <comment>当前处理子帧的OFDM1的C序列初始值寄存器</comment>
        <bits access="rw" name="cinit1" pos="30:0" rst="0x0">
          <comment>OFDM符号1的C序列的初始值，用来计算本地CSI-RS。</comment>
        </bits>
      </reg>
      <hole size="261376"/>
      <reg name="rs_fh_mem1" protect="rw">
        <bits access="rw" name="rs_fh_mem1_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="rs_fh_mem1_2" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="rs_fh_mem2" protect="rw">
        <bits access="rw" name="rs_fh_mem2_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="rs_fh_mem2_2" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="hls_mem1" protect="rw">
        <bits access="rw" name="hls_mem1_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="hls_mem1_2" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="out_mem" protect="rw">
        </reg>
    </module>
    <instance address="0x18b00000" name="CSIRS" type="CSIRS"/>
  </archive>
  <archive relative="corr.xml">
    <module category="System" name="CORR">
      <reg name="corr_para" protect="rw">
        <comment>参数寄存器</comment>
        <bits access="rw" name="corr_loclen" pos="24:16" rst="0x0">
          <comment>本地序列长度：max384</comment>
        </bits>
        <bits access="rw" name="corr_reclen" pos="15:4" rst="0x0">
          <comment>接收数据长度：max2800</comment>
        </bits>
        <bits access="rw" name="corr_idnum" pos="3:0" rst="0x0">
          <comment>ID个数：max10</comment>
        </bits>
      </reg>
      <reg name="corr_start" protect="rw">
        <comment>启动寄存器</comment>
        <bits access="rw" name="corr_start" pos="0" rst="0x0">
          <comment>模块启动：
1：启动
0：未启动或者已经完成</comment>
        </bits>
      </reg>
      <reg name="corr_out" protect="rw">
        <comment>结果输出寄存器</comment>
        <bits access="r" name="corr_pp" pos="16" rst="0x0">
          <comment>输出的相关值在乒或者乓：
0：乒
1：乓</comment>
        </bits>
        <bits access="r" name="corr_pos" pos="15:4" rst="0x0">
          <comment>最大位置：max：2800</comment>
        </bits>
        <bits access="r" name="corr_id" pos="3:0" rst="0x0">
          <comment>最大ID：max10</comment>
        </bits>
      </reg>
      <reg name="corr_max" protect="rw">
        <comment>MAX输出寄存器</comment>
        <bits access="r" name="corr_max" pos="23:0" rst="0x0">
          <comment>CORR_MAX</comment>
        </bits>
      </reg>
      <reg name="corr_sum" protect="rw">
        <comment>SUM输出寄存器</comment>
      </reg>
      <reg name="corr_int_en" protect="rw">
        <comment>中断使能寄存器</comment>
        <bits access="rw" name="corr_int_en" pos="0" rst="0x0">
          <comment>中断使能：
0：中断不使能
1：中断使能</comment>
        </bits>
      </reg>
      <reg name="int_flag" protect="rw">
        <comment>中断标志寄存器</comment>
        <bits access="rc" name="int_flag" pos="0" rst="0x0">
          <comment>中断标志：
0：没有中断
1：产生中断</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x19000800" name="CORR" type="CORR"/>
  </archive>
  <archive relative="rxcapt.xml">
    <module category="System" name="RXCAPT">
      <reg name="rxcapt_en" protect="rw">
        <comment>配置寄存器</comment>
        <bits access="rw" name="rxcapt_en" pos="0" rst="0x0">
          <comment>使能位
0：不使能
1：使能</comment>
        </bits>
      </reg>
      <reg name="capt_cfg" protect="rw">
        <comment>配置寄存器</comment>
        <bits access="rw" name="capt_dump" pos="4" rst="0x0">
          <comment>启动抓Dump数据
1：启动
0：不启动</comment>
        </bits>
        <bits access="rw" name="capt_tx" pos="3" rst="0x0">
          <comment>启动抓Tx Trace数据
1：启动
0：不启动</comment>
        </bits>
        <bits access="rw" name="capt_iddet_offline" pos="2" rst="0x0">
          <comment>启动抓IDDET offline输入口数据
1：启动
0：不启动</comment>
        </bits>
        <bits access="rw" name="capt_odtoa" pos="1" rst="0x0">
          <comment>启动抓ODTOA数据
1：启动
0：不启动</comment>
        </bits>
        <bits access="rw" name="capt_rx" pos="0" rst="0x0">
          <comment>启动抓RX输入口数据
1：启动
0：不启动</comment>
        </bits>
      </reg>
      <reg name="fill_cfg1" protect="rw">
        <comment>灌数配置寄存器</comment>
        <bits access="rw" name="fill_len" pos="31:4" rst="0xfffffff">
          <comment>灌数长度</comment>
        </bits>
        <bits access="rw" name="fill_dl_offline" pos="3" rst="0x0">
          <comment>启动DL offline灌数
1：启动
0：不启动</comment>
        </bits>
        <bits access="rw" name="fill_div" pos="2:0" rst="0x0">
          <comment>分频参数，用于生成灌数输出数据
3’h0:4分频（对应20M/15M带宽）
3’h1:8分频（对应10M带宽）
3’h2:16分频（对应5M带宽）
3’h3:32分频（对应3M带宽）
3’h4:64分频（对应1.4M带宽）
Others: 4分频</comment>
        </bits>
      </reg>
      <reg name="fill_cfg2" protect="rw">
        <comment>灌数配置寄存器2</comment>
        <bits access="rw" name="fill_len" pos="31:4" rst="0xfffffff">
          <comment>灌数长度</comment>
        </bits>
        <bits access="rw" name="fill_iddet_offline" pos="3" rst="0x0">
          <comment>启动IDDET offline灌数
1：启动
0：不启动</comment>
        </bits>
        <bits access="rw" name="fill_div" pos="2:0" rst="0x0">
          <comment>分频参数，用于生成灌数输出数据
3’h0:4分频（对应20M/15M带宽）
3’h1:8分频（对应10M带宽）
3’h2:16分频（对应5M带宽）
3’h3:32分频（对应3M带宽）
3’h4:64分频（对应1.4M带宽）
Others: 4分频</comment>
        </bits>
      </reg>
      <reg name="dma_req_en" protect="rw">
        <comment>请求DMA搬数使能寄存器</comment>
        <bits access="rw" name="dma_req7_en" pos="7" rst="0x0">
          <comment>DMA_req7使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="dma_req6_en" pos="6" rst="0x0">
          <comment>DMA_req6使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="dma_req5_en" pos="5" rst="0x0">
          <comment>DMA_req5使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="dma_req4_en" pos="4" rst="0x0">
          <comment>DMA_req4使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="dma_req3_en" pos="3" rst="0x0">
          <comment>DMA_req3使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="dma_req2_en" pos="2" rst="0x0">
          <comment>DMA_req2使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="dma_req1_en" pos="1" rst="0x0">
          <comment>DMA_req1使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="dma_req0_en" pos="0" rst="0x0">
          <comment>DMA_req0使能
1：使能
0：不使能</comment>
        </bits>
      </reg>
      <reg name="irq_inten" protect="rw">
        <comment>中断使能寄存器</comment>
        <bits access="rw" name="capt_err34" pos="13" rst="0x0">
          <comment>Capt_err34中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="capt_err12" pos="12" rst="0x0">
          <comment>Capt_err12中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="mem56_finish_irq" pos="10" rst="0x0">
          <comment>Mem56 finish中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="mem56_pang_irq" pos="9" rst="0x0">
          <comment>Mem56 pang中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="mem56_ping_irq" pos="8" rst="0x0">
          <comment>Mem56 ping中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="mem34_finish_irq" pos="6" rst="0x0">
          <comment>Mem34 finish中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="mem34_pang_irq" pos="5" rst="0x0">
          <comment>Mem34 pang中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="mem34_ping_irq" pos="4" rst="0x0">
          <comment>Mem34 ping中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="mem12_finish_irq" pos="2" rst="0x0">
          <comment>Mem12 finish中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="mem12_pang_irq" pos="1" rst="0x0">
          <comment>Mem12 pang中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rw" name="mem12_ping_irq" pos="0" rst="0x0">
          <comment>Mem12 ping中断使能
1：使能
0：不使能</comment>
        </bits>
      </reg>
      <reg name="irq_inten_set" protect="rw">
        <comment>中断使能置位寄存器</comment>
        <bits access="rs" name="capt_err34" pos="13" rst="0x0">
          <comment>Capt_err34中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rs" name="capt_err12" pos="12" rst="0x0">
          <comment>Capt_err12中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rs" name="mem56_finish_irq" pos="10" rst="0x0">
          <comment>Mem56 finish中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rs" name="mem56_pang_irq" pos="9" rst="0x0">
          <comment>Mem56 pang中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rs" name="mem56_ping_irq" pos="8" rst="0x0">
          <comment>Mem56 ping中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rs" name="mem34_finish_irq" pos="6" rst="0x0">
          <comment>Mem34 finish中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rs" name="mem34_pang_irq" pos="5" rst="0x0">
          <comment>Mem34 pang中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rs" name="mem34_ping_irq" pos="4" rst="0x0">
          <comment>Mem34 ping中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rs" name="mem12_finish_irq" pos="2" rst="0x0">
          <comment>Mem12 finish中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rs" name="mem12_pang_irq" pos="1" rst="0x0">
          <comment>Mem12 pang中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rs" name="mem12_ping_irq" pos="0" rst="0x0">
          <comment>Mem12 ping中断使能
1：使能
0：不使能</comment>
        </bits>
      </reg>
      <reg name="irq_inten_clr" protect="rw">
        <comment>中断使能清零寄存器</comment>
        <bits access="rc" name="capt_err34" pos="13" rst="0x0">
          <comment>Capt_err34中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rc" name="capt_err12" pos="12" rst="0x0">
          <comment>Capt_err12中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rc" name="mem56_finish_irq" pos="10" rst="0x0">
          <comment>Mem56 finish中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rc" name="mem56_pang_irq" pos="9" rst="0x0">
          <comment>Mem56 pang中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rc" name="mem56_ping_irq" pos="8" rst="0x0">
          <comment>Mem56 ping中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rc" name="mem34_finish_irq" pos="6" rst="0x0">
          <comment>Mem34 finish中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rc" name="mem34_pang_irq" pos="5" rst="0x0">
          <comment>Mem34 pang中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rc" name="mem34_ping_irq" pos="4" rst="0x0">
          <comment>Mem34 ping中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rc" name="mem12_finish_irq" pos="2" rst="0x0">
          <comment>Mem12 finish中断使能、
1：使能
0：不使能</comment>
        </bits>
        <bits access="rc" name="mem12_pang_irq" pos="1" rst="0x0">
          <comment>Mem12 pang中断使能
1：使能
0：不使能</comment>
        </bits>
        <bits access="rc" name="mem12_ping_irq" pos="0" rst="0x0">
          <comment>Mem12 ping中断使能
1：使能
0：不使能</comment>
        </bits>
      </reg>
      <reg name="irq_state" protect="rw">
        <comment>中断状态寄存器</comment>
        <bits access="rc" name="capt_err34_irq" pos="13" rst="0x0">
          <comment>Capt_err34中断</comment>
        </bits>
        <bits access="rc" name="capt_err12_irq" pos="12" rst="0x0">
          <comment>Capt_err12中断</comment>
        </bits>
        <bits access="rc" name="mem56_finish_irq" pos="10" rst="0x0">
          <comment>Mem56 finish中断状态</comment>
        </bits>
        <bits access="rc" name="mem56_pang_irq" pos="9" rst="0x0">
          <comment>Mem56 pang中断状态</comment>
        </bits>
        <bits access="rc" name="mem56_ping_irq" pos="8" rst="0x0">
          <comment>Mem56 ping中断状态</comment>
        </bits>
        <bits access="rc" name="mem34_finish_irq" pos="6" rst="0x0">
          <comment>Mem34 finish中断状态</comment>
        </bits>
        <bits access="rc" name="mem34_pang_irq" pos="5" rst="0x0">
          <comment>Mem34 pang中断状态</comment>
        </bits>
        <bits access="rc" name="mem34_ping_irq" pos="4" rst="0x0">
          <comment>Mem34 ping中断状态</comment>
        </bits>
        <bits access="rc" name="mem12_finish_irq" pos="2" rst="0x0">
          <comment>Mem12 finish中断状态、</comment>
        </bits>
        <bits access="rc" name="mem12_pang_irq" pos="1" rst="0x0">
          <comment>Mem12 pang中断状态</comment>
        </bits>
        <bits access="rc" name="mem12_ping_irq" pos="0" rst="0x0">
          <comment>Mem12 ping中断状态</comment>
        </bits>
      </reg>
      <reg name="capt_end_addr12" protect="rw">
        <comment>MEM12中断配置寄存器</comment>
        <bits access="rw" name="end_addr12" pos="10:0" rst="0x7cf">
          <comment>Mem12中断配置寄存器</comment>
        </bits>
      </reg>
      <reg name="capt_end_addr34" protect="rw">
        <comment>MEM34中断配置寄存器</comment>
        <bits access="rw" name="end_addr34" pos="8:0" rst="0x1f3">
          <comment>Mem34中断配置寄存器</comment>
        </bits>
      </reg>
      <reg name="fill_end_addr12" protect="rw">
        <comment>MEM12中断配置寄存器</comment>
        <bits access="rw" name="end_addr12" pos="10:0" rst="0x7ff">
          <comment>Mem12中断配置寄存器</comment>
        </bits>
      </reg>
      <reg name="fill_end_addr56" protect="rw">
        <comment>MEM56中断配置寄存器</comment>
        <bits access="rw" name="end_addr56" pos="9:0" rst="0x3ff">
          <comment>Mem56中断配置寄存器</comment>
        </bits>
      </reg>
      <reg name="norm_ctrl" protect="rw">
        <comment>通用控制寄存器</comment>
      </reg>
      <reg name="state_mem12" protect="rw">
        <comment>MEM12当前状态寄存器</comment>
        <bits access="r" name="pang_sta" pos="30:28" rst="0x0">
          <comment>Mem12 pang读写状态
000：IDLE
001：往MEM灌数据
010：MEM被灌满，没搬出
011：DMA搬数据
100：MEM被搬空
Others: IDLE</comment>
        </bits>
        <bits access="r" name="pang_addr" pos="26:16" rst="0x0">
          <comment>Mem12 pang地址</comment>
        </bits>
        <bits access="r" name="ping_sta" pos="14:12" rst="0x0">
          <comment>Mem12 ping读写状态
000：IDLE
001：往MEM灌数据
010：MEM被灌满，没搬出
011：DMA搬数据
100：MEM被搬空
Others: IDLE</comment>
        </bits>
        <bits access="r" name="ping_addr" pos="10:0" rst="0x0">
          <comment>Mem12 ping地址</comment>
        </bits>
      </reg>
      <reg name="state_mem34" protect="rw">
        <comment>MEM34当前状态寄存器</comment>
        <bits access="r" name="pang_sta" pos="30:28" rst="0x0">
          <comment>Mem34 pang读写状态
000：IDLE
001：往MEM灌数据
010：MEM被灌满，没搬出
011：DMA搬数据
100：MEM被搬空
Others: IDLE</comment>
        </bits>
        <bits access="r" name="pang_addr" pos="24:16" rst="0x0">
          <comment>Mem34 pang地址</comment>
        </bits>
        <bits access="r" name="ping_sta" pos="14:12" rst="0x0">
          <comment>Mem34 ping读写状态
000：IDLE
001：往MEM灌数据
010：MEM被灌满，没搬出
011：DMA搬数据
100：MEM被搬空
Others: IDLE</comment>
        </bits>
        <bits access="r" name="ping_addr" pos="8:0" rst="0x0">
          <comment>Mem34 ping地址</comment>
        </bits>
      </reg>
      <reg name="state_mem56" protect="rw">
        <comment>MEM56当前状态寄存器</comment>
        <bits access="r" name="pang_sta" pos="30:28" rst="0x0">
          <comment>Mem56 pang读写状态
000：IDLE
001：往MEM灌数据
010：MEM被灌满，没搬出
011：DMA搬数据
100：MEM被搬空
Others: IDLE</comment>
        </bits>
        <bits access="r" name="pang_addr" pos="25:16" rst="0x0">
          <comment>Mem56 pang地址</comment>
        </bits>
        <bits access="r" name="ping_sta" pos="14:12" rst="0x0">
          <comment>Mem56 ping读写状态
000：IDLE
001：往MEM灌数据
010：MEM被灌满，没搬出
011：DMA搬数据
100：MEM被搬空
Others: IDLE</comment>
        </bits>
        <bits access="r" name="ping_addr" pos="9:0" rst="0x0">
          <comment>Mem56 ping地址</comment>
        </bits>
      </reg>
      <reg name="state_err12" protect="rw">
        <comment>抓数EER12状态寄存器</comment>
        <bits access="r" name="which_mem" pos="24" rst="0x0">
          <comment>抓数Err的存储器
0：MEM12 Ping
1：MEM12 Pang</comment>
        </bits>
        <bits access="r" name="err_fn" pos="23:0" rst="0x0">
          <comment>抓数Error时的帧号(发生抓数ERR时锁存的帧号</comment>
        </bits>
      </reg>
      <reg name="state_err34" protect="rw">
        <comment>抓数EER34状态寄存器</comment>
        <bits access="r" name="which_mem" pos="24" rst="0x0">
          <comment>抓数Err的存储器
0：MEM34 Ping
1：MEM34 Pang</comment>
        </bits>
        <bits access="r" name="err_fn" pos="23:0" rst="0x0">
          <comment>抓数Error时的帧号(发生抓数ERR时锁存的帧号</comment>
        </bits>
      </reg>
      <reg name="capt_sta" protect="rw">
        <comment>抓数状态寄存器</comment>
        <bits access="r" name="otdoa_sta" pos="17:16" rst="0x0">
          <comment>otdoa_sta
00：未运行抓数功能
01：正抓取OTDOA
10：硬件finish信号结束抓数
11：软件清capt_cfg使能位结束抓数</comment>
        </bits>
        <bits access="r" name="iddet_sta" pos="13:12" rst="0x0">
          <comment>iddet_sta
00：未运行抓数功能
01：正抓取IDDET
10：硬件finish信号结束抓数
11：软件清capt_cfg使能位结束抓数</comment>
        </bits>
        <bits access="r" name="tx_sta" pos="9:8" rst="0x0">
          <comment>tx_sta
00：未运行抓数功能
01：正抓取TX
10：硬件finish信号结束抓数
11：软件清capt_cfg结束使能位结束抓数</comment>
        </bits>
        <bits access="r" name="dump_sta" pos="5:4" rst="0x0">
          <comment>dump_sta
00：未运行抓数功能
01：正抓取DUMP
10：硬件finish信号结束抓数
11：软件清capt_cfg使能位结束抓数</comment>
        </bits>
        <bits access="r" name="rx_sta" pos="1:0" rst="0x0">
          <comment>rx_sta
00：未运行抓数功能
01：正抓取RX
10：硬件finish信号结束抓数
11：软件清capt_cfg使能位结束抓数</comment>
        </bits>
      </reg>
      <reg name="fill1_sta1" protect="rw">
        <comment>DL offline灌数状态寄存器1</comment>
        <bits access="r" name="fill_running_sta" pos="29:28" rst="0x0">
          <comment>fill_running_sta
00：未运行灌数功能
01：正灌数
10：硬件搬完len结束灌数
11：软件清fill_cfg使能位结束灌数</comment>
        </bits>
        <bits access="r" name="out_len" pos="27:0" rst="0x0">
          <comment>out_len
当前HW吐出数据长度（I/Q对数）</comment>
        </bits>
      </reg>
      <reg name="fill1_sta2" protect="rw">
        <comment>DL offline灌数状态寄存器2</comment>
        <bits access="r" name="in_len" pos="27:0" rst="0x0">
          <comment>in_len
当前DMA搬入数据长度（I/Q对数）</comment>
        </bits>
      </reg>
      <reg name="fill2_sta1" protect="rw">
        <comment>IDDET offline灌数状态寄存器1</comment>
        <bits access="r" name="fill_running_sta" pos="29:28" rst="0x0">
          <comment>fill_running_sta
00：未运行灌数功能
01：正灌数
10：硬件搬完len结束灌数
11：软件清fill_cfg使能位结束灌数</comment>
        </bits>
        <bits access="r" name="out_len" pos="27:0" rst="0x0">
          <comment>out_len
当前HW吐出数据长度（I/Q对数）</comment>
        </bits>
      </reg>
      <reg name="fill2_sta2" protect="rw">
        <comment>IDDET offline灌数状态寄存器2</comment>
        <bits access="r" name="in_len" pos="27:0" rst="0x0">
          <comment>in_len
当前DMA搬入数据长度（I/Q对数）</comment>
        </bits>
      </reg>
      <reg name="dma_sta" protect="rw">
        <comment>DMA状态寄存器</comment>
        <bits access="r" name="ack_sta" pos="15:8" rst="0x0">
          <comment>DMA_ACK</comment>
        </bits>
        <bits access="r" name="req_sta" pos="7:0" rst="0x0">
          <comment>DMA_REQ</comment>
        </bits>
      </reg>
      <reg name="capt12_len" protect="rw">
        <bits access="r" name="current_len12" pos="23:0" rst="0x0"/>
      </reg>
      <reg name="capt34_len" protect="rw">
        <bits access="r" name="current_len34" pos="23:0" rst="0x0"/>
      </reg>
      <reg name="err_inten" protect="rw">
        <bits access="rw" name="err_inten_sr" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="err_inten_set" protect="rw">
        <bits access="rc" name="err_inten_set_sr" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="err_inten_clr" protect="rw">
        <bits access="rc" name="err_inten_clr_sr" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="err_int_sta" protect="rw">
        <bits access="rc" name="err_int_sta" pos="3:0" rst="0x0"/>
      </reg>
      <hole size="523296"/>
      <reg name="mem12_ping" protect="rw">
        <bits access="rw" name="mem12_ping_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem12_ping_0" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem12_pang" protect="rw">
        <bits access="rw" name="mem12_pang_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem12_pang_0" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem34_ping" protect="rw">
        <bits access="rw" name="mem34_ping_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem34_ping_0" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="16352"/>
      <reg name="mem34_pang" protect="rw">
        <bits access="rw" name="mem34_pang_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem34_pang_0" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="16352"/>
      <reg name="mem56_ping" protect="rw">
        <bits access="rw" name="mem56_ping_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem56_ping_0" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="mem56_pang" protect="rw">
        <bits access="rw" name="mem56_pang_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem56_pang_0" pos="15:4" rst="0x0"/>
      </reg>
    </module>
    <instance address="0x1a000000" name="RXCAPT" type="RXCAPT"/>
  </archive>
  <archive relative="pmic_adc.xml">
    <module category="System" name="PMIC_ADC">
      <reg name="auxadc_version" protect="rw">
        <comment>AUXADC IP version AUXADC IP version</comment>
        <bits access="r" name="auxadc_version" pos="15:0" rst="0x700">
          <comment>IP version r7p0</comment>
        </bits>
      </reg>
      <reg name="adc_cfg_ctrl" protect="rw">
        <comment>ADC ctrl information configure ADC ctrl information configure</comment>
        <bits access="rw" name="adc_offset_cal_en" pos="12" rst="0x0">
          <comment>Auxadc offset function enable
0: disable offset function
1: enable offset function</comment>
        </bits>
        <bits access="rw" name="rg_auxad_average" pos="10:8" rst="0x1">
          <comment>auxadc convert data out average control:
000: disable adc average, output 12bit data and valid after once conversion;
001: adc convert twice and output the average data;
010: adc convert 4 times and output the average data;
011: adc convert 8 times and output the average data;
100: adc convert 16 times and output the average data;
101: adc convert 32 times and output the average data;
110: adc convert 64 times and output the average data;
111: adc convert 128 times and output the average data;</comment>
        </bits>
        <bits access="rw" name="sw_ch_run_num" pos="7:4" rst="0x0">
          <comment>the number of SW channel accessing, N+1.</comment>
        </bits>
        <bits access="rw" name="adc_sign_code" pos="3" rst="0x0">
          <comment>AUXADC output code selection:
0:  adc_dout = (data-Doff)
1: if adc_offset_cal_en is 0
adc_dout = data
    if adc_offset_cal_en is 1
adc_dout = data-(Doff-2047)
more detail see Function Description</comment>
        </bits>
        <bits access="rw" name="adc_12b" pos="2" rst="0x1">
          <comment>ADC 12bits mode
0: ADC in 10bits mode;
1: ADC in 12bits mode.</comment>
        </bits>
        <bits access="rw" name="sw_ch_run" pos="1" rst="0x0">
          <comment>SW channel run,
Write '1' to run a SW channel accessing, it is cleared by HW.</comment>
        </bits>
        <bits access="rw" name="adc_en" pos="0" rst="0x0">
          <comment>ADC global enable,
0: ADC module disable;
1: ADC module enable.</comment>
        </bits>
      </reg>
      <reg name="adc_sw_ch_cfg" protect="rw">
        <comment>ADC SW channel configure  ADC SW channel configure</comment>
        <bits access="rw" name="adc_scale" pos="10:9" rst="0x0">
          <comment>ADC scale setting for current ADC channel</comment>
        </bits>
        <bits access="rw" name="adc_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="adc_cs" pos="4:0" rst="0x0">
          <comment>ADC software config channel ID.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch0_cfg" protect="rw">
        <comment>ADC fast HW channel0 configure  ADC fast HW channel0 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>ADC scale setting for current ADC channel</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch1_cfg" protect="rw">
        <comment>ADC fast HW channel1 configure  ADC fast HW channel1 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>ADC scale setting for current ADC channel</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch2_cfg" protect="rw">
        <comment>ADC fast HW channel2 configure  ADC fast HW channel2 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>ADC scale setting for current ADC channel</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch3_cfg" protect="rw">
        <comment>ADC fast HW channel3 configure  ADC fast HW channel3 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch4_cfg" protect="rw">
        <comment>ADC fast HW channel4 configure  ADC fast HW channel4 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch5_cfg" protect="rw">
        <comment>ADC fast HW channel5 configure  ADC fast HW channel5 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch6_cfg" protect="rw">
        <comment>ADC fast HW channel6 configure  ADC fast HW channel6 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch7_cfg" protect="rw">
        <comment>ADC fast HW channel7 configure  ADC fast HW channel7 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch0_cfg" protect="rw">
        <comment>ADC slow HW channel0 configure  ADC slow HW channel0 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch1_cfg" protect="rw">
        <comment>ADC slow HW channel1 configure  ADC slow HW channel1 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch2_cfg" protect="rw">
        <comment>ADC slow HW channel2 configure  ADC slow HW channel2 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch3_cfg" protect="rw">
        <comment>ADC slow HW channel3 configure  ADC slow HW channel3 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch4_cfg" protect="rw">
        <comment>ADC slow HW channel4 configure  ADC slow HW channel4 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch5_cfg" protect="rw">
        <comment>ADC slow HW channel5 configure  ADC slow HW channel5 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch6_cfg" protect="rw">
        <comment>ADC slow HW channel6 configure  ADC slow HW channel6 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch7_cfg" protect="rw">
        <comment>ADC slow HW channel7 configure  ADC slow HW channel7 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_hw_ch_delay" protect="rw">
        <comment>ADC HW channel accessing dealy ADC HW channel accessing dealy</comment>
        <bits access="rw" name="hw_ch_delay" pos="7:0" rst="0x0">
          <comment>ADC HW channel accessing delay, its unit is ADC clock.
It can be use for signal without enough setup time.</comment>
        </bits>
      </reg>
      <reg name="adc_dat" protect="rw">
        <comment>ADC conversion result ADC conversion result</comment>
        <bits access="r" name="adc_dat_sw" pos="11:0" rst="0x0">
          <comment>ADC conversion result.</comment>
        </bits>
      </reg>
      <reg name="adc_cfg_int_en" protect="rw">
        <comment>ADC interrupt enable ADC interrupt enable</comment>
        <bits access="rw" name="adc_int_en" pos="0" rst="0x0">
          <comment>ADC interrupt enable, 0: disable; 1: enable.</comment>
        </bits>
      </reg>
      <reg name="adc_cfg_int_clr" protect="rw">
        <comment>ADC interrupt clear ADC interrupt clear</comment>
        <bits access="w" name="adc_int_clr" pos="0" rst="0x0">
          <comment>ADC interrupt clear. Write &quot;1&quot; to clear.</comment>
        </bits>
      </reg>
      <reg name="adc_cfg_int_sattus" protect="rw">
        <comment>ADC masked interrupt ADC masked interrupt</comment>
        <bits access="r" name="adc_int_status" pos="0" rst="0x0">
          <comment>ADC masked interrupt.</comment>
        </bits>
      </reg>
      <reg name="adc_cfg_int_raw" protect="rw">
        <comment>ADC raw interrupt ADC raw interrupt</comment>
        <bits access="r" name="adc_int_raw" pos="0" rst="0x0">
          <comment>ADC raw interrupt.</comment>
        </bits>
      </reg>
      <reg name="adc_debug" protect="rw">
        <comment>ADC debug information ADC debug information</comment>
        <bits access="r" name="adc_dbg_ch" pos="15:11" rst="0x0">
          <comment>0~7: fast HW channels;
8: SW channels;
9~16: slow HW channel;
31: no request.</comment>
        </bits>
        <bits access="r" name="adc_dbg_state" pos="10:8" rst="0x0">
          <comment>ADC accessing state:
0: idle;
1: fast HW request;
2: SW request;
3: slow HW request;
4: wait for fast HW request;
5: wait for slow HW request.</comment>
        </bits>
        <bits access="r" name="adc_dbg_cnt" pos="7:0" rst="0x0">
          <comment>ADC internal counter status, 0: idle; 1~n: work or wait counter.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_timer_en" protect="rw">
        <comment>ADC fast HW channel timer enable ADC fast HW channel timer enable</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch7_timer_en" pos="7" rst="0x0">
          <comment>ADC fast HW channel7 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch6_timer_en" pos="6" rst="0x0">
          <comment>ADC fast HW channel6 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch5_timer_en" pos="5" rst="0x0">
          <comment>ADC fast HW channel5 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch4_timer_en" pos="4" rst="0x0">
          <comment>ADC fast HW channel4 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch3_timer_en" pos="3" rst="0x0">
          <comment>ADC fast HW channel3 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch2_timer_en" pos="2" rst="0x0">
          <comment>ADC fast HW channel2 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch1_timer_en" pos="1" rst="0x0">
          <comment>ADC fast HW channel1 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch0_timer_en" pos="0" rst="0x0">
          <comment>ADC fast HW channel0 timer enable, 0:disable; 1: enable.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_timer_div" protect="rw">
        <comment>ADC fast HW channel timer working clock divider ADC fast HW channel timer working clock divider</comment>
        <bits access="rw" name="rg_adc_fast_hw_timer_div" pos="15:0" rst="0x0">
          <comment>ADC fast HW channel timer working clock divider.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch0_timer_thresh" protect="rw">
        <comment>ADC fast HW channel0 timer threshold ADC fast HW channel0 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch0_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch0 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch1_timer_thresh" protect="rw">
        <comment>ADC fast HW channel1 timer threshold ADC fast HW channel1 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch1_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch1 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch2_timer_thresh" protect="rw">
        <comment>ADC fast HW channel2 timer threshold ADC fast HW channel2 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch2_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch2 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch3_timer_thresh" protect="rw">
        <comment>ADC fast HW channel3 timer threshold ADC fast HW channel3 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch3_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch3 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch4_timer_thresh" protect="rw">
        <comment>ADC fast HW channel4 timer threshold ADC fast HW channel4 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch4_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch4 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch5_timer_thresh" protect="rw">
        <comment>ADC fast HW channel5 timer threshold ADC fast HW channel5 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch5_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch5 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch6_timer_thresh" protect="rw">
        <comment>ADC fast HW channel6 timer threshold ADC fast HW channel6 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch6_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch6 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch7_timer_thresh" protect="rw">
        <comment>ADC fast HW channel7 timer threshold ADC fast HW channel7 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch7_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch7 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch0_dat" protect="rw">
        <comment>ADC fast HW channel0 data ADC fast HW channel0 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch0 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch1_dat" protect="rw">
        <comment>ADC fast HW channel1 data ADC fast HW channel1 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch1 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch2_dat" protect="rw">
        <comment>ADC fast HW channel2 data ADC fast HW channel2 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch2 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch3_dat" protect="rw">
        <comment>ADC fast HW channel3 data ADC fast HW channel3 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch3 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch4_dat" protect="rw">
        <comment>ADC fast HW channel4 data ADC fast HW channel4 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch4 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch5_dat" protect="rw">
        <comment>ADC fast HW channel5 data ADC fast HW channel5 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch5 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch6_dat" protect="rw">
        <comment>ADC fast HW channel6 data ADC fast HW channel6 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch6 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch7_dat" protect="rw">
        <comment>ADC fast HW channel7 data ADC fast HW channel7 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch7 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="auxadc_ctrl0" protect="rw">
        <comment>ADC NTC ctrl information ADC NTC ctrl information</comment>
        <bits access="rw" name="rg_auxad_ref_sel" pos="5" rst="0x0">
          <comment>output to analog</comment>
        </bits>
        <bits access="rw" name="rg_auxad_thm_cal" pos="4" rst="0x0">
          <comment>output to analog
THM calibration enable signal,
0: disable THM calibration(default)
1: enable THM calibration, must set high 100us before AUXADC measure THM voltage and start the calibration</comment>
        </bits>
        <bits access="rw" name="rg_auxad_currentsen_en" pos="0" rst="0x0">
          <comment>output to analog
Aux ADC current sense enable signal, active high, default 0.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_dvalid" protect="rw">
        <comment>ADC fast HW channel data valid ADC fast HW channel data valid</comment>
        <bits access="r" name="rg_adc_fast_hw_ch7_dvld" pos="7" rst="0x0">
          <comment>ADC fast HW channel7 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch6_dvld" pos="6" rst="0x0">
          <comment>ADC fast HW channel6 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch5_dvld" pos="5" rst="0x0">
          <comment>ADC fast HW channel5 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch4_dvld" pos="4" rst="0x0">
          <comment>ADC fast HW channel4 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch3_dvld" pos="3" rst="0x0">
          <comment>ADC fast HW channel3 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch2_dvld" pos="2" rst="0x0">
          <comment>ADC fast HW channel2 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch1_dvld" pos="1" rst="0x0">
          <comment>ADC fast HW channel1 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch0_dvld" pos="0" rst="0x0">
          <comment>ADC fast HW channel0 data valid.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108100" name="PMIC_ADC" type="PMIC_ADC"/>
  </archive>
  <archive relative="pmic_bltc.xml">
    <module category="System" name="PMIC_BLTC">
      <reg name="bltc_ctl" protect="rw">
        <comment>BLTC control 1. BLTC output select
2. BLTC output select(1: output by SW, 0: output by HW);
3. BLTC output type select (1: normal PWM, 0: breath light);
4, BLTC run enable signal</comment>
        <bits access="rw" name="wled_sw" pos="15" rst="0x0">
          <comment>BLTC WLED output value when by SW.</comment>
        </bits>
        <bits access="rw" name="wled_sel" pos="14" rst="0x0">
          <comment>BLTC WLED output selection</comment>
        </bits>
        <bits access="rw" name="wled_type" pos="13" rst="0x0">
          <comment>BLTC WLED output type</comment>
        </bits>
        <bits access="rw" name="wled_run" pos="12" rst="0x0">
          <comment>BLTC WLED run</comment>
        </bits>
        <bits access="rw" name="b_sw" pos="11" rst="0x0">
          <comment>BLTC B output value when by SW.</comment>
        </bits>
        <bits access="rw" name="b_sel" pos="10" rst="0x0">
          <comment>BLTC B output selection</comment>
        </bits>
        <bits access="rw" name="b_type" pos="9" rst="0x0">
          <comment>BLTC B output type</comment>
        </bits>
        <bits access="rw" name="b_run" pos="8" rst="0x0">
          <comment>BLTC B run</comment>
        </bits>
        <bits access="rw" name="g_sw" pos="7" rst="0x0">
          <comment>BLTC G output value when by SW.</comment>
        </bits>
        <bits access="rw" name="g_sel" pos="6" rst="0x0">
          <comment>BLTC G output selection</comment>
        </bits>
        <bits access="rw" name="g_type" pos="5" rst="0x0">
          <comment>BLTC G output type</comment>
        </bits>
        <bits access="rw" name="g_run" pos="4" rst="0x0">
          <comment>BLTC G run</comment>
        </bits>
        <bits access="rw" name="r_sw" pos="3" rst="0x0">
          <comment>BLTC R output value when by SW.</comment>
        </bits>
        <bits access="rw" name="r_sel" pos="2" rst="0x0">
          <comment>BLTC R output selection</comment>
        </bits>
        <bits access="rw" name="r_type" pos="1" rst="0x0">
          <comment>BLTC R output type</comment>
        </bits>
        <bits access="rw" name="r_run" pos="0" rst="0x0">
          <comment>BLTC R run</comment>
        </bits>
      </reg>
      <reg name="bltc_r_prescale" protect="rw">
        <comment>BLTC R prescale coefficient PWM prescale coefficient for work clock.</comment>
        <bits access="rw" name="prescl" pos="7:0" rst="0x0">
          <comment>BLTC prescale coefficient.</comment>
        </bits>
      </reg>
      <reg name="bltc_r_duty" protect="rw">
        <comment>BLTC R duty config PWM duty config.</comment>
        <bits access="rw" name="duty" pos="15:8" rst="0x0">
          <comment>PWM duty counter,duty cycle = duty /(mod+1)</comment>
        </bits>
        <bits access="rw" name="mode" pos="7:0" rst="0x0">
          <comment>PWM mod counter.</comment>
        </bits>
      </reg>
      <reg name="bltc_r_curve0" protect="rw">
        <comment>BLTC R rise/fall config BLTC R rise/fall config</comment>
        <bits access="rw" name="tfall" pos="13:8" rst="0x0">
          <comment>Output falling time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="trise" pos="5:0" rst="0x0">
          <comment>Output rising time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_r_curve1" protect="rw">
        <comment>BLTC R high/low config BLTC R high/low config</comment>
        <bits access="rw" name="tlow" pos="15:8" rst="0x0">
          <comment>Output low time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="thigh" pos="7:0" rst="0x0">
          <comment>Output  high time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_g_prescale" protect="rw">
        <comment>BLTC G prescale coefficient PWM prescale coefficient for work clock.</comment>
        <bits access="rw" name="prescl" pos="7:0" rst="0x0">
          <comment>BLTC prescale coefficient.</comment>
        </bits>
      </reg>
      <reg name="bltc_g_duty" protect="rw">
        <comment>BLTC G duty config PWM duty config.</comment>
        <bits access="rw" name="duty" pos="15:8" rst="0x0">
          <comment>PWM duty counter,duty cycle = duty /(mod+1)</comment>
        </bits>
        <bits access="rw" name="mode" pos="7:0" rst="0x0">
          <comment>PWM mod counter.</comment>
        </bits>
      </reg>
      <reg name="bltc_g_curve0" protect="rw">
        <comment>BLTC G rise/fall config BLTC G rise/fall config</comment>
        <bits access="rw" name="tfall" pos="13:8" rst="0x0">
          <comment>Output falling time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="trise" pos="5:0" rst="0x0">
          <comment>Output rising time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_g_curve1" protect="rw">
        <comment>BLTC G high/low config BLTC G high/low config</comment>
        <bits access="rw" name="tlow" pos="15:8" rst="0x0">
          <comment>Output low time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="thigh" pos="7:0" rst="0x0">
          <comment>Output  high time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_b_prescale" protect="rw">
        <comment>BLTC B prescale coefficient PWM prescale coefficient for work clock.</comment>
        <bits access="rw" name="prescl" pos="7:0" rst="0x0">
          <comment>BLTC prescale coefficient.</comment>
        </bits>
      </reg>
      <reg name="bltc_b_duty" protect="rw">
        <comment>BLTC B duty config PWM duty config.</comment>
        <bits access="rw" name="duty" pos="15:8" rst="0x0">
          <comment>PWM duty counter,duty cycle = duty /(mod+1)</comment>
        </bits>
        <bits access="rw" name="mode" pos="7:0" rst="0x0">
          <comment>PWM mod counter.</comment>
        </bits>
      </reg>
      <reg name="bltc_b_curve0" protect="rw">
        <comment>BLTC B rise/fall config BLTC B rise/fall config</comment>
        <bits access="rw" name="tfall" pos="13:8" rst="0x0">
          <comment>Output falling time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="trise" pos="5:0" rst="0x0">
          <comment>Output rising time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_b_curve1" protect="rw">
        <comment>BLTC B high/low config BLTC B high/low config</comment>
        <bits access="rw" name="tlow" pos="15:8" rst="0x0">
          <comment>Output low time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="thigh" pos="7:0" rst="0x0">
          <comment>Output  high time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_sts" protect="rw">
        <comment>BLTC status BLTC status</comment>
        <bits access="r" name="bltc_wled_busy" pos="3" rst="0x0">
          <comment>BLTC WLED busy, active high.</comment>
        </bits>
        <bits access="r" name="bltc_b_busy" pos="2" rst="0x0">
          <comment>BLTC B busy, active high.</comment>
        </bits>
        <bits access="r" name="bltc_g_busy" pos="1" rst="0x0">
          <comment>BLTC G busy, active high.</comment>
        </bits>
        <bits access="r" name="bltc_r_busy" pos="0" rst="0x0">
          <comment>BLTC R busy, active high.</comment>
        </bits>
      </reg>
      <reg name="bltc_r_isat" protect="rw">
        <comment>BLTC R current strength config. BLTC current strength config.</comment>
        <bits access="rw" name="isat" pos="5:0" rst="0x0">
          <comment>Current strength config.</comment>
        </bits>
      </reg>
      <reg name="bltc_g_isat" protect="rw">
        <comment>BLTC G current strength config. BLTC current strength config.</comment>
        <bits access="rw" name="isat" pos="5:0" rst="0x0">
          <comment>Current strength config.</comment>
        </bits>
      </reg>
      <reg name="bltc_b_isat" protect="rw">
        <comment>BLTC B current strength config. BLTC current strength config.</comment>
        <bits access="rw" name="isat" pos="5:0" rst="0x0">
          <comment>Current strength config.</comment>
        </bits>
      </reg>
      <reg name="bltc_wled_isat" protect="rw">
        <comment>BLTC WLED current strength config. BLTC current strength config.</comment>
        <bits access="rw" name="isat" pos="5:0" rst="0x0">
          <comment>Current strength config.</comment>
        </bits>
      </reg>
      <reg name="bltc_wled_prescale" protect="rw">
        <comment>BLTC WLED prescale coefficient PWM prescale coefficient for work clock.</comment>
        <bits access="rw" name="prescl" pos="7:0" rst="0x0">
          <comment>BLTC prescale coefficient.</comment>
        </bits>
      </reg>
      <reg name="bltc_wled_duty" protect="rw">
        <comment>BLTC WLED duty config PWM duty config.</comment>
        <bits access="rw" name="duty" pos="15:8" rst="0x0">
          <comment>PWM duty counter,duty cycle = duty /(mod+1)</comment>
        </bits>
        <bits access="rw" name="mode" pos="7:0" rst="0x0">
          <comment>PWM mod counter.</comment>
        </bits>
      </reg>
      <reg name="bltc_wled_curve0" protect="rw">
        <comment>BLTC WLED rise/fall config BLTC WLED rise/fall config</comment>
        <bits access="rw" name="tfall" pos="13:8" rst="0x0">
          <comment>Output falling time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="trise" pos="5:0" rst="0x0">
          <comment>Output rising time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_wled_curve1" protect="rw">
        <comment>BLTC WLED high/low config BLTC WLED high/low config</comment>
        <bits access="rw" name="tlow" pos="15:8" rst="0x0">
          <comment>Output low time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="thigh" pos="7:0" rst="0x0">
          <comment>Output  high time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_pd_ctrl" protect="rw">
        <comment>BLTC current strength config. BLTC current strength config.</comment>
        <bits access="rw" name="hw_pd" pos="1" rst="0x1">
          <comment>Power down signal</comment>
        </bits>
        <bits access="rw" name="sw_pd" pos="0" rst="0x1">
          <comment>Power down signal</comment>
        </bits>
      </reg>
      <reg name="bltc_version" protect="rw">
        <comment>BLTC version BLTC WLED high/low config</comment>
        <bits access="rw" name="bltc_version" pos="15:0" rst="0x0">
          <comment>bltc version information</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108080" name="PMIC_BLTC" type="PMIC_BLTC"/>
  </archive>
  <archive relative="pmic_efuse.xml">
    <module category="System" name="PMIC_EFUSE">
      <reg name="efuse_glb_ctrl" protect="rw">
        <comment>efuse global control register</comment>
        <bits access="rw" name="efuse_clk_gate" pos="3" rst="0x1">
          <comment>Control efs_clk gate
1: gate efs_clk</comment>
        </bits>
        <bits access="rw" name="efuse_type" pos="2:1">
          <comment>Efuse type select, 00:TSMC default</comment>
        </bits>
        <bits access="rw" name="efuse_pgm_en" pos="0">
          <comment>Efuse SW programme enable</comment>
        </bits>
      </reg>
      <reg name="efuse_data_rd" protect="rw">
        <comment>Data read from efuse memory</comment>
        <bits access="r" name="efuse_data_rd" pos="15:0">
          <comment>Efuse read data,
If SW  use efuse controller to send a read command to efuse memory, the return value will store here.</comment>
        </bits>
      </reg>
      <reg name="efuse_data_wr" protect="rw">
        <comment>Data to be write to efuse memory</comment>
        <bits access="rw" name="efuse_data_wr" pos="15:0">
          <comment>Efuse data to be write.
If SW want to program the efuse memory, the data to be programmed  will write to this register before SW issue a PGM command.</comment>
        </bits>
      </reg>
      <reg name="efuse_addr_index" protect="rw">
        <comment>block index for read, program</comment>
        <bits access="rw" name="read_write_index" pos="5:0">
          <comment>The efuse memory block index to be read or write.</comment>
        </bits>
      </reg>
      <reg name="efuse_mode_ctrl" protect="rw">
        <comment>Mode control of efuse memory</comment>
        <bits access="w" name="efuse_normal_rd_flag_clr" pos="2">
          <comment>Write 1 to this bit will clear normal read flag.This bit is self-clear, read this bit will always get 0</comment>
        </bits>
        <bits access="w" name="efuse_rd_start" pos="1">
          <comment>Write 1 to this bit start READ mode(read mode).This bit is self-clear, read this bit will always get 0</comment>
        </bits>
        <bits access="w" name="efuse_pg_start" pos="0">
          <comment>Write 1 to this bit start PGM mode(PGM mode). This bit is self-clear, read this bit will always get 0</comment>
        </bits>
      </reg>
      <reg name="efuse_status" protect="rw">
        <comment>Efuse controller internal status</comment>
        <bits access="r" name="efuse_normal_rd_done" pos="4">
          <comment>“1” indicate EFUSE normal read has been done</comment>
        </bits>
        <bits access="r" name="efuse_global_prot" pos="3">
          <comment>If SW send a PGM command to memory and memory controller find the memory need to be protected (LSB of 64 bit is 1), this flag will be set to 1.</comment>
        </bits>
        <bits access="r" name="standby_busy" pos="2" rst="0x1">
          <comment>“1” indicate efuse memory in standby mode</comment>
        </bits>
        <bits access="r" name="read_busy" pos="1">
          <comment>“1” indicate efuse memory in read mode</comment>
        </bits>
        <bits access="r" name="pgm_busy" pos="0">
          <comment>“1” indicate efuse memory in programming mode</comment>
        </bits>
      </reg>
      <reg name="efuse_magic_number" protect="rw">
        <comment>magic number to protect efuse from un-intentionally programming</comment>
        <bits access="rw" name="efuse_magic_number" pos="15:0">
          <comment>Magic number, only when this field is  0x7520, the Efuse programming command can be handle.
So if SW want to program efuse memory, except open clocks and power, 2 other  conditions must be met :
a) PGM_EN =1;
b) EFUSE_MAGIC_NUMBER = 0x7520</comment>
        </bits>
      </reg>
      <reg name="efuse_margin_magic_number" protect="rw">
        <comment>magic number to protect efuse from un-intentionally programming</comment>
        <bits access="rw" name="efuse_margin_magic_number" pos="15:0">
          <comment>Magic number, only when this field is  0x6688,  the margin read is usable.</comment>
        </bits>
      </reg>
      <reg name="efuse_wr_timing_ctrl" protect="rw">
        <comment>Write command timing control</comment>
        <bits access="rw" name="efuse_wr_timing_ctrl" pos="15:0" rst="0x5d91">
          <comment>Config this register to control the timing of writing operation related signals</comment>
        </bits>
      </reg>
      <reg name="efuse_rd_timing_ctrl" protect="rw">
        <comment>Read command timing control</comment>
        <bits access="rw" name="efuse_rd_timing_ctrl" pos="15:0" rst="0x3e">
          <comment>Config this register to control the timing of writing operation related signals</comment>
        </bits>
      </reg>
      <reg name="efuse_version" protect="rw">
        <comment>EFUSE control version registers</comment>
        <bits access="r" name="efuse_version" pos="15:0" rst="0x100">
          <comment>Efuse control version register</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="efuse_por_blk00" protect="rw">
        <comment>EFUSE POR READ BLK00</comment>
        <bits access="r" name="efuse_por_blk00" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk01" protect="rw">
        <comment>EFUSE POR READ BLK01</comment>
        <bits access="r" name="efuse_por_blk01" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk02" protect="rw">
        <comment>EFUSE POR READ BLK02</comment>
        <bits access="r" name="efuse_por_blk02" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk03" protect="rw">
        <comment>EFUSE POR READ BLK03</comment>
        <bits access="r" name="efuse_por_blk03" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk04" protect="rw">
        <comment>EFUSE POR READ BLK04</comment>
        <bits access="r" name="efuse_por_blk04" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk05" protect="rw">
        <comment>EFUSE POR READ BLK05</comment>
        <bits access="r" name="efuse_por_blk05" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk06" protect="rw">
        <comment>EFUSE POR READ BLK06</comment>
        <bits access="r" name="efuse_por_blk06" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk07" protect="rw">
        <comment>EFUSE POR READ BLK07</comment>
        <bits access="r" name="efuse_por_blk07" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk08" protect="rw">
        <comment>EFUSE POR READ BLK08</comment>
        <bits access="r" name="efuse_por_blk08" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk09" protect="rw">
        <comment>EFUSE POR READ BLK09</comment>
        <bits access="r" name="efuse_por_blk09" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk10" protect="rw">
        <comment>EFUSE POR READ BLK10</comment>
        <bits access="r" name="efuse_por_blk10" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk11" protect="rw">
        <comment>EFUSE POR READ BLK11</comment>
        <bits access="r" name="efuse_por_blk11" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk12" protect="rw">
        <comment>EFUSE POR READ BLK12</comment>
        <bits access="r" name="efuse_por_blk12" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk13" protect="rw">
        <comment>EFUSE POR READ BLK13</comment>
        <bits access="r" name="efuse_por_blk13" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk14" protect="rw">
        <comment>EFUSE POR READ BLK14</comment>
        <bits access="r" name="efuse_por_blk14" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk15" protect="rw">
        <comment>EFUSE POR READ BLK15</comment>
        <bits access="r" name="efuse_por_blk15" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk16" protect="rw">
        <comment>EFUSE POR READ BLK16</comment>
        <bits access="r" name="efuse_por_blk16" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk17" protect="rw">
        <comment>EFUSE POR READ BLK17</comment>
        <bits access="r" name="efuse_por_blk17" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk18" protect="rw">
        <comment>EFUSE POR READ BLK18</comment>
        <bits access="r" name="efuse_por_blk18" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk19" protect="rw">
        <comment>EFUSE POR READ BLK19</comment>
        <bits access="r" name="efuse_por_blk19" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk20" protect="rw">
        <comment>EFUSE POR READ BLK20</comment>
        <bits access="r" name="efuse_por_blk20" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk21" protect="rw">
        <comment>EFUSE POR READ BLK21</comment>
        <bits access="r" name="efuse_por_blk21" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk22" protect="rw">
        <comment>EFUSE POR READ BLK22</comment>
        <bits access="r" name="efuse_por_blk22" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk23" protect="rw">
        <comment>EFUSE POR READ BLK23</comment>
        <bits access="r" name="efuse_por_blk23" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk24" protect="rw">
        <comment>EFUSE POR READ BLK24</comment>
        <bits access="r" name="efuse_por_blk24" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk25" protect="rw">
        <comment>EFUSE POR READ BLK25</comment>
        <bits access="r" name="efuse_por_blk25" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk26" protect="rw">
        <comment>EFUSE POR READ BLK26</comment>
        <bits access="r" name="efuse_por_blk26" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk27" protect="rw">
        <comment>EFUSE POR READ BLK27</comment>
        <bits access="r" name="efuse_por_blk27" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk28" protect="rw">
        <comment>EFUSE POR READ BLK28</comment>
        <bits access="r" name="efuse_por_blk28" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk29" protect="rw">
        <comment>EFUSE POR READ BLK29</comment>
        <bits access="r" name="efuse_por_blk29" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk30" protect="rw">
        <comment>EFUSE POR READ BLK30</comment>
        <bits access="r" name="efuse_por_blk30" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk31" protect="rw">
        <comment>EFUSE POR READ BLK31</comment>
        <bits access="r" name="efuse_por_blk31" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk32" protect="rw">
        <comment>EFUSE POR READ BLK32</comment>
        <bits access="r" name="efuse_por_blk32" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk33" protect="rw">
        <comment>EFUSE POR READ BLK33</comment>
        <bits access="r" name="efuse_por_blk33" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk34" protect="rw">
        <comment>EFUSE POR READ BLK34</comment>
        <bits access="r" name="efuse_por_blk34" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk35" protect="rw">
        <comment>EFUSE POR READ BLK35</comment>
        <bits access="r" name="efuse_por_blk35" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk36" protect="rw">
        <comment>EFUSE POR READ BLK36</comment>
        <bits access="r" name="efuse_por_blk36" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk37" protect="rw">
        <comment>EFUSE POR READ BLK37</comment>
        <bits access="r" name="efuse_por_blk37" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk38" protect="rw">
        <comment>EFUSE POR READ BLK38</comment>
        <bits access="r" name="efuse_por_blk38" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk39" protect="rw">
        <comment>EFUSE POR READ BLK39</comment>
        <bits access="r" name="efuse_por_blk39" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk40" protect="rw">
        <comment>EFUSE POR READ BLK40</comment>
        <bits access="r" name="efuse_por_blk40" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk41" protect="rw">
        <comment>EFUSE POR READ BLK41</comment>
        <bits access="r" name="efuse_por_blk41" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk42" protect="rw">
        <comment>EFUSE POR READ BLK42</comment>
        <bits access="r" name="efuse_por_blk42" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk43" protect="rw">
        <comment>EFUSE POR READ BLK43</comment>
        <bits access="r" name="efuse_por_blk43" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk44" protect="rw">
        <comment>EFUSE POR READ BLK44</comment>
        <bits access="r" name="efuse_por_blk44" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk45" protect="rw">
        <comment>EFUSE POR READ BLK45</comment>
        <bits access="r" name="efuse_por_blk45" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk46" protect="rw">
        <comment>EFUSE POR READ BLK46</comment>
        <bits access="r" name="efuse_por_blk46" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk47" protect="rw">
        <comment>EFUSE POR READ BLK47</comment>
        <bits access="r" name="efuse_por_blk47" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk48" protect="rw">
        <comment>EFUSE POR READ BLK48</comment>
        <bits access="r" name="efuse_por_blk48" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk49" protect="rw">
        <comment>EFUSE POR READ BLK49</comment>
        <bits access="r" name="efuse_por_blk49" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk50" protect="rw">
        <comment>EFUSE POR READ BLK50</comment>
        <bits access="r" name="efuse_por_blk50" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk51" protect="rw">
        <comment>EFUSE POR READ BLK51</comment>
        <bits access="r" name="efuse_por_blk51" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk52" protect="rw">
        <comment>EFUSE POR READ BLK52</comment>
        <bits access="r" name="efuse_por_blk52" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk53" protect="rw">
        <comment>EFUSE POR READ BLK53</comment>
        <bits access="r" name="efuse_por_blk53" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk54" protect="rw">
        <comment>EFUSE POR READ BLK54</comment>
        <bits access="r" name="efuse_por_blk54" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk55" protect="rw">
        <comment>EFUSE POR READ BLK55</comment>
        <bits access="r" name="efuse_por_blk55" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk56" protect="rw">
        <comment>EFUSE POR READ BLK56</comment>
        <bits access="r" name="efuse_por_blk56" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk57" protect="rw">
        <comment>EFUSE POR READ BLK57</comment>
        <bits access="r" name="efuse_por_blk57" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk58" protect="rw">
        <comment>EFUSE POR READ BLK58</comment>
        <bits access="r" name="efuse_por_blk58" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk59" protect="rw">
        <comment>EFUSE POR READ BLK59</comment>
        <bits access="r" name="efuse_por_blk59" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk60" protect="rw">
        <comment>EFUSE POR READ BLK60</comment>
        <bits access="r" name="efuse_por_blk60" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk61" protect="rw">
        <comment>EFUSE POR READ BLK61</comment>
        <bits access="r" name="efuse_por_blk61" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk62" protect="rw">
        <comment>EFUSE POR READ BLK62</comment>
        <bits access="r" name="efuse_por_blk62" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk63" protect="rw">
        <comment>EFUSE POR READ BLK63</comment>
        <bits access="r" name="efuse_por_blk63" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108200" name="PMIC_EFUSE" type="PMIC_EFUSE"/>
  </archive>
  <archive relative="pmic_eic.xml">
    <module category="System" name="PMIC_EIC">
      <reg name="eic_dbnc_data" protect="rw">
        <comment>EIC_DBNC bits data register, read only</comment>
        <bits access="r" name="dbnc_data" pos="15:0" rst="0x0">
          <comment>EIC_DBNC bits data input</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_dmsk" protect="rw">
        <comment>EIC_DBNC bits data mask register</comment>
        <bits access="rw" name="dbnc_dmsk" pos="15:0" rst="0x0">
          <comment>EIC_DBNC_DATA register can be read if EIC_DBNC_DMSK set “1”</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="eic_dbnc_iev" protect="rw">
        <comment>EIC_DBNC bits interrupt status register</comment>
        <bits access="rw" name="dbnc_iev" pos="15:0" rst="0xffff">
          <comment>EIC_DBNC bits interrupt status register:
“1” high levels trigger interrupts,
“0” low levels trigger interrupts.</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_ie" protect="rw">
        <comment>EIC_DBNC bits interrupt enable register</comment>
        <bits access="rw" name="dbnc_ie" pos="15:0" rst="0x0">
          <comment>EIC_DBNC bits interrupt enable register:
“1” corresponding bit interrupt is enabled.
“0” corresponding bit interrupt isn't enabled</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_ris" protect="rw">
        <comment>EIC_DBNC bits raw interrupt status register, and it reflects the status of interrupts trigger conditions detection on pins (prior to EIC_DBNC_MIS)</comment>
        <bits access="r" name="dbnc_ris" pos="15:0" rst="0x0">
          <comment>EIC bits raw interrupt status register:
“1” interrupt condition met
“0” condition not met</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_mis" protect="rw">
        <comment>EIC_DBNC bits masked interrupt status register</comment>
        <bits access="r" name="dbnc_mis" pos="15:0" rst="0x0">
          <comment>EIC_DBNC bits masked interrupt status register:
“1” Interrupt active
“0” interrupt not active</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_ic" protect="rw">
        <comment>EIC_DBNC_ bits interrupt clear register</comment>
        <bits access="rc" name="dbnc_ic" pos="15:0" rst="0x0">
          <comment>EIC_DBNC bits interrupt clear register:
“1” clears detected interrupt.
“0” has no effect.</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_trig" protect="rw">
        <comment>EIC_DBNC bits trig control register</comment>
        <bits access="w" name="dbnc_trig" pos="15:0" rst="0x0">
          <comment>EIC_DBNC bits trig control register:
“1”: generate the trig_start pulse
“0”: no effect
It must set EIC_DBNC_TRIG for using de-bounce function and getting active interrupt.</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="eic0_dbnc_ctrl" protect="rw">
        <comment>EIC0_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc0" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en0" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt0" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic1_dbnc_ctrl" protect="rw">
        <comment>EIC1_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc1" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en1" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt1" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic2_dbnc_ctrl" protect="rw">
        <comment>EIC2_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc2" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en2" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt2" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic3_dbnc_ctrl" protect="rw">
        <comment>EIC3_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc3" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en3" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt3" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic4_dbnc_ctrl" protect="rw">
        <comment>EIC4_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc4" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en4" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt4" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic5_dbnc_ctrl" protect="rw">
        <comment>EIC5_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc5" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en5" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt5" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic6_dbnc_ctrl" protect="rw">
        <comment>EIC6_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc6" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en6" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt6" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic7_dbnc_ctrl" protect="rw">
        <comment>EIC7_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc7" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en7" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt7" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic8_dbnc_ctrl" protect="rw">
        <comment>EIC8_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc8" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en8" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt8" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic9_dbnc_ctrl" protect="rw">
        <comment>EIC9_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc9" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en9" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt9" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic10_dbnc_ctrl" protect="rw">
        <comment>EIC10_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc10" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en10" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt10" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic11_dbnc_ctrl" protect="rw">
        <comment>EIC11_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc11" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en11" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt11" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic12_dbnc_ctrl" protect="rw">
        <comment>EIC12_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc12" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en12" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt12" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic13_dbnc_ctrl" protect="rw">
        <comment>EIC13_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc13" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en13" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt13" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic14_dbnc_ctrl" protect="rw">
        <comment>EIC14_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc14" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en14" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt14" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
      <reg name="eic15_dbnc_ctrl" protect="rw">
        <comment>EIC15_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc15" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en15" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt15" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 （1000/1024） millisecond</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108500" name="PMIC_EIC" type="PMIC_EIC"/>
  </archive>
  <archive relative="pmic_rtc.xml">
    <module category="System" name="PMIC_RTC">
      <reg name="rtc_sec_cnt_value" protect="rw">
        <comment>RTC second counter value</comment>
        <bits access="r" name="rtc_sec_cnt_value" pos="5:0" rst="0x0">
          <comment>RTC second counter value</comment>
        </bits>
      </reg>
      <reg name="rtc_min_cnt_value" protect="rw">
        <comment>RTC minute counter value</comment>
        <bits access="r" name="rtc_min_cnt_value" pos="5:0" rst="0x0">
          <comment>RTC minute counter value</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_cnt_value" protect="rw">
        <comment>RTC hour counter value</comment>
        <bits access="r" name="rtc_hrs_cnt_value" pos="5:0" rst="0x0">
          <comment>RTC hour counter value</comment>
        </bits>
      </reg>
      <reg name="rtc_day_cnt_value" protect="rw">
        <comment>RTC day counter value</comment>
        <bits access="r" name="rtc_day_cnt_value" pos="5:0" rst="0x0">
          <comment>RTC day counter value</comment>
        </bits>
      </reg>
      <reg name="rtc_sec_cnt_upd" protect="rw">
        <comment>RTC second counter update</comment>
        <bits access="rw" name="rtc_sec_cnt_upd" pos="5:0" rst="0x0">
          <comment>RTC second counter update
Write new counter value to this register to start a second counter updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_min_cnt_upd" protect="rw">
        <comment>RTC minute counter update</comment>
        <bits access="rw" name="rtc_min_cnt_upd" pos="5:0" rst="0x0">
          <comment>RTC minute counter update
Write new counter value to this register to start a minute counter updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_cnt_upd" protect="rw">
        <comment>RTC hour counter update</comment>
        <bits access="rw" name="rtc_hrs_cnt_upd" pos="4:0" rst="0x0">
          <comment>RTC hour counter update
Write new counter value to this register to start an hour counter updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_day_cnt_upd" protect="rw">
        <comment>RTC day counter update</comment>
        <bits access="rw" name="rtc_day_cnt_upd" pos="5:0" rst="0x0">
          <comment>RTC day counter update
Write new counter value to this register to start a day counter updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_sec_alm_upd" protect="rw">
        <comment>RTC second alarm update</comment>
        <bits access="rw" name="rtc_sec_alm_upd" pos="5:0" rst="0x0">
          <comment>RTC second alarm update
Write new counter value to this register to start a second alarm updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_min_alm_upd" protect="rw">
        <comment>RTC minute alarm update</comment>
        <bits access="rw" name="rtc_min_alm_upd" pos="5:0" rst="0x0">
          <comment>RTC minute alarm update
Write new counter value to this register to start a minute alarm updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_alm_upd" protect="rw">
        <comment>RTC hour alarm update</comment>
        <bits access="rw" name="rtc_hrs_alm_upd" pos="4:0" rst="0x0">
          <comment>RTC hour alarm update
Write new counter value to this register to start an hour alarm updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_day_alm_upd" protect="rw">
        <comment>RTC day alarm update</comment>
        <bits access="rw" name="rtc_day_alm_upd" pos="5:0" rst="0x0">
          <comment>RTC day alarm update
Write new counter value to this register to start a day alarm updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_int_en" protect="rw">
        <comment>RTC interrupt enable and
hour format control</comment>
        <bits access="rw" name="rtc_day_alm_upd_int_en" pos="15" rst="0x0">
          <comment>Day alarm updating complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rtc_hrs_alm_upd_int_en" pos="14" rst="0x0">
          <comment>Hour alarm updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_min_alm_upd_int_en" pos="13" rst="0x0">
          <comment>Minute alarm updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_sec_alm_upd_int_en" pos="12" rst="0x0">
          <comment>Second alarm updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_day_cnt_upd_int_en" pos="11" rst="0x0">
          <comment>Day counter updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_hrs_cnt_upd_int_en" pos="10" rst="0x0">
          <comment>Hour counter updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_min_cnt_upd_int_en" pos="9" rst="0x0">
          <comment>Minute counter updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_sec_cnt_upd_int_en" pos="8" rst="0x0">
          <comment>Second counter updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_spg_upd_int_en" pos="7" rst="0x0">
          <comment>Spare register updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_auxalm_int_en" pos="6" rst="0x0">
          <comment>auxiliary alarm interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_hrs_format_sel" pos="5" rst="0x0">
          <comment>Hour format select
0: The read back hour count is formatted as 0 to 23.
1: The read back hour count is formatted as 0 to 11, and bit 4 represent AM or PM – AM is 0 and PM is 1.</comment>
        </bits>
        <bits access="rw" name="rtc_alm_int_en" pos="4" rst="0x0">
          <comment>alarm interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_day_int_en" pos="3" rst="0x0">
          <comment>day interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_hrs_int_en" pos="2" rst="0x0">
          <comment>hour interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_min_int_en" pos="1" rst="0x0">
          <comment>minute interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_sec_int_en" pos="0" rst="0x0">
          <comment>Second interrupt enable</comment>
        </bits>
      </reg>
      <reg name="rtc_int_raw_sts" protect="rw">
        <comment>RTC interrupt raw status</comment>
        <bits access="r" name="rtc_day_alm_upd_int_raw_sts" pos="15" rst="0x0">
          <comment>Day alarm updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_alm_upd_int_raw_sts" pos="14" rst="0x0">
          <comment>Hour alarm updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_min_alm_upd_int_raw_sts" pos="13" rst="0x0">
          <comment>Minute alarm updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_sec_alm_upd_int_raw_sts" pos="12" rst="0x0">
          <comment>Second alarm updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_day_cnt_upd_int_raw_sts" pos="11" rst="0x0">
          <comment>Day counter updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_cnt_upd_int_raw_sts" pos="10" rst="0x0">
          <comment>Hour counter updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_min_cnt_upd_int_raw_sts" pos="9" rst="0x0">
          <comment>Minute counter updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_sec_cnt_upd_int_raw_sts" pos="8" rst="0x0">
          <comment>Second counter updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_spg_upd_int_raw_sts" pos="7" rst="0x0">
          <comment>Spare register updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_auxalm_int_raw_sts" pos="6" rst="0x0">
          <comment>auxiliary alarm interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_alm_int0_raw_sts" pos="5" rst="0x0">
          <comment>Reserved for debug</comment>
        </bits>
        <bits access="r" name="rtc_alm_int_raw_sts" pos="4" rst="0x0">
          <comment>alarm interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_day_int_raw_sts" pos="3" rst="0x0">
          <comment>day interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_int_raw_sts" pos="2" rst="0x0">
          <comment>hour interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_min_int_raw_sts" pos="1" rst="0x0">
          <comment>minute interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_sec_int_raw_sts" pos="0" rst="0x0">
          <comment>Second interrupt raw status</comment>
        </bits>
      </reg>
      <reg name="rtc_int_clr" protect="rw">
        <comment>RTC interrupt clear</comment>
        <bits access="w" name="rtc_day_alm_upd_int_clr" pos="15" rst="0x0">
          <comment>Day alarm updating complete interrupt clear
Write 1 to this bit to clear corresponding interrupt</comment>
        </bits>
        <bits access="w" name="rtc_hrs_alm_upd_int_clr" pos="14" rst="0x0">
          <comment>Hour alarm updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_min_alm_upd_int_clr" pos="13" rst="0x0">
          <comment>Minute alarm updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_sec_alm_upd_int_clr" pos="12" rst="0x0">
          <comment>Second alarm updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_day_cnt_upd_int_clr" pos="11" rst="0x0">
          <comment>Day counter updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_hrs_cnt_upd_int_clr" pos="10" rst="0x0">
          <comment>Hour counter updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_min_cnt_upd_int_clr" pos="9" rst="0x0">
          <comment>Minute counter updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_sec_cnt_upd_int_clr" pos="8" rst="0x0">
          <comment>Second counter updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_spg_upd_int_clr" pos="7" rst="0x0">
          <comment>Spare register updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_auxalm_int_clr" pos="6" rst="0x0">
          <comment>Auxiliary alarm interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_alm_int_clr" pos="4" rst="0x0">
          <comment>alarm interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_day_int_clr" pos="3" rst="0x0">
          <comment>day interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_hrs_int_clr" pos="2" rst="0x0">
          <comment>hour interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_min_int_clr" pos="1" rst="0x0">
          <comment>minute interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_sec_int_clr" pos="0" rst="0x0">
          <comment>Second interrupt clear</comment>
        </bits>
      </reg>
      <reg name="rtc_int_mask_sts" protect="rw">
        <comment>RTC interrupt masked status</comment>
        <bits access="r" name="rtc_day_alm_upd_int_mask_sts" pos="15" rst="0x0">
          <comment>Day alarm updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_alm_upd_int_mask_sts" pos="14" rst="0x0">
          <comment>Hour alarm updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_min_alm_upd_int_mask_sts" pos="13" rst="0x0">
          <comment>Minute alarm updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_sec_alm_upd_int_mask_sts" pos="12" rst="0x0">
          <comment>Second alarm updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_day_cnt_upd_int_mask_sts" pos="11" rst="0x0">
          <comment>Day counter updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_cnt_upd_int_mask_sts" pos="10" rst="0x0">
          <comment>Hour counter updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_min_cnt_upd_int_mask_sts" pos="9" rst="0x0">
          <comment>Minute counter updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_sec_cnt_upd_int_mask_sts" pos="8" rst="0x0">
          <comment>Second counter updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_spg_upd_int_mask_sts" pos="7" rst="0x0">
          <comment>Spare register updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_auxalm_int_mask_sts" pos="6" rst="0x0">
          <comment>auxiliary alarm interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_alm_int_mask_sts" pos="4" rst="0x0">
          <comment>alarm interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_day_int_mask_sts" pos="3" rst="0x0">
          <comment>day interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_int_mask_sts" pos="2" rst="0x0">
          <comment>hour interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_min_int_mask_sts" pos="1" rst="0x0">
          <comment>minute interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_sec_int_mask_sts" pos="0" rst="0x0">
          <comment>Second interrupt masked status</comment>
        </bits>
      </reg>
      <reg name="rtc_sec_alm_value" protect="rw">
        <comment>RTC second alarm value</comment>
        <bits access="r" name="rtc_sec_alm_value" pos="5:0" rst="0x0">
          <comment>RTC second alarm value</comment>
        </bits>
      </reg>
      <reg name="rtc_min_alm_value" protect="rw">
        <comment>RTC minute alarm value</comment>
        <bits access="r" name="rtc_min_alm_value" pos="5:0" rst="0x0">
          <comment>RTC minute alarm value</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_alm_value" protect="rw">
        <comment>RTC hour alarm value</comment>
        <bits access="r" name="rtc_hrs_alm_value" pos="5:0" rst="0x0">
          <comment>RTC hour alarm value</comment>
        </bits>
      </reg>
      <reg name="rtc_day_alm_value" protect="rw">
        <comment>RTC day alarm value</comment>
        <bits access="r" name="rtc_day_alm_value" pos="5:0" rst="0x0">
          <comment>RTC day alarm value</comment>
        </bits>
      </reg>
      <reg name="rtc_spg_value" protect="rw">
        <comment>RTC spare register value</comment>
        <bits access="r" name="rtc_spg_value" pos="15:8" rst="0x0">
          <comment>RTC spare register value</comment>
        </bits>
        <bits access="r" name="rtc_almlock_value" pos="7:0" rst="0x0">
          <comment>RTC alarm lock register value</comment>
        </bits>
      </reg>
      <reg name="rtc_spg_upd" protect="rw">
        <comment>RTC spare register update</comment>
        <bits access="rw" name="rtc_spg_upd" pos="15:8" rst="0x0">
          <comment>RTC spare register update
Write new counter value to this register to start a spare register updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
        <bits access="rw" name="rtc_almlock_upd" pos="7:0" rst="0x0">
          <comment>RTC alarm lock register update
Write new counter value to this register to start a register updating operation in VDDRTC domain.
Reading this register can get recent updating value.
Write 8’hA5 to this register to unlock alarm function, and write other data to lock alarm function. That means, software must 8’hA5 to this register to enable alarm function before using this function.</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_flag_ctrl" protect="rw">
        <comment>RTC power flag control register</comment>
        <bits access="rw" name="rtc_pwr_flag_set" pos="15:8" rst="0x0">
          <comment>RTC power flag register set</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_flag_clr" pos="7:0" rst="0x0">
          <comment>RTC power flag register clear</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_flag_sts" protect="rw">
        <comment>RTC power flag status</comment>
        <bits access="r" name="rtc_power_flag_status_register" pos="7:0" rst="0x96">
          <comment>RTC power flag status register</comment>
        </bits>
      </reg>
      <reg name="rtc_sec_auxalm_upd" protect="rw">
        <comment>RTC second auxiliary alarm
 update</comment>
        <bits access="rw" name="rtc_sec_auxalm_upd" pos="5:0" rst="0x0">
          <comment>RTC second auxiliary alarm register</comment>
        </bits>
      </reg>
      <reg name="rtc_min_auxalm_upd" protect="rw">
        <comment>RTC minute auxiliary alarm
 update</comment>
        <bits access="rw" name="rtc_min_auxalm_upd" pos="5:0" rst="0x0">
          <comment>RTC minute auxiliary alarm register</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_auxalm_upd" protect="rw">
        <comment>RTC hour auxiliary alarm
 update</comment>
        <bits access="rw" name="rtc_hrs_auxalm_upd" pos="4:0" rst="0x0">
          <comment>RTC hour auxiliary alarm register</comment>
        </bits>
      </reg>
      <reg name="rtc_day_auxalm_upd" protect="rw">
        <comment>RTC day auxiliary alarm
 update</comment>
        <bits access="rw" name="rtc_day_auxalm_upd" pos="5:0" rst="0x0">
          <comment>RTC day auxiliary alarm register</comment>
        </bits>
      </reg>
      <reg name="rtc_sec_cnt_raw" protect="rw">
        <comment>RTC second counter raw value</comment>
        <bits access="r" name="rtc_sec_cnt_raw" pos="5:0" rst="0x0">
          <comment>RTC second counter raw value
Only for debug</comment>
        </bits>
      </reg>
      <reg name="rtc_min_cnt_raw" protect="rw">
        <comment>RTC minute counter raw value</comment>
        <bits access="r" name="rtc_min_cnt_raw" pos="5:0" rst="0x0">
          <comment>RTC minute counter raw value
Only for debug</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_cnt_raw" protect="rw">
        <comment>RTC hour counter raw value</comment>
        <bits access="r" name="rtc_hrs_cnt_raw" pos="5:0" rst="0x0">
          <comment>RTC hour counter raw value
Only for debug</comment>
        </bits>
      </reg>
      <reg name="rtc_day_cnt_raw" protect="rw">
        <comment>RTC second counter raw value</comment>
        <bits access="r" name="rtc_day_cnt_raw" pos="5:0" rst="0x0">
          <comment>RTC day counter raw value
Only for debug</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108600" name="PMIC_RTC" type="PMIC_RTC"/>
  </archive>
  <archive relative="pmic_timer.xml">
    <module category="System" name="PMIC_TIMER">
      <reg name="timer_version" protect="rw">
        <comment>the IP version of this timer the IP version of this timer</comment>
        <bits access="r" name="ip_version" pos="15:4" rst="0x10">
          <comment>the IP version of this timer</comment>
        </bits>
        <bits access="r" name="ip_patch_version" pos="3:0" rst="0x1">
          <comment>the IP patch version of this timer</comment>
        </bits>
      </reg>
      <reg name="timer_load_lo" protect="rw">
        <comment>timer load value of lower 16 bit timer load value of lower 16 bit</comment>
        <bits access="rw" name="timer_load_lo" pos="15:0" rst="0x0">
          <comment>timer load value of lower 16 bit.
Write to this register will reload the timer with the new value.
In one-time mode, this value is the first counting start number.
In periodic mode, this value is each counting start number.</comment>
        </bits>
      </reg>
      <reg name="timer_load_hi" protect="rw">
        <comment>timer load value of higher 16 bit timer load value of higher 16 bit</comment>
        <bits access="rw" name="timer_load_hi" pos="15:0" rst="0x0">
          <comment>timer load value of higher 16 bit
Write to this register will reload the timer with the new value.
In one-time mode, this value is the first counting start number.
In periodic mode, this value is each counting start number.</comment>
        </bits>
      </reg>
      <reg name="timer_ctl" protect="rw">
        <comment>timer control register timer control register</comment>
        <bits access="rw" name="timer_run" pos="1" rst="0x0">
          <comment>timer open bit
0: timer stops
1: timer runs</comment>
        </bits>
        <bits access="rw" name="timer_mode" pos="0" rst="0x0">
          <comment>timer mode select
0: one-time mode
1: period mode</comment>
        </bits>
      </reg>
      <reg name="timer_int" protect="rw">
        <comment>timer interrupt timer interrupt</comment>
        <bits access="rc" name="timer_int_clr" pos="3" rst="0x0">
          <comment>timer Interrupt clear
Write 1 to this bit to clear interrupt</comment>
        </bits>
        <bits access="r" name="timer_int_mask_sts" pos="2" rst="0x0">
          <comment>timer interrupt masked status</comment>
        </bits>
        <bits access="r" name="timer_int_raw_sts" pos="1" rst="0x0">
          <comment>timer interrupt raw status</comment>
        </bits>
        <bits access="rw" name="timer_int_en" pos="0" rst="0x0">
          <comment>timer interrupt enable</comment>
        </bits>
      </reg>
      <reg name="timer_value_shdw_lo" protect="rw">
        <comment>timer counter shadow value of lower 16 bit for read timer counter shadow value of lower 16 bit for read</comment>
        <bits access="r" name="timer_value_shdw_lo" pos="15:0" rst="0x0">
          <comment>timer counter of lower 16bit shadow value for read.
This read-only register indicates current counter value.
The software can read the counter value immediately after load, without waiting for the load done. Also, software just needs to read once instead of double read.</comment>
        </bits>
      </reg>
      <reg name="timer_value_shdw_hi" protect="rw">
        <comment>timer counter shadow value of higher 16 bit for read timer counter shadow value of higher 16 bit for read</comment>
        <bits access="r" name="timer_value_shdw_hi" pos="15:0" rst="0x0">
          <comment>timer counter of higher 16bit shadow value for read.
This read-only register indicates current counter value.
The software can read the counter value immediately after load, without waiting for the load done. Also, software just needs to read once instead of double read.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108000" name="PMIC_TIMER" type="PMIC_TIMER"/>
  </archive>
  <archive relative="pmic_ana.xml">
    <module category="System" name="PMIC_ANA">
      <reg name="chip_id_low" protect="rw">
        <comment>CHIP_ID_LOW</comment>
        <bits access="r" name="chip_id_low" pos="15:0" rst="0xa000">
          <comment>CHIP ID low 16 bits,default:a000</comment>
        </bits>
      </reg>
      <reg name="chip_id_high" protect="rw">
        <comment>CHIP_ID_HIGH</comment>
        <bits access="r" name="chip_id_high" pos="15:0" rst="0x8850">
          <comment>CHIP ID high 16 bits,default:8850</comment>
        </bits>
      </reg>
      <reg name="module_en0" protect="rw">
        <comment>MODULE_EN0</comment>
        <bits access="rw" name="tmr_en" pos="12" rst="0x0">
          <comment>TMR module enable
0: Disable the PCLK  of timer
1: Enable  the PCLK  of timer</comment>
        </bits>
        <bits access="rw" name="bltc_en" pos="9" rst="0x0">
          <comment>BLTC module enable
0: Disable the PCLK  of BLTC
1: Enable  the PCLK  of BLTC</comment>
        </bits>
        <bits access="rw" name="efs_en" pos="6" rst="0x0">
          <comment>Efuse module enable
0: Disable the PCLK  of efuse ctrl
1: Enable  the PCLK  of efuse ctrl</comment>
        </bits>
        <bits access="rw" name="adc_en" pos="5" rst="0x0">
          <comment>AUXADC module enable
0: Disable the PCLK  of AUXADC
1: Enable  the PCLK  of AUXADC</comment>
        </bits>
        <bits access="rw" name="cal_en" pos="0" rst="0x0">
          <comment>CAL module enable
0: Disable the PCLK  of CAL
1: Enable  the PCLK  of CAL</comment>
        </bits>
      </reg>
      <reg name="dig_clk_en0" protect="rw">
        <comment>DIG_CLK_EN0</comment>
        <bits access="rw" name="clk_auxad_en" pos="6" rst="0x0">
          <comment>AUXAD clock enable, the clock is connected to AUXADC converter
0: disable AUXAD_CLK
1: enable AUXAD_CLK</comment>
        </bits>
        <bits access="rw" name="clk_auxadc_en" pos="5" rst="0x0">
          <comment>AUXADC module work clock enable
0: disable clk_adc
1: enable clk_adc</comment>
        </bits>
        <bits access="rw" name="clk_cal_src_sel" pos="4:3" rst="0x0">
          <comment>Calibration module clock source select                  2'b00:RC64K
2'b01:N/A
2'b10:N/A
2'b11:N/A</comment>
        </bits>
        <bits access="rw" name="clk_cal_en" pos="2" rst="0x0">
          <comment>CLK_CAL eanble
0: disable clk_cal
1: enable clk_cal</comment>
        </bits>
      </reg>
      <reg name="rtc_clk_en0" protect="rw">
        <comment>RTC_CLK_EN0</comment>
        <bits access="rw" name="rtc_tmr_en" pos="13" rst="0x0">
          <comment>TIMER RTC clock soft enable
0: Disable the RTC clock of timer
1: Enable RTC clock of timer</comment>
        </bits>
        <bits access="rw" name="rtc_bltc_en" pos="7" rst="0x0">
          <comment>BLTC RTC clock soft enable
0: Disable the RTC clock of BLTC
1: Enable RTC clock of BLTC</comment>
        </bits>
        <bits access="rw" name="rtc_arch_en" pos="0" rst="0x1">
          <comment>ARCH RTC clock soft enable
0: Disable the RTC clock of ARCH
1: Enable RTC clock of ARCH</comment>
        </bits>
      </reg>
      <reg name="soft_rst0" protect="rw">
        <comment>SOFT_RST0</comment>
        <bits access="rw" name="bltc_soft_rst" pos="9" rst="0x0">
          <comment>BLTC soft reset</comment>
        </bits>
        <bits access="rw" name="efs_soft_rst" pos="7" rst="0x0">
          <comment>Efuse soft reset</comment>
        </bits>
        <bits access="rw" name="adc_soft_rst" pos="6" rst="0x0">
          <comment>Auxadc soft reset</comment>
        </bits>
        <bits access="rw" name="tmr_soft_rst" pos="4" rst="0x0">
          <comment>TMR soft reset</comment>
        </bits>
        <bits access="rw" name="cal_soft_rst" pos="0" rst="0x0">
          <comment>CAL soft reset</comment>
        </bits>
      </reg>
      <reg name="xtl_wait" protect="rw">
        <comment>XTL_WAIT</comment>
        <bits access="rw" name="slp_rgb_pd_en" pos="15" rst="0x1">
          <comment>RGB driver power down enable in chip deep sleep mode</comment>
        </bits>
        <bits access="rw" name="xtl_wait" pos="7:0" rst="0x32">
          <comment>26MHz crystal oscillator  wait cycles</comment>
        </bits>
      </reg>
      <reg name="rg_dvdd_reserved1" protect="rw">
        <comment>RG_DVDD_RESERVED1</comment>
        <bits access="rw" name="rg_dvdd_reserved0" pos="15:8" rst="0xf0">
          <comment>RG_DVDD_RESERVED0</comment>
        </bits>
        <bits access="rw" name="rg_dvdd_reserved1" pos="7:0" rst="0xf0">
          <comment>RG_DVDD_RESERVED1</comment>
        </bits>
      </reg>
      <reg name="vbat_ctrl0" protect="rw">
        <comment>VBAT_CTRL0</comment>
        <bits access="rw" name="rg_ldo_vbat_auxcal_sel" pos="2:0" rst="0x0">
          <comment>LDOs output selection control. (To AUXADC internal calibration)</comment>
        </bits>
      </reg>
      <reg name="thm_otp_ctrl" protect="rw">
        <comment>THM_OTP_CTRL</comment>
        <bits access="rw" name="rg_otp_en" pos="3" rst="0x0">
          <comment>OTP function enable control bit</comment>
        </bits>
        <bits access="rw" name="rg_otp_op" pos="2:0" rst="0x3">
          <comment>OTP threshold
3'b011: 135C, default</comment>
        </bits>
      </reg>
      <reg name="led_ctrl" protect="rw">
        <comment>LED_CTRL</comment>
        <bits access="rw" name="ib_trim_em_sel" pos="12" rst="0x1">
          <comment>Internal resistor for sink current calibration bit selection
0: From Software Register
1: From Ememory</comment>
        </bits>
        <bits access="rw" name="rg_batdet_cur_en" pos="11" rst="0x0">
          <comment>current mode enable                                                                         &quot;0&quot; disable (default)                                                                      &quot;1&quot; enable (default)</comment>
        </bits>
        <bits access="rw" name="rg_batdet_cur_i" pos="10:8" rst="0x0">
          <comment>set current level in current mode
bit3~bit1  effective, bit0 not used,
1.25/2.5/5/10/20/40/80/160uA 7step</comment>
        </bits>
        <bits access="rw" name="rg_ib_rex_en" pos="7" rst="0x0">
          <comment>sink current adjustment for test  enable signale, high effective
Defautl 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ib_trim" pos="6:0" rst="0x40">
          <comment>sink current calibration bit.  1.25uA/step
default 0000000(1.25uA)</comment>
        </bits>
      </reg>
      <reg name="kpled_ctrl1" protect="rw">
        <comment>KPLED_CTRL1</comment>
        <bits access="rw" name="rg_ldo_kpled_cl_adj" pos="12" rst="0x1">
          <comment>KPLED LDO current limit threshold adjust:
default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_kpled_v" pos="11:8" rst="0x0">
          <comment>Current control bit. 16 steps
(default 4’b0)
(0000:0.9mA
0001:1.8mA
 0010:2.7mA
 0011:3.6mA
 0100:4.5mA
 0101:5.4mA
 0110:6.3mA
 0111:7.2mA
 1000:16.2mA
 1001:22.5mA
 1010:29.7mA
 1011:37.8mA
 1100:46.8mA
 1101:56.7mA
 1110:67.5mA
 1111:79.2mA)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_shpt_adj" pos="7" rst="0x1">
          <comment>KPLED LDO foldback current threshold adjust:
default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_stb" pos="6:5" rst="0x2">
          <comment>KPLED LDO stability compensation:
default 2'b10</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_cap_sel" pos="4" rst="0x0">
          <comment>KPLED LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_v" pos="3:1" rst="0x5">
          <comment>KPLED LDO program bits:
100mV/step, 2.8V~3.5V; default 3.3V, 3'b101</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_shpt_pd" pos="0" rst="0x0">
          <comment>KPLED LDO short protection power down
default:0,on</comment>
        </bits>
      </reg>
      <reg name="ldo_vbat_ctrl1" protect="rw">
        <comment>LDO_VBAT_CTRL1</comment>
        <bits access="rw" name="rg_ldo_usb33_cl_adj" pos="7:5" rst="0x3">
          <comment>LDO_USB current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_usb33_shpt_en" pos="4" rst="0x1">
          <comment>LDO_USB short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_usb33_rz_adj" pos="3" rst="0x1">
          <comment>LDO_USB short current threshold adjust                                         default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_usb33_stb" pos="2:1" rst="0x0">
          <comment>LDO_USB compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_usb33_discharge_en" pos="0" rst="0x1">
          <comment>LDO_USB discharge en</comment>
        </bits>
      </reg>
      <reg name="ldo_vbat_ctrl2" protect="rw">
        <comment>LDO_VBAT_CTRL2</comment>
        <bits access="rw" name="rg_ldo_vio33_cl_adj" pos="15:13" rst="0x3">
          <comment>LDO_VIO33 current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_shpt_en" pos="12" rst="0x1">
          <comment>LDO_VIO33 short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_rz_adj" pos="11" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_stb" pos="10:9" rst="0x0">
          <comment>LDO_VIO33 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_discharge_en" pos="8" rst="0x1">
          <comment>LDO_VIO33 discharge en</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_cl_adj" pos="7:5" rst="0x3">
          <comment>LDO_CAMA current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_shpt_en" pos="4" rst="0x1">
          <comment>LDO_CAMA short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_rz_adj" pos="3" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_stb" pos="2:1" rst="0x0">
          <comment>LDO_CAMA compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_discharge_en" pos="0" rst="0x1">
          <comment>LDO_CAMA discharge en</comment>
        </bits>
      </reg>
      <reg name="ldo_vbat_ctrl3" protect="rw">
        <comment>LDO_VBAT_CTRL3</comment>
        <bits access="rw" name="rg_ldo_lcd_cl_adj" pos="15:13" rst="0x3">
          <comment>LDO_LCD current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lcd_shpt_en" pos="12" rst="0x1">
          <comment>LDO_LCD short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lcd_rz_adj" pos="11" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lcd_stb" pos="10:9" rst="0x0">
          <comment>LDO_LCD compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lcd_discharge_en" pos="8" rst="0x1">
          <comment>LDO_LCD discharge en</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mmc_cl_adj" pos="7:5" rst="0x3">
          <comment>LDO_MMC current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mmc_shpt_en" pos="4" rst="0x1">
          <comment>LDO_MMC short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mmc_rz_adj" pos="3" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mmc_stb" pos="2:1" rst="0x0">
          <comment>LDO_MMC compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mmc_discharge_en" pos="0" rst="0x1">
          <comment>LDO_MMC discharge en</comment>
        </bits>
      </reg>
      <reg name="ldo_ana_ctrl" protect="rw">
        <comment>LDO_ANA_CTRL</comment>
        <bits access="rw" name="rg_ldo_ana_cl_adj" pos="14" rst="0x0">
          <comment>LDO_ANA current limit threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_ANA short protect EN:
“1” is disable
“0” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_ANA short current threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_stb" pos="11:10" rst="0x0">
          <comment>LDO_ANA compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_bp" pos="9" rst="0x0">
          <comment>LDO_ANA bypass application:
default 1'b0, no bypass
             1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_cap_sel" pos="8" rst="0x0">
          <comment>ANA LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_v" pos="5:0" rst="0x20">
          <comment>ANA LDO output voltage select                              000000~111111 1.4V~2.1875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_vio18_ctrl" protect="rw">
        <comment>LDO_VIO18_CTRL</comment>
        <bits access="rw" name="rg_ldo_vio18_cl_adj" pos="14" rst="0x0">
          <comment>LDO_VIO18 current limit threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_VIO18 short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_VIO18 short current threshold adjust                                         default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_stb" pos="11:10" rst="0x0">
          <comment>LDO_VIO18 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_bp" pos="9" rst="0x0">
          <comment>LDO_VIO18 bypass application:
default 1'b0, no bypass
            1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_cap_sel" pos="8" rst="0x0">
          <comment>VIO18 LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_v" pos="5:0" rst="0x20">
          <comment>VIO18 LDO output voltage select                              000000~111111 1.4V~2.1875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_vgen_ctrl1" protect="rw">
        <comment>LDO_VGEN_CTRL1</comment>
        <bits access="rw" name="rg_ldo_mem_cl_adj" pos="14" rst="0x0">
          <comment>LDO_MEM current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_MEM short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_MEM short current threshold adjust                                         default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_stb" pos="11:10" rst="0x0">
          <comment>LDO_MEM compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_bp" pos="9" rst="0x0">
          <comment>LDO_MEM bypass application:
default 1'b0, no bypass
            1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_cap_sel" pos="8" rst="0x0">
          <comment>MEM LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_v" pos="5:0" rst="0x20">
          <comment>MEM LDO output voltage select                              000000~111111 1.4V~2.1875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_spimem_ctrl" protect="rw">
        <comment>LDO_SPIMEM_CTRL</comment>
        <bits access="rw" name="rg_ldo_spimem_cl_adj" pos="14" rst="0x0">
          <comment>LDO_SPIMEM current limit threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_SPIMEM short protect EN:
“1” is disable
“0” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_SPIMEM short current threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_stb" pos="11:10" rst="0x0">
          <comment>LDO_SPIMEM compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_bp" pos="9" rst="0x0">
          <comment>LDO_SPIMEM bypass application:
default 1'b0, no bypass
             1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_cap_sel" pos="8" rst="0x0">
          <comment>SPIMEM LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_v" pos="5:0" rst="0x20">
          <comment>SPIMEM LDO output voltage select                              000000~111111 1.4V~2.1875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_camd_ctrl" protect="rw">
        <comment>LDO_CAMD_CTRL</comment>
        <bits access="rw" name="rg_ldo_camd_cl_adj" pos="14" rst="0x0">
          <comment>LDO_CAMD current limit threshold adjust                                         default 1'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_CAMD short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_CAMD short current threshold adjust                                         default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_stb" pos="11:10" rst="0x0">
          <comment>LDO_CAMD compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_bp" pos="9" rst="0x0">
          <comment>LDO_CAMD bypass application:
default 1'b0, no bypass
            1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_cap_sel" pos="8" rst="0x0">
          <comment>CAMD LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_v" pos="5:0" rst="0x20">
          <comment>VIO18 LDO output voltage select                              000000~111111 1.4V~2.1875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_rf15_ctrl" protect="rw">
        <comment>LDO_RF15_CTRL</comment>
        <bits access="rw" name="rg_ldo_rf15_cl_adj" pos="14" rst="0x0">
          <comment>LDO_RF15 current limit threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_RF15 short protect EN:
“1” is disable
“0” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_RF15 short current threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_stb" pos="11:10" rst="0x0">
          <comment>LDO_RF15 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_bp" pos="9" rst="0x0">
          <comment>LDO_RF15 bypass application:
default 1'b0, no bypass
            1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_cap_sel" pos="8" rst="0x0">
          <comment>LDO RF15 remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_v" pos="5:0" rst="0x20">
          <comment>RF15 LDO output voltage select                              000000~111111 1.4V~1.8875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_vgen_ctrl3" protect="rw">
        <comment>LDO_VGEN_CTRL3</comment>
      </reg>
      <reg name="ldo_lp18_ctrl" protect="rw">
        <comment>LDO_LP18_CTRL</comment>
        <bits access="rw" name="rg_ldo_lp18_cl_adj" pos="15:13" rst="0x3">
          <comment>LDO_LP18 current limit threshold adjust                                         default 1'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_shpt_en" pos="12" rst="0x1">
          <comment>LDO_LP18 short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_rz_adj" pos="11" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_stb" pos="10:9" rst="0x0">
          <comment>LDO_LP18 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_discharge_en" pos="8" rst="0x1">
          <comment>LDO_LP18 discharge en</comment>
        </bits>
      </reg>
      <reg name="ldo_rf12_ctrl" protect="rw">
        <comment>LDO_LP18_RF12_CTRL</comment>
        <bits access="rw" name="rg_ldo_rf12_cl_adj" pos="12" rst="0x0">
          <comment>LDO_RF12 current limit threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_shpt_pd" pos="11" rst="0x0">
          <comment>LDO_RF12 short protect EN:
“1” is disable
“0” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_shpt_adj" pos="10" rst="0x0">
          <comment>LDO_RF12 short current threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_v" pos="9:4" rst="0x1f">
          <comment>RF12 LDO output voltage select                              000000~111111 0.8125~1.6V  12.5mV/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_stb" pos="3:2" rst="0x0">
          <comment>LDO_RF12 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_bp" pos="1" rst="0x0">
          <comment>LDO_RF12 bypass application:
default 1'b0, no bypass
            1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_cap_sel" pos="0" rst="0x0">
          <comment>RF12 LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
      </reg>
      <reg name="dcdc_ctrl1" protect="rw">
        <comment>DCDC_CTRL1</comment>
        <bits access="rw" name="rg_dcdc_auxtrim_sel" pos="15:12" rst="0x0">
          <comment>DCDC to AUXADC trim channel selection
3'b001: select VCORE
3'b010: select VRF (VRF*18/37)
3'b011: select VPA (VPA*18/68)
RG_DCDC_AUXTRIM_SEL[2], internal test mode select:
0: default, internal test mode disable
1: internal test mode enable. Monitor internal signals by reuse CLK3M_OUT path
3'b100: enpwm_vrf
3'b101: zx_vrf
3'b110: enpwm_vcore
3'b111: zx_vcore</comment>
        </bits>
        <bits access="rw" name="rg_clk3m_out_en" pos="11" rst="0x0">
          <comment>test mode control.
1'b0: default, clock output off
1'b1:  clock output on</comment>
        </bits>
        <bits access="rw" name="rg_dcdc_clkout_uniphase" pos="4" rst="0x0">
          <comment>phase shift option
1'b0: default, w/i 1/5 phase shift at internal mode
1'b1: uni-phase mode, all ouputs = channel 0</comment>
        </bits>
        <bits access="rw" name="rg_dcdc_clkout_sel" pos="3:0" rst="0x0">
          <comment>clock selection for each channel
RG_CLKOUT_SEL[0]:  VCORE clk selection
RG_CLKOUT_SEL[1]:  VGEN clk selection
RG_CLKOUT_SEL[2]:  VRF clk selection
RG_CLKOUT_SEL[3]:  VPA clk selection
0: internal mode, default
1: external mode</comment>
        </bits>
      </reg>
      <reg name="vcore_ctrl2" protect="rw">
        <comment>VCORE_CTRL2</comment>
        <bits access="rw" name="rg_vcore_antiring_en" pos="6" rst="0x0">
          <comment>anti-ring enable
1'b0: default, anti-ring off
1'b1: anti-ring on</comment>
        </bits>
        <bits access="rw" name="rg_vcore_curlimit_r" pos="5:4" rst="0x0">
          <comment>current limit threshold tuning
2'b00: default
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
        <bits access="rw" name="rg_vcore_curavg" pos="3:2" rst="0x0">
          <comment>current sense average ratio
current sense multiplier tuning
2'b00: default, x1
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
        <bits access="rw" name="rg_vcore_curses_r" pos="1:0" rst="0x0">
          <comment>current sense R ratio tuning
current sense multiplier tuning
2'b00: default, x1
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
      </reg>
      <reg name="vcore_ctrl3" protect="rw">
        <comment>VCORE_CTRL3</comment>
        <bits access="rw" name="rg_vcore_force_pwm" pos="13" rst="0x0">
          <comment>force PWM mode
1'b0: default, PFM/PWM auto mode
1'b1: force PWM mode</comment>
        </bits>
        <bits access="rw" name="rg_vcore_zx_disable" pos="12" rst="0x0">
          <comment>force zero-cross off
1'b0: default, zero_cross detect on
1'b1: zero-cross detect off</comment>
        </bits>
        <bits access="rw" name="rg_vcore_zx_offset" pos="11:10" rst="0x0">
          <comment>zero-cross offset tuning
2'b00: default
2'b01: +5mV offset
2'b10: -5mV offset
2'b11: -10mV offset</comment>
        </bits>
        <bits access="rw" name="rg_vcore_pfm_vh" pos="9:8" rst="0x0">
          <comment>PFM mode threshold for upper limit
2'b00: default, 0.6V
2'b01: 0.55V
2'b10: 0.65V
2'b11: 0.7V</comment>
        </bits>
        <bits access="rw" name="rg_vcore_rcomp" pos="7:6" rst="0x0">
          <comment>compensation R select
2'b00: default, 360k
2'b01: 320k
2'b10: 400k
2'b11: 440k</comment>
        </bits>
        <bits access="rw" name="rg_vcore_slope" pos="5:4" rst="0x0">
          <comment>slope compensation tuning
2'b00: default
2'b01: 0.5x
2'b10: 1.5x
2'b11: 2x</comment>
        </bits>
        <bits access="rw" name="rg_vcore_sr_hs" pos="3:2" rst="0x0">
          <comment>high side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
        <bits access="rw" name="rg_vcore_sr_ls" pos="1:0" rst="0x0">
          <comment>low side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
      </reg>
      <reg name="vrf_ctrl0" protect="rw">
        <comment>VRF_CTRL0</comment>
        <bits access="rw" name="rg_vrf_antiring_en" pos="6" rst="0x0">
          <comment>anti-ring enable
1'b0: default, anti-ring off
1'b1: anti-ring on</comment>
        </bits>
        <bits access="rw" name="rg_vrf_curlimit_r" pos="5:4" rst="0x0">
          <comment>current limit threshold tuning
2'b00: default
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
        <bits access="rw" name="rg_vrf_curavg" pos="3:2" rst="0x0">
          <comment>current sense average ratio
current sense multiplier tuning
2'b00: default, x1
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
        <bits access="rw" name="rg_vrf_curses_r" pos="1:0" rst="0x0">
          <comment>current sense R ratio tuning
current sense multiplier tuning
2'b00: default, x1
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
      </reg>
      <reg name="vrf_ctrl1" protect="rw">
        <comment>VRF_CTRL1</comment>
        <bits access="rw" name="rg_vrf_force_pwm" pos="13" rst="0x0">
          <comment>force PWM mode
1'b0: default, PFM/PWM auto mode
1'b1: force PWM mode</comment>
        </bits>
        <bits access="rw" name="rg_vrf_zx_disable" pos="12" rst="0x0">
          <comment>force zero-cross off
1'b0: default, zero_cross detect on
1'b1: zero-cross detect off</comment>
        </bits>
        <bits access="rw" name="rg_vrf_zx_offset" pos="11:10" rst="0x0">
          <comment>zero-cross offset tuning
2'b00: default
2'b01: +5mV offset
2'b10: -5mV offset
2'b11: -10mV offset</comment>
        </bits>
        <bits access="rw" name="rg_vrf_pfm_vh" pos="9:8" rst="0x0">
          <comment>PFM mode threshold for upper limit
2'b00: default, 0.6V
2'b01: 0.55V
2'b10: 0.65V
2'b11: 0.7V</comment>
        </bits>
        <bits access="rw" name="rg_vrf_rcomp" pos="7:6" rst="0x0">
          <comment>compensation R select
2'b00: default, 360k
2'b01: 320k
2'b10: 400k
2'b11: 440k</comment>
        </bits>
        <bits access="rw" name="rg_vrf_slope" pos="5:4" rst="0x0">
          <comment>slope compensation tuning
2'b00: default
2'b01: 0.5x
2'b10: 1.5x
2'b11: 2x</comment>
        </bits>
        <bits access="rw" name="rg_vrf_sr_hs" pos="3:2" rst="0x0">
          <comment>high side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
        <bits access="rw" name="rg_vrf_sr_ls" pos="1:0" rst="0x0">
          <comment>low side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
      </reg>
      <reg name="vgen_ctrl2" protect="rw">
        <comment>VGEN_CTRL2</comment>
        <bits access="rw" name="dcdc_gen_clk_rst" pos="8" rst="0x0">
          <comment>soft reset of all dcdc generated clk</comment>
        </bits>
        <bits access="rw" name="rg_vgen_antiring_en" pos="7" rst="0x0">
          <comment>anti-ring enable
1'b0: default, anti-ring off
1'b1: anti-ring on</comment>
        </bits>
        <bits access="rw" name="rg_vgen_zx_disable" pos="6" rst="0x0">
          <comment>force zero-cross off
1'b0: default, zero_cross detect on
1'b1: zero-cross detect off</comment>
        </bits>
        <bits access="rw" name="rg_vgen_zx_offset" pos="5:4" rst="0x0">
          <comment>zero-cross offset tuning
2'b00: default
2'b01: +5mV offset
2'b10: -5mV offset
2'b11: -10mV offset</comment>
        </bits>
        <bits access="rw" name="rg_vgen_curlimit_r" pos="3:2" rst="0x0">
          <comment>current limit threshold tuning
2'b00: default
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
        <bits access="rw" name="rg_vgen_curses_r" pos="1:0" rst="0x0">
          <comment>current sense R ratio tuning
current sense multiplier tuning
2'b00: default, x1
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
      </reg>
      <reg name="vgen_ctrl3" protect="rw">
        <comment>VGEN_CTRL3</comment>
        <bits access="rw" name="rg_vgen_force_pwm" pos="11" rst="0x0">
          <comment>force PWM mode
1'b0: default, PFM/PWM auto mode
1'b1: force PWM mode</comment>
        </bits>
        <bits access="rw" name="rg_vgen_maxduty_sel" pos="10" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="rg_vgen_pfm_vh" pos="9:8" rst="0x0">
          <comment>PFM mode threshold for upper limit
2'b00: default, 0.6V
2'b01: 0.55V
2'b10: 0.65V
2'b11: 0.7V</comment>
        </bits>
        <bits access="rw" name="rg_vgen_rcomp" pos="7:6" rst="0x0">
          <comment>compensation R select
2'b00: default, 360k
2'b01: 320k
2'b10: 400k
2'b11: 440k</comment>
        </bits>
        <bits access="rw" name="rg_vgen_slope" pos="5:4" rst="0x0">
          <comment>slope compensation tuning
2'b00: default
2'b01: 0.5x
2'b10: 1.5x
2'b11: 2x</comment>
        </bits>
        <bits access="rw" name="rg_vgen_sr_hs" pos="3:2" rst="0x0">
          <comment>high side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
        <bits access="rw" name="rg_vgen_sr_ls" pos="1:0" rst="0x0">
          <comment>low side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
      </reg>
      <reg name="chgr_ctrl1" protect="rw">
        <comment>CHGR_CTRL1</comment>
        <bits access="rw" name="chgr_cc_en" pos="10" rst="0x0">
          <comment>Select charger CC mode enable, high effective, Default “0”</comment>
        </bits>
        <bits access="rw" name="chgr_end_v" pos="9:8" rst="0x0">
          <comment>Battery charging end voltage
        00: Vend=4.2V
        01: Vend=4.3V
        10: Vend=4.4V
        11: Vend=4.5V
(default 2’b00)</comment>
        </bits>
        <bits access="rw" name="chgr_iterm" pos="7:6" rst="0x0">
          <comment>Termination charger current programmable bits
00:cc*0.9
01:cc*0.4
10:cc*0.2
11:cc*0.1</comment>
        </bits>
        <bits access="rw" name="vchg_ovp_v" pos="5:4" rst="0x1">
          <comment>control bits of over voltage protection for VCHG. When VCHG is above some level set by these 2 bits, charger power down and CHGR_OVI becomes high.
      00: 6.0V     01: 6.5V    10: 7.0V    11: 9.7V
Default 2’b01</comment>
        </bits>
        <bits access="rw" name="chgr_cc_i" pos="3:0" rst="0x0">
          <comment>CC mode charging current
0000:300mA        0001 : 350
0010: 400mA       0011 : 450
0100: 500mA       0101 :550
0110: 600mA       0111: 650
1000: 700mA       1001: 750
1010: 800mA       1011: 900
1100: 1000mA       1101: 1100
1110: 1200mA     1111: 1300
Default4’b0</comment>
        </bits>
      </reg>
      <reg name="auxadc_ctrl" protect="rw">
        <comment>AUXADC_CTRL</comment>
        <bits access="rw" name="rg_auxad_thm_cal" pos="5" rst="0x0">
          <comment>THM calibration enable signal,
0: disable THM calibration(default)
1: enable THM calibration, must set high 100us before AUXADC measure THM voltage and start the calibration</comment>
        </bits>
        <bits access="rw" name="rg_auxad_currentsen_en" pos="4" rst="0x0">
          <comment>Aux ADC current sense enable signal, active high, default 0.</comment>
        </bits>
        <bits access="rw" name="rg_auxad_test_en" pos="3" rst="0x0">
          <comment>AUX ADC channel ATE test scan mode control. 1 for ATE test channel scan, 0 for normal work. For ATE test channel scan, set this reg to 1, and using AUXAD_CS[4:0] to scan channel.</comment>
        </bits>
        <bits access="rw" name="rg_auxad_vss_sel" pos="2" rst="0x0">
          <comment>AUXADC signal VSS selection,
0: share signal VSS ball with all analog circuit
1: use specific ground ball as signal VSS</comment>
        </bits>
        <bits access="rw" name="rg_auxad_ref_sel" pos="1" rst="0x0">
          <comment>AUXADC reference source selection,
0: from bandgap current generate internal reference (default)
1: from bandgap voltage reference directly.</comment>
        </bits>
        <bits access="rw" name="rg_auxad_sgn_code" pos="0" rst="0x0">
          <comment>AUXADC output code selection
0: output ADC 12 bit code with 11bit resolution.(default)
1: output ADC 12 bit original raw measured code.</comment>
        </bits>
      </reg>
      <reg name="chgr_status" protect="rw">
        <comment>CHGR_STATUS</comment>
        <bits access="r" name="non_dcp_int" pos="12" rst="0x0">
          <comment>Charging port of NON-DCP status
“1” Charging port is NON-DCP
“0” Charging port is not NON-DCP</comment>
        </bits>
        <bits access="r" name="chg_det_done" pos="11" rst="0x0">
          <comment>Charging detect done after charger insert once</comment>
        </bits>
        <bits access="r" name="dp_low" pos="10" rst="0x0">
          <comment>The output of the comparator of DCD detection or SDP/NON-DCP detection
“1” means DCD pass when doing DCD,
 or SDP if CHG_DET=0
“0” means DCD fail when doing DCD,
or NON-DCP if CHG_DET=0</comment>
        </bits>
        <bits access="r" name="dcp_det" pos="9" rst="0x0">
          <comment>The output of the comparator of  DCP_DET loop
“1”  means DCP if CHG_DET is “1”
“0” means CDP if CHG_DET is “1”</comment>
        </bits>
        <bits access="r" name="chg_det" pos="8" rst="0x0">
          <comment>The output of the comparator of CHG_DET loop
“1” DCP or CDP
“0” SDP or NON-DCP</comment>
        </bits>
        <bits access="r" name="sdp_int" pos="7" rst="0x0">
          <comment>Charging port  of SDP status
“1” Charging port is SDP
“0” Charging port is not SDP</comment>
        </bits>
        <bits access="r" name="dcp_int" pos="6" rst="0x0">
          <comment>Charging port of DCP status
“1” Charging port is DCP
“0” Charging port is not DCP</comment>
        </bits>
        <bits access="r" name="cdp_int" pos="5" rst="0x0">
          <comment>Charging  port of CDP status
“1” Charging port is CDP
“0” Charging port is not CDP</comment>
        </bits>
        <bits access="r" name="chgr_cv_status" pos="4" rst="0x0">
          <comment>Flag when charging current below some level(0.5*full current) in CV mode
High effective</comment>
        </bits>
        <bits access="r" name="chgr_on" pos="3" rst="0x0">
          <comment>Charger voltage ready indicator, high effective
When VCHG&lt;4.1V: “0”
When VCHG&gt;4.3V: “1”</comment>
        </bits>
        <bits access="r" name="chgr_int" pos="2" rst="0x0">
          <comment>Charger present indicator, high effective
When VCHG&lt;3.1V: ”0”
When VCHG&gt;3.3V: ”1”</comment>
        </bits>
        <bits access="r" name="vchg_ovi" pos="0" rst="0x0">
          <comment>VCHG over voltage(programmable) flag
When VCHG higher than some voltage set by VCHG_OVP_V&lt;5:0&gt; and lasts 2mS, CHGR_OVI=”1”
The hysteresis voltage is 600mV.</comment>
        </bits>
      </reg>
      <reg name="arch_en" protect="rw">
        <comment>ARCH_EN</comment>
        <bits access="rw" name="arch_en" pos="0" rst="0x1">
          <comment>PCLK_arch enable</comment>
        </bits>
      </reg>
      <reg name="mcu_wr_prot_value" protect="rw">
        <comment>MCU_WR_PROT_VALUE</comment>
        <bits access="r" name="mcu_wr_prot" pos="15" rst="0x0">
          <comment>Arch_en write protect bit status.
When mcu_wr_prot_value==16'h3c4d,
 the bit is &quot;1&quot;,else &quot;0&quot;</comment>
        </bits>
        <bits access="w" name="mcu_wr_prot_value" pos="14:0" rst="0x0">
          <comment>Arch_en write protect value</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="dcdc_core_reg1" protect="rw">
        <comment>DCDC_CORE_REG1</comment>
        <bits access="rw" name="div_clk_vcore_en" pos="12" rst="0x0">
          <comment>clock gating enable</comment>
        </bits>
        <bits access="rw" name="phase_sel_vcore" pos="11:6" rst="0x0">
          <comment>the phase difference, 26M per step</comment>
        </bits>
        <bits access="rw" name="div_base_vcore" pos="5:0" rst="0xf">
          <comment>the division factor from 26M for DCDCCORE, in default the clock is from RC in analog
6'h0: no divide
6'h1: divide by 2
……
6'h3F: divide by 64</comment>
        </bits>
      </reg>
      <reg name="dcdc_gen_reg1" protect="rw">
        <comment>DCDC_GEN_REG1</comment>
        <bits access="rw" name="div_clk_vgen_en" pos="12" rst="0x0">
          <comment>clock gating enable</comment>
        </bits>
        <bits access="rw" name="phase_sel_vgen" pos="11:6" rst="0x0">
          <comment>the phase difference, 26M per step</comment>
        </bits>
        <bits access="rw" name="div_base_vgen" pos="5:0" rst="0xf">
          <comment>the division factor from 26M for DCDCGEN, in default the clock is from RC in analog
6'h0: no divide
6'h1: divide by 2
……
6'h3F: divide by 64</comment>
        </bits>
      </reg>
      <reg name="dcdc_vrf_reg1" protect="rw">
        <comment>DCDC_VRF_REG1</comment>
        <bits access="rw" name="div_clk_vrf_en" pos="12" rst="0x0">
          <comment>clock gating enable</comment>
        </bits>
        <bits access="rw" name="phase_sel_vrf" pos="11:6" rst="0x0">
          <comment>the phase difference, 26M per step</comment>
        </bits>
        <bits access="rw" name="div_base_vrf" pos="5:0" rst="0xf">
          <comment>the division factor from 26M for DCDCVRF, in default the clock is from RC in analog
6'h0: no divide
6'h1: divide by 2
……
6'h3F: divide by 64</comment>
        </bits>
      </reg>
      <reg name="bg_ctrl0" protect="rw">
        <comment>BG_CTRL</comment>
        <bits access="rw" name="bg_chop_en" pos="12" rst="0x0">
          <comment>Band-gap chopping enable:
“0”:chopping disable (default)
“1”: chopping enable</comment>
        </bits>
        <bits access="rw" name="rg_bg_ts" pos="8" rst="0x0">
          <comment>Band-gap test enable:
“0”:test disable (default)
“1”: test enable</comment>
        </bits>
      </reg>
      <reg name="ldo_vosel1" protect="rw">
        <comment>LDO_VOSEL1</comment>
        <bits access="rw" name="rg_ldo_usb33_vosel" pos="15:10" rst="0x33">
          <comment>USB33 LDO output voltage select                              000000~111111 1.625V~3.225V  25mv/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_vosel" pos="5:0" rst="0x2f">
          <comment>CAMA LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_vosel3" protect="rw">
        <comment>LDO_VOSEL3</comment>
        <bits access="rw" name="rg_ldo_mmc_vosel" pos="15:10" rst="0x2b">
          <comment>MMC LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_vosel" pos="5:0" rst="0x37">
          <comment>VIO33 LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_vosel4" protect="rw">
        <comment>LDO_VOSEL4</comment>
        <bits access="rw" name="rg_ldo_lcd_vosel" pos="15:10" rst="0x7">
          <comment>LCD LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_vosel" pos="5:0" rst="0x7">
          <comment>LP18 LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_lp18_vio33_ctrl1" protect="rw">
        <comment>LDO_LP18_CTRL1</comment>
        <bits access="rw" name="rg_ldo_lp18_ulp_ifb_en" pos="12" rst="0x0">
          <comment>LDO_LP18 increase feedback current 300nA in ULP mode</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_ulp_itrim" pos="9:8" rst="0x0">
          <comment>LDO_LP18 bias current trim in ulp mode;20nA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_ulp_ifb_en" pos="4" rst="0x0">
          <comment>LDO_VIO33 increase feedback current 300nA in ULP mode</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_ulp_itrim" pos="1:0" rst="0x0">
          <comment>LDO_VIO33 bias current trim in ulp mode;20nA/step</comment>
        </bits>
      </reg>
      <reg name="reserved_reg_core" protect="rw">
        <comment>RESERVED_REG_CORE</comment>
        <bits access="rw" name="reserved_core" pos="15:0" rst="0x0">
          <comment>reserved for CORE:
RG_RESERVED_CORE[0] for ldo ANA cap sel, default 0;
RG_RESERVED_CORE[1] for ldo CAMIO cap sel, default 0;
RG_RESERVED_CORE[2] for ldo RF18A cap sel, default 0;
RG_RESERVED_CORE[3] for ldo RF18B cap sel, default 0;</comment>
        </bits>
      </reg>
      <reg name="reserved_reg1" protect="rw">
        <comment>RESERVED_REG1</comment>
      </reg>
      <reg name="reserved_reg2" protect="rw">
        <comment>RESERVED_REG2</comment>
      </reg>
      <reg name="ldo_sim_ctrl0" protect="rw">
        <comment>LDO_SIM_CTRL0</comment>
        <bits access="rw" name="rg_ldo_sim1_cl_adj" pos="15:13" rst="0x3">
          <comment>LDO_SIM1 current limit threshold adjust                                         default 1'b011                                                                             000 to 111 current limit increase</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim1_shpt_en" pos="12" rst="0x1">
          <comment>LDO_SIM1 short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim1_rz_adj" pos="11" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim1_stb" pos="10:9" rst="0x0">
          <comment>LDO_SIM1 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim1_discharge_en" pos="8" rst="0x1">
          <comment>LDO_SIM1 discharge en</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim0_cl_adj" pos="7:5" rst="0x3">
          <comment>LDO_SIM0 current limit threshold adjust                                         default 1'b011                                                                             000 to 111 current limit increase</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim0_shpt_en" pos="4" rst="0x1">
          <comment>LDO_SIM0 short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim0_rz_adj" pos="3" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim0_stb" pos="2:1" rst="0x0">
          <comment>LDO_SIM0 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim0_discharge_en" pos="0" rst="0x1">
          <comment>LDO_SIM0 discharge en</comment>
        </bits>
      </reg>
      <reg name="ldo_sim_vosel" protect="rw">
        <comment>LDO_SIM_VOSEL</comment>
        <bits access="rw" name="rg_ldo_sim0_vosel" pos="15:10" rst="0x7">
          <comment>SIM0 LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step       1.8V=000111                                                             3V=110111</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim1_vosel" pos="5:0" rst="0x7">
          <comment>SIM1 LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step       1.8V=000111                                                             3V=110111</comment>
        </bits>
      </reg>
      <reg name="sim_vpa_ctrl0" protect="rw">
        <comment>SIM_VPA_CTRL0</comment>
        <bits access="rw" name="da_ldo_sim0_pd" pos="13" rst="0x1">
          <comment>LDO_SIM0 power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_sim1_pd" pos="12" rst="0x1">
          <comment>LDO_SIM1 power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_sim0_lp_en" pos="9" rst="0x0">
          <comment>LDO_SIM0 lower power mode  EN:
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_sim1_lp_en" pos="8" rst="0x0">
          <comment>LDO_SIM1 lower power mode  EN:
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="rg_vpa_lp_en" pos="4" rst="0x0">
          <comment>VPA low power mode
1'b0: active mode
1'b1: low-power mode</comment>
        </bits>
        <bits access="rw" name="rg_vpa_pd" pos="0" rst="0x1">
          <comment>DCDC VPA power down
1'b0: DCDC on
1'b1: DCDC power down</comment>
        </bits>
      </reg>
      <reg name="ldo_sim_ctrl1" protect="rw">
        <comment>LDO_SIM_CTRL1</comment>
        <bits access="rw" name="slp_ldosim1_pd_en" pos="13" rst="0x0">
          <comment>LDOSIM2 power down enable in deep sleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ldosim0_pd_en" pos="12" rst="0x0">
          <comment>LDO SIM1 power down enable in deep sleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ldosim1_lp_en" pos="9" rst="0x0">
          <comment>LDO SIM1 low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="slp_ldosim0_lp_en" pos="8" rst="0x0">
          <comment>LDO SIM0 low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
      </reg>
      <reg name="vpa_ctrl0" protect="rw">
        <comment>VPA_CTRL0</comment>
        <bits access="rw" name="ldo_vpa_votrim_sw_sel" pos="12" rst="0x0">
          <comment>DCDC VPA reference Bits selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="da_vpa_votrim" pos="4:0" rst="0x10">
          <comment>output voltage trim
5'10000: default 1.2V, 18.75mV/step
5'11111: +15 step
5'00000: -16 step</comment>
        </bits>
      </reg>
      <reg name="vpa_ctrl1" protect="rw">
        <comment>VPA_CTRL1</comment>
        <bits access="rw" name="rg_vpa_vosel" pos="6:0" rst="0x78">
          <comment>output voltage selection, 25mV/step.
7'h00=0.4V,
7'h7C=3.5V
default 7'h78=3.4V</comment>
        </bits>
      </reg>
      <reg name="vpa_ctrl2" protect="rw">
        <comment>VPA_CTRL2</comment>
        <bits access="rw" name="rg_vpa_zx_disable" pos="15" rst="0x0">
          <comment>force zero-cross off
1'b0: default, zero_cross detect on
1'b1: zero-cross detect off</comment>
        </bits>
        <bits access="rw" name="rg_vpa_zx_offset" pos="14:13" rst="0x0">
          <comment>zero-cross offset tuning
2'b00: default
2'b01: +4mV offset
2'b10: -2mV offset
2'b11: -4mV offset</comment>
        </bits>
        <bits access="rw" name="rg_vpa_antiring_en" pos="12" rst="0x0">
          <comment>anti-ring enable
1'b0: default, anti-ring off
1'b1: anti-ring on</comment>
        </bits>
        <bits access="rw" name="rg_vpa_apc_enable" pos="11" rst="0x0">
          <comment>APC mode enable
1'b0: default, RG control mode
1'b1: APC mode</comment>
        </bits>
        <bits access="rw" name="rg_vpa_apc_ramp_sel" pos="10" rst="0x0">
          <comment>APC ramp selection
1'b0: default, 2.0x ramp
1'b1: 2.5x ramp</comment>
        </bits>
        <bits access="rw" name="rg_vpa_bypass_disable" pos="9" rst="0x0">
          <comment>bypass mode disable
1'b0: default, auto bypass
1'b1: bypass off</comment>
        </bits>
        <bits access="rw" name="rg_vpa_bypass_forceon" pos="8" rst="0x0">
          <comment>bypass force on
1'b0: default, auto bypass
1'b1: force bypass mode on</comment>
        </bits>
        <bits access="rw" name="rg_vpa_bypass_threshold" pos="7:6" rst="0x0">
          <comment>bypass mode threshold
2'b00: default, ~200mV</comment>
        </bits>
        <bits access="rw" name="rg_vpa_ccomp3" pos="5:4" rst="0x0">
          <comment>compensation C3
2'b00: default 6.5pF
2'b01: -0.5pF
2'b10: +1pF
2'b11: +0.5pF</comment>
        </bits>
        <bits access="rw" name="rg_vpa_curlimit_r" pos="3:2" rst="0x0">
          <comment>current limit threshold tuning
2'b00: default 36k
2'b01: 52k
2'b10: 12k
2'b11: 28k</comment>
        </bits>
        <bits access="rw" name="rg_vpa_curses_m" pos="1:0" rst="0x0">
          <comment>current sense multiplier tuning
2'b00: default, x1
2'b01: x0.5
2'b10: x2
2'b11: x1.5</comment>
        </bits>
      </reg>
      <reg name="vpa_ctrl3" protect="rw">
        <comment>VPA_CTRL3</comment>
        <bits access="rw" name="rg_vpa_sawtoothcal_rst" pos="15" rst="0x0">
          <comment>sawtooth calibration
1'b0: default, auto calibration before power-on
1'b1: calibration manully</comment>
        </bits>
        <bits access="rw" name="rg_vpa_dvs_on" pos="14" rst="0x0">
          <comment>DVS control
1'b0: default, off
1'b0: on, for DCM down discharge</comment>
        </bits>
        <bits access="rw" name="rg_vpa_force_pwm" pos="13" rst="0x0">
          <comment>force PWM mode
1'b0: default, PFM/PWM auto mode
1'b1: force PWM mode</comment>
        </bits>
        <bits access="rw" name="rg_vpa_maxduty_sel" pos="12" rst="0x0">
          <comment>100% duty selection
1'b0: default, max duty=100%
1'b1: max duty ~95%</comment>
        </bits>
        <bits access="rw" name="rg_vpa_pfm_threshold" pos="11:10" rst="0x0">
          <comment>PFM mode threshold for upper limit
2'b00: default,960mV
2'b01: -40mV
2'b10: +40mV
2'b11: +80mV</comment>
        </bits>
        <bits access="rw" name="rg_vpa_rcomp2" pos="9:8" rst="0x0">
          <comment>compensation R2 select
2'b00: default, 960k
2'b01: 880k
2'b10: 1040k
2'b11: 1120k</comment>
        </bits>
        <bits access="rw" name="rg_vpa_rcomp3" pos="7:6" rst="0x0">
          <comment>compensation R3 select
2'b00: default, 9k
2'b01: 4.5k
2'b10: 18k
2'b11: 13.5k</comment>
        </bits>
        <bits access="rw" name="rg_vpa_sawtooth_slope" pos="5:4" rst="0x0">
          <comment>sawtooth tuning manully
2'b00: default 0.75x
2'b01: 0.875x
2'b10: 0.5x
2'b11: 0.625x</comment>
        </bits>
        <bits access="rw" name="rg_vpa_sr_hs" pos="3:2" rst="0x0">
          <comment>high side slew rate control
2'b00: default 2.5x
2'b01: 2x
2'b10: 1.5x
2'b11: 1x</comment>
        </bits>
        <bits access="rw" name="rg_vpa_sr_ls" pos="1:0" rst="0x0">
          <comment>low side slew rate control
2'b00: default 2x
2'b01: 1.5x
2'b10: 1.5x
2'b11: 1x</comment>
        </bits>
      </reg>
      <reg name="dcdc_vpa_reg1" protect="rw">
        <comment>DCDC_VPA_REG1</comment>
        <bits access="rw" name="div_clk_vpa_en" pos="12" rst="0x0">
          <comment>clock gating enable</comment>
        </bits>
        <bits access="rw" name="phase_sel_vpa" pos="11:6" rst="0x0">
          <comment>the phase difference, 26M per step</comment>
        </bits>
        <bits access="rw" name="div_base_vpa" pos="5:0" rst="0xf">
          <comment>the division factor from 26M for DCDCWPA, in default the clock is from RC in analog
6'h0: no divide
6'h1: divide by 2
……
6'h3F: divide by 64</comment>
        </bits>
      </reg>
      <hole size="1824"/>
      <reg name="sim_vpa_ctrl0_set" protect="rw"/>
      <reg name="ldo_sim_ctrl1_set" protect="rw"/>
      <hole size="1984"/>
      <reg name="sim_vpa_ctrl0_clr" protect="rw"/>
      <reg name="ldo_sim_ctrl1_clr" protect="rw"/>
    </module>
    <var name="REG_PMIC_ANA_SET_OFFSET" value="0x100"/>
    <var name="REG_PMIC_ANA_CLR_OFFSET" value="0x200"/>
    <instance address="0x51108c00" name="PMIC_ANA" type="PMIC_ANA"/>
  </archive>
  <archive relative="pmic_rtc_ana.xml">
    <module category="System" name="PMIC_RTC_ANA">
      <reg name="module_en0" protect="rw">
        <comment>MODULE_EN0</comment>
        <bits access="rw" name="iomux_en" pos="8" rst="0x1">
          <comment>PINREG module enable
0: Disable the PCLK  of pin registers
1: Enable  the PCLK  of pin registers</comment>
        </bits>
        <bits access="rw" name="rtc_topa_en" pos="7" rst="0x1">
          <comment>RTC_TOPA module enable
0: Disable the PCLK  of RTC_TOPA
1: Enable  the PCLK  of RTC_TOPA</comment>
        </bits>
        <bits access="rw" name="psm_topa_en" pos="4" rst="0x0">
          <comment>PSM  module enable
0: Disable the PCLK  of PSM
1: Enable  the PCLK  of PSM</comment>
        </bits>
        <bits access="rw" name="eic_en" pos="3" rst="0x0">
          <comment>EIC module enable
0: Disable the PCLK  of EIC
1: Enable  the PCLK  of EIC</comment>
        </bits>
        <bits access="rw" name="wdg_en" pos="2" rst="0x0">
          <comment>WDG module enable
0: Disable the PCLK  of watchdog
1: Enable  the PCLK  of watchdog</comment>
        </bits>
        <bits access="rw" name="rtc_en" pos="1" rst="0x1">
          <comment>RTC module enable
0: Disable the PCLK  of RTC
1: Enable  the PCLK  of RTC</comment>
        </bits>
      </reg>
      <reg name="dig_clk_en0" protect="rw">
        <comment>DIG_CLK_EN0</comment>
        <bits access="rw" name="clk_wdg_sel" pos="0" rst="0x0">
          <comment>WDG clk sel
0: clk_wdg_rtc
1: clk_32k_rtc</comment>
        </bits>
      </reg>
      <reg name="rtc_clk_en0" protect="rw">
        <comment>RTC_CLK_EN0</comment>
        <bits access="rw" name="rtc_efs_en" pos="11" rst="0x1">
          <comment>EFS RTC clock soft enable
0: Disable the RTC clock of EFS
1: Enable RTC clock of EFS</comment>
        </bits>
        <bits access="rw" name="rtc_eic_en" pos="3" rst="0x0">
          <comment>EIC RTC clock soft enable
0: Disable the RTC clock of EIC
1: Enable RTC clock of EIC</comment>
        </bits>
        <bits access="rw" name="rtc_wdg_en" pos="2" rst="0x1">
          <comment>Watchdog RTC clock soft enable
0: Disable the RTC clock of Watchdog
1: Enable RTC clock of Watchdo</comment>
        </bits>
        <bits access="rw" name="rtc_rtc_en" pos="1" rst="0x1">
          <comment>RTC RTC clock soft enable
0: Disable the RTC clock of RTC
1: Enable RTC clock of RTC</comment>
        </bits>
        <bits access="rw" name="rtc_arch_en" pos="0" rst="0x1">
          <comment>ARCH RTC clock soft enable
0: Disable the RTC clock of ARCH
1: Enable RTC clock of ARCH</comment>
        </bits>
      </reg>
      <reg name="soft_rst0" protect="rw">
        <comment>SOFT_RST0</comment>
        <bits access="rw" name="eic_soft_rst" pos="3" rst="0x0">
          <comment>EIC soft reset</comment>
        </bits>
        <bits access="rw" name="wdg_soft_rst" pos="2" rst="0x0">
          <comment>Watchdog soft reset</comment>
        </bits>
        <bits access="rw" name="rtc_soft_rst" pos="1" rst="0x0">
          <comment>RTC soft reset</comment>
        </bits>
      </reg>
      <reg name="vbat_ctrl1" protect="rw">
        <comment>VBAT_CTRL1</comment>
        <bits access="rw" name="da_ldo_vbat_reftrim_ulp" pos="12:8" rst="0x10">
          <comment>LDO_VBAT ULP reference voltage trim bit</comment>
        </bits>
        <bits access="rw" name="da_ldo_vbat_reftrim" pos="4:0" rst="0x10">
          <comment>LDO_VBAT reference voltage trim bit</comment>
        </bits>
      </reg>
      <reg name="ldo_vgen_ctrl3" protect="rw">
        <comment>LDO_VGEN_CTRL3</comment>
        <bits access="rw" name="da_ldo_vgen_reftrim" pos="4:0" rst="0x10">
          <comment>LDO_VGEN reference voltage trim bit</comment>
        </bits>
      </reg>
      <reg name="dcdc_ctrl1" protect="rw">
        <comment>DCDC_CTRL1</comment>
        <bits access="rw" name="da_dcdc_osc3m_en" pos="10" rst="0x0">
          <comment>internal oscillator enable
1'b0: oscillator off
1'b1: oscillator on</comment>
        </bits>
        <bits access="rw" name="da_dcdc_osc3m_freq" pos="9:5" rst="0x10">
          <comment>oscillator frequency tuning
5'b10000: default 3MHz
5'b01111: -1 step
5'b10001: +1 step
5'b00000: -16 step
5'b11111: +15 step</comment>
        </bits>
      </reg>
      <reg name="pm2_pd_en" protect="rw">
        <comment>PM2_PD_EN</comment>
        <bits access="rw" name="pm2_dcdc_core_ulp_en" pos="14" rst="0x0">
          <comment>PM2 VCORE ULP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldovio33_ulp_en" pos="13" rst="0x0">
          <comment>PM2 VIO33 ULP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldolp18_ulp_en" pos="12" rst="0x0">
          <comment>PM2 LP18 ULP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_dcdccore_lp_en" pos="11" rst="0x0">
          <comment>PM2 VCORE LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_dcdcgen_lp_en" pos="10" rst="0x0">
          <comment>PM2 VGEN LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldolp18_lp_en" pos="9" rst="0x0">
          <comment>PM2 VLP18 LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldodcxo_lp_en" pos="8" rst="0x0">
          <comment>PM2 VDCXO LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldovio33_lp_en" pos="7" rst="0x0">
          <comment>PM2 VIO33 LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldovio18_lp_en" pos="6" rst="0x0">
          <comment>PM2 VIO18 LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_dcdccore_pd_en" pos="5" rst="0x0">
          <comment>VCORE power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_dcdcgen_pd_en" pos="4" rst="0x0">
          <comment>VGEN power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldolp18_pd_en" pos="3" rst="0x0">
          <comment>VLP18 power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldodcxo_pd_en" pos="2" rst="0x0">
          <comment>VDCXO power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldovio33_pd_en" pos="1" rst="0x0">
          <comment>VIO33 power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldovio18_pd_en" pos="0" rst="0x0">
          <comment>VIO18 power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
      </reg>
      <reg name="vgen_ctrl1" protect="rw">
        <comment>VGEN_CTRL1</comment>
        <bits access="rw" name="rg_vgen_vosel" pos="7:0" rst="0x2c">
          <comment>output voltage selection, 12.5mV/step.
8'h00= 1.3V
default 8'h2c=1.85V</comment>
        </bits>
      </reg>
      <reg name="ldo_vbat_ctrl1" protect="rw">
        <comment>LDO_VBAT_CTRL1</comment>
      </reg>
      <reg name="chgr_status" protect="rw">
        <comment>CHGR_STATUS</comment>
        <bits access="rw" name="chgr_int_en" pos="13" rst="0x0">
          <comment>Chgr_int enable after CHG_DET_DONE</comment>
        </bits>
        <bits access="rw" name="dcp_switch_en" pos="1" rst="0x1">
          <comment>0: switch DPDM to USB phy when DCP
1: keep to connect charger detector when DCP</comment>
        </bits>
      </reg>
      <reg name="power_pd_sw0" protect="rw">
        <comment>POWER_PD_SW0</comment>
        <bits access="rw" name="da_ldo_spimem_pd" pos="15" rst="0x0">
          <comment>LDO_SPIMEM power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_usb33_pd" pos="14" rst="0x0">
          <comment>LDO_USB power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_ana_pd" pos="13" rst="0x0">
          <comment>LDO_ANA power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_rf12_pd" pos="12" rst="0x0">
          <comment>LDO_RF12 power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_lp18_pd" pos="11" rst="0x0">
          <comment>LDO_LP18 power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_vio33_pd" pos="10" rst="0x0">
          <comment>LDO_VIO33 power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="ldo_emm_pd" pos="9" rst="0x0">
          <comment>EMM domain power down                                            1: power down                                                                0: power on</comment>
        </bits>
        <bits access="rw" name="ldo_cp_pd" pos="8" rst="0x0">
          <comment>LDO of charge pump power down
1: power down
0: power on</comment>
        </bits>
        <bits access="rw" name="da_ldo_dcxo_pd" pos="7" rst="0x0">
          <comment>LDO_DCXO power down                                           1: power down                                                                0: power on</comment>
        </bits>
        <bits access="rw" name="da_ldo_mem_pd" pos="6" rst="0x0">
          <comment>LDO_MEM power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_vio18_pd" pos="5" rst="0x0">
          <comment>LDO_VIO18 power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_vgen_pd" pos="4" rst="0x0">
          <comment>DCDC power down
1'b0: DCDC on
1'b1: DCDC power down</comment>
        </bits>
        <bits access="rw" name="da_vrf_pd" pos="3" rst="0x0">
          <comment>DCDC power down
1'b0: DCDC on
1'b1: DCDC power down</comment>
        </bits>
        <bits access="rw" name="da_vcore_pd" pos="2" rst="0x0">
          <comment>DCDC power down
1'b0: DCDC on
1'b1: DCDC power down</comment>
        </bits>
        <bits access="rw" name="da_ldo_mmc_pd" pos="1" rst="0x0">
          <comment>LDO_MMC power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="bg_pd" pos="0" rst="0x0">
          <comment>Band-gap power down:
“1” is power down
“0” is power up
At reset, should be &quot;1&quot;</comment>
        </bits>
      </reg>
      <reg name="power_pd_hw" protect="rw">
        <comment>POWER_PD_HW</comment>
        <bits access="rw" name="pwr_off_seq_en" pos="0" rst="0x0">
          <comment>Power off_sequence enable</comment>
        </bits>
      </reg>
      <reg name="soft_rst_hw" protect="rw">
        <comment>SOFT_RST_HW</comment>
        <bits access="rw" name="reg_soft_rst_sw" pos="0" rst="0x0">
          <comment>register soft reset，write 1 can：
1、 reset total system
2 、power down and up</comment>
        </bits>
      </reg>
      <reg name="xtal_rc_ctrl" protect="rw">
        <comment>XTAL_RC_CTRL</comment>
        <bits access="rw" name="rg_rc64k_pu" pos="7" rst="0x1">
          <comment>RC Oscillator 32kHz power up
1‘b0: power off
1'b1:  power on</comment>
        </bits>
        <bits access="rw" name="rg_xtal32k_pu" pos="6" rst="0x1">
          <comment>Crystal 64kHz power up
1‘b0: power off
1'b1:  power on</comment>
        </bits>
        <bits access="rw" name="rg_xtal32k_coarse" pos="5:3" rst="0x4">
          <comment>Crystal 32kHz capacitor coarse adjust</comment>
        </bits>
        <bits access="rw" name="rg_xtal32k_fine" pos="2:0" rst="0x5">
          <comment>Crystal 32kHz capacitor fine adjust</comment>
        </bits>
      </reg>
      <reg name="rtc_ctrl" protect="rw">
        <comment>RTC_CTRL</comment>
        <bits access="rw" name="rg_rtc_vosel" pos="10:8" rst="0x4">
          <comment>LDO RTC output program bits
3'b100: 1.8V (Default)</comment>
        </bits>
        <bits access="rw" name="rg_vbatbk_vosel" pos="7:5" rst="0x4">
          <comment>Backup battery output program bits
3'b100: 3.0V default</comment>
        </bits>
        <bits access="rw" name="da_rtcbg_trim" pos="4:0" rst="0x10">
          <comment>RTC bandgap calibretion bit
cover +/-10%
step 0.625% acc +/- 0.3125%</comment>
        </bits>
      </reg>
      <reg name="rg_rtc_reserved1" protect="rw">
        <comment>RG_RTC_RESERVED1</comment>
        <bits access="rw" name="rg_rtc_reserved0" pos="15:8" rst="0xf0">
          <comment>RG_RTC_RESERVED0</comment>
        </bits>
        <bits access="rw" name="rg_rtc_reserved1" pos="7:0" rst="0xf0">
          <comment>RG_RTC_RESERVED1</comment>
        </bits>
      </reg>
      <reg name="dvdd_ctrl" protect="rw">
        <comment>DVDD_CTRL</comment>
        <bits access="rw" name="da_psm_vref_pd" pos="2" rst="0x0">
          <comment>ULP global bias power down
1'b0:  default, power on
1'b1:  power down</comment>
        </bits>
        <bits access="rw" name="da_dvdd_iso" pos="1" rst="0x1">
          <comment>DVDD18 isolation signal used in force mode
1'b1:  default isolation</comment>
        </bits>
        <bits access="rw" name="da_dvdd_pd" pos="0" rst="0x0">
          <comment>DVDD18 power down control used in force mode
1'b0:  DVDD18 power switch on
1'b1:  DVDD18 power switch off</comment>
        </bits>
      </reg>
      <reg name="powon_ctrl" protect="rw">
        <comment>POWON_CTRL</comment>
        <bits access="rw" name="rg_baton_t" pos="15:14" rst="0x0">
          <comment>Control bit of de-glitch time for battery remove
&quot;00&quot; 32us    &quot;01&quot; 64us    &quot;10&quot; 128us    &quot;11&quot; no de-glitch         default&quot;00&quot;</comment>
        </bits>
        <bits access="rw" name="rg_ovlo_en" pos="13" rst="0x1">
          <comment>Over voltage locked-out enable (high effective)
Default “1”</comment>
        </bits>
        <bits access="rw" name="rg_ovlo_t" pos="12:11" rst="0x0">
          <comment>Over voltage locked-out detecting time
00 : 1ms (default)
01 : 0.5ms
10 : 0.25ms
11 : 2ms</comment>
        </bits>
        <bits access="rw" name="rg_ovlo_v" pos="10:9" rst="0x0">
          <comment>Over voltage locked-out threshold
00 : 5.0V (default)
01 : 5.2V
10 : 4.8V
11 : 4.2V</comment>
        </bits>
        <bits access="rw" name="rg_uvlo_v" pos="8:7" rst="0x0">
          <comment>over voltage locked-out threshold
00 : 1.9V (default)
01 : 1.95V
10 : 1.85V
11 : 1.8V</comment>
        </bits>
        <bits access="rw" name="rg_vbat_crash_v" pos="6:5" rst="0x0">
          <comment>Battery crash voltage setting:
00: 1.7/2.1V (default)
01: 1.8/2.2V
10: 1.65/2.3V
11: 1.6/2.5V</comment>
        </bits>
        <bits access="rw" name="rg_buadet_en" pos="4" rst="0x0">
          <comment>BUA function enable
1'b0: default, off
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="rg_pbint_pullh_enb" pos="3" rst="0x0">
          <comment>PBINT pull-high control
1'b0: with internal pull-high. Default
1'b1: without internal pull-high</comment>
        </bits>
        <bits access="rw" name="da_powerdet_en" pos="2" rst="0x0">
          <comment>Power detect enable
1'b0: default, off
1'b1: Power detect on (UVLO/OVLO/VBATLOW)</comment>
        </bits>
        <bits access="rw" name="rg_vbatlow_en" pos="1" rst="0x1">
          <comment>VBATLOW detect enable control at LP mode
1'b0: VBATLOW detect off
1'b1: VBATLOW detect on</comment>
        </bits>
        <bits access="rw" name="rg_uvlo_en" pos="0" rst="0x1">
          <comment>UVLO detect enable control at LP mode
1'b0: UVLO detect off
1'b1: UVLO detect on</comment>
        </bits>
      </reg>
      <reg name="kpled_ctrl0" protect="rw">
        <comment>KPLED_CTRL0</comment>
        <bits access="rw" name="rg_kpled_pd" pos="7" rst="0x1">
          <comment>Key PAD LED driver power down
“1” power down (default)
“0” enable</comment>
        </bits>
        <bits access="rw" name="rg_kpled_pulldown_en" pos="6" rst="0x0">
          <comment>Keypad LED pull down enable signale, high effective
Defautl 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_pd" pos="5" rst="0x1">
          <comment>KPLED LDO power down signal, high effective
(Default 1, Off) iload=50mA</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_reftrim" pos="4:0" rst="0x10">
          <comment>LDO_KPLED trim bits:
6.25mV/step, 0.7V~0.89375V;   default 0.8V, 5'b10000</comment>
        </bits>
      </reg>
      <reg name="power_pd_sw1" protect="rw">
        <comment>POWER_PD_SW1</comment>
        <bits access="rw" name="da_ldo_cama_pd" pos="11" rst="0x1">
          <comment>LDO_CAMA power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_camd_pd" pos="10" rst="0x1">
          <comment>LDO_CAMD power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_lcd_pd" pos="8" rst="0x1">
          <comment>LDO_LCD power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_rf15_pd" pos="3" rst="0x1">
          <comment>LDO_RF15 power down:
“1” is power down(default)
“0” is power up</comment>
        </bits>
      </reg>
      <reg name="power_lp_sw0" protect="rw">
        <comment>POWER_LP_SW0</comment>
        <bits access="rw" name="da_ldo_usb33_lp_en" pos="13" rst="0x0">
          <comment>LDO_USB lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_dcxo_lp_en" pos="12" rst="0x0">
          <comment>LDO_DCXO lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_cama_lp_en" pos="11" rst="0x0">
          <comment>LDO_CAMA lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_camd_lp_en" pos="10" rst="0x0">
          <comment>LDO_CAMD lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_mmc_lp_en" pos="9" rst="0x0">
          <comment>LDO_MMC lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_lcd_lp_en" pos="8" rst="0x0">
          <comment>LDO_LCD lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_vio18_lp_en" pos="7" rst="0x0">
          <comment>LDO_VIO18 lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_ana_lp_en" pos="6" rst="0x0">
          <comment>LDO_ANA lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_mem_lp_en" pos="5" rst="0x0">
          <comment>LDO_MEM lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_spimem_lp_en" pos="4" rst="0x0">
          <comment>LDO_SPIMEM lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_rf15_lp_en" pos="3" rst="0x0">
          <comment>LDO_RF15 lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_rf12_lp_en" pos="2" rst="0x0">
          <comment>LDO_RF12 lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_lp18_lp_en" pos="1" rst="0x0">
          <comment>LDO_LP18 lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_vio33_lp_en" pos="0" rst="0x0">
          <comment>LDO_VIO33 lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
      </reg>
      <reg name="ldo_vosel1" protect="rw">
        <comment>LDO_VOSEL1</comment>
        <bits access="rw" name="rg_ldo_dcxo_vosel" pos="5:0" rst="0x7">
          <comment>DCXO LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
      </reg>
      <reg name="slp_ldo_ulp_ctrl" protect="rw">
        <comment>SLP_LDO_ULP_CTRL</comment>
        <bits access="rw" name="pm1_dcdc_core_ulp_en" pos="2" rst="0x0">
          <comment>LDO_VCORE ultra lower power mode  EN:
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="pm1_ldo_vio33_ulp_en" pos="1" rst="0x0">
          <comment>LDO_VIO33 ultra lower power mode  EN:
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="pm1_ldo_lp18_ulp_en" pos="0" rst="0x0">
          <comment>LDO_LP18 ultra lower power mode  EN:
“1” is enable
“0” is disable(default)</comment>
        </bits>
      </reg>
      <reg name="ldo_vgen_ctrl" protect="rw">
        <comment>LDO_VGEN_CTRL</comment>
        <bits access="rw" name="rg_ldo_vgen_auxcal_sel" pos="2:0" rst="0x0">
          <comment>DCDC supplied LDO TRIM CONTROL BITS:
000:  cal disable (default)
001: LDO VDDCAMIOcal enable;
010: LDO ANA cal enable;
011: LDO VDDRF18A cal enable;
100: LDO VDDCAMD cal enable;
101: LDO VDDMEM cal enable;
110: LDO VDDCON cal enable;
111: LDO VDDRF18B cal enable;</comment>
        </bits>
      </reg>
      <reg name="ldo_lp18_vio33_ulp_en" protect="rw">
        <comment>LDO_LP18_VIO33_ULP_EN</comment>
        <bits access="rw" name="da_ldo_vio33_ulp_en" pos="1" rst="0x0">
          <comment>LDO_VIO33 ultra lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_lp18_ulp_en" pos="0" rst="0x0">
          <comment>LDO_LP18 ultra lower power mode  EN(force mode):
“1” is enable
“0” is disable(default)</comment>
        </bits>
      </reg>
      <reg name="vcore_ctrl0" protect="rw">
        <comment>VCORE_CTRL0</comment>
        <bits access="rw" name="da_vcore_vosel" pos="8:0" rst="0x120">
          <comment>output voltage selection
9'b100100000, default 0.9V</comment>
        </bits>
      </reg>
      <reg name="vcore_ctrl1" protect="rw">
        <comment>VCORE_CTRL1</comment>
        <bits access="rw" name="rg_vcore_lp_en" pos="14" rst="0x0">
          <comment>low power mode(force mode)
1'b0: active mode
1'b1: low-power mode</comment>
        </bits>
        <bits access="rw" name="da_vcore_ulp_en" pos="13" rst="0x0">
          <comment>Ultra- low power mode(force mode)
1'b0: active mode
1'b1: low-power mode</comment>
        </bits>
        <bits access="rw" name="da_vcore_ulp_ret" pos="12" rst="0x0">
          <comment>Retention active at ULP mode(force mode)
1'b0: retention off
1'b1: retention active</comment>
        </bits>
        <bits access="rw" name="da_vcore_votrim" pos="9:5" rst="0x10">
          <comment>output voltage trimming</comment>
        </bits>
        <bits access="rw" name="da_vcore_votrim_lp" pos="4:0" rst="0x10">
          <comment>output voltage trimming at low power mode</comment>
        </bits>
      </reg>
      <reg name="vrf_ctrl2" protect="rw">
        <comment>VRF_CTRL2</comment>
        <bits access="rw" name="da_vrf_lp_en" pos="5" rst="0x0">
          <comment>VRF low power mode(force mode)
1'b0: active mode
1'b1: low-power mode</comment>
        </bits>
        <bits access="rw" name="da_vrf_votrim" pos="4:0" rst="0x10">
          <comment>output voltage selection, 12.5mV/step.
8'h00= 1.3V
default 8'h2c=1.85V</comment>
        </bits>
      </reg>
      <reg name="vrf_ctrl3" protect="rw">
        <comment>VRF_CTRL3</comment>
        <bits access="rw" name="rg_vrf_vosel" pos="8:0" rst="0xd0">
          <comment>output voltage selection, 6.25mV/step.
9'b011010000, default 1.3V</comment>
        </bits>
      </reg>
      <reg name="vgen_ctrl0" protect="rw">
        <comment>VGEN_CTRL0</comment>
        <bits access="rw" name="slp_ldo_mem_powersel_en" pos="9" rst="0x0">
          <comment>LP mode VMEM power switch enable:
1'b0:VMEM out
1'b1:VMEM short lp18,lp18 out</comment>
        </bits>
        <bits access="rw" name="pm2_ldo_mem_powersel" pos="8" rst="0x0">
          <comment>PM2 LDO VMEM power switch value:
1'b0:VMEM out
1'b1:VMEM short lp18,lp18 out</comment>
        </bits>
        <bits access="rw" name="da_vgen_lp_en" pos="5" rst="0x0">
          <comment>VGEN low power mode(force mode)
1'b0: active mode
1'b1: low-power mode</comment>
        </bits>
        <bits access="rw" name="da_vgen_votrim" pos="4:0" rst="0x10">
          <comment>VGEN output voltage trim
5'10000: default 1.2V, 18.75mV/step
5'11111: +15 step
5'00000: -16 step</comment>
        </bits>
      </reg>
      <reg name="chgr_ctrl0" protect="rw">
        <comment>CHGR_CTRL0</comment>
        <bits access="rw" name="chgr_pd" pos="10" rst="0x0">
          <comment>“1”  Internal charger power down
 “0” Internal charger power up</comment>
        </bits>
        <bits access="rw" name="chgr_ptest" pos="9" rst="0x0">
          <comment>Charger production test signal,testmode flag
&quot;1&quot;ATE test mode, reduce delay time after VCHG insert
&quot;0&quot; normal mode</comment>
        </bits>
        <bits access="rw" name="chgr_expower_device" pos="8" rst="0x0">
          <comment>Choice of charger external power device
0:PNP+NMOS
1:PMOS+DIODE
Default value is 0</comment>
        </bits>
        <bits access="rw" name="chgr_dpm" pos="7:6" rst="0x3">
          <comment>VCHG tracking voltage level for automatic input control loop(AICL)
00: 3.8V
01: 3.95V
10: 4.3V
11: 4.5V
Default value is 11</comment>
        </bits>
        <bits access="rw" name="chgr_cv_v" pos="5:0" rst="0x10">
          <comment>Battery sense DAC (CC-CV trans-point control)
(default 6’b010000)</comment>
        </bits>
      </reg>
      <reg name="chgr_det_ctrl0" protect="rw">
        <comment>CHGR_DET_CTRL0</comment>
        <bits access="rw" name="dp_dm_bc_enb" pos="5" rst="0x1">
          <comment>The DP DM path switch control
“1” switch to USB phy, BC1P2 detect disable (default)
“0” switch to BC1P2, BC1P2 detect enable</comment>
        </bits>
        <bits access="rw" name="rg_dp_dm_aux_en" pos="4" rst="0x0">
          <comment>DP, DM to auxADC select signal:
“0”: switch off, no DP/DM to auxADC
“1”: switch on, DP/DM to auxADC</comment>
        </bits>
        <bits access="rw" name="chg_int_delay" pos="2:0" rst="0x0">
          <comment>charger int delay time:
000：0ms
001：64ms
010：2×64ms
…..
111：7×64ms</comment>
        </bits>
      </reg>
      <reg name="slp_ldo_pd_ctrl0" protect="rw">
        <comment>SLP_LDO_PD_CTRL0</comment>
        <bits access="rw" name="pm1_ldovio18_pd_en" pos="15" rst="0x0">
          <comment>LDO VIO18 power down enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldoana_pd_en" pos="14" rst="0x0">
          <comment>LDO ANA power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldorf12_pd_en" pos="13" rst="0x0">
          <comment>LDO RF12 power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldolp18_pd_en" pos="12" rst="0x0">
          <comment>LDO LP18 power down enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldodcxo_pd_en" pos="11" rst="0x0">
          <comment>LDO DCXO power down enable PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldovio33_pd_en" pos="10" rst="0x0">
          <comment>LDO VIO33 power down enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldorf15_pd_en" pos="9" rst="0x0">
          <comment>LDO RF15 power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldospimem_pd_en" pos="8" rst="0x0">
          <comment>LDO SPIMEM power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldousb_pd_en" pos="7" rst="0x0">
          <comment>LDO USB power down enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldokpled_pd_en" pos="6" rst="0x0">
          <comment>LDO KPLED power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldommc_pd_en" pos="5" rst="0x0">
          <comment>LDO MMC power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldolcd_pd_en" pos="4" rst="0x0">
          <comment>LDO LCD power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldocamd_pd_en" pos="3" rst="0x0">
          <comment>LDO CAMD power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldocama_pd_en" pos="2" rst="0x0">
          <comment>LDO CAMA power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="slp_ldo_pd_ctrl1" protect="rw">
        <comment>SLP_LDO_PD_CTRL1</comment>
        <bits access="rw" name="pm1_ldocp_pd_en" pos="4" rst="0x0">
          <comment>LDO CP power down enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldo_pd_en" pos="3" rst="0x0">
          <comment>ALL LDO and DCDC power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_io_en" pos="2" rst="0x0">
          <comment>IO PAD sleep enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ldo_xtl_en" pos="1" rst="0x0">
          <comment>LDO and DCDC can be controlled by external device if this bit is set
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldomem_pd_en" pos="0" rst="0x0">
          <comment>LDO MEM power down enable in PM1
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="slp_dcdc_pd_ctrl" protect="rw">
        <comment>SLP_DCDC_PD_CTRL</comment>
        <bits access="rw" name="slp_dcdccore_pd_rstn_th" pos="15:12" rst="0x0">
          <comment>The number of 32K cycles set reset delay in DCDC CORE power down sleep mode</comment>
        </bits>
        <bits access="rw" name="slp_dcdccore_pu_rstn_th" pos="11:6" rst="0x0">
          <comment>The number of 32K cycles release reset delay in DCDC CORE power down sleep mode</comment>
        </bits>
        <bits access="rw" name="slp_dcdccore_drop_en" pos="3" rst="0x0">
          <comment>DCDC CORE power drop enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_dcdcvrf_pd_en" pos="1" rst="0x0">
          <comment>DCDC RF power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_dcdcgen_pd_en" pos="0" rst="0x0">
          <comment>DCDC GEN power down enable in PM1
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="dcdc_core_slp_ctrl0" protect="rw">
        <comment>DCDC_CORE_SLP_CTRL0</comment>
        <bits access="rw" name="pm1_dcdc_core_slp_step_delay" pos="13:12" rst="0x0">
          <comment>delay between two steps in PM1
00:1*32k clock
01:2*32k clock
10:3*32k clock
11:4*32k clock</comment>
        </bits>
        <bits access="rw" name="pm1_dcdc_core_slp_step_num" pos="11:8" rst="0x0">
          <comment>step number in PM1</comment>
        </bits>
        <bits access="rw" name="pm1_dcdc_core_slp_step_vol" pos="7:3" rst="0x0">
          <comment>voltage per step in PM1
00000:0mv
00001:1*3.125mv
00010:2*3.125mv
…..
11111:31*3.125mv</comment>
        </bits>
        <bits access="rw" name="pm1_dcdccore_pd_en" pos="1" rst="0x0">
          <comment>DCDC CORE power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dcdc_core_slp_step_en" pos="0" rst="0x0">
          <comment>DCDCCORE step tune enable in deep sleep
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="dcdc_core_slp_ctrl1" protect="rw">
        <comment>DCDC_CORE_SLP_CTRL1</comment>
        <bits access="rw" name="pm1_dcdc_core_vosel_ds_sw" pos="8:0" rst="0x4">
          <comment>DCDC CORE voltage control in PM1</comment>
        </bits>
      </reg>
      <reg name="slp_dcdc_lp_ctrl" protect="rw">
        <comment>SLP_DCDC_LP_CTRL</comment>
        <bits access="rw" name="pm1_dcdccore_lp_en" pos="4" rst="0x0">
          <comment>DCDC CORE low power mode enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_dcdcvrf_lp_en" pos="2" rst="0x0">
          <comment>DCDC VRF low power mode enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_dcdcgen_lp_en" pos="1" rst="0x0">
          <comment>DCDC GEN low power mode enable in PM1
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="slp_ldo_lp_ctrl0" protect="rw">
        <comment>SLP_LDO_LP_CTRL0</comment>
        <bits access="rw" name="slp_ldorf15_lp_en" pos="14" rst="0x0">
          <comment>LDO RF15 low power mode enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldorf12_lp_en" pos="13" rst="0x0">
          <comment>LDO RF12 low power mode enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldovio33_lp_en" pos="12" rst="0x0">
          <comment>LDO EMMCCORE low power mode enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldodcxo_lp_en" pos="11" rst="0x0">
          <comment>LDO DCXO low power mode enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldovio18_lp_en" pos="10" rst="0x0">
          <comment>LDO VIO18 low power mode enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldoana_lp_en" pos="9" rst="0x0">
          <comment>LDO ANA low power mode enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldospimem_lp_en" pos="8" rst="0x0">
          <comment>LDO MEM low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="slp_ldommc_lp_en" pos="7" rst="0x0">
          <comment>LDO MMC low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldousb_lp_en" pos="6" rst="0x0">
          <comment>LDO USB low power mode enable in PM1
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="slp_ldolcd_lp_en" pos="4" rst="0x0">
          <comment>LDO LCD low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="slp_ldocamd_lp_en" pos="3" rst="0x0">
          <comment>LDO CAMD low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="slp_ldocama_lp_en" pos="2" rst="0x0">
          <comment>LDO CAMA low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
      </reg>
      <reg name="slp_ldo_lp_ctrl1" protect="rw">
        <comment>SLP_LDO_LP_CTRL1</comment>
        <bits access="rw" name="pm2_dcdc_core_vosel_ds_sw" pos="15:7" rst="0x0">
          <comment>DCDC CORE voltage control in PM2</comment>
        </bits>
        <bits access="rw" name="pm1_ldolp18_lp_en" pos="3" rst="0x0">
          <comment>LDO LP18 low power mode enable in PM1
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldomem_lp_en" pos="0" rst="0x0">
          <comment>LDO MEM low power mode enable in PM1
0: Disable
1: Enable</comment>
        </bits>
      </reg>
      <reg name="reserved_reg_rtc" protect="rw">
        <comment>RESERVED_REG_RTC</comment>
        <bits access="rw" name="reserved_rtc" pos="15:0" rst="0x0">
          <comment>RG_RESERVED_RTC[4:0],   DCXO trim bit for 32k-less poweroff mode.  SW load from Efuse at first time power on.
RG_RESERVED_RTC[15:5], reserved</comment>
        </bits>
      </reg>
      <reg name="dcdc_vlg_sel" protect="rw">
        <comment>DCDC_VLG_SEL</comment>
        <bits access="rw" name="dcdc_gen_sw_sel" pos="3" rst="0x0">
          <comment>DCDC Voltage Program Bits selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="dcdc_core_votrim_sw_sel" pos="2" rst="0x0">
          <comment>DCDC Voltage Trim Bits selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="dcdc_core_slp_sw_sel" pos="1" rst="0x0">
          <comment>DCDC Voltage Program Bits selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="dcdc_core_nor_sw_sel" pos="0" rst="0x0">
          <comment>DCDC Voltage Program Bits selection
0: From efuse
1: From Software Register</comment>
        </bits>
      </reg>
      <reg name="ldo_vlg_sel0" protect="rw">
        <comment>LDO_VLG_SEL0</comment>
        <bits access="rw" name="vgen_reftrim_sw_sel" pos="9" rst="0x0">
          <comment>LDO_VGEN reference voltage trim bit selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="vbat_reftrim_ulp_sw_sel" pos="8" rst="0x0">
          <comment>LDO_VBAT reference ULP voltage trim bit selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="vbat_reftrim_sw_sel" pos="7" rst="0x0">
          <comment>LDO_VBAT reference voltage trim bit selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="dcdc_osc3m_freq_sw_sel" pos="6" rst="0x0">
          <comment>oscillator frequency tuning selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="rtcbg_trim_sw_sel" pos="5" rst="0x0">
          <comment>RTC bandgap calibretion bit selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="vrf_votrim_sw_sel" pos="4" rst="0x0">
          <comment>VRF output voltage selection,
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="vgen_votrim_sw_sel" pos="2" rst="0x0">
          <comment>output voltage trim selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="ldo_vcore_votrim_ulp_sw_sel" pos="1" rst="0x0">
          <comment>LDO Voltage trim selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="ldo_vcore_votrim_sw_sel" pos="0" rst="0x0">
          <comment>LDO Voltage trim selection
0: From efuse
1: From Software Register</comment>
        </bits>
      </reg>
      <reg name="clk32kless_ctrl0" protect="rw">
        <comment>CLK32KLESS_CTRL0</comment>
        <bits access="r" name="rc_mode_wr_ack_flag" pos="14" rst="0x0">
          <comment>RC_MODE write ack flag</comment>
        </bits>
        <bits access="rc" name="rc_mode_wr_ack_flag_clr" pos="10" rst="0x0">
          <comment>RC_MODE write ack flag clear, high effective</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_lp_en_rtcset" pos="7" rst="0x0">
          <comment>Low power LDO_DCXO power down set in RTC</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_lp_en_rtcclr" pos="6" rst="0x0">
          <comment>Low power LDO_DCXO power down clear in RTC</comment>
        </bits>
        <bits access="r" name="rtc_mode" pos="4" rst="0x0">
          <comment>0: 32k crystal
1: 32k-less</comment>
        </bits>
        <bits access="rw" name="rc_32k_sel" pos="1" rst="0x0">
          <comment>32K clock select in 32K crystal removal option
 0: From XO  1: From RC</comment>
        </bits>
        <bits access="rw" name="rc_32k_en" pos="0" rst="0x1">
          <comment>RC 32K oscillator enable</comment>
        </bits>
      </reg>
      <reg name="clk32kless_ctrl1" protect="rw">
        <comment>CLK32KLESS_CTRL1</comment>
        <bits access="rw" name="rc_mode" pos="15:0" rst="0x0">
          <comment>RC 32K mode in battery drop case:
16'h95A5: RC oscillator stop working.
Others: RC oscillator keep working.</comment>
        </bits>
      </reg>
      <reg name="xtl_wait_ctrl0" protect="rw">
        <comment>XTL_WAIT_CTRL0</comment>
      </reg>
      <reg name="por_rst_monitor" protect="rw">
        <comment>POR_RST_MONITOR</comment>
        <bits access="rw" name="por_rst_monitor" pos="15:0" rst="0x0">
          <comment>When POR reset active, this register is reset to 0</comment>
        </bits>
      </reg>
      <reg name="wdg_rst_monitor" protect="rw">
        <comment>WDG_RST_MONITOR</comment>
        <bits access="rw" name="wdg_rst_monitor" pos="15:0" rst="0x0">
          <comment>When WDG reset active, this register is reset to 0</comment>
        </bits>
      </reg>
      <reg name="por_pin_rst_monitor" protect="rw">
        <comment>POR_PIN_RST_MONITOR</comment>
        <bits access="rw" name="por_pin_rst_monitor" pos="15:0" rst="0x0">
          <comment>When POR_EXT_RST active, this register is reset to 0</comment>
        </bits>
      </reg>
      <reg name="por_src_flag" protect="rw">
        <comment>POR_SRC_FLAG</comment>
        <bits access="rw" name="por_sw_force_on" pos="15" rst="0x0">
          <comment>Setting this bit could disable the 1S debouncing time of power key after boot.</comment>
        </bits>
        <bits access="rc" name="reg_soft_rst_flag_clr" pos="14" rst="0x0">
          <comment>register reset flag clear</comment>
        </bits>
        <bits access="r" name="por_src_flag" pos="13:0" rst="0x0">
          <comment>Power on source flag:
[0]: Debounced PBINT signal, set when PBINT=0 &gt;50ms, clear when PBINT=1&gt;50ms.
[1]: PBINT initiating power-up hardware flag, set when PBINT=0&gt;1s, clear after power down.
[2]: reserved.
[3]: reserved.
[4]: Debounced CHGR_INT signal, set when VCHG=1 &gt;50ms, clear when VCHG=0&gt;50ms.
[5]: Charger plug-in initiating power-up hardware flag, set when VCHG=1&gt;1s, clear after power down.
[6]: RTC alarm initiating power-up hardware flag
[7]: Long pressing power key reboot hardware flag, set when PBINT=0&gt;PBINT_7S_THRESHOLD, clear after power down.
[8]: PBINT initiating power-up software flag, set when PBINT=0&gt;1s, clear by pbint_flag_clr.
[9]: reserved.
[10]: Charger plug-in initiating power-up software flag, set when VCHG=1&gt;1s, clear by chgr_int_flag_clr.
[11: External pin reset reboot software flag, set when EXTRSTN=0&gt;30ms, clear by ext_rstn_flag_clr.
[12]: Long pressing power key reboot software flag, set when PBINT=0&gt;PBINT_7S_THRESHOLD, clear by pbint_7s_flag_clr.
[13]: flag when register reset happened</comment>
        </bits>
      </reg>
      <reg name="por_7s_ctrl" protect="rw">
        <comment>POR_7S_CTRL</comment>
        <bits access="rw" name="pbint_7s_flag_clr" pos="15" rst="0x0">
          <comment>Write 1’b1 to this bit will clear pbint_7s_flag.</comment>
        </bits>
        <bits access="rw" name="ext_rstn_flag_clr" pos="14" rst="0x0">
          <comment>Write 1’b1 to this bit will clear ext_rstn_flag.</comment>
        </bits>
        <bits access="rw" name="chgr_int_flag_clr" pos="13" rst="0x0">
          <comment>Write 1’b1 to this bit will clear chgr_int_flag.</comment>
        </bits>
        <bits access="rw" name="pbint_flag_clr" pos="11" rst="0x0">
          <comment>Write 1’b1 to this bit will clear pbint_flag.</comment>
        </bits>
        <bits access="rw" name="key2_7s_rst_en" pos="9" rst="0x0">
          <comment>1: One-key Reset Mode;
0: Two-key Reset Mode;</comment>
        </bits>
        <bits access="rw" name="pbint_7s_rst_swmode" pos="8" rst="0x1">
          <comment>0: long reset;
1: short reset;</comment>
        </bits>
        <bits access="rw" name="pbint_7s_rst_threshold" pos="7:4" rst="0x6">
          <comment>The power key long pressing time threshold:
0~1: 2S
2: 3S
3: 4S
4: 5S
5: 6S
6: 7S
7: 8S
8: 9S
9: 10S
10:11S
11:12S
12: 13S
13:14S
14:15S
15:16S</comment>
        </bits>
        <bits access="rw" name="ext_rstn_mode" pos="3" rst="0x0">
          <comment>EXT_RSTN PIN function mode when 1key 7S reset
0: EXT_INT
1: RESET</comment>
        </bits>
        <bits access="rw" name="pbint_7s_auto_on_en" pos="2" rst="0x1">
          <comment>RTC register PBINT_7S_AUTO_ON_EN</comment>
        </bits>
        <bits access="rw" name="pbint_7s_rst_disable" pos="1" rst="0x0">
          <comment>0: enable 7s reset function;
1: disable 7s reset function;</comment>
        </bits>
        <bits access="rw" name="pbint_7s_rst_mode" pos="0" rst="0x1">
          <comment>0: software reset;
1: hardware reset;</comment>
        </bits>
      </reg>
      <reg name="hwrst_rtc" protect="rw">
        <comment>HWRST_RTC</comment>
        <bits access="r" name="hwrst_rtc_reg_sts" pos="15:8" rst="0x0">
          <comment>RTC status register, set by HWRST_RTC_SET.</comment>
        </bits>
        <bits access="rw" name="hwrst_rtc_reg_set" pos="7:0" rst="0x0">
          <comment>Software set this register to test VBAT and RTC power status.</comment>
        </bits>
      </reg>
      <reg name="smpl_ctrl0" protect="rw">
        <comment>SMPL_CTRL0</comment>
        <bits access="rw" name="smpl_mode" pos="15:0" rst="0x0">
          <comment>SMPL mode:
[15:13]: SMPL timer threshold
                0: 0.25s
                1: 0.5s
                2: 0.75s
                 ……..
                 7: 2s
[12:0]: SMPL enable
               13'h1935: enable
                Others:     disable</comment>
        </bits>
      </reg>
      <reg name="rtc_rst0" protect="rw">
        <comment>RTC_RST0</comment>
        <bits access="rw" name="rtc_clk_flag_set" pos="15:0" rst="0x0">
          <comment>RTC register flag</comment>
        </bits>
      </reg>
      <reg name="rtc_rst1" protect="rw">
        <comment>RTC_RST1</comment>
        <bits access="rw" name="rtc_clk_flag_clr" pos="15:0" rst="0x0">
          <comment>RTC register flag</comment>
        </bits>
      </reg>
      <reg name="rtc_rst2" protect="rw">
        <comment>RTC_RST2</comment>
        <bits access="r" name="rtc_clk_flag_rtc" pos="15:0" rst="0xa596">
          <comment>RTC register flag, reset by RTC_RST, default is 16'hA596</comment>
        </bits>
      </reg>
      <reg name="rtc_clk_stop" protect="rw">
        <comment>RTC_CLK_STOP</comment>
        <bits access="r" name="rtc_clk_stop_flag" pos="7" rst="0x0">
          <comment>rtc time over thresthold value</comment>
        </bits>
        <bits access="rw" name="rtc_clk_stop_threshold" pos="6:0" rst="0x10">
          <comment>set reset rtc cnt time,default 16s</comment>
        </bits>
      </reg>
      <reg name="vbat_drop_cnt" protect="rw">
        <comment>VBAT_DROP_CNT</comment>
        <bits access="r" name="vbat_drop_cnt" pos="11:0" rst="0x0">
          <comment>VBAT Drop Time Count</comment>
        </bits>
      </reg>
      <reg name="mixed_ctrl" protect="rw">
        <comment>MIXED_CTRL</comment>
        <bits access="r" name="ad_buadet" pos="15" rst="0x0">
          <comment>Power detect enable
1'b0: default, off
1'b1: Power detect on (UVLO/OVLO/VBATLOW)</comment>
        </bits>
        <bits access="r" name="batdet_ok" pos="8" rst="0x1">
          <comment>Battery presence flag to SW and POCV, so need RTC domain
&quot;0&quot; no battery
&quot;1&quot; battery presence</comment>
        </bits>
        <bits access="r" name="vbat_ok" pos="5" rst="0x1">
          <comment>VBAT detect. Active “0” is reset, no need 32K osc (same as BATDET_OK).</comment>
        </bits>
        <bits access="rw" name="all_gpi_deb" pos="3" rst="0x0">
          <comment>ALL GPI source debug</comment>
        </bits>
        <bits access="rw" name="gpi_debug_en" pos="2" rst="0x0">
          <comment>GPI debug enable</comment>
        </bits>
        <bits access="rw" name="all_int_deb" pos="1" rst="0x0">
          <comment>ALL_INT debug, if 1, interrupt will be sent</comment>
        </bits>
        <bits access="rw" name="int_debug_en" pos="0" rst="0x0">
          <comment>Interupt debug enable</comment>
        </bits>
      </reg>
      <reg name="por_off_flag" protect="rw">
        <comment>POR_OFF_FLAG</comment>
        <bits access="r" name="por_chip_pd_flag" pos="13" rst="0x0">
          <comment>uvlo + ovlo chip power down flag</comment>
        </bits>
        <bits access="rc" name="por_chip_pd_flag_clr" pos="12" rst="0x0">
          <comment>uvlo  + ovlo chip power down flag clear</comment>
        </bits>
        <bits access="r" name="uvlo_chip_pd_flag" pos="11" rst="0x0">
          <comment>uvlo chip power down flag</comment>
        </bits>
        <bits access="rc" name="uvlo_chip_pd_flag_clr" pos="10" rst="0x0">
          <comment>uvlo chip power down flag clear</comment>
        </bits>
        <bits access="r" name="hard_7s_chip_pd_flag" pos="9" rst="0x0">
          <comment>7s hard chip power down flag</comment>
        </bits>
        <bits access="rc" name="hard_7s_chip_pd_flag_clr" pos="8" rst="0x0">
          <comment>7s hard chip power down flag clear</comment>
        </bits>
        <bits access="r" name="sw_chip_pd_flag" pos="7" rst="0x0">
          <comment>SW chip power down flag</comment>
        </bits>
        <bits access="rc" name="sw_chip_pd_flag_clr" pos="6" rst="0x0">
          <comment>SW chip power down flag clear</comment>
        </bits>
        <bits access="r" name="hw_chip_pd_flag" pos="5" rst="0x0">
          <comment>HW chip power down flag</comment>
        </bits>
        <bits access="rc" name="hw_chip_pd_flag_clr" pos="4" rst="0x0">
          <comment>HW chip power down flag clear</comment>
        </bits>
        <bits access="r" name="otp_chip_pd_flag" pos="3" rst="0x0">
          <comment>OTP chip power down flag</comment>
        </bits>
        <bits access="rc" name="otp_chip_pd_flag_clr" pos="2" rst="0x0">
          <comment>OTP chip power down flag clear</comment>
        </bits>
      </reg>
      <reg name="swrst_ctrl0" protect="rw">
        <comment>SWRST_CTRL0</comment>
        <bits access="rw" name="ext_rstn_pd_en" pos="10" rst="0x0">
          <comment>Software reset certain power enable when ext_rstn valid</comment>
        </bits>
        <bits access="rw" name="pb_7s_rst_pd_en" pos="9" rst="0x0">
          <comment>Software reset certain power enable when pb_7s_rst valid</comment>
        </bits>
        <bits access="rw" name="reg_rst_pd_en" pos="8" rst="0x0">
          <comment>Software reset certain power enable when reg_rst valid</comment>
        </bits>
        <bits access="rw" name="wdg_rst_pd_en" pos="7" rst="0x0">
          <comment>Software reset certain power enable when wdg_rst valid</comment>
        </bits>
        <bits access="rw" name="reg_rst_en" pos="4" rst="0x0">
          <comment>register reset enable:
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_pd_threshold" pos="3:0" rst="0x0">
          <comment>reset LDO to normal mode threshold time
8ms/step,default 8ms</comment>
        </bits>
      </reg>
      <reg name="swrst_ctrl1" protect="rw">
        <comment>SWRST_CTRL1</comment>
        <bits access="rw" name="sw_rst_spimem_pd_en" pos="15" rst="0x0">
          <comment>Software reset LDO_SPIMEM_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_vio18_pd_en" pos="14" rst="0x0">
          <comment>Software reset LDO_VIO18_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_dcdcgen_pd_en" pos="10" rst="0x0">
          <comment>Software reset DCDC_GEN_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_dcdccore_pd_en" pos="9" rst="0x0">
          <comment>Software reset DCDC_CORE_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_mem_pd_en" pos="8" rst="0x0">
          <comment>Software reset LDO_MEM_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_dcxo_pd_en" pos="7" rst="0x0">
          <comment>Software reset LDO_DCXO_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_rf12_pd_en" pos="6" rst="0x0">
          <comment>Software reset LDO_RF12_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_ana_pd_en" pos="5" rst="0x0">
          <comment>Software reset LDO_ANA_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_rf15_pd_en" pos="4" rst="0x0">
          <comment>Software reset LDO_RF15_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_usb_pd_en" pos="3" rst="0x0">
          <comment>Software reset LDO_USB_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_vio33_pd_en" pos="2" rst="0x0">
          <comment>Software reset LDO_EMMCCORE_PD enable when global reset valid</comment>
        </bits>
      </reg>
      <reg name="free_timer_low" protect="rw">
        <comment>FREE_TIMER_LOW</comment>
        <bits access="r" name="timer_low" pos="15:0" rst="0x0">
          <comment>low 16 bit value of  free timer</comment>
        </bits>
      </reg>
      <reg name="free_timer_high" protect="rw">
        <comment>FREE_TIMER_HIGH</comment>
        <bits access="r" name="timer_high" pos="15:0" rst="0x0">
          <comment>high 16 bit value of free timer</comment>
        </bits>
      </reg>
      <reg name="reserved_reg1" protect="rw">
        <comment>RESERVED_REG1</comment>
        <bits access="rw" name="pm2_dcdc_core_slp_step_vol" pos="12:8" rst="0x0">
          <comment>voltage per step in PM2
00000:0mv
00001:1*3.125mv
00010:2*3.125mv
…..
11111:31*3.125mv</comment>
        </bits>
        <bits access="rw" name="pm1_ldo_mem_powersel" pos="6" rst="0x0">
          <comment>PM1 LDO VMEM power switch value:
1'b0:VMEM out
1'b1:VMEM short lp18,lp18 out</comment>
        </bits>
        <bits access="rw" name="ovlo_dbnc_en" pos="5" rst="0x0">
          <comment>OVLO dbnc enable:
0:  enable
1:  disable</comment>
        </bits>
        <bits access="rw" name="uvlo_dbnc_en" pos="4" rst="0x0">
          <comment>UVLO dbnc enable:
0:  enable
1:  disable</comment>
        </bits>
        <bits access="rw" name="pm1_power_det_en" pos="3" rst="0x0">
          <comment>PM1 power detect off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm1_bg_pd_en" pos="2" rst="0x0">
          <comment>PM1 bg_pd off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm1_osw_3m_en" pos="1" rst="0x0">
          <comment>PM1 OSW3M off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm1_dvdd_en" pos="0" rst="0x0">
          <comment>PM1 DVDD_PD off and DVDD_ISO hold enable:
0:disable
1:enable</comment>
        </bits>
      </reg>
      <reg name="reserved_reg2" protect="rw">
        <comment>RESERVED_REG2</comment>
        <bits access="rw" name="pm1_sleep_dly2" pos="15:12" rst="0x0">
          <comment>delay betwwen IO and VCORE when PM1 exits.(IO delay== {2'h0,pm1_sleep_dly2,2'h0})</comment>
        </bits>
        <bits access="rw" name="pm1_sleep_dly1" pos="11:8" rst="0x0">
          <comment>delay betwwen IO and VCORE when entering PM1.(VCORE delay== {2'h0,pm1_sleep_dly1,2'h0} + 1)</comment>
        </bits>
        <bits access="rw" name="ulp_cycle_sel1" pos="7:4" rst="0x0">
          <comment>if chip_sleep is low,ULP mode can use this value</comment>
        </bits>
        <bits access="rw" name="ulp_cycle_sel0" pos="3:0" rst="0x0">
          <comment>[3:0]:ULP cycle sel
4'h0:2;
4'h1:4;
4'h2:8;
…
4'hb:4096.</comment>
        </bits>
      </reg>
      <reg name="reserved_reg3" protect="rw">
        <comment>RESERVED_REG3</comment>
        <bits access="rw" name="ovlo_dbnc_time" pos="15:8" rst="0x0">
          <comment>UVLO dbnc time:
0:1ms
1:61us
2:91.5:us
3:122us
……
ff:7.8ms</comment>
        </bits>
        <bits access="rw" name="uvlo_dbnc_time" pos="7:0" rst="0x0">
          <comment>UVLO dbnc time:
0:2ms
1:61us
2:91.5:us
3:122us
……
ff:7.8ms</comment>
        </bits>
      </reg>
      <reg name="reserved_reg4" protect="rw">
        <comment>RESERVED_REG4</comment>
        <bits access="rw" name="pm2_sleep_dly2" pos="15:8" rst="0x0">
          <comment>delay betwwen IO and VCORE when PM1 exits.(IO delay== pm1_sleep_dly2)</comment>
        </bits>
        <bits access="rw" name="pm2_sleep_dly1" pos="7:0" rst="0x0">
          <comment>delay betwwen IO and VCORE when entering PM1.(VCORE delay== pm1_sleep_dly1 + 1)</comment>
        </bits>
      </reg>
      <reg name="reserved_reg5" protect="rw">
        <comment>RESERVED_REG5</comment>
        <bits access="rw" name="pm2_ldocp_pd_en" pos="14" rst="0x0">
          <comment>LDO CP power down enable in PM2
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_dcdc_core_slp_step_delay" pos="13:12" rst="0x0">
          <comment>delay between two steps in PM2
00:1*32k clock
01:2*32k clock
10:3*32k clock
11:4*32k clock</comment>
        </bits>
        <bits access="rw" name="pm2_dcdc_core_slp_step_num" pos="11:8" rst="0x0">
          <comment>step number in PM2</comment>
        </bits>
        <bits access="rw" name="pm2_power_det_en" pos="7" rst="0x0">
          <comment>PM2 power detect off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm2_slp_bg_pd_en" pos="6" rst="0x0">
          <comment>PM2 bg_pd off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm2_osw_3m_en" pos="5" rst="0x0">
          <comment>PM2 OSW3M off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm2_dvdd_en" pos="4" rst="0x0">
          <comment>PM2 DVDD_PD off and DVDD_ISO hold enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldousb_lp_en" pos="3" rst="0x0">
          <comment>LDO USB low power mode enable in PM2
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldomem_lp_en" pos="2" rst="0x0">
          <comment>LDO MEM low power mode enable in PM2
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldousb_pd_en" pos="1" rst="0x0">
          <comment>LDO USB power down enable in PM2
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldomem_pd_en" pos="0" rst="0x0">
          <comment>LDO MEM power down enable in PM2
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="reserved_reg6" protect="rw">
        <comment>RESERVED_REG6</comment>
        <bits access="rw" name="pm2_en" pos="0" rst="0x0">
          <comment>select the configuration used under PM2
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="pwr_wr_prot_value" protect="rw">
        <comment>PWR_WR_PROT_VALUE</comment>
        <bits access="r" name="pwr_wr_prot" pos="15" rst="0x0">
          <comment>All power which default on write protect bit status.
When mcu_wr_prot_value==16'h6e7f,
 the bit is &quot;1&quot;,else &quot;0&quot;</comment>
        </bits>
        <bits access="w" name="pwr_wr_prot_value" pos="14:0" rst="0x0">
          <comment>Arch_en write protect value</comment>
        </bits>
      </reg>
      <reg name="vol_tune_ctrl_core" protect="rw">
        <comment>VOL_TUNE_CTRL_CORE</comment>
        <bits access="rw" name="core_clk_sel" pos="14" rst="0x0">
          <comment>clock source for CORE DVFS
0: clock 26M
1: clock 32K</comment>
        </bits>
        <bits access="rw" name="core_step_delay" pos="13:12" rst="0x0">
          <comment>delay between two steps
00:1*32k clock or 2us in 26M
01:2*32k clock or 4us in 26M
10:3*32k clock or 8us in 26M
11:4*32k clock or 16us in 26M</comment>
        </bits>
        <bits access="rw" name="core_step_num" pos="11:8" rst="0x0">
          <comment>step number</comment>
        </bits>
        <bits access="rw" name="core_step_vol" pos="7:3" rst="0x0">
          <comment>DVFS voltage per step
00000:0mv
00001:1*3.125mv
00010:2*3.125mv
…..
11111:31*3.125mv</comment>
        </bits>
        <bits access="rc" name="core_vol_tune_start" pos="2" rst="0x0">
          <comment>voltage tune start bit</comment>
        </bits>
        <bits access="r" name="core_vol_tune_flag" pos="1" rst="0x0">
          <comment>voltage tune flag
0:done
1:on going</comment>
        </bits>
        <bits access="rw" name="core_vol_tune_en" pos="0" rst="0x0">
          <comment>voltage tune enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="smpl_ctrl1" protect="rw">
        <comment>SMPL_CTRL1</comment>
        <bits access="r" name="smpl_pwr_on_flag" pos="15" rst="0x0">
          <comment>Set once SMPL timer not expired.</comment>
        </bits>
        <bits access="r" name="smpl_mode_wr_ack_flag" pos="14" rst="0x0">
          <comment>Set once SMPL mode write finish</comment>
        </bits>
        <bits access="rc" name="smpl_pwr_on_flag_clr" pos="13" rst="0x0">
          <comment>Clear SMPL_PWR_ON_FLAG</comment>
        </bits>
        <bits access="rc" name="smpl_mode_wr_ack_flag_clr" pos="12" rst="0x0">
          <comment>Clear SMPL_MODE_WR_ACK</comment>
        </bits>
        <bits access="r" name="smpl_pwr_on_set" pos="11" rst="0x0">
          <comment>Set once SMPL timer not expired,</comment>
        </bits>
        <bits access="r" name="smpl_en" pos="0" rst="0x0">
          <comment>SMPL enable indication</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="power_pd_sw0_set" protect="rw"/>
      <hole size="96"/>
      <reg name="power_pd_sw0_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="power_pd_sw1_set" protect="rw"/>
      <hole size="96"/>
      <reg name="power_pd_sw1_clr" protect="rw"/>
    </module>
    <var name="REG_PMIC_RTC_ANA_SET_OFFSET" value="0x100"/>
    <var name="REG_PMIC_RTC_ANA_CLR_OFFSET" value="0x110"/>
    <instance address="0x51108800" name="PMIC_RTC_ANA" type="PMIC_RTC_ANA"/>
  </archive>
  <archive relative="pmic_wdt.xml">
    <module category="System" name="PMIC_WDT">
      <reg name="wdg_load_low" protect="rw">
        <comment>low 16 bits of watchdog value low 16 bits of watchdog value</comment>
        <bits access="rw" name="wdg_ld_value_low" pos="15:0" rst="0xffff">
          <comment>wdg_ld_value_low: low 16 bit of watchdog timer load value
wdg_ld_value_high: high 16 bit of watchdog timer load value
wdg_ld_value_higher: higher 16 bit of watchdog timer load value
wdg_ld_value_low, wdg_ld_value_high and wdg_ld_value_higher  are used together.Software should write wdg_ld_value_higher firstly, and then write wdg_ld_value_high, last write wdg_ld_value_low, because writing wdg_ld_value_low can trig loading both wdg_ld_value_low and wdg_ld_value_high to watchdog counter, and writing wdg_ld_value_high cannot trig this event. So software must guarantee wdg_ld_value_high is ready when writing wdg_ld_value_low.
In reset mode, software should load new value before timer decrease to 0. In interrupt mode, this value is counting start number. The default value is about 8 seconds.</comment>
        </bits>
      </reg>
      <reg name="wdg_load_high" protect="rw">
        <comment>high 16 bits of watchdog value high 16 bits of watchdog value</comment>
        <bits access="rw" name="wdg_ld_value_high" pos="15:0" rst="0x3">
          <comment>See wdg_ld_value_low description.</comment>
        </bits>
      </reg>
      <reg name="wdg_ctrl" protect="rw">
        <comment>watchdog control watchdog control</comment>
        <bits access="rw" name="wdg_rst_en" pos="3" rst="0x0">
          <comment>Watchdog reset enable bit
0: reset is disabled
1: reset is enabled
For reset mode: wdg_rst_en =1, wdg_irq_en=0.
For interrupt mode: wdg_rst_en =0, wdg_irq_en=1.
For combined mode: wdg_rst_en =1, wdg_irq_en=1.
Reset can't be triggered before wdg_rst_raw is cleared.</comment>
        </bits>
        <bits access="rw" name="wdg_new" pos="2" rst="0x0">
          <comment>Watchdog version
0: watchdog use old behavior, this is for backward compatibility
1: watchdog uses new behavior, such as multiple loads without checking busy bit, only need to read once to get timer counter value.</comment>
        </bits>
        <bits access="rw" name="wdg_open" pos="1" rst="0x0">
          <comment>Watchdog counter open:
0: counter stops.
1: counter runs.</comment>
        </bits>
        <bits access="rw" name="wdg_irq_en" pos="0" rst="0x0">
          <comment>Watchdog interrupt enable bit
0: interrupt is disabled
1: interrupt is enabled
For reset mode: wdg_rst_en =1, wdg_irq_en=0.
For interrupt mode: wdg_rst_en =0, wdg_irq_en=1.
For combined mode: wdg_rst_en =1, wdg_irq_en=1.</comment>
        </bits>
      </reg>
      <reg name="wdg_int_clr" protect="rw">
        <comment>watchdog interrupt clear watchdog interrupt clear</comment>
        <bits access="w" name="wdg_rst_clr" pos="3" rst="0x0">
          <comment>Watchdog reset clear
Write 1 to this bit to clear reset
Read this bit always get 0.</comment>
        </bits>
        <bits access="w" name="wdg_irq_clr" pos="0" rst="0x0">
          <comment>Watchdog interrupt clear
Write 1 to this bit to clear interrupt
Read this bit always get 0.</comment>
        </bits>
      </reg>
      <reg name="wdg_int_raw" protect="rw">
        <comment>watchdog interrupt raw status watchdog interrupt raw status</comment>
        <bits access="r" name="apb_wr_ld_busy" pos="4" rst="0x0">
          <comment>Watchdog load busy status
0: Watchdog is ready for new loading
1: Last loading is not completed
Software must not load new value when this bit is busy, that is, this bit should be checked before any new loading.
This bit is set after a new loading, and lasts two or three RTC clock cycles, about 60us - 92us.</comment>
        </bits>
        <bits access="r" name="wdg_rst_raw" pos="3" rst="0x0">
          <comment>Watchdog reset  raw status. Watchdog reset cannot clear this raw status, Also it can be used to judge if or not system rebooting comes from watchdog reset. Write wdg_rst_clr can clear this raw status.</comment>
        </bits>
        <bits access="r" name="wdg_irq_raw" pos="0" rst="0x0">
          <comment>Watchdog interrupt raw status. Watchdog reset cannot clear this raw status. Write wdg_irq_clr can clear this raw status.</comment>
        </bits>
      </reg>
      <reg name="wdg_irq_mask" protect="rw">
        <comment>watchdog interrupt mask status watchdog interrupt mask status</comment>
        <bits access="r" name="wdg_irq_mask" pos="0" rst="0x0">
          <comment>Watchdog interrupt masked status</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_low" protect="rw">
        <comment>low 16 bits of watchdog counter value low 16 bits of watchdog counter value</comment>
        <bits access="r" name="wdg_cnt_low" pos="15:0" rst="0xffff">
          <comment>wdg_cnt_low: Low 16 bit of watchdog timer counter value.
wdg_cnt_high: Mid 16 bit of watchdog timer counter value.
wdg_cnt_higher: High 16 bit of watchdog timer counter value.
wdg_cnt_low, wdg_cnt_mid and wdg_cnt_high  are used together.
This read-only register indicates current counter value.
It’s not recommended to read this register in normal usage.
Because the counter is in different clock domain with APB, software needs use double-reading method to read this value, like system timer.</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_high" protect="rw">
        <comment>high 16 bits of watchdog counter value high 16 bits of watchdog counter value</comment>
        <bits access="r" name="wdg_cnt_high" pos="15:0" rst="0xffff">
          <comment>See wdg_cnt_low description.</comment>
        </bits>
      </reg>
      <reg name="wdg_lock" protect="rw">
        <comment>watchdog lock control watchdog lock control</comment>
        <bits access="rw" name="wdg_lock" pos="15:0" rst="0x0">
          <comment>Watchdog lock control
Write 16’hE551 to this register to unlock watchdog.
Write other value to this register to lock watchdog
If reading this register, bit-0 is lock status, and other bits are reserved.
If watchdog is locked, all control registers cannot be written by software.</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_read_low" protect="rw">
        <comment>low 16 bits of watchdog counter value for read low 16 bits of watchdog counter value for read</comment>
        <bits access="r" name="wdg_cnt_read_low" pos="15:0" rst="0xffff">
          <comment>wdg_cnt_read_low: Low 16 bit of watchdog timer counter value for read.
wdg_cnt_read_high: High 16 bit of watchdog timer counter value for read.
wdg_cnt_read_higher: Higher 16 bit of watchdog timer counter value for read.
wdg_cnt_read_low and wdg_cnt_read_high  are used together.
This read-only register indicates current counter value.
Read once can get watchdog counter value. No need to double read this reg.
Refer to timer’s TIMER0_CNT_RD or TIMER1_CNT_RD</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_read_high" protect="rw">
        <comment>high 16 bits of watchdog counter value for read high 16 bits of watchdog counter value for read</comment>
        <bits access="r" name="wdg_cnt_read_high" pos="15:0" rst="0xffff">
          <comment>Refer to  wdg_cnt_read_low</comment>
        </bits>
      </reg>
      <reg name="wdg_irq_value_low" protect="rw">
        <comment>low 16 bits of watchdog irq value low 16 bits of watchdog irq value</comment>
        <bits access="rw" name="wdg_irq_value_low" pos="15:0" rst="0x0">
          <comment>wdg_ irq_value_low: Low 16 bit of watchdog irqvalue.
wdg_ irq_value_high: High 16 bit of watchdog irqvalue.
wdg_ irq_value_higher: Higher 16 bit of watchdog irqvalue.
wdg_ irq_value_low and wdg_ irq_value_high  are used together.
It’s useful in interrupt mode and combined mode. When  wdg_cnt equal watchdog irqvalue, an interrupt is generated.
Default value of watchdog irqvalue is 48’0000_h0003_0000, corresponds to 6 seconds, which means reset will occur after irq is 1 for 6 seconds.</comment>
        </bits>
      </reg>
      <reg name="wdg_irq_value_high" protect="rw">
        <comment>high 16 bits of watchdog irq value high 16 bits of watchdog irq value</comment>
        <bits access="rw" name="wdg_irq_value_high" pos="15:0" rst="0x3">
          <comment>wdg_ irq_value_low: Low  16 bit of watchdog irq value.
wdg_ irq_value_high: High  16 bit of watchdog irq value.
wdg_ irq_value_higher: Higher 16 bit of watchdog irq value.
wdg_ irq_value_low, wdg_irq_value_mid and wdg_ irqvalue_high  are used together, which means reset will occur after irq is 1 for 6 seconds.
It’s useful in interrupt mode and combined mode. When  wdg_cnt equal watchdog irq value, an interrupt is generated.
Default value of watchdog irqvalue is 48’h0000_0003_0000, corresponds to 6 seconds.</comment>
        </bits>
      </reg>
      <reg name="wdg_load_higher" protect="rw">
        <comment>higher 16 bits of watchdog value higher 16 bits of watchdog value</comment>
        <bits access="rw" name="wdg_ld_value_higher" pos="15:0" rst="0x0">
          <comment>See wdg_ld_value_low description.</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_higher" protect="rw">
        <comment>higher 16 bits of watchdog counter value higher 16 bits of watchdog counter value</comment>
        <bits access="r" name="wdg_cnt_higher" pos="15:0" rst="0xffff">
          <comment>See wdg_cnt_low description.</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_read_higher" protect="rw">
        <comment>higher 16 bits of watchdog counter value for read higher 16 bits of watchdog counter value for read</comment>
        <bits access="r" name="wdg_cnt_read_higher" pos="15:0" rst="0xffff">
          <comment>Refer to  wdg_cnt_read_low</comment>
        </bits>
      </reg>
      <reg name="wdg_irq_value_higher" protect="rw">
        <comment>higher 16 bits of watchdog irq value higher 16 bits of watchdog irq value</comment>
        <bits access="rw" name="wdg_irq_value_higher" pos="15:0" rst="0x0">
          <comment>wdg_ irq_value_low: Low  16 bit of watchdog irq value.
wdg_ irq_value_high: High  16 bit of watchdog irq value.
wdg_ irq_value_higher: Higher 16 bit of watchdog irq value.
wdg_ irq_value_low, wdg_irq_value_high and wdg_ irq_value_higher  are used together, which means reset will occur after irq is 1 for 6 seconds.
It’s useful in interrupt mode and combined mode. When  wdg_cnt equal watchdog irq value, an interrupt is generated.
Default value of watchdog irqvalue is 48’h0000_0003_0000, corresponds to 6 seconds.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108480" name="PMIC_WDT" type="PMIC_WDT"/>
  </archive>
  <archive relative="pmic_psm.xml">
    <module category="System" name="PMIC_PSM">
      <reg name="psm_reg_wr_protect" protect="rw">
        <bits access="rw" name="psm_reg_wr" pos="15:0" rst="0x0">
          <comment>if write 0x454e to enable write psm reg,  readback only [15] is high</comment>
        </bits>
      </reg>
      <reg name="psm_32k_cal_th" protect="rw">
        <bits access="rw" name="rc_32k_cal_pre_th" pos="11:8" rst="0x8">
          <comment>psm calibration pre time. The time is from pull DCXO high to OSC 26M stable. unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rc_32k_cal_cnt_n" pos="3:0" rst="0x7">
          <comment>psm calibration time 1s/(2^(16-rc_32k_cal_cnt_n))/( rc_32k_cal_cnt_p+1)</comment>
        </bits>
      </reg>
      <reg name="psm_26m_cal_dn_th" protect="rw">
        <bits access="rw" name="rc_26m_cal_cnt_dn_th" pos="15:0" rst="0x0">
          <comment>psm 26m calibration value update down threshold.
Value = (1/2)*26*10^6/(2^(16-rc_32k_cal_cnt_n)) /(2^9)</comment>
        </bits>
      </reg>
      <reg name="psm_26m_cal_up_th" protect="rw">
        <bits access="rw" name="rc_26m_cal_cnt_up_th" pos="15:0" rst="0x0">
          <comment>psm 26m calibration value update up threshold
Value = (3/2)*26*10^6/(2^(16-rc_32k_cal_cnt_n)) /(2^9)</comment>
        </bits>
      </reg>
      <reg name="psm_ctrl" protect="rw">
        <bits access="rw" name="rtc_32k_clk_sel" pos="15" rst="0x0">
          <comment>1'b1: rtc use psm cal 32K clock in 32K less mode,1'b0:rtc use RC 32K clock in 32K less mode</comment>
        </bits>
        <bits access="rw" name="psm_cal_en" pos="12" rst="0x0">
          <comment>enable psm cal</comment>
        </bits>
        <bits access="rw" name="psm_status_clr" pos="11" rst="0x0">
          <comment>clear psm int status</comment>
        </bits>
        <bits access="rw" name="psm_cnt_en" pos="10" rst="0x0">
          <comment>enble psm timer cnt</comment>
        </bits>
        <bits access="rw" name="psm_cnt_update" pos="9" rst="0x0">
          <comment>posedge to update psm cnt value</comment>
        </bits>
        <bits access="rw" name="psm_software_reset" pos="8" rst="0x0">
          <comment>software reset psm module, auto clear</comment>
        </bits>
        <bits access="rw" name="psm_cnt_alm_en" pos="7" rst="0x1">
          <comment>enable psm timer to wake up sys</comment>
        </bits>
        <bits access="rw" name="psm_cnt_alarm_en" pos="6" rst="0x0">
          <comment>enable psm alarm function</comment>
        </bits>
        <bits access="rw" name="charger_pwr_en" pos="5" rst="0x0">
          <comment>enable charger to power on sys</comment>
        </bits>
        <bits access="rw" name="pbint2_pwr_en" pos="4" rst="0x0">
          <comment>enable pbint2 to power on sys</comment>
        </bits>
        <bits access="rw" name="pbint1_pwr_en" pos="3" rst="0x0">
          <comment>enable pbint1 to power on sys</comment>
        </bits>
        <bits access="rw" name="ext_int_pwr_en" pos="2" rst="0x0">
          <comment>enable ext int to power on sys</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_on_timeout_en" pos="1" rst="0x0">
          <comment>enable rtc power on time out detect</comment>
        </bits>
        <bits access="rw" name="psm_en" pos="0" rst="0x0">
          <comment>enable psm fsm</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_off_th1" protect="rw">
        <bits access="rw" name="rtc_pwr_off_hold_th" pos="15:8" rst="0x4">
          <comment>The time to hold rtc ISO in power off rtc state, (clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_off_clk_en_th" pos="7:0" rst="0x2">
          <comment>The time to disable rtc clk  in power off rtc state, unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_off_th2" protect="rw">
        <bits access="rw" name="rtc_pwr_off_pd_th" pos="15:8" rst="0x8">
          <comment>The time to hold rtc ISO in power off rtc state, (clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_off_rstn_th" pos="7:0" rst="0x6">
          <comment>The time to reset rtc in power off rtc state, unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_off_th3" protect="rw">
        <bits access="rw" name="rtc_pwr_off_done_th" pos="7:0" rst="0xa">
          <comment>The time to power off rtc done  in power off rtc state, unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_on_th1" protect="rw">
        <bits access="rw" name="rtc_pwr_on_rstn_th" pos="15:8" rst="0x28">
          <comment>The time to release reset in power on rtc state, unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_on_pd_th" pos="7:0" rst="0x1">
          <comment>The time to power on rtc , unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_on_th2" protect="rw">
        <bits access="rw" name="rtc_pwr_on_clk_en_th" pos="15:8" rst="0x3">
          <comment>The time to clock enable in power on rtc state, unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_on_hold_th" pos="7:0" rst="0x2">
          <comment>The time to release hold ISO in power on rtc state, unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_on_th3" protect="rw">
        <bits access="rw" name="rtc_pwr_on_timeout_th" pos="15:8" rst="0xfa">
          <comment>The time to mark power on timeout in power on rtc state, unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_on_done_th" pos="7:0" rst="0xff">
          <comment>The time to power on rtc done , unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="psm_cnt_l_th" protect="rw">
        <bits access="rw" name="psm_cnt_th_15_0" pos="15:0" rst="0x7e40">
          <comment>The low 16 bits threshold of psm time , unit is 10*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="psm_cnt_h_th" protect="rw">
        <bits access="rw" name="psm_cnt_th_31_16" pos="15:0" rst="0x5">
          <comment>The high 16 bits threshold of psm time , unit is 10ms</comment>
        </bits>
      </reg>
      <reg name="psm_alarm_cnt_l_th" protect="rw">
        <bits access="rw" name="psm_alarm_cnt_th_15_0" pos="15:0" rst="0xffff">
          <comment>The low 16 bits threshold of psm alarm time , unit is 10*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="psm_alarm_cnt_h_th" protect="rw">
        <bits access="rw" name="psm_alarm_cnt_th_31_16" pos="15:0" rst="0x0">
          <comment>The high 16 bits threshold of psm alarm time</comment>
        </bits>
      </reg>
      <reg name="psm_cnt_interval_th" protect="rw">
        <bits access="rw" name="psm_cnt_interval_th_15_0" pos="15:0" rst="0x3c">
          <comment>The threshold of psm calibration interval , unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="psm_cnt_interval_phase" protect="rw">
        <bits access="rw" name="psm_cnt_interval_phase_15_0" pos="15:0" rst="0x3c">
          <comment>The threshold of psm calibration interval , unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="dcxo" protect="rw">
        <bits access="rw" name="psm_reg_dbnc_sel" pos="15" rst="0x0">
          <comment>0：sel clk_cal_1k；1：sel clk_rc_64k or xtal32k</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_lp_en" pos="14" rst="0x1">
          <comment>0：disable ；1：enable</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_discharge_en" pos="13" rst="0x1">
          <comment>LDO_DCXO discharge en</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_shpt_en" pos="12" rst="0x1">
          <comment>LDO_DCXO short protect EN:
“0” is disable
“1” is enable(default)</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_stb" pos="11:10" rst="0x0">
          <comment>LDO_DCXO compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_rz_adj" pos="9" rst="0x1">
          <comment>compensation resistor  adjust</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_cl_adj" pos="8:6" rst="0x3">
          <comment>LDO_DCXO current limit threshold adjust , 111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_v" pos="5:0" rst="0x7">
          <comment>DCXO LDO output voltage select, 000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
      </reg>
      <reg name="psm_rc_clk_div" protect="rw">
        <bits access="rw" name="rc_32k_cal_cnt_p" pos="11:8" rst="0x0">
          <comment>Psm calibration divider,
1）when rc_64k calib(clude xtal_32k calib use rc_64k por on first time)，it is calculated with rc_32k_cal_cnt_n – log2(clk_cal_64k_div_th+1)；e.g: I.  clk_cal_1k=128Hz, cnt_p=0x4,cnt_n=0x8，div_th=0xf；II.  clk_cal_1k=1KHz, cnt_p=0x4,cnt_n=0x5，div_th=0x1
2）when 32k_xtal calib，it is calculated with rc_32k_cal_cnt_n-log2(clk_cal_64k_div_th+1)-1；e.g: I. clk_cal_1k=128Hz, cnt_p=0x4,cnt_n=0x8，div_th=0x7；II. clk_cal_1k=1KHz, cnt_p=0x4,cnt_n=0x5，div_th=0x0
3）when 32k_xtal no calib, e.g: I. clk_cal_1k=128Hz,div_th=4'hf； II. clk_cal_1k=1KHz,div_th=4'h0</comment>
        </bits>
        <bits access="rw" name="clk_cal_64k_div_th" pos="7:4" rst="0x0">
          <comment>psm rc 64K divider, the input RC clock is divider to CLK_64K/( clk_cal_64k_div_th+1)</comment>
        </bits>
        <bits access="rw" name="wdg_rst_clk_sel_en" pos="0" rst="0x0">
          <comment>Enable watchdog power on chip by internal RC clock</comment>
        </bits>
      </reg>
      <reg name="reserved_2" protect="rw">
        </reg>
      <reg name="reserved_3" protect="rw">
        </reg>
      <reg name="reserved_4" protect="rw">
        </reg>
      <reg name="reserved_5" protect="rw">
        </reg>
      <reg name="reserved_6" protect="rw">
        </reg>
      <reg name="psm_cnt_update_l_value" protect="rw">
        <bits access="r" name="psm_cnt_update_value_15_0" pos="15:0" rst="0x0">
          <comment>Psm cnt updated low 16 bits value, the step of read this value is :
(1)enable psm_cnt_update,
(2)wait till psm_cnt_update_vld ==1.(psm_fsm_status[6])</comment>
        </bits>
      </reg>
      <reg name="psm_cnt_update_h_value" protect="rw">
        <bits access="r" name="psm_cnt_update_value_31_16" pos="15:0" rst="0x0">
          <comment>Psm cnt updated high 16 bits value</comment>
        </bits>
      </reg>
      <reg name="psm_status" protect="rw">
        <bits access="rw" name="alarm_req_int_mask" pos="13" rst="0x0"/>
        <bits access="rw" name="psm_req_int_mask" pos="12" rst="0x0"/>
        <bits access="rw" name="charger_int_mask" pos="11" rst="0x0"/>
        <bits access="rw" name="pbint2_int_mask" pos="10" rst="0x0"/>
        <bits access="rw" name="pbint1_int_mask" pos="9" rst="0x0"/>
        <bits access="rw" name="ext_int_mask" pos="8" rst="0x0"/>
        <bits access="r" name="psm_cnt_update_vld" pos="6" rst="0x0">
          <comment>psm cnt updated valid</comment>
        </bits>
        <bits access="r" name="alarm_req_int" pos="5" rst="0x0">
          <comment>when psm_cnt_alarm_en==1, then if alarm cnt get psm_alarm_cnt_th, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
        <bits access="r" name="psm_req_int" pos="4" rst="0x0">
          <comment>when psm_cnt_en==1, then if psm cnt get psm_cnt_th, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
        <bits access="r" name="charger_int" pos="3" rst="0x0">
          <comment>when psm_cnt_alarm_en==1, then if alarm cnt get psm_alarm_cnt_th, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
        <bits access="r" name="pbint2_int" pos="2" rst="0x0">
          <comment>when pbint2_pwr_en==1, then if pbint2 is low, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
        <bits access="r" name="pbint1_int" pos="1" rst="0x0">
          <comment>when pbint1_pwr_en==1, then if pbint1 is low, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
        <bits access="r" name="ext_int" pos="0" rst="0x0">
          <comment>when ext_int_en==1, then if  ext_int is high, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
      </reg>
      <reg name="psm_fsm_status" protect="rw">
        <bits access="r" name="psm_fsm" pos="14:0" rst="0x0">
          <comment>Only debug use</comment>
        </bits>
      </reg>
      <reg name="psm_cal_cnt" protect="rw">
        <bits access="r" name="psm_cal_cnt" pos="15:0" rst="0xc6">
          <comment>We can use this value to calculate the RC 64K clock real frequency. Rc_64k=( clk_cal_64k_div_th+1)*(2^ rc_32k_cal_cnt_p)*26*10^6/ (psm_cal_cnt*2^9)</comment>
        </bits>
      </reg>
      <reg name="pbint_1s_thd" protect="rw">
        <bits access="rw" name="pbint_1s_thd" pos="11:0" rst="0x760">
          <comment>PBINT or CHGR_INT dbs time,0.244ms step</comment>
        </bits>
      </reg>
      <reg name="por_timer_thd" protect="rw">
        <bits access="rw" name="bg_pd_timer_thd" pos="15:10" rst="0x0">
          <comment>bg pd power on timer,0.244ms step</comment>
        </bits>
        <bits access="rw" name="ext_rst_timer_thd" pos="9:0" rst="0x17">
          <comment>ext rst_n release timer,0.244ms step</comment>
        </bits>
      </reg>
      <reg name="ext_xtl_dbs_timer" protect="rw">
        <bits access="rw" name="ext_xtl_dbs_timer1" pos="15:8" rst="0x2">
          <comment>ext xtl0_en~ext_xtl3_en dbs time，32kHz</comment>
        </bits>
        <bits access="rw" name="ext_xtl_dbs_timer0" pos="7:0" rst="0x2">
          <comment>ext xtl0_en~ext_xtl3_en dbs time，32kHz</comment>
        </bits>
      </reg>
      <reg name="ext_xtl_en_hl" protect="rw">
        <bits access="rw" name="ext_xtl_en_hl" pos="7:0" rst="0xff">
          <comment>0~7:ext_xtl_en0~7 high or low enable to exit psm，0：low vld，1：high vld</comment>
        </bits>
      </reg>
      <reg name="clk_32k_xtal_calibra_sel" protect="rw">
        <bits access="rw" name="psm_reg_xtal32k_pon" pos="1" rst="0x1">
          <comment>0：disable xtal32k clk；1：enable xtal32k</comment>
        </bits>
        <bits access="rw" name="clk_32k_xtal_calibra_sel" pos="0" rst="0x1">
          <comment>0:clk_32k_xtal not calibra;1:clk_32k_xtal or rc_64k calibra</comment>
        </bits>
      </reg>
      <reg name="xtal_por_1st_clk_sel" protect="rw">
        <bits access="r" name="xtl7" pos="15" rst="0x0">
          <comment>xtl7_flag</comment>
        </bits>
        <bits access="r" name="xtl6" pos="14" rst="0x0">
          <comment>xtl6_flag</comment>
        </bits>
        <bits access="r" name="xtl5" pos="13" rst="0x0">
          <comment>xtl5_flag</comment>
        </bits>
        <bits access="r" name="xtl4" pos="12" rst="0x0">
          <comment>xtl4_flag</comment>
        </bits>
        <bits access="r" name="xtl3" pos="11" rst="0x0">
          <comment>xtl3_flag</comment>
        </bits>
        <bits access="r" name="xtl2" pos="10" rst="0x0">
          <comment>xtl2_flag</comment>
        </bits>
        <bits access="r" name="xtl1" pos="9" rst="0x0">
          <comment>xtl1_flag</comment>
        </bits>
        <bits access="r" name="xtl0" pos="8" rst="0x0">
          <comment>xtl0_flag</comment>
        </bits>
        <bits access="rw" name="xtal_por_1st_clk_sel" pos="0" rst="0x1">
          <comment>0:xtal_32k por on use xtal_32k,xtal not calibra must configure 0 ;1:xtal_32k por on use rc_64k</comment>
        </bits>
      </reg>
      <reg name="reserved23" protect="rw">
        <bits access="rw" name="reserved23" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved24" protect="rw">
        <bits access="rw" name="reserved24" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved25" protect="rw">
        <bits access="rw" name="reserved25" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved26" protect="rw">
        <bits access="rw" name="reserved26" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved27" protect="rw">
        <bits access="rw" name="reserved27" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved28" protect="rw">
        <bits access="rw" name="reserved28" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved29" protect="rw">
        <bits access="rw" name="reserved29" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rtc_reserved1" protect="rw">
        <bits access="rw" name="rtc_reserved1" pos="15:8" rst="0xf0"/>
        <bits access="rw" name="pbint_pullh_enb" pos="2" rst="0x0"/>
        <bits access="rw" name="vbatlow_en" pos="1" rst="0x1"/>
        <bits access="rw" name="uvlo_en" pos="0" rst="0x1"/>
      </reg>
      <reg name="rg_rtc_vosel" protect="rw">
        <bits access="rw" name="rg_rtc_vosel" pos="10:8" rst="0x4"/>
        <bits access="rw" name="rg_vbatbk_vosel" pos="2:0" rst="0x4"/>
      </reg>
    </module>
    <instance address="0x51108700" name="PMIC_PSM" type="PMIC_PSM"/>
  </archive>
  <archive relative="pmic_int.xml">
    <module category="System" name="PMIC_INT">
      <reg name="int_mask_status" protect="rw">
        <comment>INT_MASK_STATUS</comment>
        <bits access="r" name="psm_int_mask_status" pos="8" rst="0x0"/>
        <bits access="r" name="cal_int_mask_status" pos="7" rst="0x0"/>
        <bits access="r" name="trm_int_mask_status" pos="6" rst="0x0"/>
        <bits access="r" name="eic_int_mask_status" pos="4" rst="0x0"/>
        <bits access="r" name="wdg_int_mask_status" pos="2" rst="0x0"/>
        <bits access="r" name="rtc_int_mask_status" pos="1" rst="0x0"/>
        <bits access="r" name="adc_int_mask_status" pos="0" rst="0x0"/>
      </reg>
      <reg name="int_raw_status" protect="rw">
        <comment>INT_RAW_STATUS</comment>
        <bits access="r" name="psm_int_raw_status" pos="8" rst="0x0"/>
        <bits access="r" name="cal_int_raw_status" pos="7" rst="0x0"/>
        <bits access="r" name="trm_int_raw_status" pos="6" rst="0x0"/>
        <bits access="r" name="eic_int_raw_status" pos="4" rst="0x0"/>
        <bits access="r" name="wdg_int_raw_status" pos="2" rst="0x0"/>
        <bits access="r" name="rtc_int_raw_status" pos="1" rst="0x0"/>
        <bits access="r" name="adc_int_raw_status" pos="0" rst="0x0"/>
      </reg>
      <reg name="int_en" protect="rw">
        <comment>INT_EN</comment>
        <bits access="rw" name="psm_int_en" pos="8" rst="0x1"/>
        <bits access="rw" name="cal_int_en" pos="7" rst="0x1"/>
        <bits access="rw" name="trm_int_en" pos="6" rst="0x1"/>
        <bits access="rw" name="eic_int_en" pos="4" rst="0x1"/>
        <bits access="rw" name="wdg_int_en" pos="2" rst="0x1"/>
        <bits access="rw" name="rtc_int_en" pos="1" rst="0x1"/>
        <bits access="rw" name="adc_int_en" pos="0" rst="0x1"/>
      </reg>
    </module>
    <instance address="0x51108400" name="PMIC_INT" type="PMIC_INT"/>
  </archive>
  <archive relative="pmic_pin_reg.xml">
    <module category="System" name="PMIC_PIN_REG">
      <reg name="pin_adi_sclk" protect="rw">
        <comment>PIN_ADI_SCLK</comment>
        <bits access="rw" name="adi_sclk_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="adi_sclk_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="adi_sclk_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="adi_sclk_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="pin_adi_d" protect="rw">
        <comment>PIN_ADI_D</comment>
        <bits access="rw" name="adi_d_bsr_drv" pos="9:8" rst="0x3"/>
        <bits access="rw" name="adi_d_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="adi_d_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="adi_d_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="adi_d_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="adi_d_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="adi_d_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="adi_d_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="pin_ext_rst_b" protect="rw">
        <comment>PIN_EXT_RST_B</comment>
        <bits access="rw" name="ext_rst_b_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_rst_b_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_slp_oe" pos="0" rst="0x1"/>
      </reg>
      <reg name="pin_ana_int" protect="rw">
        <comment>PIN_ANA_INT</comment>
        <bits access="rw" name="adi_sclk_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="adi_sclk_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="adi_sclk_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="adi_sclk_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_oe" pos="0" rst="0x1"/>
      </reg>
      <reg name="pin_chip_sellp" protect="rw">
        <comment>PIN_CHIP_SELLP</comment>
        <bits access="rw" name="chip_sleep_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="chip_sleep_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="chip_sleep_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="chip_sleep_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="chip_sleep_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="chip_sleep_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="chip_sleep_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="chip_sleep_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="pin_clk_32k" protect="rw">
        <comment>PIN_CLK_32K</comment>
        <bits access="rw" name="clk_32k_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="clk_32k_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="clk_32k_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="clk_32k_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="clk_32k_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="clk_32k_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="clk_32k_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="clk_32k_slp_oe" pos="0" rst="0x1"/>
      </reg>
      <reg name="pin_ptesto" protect="rw">
        <comment>PIN_PTESTO</comment>
        <bits access="rw" name="ptesto_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ptesto_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ptesto_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="ptesto_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ptesto_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ptesto_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="ptesto_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="ptesto_slp_oe" pos="0" rst="0x1"/>
      </reg>
      <reg name="pin_clk26m" protect="rw">
        <comment>PIN_CLK26M</comment>
        <bits access="rw" name="clk26m_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="clk26m_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="clk26m_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="clk26m_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="clk26m_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="clk26m_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="clk26m_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="clk26m_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en0" protect="rw">
        <comment>EXT_XTL_EN0</comment>
        <bits access="rw" name="ext_xtl_en0_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en0_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en0_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en0_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en0_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en0_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en0_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en0_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en1" protect="rw">
        <comment>EXT_XTL_EN1</comment>
        <bits access="rw" name="ext_xtl_en1_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en1_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en1_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en1_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en1_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en1_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en1_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en1_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en2" protect="rw">
        <comment>EXT_XTL_EN2</comment>
        <bits access="rw" name="ext_xtl_en2_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en2_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en2_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en2_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en2_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en2_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en2_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en2_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en3" protect="rw">
        <comment>EXT_XTL_EN3</comment>
        <bits access="rw" name="ext_xtl_en3_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en3_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en3_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en3_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en3_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en3_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en3_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en3_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en4" protect="rw">
        <comment>EXT_XTL_EN4</comment>
        <bits access="rw" name="ext_xtl_en4_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en4_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en4_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en4_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en4_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en4_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en4_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en4_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en5" protect="rw">
        <comment>EXT_XTL_EN5</comment>
        <bits access="rw" name="ext_xtl_en5_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en5_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en5_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en5_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en5_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en5_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en5_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en5_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en6" protect="rw">
        <comment>EXT_XTL_EN6</comment>
        <bits access="rw" name="ext_xtl_en6_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en6_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en6_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en6_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en6_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en6_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en6_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en6_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en7" protect="rw">
        <comment>EXT_XTL_EN7</comment>
        <bits access="rw" name="ext_xtl_en7_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en7_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en7_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en7_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en7_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en7_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en7_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en7_slp_oe" pos="0" rst="0x0"/>
      </reg>
    </module>
    <instance address="0x511087c0" name="PMIC_PIN_REG" type="PMIC_PIN_REG"/>
  </archive>
  <archive relative="adi_mst.xml">
    <module category="Periph" name="ADI_MST">
      <reg name="adi_version" protect="rw">
        <bits access="rw" name="adi_version_low" pos="3:0" rst="0">
          <comment>adi low bits version.</comment>
        </bits>
        <bits access="r" name="adi_version_high" pos="15:4" rst="0x10">
          <comment>adi high bits version,read only.</comment>
        </bits>
      </reg>
      <reg name="adi_ctrl" protect="rw">
        <bits access="rw" name="addr_byte_sel" pos="1:0" rst="0">
          <comment>addr mode for access. &quot;00&quot; word mode,means addr[x:2],&quot;01&quot; half word,means addr[x:1], &quot;1x&quot; byte mode, means addr[x:0].</comment>
        </bits>
        <bits access="rw" name="wr_bit_flag" pos="2" rst="0">
          <comment>configure write bit flag.</comment>
        </bits>
        <bits access="rw" name="addr_bits_sel" pos="4:3" rst="0">
          <comment>addr bit number configure, &quot;00&quot; address is 12 bits, &quot;01&quot; address is 10 bits, &quot;10&quot; address is 15 bits.</comment>
        </bits>
        <bits access="rw" name="wr_cmd_en" pos="5" rst="0">
          <comment>&quot;1&quot; write uses command mode, in this mode, must first configure channel addr, then data.</comment>
        </bits>
      </reg>
      <reg name="adi_pril" protect="rw">
        <bits access="rw" name="chnl0_pri" pos="2:0" rst="0">
          <comment>write channel 0 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
        <bits access="rw" name="chnl1_pri" pos="5:3" rst="0">
          <comment>read channel 1 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
        <bits access="rw" name="event0_pri" pos="8:6" rst="0">
          <comment>read channel 2 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
        <bits access="rw" name="event1_pri" pos="11:9" rst="0">
          <comment>read channel 3 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
        <bits access="rw" name="event2_pri" pos="14:12" rst="0">
          <comment>read channel 4 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
        <bits access="rw" name="event3_pri" pos="17:15" rst="0">
          <comment>read channel 5 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="adi_int_en" protect="rw">
        <bits access="rw" name="wfifo_en" pos="0" rst="0">
          <comment>&quot;1&quot; write command fifo enable.</comment>
        </bits>
        <bits access="rw" name="fifo_overflow_int_en" pos="3" rst="0">
          <comment>fifo overfolow interrupt mask.</comment>
        </bits>
      </reg>
      <reg name="adi_int_raw" protect="r">
        <bits access="r" name="fifo_overflow_raw" pos="3" rst="0">
          <comment>fifo overfolow interrupt without mask status.</comment>
        </bits>
      </reg>
      <reg name="adi_int_status" protect="r">
        <bits access="r" name="fifo_overflow_status" pos="3" rst="0">
          <comment>fifo overfolow interrupt with mask status.</comment>
        </bits>
      </reg>
      <reg name="adi_int_clear" protect="w">
        <bits access="w" name="fifo_overflow_clear" pos="3" rst="0">
          <comment>fifo overfolow interrupt clear.</comment>
        </bits>
      </reg>
      <reg name="adi_cfg0" protect="rw">
        <bits access="rw" name="rf_gssi_frame_len" pos="5:0" rst="0x3d">
          <comment>total adi frame length = rf_gssi_cmd_len + rf_gssi_data_len.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_cmd_len" pos="10:6" rst="0x14">
          <comment>total adi cmd length = rf_gssi_addr_len + read/write flag.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_data_len" pos="15:11" rst="0x10">
          <comment>total adi data length .</comment>
        </bits>
        <bits access="rw" name="rf_gssi_wr_pos" pos="20:16" rst="0x10">
          <comment>write bit position in frame stream .</comment>
        </bits>
        <bits access="rw" name="rf_gssi_wr_pol" pos="21" rst="0x0">
          <comment>&quot;1&quot; write means 1, &quot;0&quot; write means 0.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sync_sel" pos="22" rst="0x1">
          <comment>&quot;1&quot; hardware auto generate sync, &quot;0&quot; software generates sync.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sync_mode" pos="23" rst="0x1">
          <comment>&quot;1&quot; sync is pulse, &quot;0&quot; sync is level.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sync" pos="24" rst="0x0">
          <comment>&quot;1&quot; software generates sync.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sck_rev" pos="25" rst="0x0">
          <comment>&quot;1&quot; invert output sck.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_oe_cfg" pos="26" rst="0x1">
          <comment>output oen : &quot;1&quot; oen add dummy cycle, &quot;0&quot; oen not add dummy cycle.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_ie_cfg" pos="27" rst="0x0">
          <comment>reserved.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_dummy_clk_en" pos="28" rst="0x1">
          <comment>&quot;1&quot; output dummy_clock, &quot;0&quot; gate dummy clock.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_fast_mode" pos="29" rst="0x0">
          <comment>&quot;1&quot; rx sample delay 1 adi clk cycle, &quot;0&quot; delay 0 adi clk cycle.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sck_all_on" pos="30" rst="0x1">
          <comment>&quot;1&quot; sck always on, &quot;0&quot; audo gate  clock.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_wr_disable" pos="31" rst="0x0">
          <comment>&quot;1&quot; write bit disable, &quot;0&quot; write bit enable.</comment>
        </bits>
      </reg>
      <reg name="adi_cfg1" protect="rw">
        <bits access="rw" name="rf_gssi_ng_tx" pos="0" rst="1">
          <comment>&quot;1&quot; tx data at negedge of sck.&quot;0&quot; tx data at posedge of sck.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_ng_rx" pos="1" rst="0">
          <comment>&quot;1&quot; rx data at negedge of sck.&quot;0&quot; rx data at posedge of sck.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_clk_div" pos="9:2" rst="1">
          <comment>F_sck = F_clk/(2*(rf_gssi_clk_div+1))</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sync_head_len" pos="12:10" rst="0">
          <comment>sync before data transfer</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sync_end_len" pos="15:13" rst="0">
          <comment>sync end data transfer</comment>
        </bits>
        <bits access="rw" name="rf_gssi_dummy_len" pos="19:16" rst="3">
          <comment>extral dummy sck</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sample_delay" pos="20" rst="0">
          <comment>extral dummy sck</comment>
        </bits>
        <bits access="rw" name="rf_gssi_scc_len" pos="23:21" rst="0">
          <comment>start sequence condition, only used in RFFE</comment>
        </bits>
        <bits access="rw" name="rf_gssi_wbp_len" pos="26:24" rst="0">
          <comment>master turn around to salve length , only used in RFFE</comment>
        </bits>
        <bits access="rw" name="rf_gssi_rbp_len" pos="30:28" rst="0">
          <comment>slave turn around to master length , only used in RFFE</comment>
        </bits>
        <bits access="rw" name="rf_gssi_strtbit_mode" pos="31" rst="0">
          <comment>&quot;1&quot; 2 wires enable</comment>
        </bits>
      </reg>
      <reg name="arm_rd_cmd" protect="rw">
        <bits access="rw" name="arm_rd_cmd" pos="16:0" rst="0">
          <comment>configure read address and start a read operation.</comment>
        </bits>
      </reg>
      <reg name="arm_rd_data" protect="r">
        <bits access="r" name="arm_rd_cmd" pos="15:0" rst="0">
          <comment>read data from analog die.</comment>
        </bits>
        <bits access="r" name="arm_rd_addr" pos="30:16" rst="0">
          <comment>read address map to arm_red_cmd[16:2].</comment>
        </bits>
        <bits access="r" name="arm_rd_cmd_busy" pos="31" rst="0">
          <comment>1 means has not been read back.</comment>
        </bits>
      </reg>
      <reg name="arm_cmd_status" protect="r">
        <bits access="r" name="arm_wr_status" pos="0" rst="0">
          <comment>&quot;1&quot; write channel is busy</comment>
        </bits>
        <bits access="r" name="arm_rd_status" pos="1" rst="0">
          <comment>&quot;1&quot; read channel is busy</comment>
        </bits>
        <bits access="r" name="adi_busy" pos="4" rst="0">
          <comment>&quot;1&quot; adi operation is busy</comment>
        </bits>
        <bits access="r" name="wfifo full" pos="8" rst="0">
          <comment>wfifo full status</comment>
        </bits>
        <bits access="r" name="wfifo empty" pos="9" rst="0">
          <comment>wfifo empty status</comment>
        </bits>
        <bits access="r" name="wfifo fill data level" pos="14:12" rst="0">
          <comment>wfifo fill data number</comment>
        </bits>
        <bits access="r" name="adi fsm status" pos="19:16" rst="0">
          <comment>adi fsm status</comment>
        </bits>
        <bits access="r" name="event0 wr status" pos="20" rst="0">
          <comment>event 0 wr status</comment>
        </bits>
        <bits access="r" name="event1 wr status" pos="21" rst="0">
          <comment>event 1 wr status</comment>
        </bits>
        <bits access="r" name="event2 wr status" pos="22" rst="0">
          <comment>event 2 wr status</comment>
        </bits>
        <bits access="r" name="event3 wr status" pos="23" rst="0">
          <comment>event 3 wr status</comment>
        </bits>
      </reg>
      <reg name="adi_chanel_en" protect="rw">
        <bits access="rw" name="event0 trigger negedge en" pos="0" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event0 trigger posedge en" pos="1" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event1 trigger negedge en" pos="2" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event1 trigger posedge en" pos="3" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event2 trigger negedge en" pos="4" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event2 trigger posedge en" pos="5" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event3 trigger negedge en" pos="6" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event3 trigger posedge en" pos="7" rst="0">
          <comment/>
        </bits>
      </reg>
      <reg name="adi_cmd_wr" protect="rw">
        <bits access="rw" name="adi_cmd_wr" pos="16:0" rst="0">
          <comment>the address map to the PMIC chip space, just for write operation</comment>
        </bits>
      </reg>
      <reg name="adi_dat_wr" protect="rw">
        <bits access="rw" name="adi_dat_wr" pos="15:0" rst="0">
          <comment>the dat to the PMIC chip space, just for write operation</comment>
        </bits>
      </reg>
      <reg name="event0_waddr" protect="rw">
        <bits access="rw" name="event0_waddr" pos="16:0" rst="0x634">
          <comment/>
        </bits>
      </reg>
      <reg name="event1_waddr" protect="rw">
        <bits access="rw" name="event1_waddr" pos="16:0" rst="0">
          <comment/>
        </bits>
      </reg>
      <reg name="event2_waddr" protect="rw">
        <bits access="rw" name="event2_waddr" pos="16:0" rst="0">
          <comment/>
        </bits>
      </reg>
      <reg name="event3_waddr" protect="rw">
        <bits access="rw" name="event3_waddr" pos="16:0" rst="0">
          <comment/>
        </bits>
      </reg>
      <reg name="event0_wdata" protect="rw">
        <bits access="rw" name="event0_neg_wdata" pos="15:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="event0_pos_wdata" pos="31:16" rst="0x1">
          <comment/>
        </bits>
      </reg>
      <reg name="event1_wdata" protect="rw">
        <bits access="rw" name="event1_neg_wdata" pos="15:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="event1_pos_wdata" pos="31:16" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="event2_wdata" protect="rw">
        <bits access="rw" name="event2_neg_wdata" pos="15:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="event2_pos_wdata" pos="31:16" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="event3_wdata" protect="rw">
        <bits access="rw" name="event3_neg_wdata" pos="15:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="event3_pos_wdata" pos="31:16" rst="0x0">
          <comment/>
        </bits>
      </reg>
    </module>
    <instance address="0x51100000" name="ADI_MST" type="ADI_MST"/>
  </archive>
  <archive relative="aon_ifc.xml">
    <var name="AON_NB_BITS_ADDR" value="32"/>
    <var name="AON_IFC_ADDR_ALIGN" value="0"/>
    <var name="AON_IFC_TC_LEN" value="23"/>
    <var name="AON_IFC_STD_CHAN_NB" value="6"/>
    <var name="AON_IFC_RFSPI_CHAN" value="0"/>
    <var name="AON_IFC_AIF_CHAN" value="2"/>
    <var name="AON_IFC_DBG_CHAN" value="1"/>
    <enum name="AON_IFC_Request_IDs">
      <entry name="DMA_ID_TX_UART2"/>
      <entry name="DMA_ID_RX_UART2"/>
      <entry name="DMA_ID_TX_UART3"/>
      <entry name="DMA_ID_RX_UART3"/>
      <entry name="DMA_ID_TX_DBG_UART"/>
      <entry name="DMA_ID_RX_DBG_UART"/>
    </enum>
    <module category="System" name="AON_IFC">
      <reg name="get_ch" protect="--">
        <bits access="r" name="ch_to_use" pos="4:0" rst="0">
          <comment>
            This field indicates which standard channel to use.
            <br/>
             Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
            <br/>
             After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
            <br/>
            Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
            <br/>
            Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
            <br/>
            When non-secure cpu read this register, the return value will automatic exlude the secure channel.
            <br/>
            00000 = use Channel0
            <br/>
            00001 = use Channel1
            <br/>
            00010 = use Channel2
            <br/>
             ...
            <br/>
            01111 = use Channel15
            <br/>
            11111 = all channels are busy
          </comment>
          <options>
            <mask/>
            <shift/>
            <default/>
          </options>
        </bits>
      </reg>
      <reg name="dma_status" protect="r">
        <bits access="r" name="ch_enable" pos="AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN-1:0" rst="0">
          <comment>
            This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels disabled
            <br/>
            0000_0001 = Ch0 enabled
            <br/>
            0000_0010 = Ch1 enabled
            <br/>
            0000_0100 = Ch2 enabled
            <br/>
            0000_0101 = Ch0 and Ch2 enabled
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 enabled
            <br/>
            all 1     = all channels enabled
          </comment>
        </bits>
        <bits access="r" name="ch_busy" pos="AON_IFC_STD_CHAN_NB-1+16:16" rst="0">
          <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
        </bits>
      </reg>
      <reg name="debug_status" protect="r">
        <bits access="r" name="dbg_status" pos="0" rst="1">
          <comment>
            Debug Channel Status .
            <br/>
            0= The debug channel is running
      (not idle)
            <br/>
            1= The debug channel is in idle mode
          </comment>
        </bits>
      </reg>
      <reg name="ifc_sec" protect="rw">
        <bits access="rw" name="std_ch_reg_sec" pos="AON_IFC_STD_CHAN_NB-1:0" rst="0">
          <comment>
            This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels registers can be accessed by secure master or non-secure master.
            <br/>
            0000_0001 = Ch0 registers can only be accessed by secure master.
            <br/>
            0000_0010 = Ch1 registers can only be accessed by secure master.
            <br/>
            0000_0100 = Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels registers can only be accessed by secure master.
          </comment>
        </bits>
        <bits access="rw" name="aif_ch_reg_sec" pos="AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN+AON_IFC_AIF_CHAN-1:AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN" rst="0">
          <comment>This register indicates aif channel register can only be accessed by secure master.</comment>
        </bits>
        <bits access="rw" name="std_ch_dma_sec" pos="AON_IFC_STD_CHAN_NB-1+16:16" rst="all1">
          <comment>
            This register indicates which channel dma is secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels dma are non-secure master.
            <br/>
            0000_0001 = Ch0 dma is secure master.
            <br/>
            0000_0010 = Ch1 dma is secure master.
            <br/>
            0000_0100 = Ch2 dma is secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 dma are secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels dma are secure master.
          </comment>
        </bits>
        <bits access="rw" name="aif_ch_dma_sec" pos="AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN+AON_IFC_AIF_CHAN-1+16:AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN+16" rst="all1">
          <comment>This register indicates aif channel dma is secure master.</comment>
        </bits>
        <bits access="rw" name="dbg_ch_dma_sec" pos="AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN+AON_IFC_AIF_CHAN+AON_IFC_DBG_CHAN-1+16:AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN+AON_IFC_AIF_CHAN+16" rst="1">
          <comment>This register indicates dbghost channel dma is secure master.</comment>
        </bits>
      </reg>
      <struct count="AON_IFC_STD_CHAN_NB" name="std_ch">
        <reg name="control" protect="rw">
          <bits access="w" name="enable" pos="0" rst="no">
            <comment>
              Channel Enable, write one in this bit enable the channel.
              <br/>
              When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer.
            </comment>
          </bits>
          <bits access="w" name="disable" pos="1" rst="no">
            <comment>
              Channel Disable, write one in this bit disable the channel.
              <br/>
              When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled.
            </comment>
          </bits>
          <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
            <comment>
              Exchange the read data from fifo halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
            <comment>
              Exchange the write data to fifo  halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="autodisable" pos="4" rst="1">
            <comment>
              Set Auto-disable mode
              <br/>
               0 = when TC reach zero the
        channel is not automatically released.
              <br/>
               1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.
            </comment>
          </bits>
          <bits access="rw" name="size" pos="5" rst="0">
            <comment>
              Peripheral Size
              <br/>
               0= 8-bit peripheral
              <br/>
               1= 32-bit peripheral
            </comment>
          </bits>
          <bits access="rw" display="hex" name="req_src" pos="12:8" rst="0x1F">
            <options linkenum="AON_IFC_Request_IDs">
              <shift/>
              <mask/>
              <default/>
            </options>
            <comment>Select DMA Request source</comment>
          </bits>
          <bits access="rw" name="flush" pos="16" rst="0">
            <comment>
              When one, flush the internal FIFO channel.
              <br/>
              This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel.
              <br/>
               Before writting back this bit to zero the internal fifo must empty.
            </comment>
          </bits>
          <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
            <comment>
              Set the MAX burst length for channel 0,1.
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.
              <br/>
               The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4.
              <br/>
               .
            </comment>
          </bits>
        </reg>
        <reg name="status" protect="r">
          <bits access="r" name="enable" pos="0" rst="0">
            <comment>Enable bit, when '1' the channel is running</comment>
          </bits>
          <bits access="r" name="fifo_empty" pos="4" rst="1">
            <comment>The internal channel fifo is empty</comment>
          </bits>
        </reg>
        <reg name="start_addr" protect="rw">
          <bits access="rw" display="hex" name="start_addr" pos="AON_NB_BITS_ADDR-1:AON_IFC_ADDR_ALIGN" rst="0xFFFFFFF">
            <comment>
              AHB Address. This field represent the start address of the
        transfer.
              <br/>
              For a 32-bit peripheral, this address must be aligned 32-bit.
            </comment>
          </bits>
        </reg>
        <reg name="tc" protect="rw">
          <bits access="rw" display="hex" name="tc" pos="AON_IFC_TC_LEN-1:0" rst="0xFFFFFF">
            <comment>
              Transfer Count, this field indicated the transfer size in bytes to perform.
              <br/>
              During a transfer a write in this register add the new value to the current TC.
              <br/>
              A read of this register return the current current transfer count.
            </comment>
          </bits>
        </reg>
        <reg name="tc_threshold" protect="rw">
          <bits access="rw" display="hex" name="tc_threshold" pos="AON_IFC_TC_LEN-1:0" rst="0x0">
            <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.</comment>
          </bits>
        </reg>
      </struct>
    </module>
    <module category="System" name="AUDIO_IFC">
      <var name="AON_APB1_IFC_AHB_MAXSPACE" value="20"/>
      <var name="AON_APB1_IFC_ADDR_ALIGN" value="2"/>
      <struct count="AON_IFC_AIF_CHAN" name="ch">
        <comment>
          The Channel 0 conveys data from the AIF to the memory.
          <br/>
        The Channel 1 conveys data from the memory to the AIF.
          <br/>
          These Channels only exist with Voice Option.
        </comment>
        <reg name="control" protect="rw">
          <bits access="w" name="enable" pos="0" rst="no">
            <comment>
              Channel Enable, write one in this bit enable the channel.
              <br/>
              When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer.
            </comment>
          </bits>
          <bits access="w" name="disable" pos="1" rst="no">
            <comment>
              Channel Disable, write one in this bit disable the channel.
              <br/>
              When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled.
            </comment>
          </bits>
          <bits access="rw" name="auto_disable" pos="4" rst="0">
            <comment>Automatic channel Disable. When this bit is set, the channel is automatically disabled at the next interrupt.</comment>
          </bits>
        </reg>
        <reg name="status" protect="r">
          <bits access="r" name="enable" pos="0" rst="0">
            <comment>When 1 the channel is enabled</comment>
          </bits>
          <bits access="r" name="fifo_empty" pos="4" rst="1">
            <comment>When 1 the fifo is empty</comment>
          </bits>
          <bits access="r" name="cause_ief" pos="8" rst="0">
            <comment>Cause interrupt End of FIFO.</comment>
          </bits>
          <bits access="r" name="cause_ihf" pos="9" rst="0">
            <comment>Cause interrupt Half of FIFO.</comment>
          </bits>
          <bits access="r" name="cause_i4f" pos="10" rst="0">
            <comment>Cause interrupt Quarter of FIFO.</comment>
          </bits>
          <bits access="r" name="cause_i3_4f" pos="11" rst="0">
            <comment>Cause interrupt Three Quarter of FIFO.</comment>
          </bits>
          <bits access="r" name="cause_ahb_error" pos="12" rst="0">
            <comment>Cause interrupt ahb error.</comment>
          </bits>
          <bits access="r" name="ief" pos="16" rst="0">
            <comment>End of FIFO interrupt status bit.</comment>
          </bits>
          <bits access="r" name="ihf" pos="17" rst="0">
            <comment>Half of FIFO interrupt status bit.</comment>
          </bits>
          <bits access="r" name="i4f" pos="18" rst="0">
            <comment>Quarter of FIFO interrupt status bit.</comment>
          </bits>
          <bits access="r" name="i3_4f" pos="19" rst="0">
            <comment>Three Quarter of FIFO interrupt status bit.</comment>
          </bits>
          <bits access="r" name="ahb error" pos="20" rst="0">
            <comment>ahb error interrupt status bit.</comment>
          </bits>
          <bits access="r" name="ch_idle" pos="21" rst="0">
            <comment>channel busy status bit.</comment>
          </bits>
        </reg>
        <reg name="start_addr" protect="rw">
          <bits access="rw" display="hex" name="start_addr" pos="AON_NB_BITS_ADDR-1:AON_APB1_IFC_ADDR_ALIGN" rst="0xFFFFFFFF">
            <comment>AHB Start Address. This field represent the start address of the FIFO located in RAM.</comment>
          </bits>
        </reg>
        <reg name="fifo_size" protect="rw">
          <bits access="rw" display="hex" name="fifo_size" pos="19:4" rst="all1">
            <comment>
              Fifo size in bytes, max 1MBytes.
              <br/>
              The size of the fifo must be a multiple of 16 (The four LSB are always zero).
            </comment>
          </bits>
        </reg>
        <hole size="32"/>
        <reg name="int_mask" protect="rw">
          <bits access="rw" name="end_fifo" pos="8" rst="0">
            <comment>END FIFO Mask interrupt. When one this interrupt is enabled.</comment>
          </bits>
          <bits access="rw" name="half_fifo" pos="9" rst="0">
            <comment>HALF FIFO Mask interrupt. When one this interrupt is enabled.</comment>
          </bits>
          <bits access="rw" name="quarter_fifo" pos="10" rst="0">
            <comment>QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled.</comment>
          </bits>
          <bits access="rw" name="three_quarter_fifo" pos="11" rst="0">
            <comment>THREE QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled.</comment>
          </bits>
          <bits access="rw" name="ahb_error" pos="12" rst="0">
            <comment>ahb_error Mask interrupt. When one this interrupt is
        enabled.</comment>
          </bits>
        </reg>
        <reg name="int_clear" protect="rw">
          <bits access="c" name="end_fifo" pos="8" rst="0">
            <comment>Write one to clear end of fifo interrupt.</comment>
          </bits>
          <bits access="c" name="half_fifo" pos="9" rst="0">
            <comment>Write one to clear half of fifo interrupt.</comment>
          </bits>
          <bits access="c" name="quarter_fifo" pos="10" rst="0">
            <comment>Write one to clear Quarter fifo interrupt.</comment>
          </bits>
          <bits access="c" name="three_quarter_fifo" pos="11" rst="0">
            <comment>Write one to clear Three Quarter fifo interrupt.</comment>
          </bits>
          <bits access="c" name="ahb_error" pos="12" rst="0">
            <comment>Write one to clear ahb_error interrupt.</comment>
          </bits>
        </reg>
        <reg name="cur_ahb_addr" protect="r">
          <bits access="r" display="hex" name="cur_ahb_addr" pos="AON_NB_BITS_ADDR-1:0" rst="0">
            <comment>Current AHB address value. The nine MSB bit is constant and
        equal to the PAGE_ADDR field in the IFC_CH_AHB_START_ADDR register.</comment>
          </bits>
        </reg>
      </struct>
    </module>
    <instance address="0x5140E000" name="AON_IFC" type="AON_IFC"/>
  </archive>
  <archive relative="ap_ifc.xml">
    <var name="AP_NB_BITS_ADDR" value="32"/>
    <var name="AP_IFC_ADDR_ALIGN" value="0"/>
    <var name="AP_IFC_TC_LEN" value="23"/>
    <var name="AP_IFC_STD_CHAN_NB" value="10"/>
    <var name="AP_IFC_RFSPI_CHAN" value="0"/>
    <var name="AP_IFC_AIF_CHAN" value="0"/>
    <var name="AP_IFC_DBG_CHAN" value="0"/>
    <enum name="AP_IFC_Request_IDs">
      <entry name="DMA_ID_TX_UART4"/>
      <entry name="DMA_ID_RX_UART4"/>
      <entry name="DMA_ID_TX_UART5"/>
      <entry name="DMA_ID_RX_UART5"/>
      <entry name="DMA_ID_TX_UART6"/>
      <entry name="DMA_ID_RX_UART6"/>
      <entry name="DMA_ID_TX_SDMMC"/>
      <entry name="DMA_ID_RX_SDMMC"/>
      <entry name="DMA_ID_RSVD"/>
      <entry name="DMA_ID_RX_CAMERA"/>
    </enum>
    <module category="System" name="AP_IFC">
      <reg name="get_ch" protect="--">
        <bits access="r" name="ch_to_use" pos="4:0" rst="0">
          <comment>
            This field indicates which standard channel to use.
            <br/>
             Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
            <br/>
             After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
            <br/>
            Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
            <br/>
            Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
            <br/>
            When non-secure cpu read this register, the return value will automatic exlude the secure channel.
            <br/>
            00000 = use Channel0
            <br/>
            00001 = use Channel1
            <br/>
            00010 = use Channel2
            <br/>
             ...
            <br/>
            01111 = use Channel15
            <br/>
            11111 = all channels are busy
          </comment>
          <options>
            <mask/>
            <shift/>
            <default/>
          </options>
        </bits>
      </reg>
      <reg name="dma_status" protect="r">
        <bits access="r" name="ch_enable" pos="AP_IFC_STD_CHAN_NB+AP_IFC_RFSPI_CHAN-1:0" rst="0">
          <comment>
            This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels disabled
            <br/>
            0000_0001 = Ch0 enabled
            <br/>
            0000_0010 = Ch1 enabled
            <br/>
            0000_0100 = Ch2 enabled
            <br/>
            0000_0101 = Ch0 and Ch2 enabled
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 enabled
            <br/>
            all 1     = all channels enabled
          </comment>
        </bits>
        <bits access="r" name="ch_busy" pos="AP_IFC_STD_CHAN_NB-1+16:16" rst="0">
          <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
        </bits>
      </reg>
      <reg name="debug_status" protect="r">
        <bits access="r" name="dbg_status" pos="0" rst="1">
          <comment>
            Debug Channel Status .
            <br/>
            0= The debug channel is running
      (not idle)
            <br/>
            1= The debug channel is in idle mode
          </comment>
        </bits>
      </reg>
      <reg name="ifc_sec" protect="rw">
        <bits access="rw" name="std_ch_reg_sec" pos="AP_IFC_STD_CHAN_NB-1:0" rst="0">
          <comment>
            This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels registers can be accessed by secure master or non-secure master.
            <br/>
            0000_0001 = Ch0 registers can only be accessed by secure master.
            <br/>
            0000_0010 = Ch1 registers can only be accessed by secure master.
            <br/>
            0000_0100 = Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels registers can only be accessed by secure master.
          </comment>
        </bits>
        <bits access="rw" name="std_ch_dma_sec" pos="AP_IFC_STD_CHAN_NB-1+16:16" rst="all1">
          <comment>
            This register indicates which channel dma is secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels dma are non-secure master.
            <br/>
            0000_0001 = Ch0 dma is secure master.
            <br/>
            0000_0010 = Ch1 dma is secure master.
            <br/>
            0000_0100 = Ch2 dma is secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 dma are secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels dma are secure master.
          </comment>
        </bits>
      </reg>
      <struct count="AP_IFC_STD_CHAN_NB" name="std_ch">
        <reg name="control" protect="rw">
          <bits access="w" name="enable" pos="0" rst="no">
            <comment>
              Channel Enable, write one in this bit enable the channel.
              <br/>
              When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer.
            </comment>
          </bits>
          <bits access="w" name="disable" pos="1" rst="no">
            <comment>
              Channel Disable, write one in this bit disable the channel.
              <br/>
              When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled.
            </comment>
          </bits>
          <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
            <comment>
              Exchange the read data from fifo halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
            <comment>
              Exchange the write data to fifo  halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="autodisable" pos="4" rst="1">
            <comment>
              Set Auto-disable mode
              <br/>
               0 = when TC reach zero the
        channel is not automatically released.
              <br/>
               1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.
            </comment>
          </bits>
          <bits access="rw" name="size" pos="5" rst="0">
            <comment>
              Peripheral Size
              <br/>
               0= 8-bit peripheral
              <br/>
               1= 32-bit peripheral
            </comment>
          </bits>
          <bits access="rw" display="hex" name="req_src" pos="12:8" rst="0x1F">
            <options linkenum="AP_IFC_Request_IDs">
              <shift/>
              <mask/>
              <default/>
            </options>
            <comment>Select DMA Request source</comment>
          </bits>
          <bits access="rw" name="flush" pos="16" rst="0">
            <comment>
              When one, flush the internal FIFO channel.
              <br/>
              This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel.
              <br/>
               Before writting back this bit to zero the internal fifo must empty.
            </comment>
          </bits>
          <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
            <comment>
              Set the MAX burst length for channel 0,1.
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.
              <br/>
               The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4.
              <br/>
               .
            </comment>
          </bits>
        </reg>
        <reg name="status" protect="r">
          <bits access="r" name="enable" pos="0" rst="0">
            <comment>Enable bit, when '1' the channel is running</comment>
          </bits>
          <bits access="r" name="fifo_empty" pos="4" rst="1">
            <comment>The internal channel fifo is empty</comment>
          </bits>
        </reg>
        <reg name="start_addr" protect="rw">
          <bits access="rw" display="hex" name="start_addr" pos="AP_NB_BITS_ADDR-1:AP_IFC_ADDR_ALIGN" rst="0xFFFFFFF">
            <comment>
              AHB Address. This field represent the start address of the
        transfer.
              <br/>
              For a 32-bit peripheral, this address must be aligned 32-bit.
            </comment>
          </bits>
        </reg>
        <reg name="tc" protect="rw">
          <bits access="rw" display="hex" name="tc" pos="AP_IFC_TC_LEN-1:0" rst="0xFFFFFF">
            <comment>
              Transfer Count, this field indicated the transfer size in bytes to perform.
              <br/>
              During a transfer a write in this register add the new value to the current TC.
              <br/>
              A read of this register return the current current transfer count.
            </comment>
          </bits>
        </reg>
        <reg name="tc_threshold" protect="rw">
          <bits access="rw" display="hex" name="tc_threshold" pos="AP_IFC_TC_LEN-1:0" rst="0x0">
            <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.</comment>
          </bits>
        </reg>
      </struct>
    </module>
    <instance address="0x04405000" name="AP_IFC" type="AP_IFC"/>
  </archive>
  <archive relative="arm_axidma.xml">
    <module category="System" name="ARM_AXIDMA">
      <reg name="axidma_conf" protect="rw">
        <bits access="rw" name="gen_reg_secuirty_en" pos="6" rst="1">
          <comment>general used register security visit enable
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="resp_err_stop_en" pos="5" rst="0">
          <comment>response error stop function enable
0:enable
1:disable</comment>
        </bits>
        <bits access="rw" name="outstand" pos="4:3" rst="2">
          <comment>the number of outstanding that can be send out
0: 2
1: 3
2: 4</comment>
        </bits>
        <bits access="rw" name="priority" pos="2" rst="0">
          <comment>multe-channel transport priority mode control
0: there is no priority in the channels, using polling to DMA data
1: smaller channel number has high-priority.high-priority move data before low-priority channels</comment>
        </bits>
        <bits access="rw" name="stop_ie" pos="1" rst="0">
          <comment>interrupt control bit
0: no interruption occurs when all logical channels finish
1: interruption occurs when all logical channels finish</comment>
        </bits>
        <bits access="rw" name="stop" pos="0" rst="0">
          <comment>the control bit of logical channel transport finish
0: don't stop all the channel,or automatically clear after setting
1: stop all channel.the current transmission is stopped.the start bits of all channels are cleared</comment>
        </bits>
      </reg>
      <reg name="axidma_delay" protect="rw">
        <bits access="rw" name="delay" pos="15:0" rst="0">
          <comment>in the non-priority mode, the time interval between two COUNTP transmission. Take the system clock as the criterion to avoid AXIDMA long-term use of the bus.</comment>
        </bits>
      </reg>
      <reg name="axidma_status" protect="r">
        <bits access="r" name="stop_status" pos="4" rst="0">
          <comment>stop status
0: not finish
1: finish</comment>
        </bits>
        <bits access="r" name="ch_num" pos="3:0" rst="15">
          <comment>the channel number of the final transmission
0000: channel 0 just finished the transmission
0001: channel 1 just finished the transmission
0010: channel 2 just finished the transmission
......
1011: channel 11 just finished the transmission
others: nonentity</comment>
        </bits>
      </reg>
      <reg name="axidma_irq_stat" protect="r">
        <bits access="r" name="rst_fin_irq" pos="12" rst="0">
          <comment>logic channel stop interrupt status</comment>
        </bits>
        <bits access="r" name="ch11_irq" pos="11" rst="0">
          <comment>channel 11 interrupts state
0: the channel 11 has not been interrupted, or the interrupt bit has been cleared
1: channel 11 is interrupted</comment>
        </bits>
        <bits access="r" name="ch10_irq" pos="10" rst="0">
          <comment>channel 10 interrupts state
0: the channel 10 has not been interrupted, or the interrupt bit has been cleared
1: channel 10 is interrupted</comment>
        </bits>
        <bits access="r" name="ch9_irq" pos="9" rst="0">
          <comment>channel 9 interrupts state
0: the channel 9 has not been interrupted, or the interrupt bit has been cleared
1: channel 9 is interrupted</comment>
        </bits>
        <bits access="r" name="ch8_irq" pos="8" rst="0">
          <comment>channel 8 interrupts state
0: the channel 8 has not been interrupted, or the interrupt bit has been cleared
1: channel 8 is interrupted</comment>
        </bits>
        <bits access="r" name="ch7_irq" pos="7" rst="0">
          <comment>channel 7 interrupts state
0: the channel 7 has not been interrupted, or the interrupt bit has been cleared
1: channel 7 is interrupted</comment>
        </bits>
        <bits access="r" name="ch6_irq" pos="6" rst="0">
          <comment>channel 6 interrupts state
0: the channel 6 has not been interrupted, or the interrupt bit has been cleared
1: channel 6 is interrupted</comment>
        </bits>
        <bits access="r" name="ch5_irq" pos="5" rst="0">
          <comment>channel 5 interrupts state
0: the channel 5 has not been interrupted, or the interrupt bit has been cleared
1: channel 5 is interrupted</comment>
        </bits>
        <bits access="r" name="ch4_irq" pos="4" rst="0">
          <comment>channel 4 interrupts state
0: the channel 4 has not been interrupted, or the interrupt bit has been cleared
1: channel 4 is interrupted</comment>
        </bits>
        <bits access="r" name="ch3_irq" pos="3" rst="0">
          <comment>channel 3 interrupts state
0: the channel 3 has not been interrupted, or the interrupt bit has been cleared
1: channel 3 is interrupted</comment>
        </bits>
        <bits access="r" name="ch2_irq" pos="2" rst="0">
          <comment>channel 2 interrupts state
0: the channel 2 has not been interrupted, or the interrupt bit has been cleared
1: channel 2 is interrupted</comment>
        </bits>
        <bits access="r" name="ch1_irq" pos="1" rst="0">
          <comment>channel 1 interrupts state
0: the channel 1 has not been interrupted, or the interrupt bit has been cleared
1: channel 1 is interrupted</comment>
        </bits>
        <bits access="r" name="ch0_irq" pos="0" rst="0">
          <comment>channel 0 interrupts state
0: the channel 0 has not been interrupted, or the interrupt bit has been cleared
1: channel 0 is interrupted</comment>
        </bits>
      </reg>
      <reg name="axidma_arm_req_stat" protect="r">
        <bits access="r" name="irq23" pos="23" rst="0">
          <comment>state of IRQ 23 generate requests of moving data
0: IRQ 23 does not generate requests of moving data
1: IRQ 23 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq22" pos="22" rst="0">
          <comment>state of IRQ 22 generate requests of moving data
0: IRQ 22 does not generate requests of moving data
1: IRQ 22 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq21" pos="21" rst="0">
          <comment>state of IRQ 21 generate requests of moving data
0: IRQ 21 does not generate requests of moving data
1: IRQ 21 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq20" pos="20" rst="0">
          <comment>state of IRQ 20 generate requests of moving data
0: IRQ 20 does not generate requests of moving data
1: IRQ 20 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq19" pos="19" rst="0">
          <comment>state of IRQ 19 generate requests of moving data
0: IRQ 19 does not generate requests of moving data
1: IRQ 19 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq18" pos="18" rst="0">
          <comment>state of IRQ 18 generate requests of moving data
0: IRQ 18 does not generate requests of moving data
1: IRQ 18 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq17" pos="17" rst="0">
          <comment>state of IRQ 17 generate requests of moving data
0: IRQ 17 does not generate requests of moving data
1: IRQ 17 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq16" pos="16" rst="0">
          <comment>state of IRQ 16 generate requests of moving data
0: IRQ 16 does not generate requests of moving data
1: IRQ 16 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq15" pos="15" rst="0">
          <comment>state of IRQ 15 generate requests of moving data
0: IRQ 15 does not generate requests of moving data
1: IRQ 15 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq14" pos="14" rst="0">
          <comment>state of IRQ 14 generate requests of moving data
0: IRQ 14 does not generate requests of moving data
1: IRQ 14 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq13" pos="13" rst="0">
          <comment>state of IRQ 13 generate requests of moving data
0: IRQ 13 does not generate requests of moving data
1: IRQ 13 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq12" pos="12" rst="0">
          <comment>state of IRQ 12 generate requests of moving data
0: IRQ 12 does not generate requests of moving data
1: IRQ 12 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq11" pos="11" rst="0">
          <comment>state of IRQ 11 generate requests of moving data
0: IRQ 11 does not generate requests of moving data
1: IRQ 11 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq10" pos="10" rst="0">
          <comment>state of IRQ 10 generate requests of moving data
0: IRQ 10 does not generate requests of moving data
1: IRQ 10 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq9" pos="9" rst="0">
          <comment>state of IRQ 9 generate requests of moving data
0: IRQ 9 does not generate requests of moving data
1: IRQ 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq8" pos="8" rst="0">
          <comment>state of IRQ 8 generate requests of moving data
0: IRQ 8 does not generate requests of moving data
1: IRQ 8 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq7" pos="7" rst="0">
          <comment>state of IRQ 7 generate requests of moving data
0: IRQ 7 does not generate requests of moving data
1: IRQ 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq6" pos="6" rst="0">
          <comment>state of IRQ 6 generate requests of moving data
0: IRQ 6 does not generate requests of moving data
1: IRQ 6 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq5" pos="5" rst="0">
          <comment>state of IRQ 5 generate requests of moving data
0: IRQ 5 does not generate requests of moving data
1: IRQ 5 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq4" pos="4" rst="0">
          <comment>state of IRQ 4 generate requests of moving data
0: IRQ 4 does not generate requests of moving data
1: IRQ 4 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq3" pos="3" rst="0">
          <comment>state of IRQ 3 generate requests of moving data
0: IRQ 3 does not generate requests of moving data
1: IRQ 3 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq2" pos="2" rst="0">
          <comment>state of IRQ 2 generate requests of moving data
0: IRQ 2 does not generate requests of moving data
1: IRQ 2 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq1" pos="1" rst="0">
          <comment>state of IRQ 1 generate requests of moving data
0: IRQ 1 does not generate requests of moving data
1: IRQ 1 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq0" pos="0" rst="0">
          <comment>state of IRQ 0 generate requests of moving data
0: IRQ 0 does not generate requests of moving data
1: IRQ 0 generate requests of moving data</comment>
        </bits>
      </reg>
      <reg name="axidma_arm_ack_stat" protect="r">
        <bits access="r" name="ack23" pos="23" rst="0">
          <comment>state of ACK 23 generate requests of moving data
0: ACK 23 does not generate requests of moving data
1: ACK 23 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack22" pos="22" rst="0">
          <comment>state of ACK 22 generate requests of moving data
0: ACK 22 does not generate requests of moving data
1: ACK 22 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack21" pos="21" rst="0">
          <comment>state of ACK 21 generate requests of moving data
0: ACK 21 does not generate requests of moving data
1: ACK 21 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack20" pos="20" rst="0">
          <comment>state of ACK 20 generate requests of moving data
0: ACK 20 does not generate requests of moving data
1: ACK 20 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack19" pos="19" rst="0">
          <comment>state of ACK 19 generate requests of moving data
0: ACK 19 does not generate requests of moving data
1: ACK 19 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack18" pos="18" rst="0">
          <comment>state of ACK 18 generate requests of moving data
0: ACK 18 does not generate requests of moving data
1: ACK 18 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack17" pos="17" rst="0">
          <comment>state of ACK 17 generate requests of moving data
0: ACK 17 does not generate requests of moving data
1: ACK 17 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack16" pos="16" rst="0">
          <comment>state of ACK 16 generate requests of moving data
0: ACK 16 does not generate requests of moving data
1: ACK 16 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack15" pos="15" rst="0">
          <comment>state of ACK 15 generate requests of moving data
0: ACK 15 does not generate requests of moving data
1: ACK 15 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack14" pos="14" rst="0">
          <comment>state of ACK 14 generate requests of moving data
0: ACK 14 does not generate requests of moving data
1: ACK 14 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack13" pos="13" rst="0">
          <comment>state of ACK 13 generate requests of moving data
0: ACK 13 does not generate requests of moving data
1: ACK 13 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack12" pos="12" rst="0">
          <comment>state of ACK 12 generate requests of moving data
0: ACK 12 does not generate requests of moving data
1: ACK 12 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack11" pos="11" rst="0">
          <comment>state of ACK 11 generate requests of moving data
0: ACK 11 does not generate requests of moving data
1: ACK 11 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack10" pos="10" rst="0">
          <comment>state of ACK 10 generate requests of moving data
0: ACK 10 does not generate requests of moving data
1: ACK 10 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack9" pos="9" rst="0">
          <comment>state of ACK 9 generate requests of moving data
0: ACK 9 does not generate requests of moving data
1: ACK 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack8" pos="8" rst="0">
          <comment>state of ACK 8 generate requests of moving data
0: ACK 8 does not generate requests of moving data
1: ACK 8 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack7" pos="7" rst="0">
          <comment>state of ACK 7 generate requests of moving data
0: ACK 7 does not generate requests of moving data
1: ACK 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack6" pos="6" rst="0">
          <comment>state of ACK 6 generate requests of moving data
0: ACK 6 does not generate requests of moving data
1: ACK 6 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack5" pos="5" rst="0">
          <comment>state of ACK 5 generate requests of moving data
0: ACK 5 does not generate requests of moving data
1: ACK 5 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack4" pos="4" rst="0">
          <comment>state of ACK 4 generate requests of moving data
0: ACK 4 does not generate requests of moving data
1: ACK 4 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack3" pos="3" rst="0">
          <comment>state of ACK 3 generate requests of moving data
0: ACK 3 does not generate requests of moving data
1: ACK 3 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack2" pos="2" rst="0">
          <comment>state of ACK 2 generate requests of moving data
0: ACK 2 does not generate requests of moving data
1: ACK 2 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack1" pos="1" rst="0">
          <comment>state of ACK 1 generate requests of moving data
0: ACK 1 does not generate requests of moving data
1: ACK 1 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack0" pos="0" rst="0">
          <comment>state of ACK 0 generate requests of moving data
0: ACK 0 does not generate requests of moving data
1: ACK 0 generate requests of moving data</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="axidma_ch_irq_distr" protect="rw">
        <bits access="rw" name="ch11_irq_en0" pos="11" rst="0">
          <comment>channel 11 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch10_irq_en0" pos="10" rst="0">
          <comment>channel 10 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch9_irq_en0" pos="9" rst="0">
          <comment>channel 9 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch8_irq_en0" pos="8" rst="0">
          <comment>channel 8 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch7_irq_en0" pos="7" rst="0">
          <comment>channel 7 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch6_irq_en0" pos="6" rst="0">
          <comment>channel 6 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch5_irq_en0" pos="5" rst="0">
          <comment>channel 5 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch4_irq_en0" pos="4" rst="0">
          <comment>channel 4 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch3_irq_en0" pos="3" rst="0">
          <comment>channel 3 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch2_irq_en0" pos="2" rst="0">
          <comment>channel 2 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch1_irq_en0" pos="1" rst="0">
          <comment>channel 1 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch0_irq_en0" pos="0" rst="0">
          <comment>channel 0 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
      </reg>
      <hole size="224"/>
      <reg name="axidma_c0_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c0_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c0_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c0_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c1_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="1">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="1">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c1_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c1_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c1_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c2_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="2">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="2">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c2_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c2_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c2_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c3_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="3">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="3">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c3_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c3_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c3_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c4_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="4">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="4">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c4_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c4_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c4_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c5_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="5">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="5">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c5_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c5_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c5_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c6_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="6">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="6">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c6_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c6_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c6_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c7_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="7">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="7">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c7_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c7_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c7_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c8_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="8">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="8">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c8_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c8_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c8_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c9_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="9">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="9">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c9_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c9_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c9_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c10_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="10">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="10">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c10_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c10_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c10_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c11_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="11">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="11">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c11_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c11_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c11_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x020c0000" name="AP_AXIDMA" type="ARM_AXIDMA"/>
    <instance address="0x12040000" name="CP_AXIDMA" type="ARM_AXIDMA"/>
  </archive>
  <archive relative="aud_2ad.xml">
    <module category="Periph" name="AUD_2AD">
      <reg name="aud_top_ctl" protect="rw">
        <bits access="rw" name="adc1_sinc_in_sel" pos="15:14" rst="0">
      </bits>
        <bits access="rw" name="adc1_iis_sel" pos="13:12" rst="0">
      </bits>
        <bits access="rw" name="adc1_en_r" pos="11" rst="0">
      </bits>
        <bits access="rw" name="adc1_en_l" pos="10" rst="0">
      </bits>
        <bits access="rw" name="adc_sinc_in_sel" pos="9:8" rst="0">
          <comment>[9:8]=='b00: select adc input data  ;
                   [9:8]=='b01: select dac output loop data ;
                   [9:8]=='b1x: force to zero ;</comment>
        </bits>
        <bits access="rw" name="adc_iis_sel" pos="7:6" rst="0">
          <comment>[6]==0: fm input to aif1; [6]=1: audio codec input to aif1;
                   [7]==0: fm input to aif2; [7]=1: audio codec input to aif2;</comment>
        </bits>
        <bits access="rw" name="dac_iis_sel" pos="5:4" rst="0">
          <comment>[5:4]=='bx1: aif1 output to audio codec ;
                   [5:4]=='b10: aif2 output to audio codec ;
                   [5:4]=='b00: zero output to audio codec ;</comment>
        </bits>
        <bits access="rw" name="adc_en_r" pos="3" rst="0">
          <comment>==1: enable adc left channel;</comment>
        </bits>
        <bits access="rw" name="dac_en_r" pos="2" rst="0">
          <comment>==1: enable dac right channel;</comment>
        </bits>
        <bits access="rw" name="adc_en_l" pos="1" rst="0">
          <comment>==1: enable adc left channel;</comment>
        </bits>
        <bits access="rw" name="dac_en_l" pos="0" rst="0">
          <comment>==1: enable adc right channel;</comment>
        </bits>
      </reg>
      <reg name="aud_clr" protect="rw">
        <bits access="w" name="adc_clr" pos="2" rst="0">
      </bits>
        <bits access="w" name="dac_clr" pos="1" rst="0">
      </bits>
        <bits access="w" name="adc1_clr" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="aud_iis_ctl" protect="rw">
        <bits access="rw" name="adc_iis_ckgate_en" pos="15" rst="0">
      </bits>
        <bits access="rw" name="dac_iis_ckgate_en" pos="14" rst="0">
      </bits>
        <bits access="rw" name="adc_bclk_pol" pos="13" rst="0">
      </bits>
        <bits access="rw" name="dac_bclk_pol" pos="12" rst="0">
      </bits>
        <bits access="rw" name="dac_sample_phase_sel" pos="11" rst="0">
      </bits>
        <bits access="rw" name="adc_iowl" pos="10:9" rst="3">
      </bits>
        <bits access="rw" name="dac_iowl" pos="8:7" rst="3">
      </bits>
        <bits access="rw" name="adc_io_mode" pos="6:5" rst="0">
      </bits>
        <bits access="rw" name="dac_io_mode" pos="4:3" rst="0">
      </bits>
        <bits access="rw" name="adc_lr_sel" pos="2" rst="0">
      </bits>
        <bits access="rw" name="dac_lr_sel" pos="1" rst="0">
      </bits>
        <bits access="rw" name="iis_clkdiv_mode" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="dac_src_ctl" protect="rw">
        <bits access="rw" name="dac_mute_en" pos="15" rst="1">
          <comment>==1: enable mute;</comment>
        </bits>
        <bits access="rw" name="dac_mute_ctl" pos="14" rst="0">
          <comment>==1: enable soft mute;</comment>
        </bits>
        <bits access="rw" name="dac_mute_div_ctl1" pos="13:10" rst="0">
          <comment>dac mute counter1 threshold, step is countrolled by counter 0;</comment>
        </bits>
        <bits access="rw" name="dac_mute_div_ctl0" pos="9:4" rst="63">
          <comment>dac mute counter0 threshold</comment>
        </bits>
        <bits access="rw" name="dac_fs_mode" pos="3:0" rst="4">
          <comment>dac fs frequency
            0:96K
            1:48K
            2:44.1K
            3:32K
            4:24K
            5:22.05K
            6:16K
            7:12K
            8:11.025K
            9:9.6K
            10:8K</comment>
        </bits>
      </reg>
      <reg name="dac_sdm_ctl0" protect="rw">
        <bits access="rw" name="dac_sdm_dolvl" pos="11:8" rst="1">
      </bits>
        <bits access="rw" name="dac_sdm_dilvl" pos="7:4" rst="0">
      </bits>
        <bits access="rw" name="dac_sdm_do" pos="3:2" rst="0">
      </bits>
        <bits access="rw" name="dac_sdm_di" pos="1:0" rst="0">
      </bits>
      </reg>
      <reg name="dac_sdm_ctl1" protect="rw">
        <bits access="rw" name="dac_sdm_soft_rst_r" pos="9" rst="0">
      </bits>
        <bits access="rw" name="dac_sdm_soft_rst_l" pos="8" rst="0">
      </bits>
        <bits access="rw" name="dac_sdm_test" pos="7:0" rst="8">
      </bits>
      </reg>
      <reg name="adc_src_ctl" protect="rw">
        <bits access="rw" name="adc1_src_n" pos="7:4" rst="0">
      </bits>
        <bits access="rw" name="adc_src_n" pos="3:0" rst="0">
          <comment>adc src upsample tap, sample rate=N*4K</comment>
        </bits>
      </reg>
      <reg name="aud_loop_test" protect="rw">
        <bits access="rw" name="loop_adc_path_sel" pos="9" rst="0">
      </bits>
        <bits access="rw" name="loop_fifo_ae_lvl" pos="8:6" rst="4">
      </bits>
        <bits access="rw" name="loop_fifo_af_lvl" pos="5:3" rst="4">
      </bits>
        <bits access="rw" name="loop_path_sel" pos="2:1" rst="0">
      </bits>
        <bits access="rw" name="aud_loop_test" pos="0" rst="0">
          <comment>==1: enable audio adc parallel data loop to dac parallel data path;</comment>
        </bits>
      </reg>
      <reg name="aud_sts0" protect="r">
        <bits access="r" name="aud_int_mask" pos="5:4" rst="0">
      </bits>
        <bits access="r" name="aud_int_raw" pos="3:2" rst="0">
      </bits>
        <bits access="r" name="st_mute" pos="1:0" rst="0">
      </bits>
      </reg>
      <reg name="aud_int_clr" protect="rw">
        <bits access="rw" name="aud_int_clr" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="aud_int_en" protect="rw">
        <bits access="rw" name="aud_int_en" pos="1:0" rst="0">
      </bits>
      </reg>
      <reg name="audif_fifo_ctl" protect="rw">
        <bits access="rw" name="adc_fifo_af_lvl" pos="2:0" rst="3">
      </bits>
      </reg>
      <reg name="aud_dmic_ctl" protect="rw">
        <bits access="rw" name="adc1_dmic_en" pos="7" rst="0">
      </bits>
        <bits access="rw" name="clk_aud_26m_sel" pos="6" rst="0">
          <comment>==0: force to 0 to select 26m audio clock;</comment>
        </bits>
        <bits access="rw" name="adc1_dmic_lr_sel" pos="5" rst="0">
      </bits>
        <bits access="rw" name="adc1_dmic_clk_mode" pos="4:3" rst="0">
      </bits>
        <bits access="rw" name="clk_aud_26m_inv" pos="2" rst="0">
          <comment>==1: invert output mclk ;</comment>
        </bits>
        <bits access="rw" name="adc_dmic_clk_mode" pos="1:0" rst="0">
      </bits>
      </reg>
      <reg name="adc1_iis_ctl" protect="rw">
        <bits access="rw" name="adc1_iis_ckgate_en" pos="6" rst="0">
      </bits>
        <bits access="rw" name="adc1_bclk_pol" pos="5" rst="0">
      </bits>
        <bits access="rw" name="adc1_iowl" pos="4:3" rst="3">
      </bits>
        <bits access="rw" name="adc1_io_mode" pos="2:1" rst="0">
      </bits>
        <bits access="rw" name="adc1_lr_sel" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="dac_sdm_dc_l" protect="rw">
        <bits access="rw" name="dac_sdm_dc_l" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="dac_sdm_dc_h" protect="rw">
        <bits access="rw" name="dac_sdm_dc_h" pos="7:0" rst="0">
      </bits>
      </reg>
      <reg name="audif_ctl0" protect="rw">
        <bits access="rw" name="audif_5p_mode" pos="6" rst="0">
      </bits>
        <bits access="rw" name="ad_sync_sel" pos="5:3" rst="0">
      </bits>
        <bits access="rw" name="adc_fifo_af_lvl_r" pos="2:0" rst="1">
      </bits>
      </reg>
      <reg name="audif_adc_fifo_sts" protect="r">
        <bits access="r" name="audif_adc_fifo_af_r" pos="10" rst="0">
      </bits>
        <bits access="r" name="audif_adc_fifo_empty_r" pos="9" rst="0">
      </bits>
        <bits access="r" name="audif_adc_fifo_full_r" pos="8" rst="0">
      </bits>
        <bits access="r" name="audif_adc_fifo_raddr_r" pos="7:4" rst="0">
      </bits>
        <bits access="r" name="audif_adc_fifo_waddr_r" pos="3:0" rst="0">
      </bits>
      </reg>
      <reg name="audif_dac_fifo_sts" protect="r">
        <bits access="r" name="audif_dac_fifo_empty" pos="9" rst="0">
      </bits>
        <bits access="r" name="audif_dac_fifo_full" pos="8" rst="0">
      </bits>
        <bits access="r" name="audif_dac_fifo_addr_r" pos="7:4" rst="0">
      </bits>
        <bits access="r" name="audif_dac_fifo_addr_w" pos="3:0" rst="0">
      </bits>
      </reg>
      <reg name="audif_sts" protect="r">
        <bits access="r" name="audif_adc_rx_data_ready" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="audif_sts_raw" protect="r">
        <bits access="r" name="audif_adc_fifo_underfl_raw" pos="1" rst="0">
      </bits>
        <bits access="r" name="audif_dac_fifo_ovfl_raw" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="audif_sts_clr" protect="rw">
        <bits access="rw" name="ovfl_sts_clr" pos="1" rst="0">
      </bits>
        <bits access="rw" name="underfl_sts_clr" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="dac_src_step" protect="rw">
        <bits access="rw" name="dac_src_step" pos="11:0" rst="0">
      </bits>
      </reg>
      <reg name="adc_dgain" protect="rw">
        <bits access="rw" name="adc_l_dgain" pos="3:0" rst="0">
          <comment>left adc channel dgain
            4'hf: 16dB
            4'he: 14dB
            4'hd: 12dB
            4'hc: 10dB
            4'hb:  8dB
            4'ha:  6dB
            4'h9:  4dB
            4'h8:  2dB
            4'h7:  0dB
            4'h6:-2dB
            4'h5:-4dB
            4'h4:-6dB
            4'h3:-8dB
            4'h2:-10dB
            4'h1:-12dB
            4'h0:mute</comment>
        </bits>
        <bits access="rw" name="adc_r_dgain" pos="7:4" rst="0">
          <comment>right adc channel dgain
            4'hf: 16dB
            4'he: 14dB
            4'hd: 12dB
            4'hc: 10dB
            4'hb:  8dB
            4'ha:  6dB
            4'h9:  4dB
            4'h8:  2dB
            4'h7:  0dB
            4'h6:-2dB
            4'h5:-4dB
            4'h4:-6dB
            4'h3:-8dB
            4'h2:-10dB
            4'h1:-12dB
            4'h0:mute</comment>
        </bits>
        <bits access="rw" name="adc_dgain_update" pos="8" rst="0">
      </bits>
      </reg>
      <reg name="dac_dgain0" protect="rw">
        <bits access="rw" name="dac_dgain_tone_sel" pos="0" rst="0">
          <comment>right adc channel dgain
            1:sel tone dac tone dgain
            0:sel normal dac dgain</comment>
        </bits>
        <bits access="rw" name="dac_dgain_update" pos="1" rst="0">
      </bits>
      </reg>
      <reg name="dac_dgain1" protect="rw">
        <bits access="rw" name="dac_l_nor_dgain" pos="7:0" rst="0x34">
          <comment>left dac channel dgain
            [5:1] =
            5'h1f:  05dB
            5'h1e:  04dB
            5'h1d:  03dB
            5'h1c:  02dB
            5'h1b:  01dB
            5'h1a:  00dB
            5'h19: -01dB
            5'h18: -02dB
            5'h17: -03dB
            5'h16: -04dB
            5'h15: -05dB
            5'h14: -06dB
            5'h13: -07dB
            5'h12: -08dB
            5'h11: -09dB
            5'h10: -10dB
            5'h0f: -11dB
            5'h0e: -12dB
            5'h0d: -13dB
            5'h0c: -14dB
            5'h0b: -15dB
            5'h0a: -16dB
            5'h09: -17dB
            5'h08: -18dB
            5'h07: -19dB
            5'h06: -20dB
            5'h05: -21dB
            5'h04: -22dB
            5'h03: -23dB
            5'h02: -24dB
            5'h01: -25dB
            5'h00: -26dB
            [0]:1'b1,+0.5dB
            [7]:1'b1,+12dB
            [6]:1'b1,+6dB</comment>
        </bits>
        <bits access="rw" name="dac_r_nor_dgain" pos="15:8" rst="0x34">
          <comment>right dac channel dgain
            detail see  dac_l_nor_dgain[7:0]</comment>
        </bits>
      </reg>
      <reg name="dac_dgain2" protect="rw">
        <bits access="rw" name="dac_l_tone_dgain" pos="7:0" rst="0x34">
          <comment>left dac channel dgain
            detail see  dac_l_nor_dgain[7:0]</comment>
        </bits>
        <bits access="rw" name="dac_r_tone_dgain" pos="15:8" rst="0x34">
          <comment>right dac channel dgain
            detail see  dac_l_nor_dgain[7:0]</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x5150a000" name="AUD_2AD" type="AUD_2AD"/>
  </archive>
  <archive relative="camera.xml">
    <var name="FIFORAM_SIZE" value="80"/>
    <module category="Periph" name="CAMERA">
      <reg name="ctrl" protect="rw">
        <bits access="rw" name="enable" pos="0" rst="0">
          <options>
            <default/>
            <option name="ENABLE" value="1"/>
            <option name="DISABLE" value="0"/>
          </options>
          <comment>Enable camera controller,high active.</comment>
        </bits>
        <bits access="rw" name="dctenable" pos="1" rst="0">
          <comment>Enable camera controller,high active.</comment>
        </bits>
        <bits access="rw" name="buf_enable" pos="2" rst="0">
    </bits>
        <bits access="rw" name="rgb_rfirst" pos="3" rst="0">
    </bits>
        <bits access="rw" name="dataformat" pos="5:4" rst="0">
          <options>
            <default/>
            <option name="RGB565" value="0"/>
            <option name="YUV422" value="1"/>
            <option name="JPEG" value="2"/>
            <option name="RESERVE" value="3"/>
          </options>
          <comment>
            &quot;0&quot; = RGB565.
            <br/>
             &quot;1&quot; = YUV422.
            <br/>
             &quot;2&quot; = Compressed Data.
            <br/>
             &quot;3&quot; = Reserved.
          </comment>
        </bits>
        <bits access="rw" name="cfg_cam_c2cse" pos="7:6" rst="0">
    </bits>
        <bits access="rw" name="reset_pol" pos="8" rst="1">
          <options>
            <default/>
            <option name="INVERT" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = keep output camera reset polarity.
            <br/>
             '1' = invert output camera reset polarity.
          </comment>
        </bits>
        <bits access="rw" name="pwdn_pol" pos="9" rst="0">
          <options>
            <default/>
            <option name="INVERT" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = keep output camera power down polarity.
            <br/>
             '1' = invert output camera power down polarity.
          </comment>
        </bits>
        <bits access="rw" name="vsync_pol" pos="10" rst="0">
          <options>
            <default/>
            <option name="INVERT" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = keep input VSYNC polarity.
            <br/>
             '1' = invert input VSYNC polarity.
          </comment>
        </bits>
        <bits access="rw" name="href_pol" pos="11" rst="0">
          <options>
            <default/>
            <option name="INVERT" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = keep input HREF polarity so data is sampled when HREF high.
            <br/>
             '1' = invert input HREF polarity so data is sampled when HREF low.
          </comment>
        </bits>
        <bits access="rw" name="pixclk_pol" pos="12" rst="0">
          <options>
            <default/>
            <option name="INVERT" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = keep pix clk polarity.
            <br/>
             '1' = invert pix clk polarity.
          </comment>
        </bits>
        <bits access="rw" name="vsync_drop" pos="14" rst="1">
          <options>
            <default/>
            <option name="DROP" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = VSYNC irq always exists when Frame decimation is enabled.
            <br/>
             '1' = VSYNC irq will drop when Frame data are dropped in decipation.
          </comment>
        </bits>
        <bits access="rw" name="decimfrm" pos="17:16" rst="0">
          <options>
            <default/>
            <option name="ORIGINAL" value="0"/>
            <option name="DIV_2" value="1"/>
            <option name="DIV_3" value="2"/>
            <option name="DIV_4" value="3"/>
          </options>
          <comment>
            &quot;0&quot;= All frame data will be sent.
            <br/>
             &quot;1&quot;= only one frame out of two (1/2) will be sent.
            <br/>
             &quot;2&quot;= only one frame out of three (1/3) will be sent.
            <br/>
             &quot;3&quot;= only one frame out of four (1/4) will be sent.
          </comment>
        </bits>
        <bits access="rw" name="decimcol" pos="19:18" rst="0">
          <options>
            <default/>
            <option name="ORIGINAL" value="0"/>
            <option name="DIV_2" value="1"/>
            <option name="DIV_3" value="2"/>
            <option name="DIV_4" value="3"/>
          </options>
          <comment>
            &quot;0&quot;= Pixel Decimation Disabled.
            <br/>
             &quot;1&quot;= Pixel Decimation 1/2.
            <br/>
             &quot;2&quot;= Pixel Decimation 1/3.
            <br/>
             &quot;3&quot;= Pixel Decimation 1/4.
          </comment>
        </bits>
        <bits access="rw" name="decimrow" pos="21:20" rst="0">
          <options>
            <default/>
            <option name="ORIGINAL" value="0"/>
            <option name="DIV_2" value="1"/>
            <option name="DIV_3" value="2"/>
            <option name="DIV_4" value="3"/>
          </options>
          <comment>
            &quot;0&quot;= line Decimation Disabled.
            <br/>
             &quot;1&quot;= line Decimation 1/2.
            <br/>
             &quot;2&quot;= line Decimation 1/3.
            <br/>
             &quot;3&quot;= line Decimation 1/4.
          </comment>
        </bits>
        <bits access="rw" name="reorder" pos="26:24" rst="0">
          <comment>
            Controls the Re-ordering of the FIFO data.
            <br/>
             In following table, for input data, right comes before left. So YUYV means V comes first.
            <br/>
             for output data, right data is the LSB. So YUYV means V is stored in low 8-bit (byte0) of 32-bit word.
            <br/>
            <br/>
             If Bit 26 is '1', byte2 and byte0 is Y.
            <br/>
             If Bit 25 is '1', both byte2/byte3 and byte1/byte0 interchange.
            <br/>
             If Bit 24 is '1', byte U and V should interchange. (UV bytes can be decided using bit 26).
            <br/>
            <br/>
             input YUYV, output YUYV: &quot;000&quot;
            <br/>
             input YVYU, output YUYV: &quot;001&quot;
            <br/>
             input UYVY, output YUYV: &quot;110&quot;
            <br/>
             input VYUY, output YUYV: &quot;111&quot;
            <br/>
            <br/>
             input YUYV, output UYVY: &quot;010&quot;
            <br/>
             input YVYU, output UYVY: &quot;011&quot;
            <br/>
             input UYVY, output UYVY: &quot;100&quot;
            <br/>
             input VYUY, output UYVY: &quot;101&quot;
            <br/>
            <br/>
             input YUYV, output YVYU: &quot;001&quot;
            <br/>
             input YVYU, output YVYU: &quot;000&quot;
            <br/>
             input UYVY, output YVYU: &quot;111&quot;
            <br/>
             input VYUY, output YVYU: &quot;110&quot;
            <br/>
            <br/>
             input YUYV, output VYUY: &quot;011&quot;
            <br/>
             input YVYU, output VYUY: &quot;010&quot;
            <br/>
             input UYVY, output VYUY: &quot;101&quot;
            <br/>
             input VYUY, output VYUY: &quot;100&quot;
            <br/>
            <br/>
             Decimation will reorder data flow also. Input UYVY becomes YUVY after decimation.
                      This reorder is corrected using Bit 26 infomation.
          </comment>
        </bits>
        <bits access="rw" name="cropen" pos="28" rst="0">
          <options>
            <default/>
            <option name="ENABLE" value="1"/>
            <option name="DISABLE" value="0"/>
          </options>
          <comment>
            &quot;0&quot;= Cropping Disabled.
            <br/>
             &quot;1&quot;= Cropping Enabled.
            <br/>
             Note: this bit should set to '0' when bit field &quot;DataFormat&quot; is &quot;10&quot; (compressed data)
          </comment>
        </bits>
        <bits access="rw" name="bist mode" pos="30" rst="0">
          <options>
            <default/>
            <option name="BIST" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>In Bist Mode, FIFO RAM are read and write by its address, FIFO mode is disabled.</comment>
        </bits>
        <bits access="rw" name="test" pos="31" rst="0">
          <options>
            <default/>
            <option name="TEST" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>Debug only. A RGB565 test card is sent to system bus instead of real data from sensor.</comment>
        </bits>
      </reg>
      <reg name="status" protect="r">
        <bits access="r" name="ovfl" pos="0" rst="0">
          <comment>
            '1' = FIFO over-write IRQ status.
            <br/>
             Write to corresponding bit in IRQ CLEAR register will clear this bit.
          </comment>
        </bits>
        <bits access="r" name="vsync_r" pos="1" rst="0">
          <comment>
            '1' = VSYNC rising edge IRQ status
            <br/>
             Write to corresponding bit in IRQ CLEAR register will clear this bit.
          </comment>
        </bits>
        <bits access="r" name="vsync_f" pos="2" rst="0">
          <comment>
            '1' = VSYNC falling edge IRQ status
            <br/>
             Write to corresponding bit in IRQ CLEAR register will clear this bit.
          </comment>
        </bits>
        <bits access="r" name="dma done" pos="3" rst="0">
          <comment>
            '1' = DMA Done IRQ status
            <br/>
             Write to corresponding bit in IRQ CLEAR register will clear this bit.
          </comment>
        </bits>
        <bits access="r" name="fifo empty" pos="4" rst="1">
          <comment>'1' = FIFO Empty status, not clear-able.</comment>
        </bits>
        <bits access="r" name="spi ovfl" pos="5" rst="0">
        </bits>
      </reg>
      <reg name="data" protect="r">
        <comment>Read in the receive FIFO</comment>
      </reg>
      <reg name="irq mask" protect="rw">
        <bits access="rw" name="ovfl" pos="0" rst="0">
          <comment>'1' = FIFO over-write enable</comment>
        </bits>
        <bits access="rw" name="vsync_r" pos="1" rst="0">
          <comment>'1' = VSYNC rising edge enable</comment>
        </bits>
        <bits access="rw" name="vsync_f" pos="2" rst="0">
          <comment>'1' = VSYNC falling edge enable</comment>
        </bits>
        <bits access="rw" name="dma done" pos="3" rst="0">
          <comment>'1' = DMA Done enable</comment>
        </bits>
      </reg>
      <reg name="irq clear" protect="w">
        <bits access="w" name="ovfl" pos="0" rst="0">
          <comment>Write '1' to clear FIFO over-write interrupt</comment>
        </bits>
        <bits access="w" name="vsync_r" pos="1" rst="0">
          <comment>Write '1' to clear VSYNC rising edge interrupt</comment>
        </bits>
        <bits access="w" name="vsync_f" pos="2" rst="0">
          <comment>Write '1' to clear VSYNC falling edge interrupt</comment>
        </bits>
        <bits access="w" name="dma done" pos="3" rst="0">
          <comment>Write '1' to clear DMA Done interrupt</comment>
        </bits>
      </reg>
      <reg name="irq cause" protect="r">
        <bits access="r" name="ovfl" pos="0" rst="0">
          <comment>'1' = FIFO over-write cause</comment>
        </bits>
        <bits access="r" name="vsync_r" pos="1" rst="0">
          <comment>'1' = VSYNC rising edge cause</comment>
        </bits>
        <bits access="r" name="vsync_f" pos="2" rst="0">
          <comment>'1' = VSYNC falling edge cause</comment>
        </bits>
        <bits access="r" name="dma done" pos="3" rst="0">
          <comment>'1' = DMA Done cause</comment>
        </bits>
      </reg>
      <reg name="cmd set" protect="rw">
        <bits access="rs" name="pwdn" pos="0" rst="1">
          <comment>Power down pin of CMOS sensor .</comment>
        </bits>
        <bits access="rs" name="reset" pos="4" rst="1">
          <comment>
            Reset pin of CMOS sensor.
            <br/>
            Active Low.
          </comment>
        </bits>
        <bits access="s" name="fifo reset" pos="8" rst="0">
          <comment>For the software to clear FIFO. This bit is auto-reset to 0.</comment>
        </bits>
      </reg>
      <reg name="cmd clr" protect="rw">
        <bits access="rc" name="pwdn" pos="0" rst="1">
          <comment>Power down pin of CMOS sensor .</comment>
        </bits>
        <bits access="rc" name="reset" pos="4" rst="1">
          <comment>Reset pin of CMOS sensor.</comment>
        </bits>
      </reg>
      <reg name="dstwincol" protect="rw">
        <bits access="rw" name="dstwincolstart" pos="11:0" rst="0">
          <comment>start pixel of cropped window.</comment>
        </bits>
        <bits access="rw" name="dstwincolend" pos="27:16" rst="0">
          <comment>end pixel of cropped window.</comment>
        </bits>
      </reg>
      <reg name="dstwinrow" protect="rw">
        <bits access="rw" name="dstwinrowstart" pos="11:0" rst="0">
          <comment>start line of cropped window.</comment>
        </bits>
        <bits access="rw" name="dstwinrowend" pos="27:16" rst="0">
          <comment>end line of cropped window.</comment>
        </bits>
      </reg>
      <reg name="scl config" protect="rw">
        <bits access="rw" name="scale en" pos="0" rst="0">
        </bits>
        <bits access="rw" name="data_out_swap" pos="4" rst="0">
          <comment>swap camera data output [15:0],[31:16].</comment>
        </bits>
        <bits access="rw" name="scale col" pos="9:8" rst="0">
        </bits>
        <bits access="rw" name="scale row" pos="17:16" rst="0">
        </bits>
      </reg>
      <reg name="spi camera reg0" protect="rw">
        <bits access="rw" name="camera_spi_slave_en" pos="0" rst="0">
          <comment>spi slave enable.</comment>
        </bits>
        <bits access="rw" name="camera_spi_master_en" pos="1" rst="0">
          <comment>spi master enable.</comment>
        </bits>
        <bits access="rw" name="yuv_out_format" pos="4:2" rst="0">
          <comment>yuv out format.
			  3'b000: data_serial_mux = {Y0,U0,Y1,V0};
        3'b001: data_serial_mux = {Y0,V0,Y1,U0};
        3'b010: data_serial_mux = {U0,Y0,V0,Y1};
        3'b011: data_serial_mux = {U0,Y1,V0,Y0};
        3'b100: data_serial_mux = {V0,Y1,U0,Y0};
        3'b101: data_serial_mux = {V0,Y0,U0,Y1};
        3'b110: data_serial_mux = {Y1,V0,Y0,U0};
        3'b111: data_serial_mux = {Y1,U0,Y0,V0};</comment>
        </bits>
        <bits access="rw" name="overflow_rstn_only_vsync_low" pos="5" rst="0">
          <comment>overflow rstn only vsync low.</comment>
        </bits>
        <bits access="rw" name="overflow_observe_only_vsync_low" pos="6" rst="0">
          <comment>overflow_observe_only_vsync_low.</comment>
        </bits>
        <bits access="rw" name="overflow_rstn_en" pos="7" rst="0">
          <comment>overflow_rstn enable</comment>
        </bits>
        <bits access="rw" name="big_end_dis" pos="8" rst="0">
          <comment>big_end_dis</comment>
        </bits>
        <bits access="rw" name="overflow_inv" pos="9" rst="0">
          <comment>overflow inv control</comment>
        </bits>
        <bits access="rw" name="href_inv" pos="10" rst="0">
          <comment>href inv control</comment>
        </bits>
        <bits access="rw" name="vsync_inv" pos="11" rst="0">
          <comment>vsync inv control</comment>
        </bits>
        <bits access="rw" name="block_num_per_line" pos="21:12" rst="0">
          <comment>block_num_per_line[9:0] pixels num of a line</comment>
        </bits>
        <bits access="rw" name="line_num_per_frame" pos="31:22" rst="0">
          <comment>line_num_per_frame[9:0] lines num of a frame</comment>
        </bits>
      </reg>
      <reg name="spi camera reg1" protect="rw">
        <bits access="rw" name="camera_clk_div_num" pos="15:0" rst="0">
          <comment>camera_clk_div_num</comment>
        </bits>
        <bits access="rw" name="cts_spi_master_reg" pos="16" rst="0">
          <comment>cts_spi_master_reg</comment>
        </bits>
        <bits access="rw" name="ssn_cm_inv" pos="17" rst="0">
          <comment>ssn_cm inv control</comment>
        </bits>
        <bits access="rw" name="sck_cm_inv" pos="18" rst="0">
          <comment>sck_cm inv control</comment>
        </bits>
        <bits access="rw" name="ssn_spi_oenb_dr" pos="19" rst="0">
          <comment>ssn_spi_oen select, 1:from reg  0: from logic</comment>
        </bits>
        <bits access="rw" name="ssn_spi_oenb_reg" pos="20" rst="0">
          <comment>ssn_spi_oenb reg</comment>
        </bits>
        <bits access="rw" name="sck_spi_oenb_dr" pos="21" rst="0">
          <comment>sck_spi_oenb select, 1:from reg 0:from logic</comment>
        </bits>
        <bits access="rw" name="sck_spi_oenb_reg" pos="22" rst="0">
          <comment>sck_spi_oenb reg</comment>
        </bits>
        <bits access="rw" name="sdo_spi_swap" pos="29" rst="0">
          <comment>sdo_spi_swap reg,swap camera_spi_0 and camera_spi_1</comment>
        </bits>
        <bits access="rw" name="clk_inv" pos="30" rst="0">
          <comment>clk inv control</comment>
        </bits>
        <bits access="rw" name="sck_ddr_en" pos="31" rst="0">
          <comment>sck double edge enable</comment>
        </bits>
      </reg>
      <reg name="spi camera reg2" protect="rw">
        <bits access="rw" name="ssn_wait_length" pos="7:0" rst="0">
          <comment>ssn_wait_length[7:0]</comment>
        </bits>
        <bits access="rw" name="init_wait_length" pos="15:8" rst="0">
          <comment>init_wait_length[7:0]</comment>
        </bits>
        <bits access="rw" name="word_num_per_block" pos="23:16" rst="0">
          <comment>word_num_per_block[7:0]</comment>
        </bits>
        <bits access="rw" name="ssn_cs_delay" pos="25:24" rst="0">
          <comment>ssn_cs_delay[1:0]</comment>
        </bits>
        <bits access="rw" name="data_receive_choose_bit" pos="27:26" rst="0">
          <comment>data_receive_choose_bit[1:0]</comment>
        </bits>
        <bits access="rw" name="ready_cs_inv" pos="28" rst="0">
          <comment>ready_cs_inv</comment>
        </bits>
        <bits access="rw" name="ssn_cs_inv" pos="29" rst="0">
          <comment>ssn_cs_inv</comment>
        </bits>
        <bits access="rw" name="eco_bypass_isp" pos="31" rst="0">
          <comment>eco_bypass_isp</comment>
        </bits>
      </reg>
line_wait_length[15:0]
      <reg name="spi camera reg3" protect="rw">
        <bits access="rw" name="line_wait_length" pos="15:0" rst="0">
          <comment>line_wait_length</comment>
        </bits>
        <bits access="rw" name="block_wait_length" pos="23:16" rst="0">
          <comment>block_wait_length[7:0]</comment>
        </bits>
        <bits access="rw" name="ssn_high_length" pos="31:24" rst="0">
          <comment>ssn_high_length[7:0]</comment>
        </bits>
      </reg>
      <reg name="spi camera reg4" protect="rw">
        <bits access="rw" name="camera_spi_master_en_2" pos="0" rst="0">
          <comment>camera_spi_master no ssn mode enable</comment>
        </bits>
        <bits access="rw" name="sdo_line_choose_bit" pos="2:1" rst="0">
          <comment>sdo_line_choose_bit[1:0] 0:1 line 1: 2lines 2:4lines</comment>
        </bits>
        <bits access="rw" name="data_size_choose_bit" pos="3" rst="0">
          <comment>data_size_choose_bit  1: from reg  0:from logic</comment>
        </bits>
        <bits access="rw" name="image_height_choose_bit" pos="4" rst="0">
          <comment>image_height_choose_bit  1: from reg  0:from logic</comment>
        </bits>
        <bits access="rw" name="image_width_choose_bit" pos="5" rst="0">
          <comment>image_width_choose_bit 1: from reg  0:from logic</comment>
        </bits>
        <bits access="rw" name="block_num_per_packet" pos="15:6" rst="0">
          <comment>block_num_per_packet[9:0]</comment>
        </bits>
        <bits access="rw" name="spi_data0_phase_sel" pos="17:16" rst="0">
          <comment>0: spi data0 delay 0
			          1: spi data0 delay 2 cycles spi_cam_clk
			          2: spi data0 delay 3 cycles spi_cam_clk
			          3: spi data0 delay 4 cycles spi_cam_clk</comment>
        </bits>
        <bits access="rw" name="spi_data1_phase_sel" pos="19:18" rst="0">
          <comment>0: spi data1 delay 0
			          1: spi data1 delay 2 cycles spi_cam_clk
			          2: spi data1 delay 3 cycles spi_cam_clk
			          3: spi data1 delay 4 cycles spi_cam_clk</comment>
        </bits>
      </reg>
      <reg name="spi camera reg5" protect="rw">
        <bits access="rw" name="sync_code" pos="23:0" rst="0">
          <comment>sync code</comment>
        </bits>
      </reg>
      <reg name="spi camera reg6" protect="rw">
        <bits access="rw" name="packet_id_data_start" pos="7:0" rst="0">
          <comment>packet_id_data_start</comment>
        </bits>
        <bits access="rw" name="packet_id_line_start" pos="15:8" rst="0">
          <comment>packet_id_line_start</comment>
        </bits>
        <bits access="rw" name="packet_id_frame_end" pos="23:16" rst="0">
          <comment>packet_id_frame_end</comment>
        </bits>
        <bits access="rw" name="packet_id_frame_start" pos="31:24" rst="0">
          <comment>packet_id_frame_start</comment>
        </bits>
      </reg>
      <reg name="spi camera obs0" protect="rw">
        <bits access="ro" name="line_id[15:0]" pos="15:0" rst="0">
          <comment>line_id[15:0]</comment>
        </bits>
        <bits access="ro" name="data_id[7:0]" pos="23:16" rst="0">
          <comment>data_id[7:0]</comment>
        </bits>
        <bits access="ro" name="observe_data_size_wrong" pos="24" rst="0">
          <comment>observe_data_size_wrong</comment>
        </bits>
        <bits access="ro" name="observe_image_height_wrong" pos="25" rst="0">
          <comment>observe_image_height_wrong</comment>
        </bits>
        <bits access="ro" name="observe_image_width_wrong" pos="26" rst="0">
          <comment>observe_image_width_wrong</comment>
        </bits>
        <bits access="ro" name="observe_line_num_wrong" pos="27" rst="0">
          <comment>observe_line_num_wrong</comment>
        </bits>
        <bits access="ro" name="observe_data_id_wrong" pos="28" rst="0">
          <comment>observe_data_id_wrong</comment>
        </bits>
      </reg>
      <reg name="spi camera obs1" protect="rw">
        <bits access="ro" name="image_height" pos="15:0" rst="0">
          <comment>image_height[15:0]</comment>
        </bits>
        <bits access="ro" name="image_width" pos="31:16" rst="0">
          <comment>image_width[15:0]</comment>
        </bits>
      </reg>
      <reg name="csi config reg0" protect="rw">
        <bits access="rw" name="num_d_term_en" pos="7:0" rst="8">
          <comment>num_d_term_en[7:0]  term time reg</comment>
        </bits>
        <bits access="rw" name="cur_frame_line_num" pos="20:8" rst="240">
          <comment>cur_frame_line_num[12:0]</comment>
        </bits>
        <bits access="rw" name="data_lp_in_choose_bit" pos="22:21" rst="0">
          <comment>data_lp_in_choose_bit[1:0]</comment>
        </bits>
        <bits access="rw" name="clk_lp_inv" pos="23" rst="0">
          <comment>clk_lp inv</comment>
        </bits>
        <bits access="rw" name="trail_data_wrong_choose_bit" pos="24" rst="0">
          <comment>trail_data_wrong_choose_bit 1:secelt trail1  0:select trail0</comment>
        </bits>
        <bits access="rw" name="sync_bypass" pos="25" rst="0">
          <comment>sync_bypass</comment>
        </bits>
        <bits access="rw" name="rdata_bit_inv_en" pos="26" rst="0">
          <comment>rdata_bit_inv en</comment>
        </bits>
        <bits access="rw" name="hs_sync_find_en" pos="27" rst="0">
          <comment>hs_sync_find en</comment>
        </bits>
        <bits access="rw" name="line_packet_enable" pos="28" rst="0">
          <comment>line_packet_enable</comment>
        </bits>
        <bits access="rw" name="ecc_bypass" pos="29" rst="0">
          <comment>ecc_bypass</comment>
        </bits>
        <bits access="rw" name="data_lane_choose_bit" pos="30" rst="0">
          <comment>data_lane_choose_bit  1:select lane2  0:select lane1</comment>
        </bits>
        <bits access="rw" name="csi_module_enable" pos="31" rst="0">
          <comment>csi_module_enable</comment>
        </bits>
      </reg>
      <reg name="csi config reg1" protect="rw">
        <bits access="rw" name="num_hs_settle" pos="7:0" rst="8">
          <comment>num_hs_settle[7:0]  set hs settle time</comment>
        </bits>
        <bits access="rw" name="lp_data_length_choose_bit" pos="10:8" rst="0">
          <comment>lp_data_length_choose_bit[2:0]  set data length</comment>
        </bits>
        <bits access="rw" name="data_clk_lp_posedge_choose" pos="13:11" rst="0">
          <comment>data_clk_lp_posedge_choose[2:0]  select delay cycles</comment>
        </bits>
        <bits access="rw" name="clk_lp_ck_inv" pos="14" rst="0">
          <comment>clk_lp_ck_inv</comment>
        </bits>
        <bits access="rw" name="rclr_mask_en" pos="15" rst="1">
          <comment>rclr_mask_en</comment>
        </bits>
        <bits access="rw" name="rinc_mask_en" pos="16" rst="1">
          <comment>rinc_mask_en</comment>
        </bits>
        <bits access="rw" name="hs_enable_mask_en" pos="17" rst="1">
          <comment>hs_enable_mask_en</comment>
        </bits>
        <bits access="rw" name="den_csi_inv_bit" pos="18" rst="0">
          <comment>den_csi_inv_bit</comment>
        </bits>
        <bits access="rw" name="hsync_csi_inv_bit" pos="19" rst="0">
          <comment>hsync_csi_inv_bit</comment>
        </bits>
        <bits access="rw" name="vsync_csi_inv_bit" pos="20" rst="0">
          <comment>vsync_csi_inv_bit</comment>
        </bits>
        <bits access="rw" name="hs_data2_enable_reg" pos="21" rst="0">
          <comment>hs_data2_enable_reg</comment>
        </bits>
        <bits access="rw" name="hs_data1_enable_reg" pos="22" rst="0">
          <comment>hs_data1_enable_reg</comment>
        </bits>
        <bits access="rw" name="hs_data1_enable_choose_bit" pos="23" rst="0">
          <comment>hs_data1_enable_choose_bit</comment>
        </bits>
        <bits access="rw" name="hs_data1_enable_dr" pos="24" rst="0">
          <comment>hs_data1_enable_dr 1:select reg  0:select logic</comment>
        </bits>
        <bits access="rw" name="data2_terminal_enable_reg" pos="25" rst="0">
          <comment>data2_terminal_enable_reg</comment>
        </bits>
        <bits access="rw" name="data1_terminal_enable_reg" pos="26" rst="0">
          <comment>data1_terminal_enable_reg</comment>
        </bits>
        <bits access="rw" name="data1_terminal_enable_dr" pos="27" rst="0">
          <comment>data1_terminal_enable_dr 1:select reg  0:select logic</comment>
        </bits>
        <bits access="rw" name="lp_data_interrupt_clr" pos="28" rst="0">
          <comment>lp_data_interrupt_clr, clear flag</comment>
        </bits>
        <bits access="rw" name="lp_cmd_interrupt_clr" pos="29" rst="0">
          <comment>lp_cmd_interrupt_clr, clear flag</comment>
        </bits>
        <bits access="rw" name="lp_data_clr" pos="30" rst="0">
          <comment>lp_data_clr, clear data out</comment>
        </bits>
        <bits access="rw" name="lp_cmd_clr" pos="31" rst="0">
          <comment>lp_cmd_clr, clear cmd out</comment>
        </bits>
      </reg>
      <reg name="csi config reg2" protect="rw">
        <bits access="rw" name="num_hs_settle_clk" pos="15:0" rst="4096">
          <comment>num_hs_settle_clk[15:0], set hs settle counter</comment>
        </bits>
        <bits access="rw" name="num_c_term_en" pos="31:16" rst="4112">
          <comment>num_c_term_en[15:0],set clk term counter</comment>
        </bits>
      </reg>
      <reg name="csi config reg3" protect="rw">
        <bits access="rw" name="clk_lp_in_choose_bit" pos="7:6" rst="0">
          <comment>clk_lp_in_choose_bit</comment>
        </bits>
        <bits access="rw" name="pu_lprx_reg" pos="8" rst="0">
          <comment>pu_lprx_reg</comment>
        </bits>
        <bits access="rw" name="pu_hsrx_reg" pos="9" rst="0">
          <comment>pu_hsrx_reg</comment>
        </bits>
        <bits access="rw" name="pu_dr" pos="10" rst="0">
          <comment>pu_dr, 1:select reg  0:select logic</comment>
        </bits>
        <bits access="rw" name="data_pnsw_reg" pos="11" rst="0">
          <comment>data_pnsw_reg</comment>
        </bits>
        <bits access="rw" name="hs_clk_enable_reg" pos="12" rst="0">
          <comment>hs_clk_enable_reg</comment>
        </bits>
        <bits access="rw" name="hs_clk_enable_choose_bit" pos="13" rst="0">
          <comment>hs_clk_enable_choose_bit</comment>
        </bits>
        <bits access="rw" name="hs_clk_enable_dr" pos="14" rst="0">
          <comment>hs_clk_enable_dr  1:select reg  0:select logic</comment>
        </bits>
        <bits access="rw" name="clk_terminal_enable_reg" pos="15" rst="0">
          <comment>clk_terminal_enable_reg</comment>
        </bits>
        <bits access="rw" name="clk_terminal_enable_dr" pos="16" rst="0">
          <comment>clk_terminal_enable_dr   1:select reg  0:select logic</comment>
        </bits>
        <bits access="rw" name="observe_reg_5_low8_choose" pos="17" rst="0">
          <comment>observe_reg_5_low8_choose</comment>
        </bits>
        <bits access="rw" name="ecc_error_flag_reg" pos="18" rst="0">
          <comment>ecc_error_flag_reg</comment>
        </bits>
        <bits access="rw" name="ecc_error_dr" pos="19" rst="0">
          <comment>ecc_error_dr</comment>
        </bits>
        <bits access="rw" name="csi_channel_sel" pos="20" rst="0">
          <comment>csi_channel_sel</comment>
        </bits>
        <bits access="rw" name="two_lane_bit_reverse" pos="21" rst="0">
          <comment>two_lane_bit_reverse, reverse high and low 8bit</comment>
        </bits>
        <bits access="rw" name="data2_lane_bit_reverse" pos="22" rst="0">
          <comment>data2_lane_bit_reverse 1:select revert data</comment>
        </bits>
        <bits access="rw" name="data1_lane_bit_reverse" pos="23" rst="0">
          <comment>data1_lane_bit_reverse 1:select revert data</comment>
        </bits>
        <bits access="rw" name="data2_hs_no_mask" pos="24" rst="0">
          <comment>data2_hs_no_mask  1:data only valid when sync assert</comment>
        </bits>
        <bits access="rw" name="data1_hs_no_mask" pos="25" rst="0">
          <comment>data1_hs_no_mask  1:data only valid when sync assert</comment>
        </bits>
        <bits access="rw" name="pu_lprx_d2_reg" pos="26" rst="0">
          <comment>pu_lprx_d2_reg</comment>
        </bits>
        <bits access="rw" name="pu_lprx_d1_reg" pos="27" rst="0">
          <comment>pu_lprx_d1_reg</comment>
        </bits>
        <bits access="rw" name="clk_edge_sel" pos="29" rst="0">
          <comment>clk_edge_sel</comment>
        </bits>
        <bits access="rw" name="clk_x2_sel" pos="30" rst="0">
          <comment>clk_x2_sel</comment>
        </bits>
        <bits access="rw" name="single_data_lane_en" pos="31" rst="0">
          <comment>single_data_lane_en  1:1lane  0:2lanes</comment>
        </bits>
      </reg>
      <reg name="csi config reg4" protect="rw">
        <bits access="rw" name="num_hs_clk_useful" pos="30:0" rst="0">
          <comment>num_hs_clk_useful[30:0]   hs clk useful counter</comment>
        </bits>
        <bits access="rw" name="num_hs_clk_useful_en" pos="31" rst="0">
          <comment>num_hs_clk_useful_en</comment>
        </bits>
      </reg>
      <reg name="csi config reg5" protect="rw">
        <bits access="rw" name="vc_id_set" pos="1:0" rst="0">
          <comment>vc_id_set[1:0]</comment>
        </bits>
        <bits access="rw" name="data_lp_inv" pos="2" rst="0">
          <comment>data_lp_inv</comment>
        </bits>
        <bits access="rw" name="fifo_rclr_8809p_reg" pos="3" rst="0">
          <comment>fifo_rclr_8809p_reg</comment>
        </bits>
        <bits access="rw" name="fifo_wclr_8809p_reg" pos="4" rst="0">
          <comment>fifo_wclr_8809p_reg</comment>
        </bits>
        <bits access="rw" name="hs_sync_16bit_8809p_mode" pos="5" rst="0">
          <comment>hs_sync_16bit_8809p_mode</comment>
        </bits>
        <bits access="rw" name="d_term_small_8809p_en" pos="6" rst="0">
          <comment>d_term_small_8809p_en</comment>
        </bits>
        <bits access="rw" name="data_line_inv_8809p_en" pos="7" rst="0">
          <comment>data_line_inv_8809p_en</comment>
        </bits>
        <bits access="rw" name="hs_enable_8809p_mode" pos="8" rst="0">
          <comment>hs_enable_8809p_mode</comment>
        </bits>
        <bits access="rw" name="sp_to_trail_8809p_en" pos="9" rst="0">
          <comment>sp_to_trail_8809p_en</comment>
        </bits>
        <bits access="rw" name="trail_wrong_8809p_bypass" pos="10" rst="0">
          <comment>trail_wrong_8809p_bypass</comment>
        </bits>
        <bits access="rw" name="rinc_trail_8809p_bypass" pos="11" rst="0">
          <comment>rinc_trail_8809p_bypass</comment>
        </bits>
        <bits access="rw" name="hs_data_enable_8809p_mode" pos="12" rst="0">
          <comment>hs_data_enable_8809p_mode</comment>
        </bits>
        <bits access="rw" name="hs_clk_enable_8809p_mode" pos="13" rst="0">
          <comment>hs_clk_enable_8809p_mode</comment>
        </bits>
        <bits access="rw" name="data_type_re_check_en" pos="14" rst="0">
          <comment>data_type_re_check_en</comment>
        </bits>
        <bits access="rw" name="sync_id_reg" pos="22:15" rst="0">
          <comment>sync_id_reg</comment>
        </bits>
        <bits access="rw" name="sync_id_dr" pos="23" rst="0">
          <comment>sync_id_dr</comment>
        </bits>
        <bits access="rw" name="csi_observe_choose_bit" pos="28:24" rst="0">
          <comment>csi_observe_choose_bit</comment>
        </bits>
        <bits access="rw" name="crc_error_flag_reg" pos="29" rst="0">
          <comment>crc_error_flag_reg</comment>
        </bits>
        <bits access="rw" name="crc_error_flag_dr" pos="30" rst="0">
          <comment>crc_error_flag_dr  1:select reg 0:select logic</comment>
        </bits>
        <bits access="rw" name="csi_rinc_new_mode_dis" pos="31" rst="0">
          <comment>csi_rinc_new_mode_dis</comment>
        </bits>
      </reg>
      <reg name="csi config reg6" protect="rw">
        <bits access="rw" name="data_type_dp_reg" pos="5:0" rst="0">
          <comment>data_type_dp_reg[5:0],  set data type</comment>
        </bits>
        <bits access="rw" name="data_type_le_reg" pos="11:6" rst="0">
          <comment>data_type_le_reg  line end type</comment>
        </bits>
        <bits access="rw" name="data_type_ls_reg" pos="17:12" rst="0">
          <comment>data_type_ls_reg  line start type</comment>
        </bits>
        <bits access="rw" name="data_type_fe_reg" pos="23:18" rst="0">
          <comment>data_type_fe_reg  frame end type</comment>
        </bits>
        <bits access="rw" name="data_type_fs_reg" pos="29:24" rst="0">
          <comment>data_type_fs_reg  frame start type</comment>
        </bits>
        <bits access="rw" name="data_type_dp_dr" pos="30" rst="0">
          <comment>1: only support raw8   0:support more type</comment>
        </bits>
        <bits access="rw" name="data_type_dr" pos="31" rst="0">
          <comment>1:select reg value</comment>
        </bits>
      </reg>
      <reg name="csi config reg7" protect="rw">
        <bits access="rw" name="data_lane_16bits_mode" pos="2" rst="0">
          <comment>data_lane_16bits_mode</comment>
        </bits>
        <bits access="rw" name="terminal_2_hs_exchage_8809p" pos="3" rst="0">
          <comment>terminal_2_hs_exchage_8809p</comment>
        </bits>
        <bits access="rw" name="terminal_1_hs_exchage_8809p" pos="4" rst="0">
          <comment>terminal_1_hs_exchage_8809p</comment>
        </bits>
        <bits access="rw" name="data2_terminal_enable_8809p_dr" pos="5" rst="0">
          <comment>data2_terminal_enable_8809p_dr</comment>
        </bits>
        <bits access="rw" name="hs_data2_enable_8809p_dr" pos="6" rst="0">
          <comment>hs_data2_enable_8809p_dr</comment>
        </bits>
        <bits access="rw" name="csi_dout_test_8809p_en" pos="7" rst="0">
          <comment>csi_dout_test_8809p_en</comment>
        </bits>
        <bits access="rw" name="csi_dout_test_8809p" pos="15:8" rst="0">
          <comment>csi_dout_test_8809p[7:0]</comment>
        </bits>
        <bits access="rw" name="num_d_term_en" pos="23:16" rst="0">
          <comment>num_d_term_en[15:8]</comment>
        </bits>
        <bits access="rw" name="num_hs_settle" pos="31:24" rst="0">
          <comment>num_hs_settle[15:8]</comment>
        </bits>
      </reg>
      <reg name="csi obs4" protect="rw">
        <bits access="rw" name="hs_data_state" pos="13:0" rst="0">
          <comment>hs_data_state[13:0]</comment>
        </bits>
        <bits access="rw" name="phy_data_state" pos="28:14" rst="0">
          <comment>phy_data_state[14:0]</comment>
        </bits>
        <bits access="rw" name="fifo_wfull_almost" pos="29" rst="0">
          <comment>fifo_wfull_almost</comment>
        </bits>
        <bits access="rw" name="fifo_wfull" pos="30" rst="0">
          <comment>fifo_wfull</comment>
        </bits>
        <bits access="rw" name="fifo_wempty" pos="31" rst="1">
          <comment>fifo_wempty</comment>
        </bits>
      </reg>
      <reg name="csi obs5" protect="rw">
        <bits access="ro" name="csi_observe_reg_5_low" pos="7:0" rst="0">
          <comment>if observe_reg_5_low8_choose=1, out is data_id[7:0], else out is lp_cmd_out[7:0]</comment>
        </bits>
        <bits access="ro" name="lp_data_interrupt_flag" pos="8" rst="0">
          <comment>lp_data_interrupt_flag</comment>
        </bits>
        <bits access="ro" name="lp_cmd_interrupt_flag" pos="9" rst="0">
          <comment>lp_data_interrupt_flag</comment>
        </bits>
        <bits access="ro" name="phy_clk_state" pos="18:10" rst="0">
          <comment>phy_clk_state[8:0]</comment>
        </bits>
        <bits access="ro" name="fifo_rcount" pos="27:19" rst="0">
          <comment>fifo_rcount[8:0]</comment>
        </bits>
        <bits access="ro" name="crc_error" pos="28" rst="0">
          <comment>crc_error</comment>
        </bits>
        <bits access="ro" name="err_ecc_corrected_flag" pos="29" rst="0">
          <comment>err_ecc_corrected_flag</comment>
        </bits>
        <bits access="ro" name="err_data_corrected_flag" pos="30" rst="0">
          <comment>err_data_corrected_flag</comment>
        </bits>
        <bits access="ro" name="err_data_zero_flag" pos="31" rst="1">
          <comment>err_data_zero_flag</comment>
        </bits>
      </reg>
      <reg name="csi obs6" protect="rw">
        <comment>if observe_reg_5_low8_choose=1, out is csi_observe_mon, else out is lp_data_out[63:32]</comment>
      </reg>
      <reg name="csi obs7" protect="rw">
        <comment>csi_observe_reg_7[31:0]</comment>
      </reg>
      <reg name="csi enable" protect="rw">
        <bits access="rw" name="csi_enable" pos="0" rst="0">
          <comment>csi_enable</comment>
        </bits>
      </reg>
      <reg name="csi config reg8" protect="rw">
        <bits access="rw" name="dly_sel_clkn_reg" pos="3:0" rst="0">
          <comment>dly_sel_clkn_reg,set clkn delay,to csi analog phy</comment>
        </bits>
        <bits access="rw" name="dly_sel_clkp_reg" pos="7:4" rst="0">
          <comment>dly_sel_clkp_reg,set clkp delay,to csi analog phy</comment>
        </bits>
        <bits access="rw" name="dly_sel_data2_reg" pos="11:8" rst="0">
          <comment>dly_sel_data2_reg,set data2 delay,to csi analog phy</comment>
        </bits>
        <bits access="rw" name="dly_sel_data1_reg" pos="15:12" rst="0">
          <comment>dly_sel_data1_reg,set data1 delay,to csi analog phy</comment>
        </bits>
        <bits access="rw" name="vth_sel" pos="16" rst="0">
          <comment>vth_sel,to csi analog phy</comment>
        </bits>
      </reg>
      <hole size="222*32"/>
      <struct count="FIFORAM_SIZE" name="fiforam">
        <reg name="ramdata" protect="r">
          <comment>Direct FIFO Ram Access. They are enabled only in Bist Mode.</comment>
        </reg>
      </struct>
      <hole size="176*32"/>
      <reg name="soft_reset" protect="rw">
        <bits access="rw" name="dsp_reset" pos="0" rst="0x1">
          <comment>rstn of dsp</comment>
        </bits>
      </reg>
      <hole size="17*32"/>
      <reg name="awb_x1_min" protect="rw">
        <bits access="rw" name="awb_x1_min" pos="7:0" rst="0x78">
          <comment>for A ctd block, u2.7 format
                  awb_x1_min[8:0]=[awb_ctd_msb[0],awb_x1_min[7:0]]</comment>
        </bits>
      </reg>
      <reg name="awb_x1_max" protect="rw">
        <bits access="rw" name="awb_x1_max" pos="7:0" rst="0x99">
          <comment>for A ctd block, u2.7 format
                  awb_x1_max[8:0]=[awb_ctd_msb[1],awb_x1_max[7:0]]</comment>
        </bits>
      </reg>
      <reg name="awb_y1_min" protect="rw">
        <bits access="rw" name="awb_y1_min" pos="7:0" rst="0x27">
          <comment>for A ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y1_max" protect="rw">
        <bits access="rw" name="awb_y1_max" pos="7:0" rst="0x3c">
          <comment>for A ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x2_min" protect="rw">
        <bits access="rw" name="awb_x2_min" pos="7:0" rst="0x5b">
          <comment>for TL84 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x2_max" protect="rw">
        <bits access="rw" name="awb_x2_max" pos="7:0" rst="0x70">
          <comment>for TL84 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y2_min" protect="rw">
        <bits access="rw" name="awb_y2_min" pos="7:0" rst="0x34">
          <comment>for TL84 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y2_max" protect="rw">
        <bits access="rw" name="awb_y2_max" pos="7:0" rst="0x4d">
          <comment>for TL84 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x3_min" protect="rw">
        <bits access="rw" name="awb_x3_min" pos="7:0" rst="0x44">
          <comment>for CWF ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x3_max" protect="rw">
        <bits access="rw" name="awb_x3_max" pos="7:0" rst="0x5a">
          <comment>for CWF ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y3_min" protect="rw">
        <bits access="rw" name="awb_y3_min" pos="7:0" rst="0x2b">
          <comment>for CWF ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y3_max" protect="rw">
        <bits access="rw" name="awb_y3_max" pos="7:0" rst="0x44">
          <comment>for CWF ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x4_min" protect="rw">
        <bits access="rw" name="awb_x4_min" pos="7:0" rst="0x42">
          <comment>for Indoor ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x4_max" protect="rw">
        <bits access="rw" name="awb_x4_max" pos="7:0" rst="0x5c">
          <comment>for Indoor ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y4_min" protect="rw">
        <bits access="rw" name="awb_y4_min" pos="7:0" rst="0x4f">
          <comment>for Indoor ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y4_max" protect="rw">
        <bits access="rw" name="awb_y4_max" pos="7:0" rst="0x68">
          <comment>for Indoor ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x5_min" protect="rw">
        <bits access="rw" name="awb_x5_min" pos="7:0" rst="0x2d">
          <comment>for D65 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x5_max" protect="rw">
        <bits access="rw" name="awb_x5_max" pos="7:0" rst="0x47">
          <comment>for D65 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y5_min" protect="rw">
        <bits access="rw" name="awb_y5_min" pos="7:0" rst="0x6d">
          <comment>for D65 ctd block, u2.7 format
                  awb_y5_min[8:0]=[awb_ctd_msb[2],awb_y5_min[7:0]]</comment>
        </bits>
      </reg>
      <reg name="awb_y5_max" protect="rw">
        <bits access="rw" name="awb_y5_max" pos="7:0" rst="0x83">
          <comment>for D65 ctd block, u2.7 format
                  awb_y5_max[8:0]=[awb_ctd_msb[3],awb_y5_max[7:0]]</comment>
        </bits>
      </reg>
      <reg name="awb_skin_x1_min" protect="rw">
        <bits access="rw" name="awb_skin_x1_min" pos="7:0" rst="0x90">
          <comment>for TL84 skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_x1_max" protect="rw">
        <bits access="rw" name="awb_skin_x1_max" pos="7:0" rst="0xa8">
          <comment>for TL84 skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_y1_min" protect="rw">
        <bits access="rw" name="awb_skin_y1_min" pos="7:0" rst="0x28">
          <comment>for TL84 skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_y1_max" protect="rw">
        <bits access="rw" name="awb_skin_y1_max" pos="7:0" rst="0x45">
          <comment>for TL84 skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_x2_min" protect="rw">
        <bits access="rw" name="awb_skin_x2_min" pos="7:0" rst="0x73">
          <comment>for CWF skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_x2_max" protect="rw">
        <bits access="rw" name="awb_skin_x2_max" pos="7:0" rst="0x8c">
          <comment>for CWF skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_y2_min" protect="rw">
        <bits access="rw" name="awb_skin_y2_min" pos="7:0" rst="0x18">
          <comment>for CWF skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_y2_max" protect="rw">
        <bits access="rw" name="awb_skin_y2_max" pos="7:0" rst="0x39">
          <comment>for CWF skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_ctd_msb" protect="rw">
        <bits access="rw" name="awb_x1_min_msb" pos="0" rst="0x0">
          <comment>awb_x1_min[8:0]=[awb_x1_min_msb,awb_x1_min[7:0]]</comment>
        </bits>
        <bits access="rw" name="awb_x1_max_msb" pos="1" rst="0x0">
          <comment>awb_x1_max[8:0]=[awb_x1_max_msb,awb_x1_max[7:0]]</comment>
        </bits>
        <bits access="rw" name="awb_y5_min_msb" pos="2" rst="0x0">
          <comment>awb_y5_min[8:0]=[awb_y5_min_msb,awb_y5_min[7:0]]</comment>
        </bits>
        <bits access="rw" name="awb_y5_max_msb" pos="3" rst="0x0">
          <comment>awb_y5_max[8:0]=[awb_y5_max_msb,awb_y5_max[7:0]]</comment>
        </bits>
        <bits access="rw" name="awb_adj_mode" pos="5:4" rst="0x0">
          <comment>2d0: awb_adj_sig=1
                  2d1: awb_adj_sig= crsum_abs&gt;vld_cnt_cr_thr x2 or  cbsum_abs&gt;vld_cnt_cb_thr x2
                  2d2: awb_adj_sig= crsum_abs&gt;vld_cnt_cr_thr x3 or  cbsum_abs&gt;vld_cnt_cb_thr x3
                  2d3: awb_adj_sig= crsum_abs&gt;vld_cnt_cr_thr x2 and cbsum_abs&gt;vld_cnt_cb_thr x2</comment>
        </bits>
        <bits access="rw" name="awb_ratio_mode" pos="7:6" rst="0x0">
          <comment>2d3: awb_ratio_lmax=4
                  2d2: awb_ratio_lmax=2
                  2d1: awb_ratio_lmax=0
                  2d0: awb_ratio_lmax= according to the proportion of cnt_max and cnt_lmax</comment>
        </bits>
      </reg>
      <reg name="int_dif_thr_mid" protect="rw">
        <bits access="rw" name="int_dif_thr_mid" pos="7:0" rst="0x18">
          <comment/>
        </bits>
      </reg>
      <reg name="lb_soft_rstn" protect="rw">
        <bits access="rw" name="lb_soft_rstn" pos="0" rst="0x1">
          <comment/>
        </bits>
      </reg>
      <reg name="vsync_end_high" protect="rw">
        <bits access="rw" name="vsync_end_high" pos="7:0" rst="0x0">
          <comment>vsync_end_reg=[vsync_end_high,vsync_end_low]</comment>
        </bits>
      </reg>
      <reg name="vsync_end_low" protect="rw">
        <bits access="rw" name="vsync_end_low" pos="7:0" rst="0x01">
          <comment>vsync_end_reg=[vsync_end_high,vsync_end_low]</comment>
        </bits>
      </reg>
      <reg name="line_numl" protect="rw">
        <bits access="rw" name="line_numl" pos="7:0" rst="0xe8">
          <comment>line_num = [line_numH,line_numL]</comment>
        </bits>
      </reg>
      <reg name="pix_numl" protect="rw">
        <bits access="rw" name="pix_numl" pos="7:0" rst="0x88">
          <comment>pix_num = [pix_numH,pix_numL]</comment>
        </bits>
      </reg>
      <reg name="pix_line_numh" protect="rw">
        <bits access="rw" name="line_numh" pos="0" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="pix_numh_rsvd" pos="3:1" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="pix_numh" pos="5:4" rst="0x2">
          <comment/>
        </bits>
        <bits access="rw" name="line_numh_rsvd" pos="7:6" rst="0x0">
          <comment>not used here</comment>
        </bits>
      </reg>
      <reg name="lb_ctrl" protect="rw">
        <bits access="rw" name="low_order" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="use_fb_reg" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="not_cvp_reg" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="first_byte_reg" pos="5:3" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="data_format" protect="rw">
        <bits access="rw" name="data_format" pos="1:0" rst="0x0">
          <comment>00:YUV/RAW8(para)
                  01:RAW8(mipi)
                  10:RAW10(mipi)</comment>
        </bits>
      </reg>
      <reg name="lb_enable" protect="rw">
        <bits access="rw" name="lb_enable" pos="0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="vh_inv" protect="rw">
        <bits access="rw" name="hsync_inv" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="vsync_inv" pos="1" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="line_cnt_l" protect="ro">
        <bits access="ro" name="line_cnt_l" pos="7:0" rst="0x0">
          <comment>line_cnt=[line_cnt_H[1:0], [7:0]]</comment>
        </bits>
      </reg>
      <reg name="line_cnt_h" protect="ro">
        <bits access="ro" name="line_cnt_h" pos="1:0" rst="0x0">
          <comment>line_cnt=[line_cnt_H[1:0], line_cnt_L]</comment>
        </bits>
      </reg>
      <reg name="num_check" protect="rw">
        <bits access="ro" name="line_num_check" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="ro" name="byte_num_check" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="wo" name="line_num_clear" pos="4" rst="0x0">
          <comment/>
        </bits>
        <bits access="wo" name="byte_num_clear" pos="5" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="dci_ctrl_reg" protect="rw">
        <bits access="rw" name="kl_low_light_fix" pos="0" rst="0x1">
          <comment>1: kl 0: kldci ()</comment>
        </bits>
        <bits access="rw" name="kl_reg_fix" pos="1" rst="0x1">
          <comment>1: kl 0: kldci</comment>
        </bits>
        <bits access="rw" name="ku_low_light_fix" pos="2" rst="0x1">
          <comment>1: ku 0: kudci ()</comment>
        </bits>
        <bits access="rw" name="ku_reg_fix" pos="3" rst="0x1">
          <comment>1: ku 0: kudci</comment>
        </bits>
        <bits access="rw" name="hofst" pos="5:4" rst="0x0">
          <comment>hist 2</comment>
        </bits>
        <bits access="rw" name="vbh_sel" pos="7:6" rst="0x0">
          <comment>00: 0x98regae_dark_hist_reg
                  01: 0x98regyave_target_RO_reg
                  other: 0x98regyave_contr_reg</comment>
        </bits>
      </reg>
      <reg name="dci_ofst_reg" protect="rw">
        <bits access="rw" name="kl_ofstx1" pos="3:0" rst="0x8">
          <comment>kl_ofstx1[4:0] = [kl_ofstx1, 1b0] (kl0x80)</comment>
        </bits>
        <bits access="rw" name="ku_ofstx1" pos="7:4" rst="0x8">
          <comment>ku_ofstx1[4:0] = [ku_ofstx1, 1b0] (kl0x80)</comment>
        </bits>
      </reg>
      <reg name="dci_hist_reg" protect="rw">
        <bits access="rw" name="dk_histx1" pos="3:0" rst="0x8">
          <comment>dk_histx1[4:0] = [dk_histx1, 1b0] (dhist)</comment>
        </bits>
        <bits access="rw" name="br_histx1" pos="7:4" rst="0x8">
          <comment>br_histx1[4:0] = [br_histx1, 1b0] (bhist)</comment>
        </bits>
      </reg>
      <reg name="ae_sw_ctrl_reg" protect="rw">
        <bits access="rw" name="nexp_sw_in" pos="3:0" rst="0x0">
          <comment>swaeswexp/gainnexphw//</comment>
        </bits>
        <bits access="wo" name="ae_ext_adj_start" pos="7" rst="0x0">
          <comment>sw/hwae,SWae,</comment>
        </bits>
      </reg>
      <reg name="ae_thr_reg" protect="rw">
        <bits access="rw" name="thr_dark" pos="3:0" rst="0x3">
          <comment>THR_dark[4:0] = [THR_dark, 1'b0] (ytarget-yave  THR_darkae)</comment>
        </bits>
        <bits access="rw" name="thr_bright" pos="7:4" rst="0x8">
          <comment>THR_bright[4:0] = [THR_bright,1'b0](yave-ytargetTHR_brightae)</comment>
        </bits>
      </reg>
      <reg name="ae_misc_ctrl_reg" protect="rw">
        <bits access="rw" name="ofst_dec_low_sel" pos="1:0" rst="0x0">
          <comment>ytarget_dec
                  2d3:4indexytargetregd[3:0]8index08
                  2d2:2indexytargetregd[3:0]8index016
                  2d1:1indexytargetregd[3:0]8index032
                  2d0:1indexytargetregd[3:0]8index064</comment>
        </bits>
        <bits access="rw" name="ofst_dec_high_sel" pos="3:2" rst="0x0">
          <comment>ytarget_dec
                  2d3:4indexytargetregc[7:4]8index_max8
                  2d2:2indexytargetregc[7:4]8index_max16
                  2d1:1indexytargetregd[7:4]8index_max32
                  2d0:1indexytargetregd[7:4]8index_max64</comment>
        </bits>
        <bits access="rw" name="force_adj1" pos="4" rst="0x0">
          <comment>1yave_diff_2frame</comment>
        </bits>
        <bits access="rw" name="force_adj2" pos="5" rst="0x0">
          <comment>1THR_big</comment>
        </bits>
        <bits access="rw" name="force_adj3" pos="6" rst="0x0">
          <comment>1bhist&gt;0@is_dark</comment>
        </bits>
        <bits access="rw" name="index_ofst_no_step" pos="7" rst="0x0">
          <comment>1index_ofst</comment>
        </bits>
      </reg>
      <reg name="csup_xx_reg" protect="rw">
        <bits access="rw" name="x_low" pos="3:0" rst="0x0">
          <comment>@nexp</comment>
        </bits>
        <bits access="rw" name="x_high" pos="7:4" rst="0x8">
          <comment>@nexp</comment>
        </bits>
      </reg>
      <reg name="contr_ythr_reg" protect="rw">
        <bits access="rw" name="csup_gain_low_th_h" pos="0" rst="0x1">
          <comment>low_th = [[0], lsc_blc_gain_th[7:6]](nexp=low_th)</comment>
        </bits>
        <bits access="rw" name="csup_gain_high_th" pos="3:1" rst="0x3">
          <comment>nexp&gt;(8+high_th)</comment>
        </bits>
        <bits access="rw" name="fixed_contr_ythr" pos="7:4" rst="0x8">
          <comment>Fixed Ythr of contr = [[7:4], 4d0]</comment>
        </bits>
      </reg>
      <reg name="contr_yave_offset_reg" protect="rw">
        <bits access="rw" name="yave_offset_reg" pos="5:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="ythr_sel" pos="6" rst="0x1">
          <comment>1: dynamic yave (Yave)
                  0: fixed ythr contr_ythr_reg</comment>
        </bits>
        <bits access="rw" name="yave_offset_sign" pos="7" rst="0x0">
          <comment>YaveYthrofst (01)</comment>
        </bits>
      </reg>
      <reg name="contr_ku_lo_reg" protect="rw">
        <bits access="rw" name="ku" pos="6:0" rst="0x20">
          <comment>upper@Low gain
                  Yout = Yin +/- min(ku*(Yin-Ythr), ku*(255-Yin))</comment>
        </bits>
        <bits access="rw" name="ku_sign" pos="7" rst="0x1">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="contr_kl_lo_reg" protect="rw">
        <bits access="rw" name="kl" pos="6:0" rst="0x20">
          <comment>lower@Low gain
                  Yout = Yin -/+ min(kl*(Ythr-Yin), kl*Yin)</comment>
        </bits>
        <bits access="rw" name="kl_sign" pos="7" rst="0x1">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="contr_ku_mid_reg" protect="rw">
        <bits access="rw" name="ku" pos="6:0" rst="0x10">
          <comment>upper@Mid gain
                  Yout = Yin +/- min(ku*(Yin-Ythr), ku*(255-Yin))</comment>
        </bits>
        <bits access="rw" name="ku_sign" pos="7" rst="0x1">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="contr_kl_mid_reg" protect="rw">
        <bits access="rw" name="kl" pos="6:0" rst="0x10">
          <comment>lower@Mid gain
                  Yout = Yin -/+ min(kl*(Ythr-Yin), kl*Yin)</comment>
        </bits>
        <bits access="rw" name="kl_sign" pos="7" rst="0x1">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="contr_ku_hi_reg" protect="rw">
        <bits access="rw" name="ku" pos="6:0" rst="0x70">
          <comment>upper@High gain
                  Yout = Yin +/- min(ku*(Yin-Ythr), ku*(255-Yin))</comment>
        </bits>
        <bits access="rw" name="ku_sign" pos="7" rst="0x0">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="contr_kl_hi_reg" protect="rw">
        <bits access="rw" name="kl" pos="6:0" rst="0x70">
          <comment>lower@High gain
                  Yout = Yin -/+ min(kl*(Ythr-Yin), kl*Yin)</comment>
        </bits>
        <bits access="rw" name="kl_sign" pos="7" rst="0x0">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="luma_offset_lo_reg" protect="rw">
        <bits access="rw" name="offset" pos="5:0" rst="0x0">
          <comment>@Low gain</comment>
        </bits>
        <bits access="rw" name="algo_sel" pos="6" rst="0x0">
          <comment>1: Yout = (256-offset)*Yin/256 + offset
                  0: Yout = Yin + offset</comment>
        </bits>
        <bits access="rw" name="offset_sign" pos="7" rst="0x0">
          <comment>0   1</comment>
        </bits>
      </reg>
      <reg name="luma_offset_mid_reg" protect="rw">
        <bits access="rw" name="offset" pos="5:0" rst="0x0">
          <comment>@Mid gain</comment>
        </bits>
        <bits access="rw" name="algo_sel" pos="6" rst="0x0">
          <comment>1: Yout = (256-offset)*Yin/256 + offset
                  0: Yout = Yin + offset</comment>
        </bits>
        <bits access="rw" name="offset_sign" pos="7" rst="0x0">
          <comment>0   1</comment>
        </bits>
      </reg>
      <reg name="luma_offset_hi_reg" protect="rw">
        <bits access="rw" name="offset" pos="5:0" rst="0x0">
          <comment>@High gain</comment>
        </bits>
        <bits access="rw" name="algo_sel" pos="6" rst="0x0">
          <comment>1: Yout = (256-offset)*Yin/256 + offset
                  0: Yout = Yin + offset</comment>
        </bits>
        <bits access="rw" name="offset_sign" pos="7" rst="0x0">
          <comment>0   1</comment>
        </bits>
      </reg>
      <reg name="u_gain_lo_reg" protect="rw">
        <bits access="rw" name="u_gain_lo_reg" pos="7:0" rst="0xb0">
          <comment>Cb@Low gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="v_gain_lo_reg" protect="rw">
        <bits access="rw" name="v_gain_lo_reg" pos="7:0" rst="0xb0">
          <comment>Cr@Low gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="u_gain_mid_reg" protect="rw">
        <bits access="rw" name="u_gain_mid_reg" pos="7:0" rst="0xa0">
          <comment>Cb@Mid gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="v_gain_mid_reg" protect="rw">
        <bits access="rw" name="v_gain_mid_reg" pos="7:0" rst="0xa0">
          <comment>Cr@Mid gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="u_gain_hi_reg" protect="rw">
        <bits access="rw" name="u_gain_hi_reg" pos="7:0" rst="0x80">
          <comment>Cb@High gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="v_gain_hi_reg" protect="rw">
        <bits access="rw" name="v_gain_hi_reg" pos="7:0" rst="0x80">
          <comment>Cr@High gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="again_sel_th0_reg" protect="rw">
        <bits access="rw" name="contr_gain_low_th" pos="2:0" rst="0x4">
          <comment>@luma/contr/satur(nexp=low_th)</comment>
        </bits>
        <bits access="rw" name="again_sel_th0_rsvd" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="contr_gain_hi_th" pos="6:4" rst="0x3">
          <comment>@luma/contr/satur(nexp&gt;(8+high_th))</comment>
        </bits>
      </reg>
      <reg name="awb_cc_type_ctrl_reg" protect="rw">
        <bits access="rw" name="cc_type_mode" pos="3:0" rst="0x0">
          <comment>4'd0:         cc_type = 0; //D65
                  4'd1:         cc_type = 1; //U30
                  4'd2:if(is_outdoor) cc_type = 0;
                       else           cc_type = 1;
                  4'd3:if(ana_gain&gt;=cc_gain_th) cc_type = 0;
                       else                     cc_type = 1;
                  4'd4:if(rgain_bigger)         cc_type = 0; //D65
                       else if(bgain_bigger)    cc_type = 1; //U30
                  4'd5: if(is_outdoor)          cc_type = 0;
                        else if(rgain_bigger)   cc_type = 0;
                        else if(bgain_bigger)   cc_type = 1;
                  4'd6: if(is_outdoor)                 cc_type = 0;
                        else if(ana_gain=cc_gain_th) cc_type = 0;
                        else if(rgain_bigger)          cc_type = 0;
                        else if(bgain_bigger)          cc_type = 1;
                  4'd7: if(is_outdoor)                 cc_type = 0;
                        else if(ana_gain=cc_gain_th) cc_type = 1;
                        else if(rgain_bigger)          cc_type = 0;
                        else if(bgain_bigger)          cc_type = 1;
                  4'd8: if(r_awb_gain_outr_low_non_A)cc_type = 1;
                        else if(r_awb_gain_out(r_low_non_A+8)) cc_type = 0;
                  4d9: if(awb_idx_max2)       cc_type = 1;
                         else if(awb_idx_max2)  cc_type = 0;
                  other: SW driven  ( reg1c2)</comment>
        </bits>
        <bits access="rw" name="cc_gain_hi_th" pos="6:4" rst="0x0">
          <comment>nexp&gt;(8+high_th)</comment>
        </bits>
        <bits access="rw" name="luma_first" pos="7" rst="0x0">
          <comment>1:  0:</comment>
        </bits>
      </reg>
      <reg name="awb_cc_type_th_reg" protect="rw">
        <bits access="rw" name="r_big_th" pos="3:0" rst="0x1">
          <comment>r_big_th=[awb_cc_type_th_reg[3:0], 2d0]</comment>
        </bits>
        <bits access="rw" name=" b_big_th" pos="7:4" rst="0x1">
          <comment>b_big_th=[awb_cc_type_th_reg[7:4], 2d0]</comment>
        </bits>
      </reg>
      <reg name="isp_wrapper_ctrl_1" protect="rw">
        <bits access="rw" name="pout_mode" pos="1:0" rst="0x0">
          <comment>00: YUV422     01: RGB565
                  10: raw bayer  11: clip out</comment>
        </bits>
        <bits access="rw" name="yuv_mode" pos="3:2" rst="0x0">
          <comment>00:YUYV       01:YVYU
                  10:UYVY       11:VYUY
                 (Note:[2] uv_sel  0:UV  1:VU)</comment>
        </bits>
        <bits access="rw" name="vsync_toggle" pos="4" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="mipi_rstn" pos="5" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name=" hsync_fix" pos="6" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="top_dummy" protect="rw">
        <bits access="rw" name="top_dummy" pos="6:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="left_dummy" protect="rw">
        <bits access="rw" name="left_dummy" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="isp_wrapper_ctrl_2" protect="rw">
        <bits access="rw" name="rgb_mode_reg" pos="2:0" rst="0x0">
          <comment>Case(rgb_mode_reg)  @clip out
                  3'd0: to_n_clp_data     3'd1: y_data
                  3'd2: cnr_1d_cb         3'd3: cnr_1d_cr
                  3'd4: c_data            3'd5: yc2r_data
                  3'd6: yc2g_data         3'd7: yc2b_data
                  Note:rgb_mode_reg[0] is also used to
                  1, select the line of sub_YUV output</comment>
        </bits>
        <bits access="rw" name="sub_mode" pos="3" rst="0x0">
          <comment>not used, sca_reg=1:sub mode</comment>
        </bits>
        <bits access="rw" name="mon_mode_reg" pos="4" rst="0x0">
          <comment>bypass vsync_in and hsync_in</comment>
        </bits>
        <bits access="rw" name="oclk_inv_reg" pos="5" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="isp_out_en" pos="6" rst="0x1">
          <comment/>
        </bits>
      </reg>
      <reg name="line_num_l_reg" protect="rw">
        <bits access="rw" name="line_num_l_reg" pos="5:0" rst="0x3c">
          <comment>Line_num=[lin_num_l_reg[5:0], 3d0]</comment>
        </bits>
      </reg>
      <reg name="pix_num_l_reg" protect="rw">
        <bits access="rw" name="pix_num_l_reg" pos="6:0" rst="0x50">
          <comment>Pix_num=[pix_num_l_reg[6:0], 3d0]</comment>
        </bits>
        <bits access="rw" name="csi_mon_reg" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="v_dummy" protect="rw">
        <bits access="rw" name="vbot_dummy_reg" pos="3:0" rst="0x2">
          <comment>HsyncNvsync</comment>
        </bits>
        <bits access="rw" name="vtop_dummy_reg" pos="7:4" rst="0x0">
          <comment>Mvsync
                  top_dummy&gt;16, vtop_dummy=top_dummy-[7:4]</comment>
        </bits>
      </reg>
      <reg name="scg" protect="rw">
        <bits access="rw" name="kukl_sel" pos="0" rst="0x1">
          <comment>1blc[ku, kl]</comment>
        </bits>
        <bits access="rw" name="reg94_rd_sel" pos="1" rst="0x1">
          <comment>1:nexp[3:0]  0:mono_color</comment>
        </bits>
        <bits access="rw" name="bayer_out_sel" pos="2" rst="0x0">
          <comment>1: dpc_out  0: bayer_data</comment>
        </bits>
        <bits access="rw" name="csup_en" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="y_gamma_en" pos="5:4" rst="0x3">
          <comment>1: enable 0: disable
                  y_gamma_en = is_outdoor ? scg_reg[5] : scg_reg[4]</comment>
        </bits>
        <bits access="rw" name="yuv_sdi_en" pos="6" rst="0x1">
          <comment>1: SDI  0: BT.601</comment>
        </bits>
        <bits access="rw" name="reg92_rd_sel" pos="7" rst="0x0">
          <comment>1: [ae_ok, nexp_sel[1:0], awb_ok, exp[11:8]]
                  0: [ae_ok, 1b0, nexp_sel[1:0], awb_ok, exp[10:8]]
                     labview</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b0" protect="rw">
        <bits access="rw" name="y_gamma_b0" pos="7:0" rst="0x0">
          <comment>(0x00)0      (0x00)0     (0x00)0</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b1" protect="rw">
        <bits access="rw" name="y_gamma_b1" pos="7:0" rst="0x10">
          <comment>(0x13)19     (0x10)16    (0x08)8</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b2" protect="rw">
        <bits access="rw" name="y_gamma_b2" pos="7:0" rst="0x1c">
          <comment>(0x20)32     (0x1c)28    (0x10)16</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b4" protect="rw">
        <bits access="rw" name="y_gamma_b4" pos="7:0" rst="0x30">
          <comment>(0x36)54     (0x30)48    (0x20)32</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b6" protect="rw">
        <bits access="rw" name="y_gamma_b6" pos="7:0" rst="0x43">
          <comment>(0x49)73     (0x43)67    (0x30)48</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b8" protect="rw">
        <bits access="rw" name="y_gamma_b8" pos="7:0" rst="0x54">
          <comment>(0x5a)90     (0x54)84    (0x40)64</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b10" protect="rw">
        <bits access="rw" name="y_gamma_b10" pos="7:0" rst="0x65">
          <comment>(0x6b)107    (0x65)101   (0x50)80</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b12" protect="rw">
        <bits access="rw" name="y_gamma_b12" pos="7:0" rst="0x75">
          <comment>(0x7b)123    (0x75)117   (0x60)96</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b16" protect="rw">
        <bits access="rw" name="y_gamma_b16" pos="7:0" rst="0x93">
          <comment>RW(0x98)152    (0x93)147   (0x80)128</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b20" protect="rw">
        <bits access="rw" name="y_gamma_b20" pos="7:0" rst="0xb0">
          <comment>(0xb4)180    (0xb0)176   (0xa0)160</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b24" protect="rw">
        <bits access="rw" name="y_gamma_b24" pos="7:0" rst="0xcb">
          <comment>(0xce)206    (0xcb)203   (0xc0)192</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b28" protect="rw">
        <bits access="rw" name="y_gamma_b28" pos="7:0" rst="0xe6">
          <comment>(0xe7)231    (0xe6)230   (0xe0)224</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b32" protect="rw">
        <bits access="rw" name="y_gamma_b32" pos="7:0" rst="0x0">
          <comment>0.75    0.8   1.0</comment>
        </bits>
      </reg>
      <reg name="r_awb_gain_in" protect="rw">
        <bits access="rw" name="r_awb_gain_in" pos="7:0" rst="0x40">
          <comment>r_gain_manual 2.6 format</comment>
        </bits>
      </reg>
      <reg name="g_awb_gain_in" protect="rw">
        <bits access="rw" name="g_awb_gain_in" pos="7:0" rst="0x40">
          <comment>g_gain_manual 2.6 format</comment>
        </bits>
      </reg>
      <reg name="b_awb_gain_in" protect="rw">
        <bits access="rw" name="b_awb_gain_in" pos="7:0" rst="0x40">
          <comment>b_gain_manual 2.6 format</comment>
        </bits>
      </reg>
      <reg name="r_drc_gain_in" protect="rw">
        <bits access="rw" name="r_drc_gain_in" pos="7:0" rst="0x40">
          <comment>2.6 format</comment>
        </bits>
      </reg>
      <reg name="gr_drc_gain_in" protect="rw">
        <bits access="rw" name="gr_drc_gain_in" pos="7:0" rst="0x40">
          <comment>2.6 format</comment>
        </bits>
      </reg>
      <reg name="gb_drc_gain_in" protect="rw">
        <bits access="rw" name="gb_drc_gain_in" pos="7:0" rst="0x40">
          <comment>2.6 format</comment>
        </bits>
      </reg>
      <reg name="b_drc_gain_in" protect="rw">
        <bits access="rw" name="b_drc_gain_in" pos="7:0" rst="0x40">
          <comment>2.6 format</comment>
        </bits>
      </reg>
      <reg name="ae_ctrl" protect="rw">
        <bits access="rw" name="ana_gain_in" pos="5:0" rst="0x8">
          <comment/>
        </bits>
        <bits access="rw" name="ae_update_en" pos="6" rst="0x1">
          <comment>also update cc_type,gamma_type,is_outdoor</comment>
        </bits>
        <bits access="rw" name="ae_en" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="ae_ctrl2" protect="rw">
        <bits access="rw" name=" awb_adj_sel" pos="1:0" rst="0x1">
          <comment>00: AWB
                  01: AWB
                  10: yaveAWB
                  11: nexpAWB</comment>
        </bits>
        <bits access="rw" name="gap_ae" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gap_be" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="ae_action_period" pos="6:4" rst="0x4">
          <comment/>
        </bits>
        <bits access="rw" name="yave_mon_sel" pos="7" rst="0x0">
          <comment>1: mon ae index  0:mon awb_debug</comment>
        </bits>
      </reg>
      <reg name="ae_ctrl3" protect="rw">
        <bits access="rw" name="yave_use_mean" pos="1:0" rst="0x3">
          <comment>0yave        1yave
                  2yave    3yave</comment>
        </bits>
        <bits access="rw" name="yave_diff_thr_reg" pos="3:2" rst="0x1">
          <comment>07/0f/17/1f Yave</comment>
        </bits>
        <bits access="rw" name="yave_sel" pos="5:4" rst="0x2">
          <comment>00: y2ave x1.0    01: y2ave x1.5
                  10: y3ave x1.0    11: y3ave x1.5</comment>
        </bits>
        <bits access="rw" name="yave_plus_bh_mode" pos="6" rst="0x1">
          <comment>1:plus bh   0: only yave</comment>
        </bits>
        <bits access="rw" name="ywave_plus_bh_mode" pos="7" rst="0x1">
          <comment>1:plus bh   0: only ywave</comment>
        </bits>
      </reg>
      <reg name="ae_ctrl4" protect="rw">
        <bits access="rw" name="ae_hist_big_en" pos="0" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="ae_hist_too_big_en" pos="1" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="hist_ofst0" pos="3:2" rst="0x2">
          <comment/>
        </bits>
        <bits access="rw" name="index_ofst0" pos="5:4" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="index_ofst1" pos="7:6" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="ae_win_start" protect="rw">
        <bits access="rw" name="pcnt_left" pos="3:0" rst="0x2">
          <comment>pcnt_left =[ae_win_start_reg[3:0] ,1'd0]</comment>
        </bits>
        <bits access="rw" name="lcnt_top" pos="7:4" rst="0x2">
          <comment>lcnt_top =[ae_win_start_reg[7:4] ,1'd0]</comment>
        </bits>
      </reg>
      <reg name="ae_win_width" protect="rw">
        <bits access="rw" name="ae_win_width" pos="7:0" rst="0x95">
          <comment>ae(yave) win_width = [ae_win_width[7:0], 2'd0]</comment>
        </bits>
      </reg>
      <reg name="ae_win_height" protect="rw">
        <bits access="rw" name="ae_win_height" pos="7:0" rst="0xdc">
          <comment>ae(yave) ae_win_height = [ae_win_height[7:0], 1'd0]</comment>
        </bits>
      </reg>
      <reg name="exp_init" protect="rw">
        <bits access="rw" name="exp_init" pos="7:0" rst="0x0">
          <comment>exp[7:0](ae_enMCUexp_init[6:0]indexae)</comment>
        </bits>
      </reg>
      <reg name="exp_ceil_init" protect="rw">
        <bits access="rw" name="exp_ceil_init" pos="3:0" rst="0x1">
          <comment>exp[11:8]</comment>
        </bits>
      </reg>
      <reg name="ae_exp_1e" protect="rw">
        <bits access="rw" name="ae_exp_1e" pos="7:0" rst="0x4a">
          <comment>10msexp</comment>
        </bits>
      </reg>
      <reg name="ae_diff_thr" protect="rw">
        <bits access="rw" name="thr2_dark" pos="3:0" rst="0x8">
          <comment>(ytarget)
                  THR_dark(reg41)
                  THR22index1
                  THR24index2
                  THR26index4+ofst0
                  THR28index8+ofst1
                                    index16</comment>
        </bits>
        <bits access="rw" name="thr2_bright" pos="7:4" rst="0x8">
          <comment>(ytarget)
                  THR_bright(reg41)
                  THR22index1
                  THR24index2
                  THR26index4+ofst0
                  THR28index8+ofst1
                                    index16</comment>
        </bits>
      </reg>
      <reg name="ae_bh_sel" protect="rw">
        <bits access="rw" name="bh_factor_indoor" pos="2:0" rst="0x3">
          <comment/>
        </bits>
        <bits access="rw" name="bh_factor_outdoor" pos="5:3" rst="0x2">
          <comment>Bh = Bh_mean * bh_factor /8
                  bh_factor = is_outdoor? bh_factor_outdoor : bh_factor_indoor</comment>
        </bits>
        <bits access="rw" name="bh_mean_sel" pos="7:6" rst="0x2">
          <comment>00:  curr frame     01:  2 frame ave
                  10:  3 frame ave    11:  4 frame ave</comment>
        </bits>
      </reg>
      <reg name="awb_ctrl" protect="rw">
        <bits access="rw" name="awb_sw_mon_en" pos="0" rst="0x0">
          <comment>awb_mon_out[7:0][cbsum_abs_eq, crsum_abs_eq]SWAWB</comment>
        </bits>
        <bits access="rw" name="fast_2x" pos="1" rst="0x0">
          <comment>2.0xr/b</comment>
        </bits>
        <bits access="rw" name="fast_4x" pos="2" rst="0x0">
          <comment>4.0xr/b</comment>
        </bits>
        <bits access="rw" name="awb_action_period" pos="5:3" rst="0x4">
          <comment>0: 1frame  or 2frame</comment>
        </bits>
        <bits access="rw" name="awb_update_en" pos="6" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="awb_en" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="awb_ctrl2" protect="rw">
        <bits access="rw" name="awb_mon_sel" pos="2:0" rst="0x0">
          <comment>[  2]  0:readback blc  1: readback awb
                  [1:0]  0: crsum_abs    1:cbsum_abs
                         2: vld_cnt      3:awb_idx_lmax and max</comment>
        </bits>
        <bits access="rw" name="awb_vld_sel" pos="3" rst="0x0">
          <comment>AWB</comment>
        </bits>
        <bits access="rw" name="awb_vld_mode" pos="6:4" rst="0x0">
          <comment>3'd0:awb_vld=vld_max||(vld_lmax and awb_ratio_lmax);
                  3'd1: awb_vld = awb_vld1;
                  3'd2: awb_vld = awb_vld2;
                  3'd3: awb_vld = awb_vld3;
                  3'd4: awb_vld = awb_vld4;
                  3'd5: awb_vld = awb_vld5;
                  3'd6: awb_vld =!skin_vld;
                  3'd7: awb_vld = awb_vld1|awb_vld2|awb_vld3| awb_vld4 | awb_vld5;</comment>
        </bits>
        <bits access="ro" name="awb_adj" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="awb_y_max" protect="rw">
        <bits access="rw" name="awb_y_max" pos="7:0" rst="0xf0">
          <comment>Y  Y_maxAWB</comment>
        </bits>
      </reg>
      <reg name="awb_stop" protect="rw">
        <bits access="rw" name="awb_stop_cb_neg_level" pos="1:0" rst="0x1">
          <comment>Levelawb_stop</comment>
        </bits>
        <bits access="rw" name="awb_stop_cb_pos_level" pos="3:2" rst="0x1">
          <comment>Levelawb_stop</comment>
        </bits>
        <bits access="rw" name="awb_stop_cr_neg_level" pos="5:4" rst="0x1">
          <comment>Levelawb_stop</comment>
        </bits>
        <bits access="rw" name="awb_stop_cr_pos_level" pos="7:6" rst="0x1">
          <comment>Levelawb_stop</comment>
        </bits>
      </reg>
      <reg name="awb_algo" protect="rw">
        <bits access="rw" name="awb_algo" pos="7:0" rst="0x80">
          <comment>[7:0]awb_algo_thr
                  Y &gt; cr_abs+cb_abs+awb_algo_reg
                  //</comment>
        </bits>
      </reg>
      <reg name="awb_ctrl3" protect="rw">
        <bits access="rw" name="cr_ofst_lt1x" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="cr_ofst_gt1x" pos="1" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="cb_ofst_lt1x" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="cb_ofst_gt1x" pos="3" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="awb_sum_vld_sel" pos="4" rst="0x0">
          <comment>0: (vld_cntawb_vld_thr)
                  1: (vld_cntawb_vld_thr)and(crsum_absawb_vld_thr)and(cbsum_absawb_vld_thr)</comment>
        </bits>
        <bits access="rw" name="awb_stop_sel_reg" pos="5" rst="0x1">
          <comment>0: awb_stopcb/cr
                  1:</comment>
        </bits>
        <bits access="rw" name="awb_skin_sel" pos="6" rst="0x0">
          <comment>0: use CTD block to detect skin
                  1: use cb,cr to detect skin</comment>
        </bits>
        <bits access="rw" name="awb_algo_mode" pos="7" rst="0x1">
          <comment>0: cb+cr
                  1: cb/cr</comment>
        </bits>
      </reg>
      <reg name="awb_ctrl4" protect="rw">
        <bits access="rw" name="awb_ctrl4" pos="7:0" rst="0x10">
          <comment>awb_vld_thr = [awb_ctrl4[7:0], 4'hf]</comment>
        </bits>
      </reg>
      <reg name="dig_gain_in" protect="rw">
        <bits access="rw" name="dig_gain_in" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="y_init_thr" protect="rw">
        <bits access="rw" name="y_init_mode" pos="0" rst="0x1">
          <comment>1:    0</comment>
        </bits>
        <bits access="rw" name="y_low_en" pos="1" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="y_high_en" pos="2" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="y_low_thr" pos="7:3" rst="0x8">
          <comment>y_low_thr = [1h0, y_thr_reg[7:3], 2'h0]
                  y_high_thr = ~y_low_thr</comment>
        </bits>
      </reg>
      <reg name="y_ave_target" protect="rw">
        <bits access="rw" name="y_ave_target" pos="7:0" rst="0x78">
          <comment/>
        </bits>
      </reg>
      <reg name="y_lmt_offset" protect="rw">
        <bits access="rw" name="y_low_limit" pos="2:0" rst="0x5">
          <comment>Only for awb_adj, yaveAWB
                  y_low_limit = y_ave_target - [y_lmt_offset_reg[2:0],4'd0]</comment>
        </bits>
        <bits access="rw" name="y_lmt_ofst" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="y_high_limit" pos="6:4" rst="0x6">
          <comment>Only for awb_adj, yaveAWB
                  y_high_limit = y_ave_target+ [y_lmt_offset_reg[6:4],4'd0]</comment>
        </bits>
      </reg>
      <reg name="again_sel_th2" protect="rw">
        <bits access="rw" name="ynr_gain_low_th" pos="2:0" rst="0x4">
          <comment>nexp=low_th</comment>
        </bits>
        <bits access="rw" name="again_sel_th2" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="ynr_gain_hi_th" pos="6:4" rst="0x3">
          <comment>nexp&gt;(8+high_th)</comment>
        </bits>
      </reg>
      <reg name="yave_target_chg1" protect="rw">
        <bits access="rw" name="yave_target_ofst_l" pos="3:0" rst="0x4">
          <comment>yave_target (yave_target0)</comment>
        </bits>
        <bits access="rw" name="yave_target_ofst_h" pos="7:4" rst="0x8">
          <comment>yave_target (yave_target0)</comment>
        </bits>
      </reg>
      <reg name="image_eff_reg" protect="rw">
        <bits access="rw" name="grey_en" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="sepia_en" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="negative_en" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="color_bar_en" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="image_eff_rsvd" pos="4" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="reg93_sel" pos="5" rst="0x0">
          <comment>1reg93vbright_hist</comment>
        </bits>
        <bits access="rw" name="reg94_sel" pos="6" rst="0x0">
          <comment>1reg94vdark_hist</comment>
        </bits>
        <bits access="rw" name="sharp_mon" pos="7" rst="0x0">
          <comment>display edge pixel for sharpness</comment>
        </bits>
      </reg>
      <reg name="ywave_out" protect="ro">
        <bits access="ro" name="ywave_out" pos="7:0" rst="0x0">
          <comment>Ywave+bhist histYwave</comment>
        </bits>
      </reg>
      <reg name="ae_bright_hist" protect="ro">
        <bits access="ro" name="ae_bright_hist" pos="7:0" rst="0x0">
          <comment>bright hist</comment>
        </bits>
      </reg>
      <reg name="yave_out" protect="ro">
        <bits access="ro" name="yave_out" pos="7:0" rst="0x0">
          <comment>Yave+bhisthistYave</comment>
        </bits>
      </reg>
      <reg name="exp_out" protect="ro">
        <bits access="ro" name="exp_out" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="misc_out" protect="ro">
        <bits access="ro" name="exp_out_h" pos="2:0" rst="0x1">
          <comment>exp_out[10:8]</comment>
        </bits>
        <bits access="ro" name="awb_ok" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="ro" name="nexp_sel" pos="5:4" rst="0x0">
          <comment>nexp_selbnr/dpc/int_dif</comment>
        </bits>
        <bits access="ro" name="fixed_0" pos="6" rst="0x0">
          <comment/>
        </bits>
        <bits access="ro" name="ae_ok" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="awb_debug_out" protect="ro">
        <bits access="ro" name="awb_crgt" pos="1:0" rst="0x0">
          <comment>00: cr_lt_1x     01: cr_gt_1x
                  10: cr_gt_2x    11: cr_gt_4x</comment>
        </bits>
        <bits access="ro" name="awb_cbgt" pos="3:2" rst="0x0">
          <comment>00: cb_lt_1x    01: cb_gt_1x
                  10: cb_gt_2x    11: cb_gt_4x</comment>
        </bits>
        <bits access="ro" name="awb_crsum_sign" pos="4" rst="0x0">
          <comment>0:crsum   (5R  B+4G)
                  1:crsum   (5R  B+4G)</comment>
        </bits>
        <bits access="ro" name="awb_cbsum_sign" pos="5" rst="0x0">
          <comment>0:cbsum   (3B  R+2G)
                  1:cbsum   (3B  R+2G)</comment>
        </bits>
        <bits access="ro" name="awb_cbcr" pos="6" rst="0x0">
          <comment>0: crsum_abs  cbsum_abs  (crsum)
                  1: crsum_abs  cbsum_abs  (cbsum)</comment>
        </bits>
        <bits access="ro" name="awb_sum_vld" pos="7" rst="0x0">
          <comment>ae_index
                  Note: regd[5]? ae_vbright_hist :
                  reg75[7]? ae_index[6:0] : awb_debug;</comment>
        </bits>
      </reg>
      <reg name="mono_color" protect="ro">
        <bits access="ro" name="mono_color" pos="7:0" rst="0x0">
          <comment>YUVnexp vdark_hist
                  Note:  regd[6]? ae_vdark_hist :
                         reg5F[1]? nexp[3:0] : mono_color</comment>
        </bits>
      </reg>
      <reg name="r_awb_gain" protect="ro">
        <bits access="ro" name="r_awb_gain" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="b_awb_gain" protect="ro">
        <bits access="ro" name="b_awb_gain" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="misc_status" protect="ro">
        <bits access="ro" name="ana_gain_out" pos="5:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="ro" name="cc_type" pos="6" rst="0x0">
          <comment/>
        </bits>
        <bits access="ro" name="is_outdoor" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="yave_contr" protect="ro">
        <bits access="ro" name="yave_contr" pos="7:0" rst="0x0">
          <comment>yavehist
                  Vbh_sel[1]? Yave_contr_reg :
                  Vbh_sel[0]? Yave_target_RO_reg : ae_dark_hist
                  NoteVbh_sel[1:0] = reg3d[7:6]</comment>
        </bits>
      </reg>
      <reg name="gamma_type" protect="rw">
        <bits access="rw" name="gamma_type_mode" pos="2:0" rst="0x2">
          <comment>3d0:  gamma_type=0
                  3d1:  gamma_type=1
                  3d2:  gamma_type=is_outdoor
                  3d3:  gamma_type=ana_gain&gt;=gamma_gain_th
                  default:gamma_type=gamma_type_sw</comment>
        </bits>
        <bits access="rw" name="gamma_gain_hi_th" pos="5:3" rst="0x4">
          <comment>nexp&gt;(8+high_th)</comment>
        </bits>
        <bits access="rw" name="vgas" pos="7:6" rst="0x3">
          <comment>00:QVGA  240x320   01:QVGA 320x240
                  10:CIF   352x288   11:VGA  640x480</comment>
        </bits>
      </reg>
      <reg name="blc_line" protect="rw">
        <bits access="rw" name="blc_line" pos="7:0" rst="0x0">
          <comment>line_sel = [line_init_H, blc_line_reg[7:0]]</comment>
        </bits>
      </reg>
      <reg name="lsc_xx" protect="rw">
        <bits access="rw" name="x_low" pos="3:0" rst="0x8">
          <comment>lsc gain@</comment>
        </bits>
        <bits access="rw" name="x_high" pos="7:4" rst="0x8">
          <comment>lsc gain@</comment>
        </bits>
      </reg>
      <reg name="lsc_blc_gain_th" protect="rw">
        <bits access="rw" name="lsc_gain_low_th" pos="2:0" rst="0x4">
          <comment>nexp=low_th</comment>
        </bits>
        <bits access="rw" name="lsc_gain_hi_th" pos="5:3" rst="0x3">
          <comment>nexp&gt;(8+high_th)</comment>
        </bits>
        <bits access="rw" name="csup_gain_low_th" pos="7:6" rst="0x0">
          <comment>low_th = [csup_gain_low_th_H, [7:6]](nexp=low_th)</comment>
        </bits>
      </reg>
      <reg name="blc_ctrl" protect="rw">
        <bits access="rw" name="blc_out_mode" pos="1:0" rst="0x0">
          <comment>2'd0: [blc_out0_reg,blc_out1_reg] = [blc_00, blc_01]
                  2'd1: [blc_out0_reg,blc_out1_reg] = [blc_10, blc_11]
                  2'd2: [blc_out0_reg,blc_out1_reg] = [blc_00, blc_10]
                  2'd3: [blc_out0_reg,blc_out1_reg] = [blc_00, blc_11]</comment>
        </bits>
        <bits access="rw" name="line_init_h" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="blc_ofst_sign" pos="3" rst="0x0">
          <comment>0: plus   1: minus</comment>
        </bits>
        <bits access="rw" name="blc_mode" pos="5:4" rst="0x0">
          <comment>00: 1frame           01: 2frame ave
                  10: 3frame ave       11: 4frame ave</comment>
        </bits>
        <bits access="rw" name="blc_sel" pos="6" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="blc_en" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="blc_init" protect="rw">
        <bits access="rw" name="blc00_ofst" pos="3:0" rst="0x0">
          <comment>blc00_ofst =[blc_init_reg[3:0] , 1'b0]</comment>
        </bits>
        <bits access="rw" name="blc01_ofst" pos="7:4" rst="0x0">
          <comment>blc01_ofst =[blc_init_reg[7:4] , 1'b0]</comment>
        </bits>
      </reg>
      <reg name="blc_offset" protect="rw">
        <bits access="rw" name="blc10_ofst" pos="3:0" rst="0x0">
          <comment>blc10_ofst =[blc_offset_reg[3:0] , 1'b0]</comment>
        </bits>
        <bits access="rw" name="blc11_ofst" pos="7:4" rst="0x0">
          <comment>blc11_ofst =[blc_offset_reg[7:4] , 1'b0]</comment>
        </bits>
      </reg>
      <reg name="blc_thr" protect="rw">
        <bits access="rw" name="blc_thr" pos="5:0" rst="0x3e">
          <comment>High limit of black level pixel
                  blcofst</comment>
        </bits>
      </reg>
      <reg name="lsc_xy_cent" protect="rw">
        <bits access="rw" name="y_cent" pos="3:0" rst="0x4">
          <comment>y_cent=[3:0]+240</comment>
        </bits>
        <bits access="rw" name="x_cent" pos="7:4" rst="0x4">
          <comment>x_cent=[7:4]+320</comment>
        </bits>
      </reg>
      <reg name="cnr_dif_thr" protect="rw">
        <bits access="rw" name="cnr_v_en" pos="0" rst="0x1">
          <comment>CNR</comment>
        </bits>
        <bits access="rw" name="cnr_h_en" pos="1" rst="0x1">
          <comment>CNR</comment>
        </bits>
        <bits access="rw" name="vcnr_sel" pos="2" rst="0x1">
          <comment>1:  0:</comment>
        </bits>
        <bits access="rw" name="edge_mon" pos="3" rst="0x0">
          <comment>edge monitor</comment>
        </bits>
        <bits access="rw" name="awb_skin_mode" pos="6:4" rst="0x0">
          <comment>3d0: never skip           3d1: skip 2/8 skin point
                  3d2: skip 3/8 skin point  3d3: skip 4/8 skin point
                  3d4: skip 5/8 skin point  3d5: skip 6/8 skin point
                  3d6: skip 7/8 skin point  3d7: skip 8/8 skin point</comment>
        </bits>
        <bits access="ro" name="gamma_type" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="cnr_thr" protect="rw">
        <bits access="rw" name="cnr_thr_v" pos="2:0" rst="0x0">
          <comment>cnr_thr_v  = [cnr_thr[2:0], 2'd3]</comment>
        </bits>
        <bits access="rw" name="edge_en_v" pos="3" rst="0x0">
          <comment>enable</comment>
        </bits>
        <bits access="rw" name="cnr_thr_h" pos="6:4" rst="0x0">
          <comment>cnr_thr_h  = [cnr_thr[6:4], 2'd3]</comment>
        </bits>
        <bits access="rw" name="edge_en_h" pos="7" rst="0x0">
          <comment>enable</comment>
        </bits>
      </reg>
      <reg name="gamma_ctrl" protect="rw">
        <bits access="rw" name="gamma_p_id " pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gamma_l_id " pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gamma_en_non_outdoor" pos="2" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="gamma_en_outdoor" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="lsc_p_id" pos="4" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="lsc_l_id" pos="5" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="lsc_en_non_outdoor" pos="6" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="lsc_en_outdoor" pos="7" rst="0x1">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b0" protect="rw">
        <bits access="rw" name="bayer_gamma_b0" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b1" protect="rw">
        <bits access="rw" name="bayer_gamma_b1" pos="7:0" rst="0x9">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b2" protect="rw">
        <bits access="rw" name="bayer_gamma_b2" pos="7:0" rst="0x10">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b3" protect="rw">
        <bits access="rw" name="bayer_gamma_b3" pos="7:0" rst="0x16">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b4" protect="rw">
        <bits access="rw" name="bayer_gamma_b4" pos="7:0" rst="0x1c">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b6" protect="rw">
        <bits access="rw" name="bayer_gamma_b6" pos="7:0" rst="0x27">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b8" protect="rw">
        <bits access="rw" name="bayer_gamma_b8" pos="7:0" rst="0x30">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b10" protect="rw">
        <bits access="rw" name="bayer_gamma_b10" pos="7:0" rst="0x3a">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b12" protect="rw">
        <bits access="rw" name="bayer_gamma_b12" pos="7:0" rst="0x43">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b16" protect="rw">
        <bits access="rw" name="bayer_gamma_b16" pos="7:0" rst="0x54">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b20" protect="rw">
        <bits access="rw" name="bayer_gamma_b20" pos="7:0" rst="0x65">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b24" protect="rw">
        <bits access="rw" name="bayer_gamma_b24" pos="7:0" rst="0x75">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b28" protect="rw">
        <bits access="rw" name="bayer_gamma_b28" pos="7:0" rst="0x84">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b32" protect="rw">
        <bits access="rw" name="bayer_gamma_b32" pos="7:0" rst="0x93">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b36" protect="rw">
        <bits access="rw" name="bayer_gamma_b36" pos="7:0" rst="0xa1">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b40" protect="rw">
        <bits access="rw" name="bayer_gamma_b40" pos="7:0" rst="0xb0">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b48" protect="rw">
        <bits access="rw" name="bayer_gamma_b48" pos="7:0" rst="0xcb">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b56" protect="rw">
        <bits access="rw" name="bayer_gamma_b56" pos="7:0" rst="0xe6">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b64" protect="rw">
        <bits access="rw" name="bayer_gamma_b64" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="blc_out0" protect="ro">
        <bits access="ro" name="blc_out0" pos="7:0" rst="0x0">
          <comment>~awb_mon_sel? blc_out0_reg : kukl_sel ? kl : awb_mon_out[7:0]</comment>
        </bits>
      </reg>
      <reg name="blc_out1" protect="ro">
        <bits access="ro" name="blc_out1" pos="7:0" rst="0x0">
          <comment>~awb_mon_sel? blc_out1_reg : kukl_sel ? ku : awb_mon_out[15:8]
                   Note: awb_mon_sel = reg1[2] Kukl_sel    = reg5F[0]</comment>
        </bits>
      </reg>
      <reg name="dpc_ctrl_0" protect="rw">
        <bits access="rw" name="dpc_on" pos="0" rst="0x1">
          <comment>dpc on</comment>
        </bits>
        <bits access="rw" name="adp_med_sel" pos="1" rst="0x0">
          <comment>1: median  0:adp_median
                  sel=(nexp[3:0]&gt;dpc_ctrl0[3:2])? 1 : dpc_ctrl0[1]
                  This adp_med is used in int_dif_data and nrf_data_out</comment>
        </bits>
        <bits access="rw" name="ana_gain_cmp" pos="3:2" rst="0x2">
          <comment/>
        </bits>
        <bits access="rw" name="rsvd" pos="4" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="nrf_gaus_sel" pos="5" rst="0x0">
          <comment>1:gausian filter  0:median filter</comment>
        </bits>
        <bits access="rw" name="bayer_nr_on" pos="6" rst="0x0">
          <comment>bayer nr on</comment>
        </bits>
        <bits access="rw" name="cc_on" pos="7" rst="0x0">
          <comment>cc on</comment>
        </bits>
      </reg>
      <reg name="dpc_ctrl_1" protect="rw">
        <bits access="rw" name="int_flg_cmp" pos="1:0" rst="0x1">
          <comment>00: always not meet
          01: all round point must meet
          10: can be one except point
          11: can be two except point</comment>
        </bits>
        <bits access="rw" name="abs_sign_all_cmp" pos="3:2" rst="0x3">
          <comment>00: can be three sign diff with other
            01: can be two sign diff with other
            10: can be one sign diff with other
            11: 8 same sign</comment>
        </bits>
        <bits access="rw" name="int_dif_sel" pos="4" rst="0x0">
          <comment>1: gausian filter  0:median filter</comment>
        </bits>
      </reg>
      <reg name="y_thr_lo" protect="rw">
        <bits access="rw" name="y_thr_lo" pos="7:0" rst="0x12">
          <comment>Y_thr  @</comment>
        </bits>
      </reg>
      <reg name="y_thr_mid" protect="rw">
        <bits access="rw" name="y_thr_mid" pos="7:0" rst="0x18">
          <comment>Y_thr  @mid</comment>
        </bits>
      </reg>
      <reg name="y_thr_hi" protect="rw">
        <bits access="rw" name="y_thr_hi" pos="7:0" rst="0x18">
          <comment>Y_thr  @</comment>
        </bits>
      </reg>
      <reg name="intp_cfa_hv" protect="rw">
        <bits access="rw" name="cfa_v_thr_l" pos="2:0" rst="0x0">
          <comment>cfa_v_thr[2:0]</comment>
        </bits>
        <bits access="rw" name="rsvd1" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="cfa_h_thr_l" pos="6:4" rst="0x0">
          <comment>cfa_h_thr[2:0]</comment>
        </bits>
        <bits access="rw" name="rsvd2" pos="7" rst="0x0">
          <comment>not used here</comment>
        </bits>
      </reg>
      <reg name="manual_adj" protect="rw">
        <bits access="rw" name="b_gain_adj" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="g_gain_adj" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="r_gain_adj" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="ana_gain_adj" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="adj_direction" pos="4" rst="0x0">
          <comment>0: inc  1:dec</comment>
        </bits>
        <bits access="rw" name="index_manual_adj" pos="5" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="in_capture_awb" pos="6" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="in_capture_ae" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="dpc_int_thr_lo" protect="rw">
        <bits access="rw" name="dpc_int_thr_lo" pos="7:0" rst="0x10">
          <comment/>
        </bits>
      </reg>
      <reg name="dpc_int_thr_hi" protect="rw">
        <bits access="rw" name="dpc_int_thr_hi" pos="7:0" rst="0x30">
          <comment/>
        </bits>
      </reg>
      <reg name="again_sel_th1" protect="rw">
        <bits access="rw" name="bnr_gain_low_th" pos="2:0" rst="0x4">
          <comment>nexp=low_th @bnr/dpc/int_dif/sharp/cnr</comment>
        </bits>
        <bits access="rw" name="again_sel_th1_rsvd" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="bnr_gain_hi_th" pos="6:4" rst="0x3">
          <comment>nexp&gt;(8+high_th) @bnr/dpc/int_dif/sharp/cnr</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_lf_str_lo" protect="rw">
        <bits access="rw" name="dpc_nr_lf_str_lo" pos="7:0" rst="0x80">
          <comment>bnr low frequency str @Low gain @
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_hf_str_lo" protect="rw">
        <bits access="rw" name="dpc_nr_hf_str_lo" pos="7:0" rst="0x10">
          <comment>bnr high frequency str @Low gain
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_area_thr_lo" protect="rw">
        <bits access="rw" name="dpc_nr_area_thr_lo" pos="7:0" rst="0x80">
          <comment>4.4 format, 16x ~ 1/16x @Low gain
                  HF</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_lf_str_mid" protect="rw">
        <bits access="rw" name="dpc_nr_lf_str_mid" pos="7:0" rst="0xa0">
          <comment>bnr low frequency str @Mid gain
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_hf_str_mid" protect="rw">
        <bits access="rw" name="dpc_nr_hf_str_mid" pos="7:0" rst="0x20">
          <comment>bnr high frequency str @Mid gain
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_area_thr_mid" protect="rw">
        <bits access="rw" name="dpc_nr_area_thr_mid" pos="7:0" rst="0x80">
          <comment>4.4 format, 16x ~ 1/16x @Mid gain
                  HF</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_lf_str_hi" protect="rw">
        <bits access="rw" name="dpc_nr_lf_str_hi" pos="7:0" rst="0xc0">
          <comment>bnr low frequency str @high gain @
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_hf_str_hi" protect="rw">
        <bits access="rw" name="dpc_nr_hf_str_hi" pos="7:0" rst="0x40">
          <comment>bnr high frequency str @high gain
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_area_thr_hi" protect="rw">
        <bits access="rw" name="dpc_nr_area_thr_hi" pos="7:0" rst="0x80">
          <comment>4.4 format, 16x ~ 1/16x @high gain
                  HF</comment>
        </bits>
      </reg>
      <reg name="intp_ctrl" protect="rw">
        <bits access="rw" name="pid_inv_en" pos="0" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="lid_inv_en" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gfilter_en" pos="2" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="gfilter3_en" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gfliter5_en" pos="4" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="sort_sel" pos="7:5" rst="0x3">
          <comment>0: 9        1:7
                  2: 5  3:3
                  4: median              5: adp_median</comment>
        </bits>
      </reg>
      <reg name="intp_cfa_h_thr" protect="rw">
        <bits access="rw" name="intp_cfa_h_thr" pos="7:0" rst="0x0">
          <comment>cfa_h_thr=[intp_cfa_h_thr[7:0], intp_cfa_hv[6:4]]</comment>
        </bits>
      </reg>
      <reg name="intp_cfa_v_thr" protect="rw">
        <bits access="rw" name="intp_cfa_v_thr" pos="7:0" rst="0x0">
          <comment>cfa_v_thr=[intp_cfa_v_thr[7:0], intp_cfa_hv[2:0]]</comment>
        </bits>
      </reg>
      <reg name="intp_grgb_sel_lmt" protect="rw">
        <bits access="rw" name="intp_grgb_sel_lmt" pos="7:0" rst="0x8">
          <comment/>
        </bits>
      </reg>
      <reg name="intp_gf_lmt_thr" protect="rw">
        <bits access="rw" name="intp_gf_lmt_thr" pos="7:0" rst="0x83">
          <comment>gf_lmt_thr=[3d0, intp_gf_lmt_thr_reg]</comment>
        </bits>
      </reg>
      <reg name="cc_r_offset" protect="rw">
        <bits access="rw" name="cc_r_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc_g_offset" protect="rw">
        <bits access="rw" name="cc_g_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc_b_offset" protect="rw">
        <bits access="rw" name="cc_b_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc_00" protect="rw">
        <bits access="rw" name="cc_00" pos="7:0" rst="0x58">
          <comment>S1.6 format, x1=64, cc00+cc01+cc02=1</comment>
        </bits>
      </reg>
      <reg name="cc_01" protect="rw">
        <bits access="rw" name="cc_01" pos="7:0" rst="0x90">
          <comment/>
        </bits>
      </reg>
      <reg name="cc_10" protect="rw">
        <bits access="rw" name="cc_10" pos="7:0" rst="0x88">
          <comment>S1.6 format, x1=64, cc10+cc11+cc12=1</comment>
        </bits>
      </reg>
      <reg name="cc_11" protect="rw">
        <bits access="rw" name="cc_11" pos="7:0" rst="0x50">
          <comment/>
        </bits>
      </reg>
      <reg name="cc_20" protect="rw">
        <bits access="rw" name="cc_20" pos="7:0" rst="0x88">
          <comment>S1.6 format, x1=64, cc20+cc21+cc22=1</comment>
        </bits>
      </reg>
      <reg name="cc_21" protect="rw">
        <bits access="rw" name="cc_21" pos="7:0" rst="0x90">
          <comment/>
        </bits>
      </reg>
      <reg name="cc_r_offset_post" protect="rw">
        <bits access="rw" name="cc_r_offset_post" pos="7:0" rst="0x0">
          <comment>S7 format, after cc</comment>
        </bits>
      </reg>
      <reg name="cc_g_offset_post" protect="rw">
        <bits access="rw" name="cc_g_offset_post" pos="7:0" rst="0x0">
          <comment>S7 format, after cc</comment>
        </bits>
      </reg>
      <reg name="cc_b_offset_post" protect="rw">
        <bits access="rw" name="cc_b_offset_post" pos="7:0" rst="0x0">
          <comment>S7 format, after cc</comment>
        </bits>
      </reg>
      <reg name="cc2_r_offset" protect="rw">
        <bits access="rw" name="cc2_r_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc2_g_offset" protect="rw">
        <bits access="rw" name="cc2_g_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc2_b_offset" protect="rw">
        <bits access="rw" name="cc2_b_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc2_00" protect="rw">
        <bits access="rw" name="cc2_00" pos="7:0" rst="0x40">
          <comment>S1.6 format, x1=64, cc00+cc01+cc02=1</comment>
        </bits>
      </reg>
      <reg name="cc2_01" protect="rw">
        <bits access="rw" name="cc2_01" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="cc2_10" protect="rw">
        <bits access="rw" name="cc2_10" pos="7:0" rst="0x0">
          <comment>S1.6 format, x1=64, cc10+cc11+cc12=1</comment>
        </bits>
      </reg>
      <reg name="cc2_11" protect="rw">
        <bits access="rw" name="cc2_11" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="cc2_20" protect="rw">
        <bits access="rw" name="cc2_20" pos="7:0" rst="0x0">
          <comment>S1.6 format, x1=64, cc20+cc21+cc22=1</comment>
        </bits>
      </reg>
      <reg name="cc2_21" protect="rw">
        <bits access="rw" name="cc2_21" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="sharp_lmt" protect="rw">
        <bits access="rw" name="sharp_lmt" pos="6:0" rst="0x7f">
          <comment>sharp data</comment>
        </bits>
        <bits access="rw" name="sharp_final_h" pos="7" rst="0x0">
          <comment>db/da/d9</comment>
        </bits>
      </reg>
      <reg name="sharp_mode" protect="rw">
        <bits access="rw" name="sharp_cmp_gap_lo" pos="3:0" rst="0x0">
          <comment>sharp_cmp&gt; (sharp_nr_area_thr[6:0]+sharp_cmp_gap)</comment>
        </bits>
        <bits access="rw" name="sharp_final" pos="5:4" rst="0x0">
          <comment>0: delay_df
                  1: delay_de
                  2: delay_dd
                  3: delay_dc</comment>
        </bits>
        <bits access="rw" name="sharp_sel" pos="6" rst="0x0">
          <comment>1:ppdif_sum
                  0:pp_dif (8)</comment>
        </bits>
        <bits access="rw" name="rgb_test_pattern" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="sharp_gain_str_lo" protect="rw">
        <bits access="rw" name="sharp_gain_str_lo" pos="7:0" rst="0x60">
          <comment>plus @Low gain (2.6 format)@</comment>
        </bits>
      </reg>
      <reg name="sharp_nr_area_thr_lo" protect="rw">
        <bits access="rw" name="sharp_nr_area_thr_lo" pos="6:0" rst="0x10">
          <comment>Sharp@Low gain
                  (edge)</comment>
        </bits>
      </reg>
      <reg name="sharp_gain_str_mid" protect="rw">
        <bits access="rw" name="sharp_gain_str_mid" pos="7:0" rst="0x60">
          <comment>plus @Mid gain (2.6 format)</comment>
        </bits>
      </reg>
      <reg name="sharp_nr_area_thr_mid" protect="rw">
        <bits access="rw" name="sharp_nr_area_thr_mid" pos="6:0" rst="0x10">
          <comment>Sharp@Mid gain
                  (edge)</comment>
        </bits>
      </reg>
      <reg name="sharp_gain_str_hi" protect="rw">
        <bits access="rw" name="sharp_gain_str_hi" pos="7:0" rst="0x60">
          <comment>plus @high gain (2.6 format)@</comment>
        </bits>
      </reg>
      <reg name="sharp_nr_area_thr_hi" protect="rw">
        <bits access="rw" name="sharp_nr_area_thr_hi" pos="6:0" rst="0x10">
          <comment>Sharp@high gain
                  (edge)</comment>
        </bits>
      </reg>
      <reg name="ynr_ctrl_reg" protect="rw">
        <bits access="rw" name="ynr_on" pos="0" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="ynr_edge_methode" pos="2:1" rst="0">
          <comment>(Ey)
        2d0:Ey_H/V/D1/D2
        2d1:
        2d2:
        2d3:</comment>
        </bits>
        <bits access="rw" name="sharp_on" pos="3" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="sharp_plus_mode" pos="5:4" rst="0">
          <comment>(sharpness)
                  00:
                  if(i_y_data8'ha0)       sharp_data = sharp_out[6:2];
                  else if(i_y_data8'h80)  sharp_data = sharp_out[6:1];
                  else                      sharp_data = sharp_out[6:0];
                  01: 0x80pixelsharpness
                  10: 0x90pixelsharpness
                  11:  No change</comment>
        </bits>
        <bits access="rw" name="y_ae_sel" pos="7:6" rst="0">
          <comment>AEYin
                  00:y=yuv_y
                  01:y=y_gamma   // after ygamma
                  10:y=luma_y_out // after y_luma
                  11:y=contr_y_out // after y_contr</comment>
        </bits>
      </reg>
      <reg name="ynr_lf_method_str" protect="rw">
        <bits access="rw" name="ynr_lf_method_str" pos="7:0" rst="0x00">
          <comment>GMYc</comment>
        </bits>
      </reg>
      <reg name="ynr_lf_str_lo" protect="rw">
        <bits access="rw" name="ynr_lf_str_lo" pos="7:0" rst="0x80">
          <comment>@low gain
                 GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_hf_str_lo" protect="rw">
        <bits access="rw" name="ynr_hf_str_lo" pos="7:0" rst="0x10">
          <comment>@low gain
               GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_area_thr_lo" protect="rw">
        <bits access="rw" name="ynr_area_thr_lo" pos="7:0" rst="0xc0">
          <comment>4.4 format, 16x ~ 1/16x @low gain
               HF</comment>
        </bits>
      </reg>
      <reg name="ynr_lf_str_mid" protect="rw">
        <bits access="rw" name="ynr_lf_str_mid" pos="7:0" rst="0xa0">
          <comment>@Mid gain
         GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_hf_str_mid" protect="rw">
        <bits access="rw" name="ynr_hf_str_mid" pos="7:0" rst="0x20">
          <comment>@Mid gain
        GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_area_thr_mid" protect="rw">
        <bits access="rw" name="ynr_area_thr_mid" pos="7:0" rst="0x80">
          <comment>4.4 format, 16x ~ 1/16x @Mid gain
                  HF</comment>
        </bits>
      </reg>
      <reg name="ynr_lf_str_hi" protect="rw">
        <bits access="rw" name="ynr_lf_str_hi" pos="7:0" rst="0xc0">
          <comment>@high gain
                GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_hf_str_hi" protect="rw">
        <bits access="rw" name="ynr_hf_str_hi" pos="7:0" rst="0x40">
          <comment>@high gain
               GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_area_thr_hi " protect="rw">
        <bits access="rw" name="ynr_area_thr_hi " pos="7:0" rst="0x20">
          <comment>4.4 format, 16x ~ 1/16x @high gain
                   HF</comment>
        </bits>
      </reg>
      <reg name="hue_sin_reg " protect="rw">
        <bits access="rw" name="hue_sin_reg " pos="7:0" rst="0x2c">
          <comment>sinx[7:0]=256*sin(x*pi/180)</comment>
        </bits>
      </reg>
      <reg name="hue_cos_reg" protect="rw">
        <bits access="rw" name="hue_cosx_reg" pos="6:0" rst="0x7c">
          <comment>cosx[7:0]=256*cos(x*pi/180)
                  cosx[7] fixed as 1, As abs(x) = pi/4</comment>
        </bits>
        <bits access="rw" name="sin_sign_reg" pos="7" rst="1">
          <comment>1: sinx is negative
        	      0: sinx is positive</comment>
        </bits>
      </reg>
      <reg name="cnr_1d_ctrl_reg" protect="rw">
        <bits access="rw" name="cnr_dif_thr_mid" pos="3:0" rst="0x8">
          <comment>CNR@Mid gain</comment>
        </bits>
        <bits access="rw" name="cnr_1d_on" pos="4" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name=" satur_on" pos="5" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="hue_on" pos="6" rst="0">
          <comment/>
        </bits>
      </reg>
      <reg name="cnr_xx_reg" protect="rw">
        <bits access="rw" name="cnr_dif_thr_low" pos="3:0" rst="0x4">
          <comment>CNR@Low gain</comment>
        </bits>
        <bits access="rw" name="cnr_dif_thr_high" pos="7:4" rst="0xc">
          <comment>CNR@High gain</comment>
        </bits>
      </reg>
      <reg name="in5_low_th_reg" protect="rw">
        <bits access="rw" name="in5_low_th_reg" pos="7:0" rst="0x40">
          <comment>Center point smaller than around, black point</comment>
        </bits>
      </reg>
      <reg name="in5_high_th_reg" protect="rw">
        <bits access="rw" name="in5_high_th_reg" pos="7:0" rst="0x90">
          <comment>Center point bigger than around, white point</comment>
        </bits>
      </reg>
      <hole size="72*32"/>
      <reg name="p2_up_r_reg" protect="rw">
        <bits access="rw" name="p2_up_r_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_up_g_reg" protect="rw">
        <bits access="rw" name="p2_up_g_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_up_b_reg" protect="rw">
        <bits access="rw" name="p2_up_b_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_down_r_reg" protect="rw">
        <bits access="rw" name="p2_down_r_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_down_g_reg" protect="rw">
        <bits access="rw" name="p2_down_g_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_down_b_reg" protect="rw">
        <bits access="rw" name="p2_down_b_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_left_r_reg" protect="rw">
        <bits access="rw" name="p2_left_r_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_left_g_reg" protect="rw">
        <bits access="rw" name="p2_left_g_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_left_b_reg" protect="rw">
        <bits access="rw" name="p2_left_b_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_right_r_reg" protect="rw">
        <bits access="rw" name="p2_right_r_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_right_g_reg" protect="rw">
        <bits access="rw" name="p2_right_g_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_right_b_reg" protect="rw">
        <bits access="rw" name="p2_right_b_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q1_r_reg" protect="rw">
        <bits access="rw" name="p4_q1_r_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q1_g_reg" protect="rw">
        <bits access="rw" name="p4_q1_g_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q1_b_reg" protect="rw">
        <bits access="rw" name="p4_q1_b_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q2_r_reg" protect="rw">
        <bits access="rw" name="p4_q2_r_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q2_g_reg" protect="rw">
        <bits access="rw" name="p4_q2_g_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q2_b_reg" protect="rw">
        <bits access="rw" name="p4_q2_b_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q3_r_reg" protect="rw">
        <bits access="rw" name="p4_q3_r_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q3_g_reg" protect="rw">
        <bits access="rw" name="p4_q3_g_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q3_b_reg" protect="rw">
        <bits access="rw" name="p4_q3_b_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q4_r_reg" protect="rw">
        <bits access="rw" name="p4_q4_r_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q4_g_reg" protect="rw">
        <bits access="rw" name="p4_q4_g_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q4_b_reg" protect="rw">
        <bits access="rw" name="p4_q4_b_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="ae_e00_sta_reg" protect="rw">
        <bits access="rw" name="ae_e00_sta_line" pos="5:0" rst="0x2">
          <comment>E00</comment>
        </bits>
      </reg>
      <reg name="ae_e00_num_reg" protect="rw">
        <bits access="rw" name="ae_e00_num" pos="3:0" rst="0x7">
          <comment>E00</comment>
        </bits>
        <bits access="rw" name="ae_e00_interval" pos="5:4" rst="0x2">
          <comment>E00 max is 3Line</comment>
        </bits>
      </reg>
      <reg name="ae_e01_sta_reg" protect="rw">
        <bits access="rw" name="ae_e01_sta_line" pos="5:0" rst="0x10">
          <comment>E01</comment>
        </bits>
      </reg>
      <reg name="ae_e01_num_reg" protect="rw">
        <bits access="rw" name="ae_e01_num" pos="3:0" rst="0x4">
          <comment>E01</comment>
        </bits>
        <bits access="rw" name="ae_e01_interval" pos="6:4" rst="0x4">
          <comment>E01 max is 7Line</comment>
        </bits>
      </reg>
      <reg name="ae_e02_sta_reg" protect="rw">
        <bits access="rw" name="ae_e02_sta_line" pos="6:0" rst="0x20">
          <comment>E02max is 7F</comment>
        </bits>
      </reg>
      <reg name="ae_e02_num_reg" protect="rw">
        <bits access="rw" name="ae_e02_num" pos="3:0" rst="0x6">
          <comment>E02</comment>
        </bits>
        <bits access="rw" name="ae_e02_interval" pos="7:4" rst="0x8">
          <comment>E02 max is 15Line</comment>
        </bits>
      </reg>
      <reg name="ae_e1_sta_reg" protect="rw">
        <bits access="rw" name="ae_e1_sta_gain" pos="5:0" rst="0x0">
          <comment>E1 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e1_num_reg" protect="rw">
        <bits access="rw" name="ae_e1_num_reg" pos="3:0" rst="0x7">
          <comment>E1 (1E)</comment>
        </bits>
      </reg>
      <reg name="ae_e2_sta_reg" protect="rw">
        <bits access="rw" name="ae_e2_sta_gain" pos="5:0" rst="0x0">
          <comment>E2 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e2_num_reg" protect="rw">
        <bits access="rw" name="ae_e2_num_reg" pos="3:0" rst="0x4">
          <comment>E2 (2E)</comment>
        </bits>
      </reg>
      <reg name="ae_e3_sta_reg" protect="rw">
        <bits access="rw" name="ae_e3_sta_gain" pos="5:0" rst="0x0">
          <comment>E3 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e3_num_reg" protect="rw">
        <bits access="rw" name="ae_e3_num_reg" pos="3:0" rst="0x3">
          <comment>E3 (3E)</comment>
        </bits>
      </reg>
      <reg name="ae_e4_sta_reg" protect="rw">
        <bits access="rw" name="ae_e4_sta_gain" pos="5:0" rst="0x0">
          <comment>E4 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e4_num_reg" protect="rw">
        <bits access="rw" name="ae_e4_num_reg" pos="4:0" rst="0x9">
          <comment>E4 (4E)</comment>
        </bits>
      </reg>
      <reg name="ae_e5_sta_reg" protect="rw">
        <bits access="rw" name="ae_e5_sta_gain" pos="5:0" rst="0xa">
          <comment>E5 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e5_num_reg" protect="rw">
        <bits access="rw" name="ae_e5_num_reg" pos="4:0" rst="0x8">
          <comment>E5 (5E)</comment>
        </bits>
      </reg>
      <reg name="ae_e6_sta_reg" protect="rw">
        <bits access="rw" name="ae_e6_sta_gain" pos="5:0" rst="0x15">
          <comment>E6 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e6_num_reg" protect="rw">
        <bits access="rw" name="ae_e6_num_reg" pos="3:0" rst="0x6">
          <comment>E6 (6E)</comment>
        </bits>
      </reg>
      <reg name="ae_e7_sta_reg" protect="rw">
        <bits access="rw" name="ae_e7_sta_gain" pos="5:0" rst="0x1d">
          <comment>E7 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e7_num_reg" protect="rw">
        <bits access="rw" name="ae_e7_num_reg" pos="3:0" rst="0x3">
          <comment>E7 (7E)</comment>
        </bits>
      </reg>
      <reg name="ae_e8_sta_reg" protect="rw">
        <bits access="rw" name="ae_e8_sta_gain" pos="5:0" rst="0x20">
          <comment>E8 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e8_num_reg" protect="rw">
        <bits access="rw" name="ae_e8_num_reg" pos="3:0" rst="0x3">
          <comment>E8 (8E)</comment>
        </bits>
      </reg>
      <reg name="ae_e9_sta_reg" protect="rw">
        <bits access="rw" name="ae_e9_sta_gain" pos="5:0" rst="0x23">
          <comment>E9 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e9_num_reg" protect="rw">
        <bits access="rw" name="ae_e9_num_reg" pos="3:0" rst="0x3">
          <comment>E9 (9E)</comment>
        </bits>
      </reg>
      <reg name="ae_ea_sta_reg" protect="rw">
        <bits access="rw" name="ae_ea_sta_gain" pos="5:0" rst="0x26">
          <comment>Ea (64)</comment>
        </bits>
      </reg>
      <reg name="ae_ea_num_reg" protect="rw">
        <bits access="rw" name="ae_ea_num_reg" pos="3:0" rst="0x3">
          <comment>Ea (aE)</comment>
        </bits>
      </reg>
      <reg name="ae_eb_sta_reg" protect="rw">
        <bits access="rw" name="ae_eb_sta_gain" pos="5:0" rst="0x29">
          <comment>Eb (64)</comment>
        </bits>
      </reg>
      <reg name="ae_eb_num_reg" protect="rw">
        <bits access="rw" name="ae_eb_num_reg" pos="3:0" rst="0x3">
          <comment>Eb (bE)</comment>
        </bits>
      </reg>
      <reg name="ae_ec_sta_reg" protect="rw">
        <bits access="rw" name="ae_ec_sta_gain" pos="5:0" rst="0x2c">
          <comment>Ec (64)</comment>
        </bits>
      </reg>
      <reg name="ae_ec_num_reg" protect="rw">
        <bits access="rw" name="ae_ec_num_reg" pos="3:0" rst="0x5">
          <comment>Ec (cE)</comment>
        </bits>
      </reg>
      <reg name="ae_ed_sta_reg" protect="rw">
        <bits access="rw" name="ae_ed_sta_gain" pos="5:0" rst="0x0">
          <comment>Ed (64)</comment>
        </bits>
      </reg>
      <reg name="ae_ed_num_reg" protect="rw">
        <bits access="rw" name="ae_ed_num_reg" pos="3:0" rst="0x0">
          <comment>Ed (dE)</comment>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b0" protect="rw">
        <bits access="rw" name="bayer_gamma2_b0" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b1" protect="rw">
        <bits access="rw" name="bayer_gamma2_b1" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b2" protect="rw">
        <bits access="rw" name="bayer_gamma2_b2" pos="7:0" rst="0x2d">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b3" protect="rw">
        <bits access="rw" name="bayer_gamma2_b3" pos="7:0" rst="0x37">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b4" protect="rw">
        <bits access="rw" name="bayer_gamma2_b4" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b6" protect="rw">
        <bits access="rw" name="bayer_gamma2_b6" pos="7:0" rst="0x4e">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b8" protect="rw">
        <bits access="rw" name="bayer_gamma2_b8" pos="7:0" rst="0x5a">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b10" protect="rw">
        <bits access="rw" name="bayer_gamma2_b10" pos="7:0" rst="0x65">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b12" protect="rw">
        <bits access="rw" name="bayer_gamma2_b12" pos="7:0" rst="0x6f">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b16" protect="rw">
        <bits access="rw" name="bayer_gamma2_b16" pos="7:0" rst="0x80">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b20" protect="rw">
        <bits access="rw" name="bayer_gamma2_b20" pos="7:0" rst="0x8f">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b24" protect="rw">
        <bits access="rw" name="bayer_gamma2_b24" pos="7:0" rst="0x9c">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b28" protect="rw">
        <bits access="rw" name="bayer_gamma2_b28" pos="7:0" rst="0xa9">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b32" protect="rw">
        <bits access="rw" name="bayer_gamma2_b32" pos="7:0" rst="0xb5">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b36" protect="rw">
        <bits access="rw" name="bayer_gamma2_b36" pos="7:0" rst="0xc0">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b40" protect="rw">
        <bits access="rw" name="bayer_gamma2_b40" pos="7:0" rst="0xca">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b48" protect="rw">
        <bits access="rw" name="bayer_gamma2_b48" pos="7:0" rst="0xdd">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b56" protect="rw">
        <bits access="rw" name="bayer_gamma2_b56" pos="7:0" rst="0xef">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b64" protect="rw">
        <bits access="rw" name="bayer_gamma2_b64" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="y_thr7_lo_reg" protect="rw">
        <bits access="rw" name="y_thr7_lo_reg" pos="7:0" rst="0x30">
          <comment>Y_thr7 (for 2 dead point) @</comment>
        </bits>
      </reg>
      <reg name="y_thr7_mid_reg" protect="rw">
        <bits access="rw" name="y_thr7_mid_reg" pos="7:0" rst="0x38">
          <comment>Y_thr7 (for 2 dead point) @ mid</comment>
        </bits>
      </reg>
      <reg name="y_thr7_hi_reg" protect="rw">
        <bits access="rw" name="y_thr7_hi_reg" pos="7:0" rst="0x40">
          <comment>Y_thr7 (for 2 dead point) @</comment>
        </bits>
      </reg>
      <reg name="dpa_new_ctrl_reg" protect="rw">
        <bits access="rw" name="inflg_ctrl_reg_0" pos="0" rst="0x1">
          <comment>0: check one black dead point
                   1: don't check one black dead point</comment>
        </bits>
        <bits access="rw" name="inflg_ctrl_reg_1" pos="1" rst="0x1">
          <comment>0: check 2 black dead point
                   1: don't check 2 black dead point</comment>
        </bits>
        <bits access="rw" name="inflg_ctrl_reg_2" pos="2" rst="0x1">
          <comment>0: don't check 2 dead point
              1: check 2 dead point</comment>
        </bits>
      </reg>
      <reg name="dpa_new_ctrl_hi_reg" protect="rw">
        <bits access="rw" name="inflg_ctrl_reg0_h" pos="0" rst="0x0">
          <comment>(Note)
                   0: check one black dead point
                   1: don't check one black dead point</comment>
        </bits>
        <bits access="rw" name="inflg_ctrl_reg1_h" pos="1" rst="0x0">
          <comment>(Note)
                   0: check 2 black dead point
                   1: don't check 2 black dead point</comment>
        </bits>
        <bits access="rw" name="inflg_ctrl_reg2_h" pos="2" rst="0x1">
          <comment>(Note)
                   0: don't check 2 dead point
                   1: check 2 dead point</comment>
        </bits>
        <bits access="rw" name="threshold_rsvd" pos="4:3" rst="0x2">
          <comment>not used here</comment>
        </bits>
      </reg>
      <reg name="ae_index_gap" protect="rw">
        <bits access="rw" name="gap_2e" pos="0" rst="0x0">
          <comment>2E 12</comment>
        </bits>
        <bits access="rw" name="gap_3e" pos="1" rst="0x0">
          <comment>3E 12</comment>
        </bits>
        <bits access="rw" name="gap_4e" pos="2" rst="0x0">
          <comment>4E 12</comment>
        </bits>
        <bits access="rw" name="gap_5e" pos="3" rst="0x0">
          <comment>5E 12</comment>
        </bits>
        <bits access="rw" name="gap_6e" pos="4" rst="0x0">
          <comment>6E 12</comment>
        </bits>
        <bits access="rw" name="gap_7e" pos="5" rst="0x0">
          <comment>7E 12</comment>
        </bits>
        <bits access="rw" name="gap_8e" pos="6" rst="0x0">
          <comment>8E 12</comment>
        </bits>
        <bits access="rw" name="gap_9e" pos="7" rst="0x0">
          <comment>9E 12</comment>
        </bits>
      </reg>
      <reg name="awb_calc_height_reg" protect="rw">
        <bits access="rw" name="awb_calc_height_reg" pos="7:0" rst="0xf0">
          <comment>awb_win_height = [[7:0],1'd0]
            //4:3 and keep height as even number</comment>
        </bits>
      </reg>
      <reg name="drc_r_clp_value_reg" protect="rw">
        <bits access="rw" name="drc_r_clp_value_reg" pos="5:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="drc_gr_clp_value_reg" protect="rw">
        <bits access="rw" name="drc_gr_clp_value_reg" pos="5:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="drc_gb_clp_value_reg" protect="rw">
        <bits access="rw" name="drc_gb_clp_value_reg" pos="5:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="drc_b_clp_value_reg" protect="rw">
        <bits access="rw" name="drc_b_clp_value_reg" pos="5:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="sepia_cr_reg" protect="rw">
        <bits access="rw" name="sepia_cr_reg" pos="7:0" rst="0xab">
          <comment>blue: 0x72  red: 0xD4  brown:0xAB</comment>
        </bits>
      </reg>
      <reg name="sepia_cb_reg" protect="rw">
        <bits access="rw" name="sepia_cb_reg" pos="7:0" rst="0x60">
          <comment>blue: 0xD4  red: 0x64  brown:0x60</comment>
        </bits>
      </reg>
      <reg name="csup_y_min_hi_reg" protect="rw">
        <bits access="rw" name="csup_y_min_hi_reg" pos="7:0" rst="0xdc">
          <comment/>
        </bits>
      </reg>
      <reg name="csup_gain_hi_reg" protect="rw">
        <bits access="rw" name="csup_gain_hi_reg" pos="7:0" rst="0x00">
          <comment>0x20~ff (x1~8) ()</comment>
        </bits>
      </reg>
      <reg name="csup_y_max_low_reg" protect="rw">
        <bits access="rw" name="csup_y_max_low_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="csup_gain_low_reg" protect="rw">
        <bits access="rw" name="csup_gain_low_reg" pos="7:0" rst="0x00">
          <comment>0x20~ff (x1~8) ()</comment>
        </bits>
      </reg>
      <reg name="ae_dk_hist_thr_reg" protect="rw">
        <bits access="rw" name="ae_dk_hist_thr_reg" pos="7:0" rst="0x48">
          <comment>If bhist&gt;bhist_too_big_thr, then bhist_too_big</comment>
        </bits>
      </reg>
      <reg name="ae_br_hist_thr_reg" protect="rw">
        <bits access="rw" name="ae_br_hist_thr_reg" pos="7:0" rst="0x18">
          <comment>If bhist&gt;bhist_big_thr, then bhist_big</comment>
        </bits>
      </reg>
      <reg name="hist_bp_level_reg" protect="rw">
        <bits access="rw" name="hist_bp_level_reg" pos="7:0" rst="0xd0">
          <comment>Y level of bhist and 4pbhist</comment>
        </bits>
      </reg>
      <reg name="outdoor_th_reg" protect="rw">
        <bits access="rw" name="outdoor_th" pos="3:0" rst="0x4">
          <comment>outdoor_th=[outdoor_th_reg[3:0], 4'd0]</comment>
        </bits>
        <bits access="rw" name="non_outdoor_th" pos="7:4" rst="0x8">
          <comment>non_outdoor_th=[outdoor_th_reg[7:4], 4'd0]</comment>
        </bits>
      </reg>
      <reg name="awb_rgain_low_reg" protect="rw">
        <bits access="rw" name="awb_rgain_low_reg" pos="7:2" rst="0xe">
          <comment>Low limit of rgain = [[7:2], 2d0]</comment>
        </bits>
      </reg>
      <reg name="awb_rgain_high_reg" protect="rw">
        <bits access="rw" name="awb_rgain_high_reg" pos="7:2" rst="0x1c">
          <comment>High limit of rgain = [[7:2], 2d0]</comment>
        </bits>
      </reg>
      <reg name="awb_bgain_low_reg" protect="rw">
        <bits access="rw" name="awb_bgain_low_reg" pos="7:2" rst="0xe">
          <comment>Low limit of bgain = [[7:2], 2d0]</comment>
        </bits>
      </reg>
      <reg name="awb_bgain_high_reg" protect="rw">
        <bits access="rw" name="awb_bgain_high_reg" pos="7:2" rst="0x20">
          <comment>High limit of bgain = [[7:2], 2d0]</comment>
        </bits>
      </reg>
      <reg name="awb_calc_start_reg" protect="rw">
        <bits access="rw" name="awb_win_y_start" pos="3:0" rst="0x1">
          <comment>awb_win_y_start = [[3:0], 2'd0];</comment>
        </bits>
        <bits access="rw" name="awb_win_x_start" pos="7:4" rst="0x1">
          <comment>awb_win_x_start = [[7:4], 2'd0];</comment>
        </bits>
      </reg>
      <reg name="awb_calc_width_reg" protect="rw">
        <bits access="rw" name="awb_calc_width_reg" pos="7:0" rst="0xa0">
          <comment>awb_win_width =[[7:0],2'd0];
            //4:3 and keep height as even number</comment>
        </bits>
      </reg>
      <reg name="hist_dp_level_reg" protect="rw">
        <bits access="rw" name="hist_dp_level_reg" pos="7:0" rst="0x30">
          <comment>Y level of dark_hist</comment>
        </bits>
      </reg>
      <reg name="awb_y_fmin" protect="rw">
        <bits access="rw" name="awb_y_fmin" pos="7:0" rst="0x40">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_y_fmax" protect="rw">
        <bits access="rw" name="awb_y_fmax" pos="7:0" rst="0xb4">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_cb_fmin" protect="rw">
        <bits access="rw" name="awb_cb_fmin" pos="7:0" rst="0x4d">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_cb_fmax" protect="rw">
        <bits access="rw" name="awb_cb_fmax" pos="7:0" rst="0x7f">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_cr_fmin" protect="rw">
        <bits access="rw" name="awb_cr_fmin" pos="7:0" rst="0x85">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_cr_fmax" protect="rw">
        <bits access="rw" name="awb_cr_fmax" pos="7:0" rst="0xad">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_y_fmin2" protect="rw">
        <bits access="rw" name="awb_y_fmin2" pos="7:0" rst="0x40">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="awb_y_fmax2" protect="rw">
        <bits access="rw" name="awb_y_fmax2" pos="7:0" rst="0xb4">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="awb_cb_fmin2" protect="rw">
        <bits access="rw" name="awb_cb_fmin2" pos="7:0" rst="0x34">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="awb_cb_fmax2" protect="rw">
        <bits access="rw" name="awb_cb_fmax2" pos="7:0" rst="0x5c">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="awb_cr_fmin2" protect="rw">
        <bits access="rw" name="awb_cr_fmin2" pos="7:0" rst="0x24">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="awb_cr_fmax2" protect="rw">
        <bits access="rw" name="awb_cr_fmax2" pos="7:0" rst="0x4c">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="ae_use_mean" protect="rw">
        <bits access="rw" name="ycave_use_mean" pos="1:0" rst="0x3">
          <comment>0yave        1yave
                  2yave    3yave</comment>
        </bits>
        <bits access="rw" name="ywave_use_mean" pos="3:2" rst="0x3">
          <comment>0yave        1yave
                  2yave    3yave</comment>
        </bits>
        <bits access="rw" name="yave_weight_mode" pos="4" rst="0x1">
          <comment>0: win yave     1: ywave</comment>
        </bits>
        <bits access="rw" name="nexp_out_sel_reg" pos="5" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="ae_ext_adj_val_reg" pos="6" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="ae_ext_adj_on_reg" pos="7" rst="0x1">
          <comment/>
        </bits>
      </reg>
      <reg name="ae_weight_sta" protect="rw">
        <bits access="rw" name="ywave_pcnt_left" pos="3:0" rst="0x4">
          <comment>ae ywave</comment>
        </bits>
        <bits access="rw" name="ywave_lcnt_top" pos="7:4" rst="0x4">
          <comment>ae ywave</comment>
        </bits>
      </reg>
      <reg name="ae_qwidth" protect="rw">
        <bits access="rw" name="qwidth" pos="7:0" rst="0xa0">
          <comment>QVGA 240x320 :8d60      QVGA 320x240: 8d80
                  CIF  352x288: 8d88       VGA 640x480: 8d160</comment>
        </bits>
      </reg>
      <reg name="ae_qheight" protect="rw">
        <bits access="rw" name="qheight" pos="6:0" rst="0x78">
          <comment>QVGA 240x320 :8d80      QVGA 320x240: 8d60
                  CIF  352x288: 8d72       VGA 640x480: 8d120</comment>
        </bits>
        <bits access="rw" name="ywave_sel" pos="7" rst="0x0">
          <comment>0: x1(CIFx1)  1:x1.5</comment>
        </bits>
      </reg>
      <reg name="ae_win_sta" protect="rw">
        <bits access="rw" name="yave_pcnt_sta" pos="3:0" rst="0x2">
          <comment>yave pcnt_sta=[[3:0], 1b0]</comment>
        </bits>
        <bits access="rw" name="yave_lcnt_sta" pos="7:4" rst="0x2">
          <comment>yave lcnt_sta=[[7:4], 1b0]</comment>
        </bits>
      </reg>
      <reg name="ae_width" protect="rw">
        <bits access="rw" name="width" pos="7:0" rst="0x95">
          <comment>yave Width=[[7:0],  2d0]
                  QVGA 240x320 :10d216     QVGA 320x240: 10d304
                  CIF  352x288: 10d304      VGA 640x480: 10d596</comment>
        </bits>
      </reg>
      <reg name="ae_height" protect="rw">
        <bits access="rw" name="height" pos="7:0" rst="0xdc">
          <comment>yave Height=[[7:0], 1d0]
                  QVGA 240x320 :10d304     QVGA 320x240: 10d216
                  CIF   352x288: 10d216      VGA 640x480: 10d440</comment>
        </bits>
      </reg>
      <reg name="sw_update" protect="rw">
        <bits access="rw" name="cc_type_sw" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="is_outdoor_sw" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gamma_type_sw" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="sw_update_rsvd" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="is_outdoor_mode" pos="6:4" rst="0x0">
          <comment>3'd0:   is_outdoor = 0;
                  3'd1:   is_outdoor = 1;
                  3'd2:
                       if(ana_gain==0) begin
                         if(expoutdoor_th)          is_outdoor = 1;
                         else if(expnon_outdoor_th) is_outdoor = 0;    end
                       else                           is_outdoor = 0;
                  3'd3:
                       if(ana_gain==0 and rgain_bigger) begin
                         if(expoutdoor_th)          is_outdoor = 1;
                         else if(expnon_outdoor_th) is_outdoor = 0;   end
                       else                           is_outdoor = 0;
                 default:
                       if(vsync_rp_d and sw_update_en)    is_outdoor = is_outdoor_sw;</comment>
        </bits>
        <bits access="rw" name="awb_outdoor_en" pos="7" rst="0x0">
          <comment>1: when is_outdoor=1, only detect white point at D65 and Indoor CTD block
                  0: dont care is_outdoor, detect white point at all ctd block</comment>
        </bits>
      </reg>
      <reg name="awb_ctrl5" protect="rw">
        <bits access="rw" name="r_low_non_a" pos="7:0" rst="0x3c">
          <comment/>
        </bits>
      </reg>
      <reg name="awb_ctrl6" protect="rw">
        <bits access="rw" name="awb_stop_h" pos="3:0" rst="0x0">
          <comment>awb_stop_cr_pos_level =[[3],awb_stop_reg[7:6]];
                  awb_stop_cr_neg_level =[[2],awb_stop_reg[5:4]];
                  awb_stop_cb_pos_level =[[1],awb_stop_reg[3:2]];
                  awb_stop_cb_neg_level =[[0],awb_stop_reg[1:0]];</comment>
        </bits>
        <bits access="rw" name="awb_adj_again" pos="5:4" rst="0x0">
          <comment>awb_adj_again = [2'b11, [5:4]]</comment>
        </bits>
        <bits access="rw" name="awb_algo_en" pos="6" rst="0x0">
          <comment>1: add awb_algo_thr condition to detect white point@A
                  0: detect white point according to A ctd block</comment>
        </bits>
        <bits access="rw" name="check_r_low" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="sca_reg" protect="rw">
        <bits access="rw" name="sca_mode" pos="2:0" rst="0x0">
          <comment>0: normal(no scale)
                  1: sub(yuv sub mode)
                  2: sca_320x240(1/2)
                  3: sca_176x144(1/3)
                  4: sca_160x120(1/4)
                  5: sca352x288(2/3)
                  6: sca352x288(3/5)
                  7: 3/4</comment>
        </bits>
      </reg>
      <reg name="ae_ee_sta_reg" protect="rw">
        <bits access="rw" name="ae_ee_sta_gain" pos="5:0" rst="0x0">
          <comment>Ee (64)</comment>
        </bits>
      </reg>
      <reg name="ae_ee_num_reg" protect="rw">
        <bits access="rw" name="ae_ee_num_reg" pos="3:0" rst="0x0">
          <comment>Ee (eE)</comment>
        </bits>
      </reg>
      <reg name="ae_ef_sta_reg" protect="rw">
        <bits access="rw" name="ae_ef_sta_gain" pos="5:0" rst="0x0">
          <comment>Ef (64)</comment>
        </bits>
      </reg>
      <reg name="ae_ef_num_reg" protect="rw">
        <bits access="rw" name="ae_ef_num_reg" pos="3:0" rst="0x0">
          <comment>Ef (fE)</comment>
        </bits>
      </reg>
      <reg name="ae_thr_big_reg" protect="rw">
        <bits access="rw" name="ae_thr_big_dark" pos="3:0" rst="0x6">
          <comment>ae_thr_big = [reg1CA[3:0],2d0]@dark</comment>
        </bits>
        <bits access="rw" name="ae_thr_big_bright" pos="7:4" rst="0x8">
          <comment>ae_thr_big = [reg1CA[7:4],2d0]@bright</comment>
        </bits>
      </reg>
      <reg name="sharp_gain_minus_low" protect="rw">
        <bits access="rw" name="sharp_gain_minus_low" pos="7:0" rst="0x70">
          <comment>sharp gain @low gain(2.6 format)</comment>
        </bits>
      </reg>
      <reg name="sharp_gain_minus_mid" protect="rw">
        <bits access="rw" name="sharp_gain_minus_mid" pos="7:0" rst="0x90">
          <comment>sharp gain @medium gain(2.6 format)</comment>
        </bits>
      </reg>
      <reg name="sharp_gain_minus_hi" protect="rw">
        <bits access="rw" name="sharp_gain_minus_hi" pos="7:0" rst="0xb0">
          <comment>sharp gain @high gain(2.6 format)</comment>
        </bits>
      </reg>
      <reg name="sharp_mode_mid_hi" protect="rw">
        <bits access="rw" name="sharp_cmp_gap_mid" pos="3:0" rst="0x8">
          <comment>sharp_cmp&gt; (sharp_nr_area_thr[6:0]+sharp_cmp_gap)</comment>
        </bits>
        <bits access="rw" name="sharp_cmp_gap_hi" pos="7:4" rst="0x8">
          <comment>sharp_cmp&gt; (sharp_nr_area_thr[6:0]+sharp_cmp_gap)</comment>
        </bits>
      </reg>
      <reg name="fw_version_reg" protect="rw">
        <bits access="rw" name="fw_version" pos="7:0" rst="0x00">
          <comment/>
        </bits>
      </reg>
      <reg name="awb_y_min_reg" protect="rw">
        <bits access="rw" name="awb_y_min" pos="7:0" rst="0x40">
          <comment>Y = Y_min ( AWB)</comment>
        </bits>
      </reg>
      <reg name="y_red_coef_reg" protect="rw">
        <bits access="rw" name="y_red_coef" pos="7:0" rst="0x4d">
          <comment/>
        </bits>
      </reg>
      <reg name="y_blue_coef_reg" protect="rw">
        <bits access="rw" name="y_blue_coef" pos="7:0" rst="0x1d">
          <comment/>
        </bits>
      </reg>
      <reg name="cb_red_coef_reg" protect="rw">
        <bits access="rw" name="cb_red_coef" pos="7:0" rst="0x2b">
          <comment/>
        </bits>
      </reg>
      <reg name="cr_blue_coef_reg" protect="rw">
        <bits access="rw" name="cr_blue_coef" pos="7:0" rst="0x15">
          <comment/>
        </bits>
      </reg>
      <reg name="hist_vbp_level_reg" protect="rw">
        <bits access="rw" name="hist_vbp_level" pos="7:0" rst="0xd8">
          <comment>Y level of vbright_hist</comment>
        </bits>
      </reg>
      <reg name="hist_vdp_level_reg" protect="rw">
        <bits access="rw" name="hist_vdp_level" pos="7:0" rst="0x18">
          <comment>Y level of vdark_hist</comment>
        </bits>
      </reg>
      <hole size="40*32"/>
    </module>
    <instance address="0x04404000" name="CAMERA" type="CAMERA"/>
  </archive>
  <archive relative="cp_ifc.xml">
    <var name="CP_NB_BITS_ADDR" value="32"/>
    <var name="CP_IFC_ADDR_ALIGN" value="0"/>
    <var name="CP_IFC_TC_LEN" value="23"/>
    <var name="CP_IFC_STD_CHAN_NB" value="4"/>
    <var name="CP_IFC_RFSPI_CHAN" value="0"/>
    <var name="CP_IFC_AIF_CHAN" value="0"/>
    <var name="CP_IFC_DBG_CHAN" value="0"/>
    <enum name="CP_IFC_Request_IDs">
      <entry name="DMA_ID_TX_SCI1"/>
      <entry name="DMA_ID_RX_SCI1"/>
      <entry name="DMA_ID_TX_SCI2"/>
      <entry name="DMA_ID_RX_SCI2"/>
    </enum>
    <module category="System" name="CP_IFC">
      <reg name="get_ch" protect="--">
        <bits access="r" name="ch_to_use" pos="4:0" rst="0">
          <comment>
            This field indicates which standard channel to use.
            <br/>
             Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
            <br/>
             After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
            <br/>
            Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
            <br/>
            Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
            <br/>
            When non-secure cpu read this register, the return value will automatic exlude the secure channel.
            <br/>
            00000 = use Channel0
            <br/>
            00001 = use Channel1
            <br/>
            00010 = use Channel2
            <br/>
             ...
            <br/>
            01111 = use Channel15
            <br/>
            11111 = all channels are busy
          </comment>
          <options>
            <mask/>
            <shift/>
            <default/>
          </options>
        </bits>
      </reg>
      <reg name="dma_status" protect="r">
        <bits access="r" name="ch_enable" pos="CP_IFC_STD_CHAN_NB+CP_IFC_RFSPI_CHAN-1:0" rst="0">
          <comment>
            This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels disabled
            <br/>
            0000_0001 = Ch0 enabled
            <br/>
            0000_0010 = Ch1 enabled
            <br/>
            0000_0100 = Ch2 enabled
            <br/>
            0000_0101 = Ch0 and Ch2 enabled
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 enabled
            <br/>
            all 1     = all channels enabled
          </comment>
        </bits>
        <bits access="r" name="ch_busy" pos="CP_IFC_STD_CHAN_NB-1+16:16" rst="0">
          <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
        </bits>
      </reg>
      <reg name="debug_status" protect="r">
        <bits access="r" name="dbg_status" pos="0" rst="1">
          <comment>
            Debug Channel Status .
            <br/>
            0= The debug channel is running
      (not idle)
            <br/>
            1= The debug channel is in idle mode
          </comment>
        </bits>
      </reg>
      <reg name="ifc_sec" protect="rw">
        <bits access="rw" name="std_ch_reg_sec" pos="CP_IFC_STD_CHAN_NB-1:0" rst="0">
          <comment>
            This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels registers can be accessed by secure master or non-secure master.
            <br/>
            0000_0001 = Ch0 registers can only be accessed by secure master.
            <br/>
            0000_0010 = Ch1 registers can only be accessed by secure master.
            <br/>
            0000_0100 = Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels registers can only be accessed by secure master.
          </comment>
        </bits>
        <bits access="rw" name="std_ch_dma_sec" pos="CP_IFC_STD_CHAN_NB-1+16:16" rst="all1">
          <comment>
            This register indicates which channel dma is secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels dma are non-secure master.
            <br/>
            0000_0001 = Ch0 dma is secure master.
            <br/>
            0000_0010 = Ch1 dma is secure master.
            <br/>
            0000_0100 = Ch2 dma is secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 dma are secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels dma are secure master.
          </comment>
        </bits>
      </reg>
      <struct count="CP_IFC_STD_CHAN_NB" name="std_ch">
        <reg name="control" protect="rw">
          <bits access="w" name="enable" pos="0" rst="no">
            <comment>
              Channel Enable, write one in this bit enable the channel.
              <br/>
              When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer.
            </comment>
          </bits>
          <bits access="w" name="disable" pos="1" rst="no">
            <comment>
              Channel Disable, write one in this bit disable the channel.
              <br/>
              When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled.
            </comment>
          </bits>
          <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
            <comment>
              Exchange the read data from fifo halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
            <comment>
              Exchange the write data to fifo  halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="autodisable" pos="4" rst="1">
            <comment>
              Set Auto-disable mode
              <br/>
               0 = when TC reach zero the
        channel is not automatically released.
              <br/>
               1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.
            </comment>
          </bits>
          <bits access="rw" name="size" pos="5" rst="0">
            <comment>
              Peripheral Size
              <br/>
               0= 8-bit peripheral
              <br/>
               1= 32-bit peripheral
            </comment>
          </bits>
          <bits access="rw" display="hex" name="req_src" pos="12:8" rst="0x1F">
            <options linkenum="CP_IFC_Request_IDs">
              <shift/>
              <mask/>
              <default/>
            </options>
            <comment>Select DMA Request source</comment>
          </bits>
          <bits access="rw" name="flush" pos="16" rst="0">
            <comment>
              When one, flush the internal FIFO channel.
              <br/>
              This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel.
              <br/>
               Before writting back this bit to zero the internal fifo must empty.
            </comment>
          </bits>
          <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
            <comment>
              Set the MAX burst length for channel 0,1.
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.
              <br/>
               The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4.
              <br/>
               .
            </comment>
          </bits>
        </reg>
        <reg name="status" protect="r">
          <bits access="r" name="enable" pos="0" rst="0">
            <comment>Enable bit, when '1' the channel is running</comment>
          </bits>
          <bits access="r" name="fifo_empty" pos="4" rst="1">
            <comment>The internal channel fifo is empty</comment>
          </bits>
        </reg>
        <reg name="start_addr" protect="rw">
          <bits access="rw" display="hex" name="start_addr" pos="CP_NB_BITS_ADDR-1:CP_IFC_ADDR_ALIGN" rst="0xFFFFFFF">
            <comment>
              AHB Address. This field represent the start address of the
        transfer.
              <br/>
              For a 32-bit peripheral, this address must be aligned 32-bit.
            </comment>
          </bits>
        </reg>
        <reg name="tc" protect="rw">
          <bits access="rw" display="hex" name="tc" pos="CP_IFC_TC_LEN-1:0" rst="0xFFFFFF">
            <comment>
              Transfer Count, this field indicated the transfer size in bytes to perform.
              <br/>
              During a transfer a write in this register add the new value to the current TC.
              <br/>
              A read of this register return the current current transfer count.
            </comment>
          </bits>
        </reg>
        <reg name="tc_threshold" protect="rw">
          <bits access="rw" display="hex" name="tc_threshold" pos="CP_IFC_TC_LEN-1:0" rst="0x0">
            <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.</comment>
          </bits>
        </reg>
      </struct>
    </module>
    <instance address="0x14002000" name="CP_IFC" type="CP_IFC"/>
  </archive>
  <archive relative="debug_host.xml">
    <module category="Debug" name="DEBUG_HOST">
      <reg name="cmd" protect="--">
        <bits access="r" name="addr" pos="28:0" rst="-">
          <comment>Address of data to be read or written.</comment>
        </bits>
        <bits access="r" name="size" pos="30:29" rst="-">
          <comment>
            These two bits indicates element data size.
            <br/>
            when &quot;00&quot; = &quot;byte&quot;.
            <br/>
            when &quot;01&quot; = &quot;half word&quot;.
            <br/>
            when &quot;10&quot; = &quot;word&quot;.
          </comment>
        </bits>
        <bits access="r" name="write_h" pos="31" rst="-">
          <comment>
            This bit indicates command is read or write.
            <br/>
        when &quot;0&quot; = &quot;Read&quot;.
            <br/>
        when &quot;1&quot; = &quot;Write&quot;.
          </comment>
        </bits>
      </reg>
      <reg name="data" protect="--">
        <comment>Those bits are data to be read or written by IFC.</comment>
      </reg>
      <reg name="event" protect="rw">
        <bits access="rw" name="event0_sema" pos="0" rst="0">
          <comment>
            When read, this bit is used for event semaphore.
            <br/>
            '0' = no new event should be programed.
            <br/>
            '1' = no pending event, new event is authorised.
            <br/>
            If host is not enabled, this bit is always '1'. However in this case,
            any event written will be ignored.
            <br/>
            When Write, this bit is the least significant bit for a 32-bit event.
          </comment>
        </bits>
        <bits access="w" name="event31_1" pos="31:1" rst="-">
          <comment>These bits combined with bit0 consists a 32-bit event number. If a
            new event is written before the previous event has been sent, it will
            be ignored.</comment>
        </bits>
      </reg>
      <reg name="mode" protect="rw">
        <bits access="rw" name="force_on" pos="0" rst="1">
          <comment>When '1', force the debug host on, use clock UART if clock host is not
            detected.</comment>
        </bits>
        <bits access="r" name="clk_host_on" pos="1" rst="0">
          <comment>
            This bit indicates if clock host is detected to be on or not.
            <br/>
            '0' = no clock host.
            <br/>
            '1' = clock host detected.
          </comment>
        </bits>
      </reg>
      <reg name="h2p_status" protect="rw">
        <bits access="r" name="h2p_status" pos="7:0" rst="0">
          <comment>Status which can be written through debug uart interface into a debug host
            internal register and read by APB.</comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="w" name="h2p_status_rst" pos="16" rst="0">
          <comment>write in this bit will reset h2p status register.</comment>
        </bits>
      </reg>
      <reg name="p2h_status" protect="rw">
        <bits access="rw" name="p2h_status" pos="7:0" rst="0">
          <comment>Status which can be written by APB and read through debug uart interface
            as a debug host internal register.</comment>
        </bits>
      </reg>
      <reg name="irq" protect="r">
        <bits access="r" name="xcpu_irq" pos="0" rst="0">
          <comment>
            when write '1', clear the xcpu irq level which is programmed in a debug host
          internal register, this bit is automatic cleared.
            <br/>
             when read, get the xcpu
          irq status.
          </comment>
        </bits>
        <bits access="r" name="bcpu_irq" pos="1" rst="0">
          <comment>
            when write '1', clear the bcpu irq level which is programmed in a debug host
            internal register, this bit is automatic cleared.
            <br/>
             when read, get the bcpu
            irq status.
          </comment>
        </bits>
      </reg>
    </module>
    <instance address="0x5140f000" name="DEBUG_HOST" type="DEBUG_HOST"/>
  </archive>
  <archive relative="debug_uart.xml">
    <module category="System" name="DEBUG_UART">
      <var name="DEBUG_UART_RX_FIFO_SIZE" value="16"/>
      <var name="DEBUG_UART_TX_FIFO_SIZE" value="16"/>
      <var name="DEBUG_UART_NB_RX_FIFO_BITS" value="4"/>
      <var name="DEBUG_UART_NB_TX_FIFO_BITS" value="4"/>
      <var name="ESC_DAT" value="92"/>
      <reg name="ctrl" protect="rw">
        <bits access="rw" name="enable" pos="0" rst="0">
          <options>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
            <default/>
          </options>
          <comment>
            Allows to turn off the UART:
            <br/>
            0 = Disable
            <br/>
            1 = Enable
          </comment>
        </bits>
        <bits access="rw" name="data bits" pos="1" rst="0">
          <options>
            <option name="7_BITS" value="0"/>
            <option name="8_BITS" value="1"/>
            <default/>
          </options>
          <comment>
            Number of data bits per character (least significant bit
          first):
            <br/>
            0 = 7 bits
            <br/>
            1 = 8 bits
            <br/>
             This bit will be masked to
          '1' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="tx stop bits" pos="2" rst="0">
          <options>
            <option name="1_BIT" value="0"/>
            <option name="2_BITS" value="1"/>
            <default/>
          </options>
          <comment>
            Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).
            <br/>
            0 = one stop bit is
      transmitted in the serial data.
            <br/>
            1 = two stop bits are generated and
      transmitted in the serial data out.
            <br/>
             This bit will be masked to
      '0' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="parity enable" pos="3" rst="0">
          <options>
            <option name="NO" value="0"/>
            <option name="YES" value="1"/>
            <default/>
          </options>
          <comment>
            Parity is enabled when this bit is set.
            <br/>
             This bit will be masked to
      '0' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="parity select" pos="5:4" rst="0">
          <options>
            <option name="ODD" value="0"/>
            <option name="EVEN" value="1"/>
            <option name="SPACE" value="2"/>
            <option name="MARK" value="3"/>
            <default/>
          </options>
          <comment>
            Controls the parity format when parity is enabled:
            <br/>
            00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).
            <br/>
            01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).
            <br/>
            10 = a space is
      generated and received as parity bit.
            <br/>
            11 = a mark is generated and
      received as parity bit.
            <br/>
             These bit will be ignored if debug host is
      enabled.
          </comment>
        </bits>
        <bits access="rw" name="tx break control" pos="6" rst="0">
          <comment>
            Sends a break signal by holding the Uart_Tx line low until
          this bit is cleared.
            <br/>
             This bit will be masked to '0' if debug host
          is enabled.
          </comment>
          <options>
            <option name="OFF" value="0"/>
            <option name="ON" value="1"/>
            <default/>
          </options>
        </bits>
        <bits access="rw" name="rx fifo reset" pos="7" rst="0">
          <comment>reset rx fifo.</comment>
        </bits>
        <bits access="rw" name="tx fifo reset" pos="8" rst="0">
          <comment>reset tx fifo.</comment>
        </bits>
        <bits access="rw" name="dma mode" pos="9" rst="0">
          <options>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
            <default/>
          </options>
          <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC.</comment>
        </bits>
        <bits access="rw" name="swrx flow ctrl" pos="13:12" rst="1">
          <comment>
            When this field is &quot;00&quot; and SWTX_flow_Ctrl is also &quot;00&quot;, hardwre
            flow ctrl is used. Otherwise, software flow control is used:
            <br/>
            00 = no transmit flow control.
            <br/>
            01 = transmit XON1/XOFF1 as flow control bytes
            <br/>
            10 = transmit XON2/XOFF2 as flow control bytes
            <br/>
            11 = transmit XON1 and XON2/XOFF1 and XOFF2 as flow control bytes
            <br/>
          </comment>
          <options>
            <default/>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="swtx flow ctrl" pos="15:14" rst="1">
          <comment>
            When this field is &quot;00&quot; and SWRX_flow_Ctrl is also &quot;00&quot;, hardwre
            flow ctrl is used. Otherwise, software flow control is used:
            <br/>
            00 = no receive flow control
            <br/>
            01 = receive XON1/XOFF1 as flow control bytes
            <br/>
            10 = receive XON2/XOFF2 as flow control bytes
            <br/>
            11 = receive XON1 and XON2/XOFF1 and XOFF2 as flow control bytes
            <br/>
            <br/>
             Note: If single XON/XOFF character is used for flow contol, the received
            XON/XOFF character will not be put into Rx FIFO. This is also the case if XON is
            received when XOFF is expected.
            <br/>
            If double XON/XOFF characters are expected, the XON1/XOFF1 must followed sequently
            by XON2/XOFF2 to be considered as patterns, which will not be put into Rx FIFO.
            Otherwise they will be considered as data. This is also the case if XOFF1 is followed
            by character other than XOFF2.
            <br/>
          </comment>
          <options>
            <default/>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="backslash en" pos="16" rst="1">
          <comment>When soft flow control characters or backslash are encountered in the data file,
            they will be inverted and a backslash will be added before them. for example, if tx data
            is XON(0x11) with BackSlash_En = '1', then uart will send 5Ch(Backslash) + EEh (~XON).</comment>
        </bits>
        <bits access="rw" name="tx finish n wait" pos="19" rst="0">
          <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
        </bits>
        <bits access="rw" name="divisor mode" pos="20" rst="0">
          <comment>
            Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.
            <br/>
            0 =
      (BCLK = SCLK / 4)
            <br/>
            1 = (BCLK = SCLK / 16)
            <br/>
             This bit will be
      masked to '0' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="irda enable" pos="21" rst="0">
          <comment>
            When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details).
            <br/>
             This bit will be
      masked to '0' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="rx rts" pos="22" rst="0">
          <comment>
            Controls the Uart_RTS output (not directly in auto flow control
      mode).
            <br/>
            0 = the Uart_RTS will be inactive high
            <br/>
            1 = the Uart_RTS
      will be active low
            <br/>
             This bit will be masked to '1' if debug host is
      enabled.
          </comment>
          <options>
            <option name="INACTIVE" value="0"/>
            <option name="ACTIVE" value="1"/>
            <default/>
          </options>
        </bits>
        <bits access="rw" name="auto flow control" pos="23" rst="0">
          <options>
            <option name="ENABLE" value="1"/>
            <option name="DISABLE" value="0"/>
            <default/>
          </options>
          <comment>
            Enables the auto flow control.
            <br/>
          In case HW flow control (both swTx_Flow_ctrl=0 and swRx_Flow_Ctrl=0),
          If Auto_Flow_Control is enabled, Uart_RTS is controlled by the Rx RTS bit in
          CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register).
          Tx data flow is stopped If Uart_CTS become inactive high.
            <br/>
          If Auto_Flow_Control is disabled, Uart_RTS is controlled only by the Rx RTS
          bit in CMD_Set register. Uart_CTS will not take effect.
            <br/>
            <br/>
          In case SW flow control(either swTx_Flow_ctrl/=0 or swRx_Flow_Ctrl/=0),
          If Auto_Flow_Control is enabled, XON/XOFF will be controlled by the Rx RTS bit
          in CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register).
            <br/>
          If Auto_Flow_Control is disabled, XON/XOFF will be controlled only by Rx RTS bit
          in CMD_Set register. Tx data flow will be stoped when XOFF is received either
          this bit is enable or disabled.
            <br/>
            <br/>
             This bit will be masked to '1' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="loop back mode" pos="24" rst="0">
          <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support).</comment>
        </bits>
        <bits access="rw" name="rx lock err" pos="25" rst="0">
          <comment>
            Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept.
            <br/>
             This bit
      will be masked to '0' if debug host is enabled.
          </comment>
          <options>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
            <default/>
          </options>
        </bits>
        <bits access="rw" name="hst txd oen" pos="26" rst="0">
          <comment>HST TXD output enable. '0' enable.</comment>
          <options>
            <option name="DISABLE" value="1"/>
            <option name="ENABLE" value="0"/>
            <default/>
          </options>
        </bits>
        <bits access="rw" name="rx break length" pos="31:28" rst="0xF">
          <comment>
            Length of a break, in number of bits.
            <br/>
             This bit will be masked
      to &quot;1011&quot; if debug host is enabled.
          </comment>
        </bits>
      </reg>
      <reg name="status" protect="r">
        <bits access="r" name="rx fifo level" pos="4:0" rst="0">
          <options>
            <mask/>
            <shift/>
          </options>
          <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read.</comment>
        </bits>
        <bits access="r" name="tx fifo level" pos="12:8" rst="0">
          <options>
            <mask/>
            <shift/>
          </options>
          <comment>Those bits indicate the number of data available in the Tx
      Fifo. Those data will be sent.</comment>
        </bits>
        <bits access="r" name="tx active" pos="13" rst="0">
          <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface.</comment>
        </bits>
        <bits access="r" name="rx active" pos="14" rst="0">
          <comment>This bit indicates that the UART is receiving a byte.</comment>
        </bits>
        <bits access="r" name="rx overflow err" pos="16" rst="0">
          <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="tx overflow err" pos="17" rst="0">
          <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when
          the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx parity err" pos="18" rst="0">
          <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx framing err" pos="19" rst="0">
          <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value.</comment>
        </bits>
        <bits access="r" name="rx break int" pos="20" rst="0">
          <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value.</comment>
        </bits>
        <bits access="r" name="tx dcts" pos="24" rst="0">
          <comment>
            In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0),
            This bit is set when the Uart_CTS line changed since the last
            time this register has been written.
            <br/>
            In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0),
            This bit is set when received XON/XOFF status changed since the last time
            this register has been writtern.
            <br/>
            This bit is cleared when the UART_STATUS register is written with any value.
          </comment>
        </bits>
        <bits access="r" name="tx cts" pos="25" rst="0">
          <comment>
            In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0),
            current value of the Uart_CTS line.
            <br/>
             '1' = Tx not allowed.
            <br/>
             '0' = Tx allowed.
            <br/>
            In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0),
            current state of software flow control.
            <br/>
             '1' = when XOFF received.
            <br/>
             '0' = when XON received.
          </comment>
        </bits>
        <bits access="r" name="tx fifo rsted l" pos="28" rst="0">
          <comment>This bit is set when Tx Fifo Reset command is received by CTRL
      register and is cleared when Tx fifo reset process has finished.</comment>
        </bits>
        <bits access="r" name="rx fifo rsted l" pos="29" rst="0">
          <comment>This bit is set when Rx Fifo Reset command is received by CTRL
      register and is cleared when Rx fifo reset process has finished.</comment>
        </bits>
        <bits access="r" name="enable n finished" pos="30" rst="0">
          <comment>This bit is set when bit enable is changed from '0' to '1' or
      from '1' to '0', it is cleared when the enable process has finished.</comment>
        </bits>
        <bits access="r" name="clk enabled" pos="31" rst="0">
          <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      Rx RTS too early.</comment>
        </bits>
      </reg>
      <reg name="rxtx_buffer" protect="--">
        <bits access="r" name="rx data" pos="7:0" rst="no">
          <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur.</comment>
        </bits>
        <bits access="w" name="tx data" pos="7:0" rst="no">
          <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost.</comment>
        </bits>
      </reg>
      <reg name="irq_mask" protect="rw">
        <bits access="rw" name="tx modem status" pos="0" rst="0">
          <comment>Clear to send signal change or XON/XOFF detected.</comment>
        </bits>
        <bits access="rw" name="rx data available" pos="1" rst="0">
          <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level).</comment>
        </bits>
        <bits access="rw" name="tx data needed" pos="2" rst="0">
          <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level).</comment>
        </bits>
        <bits access="rw" name="rx timeout" pos="3" rst="0">
          <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time.</comment>
        </bits>
        <bits access="rw" name="rx line err" pos="4" rst="0">
          <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt.</comment>
        </bits>
        <bits access="rw" name="tx dma done" pos="5" rst="0">
          <comment>Pulse detected on Uart_Dma_Tx_Done_H signal.</comment>
        </bits>
        <bits access="rw" name="rx dma done" pos="6" rst="0">
          <comment>Pulse detected on Uart_Dma_Rx_Done_H signal.</comment>
        </bits>
        <bits access="rw" name="rx dma timeout" pos="7" rst="0">
          <comment>In DMA mode, there is at least 1 character that has been read
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.</comment>
        </bits>
        <bits access="rw" name="xoff_detected" pos="8" rst="0">
    </bits>
      </reg>
      <reg name="irq_cause" protect="rw">
        <bits access="r" name="tx modem status" pos="0" rst="0">
          <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx data available" pos="1" rst="0">
          <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level.</comment>
        </bits>
        <bits access="r" name="tx data needed" pos="2" rst="0">
          <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level.</comment>
        </bits>
        <bits access="r" name="rx timeout" pos="3" rst="0">
          <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.</comment>
        </bits>
        <bits access="r" name="rx line err" pos="4" rst="0">
          <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value.</comment>
        </bits>
        <bits access="rw" name="tx dma done" pos="5" rst="0">
          <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="rx dma done" pos="6" rst="0">
          <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="rx dma timeout" pos="7" rst="0">
          <comment>In DMA mode, there is at least 1 character that has been read
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.</comment>
        </bits>
        <bits access="r" name="tx modem status u" pos="16" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx data available u" pos="17" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="tx data needed u" pos="18" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx timeout u" pos="19" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx line err u" pos="20" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="tx dma done u" pos="21" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx dma done u" pos="22" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx dma timeout u" pos="23" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
      </reg>
      <reg name="triggers" protect="rw">
        <bits access="rw" name="rx trigger" pos="3:0" rst="0">
          <comment>
            Defines the threshold level at which the Data Available
      Interrupt will be generated.
            <br/>
            The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.
          </comment>
        </bits>
        <bits access="rw" name="tx trigger" pos="7:4" rst="0">
          <comment>
            Defines the threshold level at which the Data Needed
      Interrupt will be generated.
            <br/>
            The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.
          </comment>
        </bits>
        <bits access="rw" name="afc level" pos="11:8" rst="0">
          <comment>
            Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).
            <br/>
            The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.
          </comment>
        </bits>
      </reg>
      <reg name="xchar" protect="rw">
        <bits access="rw" name="xon1" pos="7:0" rst="17">
          <comment>XON1 character value. Reset Value is CTRL-Q 0x11.</comment>
        </bits>
        <bits access="rw" name="xoff1" pos="15:8" rst="19">
          <comment>XOFF1 character value. Reset Value is CTRL-S 0x13</comment>
        </bits>
        <bits access="rw" name="xon2" pos="23:16" rst="0">
          <comment>XON2 character value.</comment>
        </bits>
        <bits access="rw" name="xoff2" pos="31:24" rst="0">
          <comment>XOFF2 character value.</comment>
        </bits>
        <comment>These characters must respect following constraints: They must be different if used in software control, if BackSlash_En='1', they cannot be '\' and they cannot be complementary to each other, for example neither XON1 = ~XOFF1 nor XON1 = ~'\' is permitted.</comment>
      </reg>
    </module>
    <instance address="0x51402000" name="DEBUG_UART" type="DEBUG_UART"/>
  </archive>
  <archive relative="dmc400.xml">
    <module category="Periph" name="DMC400">
      <reg name="memc_status" protect="r">
        <bits access="r" name="memc_status" pos="1:0" rst="0">
          <options>
            <option name="config" value="0"/>
            <option name="low_power" value="1"/>
            <option name="paused" value="2"/>
            <option name="ready" value="3"/>
          </options>
        </bits>
      </reg>
      <reg name="memc_config" protect="r">
        <bits access="r" name="system_interfaces_cfg" pos="1:0" rst="0">
          <options>
            <option name="1_system_interface" value="0"/>
            <option name="2_system_interface" value="1"/>
            <option name="4_system_interface" value="3"/>
          </options>
        </bits>
        <bits access="r" name="memory_interfaces_cfg" pos="5:4" rst="0">
          <options>
            <option name="1_memory_interface" value="0"/>
            <option name="2_memory_interface" value="1"/>
          </options>
        </bits>
        <bits access="r" name="memory_data_width_cfg" pos="9:8" rst="1">
          <options>
            <option name="32bit_phy_if" value="1"/>
            <option name="64bit_phy_if" value="2"/>
            <option name="128bit_phy_if" value="3"/>
          </options>
        </bits>
        <bits access="r" name="memory_chip_selects_cfg" pos="13:12" rst="0">
          <options>
            <option name="1_chip_sel" value="0"/>
            <option name="2_chip_sel" value="1"/>
          </options>
        </bits>
        <bits access="r" name="read_queue_depth_cfg" pos="18:16" rst="0">
          <options>
            <option name="16_entry" value="0"/>
            <option name="32_entry" value="1"/>
            <option name="64_entry" value="3"/>
            <option name="128_entry" value="7"/>
          </options>
        </bits>
        <bits access="r" name="write_queue_depth_cfg" pos="22:20" rst="1">
          <options>
            <option name="16_entry" value="0"/>
            <option name="32_entry" value="1"/>
            <option name="64_entry" value="3"/>
            <option name="128_entry" value="7"/>
          </options>
        </bits>
        <bits access="r" name="max_burst_length_cfg" pos="25:24" rst="3">
          <options>
            <option name="2_dmc_cycle" value="1"/>
            <option name="4_dmc_cycle" value="2"/>
            <option name="8_dmc_cycle" value="3"/>
          </options>
        </bits>
        <bits access="r" name="memory_ecc_cfg" pos="28" rst="0">
          <options>
            <option name="false" value="0"/>
            <option name="true" value="1"/>
          </options>
        </bits>
      </reg>
      <reg name="memc_cmd" protect="w">
        <bits access="w" name="memc_cmd" pos="2:0" rst="0">
          <options>
            <option name="config" value="0"/>
            <option name="sleep" value="1"/>
            <option name="pause" value="2"/>
            <option name="go" value="3"/>
            <option name="invalidate" value="4"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="address_control" protect="rw">
        <bits access="rw" name="column_bits" pos="3:0" rst="0">
          <options>
            <option name="8_col_bits" value="0"/>
            <option name="9_col_bits" value="1"/>
            <option name="10_col_bits" value="2"/>
            <option name="11_col_bits" value="3"/>
            <option name="12_col_bits" value="4"/>
          </options>
        </bits>
        <bits access="rw" name="row_bits" pos="11:8" rst="2">
          <options>
            <option name="13_row_bits" value="2"/>
            <option name="14_row_bits" value="3"/>
            <option name="15_row_bits" value="4"/>
            <option name="16_row_bits" value="5"/>
          </options>
        </bits>
        <bits access="rw" name="bank_bits" pos="19:16" rst="3">
          <options>
            <option name="2_bank_bits_4bk" value="2"/>
            <option name="3_bank_bits_8bk" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="chip_bits" pos="25:24" rst="0">
          <options>
            <option name="0_chip_bits_1cs" value="0"/>
            <option name="1_chip_bits_2cs" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="channel_bits" pos="29:28" rst="0">
          <options>
            <option name="0_channel_bits_1memif" value="0"/>
            <option name="1_channel_bits_2memif" value="1"/>
          </options>
        </bits>
      </reg>
      <reg name="decode_control" protect="rw">
        <bits access="rw" name="addr_decode" pos="1:0" rst="0">
          <options>
            <option name="channel_chip_row_bank_col" value="0"/>
            <option name="row_channel_chip_bank_col" value="1"/>
            <option name="chip_bank_row_channel_col" value="2"/>
            <option name="row_chip_bank_channel_col" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="strip_decode" pos="7:4" rst="5">
          <options>
            <option name="page_addr_13_12" value="0"/>
            <option name="page_addr_12_11" value="1"/>
            <option name="page_addr_11_10" value="2"/>
            <option name="page_addr_10_9" value="3"/>
            <option name="page_addr_9_8" value="4"/>
            <option name="page_addr_8_7" value="5"/>
            <option name="page_addr_7_6" value="6"/>
            <option name="page_addr_6_5" value="7"/>
          </options>
        </bits>
      </reg>
      <reg name="format_control" protect="rw">
        <bits access="rw" name="mem_width" pos="1:0" rst="1">
          <options>
            <option name="phy_width_32_x16_ddr" value="1"/>
            <option name="phy_width_64_x32_ddr" value="2"/>
            <option name="phy_width_128_x64_ddr" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="mem_burst" pos="9:8" rst="2">
          <options>
            <option name="mem_burst_2_ddr_bl4" value="1"/>
            <option name="mem_burst_4_ddr_bl8" value="2"/>
            <option name="mem_burst_8_ddr_bl16" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="acc_granu" pos="25:24" rst="2">
          <options>
            <option name="acc_granu_1_ddr_2n" value="0"/>
            <option name="acc_granu_2_ddr_4n" value="1"/>
            <option name="acc_granu_4_ddr_8n" value="2"/>
            <option name="acc_granu_8_ddr_16n" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="align_boundary" pos="29:28" rst="2">
          <options>
            <option name="align_boundary_1_col_1bit" value="0"/>
            <option name="align_boundary_2_col_2bit" value="1"/>
            <option name="align_boundary_4_col_3bit" value="2"/>
            <option name="align_boundary_8_col_4bit" value="3"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="low_power_control" protect="rw">
        <bits access="rw" name="stop_mem_clock_idle" pos="0" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="stop_mem_clock_sref" pos="1" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="auto_power_down" pos="2" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="auto_self_refresh" pos="3" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="asr_period" pos="7:4" rst="1">
        </bits>
      </reg>
      <hole size="(3)*32"/>
      <reg name="turnaround_priority" protect="rw">
        <bits access="rw" name="turnaround_priority" pos="3:0" rst="0">
        </bits>
        <bits access="rw" name="turnaround_limit" pos="7:4" rst="0">
        </bits>
      </reg>
      <reg name="hit_priority" protect="rw">
        <bits access="rw" name="hit_priority" pos="3:0" rst="0">
        </bits>
        <bits access="rw" name="hit_limit" pos="7:4" rst="0">
        </bits>
      </reg>
      <reg name="qos0_control" protect="rw">
        <bits access="rw" name="qos0_priority" pos="3:0" rst="0">
        </bits>
        <bits access="rw" name="qos0_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos1_control" protect="rw">
        <bits access="rw" name="qos1_priority" pos="3:0" rst="1">
        </bits>
        <bits access="rw" name="qos1_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos2_control" protect="rw">
        <bits access="rw" name="qos2_priority" pos="3:0" rst="2">
        </bits>
        <bits access="rw" name="qos2_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos3_control" protect="rw">
        <bits access="rw" name="qos3_priority" pos="3:0" rst="3">
        </bits>
        <bits access="rw" name="qos3_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos4_control" protect="rw">
        <bits access="rw" name="qos4_priority" pos="3:0" rst="4">
        </bits>
        <bits access="rw" name="qos4_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos5_control" protect="rw">
        <bits access="rw" name="qos5_priority" pos="3:0" rst="5">
        </bits>
        <bits access="rw" name="qos5_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos6_control" protect="rw">
        <bits access="rw" name="qos6_priority" pos="3:0" rst="6">
        </bits>
        <bits access="rw" name="qos6_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos7_control" protect="rw">
        <bits access="rw" name="qos7_priority" pos="3:0" rst="7">
        </bits>
        <bits access="rw" name="qos7_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos8_control" protect="rw">
        <bits access="rw" name="qos8_priority" pos="3:0" rst="8">
        </bits>
        <bits access="rw" name="qos8_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos9_control" protect="rw">
        <bits access="rw" name="qos9_priority" pos="3:0" rst="9">
        </bits>
        <bits access="rw" name="qos9_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos10_control" protect="rw">
        <bits access="rw" name="qos10_priority" pos="3:0" rst="10">
        </bits>
        <bits access="rw" name="qos10_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos11_control" protect="rw">
        <bits access="rw" name="qos11_priority" pos="3:0" rst="11">
        </bits>
        <bits access="rw" name="qos11_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos12_control" protect="rw">
        <bits access="rw" name="qos12_priority" pos="3:0" rst="12">
        </bits>
        <bits access="rw" name="qos12_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="qos13_control" protect="rw">
        <bits access="rw" name="qos13_priority" pos="3:0" rst="13">
        </bits>
        <bits access="rw" name="qos13_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos14_control" protect="rw">
        <bits access="rw" name="qos14_priority" pos="3:0" rst="14">
        </bits>
        <bits access="rw" name="qos14_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos15_control" protect="rw">
        <bits access="rw" name="qos15_priority" pos="3:0" rst="15">
        </bits>
        <bits access="rw" name="qos15_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="timeout_control" protect="rw">
        <bits access="rw" name="timeout_prescalar" pos="1:0" rst="1">
          <options>
            <option name="8_clk" value="0"/>
            <option name="16_clk" value="1"/>
            <option name="32_clk" value="2"/>
            <option name="64_clk" value="3"/>
          </options>
        </bits>
      </reg>
      <reg name="queue_control" protect="rw">
        <bits access="rw" name="s0_reserve" pos="3:0" rst="0">
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="write_priority_control" protect="rw">
        <bits access="rw" name="write_threshold_en" pos="0" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="write_fill_priority_1_16ths" pos="7:4" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_2_16ths" pos="11:8" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_3_16ths" pos="15:12" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_4_16ths" pos="19:16" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_5_16ths" pos="23:20" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_6_16ths" pos="27:24" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_7_16ths" pos="31:28" rst="0">
        </bits>
      </reg>
      <reg name="write_priority_control2" protect="rw">
        <bits access="rw" name="write_fill_priority_8_16ths" pos="3:0" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_9_16ths" pos="7:4" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_10_16ths" pos="11:8" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_11_16ths" pos="15:12" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_12_16ths" pos="19:16" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_13_16ths" pos="23:20" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_14_16ths" pos="27:24" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_15_16ths" pos="31:28" rst="0">
        </bits>
      </reg>
      <reg name="read_priority_control" protect="rw">
        <bits access="rw" name="read_escalation" pos="0" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="read_in_burst_prioritisation" pos="1" rst="1">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="read_fill_priority_1_16ths" pos="7:4" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_2_16ths" pos="11:8" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_3_16ths" pos="15:12" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_4_16ths" pos="19:16" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_5_16ths" pos="23:20" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_6_16ths" pos="27:24" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_7_16ths" pos="31:28" rst="0">
        </bits>
      </reg>
      <reg name="read_priority_control2" protect="rw">
        <bits access="rw" name="read_fill_priority_8_16ths" pos="3:0" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_9_16ths" pos="7:4" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_10_16ths" pos="11:8" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_11_16ths" pos="15:12" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_12_16ths" pos="19:16" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_13_16ths" pos="23:20" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_14_16ths" pos="27:24" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_15_16ths" pos="31:28" rst="0">
        </bits>
      </reg>
      <reg name="access_address_match" protect="rw">
        <bits access="rw" name="access_address_match" pos="31:12" rst="0">
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="access_address_mask" protect="rw">
        <bits access="rw" name="access_address_mask" pos="31:12" rst="0">
        </bits>
      </reg>
      <hole size="(23)*32"/>
      <reg name="channel_status" protect="r">
        <bits access="r" name="m0_state" pos="3:0" rst="1">
          <options>
            <option name="standby" value="0"/>
            <option name="dpd" value="1"/>
            <option name="idle" value="2"/>
            <option name="self_refresh" value="3"/>
            <option name="reading" value="4"/>
            <option name="power_down" value="5"/>
            <option name="writing" value="6"/>
          </options>
        </bits>
        <bits access="r" name="m1_state" pos="7:4" rst="0">
          <options>
            <option name="standby" value="0"/>
            <option name="dpd" value="1"/>
            <option name="idle" value="2"/>
            <option name="self_refresh" value="3"/>
            <option name="reading" value="4"/>
            <option name="power_down" value="5"/>
            <option name="writing" value="6"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="direct_cmd" protect="w">
        <bits access="w" name="direct_addr" pos="15:0" rst="0">
        </bits>
        <bits access="w" name="direct_ba" pos="18:16" rst="0">
        </bits>
        <bits access="w" name="chip_addr" pos="20" rst="0">
          <options>
            <option name="chip_0" value="0"/>
            <option name="chip_1" value="1"/>
          </options>
        </bits>
        <bits access="w" name="channel_addr" pos="24" rst="0">
          <options>
            <option name="channel_0" value="0"/>
            <option name="channel_1" value="1"/>
          </options>
        </bits>
        <bits access="w" name="direct_cmd" pos="31:28" rst="0">
          <options>
            <option name="nop" value="0"/>
            <option name="mrs" value="1"/>
            <option name="prechargeall" value="2"/>
            <option name="autorefresh" value="3"/>
            <option name="selfrefresh_entry" value="4"/>
            <option name="zqc" value="5"/>
            <option name="mrr" value="6"/>
            <option name="powerdown_entry" value="7"/>
            <option name="deep_powerdown_entry" value="8"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="mr_data" protect="r">
        <bits access="r" name="mr_data" pos="7:0" rst="0">
        </bits>
      </reg>
      <hole size="(3)*32"/>
      <reg name="refresh_control" protect="rw">
        <bits access="rw" name="per_bank_refresh" pos="0" rst="0">
          <options>
            <option name="all_bank_autorefresh" value="0"/>
            <option name="pre_bank_autorefresh" value="1"/>
          </options>
        </bits>
      </reg>
      <hole size="(55)*32"/>
      <reg name="t_refi" protect="rw">
        <bits access="rw" name="t_refi" pos="10:0" rst="0x100">
        </bits>
      </reg>
      <reg name="t_rfc" protect="rw">
        <bits access="rw" name="t_rfc" pos="8:0" rst="0x23">
        </bits>
        <bits access="rw" name="t_rfcab" pos="24:16" rst="0x23">
        </bits>
      </reg>
      <reg name="t_mrr" protect="rw">
        <bits access="rw" name="t_mrr" pos="2:0" rst="2">
        </bits>
      </reg>
      <reg name="t_mrw" protect="rw">
        <bits access="rw" name="t_mrw" pos="6:0" rst="2">
        </bits>
      </reg>
      <hole size="(2)*32"/>
      <reg name="t_rcd" protect="rw">
        <bits access="rw" name="t_rcd" pos="3:0" rst="5">
        </bits>
      </reg>
      <reg name="t_ras" protect="rw">
        <bits access="rw" name="t_ras" pos="5:0" rst="0xe">
        </bits>
      </reg>
      <reg name="t_rp" protect="rw">
        <bits access="rw" name="t_rp" pos="4:0" rst="5">
        </bits>
      </reg>
      <reg name="t_rpall" protect="rw">
        <bits access="rw" name="t_rpall" pos="4:0" rst="5">
        </bits>
      </reg>
      <reg name="t_rrd" protect="rw">
        <bits access="rw" name="t_rrd" pos="3:0" rst="4">
        </bits>
      </reg>
      <reg name="t_faw" protect="rw">
        <bits access="rw" name="t_faw" pos="5:0" rst="0x14">
        </bits>
      </reg>
      <reg name="read_latency" protect="rw">
        <bits access="rw" name="read_latency" pos="3:0" rst="5">
        </bits>
      </reg>
      <reg name="t_rtr" protect="rw">
        <bits access="rw" name="t_rtr" pos="3:0" rst="4">
        </bits>
      </reg>
      <reg name="t_rtw" protect="rw">
        <bits access="rw" name="t_rtw" pos="4:0" rst="6">
        </bits>
      </reg>
      <reg name="t_rtp" protect="rw">
        <bits access="rw" name="t_rtp" pos="3:0" rst="0">
        </bits>
      </reg>
      <reg name="write_latency" protect="rw">
        <bits access="rw" name="write_latency" pos="3:0" rst="4">
        </bits>
      </reg>
      <reg name="t_wr" protect="rw">
        <bits access="rw" name="t_wr" pos="4:0" rst="5">
        </bits>
      </reg>
      <reg name="t_wtr" protect="rw">
        <bits access="rw" name="t_wtr" pos="4:0" rst="4">
        </bits>
        <bits access="rw" name="t_wtr_cs" pos="20:16" rst="4">
        </bits>
      </reg>
      <reg name="t_wtw" protect="rw">
        <bits access="rw" name="t_wtw" pos="21:16" rst="4">
        </bits>
      </reg>
      <reg name="t_eckd" protect="rw">
        <bits access="rw" name="t_eckd" pos="3:0" rst="5">
        </bits>
      </reg>
      <reg name="t_xckd" protect="rw">
        <bits access="rw" name="t_xckd" pos="3:0" rst="5">
        </bits>
      </reg>
      <reg name="t_ep" protect="rw">
        <bits access="rw" name="t_ep" pos="3:0" rst="2">
        </bits>
      </reg>
      <reg name="t_xp" protect="rw">
        <bits access="rw" name="t_xp" pos="4:0" rst="2">
        </bits>
        <bits access="rw" name="t_xpdll" pos="20:16" rst="2">
        </bits>
      </reg>
      <reg name="t_esr" protect="rw">
        <bits access="rw" name="t_esr" pos="8:0" rst="0xe">
        </bits>
      </reg>
      <reg name="t_xsr" protect="rw">
        <bits access="rw" name="t_xsr" pos="9:0" rst="0x100">
        </bits>
        <bits access="rw" name="t_xsrdll" pos="25:16" rst="0x100">
        </bits>
      </reg>
      <reg name="t_srckd" protect="rw">
        <bits access="rw" name="t_srckd" pos="3:0" rst="5">
        </bits>
      </reg>
      <reg name="t_cksrd" protect="rw">
        <bits access="rw" name="t_cksrd" pos="3:0" rst="5">
        </bits>
      </reg>
      <hole size="(36)*32"/>
      <reg name="t_rddata_en" protect="rw">
        <bits access="rw" name="t_rddata_en" pos="3:0" rst="1">
        </bits>
      </reg>
      <reg name="t_phywrlat" protect="rw">
        <bits access="rw" name="t_phywrlat" pos="3:0" rst="1">
        </bits>
        <bits access="rw" name="t_phywrdata" pos="8" rst="1">
        </bits>
      </reg>
      <reg name="rdlvl_control" protect="rw">
        <bits access="rw" name="rdlvl_mode" pos="1:0" rst="0">
          <options>
            <option name="no_training" value="0"/>
            <option name="phy_independent_mode" value="1"/>
            <option name="phy_evaluation_mode" value="2"/>
          </options>
        </bits>
        <bits access="rw" name="rdlvl_setup" pos="4" rst="0">
          <options>
            <option name="mrs_prior_train" value="0"/>
            <option name="nop_prior_train" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="rdlvl_cmd" pos="8" rst="0">
          <options>
            <option name="read_for_train" value="0"/>
            <option name="mrr_for_train" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="rdlvl_refresh" pos="12" rst="1">
          <options>
            <option name="prechargeall_prior_train" value="0"/>
            <option name="prechargeall_autorefresh_prior_train" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="rdlvl_reg_sel" pos="16" rst="0">
          <options>
            <option name="mr32_for_train" value="0"/>
            <option name="mr40_for_train" value="1"/>
          </options>
        </bits>
      </reg>
      <reg name="rdlvl_mrs" protect="rw">
        <bits access="rw" name="rdlvl_mrs" pos="2:0" rst="4">
        </bits>
      </reg>
      <reg name="rdlvl_direct" protect="w">
        <bits access="w" name="rdlvl_req" pos="1:0" rst="0">
          <options>
            <option name="read_eye_train" value="1"/>
            <option name="read_gate_train" value="2"/>
          </options>
        </bits>
        <bits access="w" name="rdlvl_chip_addr" pos="24" rst="0">
          <options>
            <option name="chip_0" value="0"/>
            <option name="chip_1" value="1"/>
          </options>
        </bits>
        <bits access="w" name="rdlvl_channel_addr" pos="28" rst="0">
          <options>
            <option name="channel_0" value="0"/>
            <option name="channel_1" value="1"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="t_rdlvl_en" protect="rw">
        <bits access="rw" name="t_rdlvl_en" pos="5:0" rst="1">
        </bits>
      </reg>
      <reg name="t_rdlvl_rr" protect="rw">
        <bits access="rw" name="t_rdlvl_rr" pos="5:0" rst="4">
        </bits>
      </reg>
      <hole size="(2)*32"/>
      <reg name="wrlvl_control" protect="rw">
        <bits access="rw" name="wrlvl_mode" pos="1:0" rst="0">
          <options>
            <option name="no_training" value="0"/>
            <option name="phy_independent_mode" value="1"/>
            <option name="phy_evaluation_mode" value="2"/>
          </options>
        </bits>
        <bits access="rw" name="wrlvl_refresh" pos="12" rst="1">
          <options>
            <option name="prechargeall_prior_train" value="0"/>
            <option name="prechargeall_autorefresh_prior_train" value="1"/>
          </options>
        </bits>
      </reg>
      <reg name="wrlvl_mrs" protect="rw">
        <bits access="rw" name="wrlvl_mrs" pos="12:0" rst="0x86">
        </bits>
      </reg>
      <reg name="wrlvl_direct" protect="w">
        <bits access="w" name="wrlvl_req" pos="0" rst="0">
        </bits>
        <bits access="w" name="wrlvl_chip_addr" pos="24" rst="0">
          <options>
            <option name="chip_0" value="0"/>
            <option name="chip_1" value="1"/>
          </options>
        </bits>
        <bits access="w" name="wrlvl_channel_addr" pos="28" rst="0">
          <options>
            <option name="channel_0" value="0"/>
            <option name="channel_1" value="1"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="t_wrlvl_en" protect="rw">
        <bits access="rw" name="t_wrlvl_en" pos="5:0" rst="1">
        </bits>
      </reg>
      <reg name="t_wrlvl_ww" protect="rw">
        <bits access="rw" name="t_wrlvl_ww" pos="5:0" rst="4">
        </bits>
      </reg>
      <hole size="(2)*32"/>
      <reg name="phy_power_control" protect="rw">
        <bits access="rw" name="lp_wr_en" pos="0" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_rd_en" pos="1" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_idle_en" pos="2" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_pd_en" pos="3" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_sref_en" pos="4" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_dpd_en" pos="5" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_wakeup_wr" pos="11:8" rst="0">
        </bits>
        <bits access="rw" name="lp_wakeup_rd" pos="15:12" rst="0">
        </bits>
        <bits access="rw" name="lp_wakeup_idle" pos="19:16" rst="0">
        </bits>
        <bits access="rw" name="lp_wakeup_pd" pos="23:20" rst="0">
        </bits>
        <bits access="rw" name="lp_wakeup_sref" pos="27:24" rst="0">
        </bits>
        <bits access="rw" name="lp_wakeup_dpd" pos="31:28" rst="0">
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="phy_update_control" protect="rw">
        <bits access="rw" name="phyupd_type_00" pos="1:0" rst="0">
          <options>
            <option name="sref" value="0"/>
            <option name="stall" value="1"/>
            <option name="refnstall" value="2"/>
            <option name="defer" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="phyupd_type_01" pos="3:2" rst="0">
          <options>
            <option name="sref" value="0"/>
            <option name="stall" value="1"/>
            <option name="refnstall" value="2"/>
            <option name="defer" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="phyupd_type_10" pos="5:4" rst="0">
          <options>
            <option name="sref" value="0"/>
            <option name="stall" value="1"/>
            <option name="refnstall" value="2"/>
            <option name="defer" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="phyupd_type_11" pos="7:6" rst="0">
          <options>
            <option name="sref" value="0"/>
            <option name="stall" value="1"/>
            <option name="refnstall" value="2"/>
            <option name="defer" value="3"/>
          </options>
        </bits>
      </reg>
      <hole size="(43)*32"/>
      <reg name="user_status" protect="r">
        <bits access="r" name="user_status" pos="7:0" rst="0">
        </bits>
      </reg>
      <reg name="user_config0" protect="rw">
        <bits access="rw" name="user_config0" pos="7:0" rst="0">
        </bits>
      </reg>
      <reg name="user_config1" protect="rw">
        <bits access="rw" name="user_config1" pos="7:0" rst="0">
        </bits>
      </reg>
      <hole size="(637)*32"/>
      <reg name="integ_cfg" protect="rw">
        <bits access="rw" name="integ_test_en" pos="0" rst="0">
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="integ_outputs" protect="w">
        <bits access="w" name="combined_integ" pos="0" rst="0">
        </bits>
        <bits access="w" name="ecc_sec_integ" pos="1" rst="0">
        </bits>
        <bits access="w" name="ecc_ded_integ" pos="2" rst="0">
        </bits>
        <bits access="w" name="ecc_overflow_integ" pos="3" rst="0">
        </bits>
      </reg>
      <hole size="(117)*32"/>
      <reg name="periph_id_0" protect="r">
        <bits access="r" name="part_0" pos="7:0" rst="0x40">
        </bits>
      </reg>
      <reg name="periph_id_1" protect="r">
        <bits access="r" name="part_1" pos="3:0" rst="4">
        </bits>
        <bits access="r" name="des_0" pos="7:4" rst="0xb">
        </bits>
      </reg>
      <reg name="periph_id_2" protect="r">
        <bits access="r" name="des_1" pos="2:0" rst="3">
        </bits>
        <bits access="r" name="jedec" pos="3" rst="1">
        </bits>
        <bits access="r" name="revision" pos="7:4" rst="1">
        </bits>
      </reg>
      <reg name="periph_id_3" protect="r">
        <bits access="r" name="cmod" pos="7:0" rst="0">
        </bits>
      </reg>
      <reg name="component_id_0" protect="r">
        <bits access="r" name="prmbl_0" pos="7:0" rst="0xd">
        </bits>
      </reg>
      <reg name="component_id_1" protect="r">
        <bits access="r" name="prmbl_1" pos="3:0" rst="0">
        </bits>
        <bits access="r" name="pclass" pos="7:4" rst="0xf">
        </bits>
      </reg>
      <reg name="component_id_2" protect="r">
        <bits access="r" name="prmbl_2" pos="7:0" rst="5">
        </bits>
      </reg>
      <reg name="component_id_3" protect="r">
        <bits access="r" name="prmbl_3" pos="7:0" rst="0xb1">
        </bits>
      </reg>
    </module>
    <instance address="0x51600000" name="DMC_CTRL" type="DMC400"/>
  </archive>
  <archive relative="gic400_reg.xml">
    <module category="System" name="GIC400">
      <hole size="32768"/>
      <reg name="gicd_ctrl" protect="rw">
        <bits access="rw" name="enablegrp1" pos="1" rst="0">
          <comment>Global enable for forwarding pending Group 1 interrupts from the Distributor to the CPU interfaces:
          0    Group 1 interrupts not forward.
          1    Group 1 interrupts forwarded, subject to the priority rules.</comment>
        </bits>
        <bits access="rw" name="enablegrp0" pos="0" rst="0">
          <comment>Global enable for forwarding pending Group 0 interrupts from the Distributor to the CPU interfaces:
          0    Group 0 interrupts not forwarded.
          1    Group 0 interrupts forwarded, subject to the priority rules.</comment>
        </bits>
      </reg>
      <reg name="gicd_typer" protect="r">
        <bits access="r" name="lspi" pos="15:11" rst="31">
          <comment>If the GIC implements the Security Extensions, the value of this field is the maximum number of
          implemented lockable SPIs, from 0 (0b00000) to 31 (0b11111), see Configuration lockdown on
          page 4-82. If this field is 0b00000 then the GIC does not implement configuration lockdown.
          If the GIC does not implement the Security Extensions, this field is reserved.</comment>
        </bits>
        <bits access="r" name="securityextn" pos="10" rst="1">
          <comment>Indicates whether the GIC implements the Security Extensions.
          0 Security Extensions not implemented.
          1 Security Extensions implemented.</comment>
        </bits>
        <bits access="r" name="cpunumber" pos="7:5" rst="1">
          <comment>Indicates the number of implemented CPU interfaces. The number of implemented CPU interfaces is
          one more than the value of this field, for example if this field is 0b011, there are four CPU interfaces.
          If the GIC implements the Virtualization Extensions, this is also the number of virtual CPU interfaces.</comment>
        </bits>
        <bits access="r" name="itlinesnumber" pos="4:0" rst="3">
          <comment>Indicates the maximum number of interrupts that the GIC supports. If ITLinesNumber=N, the
          maximum number of interrupts is 32(N+1). The interrupt ID range is from 0 to (number of IDs C 1).
          For example:
          0b00011 Up to 128 interrupt lines, interrupt IDs 0-127.
          The maximum number of interrupts is 1020 (0b11111). See the text in this section for more information.
          Regardless of the range of interrupt IDs defined by this field, interrupt IDs 1020-1023 are reserved for
          special purposes.</comment>
        </bits>
      </reg>
      <reg name="gicd_iddr" protect="r">
        <bits access="r" name="productid" pos="31:24" rst="2">
          <comment>Product ID</comment>
        </bits>
        <bits access="r" name="variant" pos="19:16" rst="0">
          <comment>An IMPLEMENTATION DEFINED variant number. Typically, this field is used to distinguish product variants,
          or major revisions of a product.</comment>
        </bits>
        <bits access="r" name="revision" pos="15:12" rst="1">
          <comment>An IMPLEMENTATION DEFINED revision number. Typically, this field is used to distinguish minor revisions
          of a product.</comment>
        </bits>
        <bits access="r" name="implementer" pos="11:0" rst="1083">
          <comment>Contains the JEP106 code of the company that implemented the GIC Distributor:
          Bits [11:8] The JEP106 continuation code of the implementer. For an ARM implementation, this field
          is 0x4.
          Bits [7] Always 0.
          Bits [6:0] The JEP106 identity code of the implementer. For an ARM implementation, bits[7:0] are
          0x3B.</comment>
        </bits>
      </reg>
      <hole size="928"/>
      <reg count="4" name="gicd_igrouprn" protect="rw">
        <comment>The GICD_IGROUPR registers provide a status bit for each interrupt supported by the GIC.
          Each bit controls whether the corresponding interrupt is in Group 0 or Group 1.
          Accessible by Secure accesses Only.
          For each bit:
          0 The corresponding interrupt is Group 0.
          1 The corresponding interrupt is Group 1.For interrupt ID m, when DIV and MOD are the integer division and
          modulo operations:
          a. the corresponding GICD_IGROUPRn number, n, is given by n = m DIV 32
          b. the offset of the required GICD_IGROUPR is (0x080 + (4*n))
          c. the bit number of the required group status bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg name="gicd_isenabler0" protect="rw">
        <comment>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Enables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 1.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ISENABLER number, n, is given by n = m DIV 32
          b.the offset of the required GICD_ISENABLER is (0x100 + (4*n))
          c.the bit number of the required Set-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_isenabler1" protect="rw">
        <comment>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Enables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 1.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ISENABLER number, n, is given by n = m DIV 32
          b.the offset of the required GICD_ISENABLER is (0x100 + (4*n))
          c.the bit number of the required Set-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_isenabler2" protect="rw">
        <comment>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Enables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 1.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ISENABLER number, n, is given by n = m DIV 32
          b.the offset of the required GICD_ISENABLER is (0x100 + (4*n))
          c.the bit number of the required Set-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_isenabler3" protect="rw">
        <comment>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Enables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 1.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ISENABLER number, n, is given by n = m DIV 32
          b.the offset of the required GICD_ISENABLER is (0x100 + (4*n))
          c.the bit number of the required Set-enable bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg name="gicd_icenabler0" protect="rw">
        <comment>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the
          GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Disables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 0.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ICENABLERn number, n, is given by m = n DIV 32
          b.the offset of the required GICD_ICENABLERn is (0x180 + (4*n))
          c.the bit number of the required Clear-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_icenabler1" protect="rw">
        <comment>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the
          GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Disables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 0.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ICENABLERn number, n, is given by m = n DIV 32
          b.the offset of the required GICD_ICENABLERn is (0x180 + (4*n))
          c.the bit number of the required Clear-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_icenabler2" protect="rw">
        <comment>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the
          GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Disables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 0.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ICENABLERn number, n, is given by m = n DIV 32
          b.the offset of the required GICD_ICENABLERn is (0x180 + (4*n))
          c.the bit number of the required Clear-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_icenabler3" protect="rw">
        <comment>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the
          GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Disables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 0.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ICENABLERn number, n, is given by m = n DIV 32
          b.the offset of the required GICD_ICENABLERn is (0x180 + (4*n))
          c.the bit number of the required Clear-enable bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg count="4" name="gicd_ispendrn" protect="rw">
        <comment>The GICD_ISPENDRs provide a Set-pending bit for each interrupt supported by the GIC.
          For each bit:
          Reads 0  The corresponding interrupt is not pending on any processor.
                1  a. For PPIs and SGIs, the corresponding interrupt is pendinga on this
                      processor.
                   b. For SPIs, the corresponding interrupt is pendinga on at least one
                      processor.
          Writes For SPIs and PPIs:
                0  Has no effect.
                1  The effect depends on whether the interrupt is edge-triggered or
                   level-sensitive:
                   Edge-triggered
                         Changes the status of the corresponding interrupt to:
                         a.pending if it was previously inactive
                         b.active and pending if it was previously active.
                         Has no effect if the interrupt is already pending.
                   Level sensitive
                         If the corresponding interrupt is not pendinga, changes the status
                         of the corresponding interrupt to:
                         a. pending if it was previously inactive
                         b. active and pending if it was previously active.
                         If the interrupt is already pending:
                         a. because of a write to the GICD_ISPENDR, the write has
                           no effect.
                         b. because the corresponding interrupt signal is asserted, the
                           write has no effect on the status of the interrupt, but the
                           interrupt remains pendinga if the interrupt signal is
                           deasserted.
                For SGIs, the write is ignored. SGIs have their own Set-Pending registers.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ISPENDR number, n, is given by n = m DIV 32
          b. the offset of the required GICD_ISPENDR is (0x200 + (4*n))
          c. the bit number of the required Set-pending bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg count="4" name="gicd_icpendrn" protect="rw">
        <comment>The GICD_ICPENDRs provide a Clear-pending bit for each interrupt supported by the GIC.
          For each bit:
          Reads 0   The corresponding interrupt is not pending on any processor.
                1   a. For SGIs and PPIs, the corresponding interrupt is pendinga on this
                       processor.
                    b. For SPIs, the corresponding interrupt is pendinga on at least one
                       processor.
          Writes For SPIs and PPIs:
                0   Has no effect.
                1   The effect depends on whether the interrupt is edge-triggered or level-sensitive:
                    Edge-triggered
                          Changes the status of the corresponding interrupt to:
                          a. inactive if it was previously pending
                          b. active if it was previously active and pending.
                          Has no effect if the interrupt is not pending.
                    Level-sensitive
                          If the corresponding interrupt is pendinga only because of a write to
                          GICD_ISPENDRn, the write changes the status of the interrupt to:
                          a. inactive if it was previously pending
                          b. active if it was previously active and pending.
                          Otherwise the interrupt remains pending if the interrupt signal
                          remains asserted.
                For SGIs, the write is ignored. SGIs have their own Clear-Pending registers.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICPENDR number, n, is given by n = m DIV 32
          b. the offset of the required GICD_ICPENDR is (0x280 + (4*n))
          c. the bit number of the required Set-pending bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg count="4" name="gicd_isactivern" protect="rw">
        <comment>The GICD_ISACTIVERs provide a Set-active bit for each interrupt that the GIC supports.
          For each bit:
          Reads  0  The corresponding interrupt is not active.
                 1  The corresponding interrupt is active.
          Writes 0  Has no effect.
                 1  Activates the corresponding interrupt, if it is not already active. If the interrupt
                    is already active, the write has no effect.
                    After a write of 1 to this bit, a subsequent read of the bit returns the value 1.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ISACTIVERn number, n, is given by n = m DIV 32
          b. the offset of the required GICD_ISACTIVERn is (0x300 + (4*n))
          c. the bit number of the required Set-active bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg count="4" name="gicd_icactivern" protect="rw">
        <comment>The GICD_ICACTIVERs provide a Clear-active bit for each interrupt that the GIC
          supports.
          For each bit:
          Reads  0  The corresponding interrupt is not activea.
                 1  The corresponding interrupt is activea.
          Writes 0  Has no effect.
                 1  Deactivates the corresponding interrupt, if the interrupt is active. If the
                    interrupt is already deactivated, the write has no effect.
                    After a write of 1 to this bit, a subsequent read of the bit returns the value 0.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICACTIVERn number, n, is given by n = m DIV 32
          b. the offset of the required GICD_ICACTIVERn is (0x380 + (4*n))
          c. the bit number of the required Clear-active bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg count="32" name="gicd_ipriorityrn" protect="rw">
        <comment>The GICD_IPRIORITYRs provide an 8-bit priority field for each interrupt supported by the
          GIC.
          Each priority field holds a priority value, from an IMPLEMENTATION DEFINED range. The lower the
          value, the greater the priority of the corresponding interrupt.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_IPRIORITYRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_IPRIORITYRn is (0x400 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <hole size="7168"/>
      <reg name="gicd_itargetsr0" protect="r">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr1" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr2" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr3" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr4" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr5" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr6" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr7" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr8" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr9" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr10" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr11" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr12" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr13" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr14" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr15" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr16" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr17" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr18" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr19" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr20" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr21" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr22" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr23" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr24" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr25" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr26" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr27" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr28" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr29" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr30" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr31" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <hole size="7168"/>
      <reg name="gicd_icfgr0" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr1" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr2" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr3" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr4" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr5" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr6" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr7" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <hole size="1792"/>
      <reg name="gicd_ppisr" protect="r">
        <bits access="r" name="ppi_status" pos="15:9" rst="0">
          <comment>Asserted when the PPI inputs to the Distributor are active.
          ID 31 nLEGACYIRQ signal
          ID 30 Non-secure physical timer event
          ID 29 Secure physical timer event
          ID 28 nLEGACYFIQ signal
          ID 27 Virtual timer event
          ID 26 Hypervisor timer event
          ID 25 Virtual maintenance interrupt.</comment>
        </bits>
      </reg>
      <reg count="3" name="gicd_spisrn" protect="r">
        <comment>Returns the status of the IRQS inputs on the Distributor. For each bit:
          0 IRQS is LOW
          1 IRQS is HIGH.</comment>
      </reg>
      <hole size="1920"/>
      <reg count="8" name="gicd_nsacrn" protect="rw">
        <comment>The GICD_NSACRs enable Secure software to permit Non-secure software on a particular
          processor to create and manage Group 0 interrupts. They provide an access control for each
          implemented interrupt.
          If the corresponding interrupt does not support configurable Non-secure access, the field is
          RAZ/WI. Otherwise, the field is RW and configures the level of Non-secure access permitted
          when the interrupt is in Group 0. If the interrupt is in Group 1, this field is ignored. The possible
          values of the field are:
          0b00 No Non-secure access is permitted to fields associated with the corresponding
               interrupt.
          0b01 Non-secure write access is permitted to fields associated with the corresponding
               interrupt in the GICD_ISPENDRn registers. A Non-secure write access to
               GICD_SGIR is permitted to generate a Group 0 SGI for the corresponding
               interrupt.
          0b10 Adds Non-secure write access permission to fields associated with the
               corresponding interrupt in the GICD_ICPENDRn registers. Also adds
               Non-secure read access permission to fields associated with the corresponding
               interrupt in the GICD_ISACTIVERn and GICD_ICACTIVERn registers.
          0b11 Adds Non-secure read and write access permission to fields associated with the
               corresponding interrupt in the GICD_ITARGETSRn registers.
          The GICD_NSACRn registers do not support PPI accesses, meaning that GICD_NSACR0 bits [31:16] are
          RAZ/WI.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_NSACR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_NSACRn is (0xE00 + (4*n)).</comment>
      </reg>
      <hole size="1792"/>
      <reg name="gicd_sgir" protect="rw">
        <bits access="w" name="targetlistfilter" pos="25:24" rst="0">
          <comment>Determines how the distributor must process the requested SGI:
          0b00 Forward the interrupt to the CPU interfaces specified in the CPUTargetList fielda.
          0b01 Forward the interrupt to all CPU interfaces except that of the processor that requested the
               interrupt.
          0b10 Forward the interrupt only to the CPU interface of the processor that requested the
               interrupt.
          0b11 Reserved.</comment>
        </bits>
        <bits access="w" name="cputargetlist" pos="23:16" rst="0">
          <comment>When TargetList Filter = 0b00, defines the CPU interfaces to which the Distributor must forward the
          interrupt.
          Each bit of CPUTargetList[7:0] refers to the corresponding CPU interface, for example
          CPUTargetList[0] corresponds to CPU interface 0. Setting a bit to 1 indicates that the interrupt must be
          forwarded to the corresponding interface.
          If this field is 0x00 when TargetListFilter is 0b00, the Distributor does not forward the interrupt to any
          CPU interface.</comment>
        </bits>
        <bits access="w" name="nsatt" pos="15" rst="0">
          <comment>Implemented only if the GIC includes the Security Extensions.
          Specifies the required security value of the SGI:
          0   Forward the SGI specified in the SGIINTID field to a specified CPU interface only if the
              SGI is configured as Group 0 on that interface.
          1   Forward the SGI specified in the SGIINTID field to a specified CPU interfaces only if
              the SGI is configured as Group 1 on that interface.
          This field is writable only by a Secure access. Any Non-secure write to the GICD_SGIR generates an
          SGI only if the specified SGI is programmed as Group 1, regardless of the value of bit[15] of the write.</comment>
        </bits>
        <bits access="w" name="sgiintid" pos="3:0" rst="0">
          <comment>The Interrupt ID of the SGI to forward to the specified CPU interfaces. The value of this field is the
          Interrupt ID, in the range 0-15, for example a value of 0b0011 specifies Interrupt ID 3.</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg count="4" name="gicd_cpendsgirn" protect="rw">
        <comment>The GICD_CPENDSGIRs provide a clear-pending bit for each supported SGI and source
          processor combination.
          For each bit:
          Reads  0 SGI x from the corresponding processor is not pending.
                 1 SGI x from the corresponding processor is pending.
          Writes 0 Has no effect.
                 1 Removes the pending state of SGI x for the corresponding processor.
          For SGI ID x, generated by CPU C writing to its GICD_SGIR, when DIV and MOD are the integer division and
          modulo operations:
          a. the corresponding GICD_CPENDSGIR register number, n, is given by n = x DIV 4
          b. the offset of the required GICD_CPENDSGIR is (0xF10 + (4*n));
          c. the SGI Clear-pending field offset, y, is given by y = x MOD 4
          d. the required bit in the SGI x Clear-pending field is bit C.</comment>
      </reg>
      <reg count="4" name="gicd_spendsgirn" protect="rw">
        <comment>The GICD_SPENDSGIRn registers provide a set-pending bit for each supported SGI and
          source processor combination.
          For each bit:
          Reads  0 SGI x for the corresponding processor is not pendinga.
                 1 SGI x for the corresponding processor is pendinga.
          Writes 0 Has no effect.
                 1 Adds the pending state of SGI x for the corresponding processor,
                   if it is not already pending. If SGI x is already pending for the
                   corresponding processor then the write has no effect.
          For SGI ID x, generated by CPU C writing to its GICD_SGIR, when DIV and MOD are the integer division and
          modulo operations:
          a. the corresponding GICD_SPENDSGIR register number, n, is given by n = x DIV 4
          b. the offset of the required GICD_SPENDSGIR is (0xF20 + (4*n))
          c. the SGI Set-pending field offset, y, is given by y = x MOD 4
          d. the required bit in the SGI x Set-pending field is bit C.</comment>
      </reg>
      <hole size="1664"/>
      <reg name="gicc_ctrl" protect="rw">
        <bits access="rw" name="eoimodens" pos="10" rst="0">
          <comment>Alias of EOImodeNS from the Non-secure copy of this register.</comment>
        </bits>
        <bits access="rw" name="eoimodes" pos="9" rst="0">
          <comment>Controls the behavior of accesses to GICC_EOIR and GICC_DIR registers. In a GIC implementation
          that includes the Security Extensions, this control applies only to Secure accesses, and the EOImodeNS
          bit controls the behavior of Non-secure accesses to these registers:
          0   GICC_EOIR has both priority drop and deactivate interrupt functionality. Accesses to
              the GICC_DIR are UNPREDICTABLE.
          1   GICC_EOIR has priority drop functionality only. GICC_DIR has deactivate interrupt
              functionality.</comment>
        </bits>
        <bits access="rw" name="irqbypdisgrp1" pos="8" rst="0">
          <comment>Alias of IRQBypDisGrp1 from the Non-secure copy of this register.</comment>
        </bits>
        <bits access="rw" name="fiqbypdisgrp1" pos="7" rst="0">
          <comment>Alias of FIQBypDisGrp1 from the Non-secure copy of this register.</comment>
        </bits>
        <bits access="rw" name="irqbypdisgrp0" pos="6" rst="0">
          <comment>When the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the bypass
          IRQ signal is signaled to the processor:
          0 Bypass IRQ signal is signaled to the processor
          1 Bypass IRQ signal is not signaled to the processor.</comment>
        </bits>
        <bits access="rw" name="fiqbypdisgrp0" pos="5" rst="0">
          <comment>When the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the bypass
          FIQ signal is signaled to the processor:
          0 Bypass FIQ signal is signaled to the processor
          1 Bypass FIQ signal is not signaled to the processor.</comment>
        </bits>
        <bits access="rw" name="cbpr" pos="4" rst="0">
          <comment>Controls whether the GICC_BPR provides common control to Group 0 and Group 1 interrupts.
          0 To determine any preemption, use:
          ? the GICC_BPR for Group 0 interrupts
          ? the GICC_ABPR for Group 1 interrupts.
          1 To determine any preemption use the GICC_BPR for both Group 0 and Group 1
          interrupts.</comment>
        </bits>
        <bits access="rw" name="fiqen" pos="3" rst="0">
          <comment>Controls whether the CPU interface signals Group 0 interrupts to a target processor using the FIQ or
          the IRQ signal.
          0 Signal Group 0 interrupts using the IRQ signal.
          1 Signal Group 0 interrupts using the FIQ signal.
          The GIC always signals Group 1 interrupts using the IRQ signal.</comment>
        </bits>
        <bits access="rw" name="ackctl" pos="2" rst="0">
          <comment>When the highest priority pending interrupt is a Group 1 interrupt, determines both:
          ? whether a read of GICC_IAR acknowledges the interrupt, or returns a spurious interrupt ID
          ? whether a read of GICC_HPPIR returns the ID of the highest priority pending interrupt, or
          returns a spurious interrupt ID.
          0 If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR
          or the GICC_HPPIR returns an Interrupt ID of 1022. A read of the GICC_IAR does
          not acknowledge the interrupt, and has no effect on the pending status of the interrupt.
          1 If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR
          or the GICC_HPPIR returns the Interrupt ID of the Group 1 interrupt. A read of
          GICC_IAR acknowledges and Activates the interrupt.</comment>
        </bits>
        <bits access="rw" name="enablegrp1" pos="1" rst="0">
          <comment>Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor:
          0 Disable signaling of Group 1 interrupts.
          1 Enable signaling of Group 1 interrupts.</comment>
        </bits>
        <bits access="rw" name="enablegrp0" pos="0" rst="0">
          <comment>Enable for the signaling of Group 0 interrupts by the CPU interface to the connected processor:
          0 Disable signaling of Group 0 interrupts.
          1 Enable signaling of Group 0 interrupts.</comment>
        </bits>
      </reg>
      <reg name="gicc_pmr" protect="rw">
        <bits access="rw" name="priority" pos="7:0" rst="0">
          <comment>The priority mask level for the CPU interface. If the priority of an interrupt is higher than the
          value indicated by this field, the interface signals the interrupt to the processor.
          If the GIC supports fewer than 256 priority levels then some bits are RAZ/WI, as follows:
          128 supported levels Bit [0] = 0.
          64 supported levels Bit [1:0] = 0b00.
          32 supported levels Bit [2:0] = 0b000.
          16 supported levels Bit [3:0] = 0b0000.</comment>
        </bits>
      </reg>
      <reg name="gicc_bpr" protect="rw">
        <bits access="rw" name="binary_point" pos="2:0" rst="2">
          <comment>The value of this field controls how the 8-bit interrupt priority field is split into a group
          priority field, used to determine interrupt preemption, and a subpriority field.
          The minimum value of the Binary Point Register depends on which
          security-banked copy is considered:
          0x2 Secure copy
          0x3 Non-secure copy</comment>
        </bits>
      </reg>
      <reg name="gicc_iar" protect="r">
        <bits access="r" name="cpuid" pos="12:10" rst="0">
          <comment>For SGIs in a multiprocessor implementation, this field identifies the processor that
          requested the interrupt. It returns the number of the CPU interface that made the
          request, for example a value of 3 means the request was generated by a write to the
          GICD_SGIR on CPU interface 3.
          For all other interrupts this field is RAZ.</comment>
        </bits>
        <bits access="r" name="interrupt_id" pos="9:0" rst="1023">
          <comment>The interrupt ID.</comment>
        </bits>
      </reg>
      <reg name="gicc_eoir" protect="rw">
        <bits access="w" name="cpuid" pos="12:10" rst="0">
          <comment>On a multiprocessor implementation, if the write refers to an SGI, this
          the CPUID value from the corresponding GICC_IAR access.
          In all other cases this field SBZ.</comment>
        </bits>
        <bits access="w" name="eoiintid" pos="9:0" rst="0">
          <comment>The Interrupt ID value from the corresponding GICC_IAR access.</comment>
        </bits>
      </reg>
      <reg name="gicc_rpr" protect="r">
        <bits access="r" name="priority" pos="7:0" rst="255">
          <comment>The current running priority on the CPU interface.</comment>
        </bits>
      </reg>
      <reg name="gicc_hppir" protect="r">
        <bits access="r" name="cpuid" pos="12:10" rst="0">
          <comment>On a multiprocessor implementation, if the PENDINTID field returns the ID of an
          SGI, this field contains the CPUID value for that interrupt. This identifies the
          processor that generated the interrupt.
          In all other cases this field is RAZ.</comment>
        </bits>
        <bits access="r" name="pendintid" pos="9:0" rst="1023">
          <comment>The interrupt ID of the highest priority pending interrupt. See Table 4-42 on
          page 4-144 for more information about the result of Non-secure reads of the
          GICC_HPPIR when the GIC implements the Security Extensions.</comment>
        </bits>
      </reg>
      <reg name="gicc_abpr" protect="rw">
        <bits access="rw" name="binary_point" pos="2:0" rst="3">
          <comment>A Binary Point Register for handling Group 1 interrupts.</comment>
        </bits>
      </reg>
      <reg name="gicc_aiar" protect="r">
        <bits access="r" name="cpuid" pos="12:10" rst="0">
          <comment>CPUID For SGIs in a multiprocessor implementation, this field identifies the processor that
          requested the interrupt. It returns the number of the CPU interface that made the request,
          for example a value of 3 means the request was generated by a write to the GICD_SGIR
          on CPU interface 3.
          For all other interrupts this field is RAZ.</comment>
        </bits>
        <bits access="r" name="interrupt_id" pos="9:0" rst="1023">
          <comment>Interrupt ID The interrupt ID.</comment>
        </bits>
      </reg>
      <reg name="gicc_aeoir" protect="rw">
        <bits access="w" name="cpuid" pos="12:10" rst="0">
          <comment>On a multiprocessor implementation, when processing an SGI, this field must contain
          the CPUID value from the corresponding GICC_AIAR, or Non-secure GICC_IAR,
          access.
          In all other cases this field SBZ.</comment>
        </bits>
        <bits access="w" name="interrupt_id" pos="9:0" rst="0">
          <comment>The Interrupt ID value from the corresponding GICC_AIAR, or Non-secure GICC_IAR,
          access.</comment>
        </bits>
      </reg>
      <reg name="gicc_ahppir" protect="r">
        <bits access="r" name="cpuid" pos="12:10" rst="0">
          <comment>On a multiprocessor implementation, if the PENDINTID field returns the ID of an
          SGI, this field contains the CPUID value for that interrupt. This identifies the
          processor that generated the interrupt.
          In all other cases this field is RAZ.</comment>
        </bits>
        <bits access="r" name="pendintid" pos="9:0" rst="1023">
          <comment>The interrupt ID of the highest priority pending interrupt, if that interrupt is a Group 1
          interrupt. Otherwise, the spurious interrupt ID, 1023.</comment>
        </bits>
      </reg>
      <hole size="1312"/>
      <reg name="gicc_aprn" protect="rw">
        <comment>Active Priorities Registers</comment>
      </reg>
      <hole size="96"/>
      <reg name="gicc_nsaprn" protect="rw">
        <comment>NonSecure Active Priorities Registers</comment>
      </reg>
      <hole size="192"/>
      <reg name="gicc_iidr" protect="r">
        <bits access="r" name="productid" pos="31:24" rst="2">
          <comment>An IMPLEMENTATION DEFINED product identifier.</comment>
        </bits>
        <bits access="r" name="architecture_version" pos="19:16" rst="2">
          <comment>The value of this field depends on the GIC architecture version, as follows:
          ? 0x1 for GICv1
          ? 0x2 for GICv2.</comment>
        </bits>
        <bits access="r" name="revision" pos="15:12" rst="1">
          <comment>An IMPLEMENTATION DEFINED revision number for the CPU interface.</comment>
        </bits>
        <bits access="r" name="implementer" pos="11:0" rst="1083">
          <comment>Contains the JEP106 code of the company that implemented the GIC CPU
          interface:
          Bits [11:8] The JEP106 continuation code of the implementer.
          Bit  [7]    Always 0.
          Bits [6:0] The JEP106 identity code of the implementer.</comment>
        </bits>
      </reg>
      <hole size="30720"/>
      <reg name="gicc_dir" protect="rw">
        <bits access="w" name="cpuid" pos="12:10" rst="0">
          <comment>For an SGI in a multiprocessor implementation, this field
          identifies the processor that requested the interrupt.
          For all other interrupts this field is RAZ.</comment>
        </bits>
        <bits access="w" name="interrupt_id" pos="9:0" rst="0">
          <comment>The interrupt ID</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x00800000" name="GIC400" type="GIC400"/>
  </archive>
  <archive relative="gouda.xml">
    <include file="globals.xml"/>
    <module category="System" name="GOUDA">
      <var name="GD_MAX_OUT_WIDTH" value="640"/>
      <comment>Maximum output width in pixels</comment>
      <var name="GD_NB_BITS_LCDPOS" value="11"/>
      <comment>Number of bits coding position in virtual screen</comment>
      <var name="GD_FP_FRAC_SIZE" value="8"/>
      <comment>Number of bits of fractional part of internal fixed point values</comment>
      <var name="GD_FIXEDPOINT_SIZE" value="3+GD_FP_FRAC_SIZE"/>
      <comment>Number of bits of internal fixed point values</comment>
      <var name="GD_NB_BITS_STRIDE" value="13"/>
      <comment>Number of bits for stride storage</comment>
      <var name="GD_MAX_SLCD_READ_LEN" value="4"/>
      <var name="GD_MAX_SLCD_CLK_DIVIDER" value="255"/>
      <reg name="gd_command" protect="rw">
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>Starts the image transfer. Autoreset</comment>
        </bits>
      </reg>
      <reg name="gd_status" protect="r">
        <bits access="r" name="ia_busy" pos="0" rst="0x0">
          <comment>High while image accelerator is busy</comment>
        </bits>
        <bits access="r" name="lcd_busy" pos="4" rst="0x0">
          <comment>High while LCD controller is busy</comment>
        </bits>
      </reg>
      <reg name="gd_eof_irq" protect="rc">
        <bits access="rc" name="eof_cause" pos="0" rst="0x0">
          <comment>
            High when End Of Frame IRQ has been generated.
            <br/>
            To clear it, write 1 in this bit or in eof_status.
          </comment>
        </bits>
        <bits access="rc" name="eof_status" pos="16" rst="0x0">
          <comment>
            Unmasked version of eof_cause.
            <br/>
            To clear it, write 1 in this bit or in eof_status.
          </comment>
        </bits>
      </reg>
      <reg name="gd_eof_irq_mask" protect="rw">
        <bits access="rw" name="eof_mask" pos="0" rst="0x0">
          <comment>
            EOF interrupt generation mask:
            <br/>
            0: EOF IRQ disabled
            <br/>
            1: EOF IRQ enabled
          </comment>
        </bits>
      </reg>
      <reg name="gd_roi_tl_ppos" protect="rw">
        <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
          <comment>LCD Region Of Interest Top-Left pixel x-axis</comment>
        </bits>
        <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
          <comment>LCD Region Of Interest Top-Left pixel y-axis</comment>
        </bits>
      </reg>
      <reg name="gd_roi_br_ppos" protect="rw">
        <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
          <comment>LCD Region Of Interest Bottom-Right pixel x-axis</comment>
        </bits>
        <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
          <comment>LCD Region Of Interest Bottom-Right pixel y-axis</comment>
        </bits>
      </reg>
      <reg name="gd_roi_bg_color" protect="rw">
        <bits access="rw" name="b" pos="4:0" rst="0x0">
          <comment>Blue component of the ROI background color</comment>
        </bits>
        <bits access="rw" name="g" pos="10:5" rst="0x0">
          <comment>Green component of the ROI background color</comment>
        </bits>
        <bits access="rw" name="r" pos="15:11" rst="0x0">
          <comment>Red component of the ROI background color</comment>
        </bits>
      </reg>
      <reg name="gd_vl_input_fmt" protect="rw">
        <bits access="rw" name="format" pos="1:0" rst="0x0">
          <comment>
            Input image format
            <br/>
            00b: RGB565 pixel packed
            <br/>
            01b: YUV4:2:2 pixel packed (UYVY)
            <br/>
            10b: YUV4:2:2 pixel packed (YUYV)
            <br/>
            11b: YUV4:2:0 planar (IYUV)
          </comment>
        </bits>
        <bits access="rw" name="stride" pos="GD_NB_BITS_STRIDE+1:2" rst="0x0">
          <comment>
            Image stride in bytes (of Y component for planar formats).
            <br/>
            This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
          </comment>
        </bits>
        <bits access="rw" name="active" pos="31" rst="0x0">
          <comment>
            Defines Layer's activity:
            <br/>
            0: Layer disabled
            <br/>
            1: Layer active
          </comment>
        </bits>
      </reg>
      <reg name="gd_vl_tl_ppos" protect="rw">
        <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
          <comment>Video Layer (layer 0) Top-Left pixel x-axis position</comment>
        </bits>
        <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
          <comment>Video Layer (layer 0) Top-Left pixel y-axis position</comment>
        </bits>
      </reg>
      <reg name="gd_vl_br_ppos" protect="rw">
        <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
          <comment>Video Layer (layer 0) Bottom-Right pixel x-axis position</comment>
        </bits>
        <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
          <comment>Video Layer (layer 0) Bottom-Right pixel y-axis position</comment>
        </bits>
      </reg>
      <reg name="gd_vl_extents" protect="rw">
        <bits access="rw" name="max_line" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
          <comment>Number of lines of source image (idem gd_vl_br_ppos.y1 when
                 vertical scaling factor is one).</comment>
        </bits>
        <bits access="rw" name="max_col" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
          <comment>Number of columns of source image (idem gd_vl_br_ppos.x1 when
                 vertical scaling factor is one).</comment>
        </bits>
      </reg>
      <reg name="gd_vl_blend_opt" protect="rw">
        <bits access="rw" name="chroma key b" pos="4:0" rst="0x0">
          <comment>Blue component of the Chroma Key</comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="chroma key g" pos="10:5" rst="0x0">
          <comment>Green component of the Chroma Key</comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="chroma key r" pos="15:11" rst="0x0">
          <comment>Red component of the Chroma Key</comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bitgroup name="chroma key color">
          <entry ref="chroma key b"/>
          <entry ref="chroma key g"/>
          <entry ref="chroma key r"/>
        </bitgroup>
        <bits access="rw" name="chroma key enable" pos="16" rst="0x0">
          <comment>Enables the Chroma Keying</comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="chroma key mask" pos="19:17" rst="0x0">
          <comment>
            Allows a range of color for the Chroma Keying:
            <br/>
            000b: exact color match
            <br/>
            001b: disregard 1 LSBit of each color component for matching
            <br/>
            011b: disregard 2 LSBit of each color component for matching
            <br/>
            111b: disregard 3 LSBit of each color component for matching
          </comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="alpha" pos="27:20" rst="0x0">
          <comment>Layer Alpha blending coefficient</comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="rotation" pos="29:28" rst="0x0">
          <comment>
            Layer rotation selection
            <br/>
            00b: No rotation
            <br/>
            01b: 90  degrees rotation (clockwise)
            <br/>
            10b: reserved
            <br/>
            11b: reserved
          </comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="depth" pos="31:30" rst="0x0">
          <comment>
            Layer depth
            <br/>
            00b: Video layer behind all Overlay layers
            <br/>
            01b: Video layer between Overlay layers 1 and 0
            <br/>
            10b: Video layer between Overlay layers 2 and 1
            <br/>
            11b: Video layer on top of all Overlay layers
          </comment>
          <options>
            <mask/>
          </options>
        </bits>
      </reg>
      <reg name="gd_vl_y_src" protect="rw">
        <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
          <comment>Dword-aligned address of the Y component (or RGB) of the source image</comment>
        </bits>
      </reg>
      <reg name="gd_vl_u_src" protect="rw">
        <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
          <comment>Dword-aligned address of the U component of the source image</comment>
        </bits>
      </reg>
      <reg name="gd_vl_v_src" protect="rw">
        <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
          <comment>Dword-aligned address of the V component of the source image</comment>
        </bits>
      </reg>
      <reg name="gd_vl_resc_ratio" protect="rw">
        <bits access="rw" name="xpitch" pos="GD_FIXEDPOINT_SIZE-1:0" rst="0x0">
          <comment>Video layer rescaling ratio upon x-axis. This is a 2.8 fixed point number representing the input/output width ratio.</comment>
        </bits>
        <bits access="rw" name="ypitch" pos="GD_FIXEDPOINT_SIZE+15:16" rst="0x0">
          <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
        </bits>
        <bits access="w" name="pre_fetch_en" pos="29" rst="0x0">
          <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
        </bits>
        <bits access="rw" name="iy_dctenable" pos="30" rst="0x0">
          <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
        </bits>
        <bits access="rw" name="ypitch_scale_enable" pos="31" rst="0x0">
          <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
        </bits>
      </reg>
      <struct count="3" name="overlay_layer">
        <comment>The Overlay layers have a fixed depth relative to their index. Overlay layer 0 is the first to be drawn (thus the deepest), overlay layer 2 is the last to be drawn.</comment>
        <reg name="gd_ol_input_fmt" protect="rw">
          <bits access="rw" name="format" pos="1:0" rst="0x0">
            <comment>
              Input image format
              <br/>
              0: RGB565 pixel packed
              <br/>
              1: ARGB8888 pixel packed
              <br/>
              others: reserved
            </comment>
          </bits>
          <bits access="rw" name="stride" pos="GD_NB_BITS_STRIDE+1:2" rst="0x0">
            <comment>
              Image stride in 16-bits word.
              <br/>
              This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
            </comment>
          </bits>
          <bits access="rw" name="prefetch" pos="18" rst="0x1">
            <comment>
              Image stride in 16-bits word.
              <br/>
              This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
            </comment>
          </bits>
          <bits access="rw" name="active" pos="31" rst="0x0">
            <comment>
              Defines Layer's activity:
              <br/>
              0: Layer disabled
              <br/>
              1: Layer active
            </comment>
          </bits>
        </reg>
        <reg name="gd_ol_tl_ppos" protect="rw">
          <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
            <comment>Overlay Layer (layer X+1) Top-Left pixel x-axis position</comment>
          </bits>
          <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
            <comment>Overlay Layer (layer X+1) Top-Left pixel y-axis position</comment>
          </bits>
        </reg>
        <reg name="gd_ol_br_ppos" protect="rw">
          <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
            <comment>Overlay Layer (layer X+1) Bottom-Right pixel x-axis position</comment>
          </bits>
          <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
            <comment>Overlay Layer (layer X+1) Bottom-Right pixel y-axis position</comment>
          </bits>
        </reg>
        <reg name="gd_ol_blend_opt" protect="rw">
          <bits access="rw" name="chroma key b" pos="4:0" rst="0x0">
            <comment>Blue component of the Chroma Key</comment>
          </bits>
          <bits access="rw" name="chroma key g" pos="10:5" rst="0x0">
            <comment>Green component of the Chroma Key</comment>
          </bits>
          <bits access="rw" name="chroma key r" pos="15:11" rst="0x0">
            <comment>Red component of the Chroma Key</comment>
          </bits>
          <bitgroup name="chroma key color">
            <entry ref="chroma key b"/>
            <entry ref="chroma key g"/>
            <entry ref="chroma key r"/>
          </bitgroup>
          <bits access="rw" name="chroma key enable" pos="16" rst="0x0">
            <comment>Enables the Chroma Keying</comment>
          </bits>
          <bits access="rw" name="chroma key mask" pos="19:17" rst="0x0">
            <comment>
              Allows a range of color for the Chroma Keying:
              <br/>
              000b: exact color match
              <br/>
              001b: disregard 1 LSBit of each color component for matching
              <br/>
              011b: disregard 2 LSBit of each color component for matching
              <br/>
              111b: disregard 3 LSBit of each color component for matching
            </comment>
          </bits>
          <bits access="rw" name="alpha" pos="27:20" rst="0x0">
            <comment>Layer Alpha blending coefficient</comment>
          </bits>
        </reg>
        <reg name="gd_ol_rgb_src" protect="rw">
          <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
            <comment>Dword-aligned address of the source image</comment>
          </bits>
        </reg>
      </struct>
      <reg name="gd_lcd_ctrl" protect="rw">
        <bits access="rw" name="destination" pos="1:0" rst="0x0">
          <comment>Destination Selection</comment>
          <options>
            <option name="LCD CS 0" value="0"/>
            <option name="LCD CS 1" value="1"/>
            <option name="Memory LCD type" value="2"/>
            <option name="Memory RAM" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="output format" pos="6:4" rst="0x0">
          <comment>
            Output format
            <br/>
            000b:  8-bit - RGB3:3:2 - 1cycle/1pixel - RRRGGGBB
            <br/>
            001b:  8-bit - RGB4:4:4 - 3cycle/2pixel - RRRRGGGG/BBBBRRRR/GGGGBBBB
            <br/>
            010b:  8-bit - RGB5:6:5 - 2cycle/1pixel - RRRRRGGG/GGGBBBBB
            <br/>
            011b:  reserved
            <br/>
            100b: 16-bit - RGB3:3:2 - 1cycle/2pixel - RRRGGGBBRRRGGGBB
            <br/>
            101b: 16-bit - RGB4:4:4 - 1cycle/1pixel - XXXXRRRRGGGGBBBB
            <br/>
            110b: 16-bit - RGB5:6:5 - 1cycle/1pixel - RRRRRGGGGGGBBBBB
            <br/>
            111b: 32-bit - RGB5:6:5 - 1cycle/2pixel - RRRRRGGGGGGBBBBB/RRRRRGGGGGGBBBBB
            <br/>
            <br/>
             The MSB select also the AHB access size (8-bit or 16-bit) when Memory destination is selected.
            <br/>
             Must set to RGB565 when RAM type destination selected
          </comment>
          <options>
            <option name="8-bit;RGB332" value="0"/>
            <option name="8-bit;RGB444" value="1"/>
            <option name="8-bit;RGB565" value="2"/>
            <option name="16-bit;RGB332" value="4"/>
            <option name="16-bit;RGB444" value="5"/>
            <option name="16-bit;RGB565" value="6"/>
          </options>
        </bits>
        <bits access="rw" name="high byte" pos="7" rst="0x0">
    </bits>
        <bits access="rw" name="cs0 polarity" pos="8" rst="0x0">
          <comment>
            Change Polarity of CS0 signal
            <br/>
             0: no change
            <br/>
             1: Inverted
          </comment>
        </bits>
        <bits access="rw" name="cs1 polarity" pos="9" rst="0x0">
          <comment>
            Change Polarity of CS1 signal
            <br/>
             0: no change
            <br/>
             1: Inverted
          </comment>
        </bits>
        <bits access="rw" name="rs polarity" pos="10" rst="0x0">
          <comment>
            Change Polarity of RS signal
            <br/>
             0: no change
            <br/>
             1: Inverted
          </comment>
        </bits>
        <bits access="rw" name="wr polarity" pos="11" rst="0x0">
          <comment>
            Change Polarity of WR signal
            <br/>
             0: no change
            <br/>
             1: Inverted
          </comment>
        </bits>
        <bits access="rw" name="rd polarity" pos="12" rst="0x0">
          <comment>
            Change Polarity of RD signal
            <br/>
             0: no change
            <br/>
             1: Inverted
          </comment>
        </bits>
        <bits access="rw" name="nb command" pos="21:16" rst="0x0">
          <comment>Number of command to be send to the LCD command (up to 31)</comment>
        </bits>
        <bits access="w" name="start command" pos="24" rst="0x0">
          <comment>Start command transfer only. Autoreset</comment>
        </bits>
        <bits access="rw" name="lcd resetb" pos="25" rst="0x1">
          <comment>LCD reset signal. Low active</comment>
        </bits>
      </reg>
      <reg name="gd_lcd_timing" protect="rw">
        <comment>All value are in cycle number of system clock</comment>
        <bits access="rw" name="tas" pos="2:0" rst="0x0">
          <comment>Address setup time (RS to WR, RS to RD)</comment>
        </bits>
        <bits access="rw" name="tah" pos="6:4" rst="0x0">
          <comment>Adress hold time</comment>
        </bits>
        <bits access="rw" name="pwl" pos="13:8" rst="0x0">
          <comment>Pulse Width Low level, between 2 and 63.</comment>
        </bits>
        <bits access="rw" name="pwh" pos="21:16" rst="0x0">
          <comment>Pulse Width High level, between 2 and 63 (must be &gt; (TAH+TAS) ).</comment>
        </bits>
      </reg>
      <reg name="gd_lcd_mem_address" protect="rw">
        <bits access="rw" name="addr_dst" pos="NB_BITS_ADDR-1:2" rst="all0">
          <comment>
            Address destination pointer when memory destination is selected.
            <br/>
            The addr_dst[1] which correspond to the M_A[0] on the memory interface is used to select between command/data.
          </comment>
        </bits>
      </reg>
      <reg name="gd_lcd_stride_offset" protect="rw">
        <bits access="rw" name="stride_offset" pos="9:0" rst="all0">
          <comment>
            Address offset (in Bytes) skipped at the end of each line when memory destination is selected.
            <br/>
            This 2D feature allows for in-memory image compositing.
          </comment>
        </bits>
      </reg>
      <reg name="gd_lcd_single_access" protect="rw">
        <bits access="rw" name="lcd_data" pos="15:0" rst="all0">
          <comment>data to write or data readen (the readen data is ready when the lcd is not busy)</comment>
        </bits>
        <bits access="rw" name="type" pos="16" rst="0x0">
          <comment>
            Acesss type selection
            <br/>
            0: Command
            <br/>
            1: Data
          </comment>
        </bits>
        <bits access="w" name="start_write" pos="17" rst="0x0">
          <comment>Start a single write access. Autoreset</comment>
        </bits>
        <bits access="w" name="start_read" pos="18" rst="0x0">
          <comment>Start a single read access (only when LCD output selected). Autoreset.</comment>
        </bits>
      </reg>
      <reg name="gd_spilcd_config" protect="rw">
        <bits access="rw" name="spi_lcd_select" pos="0" rst="0"> </bits>
        <bits access="rw" name="spi_device_id" pos="6:1" rst="all0">
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="spi_clk_divider" pos="14:7" rst="0a">
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="spi_dummy_cycle" pos="17:15" rst="all0">
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="spi_line" pos="19:18" rst="all0">
          <comment>0:4 line mode
                   1:3 line mode
                   2:command mode
                   3:3 line 2 lane mode tx</comment>
          <options>
            <mask/>
            <option name="4" value="0"/>
            <option name="3" value="1"/>
            <option name="4_Start_Byte" value="2"/>
            <option name="3_Two_Lane" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="spi_rx_byte" pos="22:20" rst="all0">
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="spi_rw" pos="23" rst="0">
          <options>
            <option name="Write" value="0"/>
            <option name="Read" value="1"/>
          </options>
        </bits>
      </reg>
      <reg name="gd_spilcd_rd" protect="r">
        <comment/>
      </reg>
      <reg name="gd_vl_fix_ratio" protect="rw">
        <bits access="rw" name="reg_vl_only_sel" pos="19" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="mirror" pos="18" rst="0x0">
          <comment>Mirror enable.</comment>
        </bits>
        <bits access="rw" name="l_yfixen" pos="17" rst="0x0">
          <comment>.</comment>
        </bits>
        <bits access="rw" name="l_xfixen" pos="16" rst="0x0">
          <comment>.</comment>
        </bits>
        <bits access="rw" name="l_yratio" pos="15:8" rst="0x0">
          <comment>.</comment>
        </bits>
        <bits access="rw" name="l_xratio" pos="7:0" rst="0x0">
          <comment>.</comment>
        </bits>
      </reg>
      <hole size="(80-38-1)*32"/>
      <reg name="tecon" protect="rw">
        <bits access="rw" name="te_count2" pos="27:16" rst="0x0">
          <comment>Count value to detect vsync pulse</comment>
        </bits>
        <bits access="rw" name="te_mode" pos="2" rst="0x0">
          <comment>0:vsync te only 1:vsync and hsync te</comment>
        </bits>
        <bits access="rw" name="te_edge_sel" pos="1" rst="0x0">
          <comment>Pol select</comment>
        </bits>
        <bits access="rw" name="te_en" pos="0" rst="0x0">
          <comment>Te enable.</comment>
        </bits>
      </reg>
      <reg name="tecon2" protect="rw">
        <bits access="rw" name="te_count1" pos="28:0" rst="0x0">
          <comment>Te counter value</comment>
        </bits>
      </reg>
      <hole size="(256-81-1)*32"/>
    </module>
    <module category="System" name="GOUDA_SRAM">
      <var name="GD_NB_WORKBUF_WORDS" value="5856"/>
      <var name="GD_NB_LCD_CMD_WORDS" value="64"/>
      <var name="GD_SRAM_SIZE" value="(GD_NB_WORKBUF_WORDS+GD_NB_LCD_CMD_WORDS)*2"/>
      <var name="GD_SRAM_ADDR_WIDTH" value="13"/>
      <memory name="sram_array" size="GD_SRAM_SIZE">
        <comment>Gouda internal Sram space</comment>
      </memory>
    </module>
    <instance address="0x04804000" name="GOUDA" type="GOUDA"/>
  </archive>
  <archive relative="i2c_master.xml">
    <module category="Periph" name="I2C_MASTER">
      <reg name="ctrl" protect="rw">
        <bits access="rw" name="en" pos="0" rst="0">
          <comment>I2C master enable, high active.</comment>
        </bits>
        <bits access="rw" name="irq_mask" pos="8" rst="0">
          <comment>I2C master interrupt enable, high active.</comment>
        </bits>
        <bits access="rw" name="clock_prescale" pos="31:16" rst="0xFFFF">
          <comment>
            This register is used to prescale the SCL clock line. Due to the structure of I2C interface, this module uses a 5*SCL clock frequency. Clock_Prescale must be programmed to this 5*SCL clock frequency (minus 1). Change the value of Clock_Prescale only when bit EN is cleared.
            <br/>
            <br/>
             Example:
            <br/>
             PCLK_MOD is 52 MHz, desired SCL is 100 KHz.
            <br/>
             Prescale = 52MHz / (5 * 100KHz) -1 = 103.
          </comment>
          <options>
            <mask/>
          </options>
        </bits>
      </reg>
      <reg name="status" protect="r">
        <bits access="r" name="irq_cause" pos="0" rst="0">
          <comment>IRQ Cause bit. This bit is set when one byte transfer has been completed or arbitration is lost, this bit is generated by bit IRQ_Status AND bit IRQ_MASK.</comment>
        </bits>
        <bits access="r" name="irq_status" pos="4" rst="0">
          <comment>IRQ status bit.</comment>
        </bits>
        <bits access="r" name="tip" pos="8" rst="0">
          <comment>TIP, Transfer in progress.
				'1' when transferring data. '0' when transfer complete.</comment>
        </bits>
        <bits access="r" name="al" pos="12" rst="0">
          <comment>AL,Arbitration lost.
				This bit is set when the I2C master lost arbitration.</comment>
        </bits>
        <bits access="r" name="busy" pos="16" rst="0">
          <comment>Busy,I2C bus busy.
				'1' after START signal detected.
				'0' after STOP signal detected.</comment>
        </bits>
        <bits access="r" name="rxack" pos="20" rst="0">
          <comment>RxACK, Received acknowledge from slave.
				'1'= &quot;No ACK&quot; received.
				'0'= ACK received.</comment>
        </bits>
      </reg>
      <reg name="txrx_buffer" protect="rw">
        <bits access="w" name="tx_data" pos="7:0" rst="-">
          <comment>
            Byte to transmit via I2C.
            <br/>
             for Bit 0, In case of a data transfer this bit represents the data's LSB. In case of a slave address transfer this bit represents the RW bit.
            <br/>
             '1' = reading from slave.
            <br/>
             '0' = writing to slave.
          </comment>
        </bits>
        <bits access="r" name="rx_data" pos="7:0" rst="-">
          <comment>Last byte received via I2C.</comment>
        </bits>
      </reg>
      <reg name="cmd" protect="w">
        <bits access="w" name="ack" pos="0" rst="0">
          <comment>ACK,when master works as a receiver,sent ACK(ACK='0') or NACK(ACK='1').</comment>
        </bits>
        <bits access="w" name="rd" pos="4" rst="0">
          <comment>RD,read from slave, this bit is auto cleared.</comment>
        </bits>
        <bits access="w" name="sto" pos="8" rst="0">
          <comment>STO,generate stop condition, this bit is auto cleared.</comment>
        </bits>
        <bits access="w" name="rw" pos="12" rst="0">
          <comment>WR,write to slave, this bit is auto cleared.</comment>
        </bits>
        <bits access="w" name="sta" pos="16" rst="0">
          <comment>STA,generate (repeated) start condition, this bit is auto cleared.</comment>
        </bits>
      </reg>
      <reg name="irq_clr" protect="rw">
        <bits access="c" name="irq_clr" pos="0" rst="0">
          <comment>When write '1', clears a pending I2C interrupt.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04807000" name="I2C_MASTER1" type="I2C_MASTER"/>
    <instance address="0x04808000" name="I2C_MASTER2" type="I2C_MASTER"/>
    <instance address="0x51504000" name="I2C_MASTER3" type="I2C_MASTER"/>
  </archive>
  <archive relative="lps_ifc.xml">
    <var name="LPS_NB_BITS_ADDR" value="32"/>
    <var name="LPS_IFC_ADDR_ALIGN" value="0"/>
    <var name="LPS_IFC_TC_LEN" value="23"/>
    <var name="LPS_IFC_STD_CHAN_NB" value="2"/>
    <var name="LPS_IFC_RFSPI_CHAN" value="0"/>
    <var name="LPS_IFC_AIF_CHAN" value="0"/>
    <var name="LPS_IFC_DBG_CHAN" value="0"/>
    <enum name="LPS_IFC_Request_IDs">
      <entry name="DMA_ID_TX_UART1"/>
      <entry name="DMA_ID_RX_UART1"/>
    </enum>
    <module category="System" name="LPS_IFC">
      <reg name="get_ch" protect="--">
        <bits access="r" name="ch_to_use" pos="4:0" rst="0">
          <comment>
            This field indicates which standard channel to use.
            <br/>
             Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
            <br/>
             After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
            <br/>
            Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
            <br/>
            Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
            <br/>
            When non-secure cpu read this register, the return value will automatic exlude the secure channel.
            <br/>
            00000 = use Channel0
            <br/>
            00001 = use Channel1
            <br/>
            00010 = use Channel2
            <br/>
             ...
            <br/>
            01111 = use Channel15
            <br/>
            11111 = all channels are busy
          </comment>
          <options>
            <mask/>
            <shift/>
            <default/>
          </options>
        </bits>
      </reg>
      <reg name="dma_status" protect="r">
        <bits access="r" name="ch_enable" pos="LPS_IFC_STD_CHAN_NB+LPS_IFC_RFSPI_CHAN-1:0" rst="0">
          <comment>
            This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels disabled
            <br/>
            0000_0001 = Ch0 enabled
            <br/>
            0000_0010 = Ch1 enabled
            <br/>
            0000_0100 = Ch2 enabled
            <br/>
            0000_0101 = Ch0 and Ch2 enabled
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 enabled
            <br/>
            all 1     = all channels enabled
          </comment>
        </bits>
        <bits access="r" name="ch_busy" pos="LPS_IFC_STD_CHAN_NB-1+16:16" rst="0">
          <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
        </bits>
      </reg>
      <reg name="debug_status" protect="r">
        <bits access="r" name="dbg_status" pos="0" rst="1">
          <comment>
            Debug Channel Status .
            <br/>
            0= The debug channel is running
      (not idle)
            <br/>
            1= The debug channel is in idle mode
          </comment>
        </bits>
      </reg>
      <reg name="ifc_sec" protect="rw">
        <bits access="rw" name="std_ch_reg_sec" pos="LPS_IFC_STD_CHAN_NB-1:0" rst="0">
          <comment>
            This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels registers can be accessed by secure master or non-secure master.
            <br/>
            0000_0001 = Ch0 registers can only be accessed by secure master.
            <br/>
            0000_0010 = Ch1 registers can only be accessed by secure master.
            <br/>
            0000_0100 = Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels registers can only be accessed by secure master.
          </comment>
        </bits>
        <bits access="rw" name="std_ch_dma_sec" pos="LPS_IFC_STD_CHAN_NB-1+16:16" rst="all1">
          <comment>
            This register indicates which channel dma is secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels dma are non-secure master.
            <br/>
            0000_0001 = Ch0 dma is secure master.
            <br/>
            0000_0010 = Ch1 dma is secure master.
            <br/>
            0000_0100 = Ch2 dma is secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 dma are secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels dma are secure master.
          </comment>
        </bits>
      </reg>
      <struct count="LPS_IFC_STD_CHAN_NB" name="std_ch">
        <reg name="control" protect="rw">
          <bits access="w" name="enable" pos="0" rst="no">
            <comment>
              Channel Enable, write one in this bit enable the channel.
              <br/>
              When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer.
            </comment>
          </bits>
          <bits access="w" name="disable" pos="1" rst="no">
            <comment>
              Channel Disable, write one in this bit disable the channel.
              <br/>
              When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled.
            </comment>
          </bits>
          <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
            <comment>
              Exchange the read data from fifo halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
            <comment>
              Exchange the write data to fifo  halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="autodisable" pos="4" rst="1">
            <comment>
              Set Auto-disable mode
              <br/>
               0 = when TC reach zero the
        channel is not automatically released.
              <br/>
               1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.
            </comment>
          </bits>
          <bits access="rw" name="size" pos="5" rst="0">
            <comment>
              Peripheral Size
              <br/>
               0= 8-bit peripheral
              <br/>
               1= 32-bit peripheral
            </comment>
          </bits>
          <bits access="rw" display="hex" name="req_src" pos="12:8" rst="0x1F">
            <options linkenum="LPS_IFC_Request_IDs">
              <shift/>
              <mask/>
              <default/>
            </options>
            <comment>Select DMA Request source</comment>
          </bits>
          <bits access="rw" name="flush" pos="16" rst="0">
            <comment>
              When one, flush the internal FIFO channel.
              <br/>
              This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel.
              <br/>
               Before writting back this bit to zero the internal fifo must empty.
            </comment>
          </bits>
          <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
            <comment>
              Set the MAX burst length for channel 0,1.
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.
              <br/>
               The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4.
              <br/>
               .
            </comment>
          </bits>
        </reg>
        <reg name="status" protect="r">
          <bits access="r" name="enable" pos="0" rst="0">
            <comment>Enable bit, when '1' the channel is running</comment>
          </bits>
          <bits access="r" name="fifo_empty" pos="4" rst="1">
            <comment>The internal channel fifo is empty</comment>
          </bits>
        </reg>
        <reg name="start_addr" protect="rw">
          <bits access="rw" display="hex" name="start_addr" pos="LPS_NB_BITS_ADDR-1:LPS_IFC_ADDR_ALIGN" rst="0xFFFFFFF">
            <comment>
              AHB Address. This field represent the start address of the
        transfer.
              <br/>
              For a 32-bit peripheral, this address must be aligned 32-bit.
            </comment>
          </bits>
        </reg>
        <reg name="tc" protect="rw">
          <bits access="rw" display="hex" name="tc" pos="LPS_IFC_TC_LEN-1:0" rst="0xFFFFFF">
            <comment>
              Transfer Count, this field indicated the transfer size in bytes to perform.
              <br/>
              During a transfer a write in this register add the new value to the current TC.
              <br/>
              A read of this register return the current current transfer count.
            </comment>
          </bits>
        </reg>
        <reg name="tc_threshold" protect="rw">
          <bits access="rw" display="hex" name="tc_threshold" pos="LPS_IFC_TC_LEN-1:0" rst="0x0">
            <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.</comment>
          </bits>
        </reg>
      </struct>
    </module>
    <instance address="0x5170e000" name="LPS_IFC" type="LPS_IFC"/>
  </archive>
  <archive relative="lzma.xml">
    <module category="System" name="LZMA">
      <reg name="lzma_cmd_reg" protect="rw">
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>Writing 1 starts block decode</comment>
        </bits>
      </reg>
      <reg name="lzma_status_reg" protect="rw">
        <bits access="rw" name="axi_err" pos="2" rst="0">
          <comment>AXI bus error flag. Reading 1 indicates AXI bus operation fails and Lzma should be reset.</comment>
        </bits>
        <bits access="rw" name="dec_err" pos="1" rst="0">
          <comment>Decode error flag. Reading 1 indicates block decode error and Lzma should be reset.</comment>
        </bits>
        <bits access="rw" name="dec_done" pos="0" rst="0">
          <comment>Decode done flag. Reading 1 indicates block decode done, writing 1 clears.</comment>
        </bits>
      </reg>
      <reg name="lzma_irq_mask" protect="rw">
        <bits access="rw" name="axi_errirqmask" pos="2" rst="0">
          <comment>Writing 1 indicates a interrupt will be generated when lzma_status_reg[2]=1</comment>
        </bits>
        <bits access="rw" name="dec_errirqmask" pos="1" rst="0">
          <comment>Writing 1 indicates a interrupt will be generated when lzma_status_reg[1]=1</comment>
        </bits>
        <bits access="rw" name="dec_doneirqmask" pos="0" rst="0">
          <comment>Writing 1 indicates a interrupt will be generated when lzma_status_reg[0]=1</comment>
        </bits>
      </reg>
      <reg name="reserve0" protect="r">
        <comment>not used</comment>
      </reg>
      <reg name="lzma_config_reg1" protect="rw">
        <bits access="rw" name="reg_dict_size" pos="29:17" rst="0">
          <comment>Lzma dictionary size in byte</comment>
        </bits>
        <bits access="rw" name="reg_block_size" pos="16:0" rst="0">
          <comment>lzma block size in byte</comment>
        </bits>
      </reg>
      <reg name="lzma_config_reg2" protect="rw">
        <bits access="rw" name="reg_stream_len" pos="16:0" rst="0">
          <comment>lzma zip stream lenght in byte</comment>
        </bits>
      </reg>
      <reg name="lzma_config_reg3" protect="rw">
        <bits access="rw" name="reg_refbyte_en" pos="2" rst="0">
          <comment>1: refbyte enable; 0: refbyte disable</comment>
        </bits>
        <bits access="rw" name="reg_cabac_movebits" pos="1" rst="0">
          <comment>1: cabac_movebits=5; 0: cabac_movebits=4</comment>
        </bits>
        <bits access="rw" name="reg_cabac_totalbits" pos="0" rst="0">
          <comment>1: cabac_totalbits=11; 0: cabac_totalbits=10</comment>
        </bits>
      </reg>
      <reg name="lzma_status_reg2" protect="r">
        <bits access="r" name="stream_byte_pos" pos="16:0" rst="0">
          <comment>current decoding byte position in zip stream</comment>
        </bits>
      </reg>
      <reg name="lzma_status_reg3" protect="r">
        <bits access="r" name="dict_byte_pos" pos="16:0" rst="0">
          <comment>current recovering byte position in dictionary</comment>
        </bits>
      </reg>
      <reg name="lzma_error_type" protect="r">
        <bits access="r" name="inbuf_underflow" pos="6" rst="0">
          <comment>Equals to 1 when block decode finishes with zip stream reading byte position less than (reg_stream_len-2)</comment>
        </bits>
        <bits access="r" name="outbuf_overflow" pos="5" rst="0">
          <comment>Equals to 1 when block decode finishes with block buffer writing byte position exceeds the block size</comment>
        </bits>
        <bits access="r" name="symbol_len_err" pos="4" rst="0">
          <comment>Equals to 1 when a symbol is decoded as match type with length more than 273</comment>
        </bits>
        <bits access="r" name="symbol_reps_err0" pos="3" rst="0">
          <comment>Equals to 1 when a symbol is decoded as match type with reps0 more than dictionary size</comment>
        </bits>
        <bits access="r" name="symbol_reps_err1" pos="2" rst="0">
          <comment>Equals to 1 when a symbol is decoded as match type with reps0 more than dictionary recovery byte postion</comment>
        </bits>
        <bits access="r" name="symbol_type_err" pos="1" rst="0">
          <comment>Equals to 1 when first symbol in a block is decoded as match type</comment>
        </bits>
        <bits access="r" name="inbuf_overflow" pos="0" rst="0">
          <comment>Equals to 1 when zip stream reading byte position exceeds the stream length</comment>
        </bits>
      </reg>
      <reg name="reserve1" protect="r">
        <comment>not used</comment>
      </reg>
      <reg name="reserve2" protect="r">
        <comment>not used</comment>
      </reg>
      <reg name="lzma_input_crc" protect="r">
        <comment>Crc of lzma rdma read bytes</comment>
      </reg>
      <reg name="lzma_output_crc" protect="r">
        <comment>Crc of lzma wdma write bytes</comment>
      </reg>
      <reg name="reserve3" protect="r">
        <comment>not used</comment>
      </reg>
      <reg name="reserve4" protect="r">
        <comment>not used</comment>
      </reg>
      <reg name="lzma_dma_raddr_reg" protect="rw">
        <comment>Base address of lzma rdma</comment>
      </reg>
      <reg name="lzma_dma_waddr_reg" protect="rw">
        <comment>Base address of lzma wdma</comment>
      </reg>
      <reg name="lzma_inbuf_rwmargin_reg" protect="rw">
        <bits access="rw" name="inbuf_rwmargin_reg" pos="5:0" rst="10">
          <comment>Set the margin between input_buf wrptr and rdptr for pending the decode process</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04800000" name="LZMA" type="LZMA"/>
  </archive>
  <archive relative="rtc_timer.xml">
    <module category="System" name="RTC_TIMER">
      <reg name="ctrl" protect="rw">
        <bits access="rc" name="load_value" pos="6" rst="0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="rc" name="data_valid_clr" pos="5" rst="0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="r" name="data_valid" pos="4" rst="0">
      </bits>
        <bits access="rc" name="read_lock" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="rw" name="wrap_int_enable" pos="2" rst="0">
      </bits>
        <bits access="rw" name="alarm_enable" pos="1" rst="0">
      </bits>
        <bits access="rw" name="timer_enable" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="cur_val_l" protect="r">
        <bits access="r" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="cur_val_m" protect="r">
        <bits access="r" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="cur_val_h" protect="r">
        <bits access="r" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="alarm_val_l" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="alarm_val_m" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="alarm_val_h" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="load_val_l" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="load_val_m" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="load_val_h" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="int_mask" protect="rw">
        <bits access="rw" name="alarm" pos="1" rst="0">
      </bits>
        <bits access="rw" name="wrap" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="int_clr" protect="rw">
        <bits access="rc" name="alarm" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="rc" name="wrap" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
      </reg>
      <reg name="int_status" protect="r">
        <bits access="r" name="alarm" pos="1" rst="0">
      </bits>
        <bits access="r" name="wrap" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="int_cause" protect="r">
        <bits access="r" name="alarm" pos="1" rst="0">
      </bits>
        <bits access="r" name="wrap" pos="0" rst="0">
      </bits>
      </reg>
    </module>
    <instance address="0x51708000" name="RTC_TIMER" type="RTC_TIMER"/>
  </archive>
  <archive relative="sci.xml">
    <module category="Periph" name="SCI">
      <reg name="sci_config" protect="rw">
        <bits access="rw" name="enable" pos="0" rst="0">
          <comment>Enables the SIM Card IF module</comment>
        </bits>
        <bits access="rw" name="parity" pos="1" rst="0">
          <comment>Selects the parity generation/detection</comment>
          <options>
            <option name="Even_parity" value="0"/>
            <option name="Odd_parity" value="1"/>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="perf" pos="2" rst="0">
          <comment>
            Parity Error Receive Feed-through
            <br/>
            0 = Don't store bytes with detected parity errors
            <br/>
            1 = Feed-through bytes with detected parity errors
          </comment>
        </bits>
        <bits access="rw" name="filter_disable" pos="3" rst="0">
          <comment>
            Enable or disable NULL (0x60) character filtering when SIM card sends NULL to reset WWT timer.
            <br/>
            0 = Enable NULL character filtering, NULL characters are not reported if not data.
            <br/>
            1 = Disable NULL character filtering.  NULL characters (0x60) are transferred to the SCI data buffer.
          </comment>
        </bits>
        <bits access="rw" name="clockstop" pos="4" rst="1">
          <comment>
            Manual SCI Clock Stop control.  Manually starts and stops the SCI clock.  This bit must be set to '1' when Autostop mode is enabled.
            <br/>
            0 = Enable the SCI clock
            <br/>
            1 = Disable SCI clock
          </comment>
        </bits>
        <bits access="rw" name="autostop_en_h" pos="5" rst="0">
          <comment>
            Enables automatic clock shutdown when command is complete.  Enabling this will generate the necessary startup and shutdown delays required by the SIM protocol.
            <br/>
            0 = Auto clock control not enabled.  SCI clock controlled by SCI_Clockstop bit
            <br/>
            1 = Auto clock control enabled.
          </comment>
        </bits>
        <bits access="rw" name="msbh_lsbl" pos="6" rst="1">
          <comment>
            Sets the transmission and reception bit order:
            <br/>
            0 = LSB is sent/recieved first (Direct convention)
            <br/>
            1 = MSB is sent/received first (Inverse convention)
          </comment>
        </bits>
        <bits access="rw" name="lli" pos="7" rst="1">
          <comment>
            Logic Level Invert:
            <br/>
            0 = Logic level 0 data is sent/received as '0' or 'A' which is the same as the start bit.  (Direct convention)
            <br/>
            1 = Logic level 0 data is sent/received as '1' or 'Z' which is the opposite of the start bit.  (Inverse convention)
          </comment>
        </bits>
        <bits access="rw" name="pegen_len" pos="8" rst="0">
          <comment>
            Parity Error signal length.  This configuration bit can be used to extend the duration of the parity error signal generation from 1 ETU to 1.5 ETU
            <br/>
            0 = Parity Error signal duration is 1 ETU starting at 10.5 ETU
            <br/>
            1 = Parity Error signal duration is 1.5 ETU starting at 10.5 ETU
          </comment>
        </bits>
        <bits access="rw" name="parity_en" pos="9" rst="0">
          <comment>
            Enable or disable parity error checking on the receive data
            <br/>
            0 = Disable parity error checking
            <br/>
            1 = Enable parity error checking
          </comment>
        </bits>
        <bits access="rw" name="stop_level" pos="10" rst="1">
          <comment>
            Logical value of the clock signal when SCI clock is stopped (either due to automatic shutdown or manual shutdown)
            <br/>
            0 = Stop clock at low level
            <br/>
            1 = Stop clock at high level
          </comment>
        </bits>
        <bits access="rw" name="arg_h" pos="16" rst="0">
          <comment>Automatic Reset Generator.  Write a '1' to this bit to initiate an automatic reset procedure on the SIM.  Write '0' to switch back to SCI_Reset control (bit 20).  An ARG interrupt will be generated if the ARG process succeeded or failed.  The ARG status bit (ARG_Det) must be read to determine if a reset response from the card was detected.  This bit needs to be cleared between ARG attempts.</comment>
        </bits>
        <bits access="rw" name="afd_en_h" pos="17" rst="0">
          <comment>
            Automatic format detection.  This bit is generally set in conjunction with the ARG_H bit to enable automatic detection of the data convention.
            <br/>
            1 = Enable TS detection and automatic convention settings programming
            <br/>
            0 = disable automatic settings and use the register bits (MSBH_LSBL and LLI) to control the convention
          </comment>
        </bits>
        <bits access="rw" name="tx_resend_en_h" pos="18" rst="1">
          <comment>
            1 = Enable automatic resend of characters when Tx parity error is detected
            <br/>
            0 = Disable automatic resend
          </comment>
        </bits>
        <bits access="rw" name="reset" pos="20" rst="0">
          <comment>
            Direct connection to the SIM card reset pin.  This is overridden when ARG_H is enabled
            <br/>
            0 = SCI_Reset low voltage
            <br/>
            1 = SCI Reset high voltage
          </comment>
        </bits>
        <bits access="rw" name="dly_sel" pos="21" rst="0">
          <comment>
            This selects between two delay times for the automatic clock stop startup and shutdown:
            <br/>
            0 = short delay
            <br/>
            Startup/Shutdown : 744 SCI clocks / 1860 SCI clocks
            <br/>
            1 = long delay
            <br/>
            Startup/Shutdown : (2 x 744) SCI clocks / (2 x 1860) SCI clocks
          </comment>
        </bits>
        <bits access="rw" name="in_avg_en" pos="22" rst="1">
          <comment>
            Input data average enable.
            <br/>
            0 = Disable
            <br/>
            1 = Enable
          </comment>
        </bits>
        <bits access="rw" name="par_chk_offset" pos="29:24" rst="0xe">
          <comment>Allows fine control of the parity check position during the parity error time period.</comment>
        </bits>
      </reg>
      <reg name="status" protect="r">
        <bits access="r" name="rxdata_rdy" pos="0" rst="0">
          <comment>
            Returns the status of the Rx FIFO:
            <br/>
            0 = Rx FIFO empty
            <br/>
            1 = There is at least 1 character in the Rx FIFO
          </comment>
        </bits>
        <bits access="r" name="tx_fifo_rdy" pos="1" rst="1">
          <comment>
            Returns the status of the Tx FIFO:
            <br/>
            0 = Tx FIFO is full
            <br/>
            1 = There is at least 1 free spot in the Tx FIFO
          </comment>
        </bits>
        <bits access="r" name="format_det" pos="2" rst="0">
          <comment>
            Returns the status of the automatic format detection after reset:
            <br/>
            0 = TS character has not been detected in the ATR
            <br/>
            1 = TS character has been detected and SCI module is using the automatic convention settings
            <br/>
            <br/>
            This bit is cleared when the AFD_En bit is cleared
          </comment>
        </bits>
        <bits access="r" name="arg_det" pos="3" rst="0">
          <comment>
            Returns the status of the automatic reset procedure:
            <br/>
            0 = ARG detection has failed
            <br/>
            1 = ARG detection has detected that the SIM has responded to the reset
            <br/>
            <br/>
            This bit is used in conjunction with the ARG interrupt.  The ARG interrupt will be generated at the successful or unsuccessful termination of the ARG process.  This bit can be used to determine the success or failure.
          </comment>
        </bits>
        <bits access="r" name="reset_det" pos="4" rst="0">
          <comment>This is the status of the Reset pin when automatic reset generation is enabled.  This bit can be used to discover whether the SIM card that has successfully responded to an ARG procedure has an active high or active low reset. (Det means 'Detection')</comment>
        </bits>
        <bits access="r" name="clk_rdy_h" pos="5" rst="0">
          <comment>
            Status of the control signal to the clock control module.  This bit respects the startup and shutdown phases, so during these times, the clock may actually be on, but it is not considered to be 'ready'
            <br/>
            0 = SCI clock may be on or off but is not ready for use
            <br/>
            1 = SCI clock is on and ready for use
          </comment>
        </bits>
        <bits access="r" name="clk_off" pos="6" rst="1">
          <comment>
            Status bit of the Sci clock.
            <br/>
            0 = Sci clock is ON
            <br/>
            1 = Sci clock is OFF
          </comment>
        </bits>
        <bits access="r" name="rx_err" pos="8" rst="0">
          <comment>A receive parity error was detected. Reading this register clears the bit.</comment>
        </bits>
        <bits access="r" name="tx_err" pos="9" rst="0">
          <comment>A transmit parity error was detected. Reading this register clears the bit.</comment>
        </bits>
        <bits access="r" name="rxoverflow" pos="10" rst="0">
          <comment>The internal receive FIFO has reached an overflow condition. Reading this register clears the bit.</comment>
        </bits>
        <bits access="r" name="txoverflow" pos="11" rst="0">
          <comment>The internal transmit FIFO has reached an overflow condition. Reading this register clears the bit.</comment>
        </bits>
        <bits access="r" name="autostop_state" pos="31:30" rst="0">
          <comment>Returns the state of the clock management state machine when AutoStop mode is enabled.  This value is '00' when manual mode is selected.</comment>
          <options>
            <option name="Startup_phase" value="0">
              <comment>Clock is on, but not ready to be used.</comment>
            </option>
            <option name="Auto_on" value="1">
              <comment>Clock is on and ready to be used</comment>
            </option>
            <option name="Shutdown_phase" value="2">
              <comment>Clock is still on, but should not be used.</comment>
            </option>
            <option name="Clock_off" value="3">
              <comment>Clock is off.</comment>
            </option>
            <mask/>
            <shift/>
          </options>
        </bits>
      </reg>
      <reg name="data" protect="--">
        <bits access="w" name="data_in" pos="7:0" rst="FF">
          <comment>Writing to this register will send the data to the SIM card. If automatic clock shutdown is enabled, the appropriate delay will be applied before the data is actually sent.</comment>
        </bits>
        <bits access="r" name="data_out" pos="7:0" rst="FF">
          <comment>Reading this register will read from the receive data FIFO.</comment>
        </bits>
      </reg>
      <reg name="clkdiv_reg" protect="rw">
        <bits access="rw" name="clkdiv" pos="8:0" rst="0x174">
          <comment>Clock divider for generating the baud clock from the SCI clock.  This value must match the value used by the SIM card whose default value is 0x174.</comment>
        </bits>
        <bits access="rw" name="baud_x8_en" pos="9" rst="0">
          <comment>
            Speed mode enable.
            <br/>
            0 = Low speed mode
            <br/>
            1 = High speed mode(372/32, 372/64, 512/64)
          </comment>
        </bits>
        <bits access="rw" name="rx_clk_cnt_limit" pos="14:10" rst="0x10">
          <comment>Rx_clk_cnt wrap value.</comment>
        </bits>
        <bits access="rw" name="clk_tst" pos="15" rst="0">
          </bits>
        <bits access="rw" name="clkdiv_16" pos="23:16" rst="0x16">
          <comment>Secondary clock divider for generating 16x baud clock.</comment>
        </bits>
        <bits access="rw" name="maindiv" pos="29:24" rst="0x4">
          <comment>
            Main clock divider to generate the SCI clock.  This value should be calculated as follows:
            <br/>
            MainDiv = Clk_Sys/(2xSCI_Clk) - 1
            <br/>
            where SCI_Clk is in the range of 3-5 MHz as specified in the SIM specification.
          </comment>
          <options>
            <mask/>
            <default/>
          </options>
        </bits>
        <bits access="rw" name="clk_out_inv" pos="30" rst="0">
          <comment>
            Inverts the polarity of the SCI clock to the SIM card only.
            <br/>
            0 = No inversion
            <br/>
            1 = Invert external SCI clock
          </comment>
        </bits>
        <bits access="rw" name="clk_inv" pos="31" rst="0">
          <comment>
            Inverts the polarity of the SCI clock to the SIM card and internal.
            <br/>
            0 = No inversion
            <br/>
            1 = Invert external SCI clock
          </comment>
        </bits>
      </reg>
      <reg name="rxcnt_reg" protect="rw">
        <bits access="rw" name="rxcnt" pos="9:0" rst="0">
          <comment>
            This value should be programmed with the number of expected characters to receive.  It will be decremented each time a character is
            <strong>actually</strong>
             received and should be 0 when the transfer is complete.  If a character is sent after the RxCnt reaches zero, the extra character flag will be set but this value will stay at zero.
          </comment>
        </bits>
        <bits access="rw" name="clk_persist" pos="31" rst="0">
          <comment>
            When in automatic clock shutdown mode, this bit can prevent the clock from entering shutdown mode when the transfer is complete.  This should be used for multi-transfer commands where the clock must not be shut down until the command is complete.  This bit must be programmed for each transfer.
            <br/>
            1 = Keep clock on
            <br/>
            0 = Allow clock shutdown when transfer is complete
          </comment>
        </bits>
      </reg>
      <reg name="times" protect="rw">
        <bits access="rw" name="chguard" pos="7:0" rst="1">
          <comment>This is the extra guard time that can be added to the 2 ETU minimum (and default) guard time between successive transmitted characters.  This should be programmed depending on the SIM's ATR.  The total ETU guard time will be ChGuard + 1.</comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="turnaroundguard" pos="11:8" rst="0x6">
          <comment>
            Turnaround guard time configuration.  This value can be used to adjust the delay between the leading edge of a received character and the leading edge of the next transmitted character.  The minimum time specified in the SIM recommendation is 16 ETU.  The number of ETUs can be calculated using the following formula:
            <br/>
            Total Turnaround Time (in ETUs) = 11 + TurnaroundGuard
          </comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="wi" pos="23:16" rst="0x0A">
          <comment>
            Work Waiting Time factor.  A timeout will be generated when the WWT is exceeded.  The WWT is calculated by:
            <br/>
                   WWT = 960 x WI x (F/Fi)
            <br/>
            where Fi is the main SCI clock frequency (3-5 MHz) and F is 372 before an enhanced PPS and 512 after an enhanced PPS.
            <br/>
            The SCI_WI value must be calculated as follows:
            <br/>
                   SCI_WI = WI * D
            <br/>
            Thus, by default (WI = 10) this value needs to be set to 10 before an EPPS, but needs to be scaled to WI*D=80 after the EPPS procedure.
          </comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="tx_pert" pos="31:24" rst="0xFF">
          <comment>Number of times to try resending character when the SIM indicates a parity error.</comment>
        </bits>
      </reg>
      <reg name="ch_filt_reg" protect="rw">
        <bits access="rw" name="ch_filt" pos="7:0" rst="0x60">
          <comment>
            Value of the character to be filtered.  0x60 is the NULL character in the SIM protocol.  If character filtering is enabled, the
            <strong>first</strong>
             0x60 character that is received by the SIM during a transfer will
            <strong>not</strong>
             be recorded.  The purpose of this character is to enable the SIM to reset the WWT counter when the SIM is not ready to send the data.  This filter has no effect on characters within the datastream.
          </comment>
        </bits>
      </reg>
      <reg name="dbg" protect="w">
        <bits access="w" name="fifo_rx_clr" pos="0" rst="0">
          <comment>Clear RX FIFO.</comment>
        </bits>
        <bits access="w" name="fifo_tx_clr" pos="1" rst="0">
          <comment>Clear TX FIFO.</comment>
        </bits>
        <comment>clear RX/TX FIFO</comment>
      </reg>
      <reg name="int_cause" protect="r">
        <bits access="r" name="rx_done" pos="0" rst="0">
          <comment>Number of expected Rx characters, as programmed in the RxCnt register, has been received.</comment>
        </bits>
        <bits access="r" name="rx_half" pos="1" rst="0">
          <comment>Receiver FIFO is half full.</comment>
        </bits>
        <bits access="r" name="wwt_timeout" pos="2" rst="0">
          <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.</comment>
        </bits>
        <bits access="r" name="extra_rx" pos="3" rst="0">
          <comment>An extra character has been received after the number of characters in RxCnt has been received.</comment>
        </bits>
        <bits access="r" name="resend_ovfl" pos="4" rst="0">
          <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the Tx_PERT field.</comment>
        </bits>
        <bits access="r" name="arg_end" pos="5" rst="0">
          <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.</comment>
        </bits>
        <bits access="r" name="sci_dma_tx_done" pos="6" rst="0">
          <comment>DMA tx done.</comment>
        </bits>
        <bits access="r" name="sci_dma_rx_done" pos="7" rst="0">
          <comment>DMA rx done.</comment>
        </bits>
        <comment>
          This register is a
          <b>READ ONLY</b>
           register that returns the logical
          <b>and</b>
           of the SCI_INT_STATUS register and the SCI_INT_MASK. If any of these bits is '1', the SCI module will generate an interrupt.  Bits 21:16 return the
          <u>status</u>
           of the interrupt which is the interrupt state before the mask is applied.  These bits should only be used for debugging.
        </comment>
      </reg>
      <reg name="int_clr" protect="rw">
        <bits access="c" name="rx_done" pos="0" rst="0">
          <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.</comment>
        </bits>
        <bits access="c" name="rx_half" pos="1" rst="0">
          <comment>Receiver FIFO is half full.</comment>
        </bits>
        <bits access="c" name="wwt_timeout" pos="2" rst="0">
          <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.</comment>
        </bits>
        <bits access="c" name="extra_rx" pos="3" rst="0">
          <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.</comment>
        </bits>
        <bits access="c" name="resend_ovfl" pos="4" rst="0">
          <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.</comment>
        </bits>
        <bits access="c" name="arg_end" pos="5" rst="0">
          <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.</comment>
        </bits>
        <bits access="c" name="sci_dma_tx_done" pos="6">
          <comment>DMA tx done.</comment>
        </bits>
        <bits access="c" name="sci_dma_rx_done" pos="7">
          <comment>DMA rx done.</comment>
        </bits>
        <comment>This is a WRITE ONLY register that is used to clear an SCI interrupt. Write a '1' to the interrupt that is to be cleared. Writing '0' has no effect.</comment>
      </reg>
      <reg name="int_mask" protect="rw">
        <bits access="rw" name="rx_done" pos="0" rst="0">
          <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.</comment>
        </bits>
        <bits access="rw" name="rx_half" pos="1" rst="0">
          <comment>Receiver FIFO is half full.</comment>
        </bits>
        <bits access="rw" name="wwt_timeout" pos="2" rst="0">
          <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.</comment>
        </bits>
        <bits access="rw" name="extra_rx" pos="3" rst="0">
          <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.</comment>
        </bits>
        <bits access="rw" name="resend_ovfl" pos="4" rst="0">
          <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.</comment>
        </bits>
        <bits access="rw" name="arg_end" pos="5" rst="0">
          <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.</comment>
        </bits>
        <bits access="rw" name="sci_dma_tx_done" pos="6" rst="0">
          <comment>DMA tx done.</comment>
        </bits>
        <bits access="rw" name="sci_dma_rx_done" pos="7" rst="0">
          <comment>DMA rx done.</comment>
        </bits>
        <comment>This register is READ/WRITE register that enables the desired interrupt. A '1' in a bit position indicates that the corresponding interrupt is enabled and if the interrupt occurs, the SCI will generate a hardware interrupt.</comment>
      </reg>
      <reg name="pa_clk_stop_en" protect="rw">
    </reg>
      <reg name="pa_status" protect="rw">
    </reg>
    </module>
    <instance address="0x14000000" name="SCI1" type="SCI"/>
    <instance address="0x14001000" name="SCI2" type="SCI"/>
  </archive>
  <archive relative="sdmmc.xml">
    <module category="Periph" name="SDMMC">
      <reg name="apbi_ctrl_sdmmc" protect="rw">
        <bits access="rw" name="l_endian" pos="2:0" rst="000">
          <comment>
            Controls the big endian or little endian of the FIFO data.
            <br/>
            Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
            <br/>
            &quot;000&quot;: the order is not changed.
            <br/>
            Byte3=&quot;0A&quot;,Byte2=&quot;0B&quot;,Byte1=&quot;0C&quot;,Byte0=&quot;0D&quot;.
            <br/>
            &quot;001&quot;: reversed on byte.
            <br/>
            Byte3=&quot;0D&quot;,Byte2=&quot;0C,Byte1=&quot;0B&quot;,Byte0=&quot;0A&quot;.
            <br/>
            &quot;010&quot;: reversed on half word.
            <br/>
            Byte3=&quot;0C&quot;,Byte2=&quot;0D,Byte1=&quot;0A&quot;,Byte0=&quot;0B&quot;.
            <br/>
            &quot;010&quot;: reversed on bit.
            <br/>
            Byte3=&quot;B0&quot;,Byte2=&quot;30,Byte1=&quot;D0&quot;,Byte0=&quot;50&quot;.
            <br/>
            &quot;100&quot;: reversed on bit.
            <br/>
            Byte3=&quot;0A&quot;,Byte2=&quot;0X,Byte1=&quot;0D&quot;,Byte0=&quot;0C&quot;.
          </comment>
        </bits>
        <bits access="rw" name="soft_rst_l" pos="3" rst="1">
          <comment>
            For the software to clear FIFO in case there is an error in communication with SD controller and some data are left behind.
            <br/>
            Active Low.
          </comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="apbi_fifo_txrx" protect="--">
        <bits access="r" name="data_out" pos="31:0" rst="0">
          <comment>Read in the receive FIFO</comment>
        </bits>
        <comment>Write to the transmit FIFO</comment>
      </reg>
      <hole size="16288"/>
      <reg name="sdmmc_config" protect="rw">
        <bits access="rw" name="sdmmc_sendcmd" pos="0" rst="0">
          <comment>
            SD/MMC operation begin register, active high.
            <br/>
		When '1', the controller finishes the last command and goes into suspend status. At suspend status, the controller will not execute the next command until the bit is set '0'.
          </comment>
        </bits>
        <bits access="rw" name="sdmmc_suspend" pos="1" rst="1">
          <comment>SD/MMC operation suspend register, active high.</comment>
        </bits>
        <bits access="rw" name="rsp_en" pos="4" rst="0">
          <comment>'1'indicates having a response,'0'indicates no response.</comment>
        </bits>
        <bits access="rw" name="rsp_sel" pos="6:5" rst="0">
          <options>
            <default/>
            <option name="R2" value="0b10"/>
            <option name="R3" value="0b01"/>
            <option name="OTHER" value="0b00"/>
          </options>
          <comment>Response select register,&quot;10&quot; means R2 response, &quot;01&quot; means R3 response, &quot;00&quot; means others response, &quot;11&quot; is reserved.</comment>
        </bits>
        <bits access="rw" name="rd_wt_en" pos="8" rst="0">
          <comment>'1' indicates data operation, which includes read and write.</comment>
        </bits>
        <bits access="rw" name="rd_wt_sel" pos="9" rst="0">
          <options>
            <default/>
            <option name="READ" value="0"/>
            <option name="WRITE" value="1"/>
          </options>
          <comment>'1' means write operation,'0' means read operation.</comment>
        </bits>
        <bits access="rw" name="s_m_sel" pos="10" rst="0">
          <options>
            <default/>
            <option name="SIMPLE" value="0"/>
            <option name="MULTIPLE" value="1"/>
          </options>
          <comment>'1'means multiple block data operation.</comment>
        </bits>
        <bits access="rw" name="bit_16" pos="16" rst="1">
	</bits>
      </reg>
      <reg name="sdmmc_status" protect="r">
        <bits access="r" name="not_sdmmc_over" pos="0" rst="0">
          <comment>'1' means the SD/MMC operation is not over.</comment>
        </bits>
        <bits access="r" name="busy" pos="1" rst="0">
          <comment>'1' means SD/MMC is busy.</comment>
        </bits>
        <bits access="r" name="dl_busy" pos="2" rst="0">
          <comment>'1' means the data line is busy.</comment>
        </bits>
        <bits access="r" name="suspend" pos="3" rst="1">
          <comment>'1' means the controller will not perform the new command when SDMMC_SENDCMD= '1'.</comment>
        </bits>
        <bits access="r" name="rsp_error" pos="8" rst="0">
          <comment>Response CRC checks error register '1' means response CRC check error.</comment>
        </bits>
        <bits access="r" name="no_rsp_error" pos="9" rst="0">
          <comment>'1' means the card has no response to command.</comment>
        </bits>
        <bits access="r" name="crc_status" pos="14:12" rst="0">
          <comment>
            CRC check for SD/MMC write operation
            <br/>
		&quot;101&quot; transmission error
            <br/>
		&quot;010&quot; transmission right
            <br/>
		&quot;111&quot; flash programming error
          </comment>
        </bits>
        <bits access="r" name="data_error" pos="23:16" rst="0">
          <comment>8 bits data CRC check, &quot;00000000&quot; means no data error, &quot;00000001&quot; means DATA0 CRC check error, &quot;10000000&quot; means DATA7 CRC check error, each bit match one data line.</comment>
        </bits>
        <bits access="r" name="dat3_val" pos="24" rst="-">
          <comment>SDMMC DATA 3 value.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_cmd_index" protect="rw">
        <bits access="rw" name="command" pos="5:0" rst="0">
          <comment>SD/MMC command register.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_cmd_arg" protect="rw">
        <comment>SD/MMC command argument register, write data to the SD/MMC card.</comment>
      </reg>
      <reg name="sdmmc_resp_index" protect="r">
        <bits access="r" name="response" pos="5:0" rst="0">
          <comment>SD/MMC response index register.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_resp_arg3" protect="r">
        <comment>Response argument of R1, R3 and R6, or 127 to 96 bit response argument of R2.</comment>
      </reg>
      <reg name="sdmmc_resp_arg2" protect="r">
        <comment>95 to 64 bit response argument of R2.</comment>
      </reg>
      <reg name="sdmmc_resp_arg1" protect="r">
        <comment>63 to 32 bit response argument of R2.</comment>
      </reg>
      <reg name="sdmmc_resp_arg0" protect="r">
        <comment>31 to 0 bit response argument of R2.</comment>
      </reg>
      <reg name="sdmmc_data_width_reg" protect="rw">
        <bits access="rw" name="sdmmc_data_width" pos="3:0" rst="0">
          <comment>
            SD/MMC data width:
            <br/>
		0x1: 1 data line
            <br/>
		0x2: 2 reserved
            <br/>
		0x4: 4 data lines
            <br/>
		0x8: 8 data lines
          </comment>
        </bits>
      </reg>
      <reg name="sdmmc_block_size_reg" protect="rw">
        <bits access="rw" name="sdmmc_block_size" pos="3:0" rst="0">
          <comment>
            SD/MMC size of one block:
            <br/>
		0-1:reserved
            <br/>
		2: 1 word
            <br/>
		3: 2 words
            <br/>
		4: 4 words
            <br/>
		5: 8 words
            <br/>
		6: 16 words
            <br/>
            <br/>
		11: 512 words
            <br/>
		12-15 reserved
          </comment>
        </bits>
      </reg>
      <reg name="sdmmc_block_cnt_reg" protect="rw">
        <bits access="rw" name="sdmmc_block_cnt" pos="15:0" rst="0">
          <comment>Block number that wants to transfer.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_int_status" protect="r">
        <bits access="r" name="no_rsp_int" pos="0" rst="0">
          <comment>'1' means no response.</comment>
        </bits>
        <bits access="r" name="rsp_err_int" pos="1" rst="0">
          <comment>'1' means CRC error of response.</comment>
        </bits>
        <bits access="r" name="rd_err_int" pos="2" rst="0">
          <comment>'1' means CRC error of reading data.</comment>
        </bits>
        <bits access="r" name="wr_err_int" pos="3" rst="0">
          <comment>'1' means CRC error of writing data.</comment>
        </bits>
        <bits access="r" name="dat_over_int" pos="4" rst="0">
          <comment>'1' means data transmission is over.</comment>
        </bits>
        <bits access="r" name="txdma_done_int" pos="5" rst="0">
          <comment>'1' means tx dma done.</comment>
        </bits>
        <bits access="r" name="rxdma_done_int" pos="6" rst="0">
          <comment>'1' means rx dma done.</comment>
        </bits>
        <bits access="r" name="no_rsp_sc" pos="8" rst="0">
          <comment>'1' means no response is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="rsp_err_sc" pos="9" rst="0">
          <comment>'1' means CRC error of response is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="rd_err_sc" pos="10" rst="0">
          <comment>'1' means CRC error of reading data is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="wr_err_sc" pos="11" rst="0">
          <comment>'1' means CRC error of writing data is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="dat_over_sc" pos="12" rst="0">
          <comment>'1' means the end of data transmission is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="txdma_done_sc" pos="13" rst="0">
          <comment>'1' means tx dma done is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="rxdma_done_sc" pos="14" rst="0">
          <comment>'1' means rx dma done is the source of interrupt.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_int_mask" protect="rw">
        <bits access="rw" name="no_rsp_mk" pos="0" rst="0">
          <comment>When no response, '1' means INT is disable.</comment>
        </bits>
        <bits access="rw" name="rsp_err_mk" pos="1" rst="0">
          <comment>When CRC error of response, '1' means INT is disable.</comment>
        </bits>
        <bits access="rw" name="rd_err_mk" pos="2" rst="0">
          <comment>When CRC error of reading data, '1' means INT is disable.</comment>
        </bits>
        <bits access="rw" name="wr_err_mk" pos="3" rst="0">
          <comment>When CRC error of writing data, '1' means INT is disable.</comment>
        </bits>
        <bits access="rw" name="dat_over_mk" pos="4" rst="0">
          <comment>When data transmission is over, '1' means INT is disable.</comment>
        </bits>
        <bits access="rw" name="txdma_done_mk" pos="5" rst="0">
          <comment>when tx dma done, '1' means INT is disabled.</comment>
        </bits>
        <bits access="rw" name="rxdma_done_mk" pos="6" rst="0">
          <comment>'1' means rx dma done, '1' means INT is disabled.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_int_clear" protect="w">
        <bits access="w" name="no_rsp_cl" pos="0" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in NO_RSP_SC.</comment>
        </bits>
        <bits access="w" name="rsp_err_cl" pos="1" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in RSP_ERR_SC.</comment>
        </bits>
        <bits access="w" name="rd_err_cl" pos="2" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in RD_ERR_SC.</comment>
        </bits>
        <bits access="w" name="wr_err_cl" pos="3" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in WR_ERR_SC.</comment>
        </bits>
        <bits access="w" name="dat_over_cl" pos="4" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in DAT_OVER_SC.</comment>
        </bits>
        <bits access="w" name="txdma_done_cl" pos="5" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in TXDMA_DONE_SC.</comment>
        </bits>
        <bits access="w" name="rxdma_done_cl" pos="6" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in RXDMA_DONE_SC.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_trans_speed_reg" protect="rw">
        <bits access="rw" name="sdmmc_trans_speed" pos="9:0" rst="0">
          <comment>Mclk = Pclk/(2*(SDMMC_TRANS_SPEED +1)).</comment>
        </bits>
      </reg>
      <reg name="sdmmc_mclk_adjust_reg" protect="rw">
        <bits access="rw" name="sdmmc_mclk_adjust" pos="3:0" rst="0">
          <comment>This register may delay the mclk output.
			 When MCLK_ADJUSTER = n, Mclk is outputted with  n Pclk.</comment>
        </bits>
        <bits access="rw" name="clk_inv" pos="4" rst="0">
          <comment>Invert Mclk.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04403000" name="SDMMC" type="SDMMC"/>
  </archive>
  <archive relative="spi_flash.xml">
    <module category="System" name="SPI_FLASH">
      <reg name="spi_cmd_addr" protect="rw">
        <bits access="rw" name="spi_tx_cmd" pos="7:0" rst="all0">
          <comment>spi flash command to send.</comment>
        </bits>
        <bits access="rw" name="spi_address" pos="31:8" rst="all0">
          <comment>spi flash address to send.</comment>
        </bits>
      </reg>
      <reg name="spi_block_size" protect="rw">
        <bits access="rw" name="spi_modebit" pos="7:0" rst="all0">
          <comment>spi flash modebit,set 0xA0 to enable continuous read.</comment>
        </bits>
        <bits access="rw" name="spi_rw_blk_size" pos="21:8" rst="0x1">
          <comment>spi flash spi read/write block size.</comment>
        </bits>
        <bits access="rw" name="continuous_enable" pos="24" rst="0x0">
        </bits>
      </reg>
      <reg name="spi_data_fifo" protect="rw">
        <bits access="w" name="spi_tx_data" pos="7:0" rst="no">
          <comment>spi flash data to send.</comment>
        </bits>
        <bits access="w" name="spi_send_type" pos="8" rst="no">
          <comment>spi send byte, 1: quad send 0: spi send.</comment>
        </bits>
      </reg>
      <reg name="spi_status" protect="r">
        <bits access="r" name="spi_flash_busy" pos="0" rst="0x0">
          <comment>spi flash busy.</comment>
        </bits>
        <bits access="r" name="tx_fifo_empty" pos="1" rst="0x1">
          <comment>tx fifo empty.</comment>
        </bits>
        <bits access="r" name="tx_fifo_full" pos="2" rst="0x0">
          <comment>tx fifo full.</comment>
        </bits>
        <bits access="r" name="rx_fifo_empty" pos="3" rst="0x1">
          <comment>rx fifo empty.</comment>
        </bits>
        <bits access="r" name="rx_fifo_count" pos="8:4" rst="all0">
          <comment>rx fifo data count.</comment>
        </bits>
        <bits access="r" name="read_stat_busy" pos="9" rst="0x0">
          <comment>read busy.</comment>
        </bits>
        <bits access="r" name="nand_int" pos="10" rst="0x0">
          <comment>nand int .</comment>
        </bits>
        <bits access="r" name="spiflash_int" pos="11" rst="0x0">
          <comment>spiflash_int = nand_int and nand_int_mask .</comment>
        </bits>
      </reg>
      <reg name="spi_read_back" protect="r">
        <comment>flash rx status.</comment>
      </reg>
      <reg name="spi_config" protect="rw">
        <bits access="rw" name="quad_mode" pos="0" rst="0x0">
          <comment>spi flash read mode from AHB.</comment>
          <options>
            <option name="spi read" value="0"/>
            <option name="quad read" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="spi_wprotect_pin" pos="1" rst="0x0">
          <comment>spi flash wprotect pin.</comment>
        </bits>
        <bits access="rw" name="spi_hold_pin" pos="2" rst="0x0">
          <comment>spi flash hold pin.</comment>
        </bits>
        <bits access="rw" name="sample_delay" pos="6:4" rst="0x2">
          <comment>spi flash read sample delay cycles.</comment>
        </bits>
        <bits access="rw" name="clk_divider" pos="15:8" rst="0x8">
          <comment>spi flash clock divider.</comment>
        </bits>
        <bits access="rw" name="cmd_quad" pos="16" rst="0x0">
          <comment>spi flash send command using quad lines.</comment>
        </bits>
        <bits access="rw" name="tx_rx_size" pos="18:17" rst="0x0">
        </bits>
      </reg>
      <reg name="spi_fifo_control" protect="w">
        <bits access="w" name="rx_fifo_clr" pos="0" rst="0x0">
          <comment>rx fifo_clr,self clear.</comment>
        </bits>
        <bits access="w" name="tx_fifo_clr" pos="1" rst="0x0">
          <comment>tx fifo_clr,self clear.</comment>
        </bits>
      </reg>
      <reg name="spi_cs_size" protect="rw">
        <bits access="rw" name="spi_cs_num" pos="0" rst="0x0">
          <comment>spi flash cs num.</comment>
          <options>
            <option name="1 spiflash" value="0"/>
            <option name="2 spiflash" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="spi size" pos="2:1" rst="all0">
          <comment>single chip spi flash size.</comment>
          <options>
            <option name="32m" value="0"/>
            <option name="64m" value="1"/>
            <option name="16m" value="2"/>
            <option name="8m" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="spi_128m" pos="3" rst="0x0">
          <comment>spi flash is 128m flash.</comment>
          <options>
            <option name="other spiflash" value="0"/>
            <option name="128m  spiflash" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="ahb_read_disable" pos="4" rst="0x0">
          <comment>disable read from ahb.</comment>
          <options>
            <option name="enable ahb read" value="0"/>
            <option name="disable ahb read" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="sel_flash_1" pos="5" rst="0x0">
          <comment>sel flash 1, addr[24].</comment>
          <options>
            <option name="sel flash 0" value="0"/>
            <option name="sel flash 1" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="sel1_flash_1" pos="6" rst="0x0">
          <comment>addr[25].</comment>
        </bits>
        <bits access="rw" name="diff_128m_diff_cmd_en" pos="7" rst="0x0">
          <comment>diff 128m diff cmd en.</comment>
        </bits>
        <bits access="rw" name="spi_256m" pos="8" rst="0x0">
          <comment>spi_256m.</comment>
        </bits>
        <bits access="rw" name="spi_512m" pos="9" rst="0x0">
          <comment>spi_512m.</comment>
        </bits>
        <bits access="rw" name="spi_cs1_sel2" pos="10" rst="0x0">
          <comment>spi_cs1_sel2.</comment>
        </bits>
        <bits access="rw" name="spi_1g" pos="11" rst="0x0">
          <comment>spi_1g .</comment>
        </bits>
        <bits access="rw" name="spi_2g" pos="12" rst="0x0">
          <comment>spi_2g.</comment>
        </bits>
        <bits access="rw" name="spi_4g" pos="13" rst="0x0">
          <comment>spi_4g.</comment>
        </bits>
        <bits access="rw" name="spi_cs1_sel3" pos="14" rst="0x0">
          <comment>spi_cs1_sel3.</comment>
        </bits>
        <bits access="rw" name="spi_cs1_sel4" pos="15" rst="0x0">
          <comment>spi_cs1_sel4.</comment>
        </bits>
        <bits access="rw" name="spi_cs1_sel5" pos="16" rst="0x0">
          <comment>spi_cs1_sel5.</comment>
        </bits>
      </reg>
      <reg name="spi_read_cmd" protect="rw">
        <bits access="rw" name="qread_cmd" pos="7:0" rst="0xeb">
          <comment>quad read command.</comment>
        </bits>
        <bits access="rw" name="fread_cmd" pos="15:8" rst="0x0b">
          <comment>fast read command.</comment>
        </bits>
        <bits access="rw" name="read_cmd" pos="23:16" rst="0x03">
          <comment>fast read command.</comment>
        </bits>
        <bits access="w" name="protect_byte" pos="31:24" rst="all0">
          <comment>protect_byte, must be 0x55 when program this register.</comment>
        </bits>
      </reg>
      <reg name="spi_nand_config" protect="rw">
        <bits access="rw" name="nand_sel" pos="0" rst="all0">
		</bits>
        <bits access="rw" name="nand_addr" pos="2:1" rst="all0">
        </bits>
        <bits access="rw" name="reuse_nand_ram" pos="3" rst="all0">
        </bits>
        <bits access="rw" name="reuse_read" pos="4" rst="all0">
        </bits>
        <bits access="rw" name="write_page_hit" pos="5" rst="all0">
        </bits>
        <bits access="rw" name="nand_data_trans" pos="6" rst="all0">
        </bits>
        <bits access="rw" name="page_size_sel" pos="7" rst="all0">
		</bits>
        <bits access="rw" name="page_read_cmd" pos="15:8" rst="0x13">
        </bits>
        <bits access="rw" name="get_sts_cmd" pos="23:16" rst="0x0f">
        </bits>
        <bits access="rw" name="ram_read_cmd" pos="31:24" rst="0x03">
        </bits>
      </reg>
      <reg name="spi_nand_config2" protect="rw">
        <bits access="rw" name="get_sts_addr" pos="7:0" rst="0xc0">
        </bits>
        <bits access="rw" name="sts_qip" pos="23:16" rst="0x01">
        </bits>
      </reg>
      <reg name="spi_256_512_flash_config" protect="rw">
        <bits access="rw" name="four_byte_addr" pos="0" rst="all0">
		</bits>
        <bits access="rw" name="dummy_cycle_en" pos="1" rst="all0">
		</bits>
        <bits access="rw" name="dummy_cycle" pos="11:8" rst="0x08">
        </bits>
        <bits access="rw" name="wrap_en" pos="12" rst="all0">
        </bits>
        <bits access="rw" name="wrap_code" pos="19:16" rst="all0">
        </bits>
      </reg>
      <reg name="spi_128_flash_config" protect="rw">
        <bits access="rw" name="first_128m_cmd" pos="7:0" rst="0x8c">
		</bits>
        <bits access="rw" name="second_128m_cmd" pos="15:8" rst="0x8d">
        </bits>
        <bits access="rw" name="third_128m_cmd" pos="23:16" rst="0x0">
        </bits>
        <bits access="rw" name="fourth_128m_cmd" pos="31:24" rst="0x0">
        </bits>
      </reg>
      <reg name="spi_cs4_sel" protect="rw">
        <bits access="rw" name="spi_cs4_sel" pos="2:0" rst="0x0">
		</bits>
      </reg>
      <reg name="page0_addr" protect="rw">
        <bits access="rw" name="page0_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page0_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page1_addr" protect="rw">
        <bits access="rw" name="page1_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page1_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page2_addr" protect="rw">
        <bits access="rw" name="page2_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page2_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page3_addr" protect="rw">
        <bits access="rw" name="page3_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page3_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page4_addr" protect="rw">
        <bits access="rw" name="page4_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page4_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page5_addr" protect="rw">
        <bits access="rw" name="page5_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page5_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page6_addr" protect="rw">
        <bits access="rw" name="page6_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page6_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page7_addr" protect="rw">
        <bits access="rw" name="page7_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page7_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page8_addr" protect="rw">
        <bits access="rw" name="page8_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page8_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page9_addr" protect="rw">
        <bits access="rw" name="page9_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page9_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page10_addr" protect="rw">
        <bits access="rw" name="page10_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page10_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page11_addr" protect="rw">
        <bits access="rw" name="page11_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page11_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page12_addr" protect="rw">
        <bits access="rw" name="page12_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page12_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page13_addr" protect="rw">
        <bits access="rw" name="page13_addr" pos="23:0" rst="0x0">
         </bits>
        <bits access="rw" name="page13_valid" pos="31" rst="0x0">
	 	</bits>
      </reg>
      <reg name="page14_addr" protect="rw">
        <bits access="rw" name="page14_addr" pos="23:0" rst="0x0">
         </bits>
        <bits access="rw" name="page14_valid" pos="31" rst="0x0">
	 	</bits>
      </reg>
      <reg name="page15_addr" protect="rw">
        <bits access="rw" name="page15_addr" pos="23:0" rst="0x0">
         </bits>
        <bits access="rw" name="page15_valid" pos="31" rst="0x0">
	 	</bits>
      </reg>
      <reg name="spi_page_config" protect="rw">
        <bits access="rw" name="multi_page_enable/multi_page_start" pos="0" rst="0x0">
         </bits>
        <bits access="rw" name="page_num" pos="12:8" rst="0x0">
	 	</bits>
      </reg>
      <reg name="spi_cmd_reconfig" protect="rw">
        <bits access="rw" name="program_exe_cmd" pos="7:0" rst="0x0">
         </bits>
        <bits access="rw" name="program_load_cmd" pos="15:8" rst="0x0">
         </bits>
        <bits access="rw" name="write_enable_cmd" pos="23:16" rst="0x0">
         </bits>
      </reg>
      <reg name="page0_col_addr" protect="rw">
        <bits access="rw" name="page0_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page1_col_addr" protect="rw">
        <bits access="rw" name="page1_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page2_col_addr" protect="rw">
        <bits access="rw" name="page2_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page3_col_addr" protect="rw">
        <bits access="rw" name="page3_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page4_col_addr" protect="rw">
        <bits access="rw" name="page4_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page5_col_addr" protect="rw">
        <bits access="rw" name="page5_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page6_col_addr" protect="rw">
        <bits access="rw" name="page6_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page7_col_addr" protect="rw">
        <bits access="rw" name="page7_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page8_col_addr" protect="rw">
        <bits access="rw" name="page8_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page9_col_addr" protect="rw">
        <bits access="rw" name="page9_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page10_col_addr" protect="rw">
        <bits access="rw" name="page10_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page11_col_addr" protect="rw">
        <bits access="rw" name="page11_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page12_col_addr" protect="rw">
        <bits access="rw" name="page12_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page13_col_addr" protect="rw">
        <bits access="rw" name="page13_col_addr" pos="15:0" rst="0x0">
         </bits>
      </reg>
      <reg name="page14_col_addr" protect="rw">
        <bits access="rw" name="page14_col_addr" pos="15:0" rst="0x0">
         </bits>
      </reg>
      <reg name="page15_col_addr" protect="rw">
        <bits access="rw" name="page15_col_addr" pos="15:0" rst="0x0">
         </bits>
      </reg>
      <reg name="nand_int_mask" protect="rw">
        <bits access="rw" name="nand_int_mask" pos="0" rst="0x0">
		</bits>
      </reg>
    </module>
    <instance address="0x02000000" name="SPI_FLASH" type="SPI_FLASH"/>
    <instance address="0x02040000" name="SPI_FLASH_EXT" type="SPI_FLASH"/>
  </archive>
  <archive relative="timer_ap.xml">
    <module category="System" name="TIMER_AP">
      <reg name="ostimer_loadval_l" protect="rw">
        <comment>Value low 32bits loaded to OS timer.</comment>
      </reg>
      <reg name="ostimer_ctrl" protect="rw">
        <bits access="rw" name="loadval_h" pos="23:0" rst="0">
          <comment>Value high 24bits loaded to OS timer.</comment>
        </bits>
        <bits access="rw" name="enable" pos="24" rst="0">
          <comment>
            Write '1' to this bit will enable OS timer.
            <br/>
            When read, the value is what we have written to this bit, it changes immediately  after been written.
          </comment>
        </bits>
        <bits access="r" name="enabled" pos="25" rst="0">
          <comment>
            Read this bit will get the information if OS timer is really enabled or not. This bit will change only after the next front of 16 KHz system clock.
            <br/>
            <br/>
            '1' indicates OS timer enabled.
            <br/>
            '0' indicates OS timer not enabled.
          </comment>
        </bits>
        <bits access="r" name="cleared" pos="26" rst="0">
          <comment>
            Read this bit will get the information if OS timer interruption clear operation is finished or not.
            <br/>
            <br/>
            '1' indicates OS timer interruption clear operation is on going.
            <br/>
            '0' indicates no OS timer interruption clear operation is on going.
          </comment>
        </bits>
        <bits access="rw" name="repeat" pos="28" rst="0">
          <comment>
            Write '1' to this bit will set OS timer to repeat mode.
            <br/>
            When read, get the information if OS timer is in repeat mode.
            <br/>
            <br/>
            '1' indicates OS timer in repeat mode.
            <br/>
            '0' indicates OS timer not in repeat mode.
          </comment>
        </bits>
        <bits access="rw" name="wrap" pos="29" rst="0">
          <comment>
            Write '1' to this bit will set OS timer to wrap mode.
            <br/>
            When read, get the information if OS timer is in wrap mode.
            <br/>
            <br/>
            '1' indicates OS timer in wrap mode.
            <br/>
            '0' indicates OS timer not in wrap mode.
          </comment>
        </bits>
        <bits access="rw" name="load" pos="30" rst="0">
          <comment>Write '1' to this bit will load the initial value to OS timer.</comment>
        </bits>
      </reg>
      <reg name="ostimer_curval_l" protect="rw">
        <comment>Current value low 32bits of OS timer.</comment>
      </reg>
      <reg name="ostimer_curval_h" protect="rw">
        <comment>Current value high bits of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.</comment>
      </reg>
      <reg name="ostimer_lockval_l" protect="rw">
        <comment>Current locked value low 32bits of OS timer.</comment>
      </reg>
      <reg name="ostimer_lockval_h" protect="rw">
        <comment>Current locked value high bits of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.</comment>
      </reg>
      <reg name="hwtimer_ctrl" protect="rw">
        <bits access="rw" name="interval_en" pos="8" rst="0">
          <comment>
            This bit enables interval IRQ mode.
            <br/>
            <br/>
            '0': hw delay timer does not generate interval IRQ.
            <br/>
            '1': hw delay timer generate an IRQ each interval.
          </comment>
        </bits>
        <bits access="rw" name="interval" pos="1:0" rst="00">
          <comment>
            interval of generating an HwTimer IRQ.
            <br/>
            <br/>
            &quot;00&quot;: interval of 1/8 second.
            <br/>
            &quot;01&quot;: interval of 1/4 second.
            <br/>
            &quot;10&quot;: interval of 1/2 second.
            <br/>
            &quot;11&quot;: interval of 1 second.
          </comment>
        </bits>
      </reg>
      <reg name="hwtimer_curval_l" protect="rw">
        <comment>Current low 32bits value of the hardware delay timer.</comment>
      </reg>
      <reg name="hwtimer_curval_h" protect="rw">
        <comment>Current high 32bits value of the hardware delay timer.</comment>
      </reg>
      <reg name="hwtimer_lockval_l" protect="rw">
        <comment>Current locked low 32bits value of the hardware delay timer.</comment>
      </reg>
      <reg name="hwtimer_lockval_h" protect="rw">
        <comment>Current locked high 32bits value of the hardware delay timer.</comment>
      </reg>
      <reg name="timer_irq_mask_set" protect="rw">
        <bits access="rs" name="ostimer_mask" pos="0" rst="0">
          <comment>Set mask for OS timer IRQ.</comment>
        </bits>
        <bits access="rs" name="hwtimer_wrap_mask" pos="1" rst="0">
          <comment>Set mask for hardwre delay timer wrap IRQ.</comment>
        </bits>
        <bits access="rs" name="hwtimer_itv_mask" pos="2" rst="0">
          <comment>Set mask for hardwre delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_mask_clr" protect="rw">
        <bits access="rc" name="ostimer_mask" pos="0" rst="0">
          <comment>Clear mask for OS timer IRQ.</comment>
        </bits>
        <bits access="rc" name="hwtimer_wrap_mask" pos="1" rst="0">
          <comment>Clear mask for hardwre delay timer wrap IRQ.</comment>
        </bits>
        <bits access="rc" name="hwtimer_itv_mask" pos="2" rst="0">
          <comment>Clear mask for hardwre delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_clr" protect="rw">
        <bits access="c" name="ostimer_clr" pos="0" rst="0">
          <comment>Clear OS timer IRQ.</comment>
        </bits>
        <bits access="c" name="hwtimer_wrap_clr" pos="1" rst="0">
          <comment>Clear hardware delay timer wrap IRQ.</comment>
        </bits>
        <bits access="c" name="hwtimer_itv_clr" pos="2" rst="0">
          <comment>Clear hardware delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_cause" protect="rw">
        <bits access="r" name="ostimer_cause" pos="0" rst="0">
          <comment>OS timer IRQ cause.</comment>
        </bits>
        <bits access="r" name="hwtimer_wrap_cause" pos="1" rst="0">
          <comment>hardware delay timer wrap IRQ cause.</comment>
        </bits>
        <bits access="r" name="hwtimer_itv_cause" pos="2" rst="0">
          <comment>hardware delay timer interval IRQ cause.</comment>
        </bits>
        <bits access="r" name="ostimer_status" pos="16" rst="0">
          <comment>OS timer IRQ status.</comment>
        </bits>
        <bits access="r" name="hwtimer_wrap_status" pos="17" rst="0">
          <comment>hardware delay timer wrap IRQ status.</comment>
        </bits>
        <bits access="r" name="hwtimer_itv_status" pos="18" rst="0">
          <comment>hardware delay timer interval IRQ status.</comment>
        </bits>
        <bitgroup name="other_tims_irq">
          <entry ref="hwtimer_wrap_cause"/>
          <entry ref="hwtimer_itv_cause"/>
        </bitgroup>
      </reg>
    </module>
    <instance address="0x04806000" name="TIMER2" type="TIMER_AP"/>
    <instance address="0x14007000" name="TIMER4" type="TIMER_AP"/>
    <instance address="0x04806800" name="TIMER5" type="TIMER_AP"/>
  </archive>
  <archive relative="timer.xml">
    <module category="System" name="TIMER">
      <var name="NB_INTERVAL" value="1"/>
      <var name="INT_TIMER_NB_BITS" value="24"/>
      <var name="WD_TIMER_NB_BITS" value="24"/>
      <var name="HW_TIMER_NB_BITS" value="32"/>
      <var name="TIM_MAXVAL" value="0xffffff"/>
      <reg name="ostimer_ctrl" protect="rw">
        <bits access="rw" name="loadval" pos="23:0" rst="0">
          <comment>Value loaded to OS timer.</comment>
        </bits>
        <bits access="rw" name="enable" pos="24" rst="0">
          <comment>
            Write '1' to this bit will enable OS timer.
            <br/>
            When read, the value is what we have written to this bit, it changes immediately  after been written.
          </comment>
        </bits>
        <bits access="r" name="enabled" pos="25" rst="0">
          <comment>
            Read this bit will get the information if OS timer is really enabled or not. This bit will change only after the next front of 16 KHz system clock.
            <br/>
            <br/>
            '1' indicates OS timer enabled.
            <br/>
            '0' indicates OS timer not enabled.
          </comment>
        </bits>
        <bits access="r" name="cleared" pos="26" rst="0">
          <comment>
            Read this bit will get the information if OS timer interruption clear operation is finished or not.
            <br/>
            <br/>
            '1' indicates OS timer interruption clear operation is on going.
            <br/>
            '0' indicates no OS timer interruption clear operation is on going.
          </comment>
        </bits>
        <bits access="rw" name="repeat" pos="28" rst="0">
          <comment>
            Write '1' to this bit will set OS timer to repeat mode.
            <br/>
            When read, get the information if OS timer is in repeat mode.
            <br/>
            <br/>
            '1' indicates OS timer in repeat mode.
            <br/>
            '0' indicates OS timer not in repeat mode.
          </comment>
        </bits>
        <bits access="rw" name="wrap" pos="29" rst="0">
          <comment>
            Write '1' to this bit will set OS timer to wrap mode.
            <br/>
            When read, get the information if OS timer is in wrap mode.
            <br/>
            <br/>
            '1' indicates OS timer in wrap mode.
            <br/>
            '0' indicates OS timer not in wrap mode.
          </comment>
        </bits>
        <bits access="rw" name="load" pos="30" rst="0">
          <comment>Write '1' to this bit will load the initial value to OS timer.</comment>
        </bits>
      </reg>
      <reg name="ostimer_curval" protect="rw">
        <comment>Current value of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.</comment>
      </reg>
      <reg name="wdtimer_ctrl" protect="rw">
        <bits access="s" name="start" pos="0" rst="0">
          <comment>Write '1' to this bit will enable watchdog timer and Load it with WDTimer_LoadVal.</comment>
        </bits>
        <bits access="c" name="stop" pos="4" rst="0">
          <comment>Write '1' to this bit will stop watchdog timer.</comment>
        </bits>
        <bits access="w" name="reload" pos="16" rst="0">
          <comment>
            Write '1' to this bit will load WDTimer_LoadVal value to watchdog timer.
            <br/>
            Use this bit to implement the watchog keep alive.
          </comment>
        </bits>
        <bits access="r" name="wdenabled" pos="8" rst="0">
          <comment>
            Read this bit will get the information if watchdog timer is really enabled or not. This bit will change only after the next front of 32 KHz system clock.
            <br/>
            <br/>
            '1' indicates watchdog timer is enabled, if current watchdog timer value reaches 0, the system will be reseted.
            <br/>
            '0' indicates watchdog timer is not enabled.
          </comment>
        </bits>
      </reg>
      <reg name="wdtimer_loadval" protect="rw">
        <bits access="rw" name="wdloadval" pos="WD_TIMER_NB_BITS-1:0" rst="-">
          <comment>
            Load value of watchdog timer. Number of 32kHz Clock before Reset.
            <br/>
          </comment>
        </bits>
      </reg>
      <reg name="hwtimer_ctrl" protect="rw">
        <bits access="rw" name="interval_en" pos="8" rst="0">
          <comment>
            This bit enables interval IRQ mode.
            <br/>
            <br/>
            '0': hw delay timer does not generate interval IRQ.
            <br/>
            '1': hw delay timer generate an IRQ each interval.
          </comment>
        </bits>
        <bits access="rw" name="interval" pos="1:0" rst="00">
          <comment>
            interval of generating an HwTimer IRQ.
            <br/>
            <br/>
            &quot;00&quot;: interval of 1/8 second.
            <br/>
            &quot;01&quot;: interval of 1/4 second.
            <br/>
            &quot;10&quot;: interval of 1/2 second.
            <br/>
            &quot;11&quot;: interval of 1 second.
          </comment>
        </bits>
      </reg>
      <reg name="hwtimer_curval" protect="rw">
        <comment>Current value of the hardware delay timer. The value is incremented every 61 us. This timer is running all the time and wrap at value 0xFFFFFFFF.</comment>
      </reg>
      <reg name="timer_irq_mask_set" protect="rw">
        <bits access="rs" name="ostimer_mask" pos="0" rst="0">
          <comment>Set mask for OS timer IRQ.</comment>
        </bits>
        <bits access="rs" name="hwtimer_wrap_mask" pos="1" rst="0">
          <comment>Set mask for hardwre delay timer wrap IRQ.</comment>
        </bits>
        <bits access="rs" name="hwtimer_itv_mask" pos="2" rst="0">
          <comment>Set mask for hardwre delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_mask_clr" protect="rw">
        <bits access="rc" name="ostimer_mask" pos="0" rst="0">
          <comment>Clear mask for OS timer IRQ.</comment>
        </bits>
        <bits access="rc" name="hwtimer_wrap_mask" pos="1" rst="0">
          <comment>Clear mask for hardwre delay timer wrap IRQ.</comment>
        </bits>
        <bits access="rc" name="hwtimer_itv_mask" pos="2" rst="0">
          <comment>Clear mask for hardwre delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_clr" protect="rw">
        <bits access="c" name="ostimer_clr" pos="0" rst="0">
          <comment>Clear OS timer IRQ.</comment>
        </bits>
        <bits access="c" name="hwtimer_wrap_clr" pos="1" rst="0">
          <comment>Clear hardware delay timer wrap IRQ.</comment>
        </bits>
        <bits access="c" name="hwtimer_itv_clr" pos="2" rst="0">
          <comment>Clear hardware delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_cause" protect="rw">
        <bits access="r" name="ostimer_cause" pos="0" rst="0">
          <comment>OS timer IRQ cause.</comment>
        </bits>
        <bits access="r" name="hwtimer_wrap_cause" pos="1" rst="0">
          <comment>hardware delay timer wrap IRQ cause.</comment>
        </bits>
        <bits access="r" name="hwtimer_itv_cause" pos="2" rst="0">
          <comment>hardware delay timer interval IRQ cause.</comment>
        </bits>
        <bits access="r" name="ostimer_status" pos="16" rst="0">
          <comment>OS timer IRQ status.</comment>
        </bits>
        <bits access="r" name="hwtimer_wrap_status" pos="17" rst="0">
          <comment>hardware delay timer wrap IRQ status.</comment>
        </bits>
        <bits access="r" name="hwtimer_itv_status" pos="18" rst="0">
          <comment>hardware delay timer interval IRQ status.</comment>
        </bits>
        <bitgroup name="other_tims_irq">
          <entry ref="hwtimer_wrap_cause"/>
          <entry ref="hwtimer_itv_cause"/>
        </bitgroup>
      </reg>
    </module>
    <instance address="0x04805000" name="TIMER1" type="TIMER"/>
    <instance address="0x14006000" name="TIMER3" type="TIMER"/>
  </archive>
  <archive relative="uart.xml">
    <module category="Periph" name="UART">
      <var name="UART_RX_FIFO_SIZE" value="128"/>
      <var name="UART_TX_FIFO_SIZE" value="16"/>
      <var name="NB_RX_FIFO_BITS" value="7"/>
      <var name="NB_TX_FIFO_BITS" value="4"/>
      <reg name="ctrl" protect="rw">
        <bits access="rw" name="enable" pos="0" rst="0">
          <options>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
            <default/>
          </options>
          <comment>
            Allows to turn off the UART:
            <br/>
            0 = Disable
            <br/>
            1 = Enable
          </comment>
        </bits>
        <bits access="rw" name="data bits" pos="1" rst="0">
          <comment>Number of data bits per character (least significant bit first),
          if {Data_Bits_56, Data_Bits} is 00, the number of data bits is 7;
          if {Data_Bits_56, Data_Bits} is 01, the number of data bits is 8;
          if {Data_Bits_56, Data_Bits} is 10, the number of data bits is 5;
          if {Data_Bits_56, Data_Bits} is 11, the number of data bits is 6;</comment>
        </bits>
        <bits access="rw" name="tx stop bits" pos="2" rst="0">
          <options>
            <option name="1_BIT" value="0"/>
            <option name="2_BITS" value="1"/>
            <default/>
          </options>
          <comment>
            Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).
            <br/>
            0 = one stop bit is
      transmitted in the serial data.
            <br/>
            1 = two stop bits are generated and
      transmitted in the serial data out.
          </comment>
        </bits>
        <bits access="rw" name="parity enable" pos="3" rst="0">
          <options>
            <option name="NO" value="0"/>
            <option name="YES" value="1"/>
            <default/>
          </options>
          <comment>Parity is enabled when this bit is set.</comment>
        </bits>
        <bits access="rw" name="parity select" pos="5:4" rst="0">
          <options>
            <option name="ODD" value="0"/>
            <option name="EVEN" value="1"/>
            <option name="SPACE" value="2"/>
            <option name="MARK" value="3"/>
            <default/>
          </options>
          <comment>
            Controls the parity format when parity is enabled:
            <br/>
            00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).
            <br/>
            01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).
            <br/>
            10 = a space is
      generated and received as parity bit.
            <br/>
            11 = a mark is generated and
      received as parity bit.
          </comment>
        </bits>
        <bits access="rw" name="soft flow ctrl enable" pos="6" rst="0">
          <comment>
            Controls whether enable or disable soft flow ctrl function.
            <br/>
            0 = disable flow ctrl function
            <br/>
            1 = enable flow ctrl function
          </comment>
        </bits>
        <bits access="rw" name="auto_enable" pos="8" rst="0">
          <comment>
            Controls whether enable or disable auto baud rate function.
            <br/>
            0 = disable auto baud rate function
            <br/>
            1 = enable auto baud rate function
          </comment>
        </bits>
        <bits access="rw" name="data bits_56" pos="12" rst="0">
          <comment>Number of data bits per character (least significant bit first),
          if {Data_Bits_56, Data_Bits} is 00, the number of data bits is 7;
          if {Data_Bits_56, Data_Bits} is 01, the number of data bits is 8;
          if {Data_Bits_56, Data_Bits} is 10, the number of data bits is 5;
          if {Data_Bits_56, Data_Bits} is 11, the number of data bits is 6;</comment>
        </bits>
        <bits access="rw" name="divisor mode" pos="20:19" rst="2'h1">
          <comment>
            Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.
            <br/>
            0 =
      (BCLK = SCLK / 16)
            <br/>
            1 = (BCLK = SCLK / 4)
            <br/>
            2 = (BCLK = SCLK / 3)
          </comment>
        </bits>
        <bits access="rw" name="irda enable" pos="21" rst="0">
          <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details).</comment>
        </bits>
        <bits access="rw" name="dma mode" pos="22" rst="0">
          <options>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
            <default/>
          </options>
          <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC.</comment>
        </bits>
        <bits access="rw" name="auto flow control" pos="23" rst="0">
          <options>
            <option name="ENABLE" value="1"/>
            <option name="DISABLE" value="0"/>
            <default/>
          </options>
          <comment>Enables the auto flow control. Uart_RTS is controlled by the Rx
      RTS bit and the UART Auto Control Flow System. If Uart_CTS
      become inactive high, the Tx data flow is stopped.</comment>
        </bits>
        <bits access="rw" name="loop back mode" pos="24" rst="0">
          <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support).</comment>
        </bits>
        <bits access="rw" name="rx lock err" pos="25" rst="0">
          <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept.</comment>
        </bits>
        <bits access="rw" name="rx break length" pos="31:28" rst="0xF">
          <comment>Length of a break, in number of bits.</comment>
        </bits>
      </reg>
      <reg name="status" protect="r">
        <bits access="r" name="rx fifo level" pos="NB_RX_FIFO_BITS:0" rst="0">
          <options>
            <mask/>
            <shift/>
          </options>
          <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read.</comment>
        </bits>
        <bits access="r" name="tx fifo space" pos="NB_TX_FIFO_BITS+8:8" rst="5'h10">
          <options>
            <mask/>
            <shift/>
          </options>
          <comment>Those bits indicate the number of space available in the Tx
      Fifo.</comment>
        </bits>
        <bits access="r" name="at_match_flag" pos="13" rst="0">
          <comment>
            at_match flag
            <br/>
             '0' = AT is detected successfully.
            <br/>
             '1' = at is detected successfully.
            When auto_enable is 0,this bit is cleared to 0.
          </comment>
        </bits>
        <bits access="r" name="tx active" pos="14" rst="0">
          <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface.</comment>
        </bits>
        <bits access="r" name="rx active" pos="15" rst="0">
          <comment>This bit indicates that the UART is receiving a byte.</comment>
        </bits>
        <bits access="r" name="rx overflow err" pos="16" rst="0">
          <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="tx overflow err" pos="17" rst="0">
          <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when
          the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx parity err" pos="18" rst="0">
          <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx framing err" pos="19" rst="0">
          <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value.</comment>
        </bits>
        <bits access="r" name="rx break int" pos="20" rst="0">
          <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value.</comment>
        </bits>
        <bits access="r" name="character_miscompare" pos="21" rst="0">
          <comment>
            character miscompare flag
            <br/>
             '0' = AT or at compare failed.
            <br/>
             '1' = AT or at compare successfully.
            When auto_enable is 0,this bit is cleared to 0.
          </comment>
        </bits>
        <bits access="r" name="auto_baud_locked" pos="22" rst="0">
          <comment>
            auto baud locked flag
            <br/>
             '0' = baud rate is detected failed.
            <br/>
             '1' = baud rate is detected successfully.
            When auto_enable is 0,this bit is cleared to 0.
          </comment>
        </bits>
        <bits access="r" name="dcts" pos="24" rst="1">
          <comment>This bit is set when the Uart_CTS line changed since the last
      time this register has been written. This bit is cleared when the
      UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="cts" pos="25" rst="0">
          <comment>
            current value of the Uart_CTS line.
            <br/>
             '1' = Tx not allowed.
            <br/>
             '0' = Tx allowed.
          </comment>
        </bits>
        <bits access="r" name="auto ratio flag" pos="26" rst="0">
          <comment>Auto mode ratio flag.</comment>
        </bits>
        <bits access="r" name="mask tx enable flag" pos="27" rst="0">
          <comment>Mask tx enable flag.</comment>
        </bits>
        <bits access="r" name="dtr" pos="28" rst="0">
          <comment>Current value of the DTR line.</comment>
        </bits>
        <bits access="r" name="clk enabled" pos="31" rst="0">
          <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      RTS too early.</comment>
        </bits>
      </reg>
      <reg name="rxtx_buffer" protect="--">
        <bits access="rw" name="rxtx_data" pos="7:0">
          <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost.</comment>
        </bits>
      </reg>
      <reg name="irq_mask" protect="rw">
        <bits access="rw" name="tx modem status" pos="0" rst="0">
          <comment>Clear to send signal change detected.</comment>
        </bits>
        <bits access="rw" name="rx data available" pos="1" rst="0">
          <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level).</comment>
        </bits>
        <bits access="rw" name="tx data needed" pos="2" rst="0">
          <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level).</comment>
        </bits>
        <bits access="rw" name="rx timeout" pos="3" rst="0">
          <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time.</comment>
        </bits>
        <bits access="rw" name="rx line err" pos="4" rst="0">
          <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt.</comment>
        </bits>
        <bits access="rw" name="tx dma done" pos="5" rst="0">
          <comment>Pulse detected on Uart_Dma_Tx_Done_H signal.</comment>
        </bits>
        <bits access="rw" name="rx dma done" pos="6" rst="0">
          <comment>Pulse detected on Uart_Dma_Rx_Done_H signal.</comment>
        </bits>
        <bits access="rw" name="rx dma timeout" pos="7" rst="0">
          <comment>In DMA mode, there is at least 1 character that has been read
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.</comment>
        </bits>
        <bits access="rw" name="dtr rise" pos="8" rst="0">
          <comment>Rising edge detected on the UART_DTR signal.</comment>
        </bits>
        <bits access="rw" name="dtr fall" pos="9" rst="0">
          <comment>Falling edge detected on the UART_DTR signal.</comment>
        </bits>
        <bits access="rw" name="auto fail" pos="10" rst="0">
          <comment>Auto function fail.</comment>
        </bits>
        <bits access="rw" name="uart dma rx adone" pos="11" rst="0">
          <comment>When rx transfer num equals to transfer threshold, there is a interrupt flag.</comment>
        </bits>
        <bits access="rw" name="uart dma tx adone" pos="12" rst="0">
          <comment>When tx transfer num equals to transfer threshold, there is a interrupt flag.</comment>
        </bits>
        <bits access="rw" name="xoff_trig" pos="13" rst="0">
          <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xoff.</comment>
        </bits>
        <bits access="rw" name="xon_trig" pos="14" rst="0">
          <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xon.</comment>
        </bits>
        <bits access="rw" name="start_det" pos="15" rst="0">
          <comment>This interrupt is generated when start bit is detected.</comment>
        </bits>
      </reg>
      <reg name="irq_cause" protect="rw">
        <bits access="r" name="tx modem status" pos="0" rst="0">
          <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx data available" pos="1" rst="0">
          <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level.</comment>
        </bits>
        <bits access="r" name="tx data needed" pos="2" rst="0">
          <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level.</comment>
        </bits>
        <bits access="r" name="rx timeout" pos="3" rst="0">
          <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.</comment>
        </bits>
        <bits access="r" name="rx line err" pos="4" rst="0">
          <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value.</comment>
        </bits>
        <bits access="rw" name="tx dma done" pos="5" rst="0">
          <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="rx dma done" pos="6" rst="0">
          <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="rx dma timeout" pos="7" rst="0">
          <comment>In DMA mode, there is at least 1 character that has been read
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.
            Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="dtr rise" pos="8" rst="0">
          <comment>This interrupt is generated when a rising edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="dtr fall" pos="9" rst="0">
          <comment>This interrupt is generated when a falling edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="auto fail" pos="10" rst="0">
          <comment>This interrupt is generated when auto function fail.
      Reset control: Write  0 in auto_enable.</comment>
        </bits>
        <bits access="rw" name="uart dma rx adone" pos="11" rst="0">
          <comment>This interrupt is generated when rx transfer num is not less than transfer threshold.
      Reset control: Write  1 in this register.</comment>
        </bits>
        <bits access="rw" name="uart dma tx adone" pos="12" rst="0">
          <comment>This interrupt is generated when tx transfer num is not less than transfer threshold.
      Reset control: Write  1 in this register.</comment>
        </bits>
        <bits access="rw" name="xoff_trig" pos="13" rst="0">
          <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xoff.
      Reset control: Write  1 in this register.</comment>
        </bits>
        <bits access="rw" name="xon_trig" pos="14" rst="0">
          <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xon.
      Reset control: Write  1 in this register.</comment>
        </bits>
        <bits access="rw" name="start_det" pos="15" rst="0">
          <comment>This interrupt is generated when start is detected.
      Reset control: Write  1 in this register.</comment>
        </bits>
        <bits access="r" name="tx modem status u" pos="16" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx data available u" pos="17" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="tx data needed u" pos="18" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx timeout u" pos="19" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx line err u" pos="20" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="tx dma done u" pos="21" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx dma done u" pos="22" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx dma timeout u" pos="23" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="dtr rise u" pos="24" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="dtr fall u" pos="25" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="auto fail u" pos="26" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="rw" name="uart dma rx adone u" pos="27" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="rw" name="uart dma tx adone u" pos="28" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="rw" name="xoff_trig u" pos="29" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="rw" name="xon_trig u" pos="30" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="rw" name="start_det u" pos="31" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
      </reg>
      <reg name="triggers" protect="rw">
        <bits access="rw" name="rx trigger" pos="NB_RX_FIFO_BITS-1:0" rst="0">
          <comment>
            Defines the empty threshold level at which the Data Available
      Interrupt will be generated.
            <br/>
            The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.
          </comment>
        </bits>
        <bits access="rw" name="tx trigger" pos="NB_TX_FIFO_BITS-1+8:8" rst="0">
          <comment>
            Defines the empty threshold level at which the Data Needed
      Interrupt will be generated.
            <br/>
            The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.
          </comment>
        </bits>
        <bits access="rw" name="afc level" pos="NB_RX_FIFO_BITS-1+16:16" rst="0">
          <comment>
            Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).
            <br/>
            The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.
          </comment>
        </bits>
      </reg>
      <reg name="cmd_set" protect="rw">
        <bits access="rs" name="ri" pos="0" rst="0">
          <comment>Ring indicator. When write '1', set RI bit. When read, get RI bit
            value.</comment>
        </bits>
        <bits access="rs" name="dcd" pos="1" rst="0">
          <comment>Data carrier detect. When write '1', set DCD bit. When read, get DCD
            bit value.</comment>
        </bits>
        <bits access="rs" name="dsr" pos="2" rst="0">
          <comment>Data set ready. When write '1', set RI bit. When read, get RI bit
            value.</comment>
        </bits>
        <bits access="rs" name="tx break control" pos="3" rst="0">
          <comment>Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared.</comment>
        </bits>
        <bits access="rs" name="tx finish n wait" pos="4" rst="0">
          <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
        </bits>
        <bits access="rs" name="rts" pos="5" rst="0">
          <comment>
            Controls the Uart_RTS output.
            <br/>
            0 = the Uart_RTS will be inactive high (Rx not allowed).
            <br/>
            1 = the Uart_RTS will be active low (Rx allowed).
          </comment>
        </bits>
        <bits access="r" name="rx fifo reset" pos="6" rst="0">
          <comment>Writing a 1 to this bit resets and flushes the Receive Fifo.
      This bit does not need to be cleared.</comment>
        </bits>
        <bits access="r" name="tx fifo reset" pos="7" rst="0">
          <comment>Writing a 1 to this bit resets and flushes the Transmit Fifo.
      This bit does not need to be cleared.</comment>
        </bits>
      </reg>
      <reg name="cmd_clr" protect="rw">
        <bits access="rc" name="ri" pos="0" rst="0">
          <comment>Ring indicator. When write '1', clear RI bit. When read, get RI bit
            value.</comment>
        </bits>
        <bits access="rc" name="dcd" pos="1" rst="0">
          <comment>Data carrier detect. When write '1', clear DCD bit. When read, get DCD
            bit value.</comment>
        </bits>
        <bits access="rc" name="dsr" pos="2" rst="0">
          <comment>Data set ready. When write '1', clear RI bit. When read, get RI bit
            value.</comment>
        </bits>
        <bits access="rc" name="tx break control" pos="3" rst="0">
          <comment>Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared.</comment>
        </bits>
        <bits access="rc" name="tx finish n wait" pos="4" rst="0">
          <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
        </bits>
        <bits access="rc" name="rts" pos="5" rst="0">
          <comment>
            Controls the Uart_RTS output.
            <br/>
            0 = the Uart_RTS will be inactive high.
            <br/>
            1 = the Uart_RTS will be active low.
          </comment>
        </bits>
      </reg>
      <reg name="auto ratio" protect="r">
        <bits access="r" name="auto ratio" pos="15:0" rst="0">
          <comment>Auto mode ratio.</comment>
        </bits>
      </reg>
      <reg name="xon" protect="rw">
        <bits access="rw" name="xon" pos="7:0" rst="8'h11">
          <comment>XON character value.</comment>
        </bits>
      </reg>
      <reg name="xoff" protect="rw">
        <bits access="rw" name="xoff" pos="7:0" rst="8'h13">
          <comment>XOFF character value.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51700000" name="UART1" type="UART"/>
    <instance address="0x51400000" name="UART2" type="UART"/>
    <instance address="0x51401000" name="UART3" type="UART"/>
    <instance address="0x04400000" name="UART4" type="UART"/>
    <instance address="0x04401000" name="UART5" type="UART"/>
    <instance address="0x04402000" name="UART6" type="UART"/>
  </archive>
  <archive relative="efuse.xml">
    <module category="System" name="EFUSE">
      <hole size="64"/>
      <reg name="efuse_all0_index" protect="rw">
        <bits access="rw" name="efuse_all0_start_index" pos="31:16" rst="0">
      </bits>
        <bits access="rw" name="efuse_all0_end_index" pos="15:0" rst="127">
      </bits>
      </reg>
      <reg name="efuse_mode_ctrl" protect="rw">
        <bits access="rw" name="efuse_all0_check_start" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_cfg1" protect="rw">
        <bits access="rw" name="tpgm_time_cnt2" pos="24:16" rst="310">
      </bits>
        <bits access="rw" name="tpgm_time_cnt1" pos="8:0" rst="310">
      </bits>
      </reg>
      <reg name="efuse_ip_ver" protect="r">
        <bits access="r" name="efuse_type" pos="17:16" rst="0">
      </bits>
        <bits access="r" name="efuse_ip_ver" pos="15:0" rst="2048">
      </bits>
      </reg>
      <reg name="efuse_cfg0" protect="rw">
        <bits access="rw" name="clk_efs_div" pos="31:24" rst="0">
      </bits>
        <bits access="rw" name="efuse_strobe_low_width" pos="23:16" rst="0">
      </bits>
        <bits access="rw" name="tpgm_time_cnt" pos="8:0" rst="310">
      </bits>
      </reg>
      <reg name="efuse_cfg2" protect="rw">
        <bits access="rw" name="tpgm_time_bist" pos="24:16" rst="310">
      </bits>
        <bits access="rw" name="tpgm_time_cnt3" pos="8:0" rst="310">
      </bits>
      </reg>
      <reg name="efuse_ns_en" protect="rw">
        <bits access="rw" name="ns_lock_bit_wr_en" pos="4" rst="0">
      </bits>
        <bits access="rw" name="ns_margin_rd_enable" pos="3" rst="0">
      </bits>
        <bits access="rw" name="double_bit_en_ns" pos="2" rst="0">
      </bits>
        <bits access="rw" name="ns_auto_check_enable" pos="1" rst="0">
      </bits>
        <bits access="rw" name="ns_vdd_en" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_ns_err_flag" protect="r">
        <bits access="r" name="ns_all0_check_flag" pos="13" rst="0">
      </bits>
        <bits access="r" name="ns_enk_err_flag" pos="12" rst="0">
      </bits>
        <bits access="r" name="ns_magnum_wr_flag" pos="11" rst="0">
      </bits>
        <bits access="r" name="ns_block0_rd_flag" pos="10" rst="0">
      </bits>
        <bits access="r" name="ns_vdd_on_rd_flag" pos="9" rst="0">
      </bits>
        <bits access="r" name="ns_pg_en_wr_flag" pos="8" rst="0">
      </bits>
        <bits access="r" name="ns_word1_prot_flag" pos="5" rst="0">
      </bits>
        <bits access="r" name="ns_word0_prot_flag" pos="4" rst="0">
      </bits>
        <bits access="r" name="ns_word1_err_flag" pos="1" rst="0">
      </bits>
        <bits access="r" name="ns_word0_err_flag" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_ns_flag_clr" protect="rw">
        <bits access="rw" name="ns_all0_check_clr" pos="13" rst="0">
      </bits>
        <bits access="rw" name="ns_enk_err_clr" pos="12" rst="0">
      </bits>
        <bits access="rw" name="ns_magnum_wr_clr" pos="11" rst="0">
      </bits>
        <bits access="rw" name="ns_block0_rd_clr" pos="10" rst="0">
      </bits>
        <bits access="rw" name="ns_vdd_on_rd_clr" pos="9" rst="0">
      </bits>
        <bits access="rw" name="ns_pg_en_wr_clr" pos="8" rst="0">
      </bits>
        <bits access="rw" name="ns_word1_prot_clr" pos="5" rst="0">
      </bits>
        <bits access="rw" name="ns_word0_prot_clr" pos="4" rst="0">
      </bits>
        <bits access="rw" name="ns_word1_err_clr" pos="1" rst="0">
      </bits>
        <bits access="rw" name="ns_word0_err_clr" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_ns_magic_number" protect="rw">
        <bits access="rw" name="ns_magic_nubmer" pos="15:0" rst="0">
      </bits>
      </reg>
      <hole size="128"/>
      <reg name="efuse_s_en" protect="rw">
        <bits access="rw" name="s_lock_bit_wr_en" pos="4" rst="0">
      </bits>
        <bits access="rw" name="s_margin_rd_enable" pos="3" rst="0">
      </bits>
        <bits access="rw" name="double_bit_en_s" pos="2" rst="0">
      </bits>
        <bits access="rw" name="s_auto_check_enable" pos="1" rst="0">
      </bits>
        <bits access="rw" name="s_vdd_en" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_s_err_flag" protect="r">
        <bits access="r" name="s_all0_check_flag" pos="13" rst="0">
      </bits>
        <bits access="r" name="s_enk_err_flag" pos="12" rst="0">
      </bits>
        <bits access="r" name="s_magnum_wr_flag" pos="11" rst="0">
      </bits>
        <bits access="r" name="s_block0_rd_flag" pos="10" rst="0">
      </bits>
        <bits access="r" name="s_vdd_on_rd_flag" pos="9" rst="0">
      </bits>
        <bits access="r" name="s_pg_en_wr_flag" pos="8" rst="0">
      </bits>
        <bits access="r" name="s_word1_prot_flag" pos="5" rst="0">
      </bits>
        <bits access="r" name="s_word0_prot_flag" pos="4" rst="0">
      </bits>
        <bits access="r" name="s_word1_err_flag" pos="1" rst="0">
      </bits>
        <bits access="r" name="s_word0_err_flag" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_s_flag_clr" protect="rw">
        <bits access="rw" name="s_all0_check_clr" pos="13" rst="0">
      </bits>
        <bits access="rw" name="s_enk_err_clr" pos="12" rst="0">
      </bits>
        <bits access="rw" name="s_magnum_wr_clr" pos="11" rst="0">
      </bits>
        <bits access="rw" name="s_block0_rd_clr" pos="10" rst="0">
      </bits>
        <bits access="rw" name="s_vdd_on_rd_clr" pos="9" rst="0">
      </bits>
        <bits access="rw" name="s_pg_en_wr_clr" pos="8" rst="0">
      </bits>
        <bits access="rw" name="s_word1_prot_clr" pos="5" rst="0">
      </bits>
        <bits access="rw" name="s_word0_prot_clr" pos="4" rst="0">
      </bits>
        <bits access="rw" name="s_word1_err_clr" pos="1" rst="0">
      </bits>
        <bits access="rw" name="s_word0_err_clr" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_s_magic_number" protect="rw">
        <bits access="rw" name="s_magic_nubmer" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_fw_cfg" protect="rw">
        <bits access="rw" name="access_prot" pos="1" rst="0">
      </bits>
        <bits access="rw" name="conf_prot" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_pw_swt" protect="rw">
        <bits access="rw" name="ns_s_pg_en" pos="2" rst="0">
      </bits>
        <bits access="rw" name="efs_enk2_on" pos="1" rst="1">
      </bits>
        <bits access="rw" name="efs_enk1_on" pos="0" rst="0">
      </bits>
      </reg>
      <hole size="128"/>
      <reg name="pw_on_rd_end_flag" protect="r">
        <bits access="r" name="pw_on_rd_end_flag" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="ns_s_flag" protect="r">
        <bits access="r" name="ns_s_flag" pos="0" rst="1">
      </bits>
      </reg>
      <reg name="por_read_data_sp" protect="r">
        </reg>
      <reg name="por_read_data_sp1" protect="r">
        </reg>
      <reg name="block3" protect="r">
        </reg>
      <reg name="block89" protect="r">
        </reg>
      <reg name="efuse_enc_bypass_en" protect="rw">
        <bits access="rw" name="efuse_enc_bypass_en" pos="7:0" rst="0">
      </bits>
      </reg>
    </module>
    <instance address="0x51200000" name="EFUSE" type="EFUSE"/>
  </archive>
  <archive relative="keypad.xml">
    <module category="Periph" name="KEYPAD">
      <var name="KEY_NB" value="36">
        <comment>Number of key in the keypad</comment>
      </var>
      <var name="LOW_KEY_NB" value="30">
        <comment>Number of key in the low data register</comment>
      </var>
      <var name="HIGH_KEY_NB" value="6">
        <comment>Number of key in the high data register</comment>
      </var>
      <reg name="kp_data_l" protect="r">
        <comment>For keys in column Idx_KeyOut(from 0 to 3) and in line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_L(Idx_KeyOut*8+Idx_KeyIn) :</comment>
      </reg>
      <reg name="kp_data_h" protect="r">
        <comment>For keys in column Idx_KeyOut(from 4 to 7) and line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_H(Idx_KeyIn*8-32+Idx_KeyIn):</comment>
      </reg>
      <reg name="kp_status" protect="r">
        <bits access="r" name="keyin_status" pos="7:0" rst="0x08">
          <comment>
            For keys in lines status
            <br/>
            0 = Released
            <br/>
            1 = Pressed
          </comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="r" name="kp_on" pos="31" rst="0">
          <comment>
            Indicate Key ON pressing status :
            <br/>
            0 = Release
            <br/>
            1 = Pressed
          </comment>
          <options>
            <default/>
            <mask/>
            <shift/>
          </options>
        </bits>
      </reg>
      <reg name="kp_ctrl" protect="rw">
        <bits access="rw" name="kp_en" pos="0" rst="0">
          <comment>
            This bit enables key detection. If this bit is '0', the key detection function
            is disabled. Key ON is an exception, it can be still detected and generate key interrupt
            even if KP_En = '0', however in this case, the debouncing time configuration in key
            control register is ignored and the key ON state is considerred to be stable if it keeps
            same in consecutive 2 cycles of 16KHz clock.
            <br/>
            <br/>
            0 = keypad disable
            <br/>
            1 = keypad enable
          </comment>
        </bits>
        <bits access="rw" name="kp_dbn_time" pos="9:2" rst="0">
          <comment>De-bounce time = (KP_DBN_TIME + 1) * SCAN_TIME, SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_DBN_TIME = 7, KP_OUT_MASK = &quot;111111&quot;, then De-bounce time = (7+1)*0.3125*6=15 ms. The maximum debounce time is 480 ms.</comment>
        </bits>
        <bits access="rw" name="kp_itv_time" pos="15:10" rst="0">
          <comment>Configure interval of generating an IRQ if one key or several keys are pressed long time. Interval of IRQ generation = (KP_ITV_Time + 1) * (KP_DBN_TIME + 1) * SCAN_TIME. SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_ITV_TIME = 7, KP_DBN_TIME = 7, KP_OUT_MASK = &quot;111111&quot;, then De-bounce time = (7+1)*(7+1)*0.3125*6=120 ms.</comment>
        </bits>
        <bits access="rw" name="kp_in_mask" pos="23:16" rst="0xff">
          <comment>
            each bit masks one input lines.
            <br/>
            '1' = enabled
            <br/>
             '0' = disabled
            <br/>
            The Key In pins 0 to 5 are muxed with the boot mode pins, latched during Reset.
            <br/>
             Key_In 0: BOOT_MODE_NO_AUTO_PU.
            <br/>
             Key_In 1: BOOT_MODE_FORCE_MONITOR.
            <br/>
             Key_In 2: BOOT_MODE_UART_MONITOR_ENABLE.
            <br/>
             Key_In 3: BOOT_MODE_USB_MONITOR_DISABLE.
            <br/>
             Key_In 4: reserved
          </comment>
        </bits>
        <bits access="rw" name="kp_out_mask" pos="31:24" rst="0xff">
          <comment>
            each bit masks one output lines.
            <br/>
            '1' = enabled
            <br/>
             '0' = disabled
          </comment>
        </bits>
      </reg>
      <reg name="kp_irq_mask" protect="rw">
        <bits access="rw" name="kp_evt0_irq_mask" pos="0" rst="0">
          <comment>
            This bit mask keypad irq generated by event0 (key press or key release event, not including all keys release event which is event1).
            <br/>
            0 = keypad event irq disable
            <br/>
            1 = keypad event irq enable
          </comment>
        </bits>
        <bits access="rw" name="kp_evt1_irq_mask" pos="1" rst="0">
          <comment>
            This bit mask keypad irq generated by event1 (all keys release event).
            <br/>
            0 = keypad event irq disable
            <br/>
            1 = keypad event irq enable
          </comment>
        </bits>
        <bits access="rw" name="kp_itv_irq_mask" pos="2" rst="0">
          <comment>
            This bit mask keypad irq generated by key pressed long time (generated each interval configured in KP_ITV_Time.
            <br/>
            0 = keypad interval irq disable
            <br/>
            1 = keypad interval irq enable
          </comment>
        </bits>
      </reg>
      <reg name="kp_irq_cause" protect="r">
        <bits access="r" name="kp_evt0_irq_cause" pos="0" rst="0">
          <comment>keypad event0(key press or key release event, not including all keys release which is event1) IRQ cause.</comment>
        </bits>
        <bits access="r" name="kp_evt1_irq_cause" pos="1" rst="0">
          <comment>keypad event1(all keys release event) IRQ cause.</comment>
        </bits>
        <bits access="r" name="kp_itv_irq_cause" pos="2" rst="0">
          <comment>keypad interval irq cause.</comment>
        </bits>
        <bits access="r" name="kp_evt0_irq_status" pos="16" rst="0">
          <comment>keypad event0(key press or key release event, not including all keys release which is event1) irq status.</comment>
        </bits>
        <bits access="r" name="kp_evt1_irq_status" pos="17" rst="0">
          <comment>keypad event1(all keys release event) irq status.</comment>
        </bits>
        <bits access="r" name="kp_itv_irq_status" pos="18" rst="0">
          <comment>keypad interval irq status.</comment>
        </bits>
      </reg>
      <reg name="kp_irq_clr" protect="rw">
        <bits access="c" name="kp_irq_clr" pos="0" rst="0">
          <comment>Write '1' to this bit clears key IRQ.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51706000" name="KEYPAD" type="KEYPAD"/>
  </archive>
  <archive relative="gpio.xml">
    <var name="IDX_GPIO_DCON" value="0"/>
    <var name="IDX_GPO_CHG" value="0"/>
    <module category="Periph" name="GPIO">
      <reg name="gpio_oen_val" protect="rw">
        <comment>Set the direction of the GPIO n.</comment>
      </reg>
      <reg name="gpio_oen_set_out" protect="rw">
        <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
      </reg>
      <reg name="gpio_oen_set_in" protect="rw">
        <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
      </reg>
      <reg name="gpio_val_reg" protect="rw">
        <comment>When write, update the output value. When read, get the input
      value.</comment>
      </reg>
      <reg name="gpio_set_reg" protect="rw">
        <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
      </reg>
      <reg name="gpio_clr_reg" protect="rw">
        <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value.</comment>
      </reg>
      <reg name="gpint_ctrl_r_set_reg" protect="rw">
        <comment>'Write '1' will set GPIO interrupt mask for rising edge and
      level high. When read, get the GPIO interrupt mask for rising edge and
      level high.</comment>
      </reg>
      <reg name="gpint_ctrl_r_clr_reg" protect="rw">
        <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
      level high.</comment>
      </reg>
      <reg name="int_clr" protect="w">
        <comment>'Write '1' will clear GPIO interrupt.</comment>
      </reg>
      <reg name="int_status" protect="r">
        <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      </reg>
      <reg name="chg_ctrl" protect="rw">
        <bits access="rw" display="hex" name="out_time" pos="3:0" rst="0xf">
          <comment>
            time for which GPIO0 is set to output mode, after a start read
            DCON command is issued.
            <br/>
            The output time = (OUT_TIME+1)*30.5us.
          </comment>
        </bits>
        <bits access="rw" display="hex" name="wait_time" pos="9:4" rst="0x3f">
          <comment>
            time for which GPIO0 should wait before reading DC_ON, after
            a start read DCON command is issued.
            <br/>
            The wait time = (WAIT_TIME+1)*30.5us.
            <br/>
            NOTE: wait_time must be strictly greater than out_time;
          </comment>
        </bits>
        <bits access="rw" display="hex" name="int_mode" pos="17:16" rst="0x3">
          <comment>
            interruption mode of GPIO0 in mode DC_ON detection.
            <br/>
          </comment>
          <options>
            <option name="L2H" value="0">
              <comment>&quot;00&quot; = send IRQ if last read DCON is '0' and now is '1'.</comment>
            </option>
            <option name="H2L" value="1">
              <comment>&quot;01&quot; = send IRQ if last read DCON is '1' and now is '0'.</comment>
            </option>
            <option name="RR" value="3">
              <comment>&quot;11&quot; = send IRQ every time read is ready.</comment>
            </option>
          </options>
        </bits>
      </reg>
      <reg name="chg_cmd" protect="w">
        <bits access="s" name="dcon_mode_set" pos="0" rst="0">
          <comment>Write '1' to set GPIO0 to charger DCON detect mode.</comment>
        </bits>
        <bits access="s" name="chg_mode_set" pos="4" rst="0">
          <comment>Write '1' to set GPO0 to charger watchdog mode.</comment>
        </bits>
        <bits access="c" name="dcon_mode_clr" pos="8" rst="0">
          <comment>Write '1' to clear charger DCON detect mode of GPIO0.</comment>
        </bits>
        <bits access="c" name="chg_mode_clr" pos="12" rst="0">
          <comment>Write '1' to clear the charger watchdog mode of GPO0.</comment>
        </bits>
        <bits access="s" name="chg_down" pos="24" rst="0">
          <comment>Write '1' to generate a pulse of '0' on GPO0 for 16 CLK_OSC cycles.</comment>
        </bits>
      </reg>
      <reg name="gpo_set_reg" protect="rw">
        <bits access="rs" display="hex" name="gpo_set" pos="7:0" rst="0xaa">
          <comment>'Write '1' will set GPO output value. When read, get the GPO
      output value.</comment>
        </bits>
      </reg>
      <reg name="gpo_clr_reg" protect="rw">
        <bits access="rc" display="hex" name="gpo_clr" pos="7:0" rst="0xaa">
          <comment>'Write '1' will clear GPO output value. When read, get the GPO
      output value.</comment>
        </bits>
      </reg>
      <reg name="gpint_ctrl_f_set_reg" protect="rw">
        <comment>'Write '1' will set GPIO interrupt mask for rising edge and
      level high. When read, get the GPIO interrupt mask for rising edge and
      level high.</comment>
      </reg>
      <reg name="gpint_ctrl_f_clr_reg" protect="rw">
        <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
      level high.</comment>
      </reg>
      <reg name="dbn_en_set_reg" protect="rw">
        <comment>'Write '1' will enable debounce mechanism.</comment>
      </reg>
      <reg name="dbn_en_clr_reg" protect="rw">
        <comment>'Write '1' will disable debounce mechanism.</comment>
      </reg>
      <reg name="gpint_mode_set_reg" protect="rw">
        <comment>Write '1' will set interruption mode to level.</comment>
      </reg>
      <reg name="gpint_mode_clr_reg" protect="rw">
        <comment>Write '1' will set interruption mode to edge
      triggered.</comment>
      </reg>
    </module>
    <instance address="0x51703000" name="GPIO1" type="GPIO"/>
    <instance address="0x51503000" name="GPIO2" type="GPIO"/>
  </archive>
</bigarchive>