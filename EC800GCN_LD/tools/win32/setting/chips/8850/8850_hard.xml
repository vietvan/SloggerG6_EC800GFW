<?xml version="1.0" ?>
<bigarchive>
  <archive relative="globals.xml">
    <var name="SYS_IRQ_ID_AP_IMEM" value="0"/>
    <var name="SYS_IRQ_ID_SPIFLASH1" value="1"/>
    <var name="SYS_IRQ_ID_SPIFLASH2" value="2"/>
    <var name="SYS_IRQ_ID_GOUDA" value="3"/>
    <var name="SYS_IRQ_ID_AP_AXIDMA" value="4"/>
    <var name="SYS_IRQ_ID_AP_AXIDMA_SECURITY" value="5"/>
    <var name="SYS_IRQ_ID_AP_AXIDMA_UNSECURITY" value="6"/>
    <var name="SYS_IRQ_ID_USBC" value="7"/>
    <var name="SYS_IRQ_ID_MED" value="8"/>
    <var name="SYS_IRQ_ID_CE_PUB" value="9"/>
    <var name="SYS_IRQ_ID_CE_SEC" value="10"/>
    <var name="SYS_IRQ_ID_UART4" value="11"/>
    <var name="SYS_IRQ_ID_UART5" value="12"/>
    <var name="SYS_IRQ_ID_UART6" value="13"/>
    <var name="SYS_IRQ_ID_SPI1" value="14"/>
    <var name="SYS_IRQ_ID_SDMMC" value="15"/>
    <var name="SYS_IRQ_ID_CAMERA" value="16"/>
    <var name="SYS_IRQ_ID_LZMA" value="17"/>
    <var name="SYS_IRQ_ID_AP_BUSMON" value="18"/>
    <var name="SYS_IRQ_ID_EMMC" value="19"/>
    <var name="SYS_IRQ_ID_TIMER1" value="20"/>
    <var name="SYS_IRQ_ID_TIMER1_OS" value="21"/>
    <var name="SYS_IRQ_ID_TIMER2" value="22"/>
    <var name="SYS_IRQ_ID_TIMER2_OS" value="23"/>
    <var name="SYS_IRQ_ID_I2C1" value="24"/>
    <var name="SYS_IRQ_ID_I2C2" value="25"/>
    <var name="SYS_IRQ_ID_GPT3_0" value="26"/>
    <var name="SYS_IRQ_ID_GPT3_1" value="27"/>
    <var name="SYS_IRQ_ID_GPT3_2" value="28"/>
    <var name="SYS_IRQ_ID_GPT3_3" value="29"/>
    <var name="SYS_IRQ_ID_GPT3_4" value="30"/>
    <var name="SYS_IRQ_ID_GPT3_5" value="31"/>
    <var name="SYS_IRQ_ID_GPT3_6" value="32"/>
    <var name="SYS_IRQ_ID_PMU_APCPU" value="33"/>
    <var name="SYS_IRQ_ID_CLK_MNT32K" value="34"/>
    <var name="SYS_IRQ_ID_CLK_MNT26M" value="35"/>
    <var name="SYS_IRQ_ID_SFW_AP_IFC" value="36"/>
    <var name="SYS_IRQ_ID_SFW_AP_AHB" value="37"/>
    <var name="SYS_IRQ_ID_MFW_AP_IMEM" value="38"/>
    <var name="SYS_IRQ_ID_MFW_SPIFLASH1" value="39"/>
    <var name="SYS_IRQ_ID_MFW_SPIFLASH2" value="40"/>
    <var name="SYS_IRQ_ID_AP_WD_RST" value="41"/>
    <var name="SYS_IRQ_ID_AP_TZPC_RST" value="42"/>
    <var name="SYS_IRQ_ID_ADIMST" value="43"/>
    <var name="SYS_IRQ_ID_IDLE_LPS" value="44"/>
    <var name="SYS_IRQ_ID_GPIO1" value="45"/>
    <var name="SYS_IRQ_ID_KEYPAD" value="46"/>
    <var name="SYS_IRQ_ID_GPT1" value="47"/>
    <var name="SYS_IRQ_ID_GPIO2" value="48"/>
    <var name="SYS_IRQ_ID_I2C3" value="49"/>
    <var name="SYS_IRQ_ID_MAILBOX_ARM_AP" value="50"/>
    <var name="SYS_IRQ_ID_AUD_2AD" value="51"/>
    <var name="SYS_IRQ_ID_GPT2_0" value="52"/>
    <var name="SYS_IRQ_ID_GPT2_1" value="53"/>
    <var name="SYS_IRQ_ID_GPT2_2" value="54"/>
    <var name="SYS_IRQ_ID_UART1" value="55"/>
    <var name="SYS_IRQ_ID_UART2" value="56"/>
    <var name="SYS_IRQ_ID_UART3" value="57"/>
    <var name="SYS_IRQ_ID_SPI2" value="58"/>
    <var name="SYS_IRQ_ID_DEBUG_UART" value="59"/>
    <var name="SYS_IRQ_ID_DEBUG_HOST" value="60"/>
    <var name="SYS_IRQ_ID_AIF_IFC0" value="61"/>
    <var name="SYS_IRQ_ID_AIF_IFC1" value="62"/>
    <var name="SYS_IRQ_ID_SFW_LPS_IFC" value="63"/>
    <var name="SYS_IRQ_ID_SFW_AON_IFC" value="64"/>
    <var name="SYS_IRQ_ID_SFW_AON_AHB" value="65"/>
    <var name="SYS_IRQ_ID_MFW_AON_IMEM_INT" value="66"/>
    <var name="SYS_IRQ_ID_MSTFLT_AON_CP" value="67"/>
    <var name="SYS_IRQ_ID_MSTFLT_AON_RF" value="68"/>
    <var name="SYS_IRQ_ID_CP_IDLE_H" value="69"/>
    <var name="SYS_IRQ_ID_CP_IDLE2_H" value="70"/>
    <var name="SYS_IRQ_ID_LTEM1_FRAME" value="71"/>
    <var name="SYS_IRQ_ID_LTEM2_FRAME" value="72"/>
    <var name="SYS_IRQ_ID_LTEM3_FRAME" value="73"/>
    <var name="SYS_IRQ_ID_RC26M_CALIB" value="74"/>
    <var name="SYS_IRQ_ID_PWRCTRL" value="75"/>
    <var name="SYS_IRQ_ID_PMIC" value="76"/>
    <var name="SYS_IRQ_ID_MFW_AON_IMEM_RST" value="77"/>
    <var name="SYS_IRQ_ID_RTC_TIMER" value="78"/>
    <var name="SYS_IRQ_ID_CP_IRQ" value="79"/>
    <var name="SYS_IRQ_ID_CP_FIQ" value="80"/>
    <var name="SYS_IRQ_ID_CP_BUSMON" value="81"/>
    <var name="SYS_IRQ_ID_CP_WD_RST" value="82"/>
    <var name="SYS_IRQ_ID_FREQ_BIAS" value="83"/>
    <var name="SYS_IRQ_ID_CP_WIFI" value="84"/>
    <var name="SYS_IRQ_ID_PPS" value="85"/>
    <var name="SYS_IRQ_ID_RFT_TOP" value="86"/>
    <var name="SYS_IRQ_ID_GNSS_BB" value="87"/>
    <var name="SYS_IRQ_ID_GNSS_BB_EXCEPT" value="88"/>
    <var name="SYS_IRQ_ID_GNSS_NOMASK_NEXT_MEASINT" value="89"/>
    <var name="SYS_IRQ_ID_RF_WD_RST" value="90"/>
    <var name="SYS_IRQ_ID_DMC" value="91"/>
    <var name="SYS_IRQ_ID_PAGE_SPY" value="92"/>
    <var name="SYS_IRQ_ID_MFW_PUB_INT" value="93"/>
    <var name="SYS_IRQ_ID_MFW_PUB_RST" value="94"/>
    <var name="SYS_IRQ_ID_TIMER5" value="95"/>
    <var name="SYS_IRQ_ID_TIMER5_OS" value="96"/>
    <var name="NB_SYS_IRQ" value="97"/>
    <var name="NB_BITS_ADDR" value="32"/>
  </archive>
  <archive relative="sys_ctrl.xml">
    <module category="System" name="SYS_CTRL">
      <reg name="aon_soft_rst_ctrl0" protect="rw">
        <comment>AON_SOFT_RST_CTRL0</comment>
        <bits access="rw" name="scc_soft_rst" pos="29" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="usbphy_soft_rst" pos="28" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="ana_wrap2_soft_rst" pos="27" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="ana_wrap1_soft_rst" pos="26" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aon_imem_soft_rst" pos="25" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="iomux_soft_rst" pos="24" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="spi2_soft_rst" pos="23" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="sysmail_soft_rst" pos="22" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="mon_ctrl_soft_rst" pos="21" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="i2c3_soft_rst" pos="20" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="gpt2_soft_rst" pos="19" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="gpio2_soft_rst" pos="18" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aud_2ad_soft_rst" pos="17" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="idle_timer_soft_rst" pos="16" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="uart3_soft_rst" pos="15" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="uart2_soft_rst" pos="14" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aif_soft_rst" pos="13" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="dbg_host_soft_rst" pos="12" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aon_ifc_soft_rst" pos="11" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="spinlock_soft_rst" pos="10" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="adimst_soft_rst" pos="9" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="lps2aon_soft_rst" pos="8" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aon2lps_soft_rst" pos="7" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="lps_ifc_soft_rst" pos="6" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="efuse_soft_rst" pos="5" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="djtag_ctrl_soft_rst" pos="4" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="dap_soft_rst" pos="3" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="async_bridge_soft_rst" pos="2" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="ahb2axi_soft_rst" pos="1" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="ahbmux_soft_rst" pos="0" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
      </reg>
      <reg name="clken_lte" protect="rw">
        <comment>CLKEN_LTE</comment>
        <bits access="rw" name="dbgio_func_en" pos="14" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="hsdl_func_en" pos="13" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="rxcapt_func_en" pos="12" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="rfad_func_en" pos="11" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="dlfft_func_en" pos="10" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="csirs_func_en" pos="9" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="pusch_func_en" pos="8" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="uldft_func_en" pos="7" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="otdoa_func_en" pos="6" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="iddet_func_en" pos="5" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="measpwr_func_en" pos="4" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="ldtc1_func_en" pos="3" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="ldtc_func_en" pos="2" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="coeff_func_en" pos="1" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="txrx_func_en" pos="0" rst="0x0">
          <comment>LTE module function clock software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="clken_lte_intf" protect="rw">
        <comment>CLKEN_LTE_INTF</comment>
        <bits access="rw" name="dbgio_intf_en" pos="14" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="hsdl_intf_en" pos="13" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="rxcapt_intf_en" pos="12" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="rfad_intf_en" pos="11" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="dlfft_intf_en" pos="10" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="csirs_intf_en" pos="9" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="pusch_intf_en" pos="8" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="uldft_intf_en" pos="7" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="otdoa_intf_en" pos="6" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="iddet_intf_en" pos="5" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="measpwr_intf_en" pos="4" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="ldtc1_intf_en" pos="3" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="ldtc_intf_en" pos="2" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="coeff_intf_en" pos="1" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
        <bits access="rw" name="txrx_intf_en" pos="0" rst="0x0">
          <comment>LTE module interface clock software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="rstctrl_lte" protect="rw">
        <comment>RSTCTRL_LTE</comment>
        <bits access="rw" name="dbgio_soft_rst" pos="15" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="hsdl_soft_rst" pos="14" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="rxcapt_soft_rst" pos="13" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="rfad_soft_rst" pos="12" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="dlfft_soft_rst" pos="11" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="csirs_soft_rst" pos="10" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="pusch_soft_rst" pos="9" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="uldft_soft_rst" pos="8" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="otdoa_soft_rst" pos="7" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="iddet_soft_rst" pos="6" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="measpwr_soft_rst" pos="5" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="ldtc1_soft_rst" pos="4" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="ldtc_soft_rst" pos="3" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="coeff_soft_rst" pos="2" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="txrx_rx_soft_rst" pos="1" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
        <bits access="rw" name="txrx_tx_soft_rst" pos="0" rst="0x0">
          <comment>LTE module reset software register control bit
0:no reset
1:reset</comment>
        </bits>
      </reg>
      <reg name="lte_autogate_mode" protect="rw">
        <comment>LTE_AUTOGATE_MODE</comment>
        <bits access="rw" name="lte_autogate_mode" pos="0" rst="0x0">
          <comment>0: LTE module clock auto gating individual
1: LTE modules invide into two parties : &quot;uplink&quot; and &quot;downlink&quot;, and auto gating individual</comment>
        </bits>
      </reg>
      <reg name="lte_autogate_en" protect="rw">
        <comment>LTE_AUTOGATE_EN</comment>
        <bits access="rw" name="uplink_intf_autogate_en" pos="27" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="downlink_intf_autogate_en" pos="26" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uplink_func_autogate_en" pos="25" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="downlink_func_autogate_en" pos="24" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dlfft_intf_autogate_en" pos="21" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="csirs_intf_autogate_en" pos="20" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pusch_intf_autogate_en" pos="19" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uldft_intf_autogate_en" pos="18" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="otdoa_intf_autogate_en" pos="17" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="iddet_intf_autogate_en" pos="16" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="measpwr_intf_autogate_en" pos="15" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ldtc1_intf_autogate_en" pos="14" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ldtc_intf_autogate_en" pos="13" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="coeff_intf_autogate_en" pos="12" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="txrx_intf_autogate_en" pos="11" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dlfft_func_autogate_en" pos="10" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="csirs_func_autogate_en" pos="9" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pusch_func_autogate_en" pos="8" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uldft_func_autogate_en" pos="7" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="otdoa_func_autogate_en" pos="6" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="iddet_func_autogate_en" pos="5" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="measpwr_func_autogate_en" pos="4" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ldtc1_func_autogate_en" pos="3" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ldtc_func_autogate_en" pos="2" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="coeff_func_autogate_en" pos="1" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="txrx_func_autogate_en" pos="0" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="lte_autogate_delay_num" protect="rw">
        <comment>LTE_AUTOGATE_DELAY_NUM</comment>
        <bits access="rw" name="lte_autogate_delay_number" pos="7:0" rst="0x10">
          <comment>When LTE autogating function enable, After module &quot;running&quot; signal was pull down, a counter begin to count from zero.LTE modules clock will be gated when the counter counts to this number value.</comment>
        </bits>
      </reg>
      <reg name="aon_lpc_ctrl" protect="rw">
        <comment>AON_LPC_CTRL</comment>
        <bits access="rw" name="lpc_pd_num" pos="31:16" rst="0x0">
          <comment>waiting time of bus entered low power mode,calculated by bus clock</comment>
        </bits>
        <bits access="rw" name="lpc_pu_num" pos="15:8" rst="0x0">
          <comment>waiting time of bus entered normal power mode,calculated by bus clock</comment>
        </bits>
        <bits access="rw" name="lpc_frc_en" pos="1" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="lpc_en" pos="0" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="aon_clock_en0" protect="rw">
        <comment>AON_CLOCK_EN0</comment>
        <bits access="rw" name="tsx_cal_en" pos="31" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="clock_out_dbg_en" pos="30" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="codec_mclock_en" pos="29" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="djtag_cfg_en" pos="28" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sdio_aon_en" pos="27" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sdio_1x_lte_en" pos="26" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sdio_1x_ap_en" pos="25" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="usb_32k_en" pos="24" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gnss_32k_en" pos="23" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dap_en" pos="22" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="funcdma_en" pos="21" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dbg_host_en" pos="20" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uart3_en" pos="19" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uart2_en" pos="18" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="idle_timer_en" pos="17" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aif_en" pos="16" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="mon_ctrl_en" pos="15" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gpio2_en" pos="14" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="spi2_en" pos="13" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aud2ad_en" pos="12" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gpt2_en" pos="11" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="lpsifc_en" pos="10" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aonifc_en" pos="9" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon2pub_en" pos="8" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="adimst_en" pos="7" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="efuse_ctrl_en" pos="6" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="spinlock_en" pos="5" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_imem_en" pos="4" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="lps2aon_en" pos="3" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon2lps_en" pos="2" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahbmux_en" pos="1" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahb_matrix_en" pos="0" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="aon_clock_en1" protect="rw">
        <comment>AON_CLOCK_EN1</comment>
        <bits access="rw" name="usb_ahb_ap_en" pos="11" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="usb_ahb_usb_en" pos="10" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="scc_en" pos="9" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="fw_aon_en" pos="8" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="calib_rc_en" pos="7" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahb_rf_en" pos="6" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahb_pub_en" pos="5" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahb_cp_en" pos="4" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_ahb_ap_en" pos="3" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="psram_en" pos="2" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="usb_ref_en" pos="1" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="djtag_tck_en" pos="0" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="aon_clock_auto_sel0" protect="rw">
        <comment>AON_CLOCK_AUTO_SEL0</comment>
      </reg>
      <reg name="aon_clock_auto_sel1" protect="rw">
        <comment>AON_CLOCK_AUTO_SEL1</comment>
      </reg>
      <reg name="aon_clock_auto_sel2" protect="rw">
        <comment>AON_CLOCK_AUTO_SEL2</comment>
      </reg>
      <reg name="aon_clock_auto_sel3" protect="rw">
        <comment>AON_CLOCK_AUTO_SEL3</comment>
      </reg>
      <reg name="aon_clock_force_en0" protect="rw">
        <comment>AON_CLOCK_FORCE_EN0</comment>
      </reg>
      <reg name="aon_clock_force_en1" protect="rw">
        <comment>AON_CLOCK_FORCE_EN1</comment>
      </reg>
      <reg name="aon_clock_force_en2" protect="rw">
        <comment>AON_CLOCK_FORCE_EN2</comment>
      </reg>
      <reg name="aon_clock_force_en3" protect="rw">
        <comment>AON_CLOCK_FORCE_EN3</comment>
      </reg>
      <reg name="aon_soft_rst_ctrl1" protect="rw">
        <comment>AON_SOFT_RST_CTRL1</comment>
        <bits access="rw" name="rc_calib_soft_rst" pos="9" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="emmc_phy_soft_rst" pos="8" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="usb_djtag_soft_rst" pos="7" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="lte_djtag_soft_rst" pos="6" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="pub_djtag_soft_rst" pos="5" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="gnss_djtag_soft_rst" pos="4" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="rf_djtag_soft_rst" pos="3" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="cp_djtag_soft_rst" pos="2" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="ap_djtag_soft_rst" pos="1" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
        <bits access="rw" name="aon_djtag_soft_rst" pos="0" rst="0x0">
          <comment>1:reset
0:reset release</comment>
        </bits>
      </reg>
      <reg name="mipi_csi_cfg_reg" protect="rw">
        <comment>MIPI_CSI_CFG_REG</comment>
        <bits access="rw" name="lvds_rx_terminal_enable" pos="1" rst="0x0"/>
        <bits access="rw" name="csi_lvds_mode_sel" pos="0" rst="0x0"/>
      </reg>
      <reg name="cfg_clk_uart2" protect="rw">
        <comment>CFG_CLK_UART2</comment>
        <bits access="rw" name="cfg_clk_uart2_update" pos="31" rst="0x0"/>
        <bits access="rw" name="cfg_clk_uart2_demod" pos="29:16" rst="0x7"/>
        <bits access="rw" name="cfg_clk_uart2_num" pos="9:0" rst="0x1"/>
      </reg>
      <reg name="cfg_clk_uart3" protect="rw">
        <comment>CFG_CLK_UART3</comment>
        <bits access="rw" name="cfg_clk_uart3_update" pos="31" rst="0x0"/>
        <bits access="rw" name="cfg_clk_uart3_demod" pos="29:16" rst="0x7"/>
        <bits access="rw" name="cfg_clk_uart3_num" pos="9:0" rst="0x1"/>
      </reg>
      <reg name="cfg_clk_debug_host" protect="rw">
        <comment>CFG_CLK_DEBUG_HOST</comment>
        <bits access="rw" name="cfg_clk_debug_host_update" pos="31" rst="0x0"/>
        <bits access="rw" name="cfg_clk_debug_host_demod" pos="29:16" rst="0x7"/>
        <bits access="rw" name="cfg_clk_debug_host_num" pos="9:0" rst="0x1"/>
      </reg>
      <hole size="32"/>
      <reg name="rc_calib_ctrl" protect="rw">
        <comment>RC_CALIB_CTRL</comment>
        <bits access="rw" name="rc_calib_int_clr" pos="2" rst="0x0">
          <comment>write 1 to clear interrupt. Read data always be &quot;0&quot;.</comment>
        </bits>
        <bits access="rw" name="rc_calib_int_en" pos="1" rst="0x0">
          <comment>0:disable interrupt
1:enable interrupt</comment>
        </bits>
        <bits access="rw" name="rc_calib_en" pos="0" rst="0x0">
          <comment>0:disable
1:enable
write 1 to enable RC caliberation, clear to 0 automatically when caliberation done.</comment>
        </bits>
      </reg>
      <reg name="rc_calib_th_val" protect="rw">
        <comment>RC_CALIB_TH_VAL</comment>
      </reg>
      <reg name="rc_calib_out_val" protect="rw">
        <comment>RC_CALIB_OUT_VAL</comment>
      </reg>
      <reg name="emmc_slice_phy_ctrl" protect="rw">
        <comment>EMMC_SLICE_PHY_CTRL</comment>
        <bits access="rw" name="emmc_lte_slice_en" pos="1" rst="0x0">
          <comment>1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="emmc_module_sel" pos="0" rst="0x0">
          <comment>1:sel lte dbgio
0:sel emmc</comment>
        </bits>
      </reg>
      <reg name="dma_req_ctrl" protect="rw">
        <comment>DMA_REQ_CTRL</comment>
        <bits access="rw" name="spi2_dma_sel" pos="1" rst="0x0">
          <comment>1:sel cp axidma
0:sel ap axidma</comment>
        </bits>
        <bits access="rw" name="busmon_dma_sel" pos="0" rst="0x0">
          <comment>1:sel cp axidma
0:sel ap axidma</comment>
        </bits>
      </reg>
      <reg name="apt_trigger_sel" protect="rw">
        <comment>APT_TRIGGER_SEL</comment>
        <bits access="rw" name="apt_trig_sel" pos="0" rst="0x0">
          <comment>1:sel lte_up_rfctrl[3]
0:sel rf_gpio[9]</comment>
        </bits>
      </reg>
      <reg name="ahb2ahb_ab_funcdma_ctrl" protect="rw">
        <comment>AHB2AHB_AB_FUNCDMA_CTRL</comment>
        <bits access="rw" name="funcdma_bridge_m_endian_sel" pos="14" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_s_endian_sel" pos="13" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_s_valid" pos="12" rst="0x1"/>
        <bits access="rw" name="funcdma_bridge_en" pos="11" rst="0x1"/>
        <bits access="rw" name="funcdma_bridge_bypass" pos="10" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_mode" pos="9" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_timeout_en" pos="8" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_sleep_req" pos="7" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_pause_req" pos="6" rst="0x0"/>
        <bits access="rw" name="funcdma_bridge_incr_r_word" pos="5:4" rst="0x3"/>
        <bits access="rw" name="funcdma_bridge_incr_r_half" pos="3:2" rst="0x3"/>
        <bits access="rw" name="funcdma_bridge_incr_r_byte" pos="1:0" rst="0x3"/>
      </reg>
      <reg name="ahb2ahb_ab_funcdma_sts" protect="rw">
        <comment>AHB2AHB_AB_FUNCDMA_STS</comment>
        <bits access="r" name="funcdma_bridge_sts_s_cmdfifo_full" pos="13" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_s_cmdfifo_empty" pos="12" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_s_rfifo_full" pos="11" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_s_rfifo_empty" pos="10" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_s_idle" pos="9" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_cmdfifo_full" pos="8" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_cmdfifo_empty" pos="7" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_rfifo_full" pos="6" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_rfifo_empty" pos="5" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_idle" pos="4" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sleep_ready" pos="3" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_pause_ready" pos="2" rst="0x0"/>
        <bits access="r" name="funcdma_bridge_sts_m_st" pos="1:0" rst="0x0"/>
      </reg>
      <reg name="ahb2ahb_ab_dap_ctrl" protect="rw">
        <comment>AHB2AHB_AB_DAP_CTRL</comment>
        <bits access="rw" name="dap_bridge_m_endian_sel" pos="14" rst="0x0"/>
        <bits access="rw" name="dap_bridge_s_endian_sel" pos="13" rst="0x0"/>
        <bits access="rw" name="dap_bridge_s_valid" pos="12" rst="0x1"/>
        <bits access="rw" name="dap_bridge_en" pos="11" rst="0x1"/>
        <bits access="rw" name="dap_bridge_bypass" pos="10" rst="0x0"/>
        <bits access="rw" name="dap_bridge_mode" pos="9" rst="0x0"/>
        <bits access="rw" name="dap_bridge_timeout_en" pos="8" rst="0x0"/>
        <bits access="rw" name="dap_bridge_sleep_req" pos="7" rst="0x0"/>
        <bits access="rw" name="dap_bridge_pause_req" pos="6" rst="0x0"/>
        <bits access="rw" name="dap_bridge_incr_r_word" pos="5:4" rst="0x3"/>
        <bits access="rw" name="dap_bridge_incr_r_half" pos="3:2" rst="0x3"/>
        <bits access="rw" name="dap_bridge_incr_r_byte" pos="1:0" rst="0x3"/>
      </reg>
      <reg name="ahb2ahb_ab_dap_sts" protect="rw">
        <comment>AHB2AHB_AB_DAP_STS</comment>
        <bits access="r" name="dap_bridge_sts_s_cmdfifo_full" pos="13" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_s_cmdfifo_empty" pos="12" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_s_rfifo_full" pos="11" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_s_rfifo_empty" pos="10" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_s_idle" pos="9" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_cmdfifo_full" pos="8" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_cmdfifo_empty" pos="7" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_rfifo_full" pos="6" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_rfifo_empty" pos="5" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_idle" pos="4" rst="0x0"/>
        <bits access="r" name="dap_bridge_sleep_ready" pos="3" rst="0x0"/>
        <bits access="r" name="dap_bridge_pause_ready" pos="2" rst="0x0"/>
        <bits access="r" name="dap_bridge_sts_m_st" pos="1:0" rst="0x0"/>
      </reg>
      <reg name="ahb2axi_pub_ctrl" protect="rw">
        <comment>AHB2AXI_PUB_CTRL</comment>
        <bits access="rw" name="ahb2axi_pub_trans_fencing_req" pos="5" rst="0x0"/>
        <bits access="rw" name="ahb2axi_pub_nonbuf_early_reqp_en" pos="4" rst="0x0"/>
        <bits access="rw" name="ahb2axi_pub_slv_disable_req" pos="3" rst="0x0"/>
        <bits access="rw" name="ahb2axi_pub_clk_auto_gate_en" pos="2" rst="0x0"/>
        <bits access="rw" name="ahb2axi_pub_sclk_next_on" pos="1" rst="0x1"/>
        <bits access="rw" name="ahb2axi_pub_mclk_next_on" pos="0" rst="0x1"/>
      </reg>
      <reg name="ahb2axi_pub_sts" protect="rw">
        <comment>AHB2AXI_PUB_STS</comment>
        <bits access="r" name="ahb2axi_pub_mclk_req" pos="3" rst="0x0"/>
        <bits access="r" name="ahb2axi_pub_trans_fencing_ack" pos="2" rst="0x0"/>
        <bits access="r" name="ahb2axi_pub_bus_busy" pos="1" rst="0x0"/>
        <bits access="r" name="ahb2axi_pub_slv_disable_ack" pos="0" rst="0x0"/>
      </reg>
      <reg name="axi2axi_pub_sts_0" protect="rw">
        <comment>AXI2AXI_PUB_STS_0</comment>
        <bits access="r" name="axi2axi_pub_bridge_trans_idle" pos="2" rst="0x0"/>
        <bits access="r" name="axi2axi_pub_pwr_handshk_clk_req" pos="1" rst="0x0"/>
        <bits access="r" name="axi2axi_pub_axi_detector_overflow" pos="0" rst="0x0"/>
      </reg>
      <reg name="axi2axi_pub_sts_1" protect="rw">
        <comment>AXI2AXI_PUB_STS_1</comment>
      </reg>
      <reg name="ahb2ahb_ab_aon2lps_ctrl" protect="rw">
        <comment>AHB2AHB_AB_AON2LPS_CTRL</comment>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_trans_fencing_req" pos="6" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_sclk_auto_gate_en" pos="5" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_mclk_auto_gate_en" pos="4" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_fifo_clr" pos="3" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_sync_mode" pos="2" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_nonbuf_early_resp_en" pos="1" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_slv_disable_req" pos="0" rst="0x0"/>
      </reg>
      <reg name="ahb2ahb_ab_aon2lps_sts" protect="rw">
        <comment>AHB2AHB_AB_AON2LPS_STS</comment>
        <bits access="r" name="ahb2ahb_ab_aon2lps_trans_fencing_ack" pos="5" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_aon2lps_s_bus_busy" pos="4" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_aon2lps_sclk_req" pos="3" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_aon2lps_mclk_req" pos="2" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_aon2lps_m_bus_busy" pos="1" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_aon2lps_slv_disable_ack" pos="0" rst="0x0"/>
      </reg>
      <reg name="ahb2ahb_ab_lps2aon_ctrl" protect="rw">
        <comment>AHB2AHB_AB_LPS2AON_CTRL</comment>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_trans_fencing_req" pos="6" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_sclk_auto_gate_en" pos="5" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_mclk_auto_gate_en" pos="4" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_fifo_clr" pos="3" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_sync_mode" pos="2" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_nonbuf_early_resp_en" pos="1" rst="0x0"/>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_slv_disable_req" pos="0" rst="0x0"/>
      </reg>
      <reg name="ahb2ahb_ab_lps2aon_sts" protect="rw">
        <comment>AHB2AHB_AB_LPS2AON_STS</comment>
        <bits access="r" name="ahb2ahb_ab_lps2aon_trans_fencing_ack" pos="5" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_lps2aon_s_bus_busy" pos="4" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_lps2aon_sclk_req" pos="3" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_lps2aon_mclk_req" pos="2" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_lps2aon_m_bus_busy" pos="1" rst="0x0"/>
        <bits access="r" name="ahb2ahb_ab_lps2aon_slv_disable_ack" pos="0" rst="0x0"/>
      </reg>
      <reg name="sysctrl_reg0" protect="rw">
        <comment>SYSCTRL_REG0</comment>
        <bits access="rw" name="rf_idle_enable" pos="13" rst="0x0">
          <comment>1: enable rf_dig clock
0: disable rf_dig clock</comment>
        </bits>
        <bits access="rw" name="pmic_26m_en" pos="12" rst="0x0">
          <comment>1: output to PMIC 26M clock enable
0: output to PMIC 26M clock disable</comment>
        </bits>
        <bits access="rw" name="iis_pll_ref_en" pos="11" rst="0x1">
          <comment>1: IIS_PLL reference clock enable
0: IIS_PLL reference clock disable</comment>
        </bits>
        <bits access="rw" name="mpll_ref_en" pos="10" rst="0x1">
          <comment>1: MPLL reference clock enable
0: MPLL reference clock disable</comment>
        </bits>
        <bits access="rw" name="apll_ref_en" pos="9" rst="0x1">
          <comment>1: APLL reference clock enable
0: APLL reference clock disable</comment>
        </bits>
        <bits access="rw" name="aud_sclk_o_pn_sel" pos="8" rst="0x0">
          <comment>1: aud_sclk clock output invert(source from clk_audio)
0: aud_sclk clock output do not invert(source from clk_audio)</comment>
        </bits>
        <bits access="rw" name="usb20_utmi_width_sel" pos="7" rst="0x0">
          <comment>usb20 utmi_width_sel value</comment>
        </bits>
        <bits access="rw" name="usb20_con_testmode" pos="6" rst="0x0">
          <comment>usb20 con testmode value</comment>
        </bits>
        <bits access="rw" name="usb20_iddig" pos="5" rst="0x1">
          <comment>usb20 iddig value</comment>
        </bits>
        <bits access="rw" name="usb20_vbus_valid_sel" pos="4" rst="0x0">
          <comment>1: sel usbphy signal to controller;
0: sel sysctrl register signal(usb20_vbus_valid_sw) to controller.</comment>
        </bits>
        <bits access="rw" name="usb20_vbus_valid_sw" pos="3" rst="0x0">
          <comment>1:valid
0:not valid</comment>
        </bits>
        <bits access="rw" name="exit_suspend_wait_xtal26m" pos="2" rst="0x0">
          <comment>1: USB exit suspend mode after xtal 26m stable
0: USB exit suspend mode not rely on the status of xtal 26m</comment>
        </bits>
        <bits access="rw" name="ptest_func_atspeed_sel" pos="1" rst="0x0">
          <comment>0: sel ptest_func_clk to instead pll output clock in ptest mode
1: use pll output clock in ptest mode</comment>
        </bits>
        <bits access="rw" name="spiflash2_nand_sel" pos="0" rst="0x0">
          <comment>1:nandflash
0:norflash</comment>
        </bits>
      </reg>
      <reg name="plls_sts" protect="rw">
        <comment>PLLS_STS</comment>
        <bits access="r" name="iispll_state" pos="10:8" rst="0x0"/>
        <bits access="r" name="mpll_state" pos="6:4" rst="0x0"/>
        <bits access="r" name="apll_state" pos="2:0" rst="0x0"/>
      </reg>
      <reg name="cfg_aon_anti_hang" protect="rw">
        <comment>CFG_AON_ANTI_HANG</comment>
        <bits access="rw" name="aon2rf_slv_disable_req_sel" pos="15" rst="0x0">
          <comment>1: sel software force register bit
0: sel hardware signal</comment>
        </bits>
        <bits access="rw" name="aon2rf_slv_disable_req_force" pos="14" rst="0x0">
          <comment>1:  disable downstream path of aon to rf
0: no disable downstream path of aon to rf</comment>
        </bits>
        <bits access="rw" name="aon2cp_slv_disable_req_sel" pos="13" rst="0x0">
          <comment>1: sel software force register bit
0: sel hardware signal</comment>
        </bits>
        <bits access="rw" name="aon2cp_slv_disable_req_force" pos="12" rst="0x0">
          <comment>1:  disable downstream path of aon to cp
0: no disable downstream path of aon to cp</comment>
        </bits>
        <bits access="rw" name="aon2ap_slv_disable_req_sel" pos="11" rst="0x0">
          <comment>1: sel software force register bit
0: sel hardware signal</comment>
        </bits>
        <bits access="rw" name="aon2ap_slv_disable_req_force" pos="10" rst="0x0">
          <comment>1:  disable downstream path of aon to ap
0: no disable downstream path of aon to ap</comment>
        </bits>
        <bits access="rw" name="aon2rf_err_resp_en" pos="9" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aon2cp_err_resp_en" pos="8" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aon2ap_err_resp_en" pos="7" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="lte_err_resp_en" pos="6" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aon2pub_slv_disable_req_sel" pos="5" rst="0x0">
          <comment>1: sel software force register bit
0: sel hardware signal</comment>
        </bits>
        <bits access="rw" name="aon2pub_slv_disable_req_force" pos="4" rst="0x0">
          <comment>1:  disable downstream path of aon to psram
0: no disable downstream path of aon to psram</comment>
        </bits>
        <bits access="rw" name="lpsifc_err_resp_en" pos="3" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aonifc_err_resp_en" pos="2" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aon_apbmux_err_resp_en" pos="1" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="aon_ahbmux_err_resp_en" pos="0" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
      </reg>
      <reg name="cfg_aon_qos" protect="rw">
        <comment>CFG_AON_QOS</comment>
        <bits access="rw" name="arqos_aon" pos="7:4" rst="0x0">
          <comment>R-channel QOS value of AON</comment>
        </bits>
        <bits access="rw" name="awqos_aon" pos="3:0" rst="0x0">
          <comment>W-channel QOS value of AON</comment>
        </bits>
      </reg>
      <reg name="aon_ahb_mtx_slice_autogate_en" protect="rw">
        <comment>AON_AHB_MTX_SLICE_AUTOGATE_EN</comment>
        <bits access="rw" name="aon_ahb_mtx_slice_m5_auto_gate_en" pos="11" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_m4_auto_gate_en" pos="10" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_m3_auto_gate_en" pos="9" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_m2_auto_gate_en" pos="8" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_m1_auto_gate_en" pos="7" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_m0_auto_gate_en" pos="6" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s5_auto_gate_en" pos="5" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s4_auto_gate_en" pos="4" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s3_auto_gate_en" pos="3" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s2_auto_gate_en" pos="2" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s1_auto_gate_en" pos="1" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_s0_auto_gate_en" pos="0" rst="0x0">
          <comment>1: clock auto gating enable.
0: clock auto gating disable.</comment>
        </bits>
      </reg>
      <reg name="dap_djtag_en_cfg" protect="rw">
        <comment>DAP_DJTAG_EN_CFG</comment>
        <bits access="rw" name="dap_djtag_en" pos="0" rst="0x0">
          <comment>1: enable dap djtag.
0: dap djtag enable by dap jtag chain.</comment>
        </bits>
      </reg>
      <reg name="lte_ahb2ahb_sync_cfg" protect="rw">
        <comment>LTE_AHB2AHB_SYNC_CFG</comment>
        <bits access="rw" name="cpu2phy_auto_gating_en" pos="3" rst="0x0">
          <comment>1: enable cpu2phyahb2ahb_sync auto clock gating.
0: disable cpu2phyahb2ahb_sync auto clock gating.</comment>
        </bits>
        <bits access="rw" name="cpu2phy_wr_early_resp_en" pos="2" rst="0x0">
          <comment>1: enable cpu2phyahb2ahb_sync write early_resp_en.
0: disable cpu2phyahb2ahb_sync write early_resp_en..</comment>
        </bits>
        <bits access="rw" name="dma2phy_auto_gating_en" pos="1" rst="0x0">
          <comment>1: enable dma2phyahb2ahb_sync auto clock gating.
0: disable dma2phyahb2ahb_sync auto clock gating.</comment>
        </bits>
        <bits access="rw" name="dma2phy_wr_early_resp_en" pos="0" rst="0x0">
          <comment>1: enable dma2phyahb2ahb_sync write early_resp_en.
0: disable dma2phyahb2ahb_sync write early_resp_en..</comment>
        </bits>
      </reg>
      <reg name="cfg_aon_io_core_ie_0" protect="rw">
        <comment>CFG_AON_IO_CORE_IE_0</comment>
      </reg>
      <reg name="cfg_aon_io_core_ie_1" protect="rw">
        <comment>CFG_AON_IO_CORE_IE_1</comment>
      </reg>
      <reg name="cfg_aon_io_core_ie_2" protect="rw">
        <comment>CFG_AON_IO_CORE_IE_2</comment>
      </reg>
      <reg name="cfg_aon_io_core_ie_3" protect="rw">
        <comment>CFG_AON_IO_CORE_IE_3</comment>
      </reg>
      <hole size="6496"/>
      <reg name="aon_soft_rst_ctrl0_set" protect="rw"/>
      <reg name="clken_lte_set" protect="rw"/>
      <reg name="clken_lte_intf_set" protect="rw"/>
      <reg name="rstctrl_lte_set" protect="rw"/>
      <hole size="32"/>
      <reg name="lte_autogate_en_set" protect="rw"/>
      <hole size="32"/>
      <reg name="aon_lpc_ctrl_set" protect="rw"/>
      <reg name="aon_clock_en0_set" protect="rw"/>
      <reg name="aon_clock_en1_set" protect="rw"/>
      <reg name="aon_clock_auto_sel0_set" protect="rw"/>
      <reg name="aon_clock_auto_sel1_set" protect="rw"/>
      <reg name="aon_clock_auto_sel2_set" protect="rw"/>
      <reg name="aon_clock_auto_sel3_set" protect="rw"/>
      <reg name="aon_clock_force_en0_set" protect="rw"/>
      <reg name="aon_clock_force_en1_set" protect="rw"/>
      <reg name="aon_clock_force_en2_set" protect="rw"/>
      <reg name="aon_clock_force_en3_set" protect="rw"/>
      <reg name="aon_soft_rst_ctrl1_set" protect="rw"/>
      <reg name="mipi_csi_cfg_reg_set" protect="rw"/>
      <reg name="cfg_clk_uart2_set" protect="rw"/>
      <reg name="cfg_clk_uart3_set" protect="rw"/>
      <reg name="cfg_clk_debug_host_set" protect="rw"/>
      <hole size="32"/>
      <reg name="rc_calib_ctrl_set" protect="rw"/>
      <hole size="64"/>
      <reg name="emmc_slice_phy_ctrl_set" protect="rw"/>
      <reg name="dma_req_ctrl_set" protect="rw"/>
      <reg name="apt_trigger_sel_set" protect="rw"/>
      <reg name="ahb2ahb_ab_funcdma_ctrl_set" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2ahb_ab_dap_ctrl_set" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2axi_pub_ctrl_set" protect="rw"/>
      <hole size="96"/>
      <reg name="ahb2ahb_ab_aon2lps_ctrl_set" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2ahb_ab_lps2aon_ctrl_set" protect="rw"/>
      <hole size="32"/>
      <reg name="sysctrl_reg0_set" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_aon_anti_hang_set" protect="rw"/>
      <hole size="32"/>
      <reg name="aon_ahb_mtx_slice_autogate_en_set" protect="rw"/>
      <reg name="dap_djtag_en_cfg_set" protect="rw"/>
      <reg name="lte_ahb2ahb_sync_cfg_set" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_0_set" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_1_set" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_2_set" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_3_set" protect="rw"/>
      <hole size="6496"/>
      <reg name="aon_soft_rst_ctrl0_clr" protect="rw"/>
      <reg name="clken_lte_clr" protect="rw"/>
      <reg name="clken_lte_intf_clr" protect="rw"/>
      <reg name="rstctrl_lte_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="lte_autogate_en_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="aon_lpc_ctrl_clr" protect="rw"/>
      <reg name="aon_clock_en0_clr" protect="rw"/>
      <reg name="aon_clock_en1_clr" protect="rw"/>
      <reg name="aon_clock_auto_sel0_clr" protect="rw"/>
      <reg name="aon_clock_auto_sel1_clr" protect="rw"/>
      <reg name="aon_clock_auto_sel2_clr" protect="rw"/>
      <reg name="aon_clock_auto_sel3_clr" protect="rw"/>
      <reg name="aon_clock_force_en0_clr" protect="rw"/>
      <reg name="aon_clock_force_en1_clr" protect="rw"/>
      <reg name="aon_clock_force_en2_clr" protect="rw"/>
      <reg name="aon_clock_force_en3_clr" protect="rw"/>
      <reg name="aon_soft_rst_ctrl1_clr" protect="rw"/>
      <reg name="mipi_csi_cfg_reg_clr" protect="rw"/>
      <reg name="cfg_clk_uart2_clr" protect="rw"/>
      <reg name="cfg_clk_uart3_clr" protect="rw"/>
      <reg name="cfg_clk_debug_host_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="rc_calib_ctrl_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="emmc_slice_phy_ctrl_clr" protect="rw"/>
      <reg name="dma_req_ctrl_clr" protect="rw"/>
      <reg name="apt_trigger_sel_clr" protect="rw"/>
      <reg name="ahb2ahb_ab_funcdma_ctrl_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2ahb_ab_dap_ctrl_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2axi_pub_ctrl_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="ahb2ahb_ab_aon2lps_ctrl_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="ahb2ahb_ab_lps2aon_ctrl_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="sysctrl_reg0_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_aon_anti_hang_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="aon_ahb_mtx_slice_autogate_en_clr" protect="rw"/>
      <reg name="dap_djtag_en_cfg_clr" protect="rw"/>
      <reg name="lte_ahb2ahb_sync_cfg_clr" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_0_clr" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_1_clr" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_2_clr" protect="rw"/>
      <reg name="cfg_aon_io_core_ie_3_clr" protect="rw"/>
    </module>
    <var name="REG_SYS_CTRL_SET_OFFSET" value="0x400"/>
    <var name="REG_SYS_CTRL_CLR_OFFSET" value="0x800"/>
    <instance address="0x51500000" name="SYS_CTRL" type="SYS_CTRL"/>
  </archive>
  <archive relative="scc.xml">
    <module category="System" name="SCC">
      <reg name="scc_tune_lmt_cfg" protect="rw">
        <comment>SCC_TUNE_LMT_CFG</comment>
        <bits access="rw" name="volt_tune_val_max" pos="15:8" rst="0xff">
          <comment>VOLT_TUNE_VAL_MAX[7:5]:
3'b000 : DCDC 0.6V
3'b001 : DCDC 0.7V
3'b010 : DCDC 0.8V
3'b011 : DCDC 0.9V
3'b100 : DCDC 1.0V
3'b101 : DCDC 1.1V
3'b110 : DCDC 1.2V
3'b111 : DCDC 1.3V
VOLT_TUNE_VAL_MAX[4:0] represent 0.1V/32.
The result voltage = VOLT_TUNE_VAL_MAX[7:5] + VOLT_TUNE_VAL_MAX[4:0]*3mV</comment>
        </bits>
        <bits access="rw" name="volt_tune_val_min" pos="7:0" rst="0x0">
          <comment>Same to VOLT_TUNE_VAL_MAX</comment>
        </bits>
      </reg>
      <reg name="scc_tune_status" protect="rw">
        <comment>SCC_TUNE_STATUS</comment>
        <bits access="r" name="volt_tune_val" pos="15:8" rst="0x0">
          <comment>the voltage give to A_DIE for voltage setting:
VOLT_TUNE_VAL[7:5]:change the voltage 100mv for each step;
VOLT_TUNE_VAL[4:0]:change the voltage about 3mv each step</comment>
        </bits>
        <bits access="r" name="volt_obs_val" pos="7:0" rst="0x0">
          <comment>the current voltage of A_DIE,observed through ADI bus:
3'b000 : DCDC 0.6V
3'b001 : DCDC 0.7V
3'b010 : DCDC 0.8V
3'b011 : DCDC 0.9V
3'b100 : DCDC 1.0V
3'b101 : DCDC 1.1V
3'b110 : DCDC 1.2V
3'b111 : DCDC 1.3V</comment>
        </bits>
      </reg>
      <reg name="scc_cfg" protect="rw">
        <comment>SCC_CFG</comment>
        <bits access="rw" name="volt0_select_override" pos="31" rst="0x0">
          <comment>Voltage Tune/Obs 0 Interface Select</comment>
        </bits>
        <bits access="rw" name="volt1_select_override" pos="30" rst="0x0">
          <comment>Voltage Tune/Obs 1 Interface Select</comment>
        </bits>
        <bits access="rw" name="pause_occur_err_en" pos="8" rst="0x0">
          <comment>not used in Whale</comment>
        </bits>
        <bits access="rw" name="volt_tune_forbid_en" pos="4" rst="0x0">
          <comment>stop tuning the voltage</comment>
        </bits>
        <bits access="rw" name="volt_obs_forbid_en" pos="0" rst="0x0">
          <comment>stop observating of voltage</comment>
        </bits>
      </reg>
      <reg name="scc_tune_step_cfg" protect="rw">
        <comment>SCC_TUNE_STEP_CFG</comment>
        <bits access="rw" name="volt_tune_down_step" pos="24:16" rst="0x101">
          <comment>voltage set down step,fine tuning</comment>
        </bits>
        <bits access="rw" name="volt_tune_up_step" pos="8:0" rst="0x1">
          <comment>voltage set up step,fine tuning</comment>
        </bits>
      </reg>
      <reg name="scc_wait_cfg" protect="rw">
        <comment>SCC_WAIT_CFG</comment>
        <bits access="rw" name="rnd_intval_wait_num" pos="31:16" rst="0x7">
          <comment>the time that SCC state_machine remain RND_INTVAL_WAIT</comment>
        </bits>
        <bits access="rw" name="volt_stb_wait_num" pos="15:0" rst="0xf">
          <comment>the time that SCC state_machine remain VOLT_STB_WAIT</comment>
        </bits>
      </reg>
      <reg name="scc_int_cfg" protect="rw">
        <comment>SCC_INT_CFG</comment>
        <bits access="r" name="scc_tune_done_int_mask_status" pos="13" rst="0x0">
          <comment>mask status of interrupt caused by tune over</comment>
        </bits>
        <bits access="r" name="scc_tune_err_int_mask_status" pos="12" rst="0x0">
          <comment>mask status of interrupt caused by tune voltage over flow or under flow</comment>
        </bits>
        <bits access="r" name="scc_tune_done_int_raw_status" pos="9" rst="0x0">
          <comment>raw status of interrupt caused by tune over</comment>
        </bits>
        <bits access="r" name="scc_tune_err_int_raw_status" pos="8" rst="0x0">
          <comment>raw status of interrupt caused by tune voltage over flow or under flow</comment>
        </bits>
        <bits access="w" name="scc_tune_done_int_clr" pos="5" rst="0x0">
          <comment>clear the interrupt caused by SCC done interrupt</comment>
        </bits>
        <bits access="w" name="scc_tune_err_int_clr" pos="4" rst="0x0">
          <comment>clear the interrupt caused by SCC tune error interrupt</comment>
        </bits>
        <bits access="rw" name="scc_tune_done_int_en" pos="1" rst="0x0">
          <comment>software configuration to enable the  interrupt of SCC</comment>
        </bits>
        <bits access="rw" name="scc_tune_err_int_en" pos="0" rst="0x0">
          <comment>software configuration to enable the  error interrupt</comment>
        </bits>
      </reg>
      <reg name="scc_tune_mark" protect="rw">
        <comment>SCC_TUNE_MARK</comment>
        <bits access="rw" name="scc_tune_dwn_mark" pos="31:16" rst="0x1388">
          <comment>the boundary that need to tune down voltage</comment>
        </bits>
        <bits access="rw" name="scc_tune_up_mark" pos="15:0" rst="0xbb8">
          <comment>the boundary that need to tune up voltage</comment>
        </bits>
      </reg>
      <reg name="scc_fsm_sts" protect="rw">
        <comment>SCC_FSM_STS</comment>
        <bits access="r" name="scc_fsm_sts" pos="4:0" rst="0x10">
          <comment>SCC Finite State Machine current state</comment>
        </bits>
      </reg>
      <reg name="scc_rosc_mode" protect="rw">
        <comment>SCC_ROSC_MODE</comment>
        <bits access="rw" name="scc_idle_mode" pos="31" rst="0x0">
          <comment>SCC IDEL CTRL</comment>
        </bits>
        <bits access="rw" name="scc_tune_bypass" pos="30" rst="0x1">
          <comment>SCC Voltage Tuning Bypass</comment>
        </bits>
        <bits access="rw" name="scc_init_halt_bypass" pos="29" rst="0x1">
          <comment>SCC Initialization Pattern Fail Halt Bypass</comment>
        </bits>
        <bits access="rw" name="scc_rpt_read_ctrl" pos="12" rst="0x0">
          <comment>SCC ROSC Report Read Control</comment>
        </bits>
        <bits access="rw" name="scc_all_rosc_chain" pos="2" rst="0x0">
          <comment>OSC through all the chain in preselected sequence</comment>
        </bits>
        <bits access="rw" name="scc_all_rosc_seq" pos="1" rst="0x0">
          <comment>OSC through a sequence in preselected chain</comment>
        </bits>
        <bits access="rw" name="scc_rosc_repeat_mode" pos="0" rst="0x0">
          <comment>REPEAT The RUN Operation</comment>
        </bits>
      </reg>
      <reg name="scc_rosc_cfg" protect="rw">
        <comment>SCC_ROSC_CFG</comment>
        <bits access="rw" name="scc_rosc_duration" pos="31:12" rst="0x0">
          <comment>SCC ROSC Oscillation duration</comment>
        </bits>
        <bits access="rw" name="scc_rosc_sel_z" pos="11:8" rst="0x0">
          <comment>SCC ROSC Ring Select</comment>
        </bits>
        <bits access="rw" name="scc_rosc_sel_y" pos="7:4" rst="0x0">
          <comment>SCC ROSC Sequence Select</comment>
        </bits>
        <bits access="rw" name="scc_rosc_sel_x" pos="3:0" rst="0x0">
          <comment>SCC ROSC Chain Select</comment>
        </bits>
      </reg>
      <reg name="scc_rosc_ctrl" protect="rw">
        <comment>SCC_ROSC_CTRL</comment>
        <bits access="rw" name="scc_rpt_read_nxt" pos="31" rst="0x0">
          <comment>SCC ROSC Report To Read</comment>
        </bits>
        <bits access="rw" name="scc_rosc_gr_enable" pos="1" rst="0x0">
          <comment>ROSC Gross Ring Enable</comment>
        </bits>
        <bits access="rw" name="scc_rosc_run" pos="0" rst="0x0">
          <comment>ROSC RUN</comment>
        </bits>
      </reg>
      <reg name="scc_rosc_rpt" protect="rw">
        <comment>SCC_ROSC_RPT</comment>
        <bits access="r" name="scc_init_pat_fail" pos="31" rst="0x0">
          <comment>Initialization Pattern Fail</comment>
        </bits>
        <bits access="r" name="scc_rosc_rpt_valid" pos="30" rst="0x0">
          <comment>SCC ROSC REPORT VALID</comment>
        </bits>
        <bits access="r" name="scc_rosc_setting" pos="24:20" rst="0x0">
          <comment>Selected ROSC Setting: GRE + RING number</comment>
        </bits>
        <bits access="r" name="scc_rosc_cnt" pos="19:0" rst="0x0">
          <comment>rosc</comment>
        </bits>
      </reg>
      <reg name="scc_rosc_sw_rst" protect="rw">
        <comment>SCC_ROSC_SW_RST</comment>
        <bits access="rw" name="scc_rosc_sw_rst" pos="1:0" rst="0x0">
          <comment>SCC ROSC Chain Reset, Active Low</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51505000" name="SCC" type="SCC"/>
  </archive>
  <archive relative="djtag_ctrl.xml">
    <module category="System" name="DJTAG_CTRL">
      <reg name="djtag_ir_len" protect="rw">
        <comment>DJTAG_IR_LEN</comment>
        <bits access="rw" name="djtag_ir_len" pos="5:0" rst="0x0">
          <comment>the instruction register length</comment>
        </bits>
      </reg>
      <reg name="ap_pwr_ctrl" protect="rw">
        <comment>DJTAG_DR_LEN</comment>
        <bits access="rw" name="djtag_dr_len" pos="15:0" rst="0x0">
          <comment>the data register length</comment>
        </bits>
      </reg>
      <reg name="djtag_ir" protect="rw">
        <comment>DJTAG_IR</comment>
      </reg>
      <reg name="djtag_dr" protect="rw">
        <comment>DJTAG_DR</comment>
      </reg>
      <reg name="dr_pause_recov" protect="rw">
        <comment>DR_PAUSE_RECOV</comment>
        <bits access="rw" name="djtag_dr_pause_recov" pos="0" rst="0x0">
          <comment>the signal to recover from PAUSE state</comment>
        </bits>
      </reg>
      <reg name="djtag_rnd_en" protect="rw">
        <comment>DJTAG_RND_EN</comment>
        <bits access="rw" name="djtag_rnd_en" pos="0" rst="0x0">
          <comment>the signal to start DJTAG scan</comment>
        </bits>
      </reg>
      <reg name="djtag_upd_dr" protect="rw">
        <comment>DJTAG_UPD_DR</comment>
      </reg>
      <reg name="djtag_dap_mux_ctrl_soft_rst" protect="rw">
        <comment>DJTAG_DAP_MUX_CTRL_SOFT_RST</comment>
        <bits access="rw" name="djtag_dap_mux_ctrl_soft_rst" pos="0" rst="0x0">
          <comment>reset of dap mux control chain</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x5150e000" name="DJTAG_CTRL" type="DJTAG_CTRL"/>
  </archive>
  <archive relative="aon_clk_gen.xml">
    <module category="System" name="AON_CLK_GEN">
      <hole size="256"/>
      <reg name="soft_cnt_done0_cfg" protect="rw">
        <comment>soft_cnt_done0_cfg</comment>
        <bits access="rw" name="apll_1000m_soft_cnt_done" pos="5" rst="0x1">
          <comment>apll_1000m_soft_cnt_done counter wait for source stable</comment>
        </bits>
        <bits access="rw" name="mempll_1000m_soft_cnt_done" pos="4" rst="0x1">
          <comment>mempll_1000m_soft_cnt_done counter wait for source stable</comment>
        </bits>
        <bits access="rw" name="audio_pll_122m_soft_cnt_done" pos="3" rst="0x1">
          <comment>audio_pll_122m_soft_cnt_done counter wait for source stable</comment>
        </bits>
        <bits access="rw" name="xtal_26m_soft_cnt_done" pos="2" rst="0x1">
          <comment>xtal_26m_soft_cnt_done counter wait for source stable</comment>
        </bits>
        <bits access="rw" name="xtal_lp_26m_soft_cnt_done" pos="1" rst="0x1">
          <comment>xtal_lp_26m_soft_cnt_done counter wait for source stable</comment>
        </bits>
        <bits access="rw" name="rc26m_78m_soft_cnt_done" pos="0" rst="0x1">
          <comment>rc26m_78m_soft_cnt_done counter wait for source stable</comment>
        </bits>
      </reg>
      <reg name="pll_wait_sel0_cfg" protect="rw">
        <comment>pll_wait_sel0_cfg</comment>
        <bits access="rw" name="apll_1000m_wait_auto_gate_sel" pos="5" rst="0x1">
          <comment>apll_1000m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="mempll_1000m_wait_auto_gate_sel" pos="4" rst="0x1">
          <comment>mempll_1000m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="audio_pll_122m_wait_auto_gate_sel" pos="3" rst="0x1">
          <comment>audio_pll_122m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="xtal_26m_wait_auto_gate_sel" pos="2" rst="0x1">
          <comment>xtal_26m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="xtal_lp_26m_wait_auto_gate_sel" pos="1" rst="0x1">
          <comment>xtal_lp_26m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="rc26m_78m_wait_auto_gate_sel" pos="0" rst="0x1">
          <comment>rc26m_78m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
      </reg>
      <reg name="pll_wait_sw_ctl0_cfg" protect="rw">
        <comment>pll_wait_sw_ctl0_cfg</comment>
        <bits access="rw" name="apll_1000m_wait_force_en" pos="5" rst="0x1">
          <comment>apll_1000m_wait_force_en pll wait's enable sw control</comment>
        </bits>
        <bits access="rw" name="mempll_1000m_wait_force_en" pos="4" rst="0x1">
          <comment>mempll_1000m_wait_force_en pll wait's enable sw control</comment>
        </bits>
        <bits access="rw" name="audio_pll_122m_wait_force_en" pos="3" rst="0x1">
          <comment>audio_pll_122m_wait_force_en pll wait's enable sw control</comment>
        </bits>
        <bits access="rw" name="xtal_26m_wait_force_en" pos="2" rst="0x1">
          <comment>xtal_26m_wait_force_en pll wait's enable sw control</comment>
        </bits>
        <bits access="rw" name="xtal_lp_26m_wait_force_en" pos="1" rst="0x1">
          <comment>xtal_lp_26m_wait_force_en pll wait's enable sw control</comment>
        </bits>
        <bits access="rw" name="rc26m_78m_wait_force_en" pos="0" rst="0x1">
          <comment>rc26m_78m_wait_force_en pll wait's enable sw control</comment>
        </bits>
      </reg>
      <reg name="div_en_sel0_cfg" protect="rw">
        <comment>div_en_sel0_cfg</comment>
        <bits access="rw" name="apll_div_1000m_90m9_auto_gate_sel" pos="11" rst="0x1">
          <comment>apll_div_1000m_90m9_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_500m_auto_gate_sel" pos="10" rst="0x1">
          <comment>apll_div_1000m_500m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_250m_auto_gate_sel" pos="9" rst="0x1">
          <comment>apll_div_1000m_250m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_125m_auto_gate_sel" pos="8" rst="0x1">
          <comment>apll_div_1000m_125m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_62m5_auto_gate_sel" pos="7" rst="0x1">
          <comment>apll_div_1000m_62m5_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_31m2_auto_gate_sel" pos="6" rst="0x1">
          <comment>apll_div_1000m_31m2_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_333m3_auto_gate_sel" pos="5" rst="0x1">
          <comment>apll_div_1000m_333m3_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_166m7_auto_gate_sel" pos="4" rst="0x1">
          <comment>apll_div_1000m_166m7_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_200m_auto_gate_sel" pos="3" rst="0x1">
          <comment>apll_div_1000m_200m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_100m_auto_gate_sel" pos="2" rst="0x1">
          <comment>apll_div_1000m_100m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="audio_div_pll_122m_30m7_auto_gate_sel" pos="1" rst="0x1">
          <comment>audio_div_pll_122m_30m7_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
        <bits access="rw" name="mempll_div_1000m_500m_auto_gate_sel" pos="0" rst="0x1">
          <comment>mempll_div_1000m_500m_auto_gate_sel pre div clock's enable select. 0: soft register control  1: hw auto control</comment>
        </bits>
      </reg>
      <reg name="div_en_sw_ctl0_cfg" protect="rw">
        <comment>div_en_sw_ctl0_cfg</comment>
        <bits access="rw" name="apll_div_1000m_90m9_force_en" pos="11" rst="0x1">
          <comment>apll_div_1000m_90m9_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_500m_force_en" pos="10" rst="0x1">
          <comment>apll_div_1000m_500m_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_250m_force_en" pos="9" rst="0x1">
          <comment>apll_div_1000m_250m_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_125m_force_en" pos="8" rst="0x1">
          <comment>apll_div_1000m_125m_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_62m5_force_en" pos="7" rst="0x1">
          <comment>apll_div_1000m_62m5_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_31m2_force_en" pos="6" rst="0x1">
          <comment>apll_div_1000m_31m2_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_333m3_force_en" pos="5" rst="0x1">
          <comment>apll_div_1000m_333m3_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_166m7_force_en" pos="4" rst="0x1">
          <comment>apll_div_1000m_166m7_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_200m_force_en" pos="3" rst="0x1">
          <comment>apll_div_1000m_200m_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="apll_div_1000m_100m_force_en" pos="2" rst="0x1">
          <comment>apll_div_1000m_100m_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="audio_div_pll_122m_30m7_force_en" pos="1" rst="0x1">
          <comment>audio_div_pll_122m_30m7_force_en pre div clock's enable sw control</comment>
        </bits>
        <bits access="rw" name="mempll_div_1000m_500m_force_en" pos="0" rst="0x1">
          <comment>mempll_div_1000m_500m_force_en pre div clock's enable sw control</comment>
        </bits>
      </reg>
      <reg name="gate_en_sel0_cfg" protect="rw">
        <comment>gate_en_sel0_cfg</comment>
        <bits access="rw" name="cgm_rtc_32k_ap_auto_gate_sel" pos="31" rst="0x1">
          <comment>cgm_rtc_32k_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_ap_auto_gate_sel" pos="30" rst="0x1">
          <comment>cgm_rc_26m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_ap_auto_gate_sel" pos="29" rst="0x1">
          <comment>cgm_xtal_26m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_500m_ap_auto_gate_sel" pos="28" rst="0x1">
          <comment>cgm_apll_500m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_ap_auto_gate_sel" pos="27" rst="0x1">
          <comment>cgm_apll_400m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_ap_auto_gate_sel" pos="26" rst="0x1">
          <comment>cgm_apll_250m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_ap_auto_gate_sel" pos="25" rst="0x1">
          <comment>cgm_apll_167m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_ap_auto_gate_sel" pos="24" rst="0x1">
          <comment>cgm_apll_125m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_100m_ap_auto_gate_sel" pos="23" rst="0x1">
          <comment>cgm_apll_100m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_ap_auto_gate_sel" pos="22" rst="0x1">
          <comment>cgm_apll_62_5m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_31_25m_ap_auto_gate_sel" pos="21" rst="0x1">
          <comment>cgm_apll_31_25m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_cp_auto_gate_sel" pos="20" rst="0x1">
          <comment>cgm_rtc_32k_cp_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_cp_auto_gate_sel" pos="19" rst="0x1">
          <comment>cgm_xtal_26m_cp_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_cp_auto_gate_sel" pos="18" rst="0x1">
          <comment>cgm_apll_400m_cp_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_200m_cp_auto_gate_sel" pos="17" rst="0x1">
          <comment>cgm_apll_200m_cp_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_aon_auto_gate_sel" pos="16" rst="0x1">
          <comment>cgm_rc_26m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_aon_auto_gate_sel" pos="15" rst="0x1">
          <comment>cgm_xtal_26m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_lp_26m_aon_auto_gate_sel" pos="14" rst="0x1">
          <comment>cgm_xtal_lp_26m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_aon_auto_gate_sel" pos="13" rst="0x1">
          <comment>cgm_apll_400m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_333m_aon_auto_gate_sel" pos="12" rst="0x1">
          <comment>cgm_apll_333m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_aon_auto_gate_sel" pos="11" rst="0x1">
          <comment>cgm_apll_250m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_200m_aon_auto_gate_sel" pos="10" rst="0x1">
          <comment>cgm_apll_200m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_aon_auto_gate_sel" pos="9" rst="0x1">
          <comment>cgm_apll_167m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_aon_auto_gate_sel" pos="8" rst="0x1">
          <comment>cgm_apll_125m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_100m_aon_auto_gate_sel" pos="7" rst="0x1">
          <comment>cgm_apll_100m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_aon_auto_gate_sel" pos="6" rst="0x1">
          <comment>cgm_apll_62_5m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_31_25m_aon_auto_gate_sel" pos="5" rst="0x1">
          <comment>cgm_apll_31_25m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_audiopll_122_88m_aon_auto_gate_sel" pos="4" rst="0x1">
          <comment>cgm_audiopll_122_88m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_audiopll_30_72m_aon_auto_gate_sel" pos="3" rst="0x1">
          <comment>cgm_audiopll_30_72m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_pub_auto_gate_sel" pos="2" rst="0x1">
          <comment>cgm_rc_26m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_pub_auto_gate_sel" pos="1" rst="0x1">
          <comment>cgm_xtal_26m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_mempll_500m_pub_auto_gate_sel" pos="0" rst="0x1">
          <comment>cgm_mempll_500m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
      </reg>
      <reg name="gate_en_sel1_cfg" protect="rw">
        <comment>gate_en_sel1_cfg</comment>
        <bits access="rw" name="cgm_apll_500m_pub_auto_gate_sel" pos="7" rst="0x1">
          <comment>cgm_apll_500m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_pub_auto_gate_sel" pos="6" rst="0x1">
          <comment>cgm_apll_400m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_pub_auto_gate_sel" pos="5" rst="0x1">
          <comment>cgm_apll_250m_pub_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_gnss_auto_gate_sel" pos="4" rst="0x1">
          <comment>cgm_xtal_26m_gnss_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_gnss_auto_gate_sel" pos="3" rst="0x1">
          <comment>cgm_apll_167m_gnss_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_gnss_auto_gate_sel" pos="2" rst="0x1">
          <comment>cgm_apll_125m_gnss_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_gnss_auto_gate_sel" pos="1" rst="0x1">
          <comment>cgm_apll_62_5m_gnss_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_rf_auto_gate_sel" pos="0" rst="0x1">
          <comment>cgm_xtal_26m_rf_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
      </reg>
      <reg name="gate_en_sw_ctl0_cfg" protect="rw">
        <comment>gate_en_sw_ctl0_cfg</comment>
        <bits access="rw" name="cgm_rtc_32k_ap_force_en" pos="31" rst="0x1">
          <comment>cgm_rtc_32k_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_ap_force_en" pos="30" rst="0x1">
          <comment>cgm_rc_26m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_ap_force_en" pos="29" rst="0x1">
          <comment>cgm_xtal_26m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_500m_ap_force_en" pos="28" rst="0x1">
          <comment>cgm_apll_500m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_ap_force_en" pos="27" rst="0x1">
          <comment>cgm_apll_400m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_ap_force_en" pos="26" rst="0x1">
          <comment>cgm_apll_250m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_ap_force_en" pos="25" rst="0x1">
          <comment>cgm_apll_167m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_ap_force_en" pos="24" rst="0x1">
          <comment>cgm_apll_125m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_100m_ap_force_en" pos="23" rst="0x1">
          <comment>cgm_apll_100m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_ap_force_en" pos="22" rst="0x1">
          <comment>cgm_apll_62_5m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_31_25m_ap_force_en" pos="21" rst="0x1">
          <comment>cgm_apll_31_25m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_cp_force_en" pos="20" rst="0x1">
          <comment>cgm_rtc_32k_cp_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_cp_force_en" pos="19" rst="0x1">
          <comment>cgm_xtal_26m_cp_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_cp_force_en" pos="18" rst="0x1">
          <comment>cgm_apll_400m_cp_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_200m_cp_force_en" pos="17" rst="0x1">
          <comment>cgm_apll_200m_cp_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_aon_force_en" pos="16" rst="0x1">
          <comment>cgm_rc_26m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_aon_force_en" pos="15" rst="0x1">
          <comment>cgm_xtal_26m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_lp_26m_aon_force_en" pos="14" rst="0x1">
          <comment>cgm_xtal_lp_26m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_aon_force_en" pos="13" rst="0x1">
          <comment>cgm_apll_400m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_333m_aon_force_en" pos="12" rst="0x1">
          <comment>cgm_apll_333m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_aon_force_en" pos="11" rst="0x1">
          <comment>cgm_apll_250m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_200m_aon_force_en" pos="10" rst="0x1">
          <comment>cgm_apll_200m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_aon_force_en" pos="9" rst="0x1">
          <comment>cgm_apll_167m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_aon_force_en" pos="8" rst="0x1">
          <comment>cgm_apll_125m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_100m_aon_force_en" pos="7" rst="0x1">
          <comment>cgm_apll_100m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_aon_force_en" pos="6" rst="0x1">
          <comment>cgm_apll_62_5m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_31_25m_aon_force_en" pos="5" rst="0x1">
          <comment>cgm_apll_31_25m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_audiopll_122_88m_aon_force_en" pos="4" rst="0x1">
          <comment>cgm_audiopll_122_88m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_audiopll_30_72m_aon_force_en" pos="3" rst="0x1">
          <comment>cgm_audiopll_30_72m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_pub_force_en" pos="2" rst="0x1">
          <comment>cgm_rc_26m_pub_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_pub_force_en" pos="1" rst="0x1">
          <comment>cgm_xtal_26m_pub_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_mempll_500m_pub_force_en" pos="0" rst="0x1">
          <comment>cgm_mempll_500m_pub_force_en clock gating enable sw control</comment>
        </bits>
      </reg>
      <reg name="gate_en_sw_ctl1_cfg" protect="rw">
        <comment>gate_en_sw_ctl1_cfg</comment>
        <bits access="rw" name="cgm_apll_500m_pub_force_en" pos="7" rst="0x1">
          <comment>cgm_apll_500m_pub_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_400m_pub_force_en" pos="6" rst="0x1">
          <comment>cgm_apll_400m_pub_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_250m_pub_force_en" pos="5" rst="0x1">
          <comment>cgm_apll_250m_pub_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_gnss_force_en" pos="4" rst="0x1">
          <comment>cgm_xtal_26m_gnss_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_167m_gnss_force_en" pos="3" rst="0x1">
          <comment>cgm_apll_167m_gnss_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_125m_gnss_force_en" pos="2" rst="0x1">
          <comment>cgm_apll_125m_gnss_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_apll_62_5m_gnss_force_en" pos="1" rst="0x1">
          <comment>cgm_apll_62_5m_gnss_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_xtal_26m_rf_force_en" pos="0" rst="0x1">
          <comment>cgm_xtal_26m_rf_force_en clock gating enable sw control</comment>
        </bits>
      </reg>
      <reg name="monitor_wait_en_status0_cfg" protect="rw">
        <comment>monitor_wait_en_status0_cfg</comment>
        <bits access="r" name="monitor_wait_en_status" pos="5:0" rst="0x0">
          <comment>monitor_wait_en_status , 0:apll_1000m, 1:mempll_1000m, 2:audio_pll_122m, 3:xtal_26m, 4:xtal_lp_26m, 5:rc26m_78m</comment>
        </bits>
      </reg>
      <reg name="monitor_div_auto_en_status0_cfg" protect="rw">
        <comment>monitor_div_auto_en_status0_cfg</comment>
        <bits access="r" name="monitor_div_auto_en_status" pos="11:0" rst="0x0">
          <comment>monitor_div_auto_en_status , 0:apll_div_1000m_90m9, 1:apll_div_1000m_500m, 2:apll_div_1000m_250m, 3:apll_div_1000m_125m, 4:apll_div_1000m_62m5, 5:apll_div_1000m_31m2, 6:apll_div_1000m_333m3, 7:apll_div_1000m_166m7, 8:apll_div_1000m_200m, 9:apll_div_1000m_100m, 10:audio_div_pll_122m_30m7, 11:mempll_div_1000m_500m</comment>
        </bits>
      </reg>
      <reg name="monitor_gate_auto_en_status00_cfg" protect="rw">
        <comment>monitor_gate_auto_en_status00_cfg</comment>
      </reg>
      <reg name="monitor_gate_auto_en_status10_cfg" protect="rw">
        <comment>monitor_gate_auto_en_status10_cfg</comment>
        <bits access="r" name="monitor_gate_auto_en_status1" pos="7:0" rst="0x0">
          <comment>monitor_gate_auto_en_status1 , 32:cgm_apll_500m_pub, 33:cgm_apll_400m_pub, 34:cgm_apll_250m_pub, 35:cgm_xtal_26m_gnss, 36:cgm_apll_167m_gnss, 37:cgm_apll_125m_gnss, 38:cgm_apll_62_5m_gnss, 39:cgm_xtal_26m_rf</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51508000" name="AON_CLK_GEN" type="AON_CLK_GEN"/>
  </archive>
  <archive relative="analog_g1.xml">
    <module category="System" name="ANALOG_G1">
      <reg name="analog_apll_apll_ctrl1" protect="rw">
        <comment>analog_apll_APLL_CTRL1</comment>
        <bits access="rw" name="analog_apll_apll_clkout_en" pos="18" rst="0x1"/>
        <bits access="rw" name="analog_apll_apll_ibias" pos="17:16" rst="0x1"/>
        <bits access="rw" name="analog_apll_apll_lpf" pos="15:13" rst="0x4"/>
        <bits access="rw" name="analog_apll_apll_ref_sel" pos="12" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_n" pos="11:1" rst="0x1e"/>
        <bits access="rw" name="analog_apll_apll_il_div2" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_apll_apll_ctrl2" protect="rw">
        <comment>analog_apll_APLL_CTRL2</comment>
        <bits access="rw" name="analog_apll_apll_ol_div2" pos="13:11" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_div_s" pos="10" rst="0x1"/>
        <bits access="rw" name="analog_apll_apll_sdm_en" pos="9" rst="0x1"/>
        <bits access="rw" name="analog_apll_apll_mod_en" pos="8" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_divn" pos="7:5" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_hop_en" pos="4" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_hop_trig" pos="3" rst="0x0"/>
        <bits access="r" name="analog_apll_apll_lock_done" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_rst" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_pd" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_apll_apll_int_value" protect="rw">
        <comment>analog_apll_APLL_INT_Value</comment>
        <bits access="rw" name="analog_apll_apll_nint" pos="26:20" rst="0x26"/>
        <bits access="rw" name="analog_apll_apll_kint" pos="19:0" rst="0x76276"/>
      </reg>
      <reg name="analog_apll_apll_ccs_ctrl" protect="rw">
        <comment>analog_apll_APLL_CCS_CTRL</comment>
        <bits access="rw" name="analog_apll_apll_ccs_ctrl" pos="15:0" rst="0x92d"/>
      </reg>
      <reg name="analog_apll_apll_kstep" protect="rw">
        <comment>analog_apll_APLL_KSTEP</comment>
        <bits access="rw" name="analog_apll_apll_kstep" pos="18:0" rst="0x19c"/>
      </reg>
      <reg name="analog_apll_ana_bias" protect="rw">
        <comment>analog_apll_ANA_BIAS</comment>
        <bits access="rw" name="analog_apll_apll_bias_top" pos="16:12" rst="0x9"/>
        <bits access="rw" name="analog_apll_apll_bist_ctrl" pos="11:2" rst="0x3ff"/>
        <bits access="rw" name="analog_apll_apll_bist_en" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_test_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_apll_ana_bias1" protect="rw">
        <comment>analog_apll_ANA_BIAS1</comment>
        <bits access="r" name="analog_apll_apll_bist_cnt" pos="18:3" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_dutyfix" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_apll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_apll_reg_sel_cfg_0" protect="rw">
        <comment>analog_apll_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_apll_apll_clkout_en" pos="4" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_apll_apll_rst" pos="3" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_apll_apll_pd" pos="2" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_apll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_apll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_mpll_apll_ctrl1" protect="rw">
        <comment>analog_mpll_APLL_CTRL1</comment>
        <bits access="rw" name="analog_mpll_apll_clkout_en" pos="18" rst="0x1"/>
        <bits access="rw" name="analog_mpll_apll_ibias" pos="17:16" rst="0x1"/>
        <bits access="rw" name="analog_mpll_apll_lpf" pos="15:13" rst="0x4"/>
        <bits access="rw" name="analog_mpll_apll_ref_sel" pos="12" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_n" pos="11:1" rst="0x1e"/>
        <bits access="rw" name="analog_mpll_apll_il_div2" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_mpll_apll_ctrl2" protect="rw">
        <comment>analog_mpll_APLL_CTRL2</comment>
        <bits access="rw" name="analog_mpll_apll_ol_div2" pos="13:11" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_div_s" pos="10" rst="0x1"/>
        <bits access="rw" name="analog_mpll_apll_sdm_en" pos="9" rst="0x1"/>
        <bits access="rw" name="analog_mpll_apll_mod_en" pos="8" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_divn" pos="7:5" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_hop_en" pos="4" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_hop_trig" pos="3" rst="0x0"/>
        <bits access="r" name="analog_mpll_apll_lock_done" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_rst" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_pd" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_mpll_apll_int_value" protect="rw">
        <comment>analog_mpll_APLL_INT_Value</comment>
        <bits access="rw" name="analog_mpll_apll_nint" pos="26:20" rst="0x1e"/>
        <bits access="rw" name="analog_mpll_apll_kint" pos="19:0" rst="0xc4ec5"/>
      </reg>
      <reg name="analog_mpll_apll_ccs_ctrl" protect="rw">
        <comment>analog_mpll_APLL_CCS_CTRL</comment>
        <bits access="rw" name="analog_mpll_apll_ccs_ctrl" pos="15:0" rst="0x92d"/>
      </reg>
      <reg name="analog_mpll_apll_kstep" protect="rw">
        <comment>analog_mpll_APLL_KSTEP</comment>
        <bits access="rw" name="analog_mpll_apll_kstep" pos="18:0" rst="0x19c"/>
      </reg>
      <reg name="analog_mpll_ana_bias" protect="rw">
        <comment>analog_mpll_ANA_BIAS</comment>
        <bits access="rw" name="analog_mpll_apll_bias_top" pos="16:12" rst="0x9"/>
        <bits access="rw" name="analog_mpll_apll_bist_ctrl" pos="11:2" rst="0x3ff"/>
        <bits access="rw" name="analog_mpll_apll_bist_en" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_test_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_mpll_ana_bias1" protect="rw">
        <comment>analog_mpll_ANA_BIAS1</comment>
        <bits access="r" name="analog_mpll_apll_bist_cnt" pos="18:3" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_dutyfix" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_mpll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_mpll_reg_sel_cfg_0" protect="rw">
        <comment>analog_mpll_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_mpll_apll_clkout_en" pos="4" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_mpll_apll_rst" pos="3" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_mpll_apll_pd" pos="2" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_mpll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_mpll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_iis_pll_apll_ctrl1" protect="rw">
        <comment>analog_iis_pll_APLL_CTRL1</comment>
        <bits access="rw" name="analog_iis_pll_apll_clkout_en" pos="18" rst="0x1"/>
        <bits access="rw" name="analog_iis_pll_apll_ibias" pos="17:16" rst="0x1"/>
        <bits access="rw" name="analog_iis_pll_apll_lpf" pos="15:13" rst="0x4"/>
        <bits access="rw" name="analog_iis_pll_apll_ref_sel" pos="12" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_n" pos="11:1" rst="0x1e"/>
        <bits access="rw" name="analog_iis_pll_apll_il_div2" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_iis_pll_apll_ctrl2" protect="rw">
        <comment>analog_iis_pll_APLL_CTRL2</comment>
        <bits access="rw" name="analog_iis_pll_apll_ol_div2" pos="13:11" rst="0x7"/>
        <bits access="rw" name="analog_iis_pll_apll_div_s" pos="10" rst="0x1"/>
        <bits access="rw" name="analog_iis_pll_apll_sdm_en" pos="9" rst="0x1"/>
        <bits access="rw" name="analog_iis_pll_apll_mod_en" pos="8" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_divn" pos="7:5" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_hop_en" pos="4" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_hop_trig" pos="3" rst="0x0"/>
        <bits access="r" name="analog_iis_pll_apll_lock_done" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_rst" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_pd" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_iis_pll_apll_int_value" protect="rw">
        <comment>analog_iis_pll_APLL_INT_Value</comment>
        <bits access="rw" name="analog_iis_pll_apll_nint" pos="26:20" rst="0x25"/>
        <bits access="rw" name="analog_iis_pll_apll_kint" pos="19:0" rst="0xcf29c"/>
      </reg>
      <reg name="analog_iis_pll_apll_ccs_ctrl" protect="rw">
        <comment>analog_iis_pll_APLL_CCS_CTRL</comment>
        <bits access="rw" name="analog_iis_pll_apll_ccs_ctrl" pos="15:0" rst="0x92d"/>
      </reg>
      <reg name="analog_iis_pll_apll_kstep" protect="rw">
        <comment>analog_iis_pll_APLL_KSTEP</comment>
        <bits access="rw" name="analog_iis_pll_apll_kstep" pos="18:0" rst="0x19c"/>
      </reg>
      <reg name="analog_iis_pll_ana_bias" protect="rw">
        <comment>analog_iis_pll_ANA_BIAS</comment>
        <bits access="rw" name="analog_iis_pll_apll_bias_top" pos="16:12" rst="0x9"/>
        <bits access="rw" name="analog_iis_pll_apll_bist_ctrl" pos="11:2" rst="0x3ff"/>
        <bits access="rw" name="analog_iis_pll_apll_bist_en" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_test_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_iis_pll_ana_bias1" protect="rw">
        <comment>analog_iis_pll_ANA_BIAS1</comment>
        <bits access="r" name="analog_iis_pll_apll_bist_cnt" pos="18:3" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_dutyfix" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_iis_pll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_iis_pll_reg_sel_cfg_0" protect="rw">
        <comment>analog_iis_pll_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_iis_pll_apll_clkout_en" pos="4" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_iis_pll_apll_rst" pos="3" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_iis_pll_apll_pd" pos="2" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_iis_pll_apll_precharge" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_iis_pll_apll_dvddiso" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_efuse4k_efuse_pin_pw_ctl" protect="rw">
        <comment>analog_efuse4k_EFUSE_PIN_PW_CTL</comment>
        <bits access="rw" name="analog_efuse4k_efs_enk1" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_efuse4k_efs_enk2" pos="0" rst="0x1"/>
      </reg>
      <reg name="analog_efuse4k_reg_sel_cfg_0" protect="rw">
        <comment>analog_efuse4k_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_efuse4k_efs_enk1" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_efuse4k_efs_enk2" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_efuse2k_efuse_pin_pw_ctl" protect="rw">
        <comment>analog_efuse2k_EFUSE_PIN_PW_CTL</comment>
        <bits access="rw" name="analog_efuse2k_efs_enk1" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_efuse2k_efs_enk2" pos="0" rst="0x1"/>
      </reg>
      <reg name="analog_efuse2k_reg_sel_cfg_0" protect="rw">
        <comment>analog_efuse2k_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_efuse2k_efs_enk1" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_efuse2k_efs_enk2" pos="0" rst="0x0"/>
      </reg>
      <hole size="7296"/>
      <reg name="analog_apll_apll_ctrl1_set" protect="rw"/>
      <reg name="analog_apll_apll_ctrl2_set" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_apll_ana_bias_set" protect="rw"/>
      <reg name="analog_apll_ana_bias1_set" protect="rw"/>
      <reg name="analog_apll_reg_sel_cfg_0_set" protect="rw"/>
      <reg name="analog_mpll_apll_ctrl1_set" protect="rw"/>
      <reg name="analog_mpll_apll_ctrl2_set" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_mpll_ana_bias_set" protect="rw"/>
      <reg name="analog_mpll_ana_bias1_set" protect="rw"/>
      <reg name="analog_mpll_reg_sel_cfg_0_set" protect="rw"/>
      <reg name="analog_iis_pll_apll_ctrl1_set" protect="rw"/>
      <reg name="analog_iis_pll_apll_ctrl2_set" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_iis_pll_ana_bias_set" protect="rw"/>
      <reg name="analog_iis_pll_ana_bias1_set" protect="rw"/>
      <reg name="analog_iis_pll_reg_sel_cfg_0_set" protect="rw"/>
      <reg name="analog_efuse4k_efuse_pin_pw_ctl_set" protect="rw"/>
      <reg name="analog_efuse4k_reg_sel_cfg_0_set" protect="rw"/>
      <reg name="analog_efuse2k_efuse_pin_pw_ctl_set" protect="rw"/>
      <reg name="analog_efuse2k_reg_sel_cfg_0_set" protect="rw"/>
      <hole size="7296"/>
      <reg name="analog_apll_apll_ctrl1_clr" protect="rw"/>
      <reg name="analog_apll_apll_ctrl2_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_apll_ana_bias_clr" protect="rw"/>
      <reg name="analog_apll_ana_bias1_clr" protect="rw"/>
      <reg name="analog_apll_reg_sel_cfg_0_clr" protect="rw"/>
      <reg name="analog_mpll_apll_ctrl1_clr" protect="rw"/>
      <reg name="analog_mpll_apll_ctrl2_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_mpll_ana_bias_clr" protect="rw"/>
      <reg name="analog_mpll_ana_bias1_clr" protect="rw"/>
      <reg name="analog_mpll_reg_sel_cfg_0_clr" protect="rw"/>
      <reg name="analog_iis_pll_apll_ctrl1_clr" protect="rw"/>
      <reg name="analog_iis_pll_apll_ctrl2_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="analog_iis_pll_ana_bias_clr" protect="rw"/>
      <reg name="analog_iis_pll_ana_bias1_clr" protect="rw"/>
      <reg name="analog_iis_pll_reg_sel_cfg_0_clr" protect="rw"/>
      <reg name="analog_efuse4k_efuse_pin_pw_ctl_clr" protect="rw"/>
      <reg name="analog_efuse4k_reg_sel_cfg_0_clr" protect="rw"/>
      <reg name="analog_efuse2k_efuse_pin_pw_ctl_clr" protect="rw"/>
      <reg name="analog_efuse2k_reg_sel_cfg_0_clr" protect="rw"/>
    </module>
    <var name="REG_ANALOG_G1_SET_OFFSET" value="0x400"/>
    <var name="REG_ANALOG_G1_CLR_OFFSET" value="0x800"/>
    <instance address="0x51501000" name="ANALOG_G1" type="ANALOG_G1"/>
  </archive>
  <archive relative="analog_g2.xml">
    <module category="System" name="ANALOG_G2">
      <reg name="analog_usb20_usb20_test_pin" protect="rw">
        <comment>analog_usb20_USB20_TEST_PIN</comment>
        <bits access="rw" name="analog_usb20_usb20_testclk" pos="24" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_testdatain" pos="23:16" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_testaddr" pos="15:12" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_testdataoutsel" pos="11" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_testdataout" pos="10:7" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bist_mode" pos="6:2" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_t2rcomp" pos="1" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_lpbk_end" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_usb20_usb20_utmi_ctl1" protect="rw">
        <comment>analog_usb20_USB20_UTMI_CTL1</comment>
        <bits access="rw" name="analog_usb20_usb20_databus16_8" pos="28" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_suspendm" pos="27" rst="0x1"/>
        <bits access="rw" name="analog_usb20_usb20_porn" pos="26" rst="0x1"/>
        <bits access="rw" name="analog_usb20_usb20_reset" pos="25" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_rxerror" pos="24" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bypass_drv_dp" pos="23" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bypass_drv_dm" pos="22" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bypass_fs" pos="21" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bypass_in_dp" pos="20" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_bypass_in_dm" pos="19" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_bypass_out_dp" pos="18" rst="0x0"/>
        <bits access="r" name="analog_usb20_usb20_bypass_out_dm" pos="17" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_vbusvldext" pos="16" rst="0x1"/>
      </reg>
      <reg name="analog_usb20_usb20_batter_pll" protect="rw">
        <comment>analog_usb20_USB20_BATTER_PLL</comment>
        <bits access="rw" name="analog_usb20_usb20_rextenable" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_dmpullup" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_sampler_sel" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_usb20_usb20_utmi_ctl2" protect="rw">
        <comment>analog_usb20_USB20_UTMI_CTL2</comment>
        <bits access="rw" name="analog_usb20_usb20_dppulldown" pos="4" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_dmpulldown" pos="3" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_txbitstuffenable" pos="2" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_txbitstuffenableh" pos="1" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_sleepm" pos="0" rst="0x1"/>
      </reg>
      <reg name="analog_usb20_usb20_trimming" protect="rw">
        <comment>analog_usb20_USB20_TRIMMING</comment>
        <bits access="rw" name="analog_usb20_usb20_tunehsamp" pos="28:27" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_tfregres" pos="26:21" rst="0x1f"/>
        <bits access="rw" name="analog_usb20_usb20_tfhsres" pos="20:16" rst="0xf"/>
        <bits access="rw" name="analog_usb20_usb20_tunerise" pos="15:14" rst="0x1"/>
        <bits access="rw" name="analog_usb20_usb20_tuneotg" pos="13:11" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_tunedsc" pos="10:9" rst="0x1"/>
        <bits access="rw" name="analog_usb20_usb20_tunesq" pos="8:5" rst="0x8"/>
        <bits access="rw" name="analog_usb20_usb20_tuneeq" pos="4:2" rst="0x0"/>
        <bits access="rw" name="analog_usb20_usb20_tuneplls" pos="1:0" rst="0x1"/>
      </reg>
      <reg name="analog_usb20_reg_sel_cfg_0" protect="rw">
        <comment>analog_usb20_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_suspendm" pos="11" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_porn" pos="10" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_reset" pos="9" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_bypass_drv_dm" pos="8" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_bypass_fs" pos="7" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_bypass_in_dm" pos="6" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_rextenable" pos="5" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_dmpullup" pos="4" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_sampler_sel" pos="3" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_dppulldown" pos="2" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_dmpulldown" pos="1" rst="0x0"/>
        <bits access="rw" name="dbg_sel_analog_usb20_usb20_sleepm" pos="0" rst="0x0"/>
      </reg>
      <hole size="8000"/>
      <reg name="analog_usb20_usb20_test_pin_set" protect="rw"/>
      <reg name="analog_usb20_usb20_utmi_ctl1_set" protect="rw"/>
      <reg name="analog_usb20_usb20_batter_pll_set" protect="rw"/>
      <reg name="analog_usb20_usb20_utmi_ctl2_set" protect="rw"/>
      <hole size="32"/>
      <reg name="analog_usb20_reg_sel_cfg_0_set" protect="rw"/>
      <hole size="8000"/>
      <reg name="analog_usb20_usb20_test_pin_clr" protect="rw"/>
      <reg name="analog_usb20_usb20_utmi_ctl1_clr" protect="rw"/>
      <reg name="analog_usb20_usb20_batter_pll_clr" protect="rw"/>
      <reg name="analog_usb20_usb20_utmi_ctl2_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="analog_usb20_reg_sel_cfg_0_clr" protect="rw"/>
    </module>
    <var name="REG_ANALOG_G2_SET_OFFSET" value="0x400"/>
    <var name="REG_ANALOG_G2_CLR_OFFSET" value="0x800"/>
    <instance address="0x5150f000" name="ANALOG_G2" type="ANALOG_G2"/>
  </archive>
  <archive relative="analog_g3.xml">
    <module category="System" name="ANALOG_G3">
      <reg name="analog_osc_26m_apll_ctrl" protect="rw">
        <comment>analog_osc_26m_APLL_CTRL</comment>
        <bits access="rw" name="analog_osc_26m_osc26m_pu" pos="8" rst="0x0"/>
        <bits access="rw" name="analog_osc_26m_osc26m_r_tune" pos="7:4" rst="0x8"/>
        <bits access="rw" name="analog_osc_26m_osc26m_c_tune" pos="3:1" rst="0x4"/>
        <bits access="rw" name="analog_osc_26m_osc26m_ibas_ctrl" pos="0" rst="0x0"/>
      </reg>
      <reg name="analog_osc_26m_reg_sel_cfg_0" protect="rw">
        <comment>analog_osc_26m_REG_SEL_CFG_0</comment>
        <bits access="rw" name="dbg_sel_analog_osc_26m_osc26m_pu" pos="0" rst="0x0"/>
      </reg>
      <hole size="8128"/>
      <reg name="analog_osc_26m_apll_ctrl_set" protect="rw"/>
      <reg name="analog_osc_26m_reg_sel_cfg_0_set" protect="rw"/>
      <hole size="8128"/>
      <reg name="analog_osc_26m_apll_ctrl_clr" protect="rw"/>
      <reg name="analog_osc_26m_reg_sel_cfg_0_clr" protect="rw"/>
    </module>
    <var name="REG_ANALOG_G3_SET_OFFSET" value="0x400"/>
    <var name="REG_ANALOG_G3_CLR_OFFSET" value="0x800"/>
    <instance address="0x51709000" name="ANALOG_G3" type="ANALOG_G3"/>
  </archive>
  <archive relative="aon_clk.xml">
    <module category="System" name="AON_CLK">
      <hole size="288"/>
      <reg name="cgm_aon_ahb_div_cfg" protect="rw">
        <comment>cgm_aon_ahb_div_cfg</comment>
        <bits access="rw" name="cgm_aon_ahb_div" pos="1:0" rst="0x0">
          <comment>cgm_aon_ahb_div: clk_aon_ahb = clk_src/(div +1), default value = 2'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_aon_ahb_sel_cfg" protect="rw">
        <comment>cgm_aon_ahb_sel_cfg</comment>
        <bits access="rw" name="cgm_aon_ahb_sel" pos="2:0" rst="0x1">
          <comment>cgm_aon_ahb_sel: clk_aon_ahb source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: apll_100m, 4: gnss_pll_133m, 5: apll_167m, 6: gnss_pll_198m, 7: apll_200m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_uart2_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart2_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart2_bf_div_sel" pos="2:0" rst="0x1">
          <comment>cgm_uart2_bf_div_sel: clk_uart2_bf_div source , 0: rtc_32k, 1: xtal_lp_26m, 2: xtal_26m, 3: rc26m_78m, 4: apll_31_25m, 5: apll_125m, 6: gnss_pll_133m, 7: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_uart3_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart3_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart3_bf_div_sel" pos="2:0" rst="0x1">
          <comment>cgm_uart3_bf_div_sel: clk_uart3_bf_div source , 0: rtc_32k, 1: xtal_lp_26m, 2: xtal_26m, 3: rc26m_78m, 4: apll_31_25m, 5: apll_125m, 6: gnss_pll_133m, 7: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_debug_host_bf_div_sel_cfg" protect="rw">
        <comment>cgm_debug_host_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_debug_host_bf_div_sel" pos="1:0" rst="0x1">
          <comment>cgm_debug_host_bf_div_sel: clk_debug_host_bf_div source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, default: 2'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_audio_div_cfg" protect="rw">
        <comment>cgm_audio_div_cfg</comment>
        <bits access="rw" name="cgm_audio_div" pos="3:0" rst="0x0">
          <comment>cgm_audio_div: clk_audio = clk_src/(div +1), default value = 4'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_audio_sel_cfg" protect="rw">
        <comment>cgm_audio_sel_cfg</comment>
        <bits access="rw" name="cgm_audio_sel" pos="2:0" rst="0x0">
          <comment>cgm_audio_sel: clk_audio source , 0: xtal_26m, 1: rc26m_78m, 2: audio_pll_30_72m, 3: apll_31_25m, 4: gnss_pll_33_25m, 5: apll_62_5m, default: 3'h0</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_codec_mclock_div_cfg" protect="rw">
        <comment>cgm_codec_mclock_div_cfg</comment>
        <bits access="rw" name="cgm_codec_mclock_div" pos="3:0" rst="0x0">
          <comment>cgm_codec_mclock_div: clk_codec_mclock = clk_src/(div +1), default value = 4'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_codec_mclock_sel_cfg" protect="rw">
        <comment>cgm_codec_mclock_sel_cfg</comment>
        <bits access="rw" name="cgm_codec_mclock_sel" pos="2:0" rst="0x0">
          <comment>cgm_codec_mclock_sel: clk_codec_mclock source , 0: xtal_26m, 1: rc26m_78m, 2: audio_pll_30_72m, 3: apll_31_25m, 4: gnss_pll_33_25m, 5: apll_62_5m, default: 3'h0</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_i2s_bck_bf_div_div_cfg" protect="rw">
        <comment>cgm_i2s_bck_bf_div_div_cfg</comment>
        <bits access="rw" name="cgm_i2s_bck_bf_div_div" pos="11:0" rst="0xf">
          <comment>cgm_i2s_bck_bf_div_div: clk_i2s_bck_bf_div = clk_src/(div +1), default value = 12'hf</comment>
        </bits>
      </reg>
      <reg name="cgm_i2s_bck_bf_div_sel_cfg" protect="rw">
        <comment>cgm_i2s_bck_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_i2s_bck_bf_div_pad_sel" pos="16" rst="0x0">
          <comment>cgm_i2s_bck_bf_div_pad_sel: reserved, no use.</comment>
        </bits>
        <bits access="rw" name="cgm_i2s_bck_bf_div_sel" pos="2:0" rst="0x0">
          <comment>cgm_i2s_bck_bf_div_sel: clk_i2s_bck_bf_div source , 0: xtal_26m, 1: rc26m_78m, 2: gnss_pll_133m, 3: audio_pll_122_88m, 4: apll_167m, default: 3'h0</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_out_div_cfg" protect="rw">
        <comment>cgm_out_div_cfg</comment>
        <bits access="rw" name="cgm_out_div" pos="7:0" rst="0x0">
          <comment>cgm_out_div: clk_out = clk_src/(div +1), default value = 8'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_out_sel_cfg" protect="rw">
        <comment>cgm_out_sel_cfg</comment>
        <bits access="rw" name="cgm_out_sel" pos="2:0" rst="0x1">
          <comment>cgm_out_sel: clk_out source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: audio_pll_122_88m, 4: gnss_pll_133m, 5: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_efuse_sel_cfg" protect="rw">
        <comment>cgm_efuse_sel_cfg</comment>
        <bits access="rw" name="cgm_efuse_sel" pos="1:0" rst="0x1">
          <comment>cgm_efuse_sel: clk_efuse source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, default: 2'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_adi_sel_cfg" protect="rw">
        <comment>cgm_adi_sel_cfg</comment>
        <bits access="rw" name="cgm_adi_sel" pos="1:0" rst="0x1">
          <comment>cgm_adi_sel: clk_adi source , 0: rtc_32k, 1: xtal_lp_26m, 2: xtal_26m, 3: rc26m_78m, default: 2'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_dap_sel_cfg" protect="rw">
        <comment>cgm_dap_sel_cfg</comment>
        <bits access="rw" name="cgm_dap_sel" pos="2:0" rst="0x1">
          <comment>cgm_dap_sel: clk_dap source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: gnss_pll_133m, 4: apll_200m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="352"/>
      <reg name="cgm_djtag_tck_sel_cfg" protect="rw">
        <comment>cgm_djtag_tck_sel_cfg</comment>
        <bits access="rw" name="cgm_djtag_tck_pad_sel" pos="16" rst="0x0">
          <comment>cgm_djtag_tck_pad_sel: clock source from pad, high active, default: 1'h0</comment>
        </bits>
        <bits access="rw" name="cgm_djtag_tck_sel" pos="0" rst="0x0">
          <comment>cgm_djtag_tck_sel: clk_djtag_tck source , 0: rtc_32k, 1: xtal_26m, default: 1'h0</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_swcgm_hw_sel_cfg" protect="rw">
        <comment>cgm_swcgm_hw_sel_cfg</comment>
        <bits access="rw" name="cgm_swcgm_hw_pad_sel" pos="16" rst="0x0">
          <comment>cgm_swcgm_hw_pad_sel: clock source from pad, high active, default: 1'h0</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_gpt2_sel_cfg" protect="rw">
        <comment>cgm_gpt2_sel_cfg</comment>
        <bits access="rw" name="cgm_gpt2_sel" pos="2:0" rst="0x1">
          <comment>cgm_gpt2_sel: clk_gpt2 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: gnss_pll_133m, 4: apll_200m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_i2c3_sel_cfg" protect="rw">
        <comment>cgm_i2c3_sel_cfg</comment>
        <bits access="rw" name="cgm_i2c3_sel" pos="2:0" rst="0x1">
          <comment>cgm_i2c3_sel: clk_i2c3 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: gnss_pll_133m, 4: apll_200m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="cgm_usb_ref_sel_cfg" protect="rw">
        <comment>cgm_usb_ref_sel_cfg</comment>
        <bits access="rw" name="cgm_usb_ref_sel" pos="0" rst="0x1">
          <comment>cgm_usb_ref_sel: clk_usb_ref source , 0: rtc_32k, 1: xtal_26m, default: 1'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_usb_ahb_div_cfg" protect="rw">
        <comment>cgm_usb_ahb_div_cfg</comment>
        <bits access="rw" name="cgm_usb_ahb_div" pos="1:0" rst="0x0">
          <comment>cgm_usb_ahb_div: clk_usb_ahb = clk_src/(div +1), default value = 2'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_usb_ahb_sel_cfg" protect="rw">
        <comment>cgm_usb_ahb_sel_cfg</comment>
        <bits access="rw" name="cgm_usb_ahb_sel" pos="2:0" rst="0x1">
          <comment>cgm_usb_ahb_sel: clk_usb_ahb source , 0: rtc_32k, 1: xtal_26m, 2: apll_125m, 3: gnss_pll_133m, 4: apll_167m, 5: apll_200m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_spi2_div_cfg" protect="rw">
        <comment>cgm_spi2_div_cfg</comment>
        <bits access="rw" name="cgm_spi2_div" pos="2:0" rst="0x0">
          <comment>cgm_spi2_div: clk_spi2 = clk_src/(div +1), default value = 3'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_spi2_sel_cfg" protect="rw">
        <comment>cgm_spi2_sel_cfg</comment>
        <bits access="rw" name="cgm_spi2_pad_sel" pos="16" rst="0x0">
          <comment>cgm_spi2_pad_sel: clock source from pad, high active, default: 1'h0</comment>
        </bits>
        <bits access="rw" name="cgm_spi2_sel" pos="2:0" rst="0x1">
          <comment>cgm_spi2_sel: clk_spi2 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_78m, 3: gnss_pll_133m, 4: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_scc_sel_cfg" protect="rw">
        <comment>cgm_scc_sel_cfg</comment>
        <bits access="rw" name="cgm_scc_pad_sel" pos="16" rst="0x1">
          <comment>cgm_scc_pad_sel: clock source from pad, high active, default: 1'h0</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_sdio_2x_div_cfg" protect="rw">
        <comment>cgm_sdio_2x_div_cfg</comment>
        <bits access="rw" name="cgm_sdio_2x_div" pos="10:0" rst="0x0">
          <comment>cgm_sdio_2x_div: reserved, no use.</comment>
        </bits>
      </reg>
      <reg name="cgm_sdio_2x_sel_cfg" protect="rw">
        <comment>cgm_sdio_2x_sel_cfg</comment>
        <bits access="rw" name="cgm_sdio_2x_sel" pos="2:0" rst="0x0">
          <comment>cgm_sdio_2x_sel: clk_sdio_2x source , 0: xtal_26m, 1: rc26m_78m, 2: apll_333m, 3: gnss_pll_397m, 4: apll_400m, default: 3'h0</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_sdio_1x_div_cfg" protect="rw">
        <comment>cgm_sdio_1x_div_cfg</comment>
        <bits access="rw" name="cgm_sdio_1x_div" pos="0" rst="0x1">
          <comment>cgm_sdio_1x_div: clk_sdio_1x = clk_src/(div +1), default value = 1'h1</comment>
        </bits>
      </reg>
      <hole size="608"/>
      <reg name="cgm_busy_src_monitor_cfg0" protect="rw">
        <comment>cgm_busy_src_monitor_cfg0</comment>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg1" protect="rw">
        <comment>cgm_busy_src_monitor_cfg1</comment>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg2" protect="rw">
        <comment>cgm_busy_src_monitor_cfg2</comment>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg3" protect="rw">
        <comment>cgm_busy_src_monitor_cfg3</comment>
      </reg>
    </module>
    <instance address="0x51508800" name="AON_CLK" type="AON_CLK"/>
  </archive>
  <archive relative="aon_spi.xml">
    <module category="System" name="AON_SPI">
      <reg name="spi_txd" protect="rw">
        <comment>Transmit word or Receive word Write data to this address initiates a character transmission through TX FIFO
Read this address retrieve data from RX fifo</comment>
      </reg>
      <reg name="spi_clkd" protect="rw">
        <comment>Clock divisor  Clock divisor bit 0 to 15</comment>
        <bits access="rw" name="spi_clkd" pos="15:0" rst="0x3">
          <comment>Specify the clock ratio between spi_sck and clk_spi.
If clk_spi runs at 48 MHz, and spi_sck runs at 12MHz, SPI_CLKD should be 1,
spi_sck = clk_spi/2(n+1).
If IS_FST bit is assert, the valid SPI_CLKD is 0, 1, 2 and 3.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl0" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="sync_3wrd_pol" pos="15" rst="0x0">
          <comment>Sync_polarity, positive or negative pulse for SPI or 3-wire mode ,read command polarity</comment>
        </bits>
        <bits access="rw" name="sync_md" pos="14" rst="0x0">
          <comment>1 : sync mode</comment>
        </bits>
        <bits access="rw" name="is_sck_rev" pos="13" rst="0x0">
          <comment>1 : spi_sck reverse</comment>
        </bits>
        <bits access="rw" name="spi_csn_pre" pos="11:8" rst="0xf">
          <comment>1 bit chip select.
0: cs0 is valid
1: cs0 is invalid</comment>
        </bits>
        <bits access="rw" name="lsb" pos="7" rst="0x0">
          <comment>In default, The input data is shifted high order first into the chip; the output data is shifted out high order first from the Most Significant Bit (MSB) on SO. When this bit is set, the data will be shift out or in from the LSB</comment>
        </bits>
        <bits access="rw" name="chnl_len" pos="6:2" rst="0x0">
          <comment>Transmit data bit number.
0 : 32 bits per word
1 : 1 bits per word

31: 31 bits per word</comment>
        </bits>
        <bits access="rw" name="ng_tx" pos="1" rst="0x1">
          <comment>1 enable TX data shift out at clock neg-edge</comment>
        </bits>
        <bits access="rw" name="ng_rx" pos="0" rst="0x0">
          <comment>1 enable RX data shift in at clock neg-edge</comment>
        </bits>
      </reg>
      <reg name="spi_ctl1" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="do_hold_en" pos="15:14" rst="0x0">
          <comment>00 : default(follow before version)
01 : spi do stay 0 value when in idle
10 : spi do stay 1 value when in idle
11 : spi do stay last-bit value when in idle</comment>
        </bits>
        <bits access="rw" name="is_txmd" pos="13" rst="0x1">
          <comment>1:is tx mode 0:not tx mode</comment>
        </bits>
        <bits access="rw" name="is_rxmd" pos="12" rst="0x1">
          <comment>1:is rx mode 0:not rx mode</comment>
        </bits>
        <bits access="rw" name="sync_csn_sel" pos="11:8" rst="0x0">
          <comment>S8 CD or SYNC signal maps to csn number
0x0001 selects csn0 as cd signal
0x0010 selects csn1 as cd signal
In SPI_HS it must be 0x0000 and disable sync and s8 mode</comment>
        </bits>
        <bits access="rw" name="s8_md" pos="7" rst="0x0">
          <comment>1 : enable S8 mode</comment>
        </bits>
        <bits access="rw" name="cs_h_md" pos="6" rst="0x0">
          <comment>3-wire Melody timing 1, csn high mode enable</comment>
        </bits>
        <bits access="rw" name="s3w_md" pos="5" rst="0x0">
          <comment>1 : enable 3-wire mode</comment>
        </bits>
        <bits access="rw" name="s3w_pos" pos="4:0" rst="0x0">
          <comment>3-wire mode, w/r control position
or the sync pulse position(the pulse will
locates on top of bit N)</comment>
        </bits>
      </reg>
      <reg name="spi_ctl2" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="dma_req_seq_sel" pos="10" rst="0x0">
          <comment>0:DMA TX and RX REQ independent
1:DMA TX REQ are depended on RX REQ status</comment>
        </bits>
        <bits access="rw" name="tx_dma_sel" pos="9" rst="0x0">
          <comment>0: tx_dma_req keep 1 until receiving the tx_dma_ack
1: tx_dma_req is 1 when tx_empty is 1,else 0</comment>
        </bits>
        <bits access="rw" name="rx_dma_sel" pos="8" rst="0x0">
          <comment>0: rx_dma_req keep 1 until receiving the rx_dma_ack
1: rx_dma_req is 1 when rx_full is 1,else 0</comment>
        </bits>
        <bits access="rw" name="rx_only_nhd" pos="7" rst="0x0">
          <comment>0 : working on only receive
mode, when rxf_realfull is high, SPI will be held until rxf_realfull is low
1 : no holding</comment>
        </bits>
        <bits access="rw" name="dma_en" pos="6" rst="0x0">
          <comment>1 enable DMA mode</comment>
        </bits>
        <bits access="rw" name="is_slvd" pos="5" rst="0x0">
          <comment>0 : master
1 : slave, only support microplus mode</comment>
        </bits>
        <bits access="rw" name="s3w_rd_strt" pos="4:0" rst="0x0">
          <comment>Read data start bit, used for 3 wire mode and 3 wire 9bit RW mode.
The 3 wire 9bit RW mode reuse this config registers, it indicated read data start position.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl3" protect="rw">
        <comment>RXF watermark  SPI RX FIFO FULL/EMPTY watermark</comment>
        <bits access="rw" name="rxf_empty_thrhld" pos="12:8" rst="0x10">
          <comment>Receive FIFO data empty threshold. Relative with rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="rw" name="rxf_full_thrhld" pos="4:0" rst="0x10">
          <comment>Receive FIFO data full threshold. Relative with rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_ctl4" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="rx_only_do" pos="15" rst="0x0">
          <comment>working in only receive mode,
0 : SPI send all 0 to slave
1 : SPI send all 1 to slave</comment>
        </bits>
        <bits access="rw" name="is_fst" pos="14" rst="0x0">
          <comment>working in only receive mode,
0 : SPI send all 0 to slave
1 : SPI send all 1 to slave</comment>
        </bits>
        <bits access="rw" name="phs_dly" pos="13:12" rst="0x0">
          <comment>0 : normal mode
1 : fast mode
Both for matser mode and slave mode,and in master mode SPI_SCK must be quicker  than 1/8 spi_clk</comment>
        </bits>
        <bits access="rw" name="sync_clkmask_en" pos="11" rst="0x0">
          <comment>Phase delay. Relate to fast mode.
When in normal mode, this bit is not used . Only used for slave mode</comment>
        </bits>
        <bits access="rw" name="sync_half" pos="10" rst="0x0">
          <comment>1 Mask out the first clock pulse in SPI mode</comment>
        </bits>
        <bits access="rw" name="is_rx_only" pos="9" rst="0x0">
          <comment>Sync_half, sync width is half  spi_sck cycle</comment>
        </bits>
        <bits access="rw" name="block_num" pos="8:0" rst="0x0">
          <comment>Number of data words ready to receive in receive only mode. Only used for master mode.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl5" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="itvl_num_sam" pos="15:0" rst="0x0">
          <comment>For master, transmit data interval, programmable n from 0 to 65535, delay is (n*4+3) clock cycle.
For slave, max receive data interval. If the slave has not sampled the edge of spi_clk in the interval(n*4+3), slave will stop the receive process and send timout interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_int_en" protect="rw">
        <comment>Interrupt enable  SPI interrupt enable register</comment>
        <bits access="rw" name="rx_end_int_en" pos="9" rst="0x0">
          <comment>Rx end interrupt enable</comment>
        </bits>
        <bits access="rw" name="tx_end_int_en" pos="8" rst="0x0">
          <comment>Tx end interrupt enable</comment>
        </bits>
        <bits access="rw" name="txf_w_empty_int_en" pos="7" rst="0x0">
          <comment>txf_empty interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_r_full_int_en" pos="6" rst="0x0">
          <comment>Rxf_full interrupt enable</comment>
        </bits>
        <bits access="rw" name="time_out_int_en" pos="5" rst="0x0">
          <comment>Slave mode timeout interrupt enable</comment>
        </bits>
        <bits access="rw" name="rx_ovf_int_en" pos="4" rst="0x0">
          <comment>Rx_overrun_reg interrupt enable</comment>
        </bits>
        <bits access="rw" name="txf_empty_en" pos="3" rst="0x0"/>
        <bits access="rw" name="txf_full_int_en" pos="2" rst="0x0">
          <comment>Tx_fifo_full interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_empty_int_en" pos="1" rst="0x0">
          <comment>Rx_fifo_empty interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_full_int_en" pos="0" rst="0x0">
          <comment>Rx_fifo_full interrupt enable</comment>
        </bits>
      </reg>
      <reg name="spi_int_clr" protect="rw">
        <comment>Interrupt clear SPI interrupt clear register</comment>
        <bits access="w" name="rx_end_int_clr" pos="9" rst="0x0">
          <comment>Rx data end interrupt clear</comment>
        </bits>
        <bits access="w" name="tx_end_int_clr" pos="8" rst="0x0">
          <comment>Tx data end interrupt clear</comment>
        </bits>
        <bits access="w" name="time_out_int_clr" pos="5" rst="0x0">
          <comment>Write 1 clear slave mode timeout interrupt</comment>
        </bits>
        <bits access="w" name="rx_ovf_int_clr" pos="4" rst="0x0">
          <comment>Write 1 clear Rx_overrun_reg interrupt</comment>
        </bits>
        <bits access="w" name="txf_empty_int_clr" pos="3" rst="0x0">
          <comment>Write 1 clear Tx_fifo_empty interrupt</comment>
        </bits>
        <bits access="w" name="txf_full_int_clr" pos="2" rst="0x0">
          <comment>Write 1 clear Tx_fifo_full interrupt</comment>
        </bits>
        <bits access="w" name="rxf_empty_int_clr" pos="1" rst="0x0">
          <comment>Write 1 clear Rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="w" name="rxf_full_int_clr" pos="0" rst="0x0">
          <comment>Write 1 clear Rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_int_raw_sts" protect="rw">
        <comment>Raw status  SPI interrupt raw status</comment>
        <bits access="r" name="rx_end_irq" pos="9" rst="0x0">
          <comment>Raw rx data end interrupt, this bit is set when spi controller received RX_DATA_LEN data from slave.</comment>
        </bits>
        <bits access="r" name="tx_end_irq" pos="8" rst="0x0">
          <comment>Raw tx data end interrupt,this bit is set when spi controller send TX_DATA_LEN data.</comment>
        </bits>
        <bits access="r" name="txf_empty_w" pos="7" rst="0x1">
          <comment>Raw txf_empty interrupt, This bit is set when the number of tx fifo data byte is less than the tx empty watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_full_r" pos="6" rst="0x0">
          <comment>Raw rxf_full interrupt.This bit is set when the number of rx fifo data byte is larger than the rx full watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="time_out_raw_sts" pos="5" rst="0x0">
          <comment>Raw slave mode time out interrupt</comment>
        </bits>
        <bits access="r" name="rx_ovf_raw_sts" pos="4" rst="0x0">
          <comment>Raw Rx_overrun_reg interrupt</comment>
        </bits>
        <bits access="r" name="tx_fifo_empty_w" pos="3" rst="0x1">
          <comment>Txf_empty_w(for debug)</comment>
        </bits>
        <bits access="r" name="txf_full_raw_sts" pos="2" rst="0x0">
          <comment>Raw Tx_fifo_full interrupt</comment>
        </bits>
        <bits access="r" name="rxf_empty_raw_sts" pos="1" rst="0x1">
          <comment>Raw rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="r" name="rx_full_raw_sts" pos="0" rst="0x0">
          <comment>Rxf_full_r(for debug)</comment>
        </bits>
      </reg>
      <reg name="spi_int_mask_sts" protect="rw">
        <comment>Mask status  SPI interrupt mask status</comment>
        <bits access="r" name="rx_end_irq_mask_sts" pos="9" rst="0x0">
          <comment>Raw rx data end interrupt, this bit is set when spi controller received RX_DATA_LEN data from slave.</comment>
        </bits>
        <bits access="r" name="tx_end_irq_mask_sts" pos="8" rst="0x0">
          <comment>Raw tx data end interrupt,this bit is set when spi controller send TX_DATA_LEN data.</comment>
        </bits>
        <bits access="r" name="txf_empty_mask_sts" pos="7" rst="0x1">
          <comment>Txf_empty interrupt mask status.</comment>
        </bits>
        <bits access="r" name="rxf_full_mask_sts" pos="6" rst="0x0">
          <comment>Rxf_full interrupt mask status.</comment>
        </bits>
        <bits access="r" name="time_out_mask_sts" pos="5" rst="0x0">
          <comment>Slave mode time out interrupt mask status</comment>
        </bits>
        <bits access="r" name="rx_ovf_mask_sts" pos="4" rst="0x0">
          <comment>Rx_overrun_reg interrupt mask status</comment>
        </bits>
        <bits access="r" name="txf_full_mask_sts" pos="2" rst="0x0">
          <comment>Tx_fifo_full interrupt mask status</comment>
        </bits>
        <bits access="r" name="rxf_empty_mask_sts" pos="1" rst="0x1">
          <comment>Rx_fifo_empty interrupt mask status</comment>
        </bits>
      </reg>
      <reg name="spi_sts1" protect="rw">
        <comment>RXF address  SPI RX FIFO write address and read address</comment>
        <bits access="r" name="rxf_waddr" pos="12:8" rst="0x0">
          <comment>RX FIFO write address</comment>
        </bits>
        <bits access="r" name="rxf_raddr" pos="4:0" rst="0x0">
          <comment>RX FIFO read address</comment>
        </bits>
      </reg>
      <reg name="spi_sts2" protect="rw">
        <comment>latch SPI status  SPI status register</comment>
        <bits access="r" name="spi_cs" pos="12" rst="0x0">
          <comment>Spi_cs(for debug)</comment>
        </bits>
        <bits access="r" name="spi_sck" pos="11" rst="0x0">
          <comment>Spi_sck(for debug)</comment>
        </bits>
        <bits access="r" name="spi_txd" pos="10" rst="0x0">
          <comment>Spi_txd(for debug)</comment>
        </bits>
        <bits access="r" name="spi_rxd" pos="9" rst="0x0">
          <comment>Spi_rxd(for debug)</comment>
        </bits>
        <bits access="r" name="busy" pos="8" rst="0x0">
          <comment>1 transmit process
0 idle state</comment>
        </bits>
        <bits access="r" name="txf_real_empty" pos="7" rst="0x1">
          <comment>TX FIFO has no data</comment>
        </bits>
        <bits access="r" name="txf_real_full" pos="6" rst="0x0">
          <comment>TX FIFO is real full. (not relates to TX full threshold)</comment>
        </bits>
        <bits access="r" name="rxf_real_empty" pos="5" rst="0x1">
          <comment>RX FIFO has no data</comment>
        </bits>
        <bits access="r" name="rxf_real_full" pos="4" rst="0x0">
          <comment>RX FIFO is real full. (not relates to TX full threshold)</comment>
        </bits>
        <bits access="r" name="txf_empty" pos="3" rst="0x1">
          <comment>This bit is set when the number of TX FIFO data byte is less than the TX empty interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="txf_full" pos="2" rst="0x0">
          <comment>This bit is set when the number of TX FIFO data byte is larger than the TX full interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_empty" pos="1" rst="0x1">
          <comment>This bit is set when the number of RX FIFO data byte is less than the RX empty interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_full" pos="0" rst="0x0">
          <comment>This bit is set when the number of RX FIFO data byte is larger than the RX full interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
      </reg>
      <reg name="spi_dspwait" protect="rw">
        <comment>DSP Register This register is used for DSP control</comment>
        <bits access="rw" name="tx_data_swt" pos="7:6" rst="0x0">
          <comment>Write data switch.
2b0: WDATA=PDATA;
2b1: WDATA={PDATA[7:0], PDATA[15:8], PDATA[23:16], PDATA[31:24]};
2b2: WDATA={PDATA[15:0],PDATA[31:16]};
2b3: WDATA={PDATA[23:16], PDATA[31:24], PDATA[7:0], PDATA[15:8]};</comment>
        </bits>
        <bits access="rw" name="rx_data_swt" pos="5:4" rst="0x0">
          <comment>Read data switch.
2b0: RDATA=PDATA;
2b1: RDATA={PDATA[7:0], PDATA[15:8], PDATA[23:16], PDATA[31:24]};
2b2: RDATA={PDATA[15:0],PDATA[31:16]};</comment>
        </bits>
        <bits access="rw" name="spi_dspwait" pos="3:0" rst="0x1">
          <comment>This register is used for DSP control</comment>
        </bits>
      </reg>
      <reg name="spi_sts3" protect="rw">
        <comment>RX conunter monitor This register is used to observe the status</comment>
        <bits access="r" name="rx_cnt" pos="8:0" rst="0x0">
          <comment>working in only receive mode
as master</comment>
        </bits>
      </reg>
      <reg name="spi_ctl6" protect="rw">
        <comment>TXF configuration This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="txf_empty_thrhld" pos="12:8" rst="0x10">
          <comment>TX FIFO data empty threshold. Relative with rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="rw" name="txf_full_thrhld" pos="4:0" rst="0x10">
          <comment>TX FIFO data full threshold. Relative with rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_sts4" protect="rw">
        <comment>TXF address This register is used to configuration of the SPI interface</comment>
        <bits access="r" name="txf_waddr" pos="12:8" rst="0x0">
          <comment>TX FIFO write address</comment>
        </bits>
        <bits access="r" name="txf_raddr" pos="4:0" rst="0x0">
          <comment>TX FIFO read address</comment>
        </bits>
      </reg>
      <reg name="spi_fifo_rst" protect="rw">
        <comment>FIFO reset configuration Used to reset TX/RX FIFO</comment>
        <bits access="rw" name="spi_fifo_rst" pos="0" rst="0x0">
          <comment>1 : reset all FIFOs. FIFO address will changed to 0</comment>
        </bits>
      </reg>
      <reg name="spi_ctl7" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="data_line2_en" pos="15" rst="0x0">
          <comment>1: two data line function enable
0: two data line function disable</comment>
        </bits>
        <bits access="rw" name="rgb565_en" pos="14" rst="0x0">
          <comment>1: enable RGB565 data format
0: disable RGB565 data format</comment>
        </bits>
        <bits access="rw" name="rgb666_en" pos="13" rst="0x0">
          <comment>1: enable RGB666 data format
0: disable RGB666 data format</comment>
        </bits>
        <bits access="rw" name="rgb888_en" pos="12" rst="0x0">
          <comment>1: enable RGB888 data format
0: disable RGB888 data format</comment>
        </bits>
        <bits access="rw" name="spi_slv_sel" pos="11" rst="0x0">
          <comment>1: SPI slave in Low speed mode
0: SPI slave in High speed mode</comment>
        </bits>
        <bits access="rw" name="spi_slv_en" pos="10" rst="0x0">
          <comment>Used when SPI slave in High speed mode.
1: enable spi slave rtx
0: disable spi slave rtx</comment>
        </bits>
        <bits access="rw" name="data_in_mode" pos="9" rst="0x0">
          <comment>Use for 3 wire 9bit RW mode and 4 wire 8bit RW mode (SPI_MODE=5 or SPI_MODE=6).
0: Data in and data out of SPI share one IO (SDA).
1: Data in and data out of SPI use separated IO (SDI, SDO).</comment>
        </bits>
        <bits access="rw" name="spi_rx_hld_en" pos="8" rst="0x0">
          <comment>1: enable ahb2apb bridge read hold when rx fifo empty
0: disable ahb2apb bridge read hold</comment>
        </bits>
        <bits access="rw" name="spi_tx_hld_en" pos="7" rst="0x0">
          <comment>1: enable ahb2apb bridge write hold when tx fifo full
0: disable ahb2apb bridge write hold</comment>
        </bits>
        <bits access="rw" name="tx_cmd_set" pos="6" rst="0x0">
          <comment>1: select fmark as the dma request
0: select software dma request</comment>
        </bits>
        <bits access="rw" name="spi_mode" pos="5:3" rst="0x0">
          <comment>Used for master only
0: SPI_MODE disable
1: 3 wire 9 bit, cd bit, SDI/SDO share  one IO
2: 3 wire 9 bit, cd bit, SDI, SDO
3: 4 wire 8 bit, cd pin, SDI/SDO share one IO
4: 4 wire 8 bit, cd pin, SDI, SDO
5: 3 wire 9bit RW mode, 9 bit command and 8 bit read data, cd bit is enable. Design for LCD driver.
6: 4 wire 8bit RW mode, 8bit command and 8 bit read data. Use CD PAD indicates command or data. Design for LCD driver.</comment>
        </bits>
        <bits access="rw" name="csn_i_sel" pos="2:1" rst="0x0">
          <comment>CSN select control:
0: CSN 0
1: CSN 1
2: CSN 2
3: CSN 3</comment>
        </bits>
        <bits access="rw" name="csn_ie_ctl" pos="0" rst="0x0">
          <comment>CSN IE output set(only slave)
0: not support csn input
1: support csn intput</comment>
        </bits>
      </reg>
      <reg name="spi_sts5" protect="rw">
        <comment>Statue Register Used to observe csn error</comment>
        <bits access="r" name="csn_in_err_sync2" pos="4" rst="0x0">
          <comment>1: indicates csn occurring a exception</comment>
        </bits>
        <bits access="r" name="csn_in_sync2" pos="0" rst="0x0">
          <comment>csn for slave</comment>
        </bits>
      </reg>
      <reg name="spi_ctl8" protect="rw">
        <comment>Configure Register Used for configure SPI interface</comment>
        <bits access="rw" name="spi_cd_bit" pos="15" rst="0x0">
          <comment>Spi tx cd bit:
0: indicates command
1: indicates data</comment>
        </bits>
        <bits access="rw" name="spi_cd_bit2" pos="14" rst="0x0">
          <comment>Use for 4 wire 8bit RW mode. Determine CD PAD high or low in read data phase.</comment>
        </bits>
        <bits access="rw" name="cd_data2_sel" pos="13" rst="0x0">
          <comment>Second data line of two data line function select bit:
0: CD PAD as second data line
1: DI PAD as second data line</comment>
        </bits>
        <bits access="rw" name="rgb_pix_mode" pos="12" rst="0x0">
          <comment>Two data line RGB data format mode:
0: 1pixel mode
1: 2/3 pixel mode</comment>
        </bits>
        <bits access="rw" name="data_line2_sw" pos="11" rst="0x0">
          <comment>2-data-line switch. Only valid in 2-data-line mode(DATA_LINE2_EN set to 1):
0: use spi_do as first data line,spi_di as second data line.
1: use spi_di as first data line, spi_do as second data line.</comment>
        </bits>
        <bits access="rw" name="spi_tx_dumy_len" pos="9:4" rst="0x0">
          <comment>Spi tx dummy clock length</comment>
        </bits>
        <bits access="rw" name="spi_tx_data_len_h" pos="3:0" rst="0x0">
          <comment>Indicates tx data length from tx fifo, High 4 bits of spi tx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl9" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="spi_tx_data_len_l" pos="15:0" rst="0x0">
          <comment>Indicates: spi tx data length from tx fifo, Low 16bit of tx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl10" protect="rw">
        <comment>Configure register SPI status register</comment>
        <bits access="rw" name="spi_rx_dumy_len" pos="9:4" rst="0x0">
          <comment>Spi rx dummy clock length</comment>
        </bits>
        <bits access="rw" name="spi_rx_data_len_h" pos="3:0" rst="0x0">
          <comment>Indicates receives data length from slave, high 4 bits of spi rx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl11" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="spi_rx_data_len_l" pos="15:0" rst="0x0">
          <comment>Indicates: spi receives data length from slave, Low 16bit of rx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl12" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="sw_tx_req" pos="1" rst="0x0">
          <comment>Software TX data request, for write LCD</comment>
        </bits>
        <bits access="rw" name="sw_rx_req" pos="0" rst="0x0">
          <comment>Software RX data request, for read LCD</comment>
        </bits>
      </reg>
      <reg name="spi_sts6" protect="rw">
        <comment>Statue Register Used to observe TX data counter</comment>
        <bits access="r" name="tx_data_cnt" pos="15:0" rst="0x0">
          <comment>Tx data cnt</comment>
        </bits>
      </reg>
      <reg name="spi_sts7" protect="rw">
        <comment>Statue Register Used to observe TX statue</comment>
        <bits access="r" name="tx_dummy_cnt" pos="15:10" rst="0x0">
          <comment>tx dummy counter</comment>
        </bits>
        <bits access="r" name="tx_data_cnt" pos="3:0" rst="0x0">
          <comment>tx data counter</comment>
        </bits>
      </reg>
      <reg name="spi_sts8" protect="rw">
        <comment>Statue Register Used to observe RX data counter</comment>
        <bits access="r" name="rx_data_cnt" pos="15:0" rst="0x0">
          <comment>Rx data cnt</comment>
        </bits>
      </reg>
      <reg name="spi_sts9" protect="rw">
        <comment>Statue Register Used to observe RX statue</comment>
        <bits access="r" name="rx_dummy_cnt" pos="15:10" rst="0x0">
          <comment>rx dummy counter</comment>
        </bits>
        <bits access="r" name="rx_data_cnt" pos="3:0" rst="0x0">
          <comment>rx data counter</comment>
        </bits>
      </reg>
      <reg name="spi_version" protect="rw">
        <comment>Statue Register Used to observe spi version</comment>
        <bits access="rw" name="spi_version" pos="15:0" rst="0x205">
          <comment>Spi version</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x5150c000" name="AON_SPI" type="AON_SPI"/>
  </archive>
  <archive relative="gpt.xml">
    <module category="System" name="GPT">
      <reg name="cr" protect="rw">
        <comment/>
        <bits access="rw" name="refclk_sel" pos="31" rst="0x1">
          <comment>refclk_sel</comment>
        </bits>
        <bits access="rw" name="tri_cnt_en" pos="12" rst="0x0">
          <comment>Input triger number count enable</comment>
        </bits>
        <bits access="rw" name="tri" pos="11:9" rst="0x0">
          <comment>slave_mode trigger select</comment>
        </bits>
        <bits access="rw" name="arpe" pos="8" rst="0x1">
          <comment>auto preload value</comment>
        </bits>
        <bits access="rw" name="cms" pos="7:6" rst="0x0">
          <comment>Center-aligned mode select 00: disable , other:enable</comment>
        </bits>
        <bits access="rw" name="dir" pos="5" rst="0x0">
          <comment>counter dir , 0: cnt ++ , 1: cnt --</comment>
        </bits>
        <bits access="rw" name="opm" pos="4" rst="0x0">
          <comment>one pulse mode,  0:disable 1:enable</comment>
        </bits>
        <bits access="rw" name="udis" pos="3" rst="0x0">
          <comment>update disable, 0:disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="ckd" pos="2:1" rst="0x0">
          <comment>clock fdts didiver, 01: divided by 2 10:divided by 4, other:bypass</comment>
        </bits>
        <bits access="rw" name="cen" pos="0" rst="0x0">
          <comment>counter enable, 0: disbale, 1:enable</comment>
        </bits>
      </reg>
      <reg name="smcr" protect="rw">
        <comment/>
        <bits access="rw" name="sms" pos="2:0" rst="0x0">
          <comment>slave mode select: 100: slave mode, 101:gate mode, 110:trig mode, others disable</comment>
        </bits>
      </reg>
      <reg name="egr" protect="rw">
        <comment/>
        <bits access="r" name="ug" pos="0" rst="0x0">
          <comment>bit type is changed from w1c to rc. user trigger gen</comment>
        </bits>
      </reg>
      <reg name="ccmr_oc1" protect="rw">
        <comment/>
        <bits access="rw" name="oc4ce" pos="31" rst="0x1">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc4m" pos="30:28" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc4pe" pos="27" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc4fe" pos="26" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc4s" pos="25:24" rst="0x1">
          <comment>channel source sel, bit[24] 0: output enable, 1 output disable bit[25] 0: use ti4, 1: use ti3</comment>
        </bits>
        <bits access="rw" name="oc3ce" pos="23" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc3m" pos="22:20" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc3pe" pos="19" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc3fe" pos="18" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc3s" pos="17:16" rst="0x0">
          <comment>channel source sel, bit[17] 0: output enable, 1 output disable bit[16] 0: use ti3, 1: use ti4</comment>
        </bits>
        <bits access="rw" name="oc2ce" pos="15" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc2m" pos="14:12" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc2pe" pos="11" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc2fe" pos="10" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc2s" pos="9:8" rst="0x0">
          <comment>channel source sel, bit[9] 0: output enable, 1 output disable bit[8] 0: use ti2, 1: use ti1</comment>
        </bits>
        <bits access="rw" name="oc1ce" pos="7" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc1m" pos="6:4" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc1pe" pos="3" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc1fe" pos="2" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc1s" pos="1:0" rst="0x0">
          <comment>channel source sel, bit[0] 0: output enable, 1 output disable bit[1] 0: use ti2, 1: use ti1</comment>
        </bits>
      </reg>
      <reg name="ccmr_ic1" protect="rw">
        <comment/>
        <bits access="rw" name="ic4f" pos="29:26" rst="0x0">
          <comment>ti4 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic4psc" pos="25:24" rst="0x0">
          <comment>ti4 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
        <bits access="rw" name="ic3f" pos="21:18" rst="0x0">
          <comment>ti3 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic3psc" pos="17:16" rst="0x0">
          <comment>ti3 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
        <bits access="rw" name="ic2f" pos="13:10" rst="0x0">
          <comment>ti2 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic2psc" pos="9:8" rst="0x0">
          <comment>ti2 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
        <bits access="rw" name="ic1f" pos="5:2" rst="0x0">
          <comment>ti1 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic1psc" pos="1:0" rst="0x0">
          <comment>ti1 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
      </reg>
      <reg name="ccer" protect="rw">
        <comment/>
        <bits access="rw" name="cc4p" pos="7" rst="0x0">
          <comment>ti4 polarity</comment>
        </bits>
        <bits access="rw" name="cc4e" pos="6" rst="0x0">
          <comment>ti4 enable</comment>
        </bits>
        <bits access="rw" name="cc3p" pos="5" rst="0x0">
          <comment>ti3 polarity</comment>
        </bits>
        <bits access="rw" name="cc3e" pos="4" rst="0x0">
          <comment>ti3 enable</comment>
        </bits>
        <bits access="rw" name="cc2p" pos="3" rst="0x0">
          <comment>ti2 polarity</comment>
        </bits>
        <bits access="rw" name="cc2e" pos="2" rst="0x0">
          <comment>ti2 enable</comment>
        </bits>
        <bits access="rw" name="cc1p" pos="1" rst="0x0">
          <comment>ti1 polarity</comment>
        </bits>
        <bits access="rw" name="cc1e" pos="0" rst="0x0">
          <comment>ti1 enable</comment>
        </bits>
      </reg>
      <reg name="cnt" protect="rw">
        <comment/>
        <bits access="r" name="cnt_value" pos="15:0" rst="0x0">
          <comment>cnt_value</comment>
        </bits>
      </reg>
      <reg name="psc" protect="rw">
        <comment/>
        <bits access="rw" name="psc_value" pos="15:0" rst="0x0">
          <comment>cnt prescale value</comment>
        </bits>
      </reg>
      <reg name="arr" protect="rw">
        <comment/>
        <bits access="rw" name="arr_value" pos="15:0" rst="0xffff">
          <comment>cnt max value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr1_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr1_capture" pos="15:0" rst="0xffff">
          <comment>ic1 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr2_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr2_capture" pos="15:0" rst="0xffff">
          <comment>ic2 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr3_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr3_capture" pos="15:0" rst="0xffff">
          <comment>ic3 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr4_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr4_capture" pos="15:0" rst="0xffff">
          <comment>ic4 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr1_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr1_compare" pos="15:0" rst="0xffff">
          <comment>ic1 compare value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr2_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr2_compare" pos="15:0" rst="0xffff">
          <comment>ic2 compare value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr3_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr3_compare" pos="15:0" rst="0xffff">
          <comment>ic3 compare value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr4_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr4_compare" pos="15:0" rst="0xffff">
          <comment>ic4 compare value</comment>
        </bits>
      </reg>
      <reg name="isr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="irsr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="mask" protect="rw">
        <comment/>
        <bits access="rw" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="rw" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="rw" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="rw" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="clr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>bit type is changed from w1c to rc. cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>bit type is changed from w1c to rc. trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x5150b000" name="AON_GPT1" type="GPT"/>
    <instance address="0x5150b400" name="AON_GPT2" type="GPT"/>
    <instance address="0x5150b800" name="AON_GPT3" type="GPT"/>
    <instance address="0x04809200" name="AP_GPT1" type="GPT"/>
    <instance address="0x04809400" name="AP_GPT2" type="GPT"/>
    <instance address="0x04809600" name="AP_GPT3" type="GPT"/>
    <instance address="0x04809800" name="AP_GPT4" type="GPT"/>
    <instance address="0x04809a00" name="AP_GPT5" type="GPT"/>
    <instance address="0x04809c00" name="AP_GPT6" type="GPT"/>
  </archive>
  <archive relative="spinlock.xml">
    <module category="System" name="SPINLOCK">
      <hole size="64"/>
      <reg name="spinlockttlsts" protect="rw">
        <comment>Spinlock Total Status Register</comment>
      </reg>
      <hole size="928"/>
      <reg name="spinlockmstid_i" protect="rw">
        <comment>Spinlock Master ID Registers</comment>
      </reg>
      <hole size="15328"/>
      <reg name="spinlocksts_i" protect="rw">
        <comment>Spinlock Individual Status Registers</comment>
        <bits access="r" name="taken" pos="0" rst="0x0">
          <comment>Read 0x0000_0000, Request and get the lock.
Read 0x0000_0001, Request but does not get the lock.
Write Unlock Token, Unlock the lock.
Write not Unlock Token, takes no effect.</comment>
        </bits>
      </reg>
      <hole size="16320"/>
      <reg name="spinlockverid" protect="rw">
        <comment>Spinlock Version ID Register</comment>
      </reg>
    </module>
    <instance address="0x51000000" name="SPINLOCK" type="SPINLOCK"/>
  </archive>
  <archive relative="ap_clk.xml">
    <module category="System" name="AP_CLK">
      <hole size="288"/>
      <reg name="cgm_ap_a5_div_cfg" protect="rw">
        <comment>cgm_ap_a5_div_cfg</comment>
        <bits access="rw" name="cgm_ap_a5_div" pos="1:0" rst="0x0">
          <comment>cgm_ap_a5_div: clk_ap_a5 = clk_src/(div +1), default value = 2'h0</comment>
        </bits>
      </reg>
      <reg name="cgm_ap_a5_sel_cfg" protect="rw">
        <comment>cgm_ap_a5_sel_cfg</comment>
        <bits access="rw" name="cgm_ap_a5_sel" pos="2:0" rst="0x1">
          <comment>cgm_ap_a5_sel: clk_ap_a5 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_397m, 4: apll_400m, 5: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_ap_bus_div_cfg" protect="rw">
        <comment>cgm_ap_bus_div_cfg</comment>
        <bits access="rw" name="cgm_ap_bus_div" pos="1:0" rst="0x1">
          <comment>cgm_ap_bus_div: clk_ap_bus = clk_src/(div +1), default value = 2'h1</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="cgm_uart4_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart4_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart4_bf_div_sel" pos="2:0" rst="0x1">
          <comment>cgm_uart4_bf_div_sel: clk_uart4_bf_div source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: apll_31_25m, 4: apll_125m, 5: gnss_pll_133m, 6: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_uart5_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart5_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart5_bf_div_sel" pos="2:0" rst="0x1">
          <comment>cgm_uart5_bf_div_sel: clk_uart5_bf_div source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: apll_31_25m, 4: apll_125m, 5: gnss_pll_133m, 6: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_uart6_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart6_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart6_bf_div_sel" pos="2:0" rst="0x1">
          <comment>cgm_uart6_bf_div_sel: clk_uart6_bf_div source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: apll_31_25m, 4: apll_125m, 5: gnss_pll_133m, 6: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_spiflash1_sel_cfg" protect="rw">
        <comment>cgm_spiflash1_sel_cfg</comment>
        <bits access="rw" name="cgm_spiflash1_sel" pos="2:0" rst="0x1">
          <comment>cgm_spiflash1_sel: clk_spiflash1 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_397m, 4: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_spiflash2_sel_cfg" protect="rw">
        <comment>cgm_spiflash2_sel_cfg</comment>
        <bits access="rw" name="cgm_spiflash2_sel" pos="2:0" rst="0x1">
          <comment>cgm_spiflash2_sel: clk_spiflash2 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_397m, 4: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_camera_pix_div_cfg" protect="rw">
        <comment>cgm_camera_pix_div_cfg</comment>
        <bits access="rw" name="cgm_camera_pix_div" pos="10:0" rst="0x7">
          <comment>cgm_camera_pix_div: clk_camera_pix = clk_src/(div +1), default value = 11'h7</comment>
        </bits>
      </reg>
      <reg name="cgm_camera_pix_sel_cfg" protect="rw">
        <comment>cgm_camera_pix_sel_cfg</comment>
        <bits access="rw" name="cgm_camera_pix_sel" pos="2:0" rst="0x1">
          <comment>cgm_camera_pix_sel: clk_camera_pix source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_57m, 4: apll_62_5m, 5: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_camera_ref_div_cfg" protect="rw">
        <comment>cgm_camera_ref_div_cfg</comment>
        <bits access="rw" name="cgm_camera_ref_div" pos="10:0" rst="0x7">
          <comment>cgm_camera_ref_div: clk_camera_ref = clk_src/(div +1), default value = 11'h7</comment>
        </bits>
      </reg>
      <reg name="cgm_camera_ref_sel_cfg" protect="rw">
        <comment>cgm_camera_ref_sel_cfg</comment>
        <bits access="rw" name="cgm_camera_ref_sel" pos="2:0" rst="0x1">
          <comment>cgm_camera_ref_sel: clk_camera_ref source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_57m, 4: apll_62_5m, 5: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cgm_camera_csi_div_cfg" protect="rw">
        <comment>cgm_camera_csi_div_cfg</comment>
        <bits access="rw" name="cgm_camera_csi_div" pos="10:0" rst="0x7">
          <comment>cgm_camera_csi_div: clk_camera_csi = clk_src/(div +1), default value = 11'h7</comment>
        </bits>
      </reg>
      <reg name="cgm_camera_csi_sel_cfg" protect="rw">
        <comment>cgm_camera_csi_sel_cfg</comment>
        <bits access="rw" name="cgm_camera_csi_sel" pos="2:0" rst="0x1">
          <comment>cgm_camera_csi_sel: clk_camera_csi source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_57m, 4: apll_62_5m, 5: apll_500m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_camera_csi_data_hs_sel_cfg" protect="rw">
        <comment>cgm_camera_csi_data_hs_sel_cfg</comment>
        <bits access="rw" name="cgm_camera_csi_data_hs_pad_sel" pos="16" rst="0x0">
          <comment>cgm_camera_csi_data_hs_pad_sel: clock source from pad, high active, default: 1'h0</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_spi1_sel_cfg" protect="rw">
        <comment>cgm_spi1_sel_cfg</comment>
        <bits access="rw" name="cgm_spi1_sel" pos="2:0" rst="0x1">
          <comment>cgm_spi1_sel: clk_spi1 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_133m, 4: apll_167m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_i2c1_sel_cfg" protect="rw">
        <comment>cgm_i2c1_sel_cfg</comment>
        <bits access="rw" name="cgm_i2c1_sel" pos="2:0" rst="0x1">
          <comment>cgm_i2c1_sel: clk_i2c1 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_198_5m, 4: apll_250m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_i2c2_sel_cfg" protect="rw">
        <comment>cgm_i2c2_sel_cfg</comment>
        <bits access="rw" name="cgm_i2c2_sel" pos="2:0" rst="0x1">
          <comment>cgm_i2c2_sel: clk_i2c2 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_198_5m, 4: apll_250m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_gpt3_sel_cfg" protect="rw">
        <comment>cgm_gpt3_sel_cfg</comment>
        <bits access="rw" name="cgm_gpt3_sel" pos="2:0" rst="0x1">
          <comment>cgm_gpt3_sel: clk_gpt3 source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, 3: gnss_pll_198_5m, 4: apll_250m, default: 3'h1</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="cgm_26m_sel_cfg" protect="rw">
        <comment>cgm_26m_sel_cfg</comment>
        <bits access="rw" name="cgm_26m_sel" pos="1:0" rst="0x1">
          <comment>cgm_26m_sel: clk_26m source , 0: rtc_32k, 1: xtal_26m, 2: rc26m_26m, default: 2'h1</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="cgm_busy_src_monitor_cfg0" protect="rw">
        <comment>cgm_busy_src_monitor_cfg0</comment>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg1" protect="rw">
        <comment>cgm_busy_src_monitor_cfg1</comment>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg2" protect="rw">
        <comment>cgm_busy_src_monitor_cfg2</comment>
        <bits access="r" name="cgm_busy_src_monitor2" pos="16:0" rst="0x8000">
          <comment>cgm_busy_src_monitor2, 64:(cgm_uart5_bf_div_sel_ac == 3) &amp; cgm_busy_uart5_bf_div 65:(cgm_uart6_bf_div_sel_ac == 3) &amp; cgm_busy_uart6_bf_div 66:cgm_busy_ap_a5_sel_0 &amp; cgm_busy_ap_a5_src 67:(cgm_uart4_bf_div_sel_ac == 0) &amp; cgm_busy_uart4_bf_div 68:(cgm_uart5_bf_div_sel_ac == 0) &amp; cgm_busy_uart5_bf_div 69:(cgm_uart6_bf_div_sel_ac == 0) &amp; cgm_busy_uart6_bf_div 70:cgm_busy_spiflash1_sel_0 &amp; cgm_busy_spiflash1 71:cgm_busy_spiflash2_sel_0 &amp; cgm_busy_spiflash2 72:(cgm_camera_pix_sel_ac == 0) &amp; cgm_busy_camera_pix 73:(cgm_camera_ref_sel_ac == 0) &amp; cgm_busy_camera_ref 74:(cgm_camera_csi_sel_ac == 0) &amp; cgm_busy_camera_csi 75:(cgm_spi1_sel_ac == 0) &amp; cgm_busy_spi1 76:(cgm_i2c1_sel_ac == 0) &amp; cgm_busy_i2c1 77:(cgm_i2c2_sel_ac == 0) &amp; cgm_busy_i2c2 78:(cgm_gpt3_sel_ac == 0) &amp; cgm_busy_gpt3 79:cgm_busy_32k 80:(cgm_26m_sel_ac == 0) &amp; cgm_busy_26m</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x0480a000" name="AP_CLK" type="AP_CLK"/>
  </archive>
  <archive relative="ap_apb.xml">
    <module category="System" name="AP_APB">
      <reg name="clk_ap_mode0" protect="rw">
        <comment>CLK_AP_MODE0</comment>
        <bits access="rw" name="clk_mode_rc26m_fr" pos="16" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_26m_fr" pos="15" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_32k_fr" pos="14" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_gpt3_fr" pos="13" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c2_fr" pos="12" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c1_fr" pos="11" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spi1_fr" pos="10" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_camera_csi_fr" pos="9" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_camera_ref_fr" pos="8" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_camera_pix_fr" pos="7" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash2_fr" pos="6" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash1_fr" pos="5" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart6_bf_div_fr" pos="4" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart5_bf_div_fr" pos="3" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart4_bf_div_fr" pos="2" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_bus_fr" pos="1" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_a5_fr" pos="0" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
      </reg>
      <reg name="clk_ap_en0" protect="rw">
        <comment>CLK_AP_EN0</comment>
        <bits access="rw" name="clk_en_rc26m_fr" pos="16" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_26m_fr" pos="15" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_32k_fr" pos="14" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_gpt3_fr" pos="13" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c2_fr" pos="12" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c1_fr" pos="11" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spi1_fr" pos="10" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_camera_csi_fr" pos="9" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_camera_ref_fr" pos="8" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_camera_pix_fr" pos="7" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash2_fr" pos="6" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash1_fr" pos="5" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart6_bf_div_fr" pos="4" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart5_bf_div_fr" pos="3" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart4_bf_div_fr" pos="2" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_bus_fr" pos="1" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_a5_fr" pos="0" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
      </reg>
      <reg name="clk_ap_mode1" protect="rw">
        <comment>CLK_AP_MODE1</comment>
        <bits access="rw" name="clk_mode_ap_ahb" pos="30" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_mnt26m" pos="28" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_mnt32k" pos="27" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_a5_dbg" pos="26" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_a5" pos="25" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_clk" pos="24" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_apb_reg" pos="23" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_gpt3" pos="22" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c2" pos="21" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c1" pos="20" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_timer2" pos="19" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_timer1" pos="18" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_emmc" pos="17" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_busmon" pos="16" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_lzma" pos="15" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_ifc" pos="14" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_camera" pos="13" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_sdmmc" pos="12" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spi1" pos="11" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart6" pos="10" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart5" pos="9" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_uart4" pos="8" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ce" pos="7" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_med" pos="6" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_axidma" pos="5" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_gouda" pos="4" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash2" pos="3" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash1" pos="2" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_gic400" pos="1" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_imem" pos="0" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
      </reg>
      <reg name="clk_ap_en1" protect="rw">
        <comment>CLK_AP_EN1</comment>
        <bits access="rw" name="clk_en_ap_ahb" pos="30" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_mnt26m" pos="28" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_mnt32k" pos="27" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_a5_dbg" pos="26" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_a5" pos="25" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_clk" pos="24" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_apb_reg" pos="23" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_gpt3" pos="22" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c2" pos="21" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c1" pos="20" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_timer2" pos="19" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_timer1" pos="18" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_emmc" pos="17" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_busmon" pos="16" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_lzma" pos="15" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_ifc" pos="14" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_camera" pos="13" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_sdmmc" pos="12" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spi1" pos="11" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart6" pos="10" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart5" pos="9" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_uart4" pos="8" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ce" pos="7" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_med" pos="6" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_axidma" pos="5" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_gouda" pos="4" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash2" pos="3" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash1" pos="2" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_gic400" pos="1" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_imem" pos="0" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
      </reg>
      <reg name="clk_ap_mode2" protect="rw">
        <comment>CLK_AP_MODE2</comment>
        <bits access="rw" name="clk_mode_gpt3_p2p_async" pos="13" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c2_p2p_async" pos="12" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_i2c1_p2p_async" pos="11" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ce2efs_p2p_async" pos="10" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap2aon_x2h_sync" pos="9" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash2_x2h_sync" pos="8" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_spiflash1_x2h_sync" pos="7" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_ahb_x2h_sync" pos="6" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_med_h2x_sync" pos="5" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap_ifc_h2x_sync" pos="4" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_gouda_h2x_sync" pos="3" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_ap2pub_x2x_async" pos="2" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_usb_h2h_async" pos="1" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_mode_aon2ap_h2x_async" pos="0" rst="0x1">
          <comment>Clock Gating Mode.
0 : Clock Auto Gating ;
1 : Clock Manual Gating ;</comment>
        </bits>
      </reg>
      <reg name="clk_ap_en2" protect="rw">
        <comment>CLK_AP_EN2</comment>
        <bits access="rw" name="clk_en_gpt3_p2p_async" pos="13" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c2_p2p_async" pos="12" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_i2c1_p2p_async" pos="11" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ce2efs_p2p_async" pos="10" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap2aon_x2h_sync" pos="9" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash2_x2h_sync" pos="8" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_spiflash1_x2h_sync" pos="7" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_ahb_x2h_sync" pos="6" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_med_h2x_sync" pos="5" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap_ifc_h2x_sync" pos="4" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_gouda_h2x_sync" pos="3" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_ap2pub_x2x_async" pos="2" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_usb_h2h_async" pos="1" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
        <bits access="rw" name="clk_en_aon2ap_h2x_async" pos="0" rst="0x1">
          <comment>When Clock Manual Gating Mode.
0 : Manual Clock Disable Gating ;
1 : Manual Clock Enable Gating ;</comment>
        </bits>
      </reg>
      <reg name="ap_rst0" protect="rw">
        <comment>AP_RST0</comment>
        <bits access="rw" name="rst_ce_pub" pos="29" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_mnt26m" pos="27" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_mnt32k" pos="26" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_a5" pos="25" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_clk" pos="24" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_gpt3" pos="22" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_i2c2" pos="21" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_i2c1" pos="20" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_timer2" pos="19" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_timer1" pos="18" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_emmc" pos="17" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_busmon" pos="16" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_lzma" pos="15" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_ifc" pos="14" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_camera" pos="13" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_sdmmc" pos="12" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_spi1" pos="11" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_uart6" pos="10" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_uart5" pos="9" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_uart4" pos="8" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ce_sec" pos="7" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_med" pos="6" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_axidma" pos="5" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_gouda" pos="4" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_spiflash2" pos="3" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_spiflash1" pos="2" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_gic400" pos="1" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_imem" pos="0" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
      </reg>
      <reg name="ap_rst1" protect="rw">
        <comment>AP_RST1</comment>
        <bits access="rw" name="rst_gpt3_p2p_async" pos="16" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_i2c2_p2p_async" pos="15" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_i2c1_p2p_async" pos="14" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ce2efs_p2p_async" pos="13" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap2aon_x2h_sync" pos="12" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_spiflash2_x2h_sync" pos="11" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_spiflash1_x2h_sync" pos="10" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_med_h2x_sync" pos="8" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_ifc_h2x_sync" pos="7" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_gouda_h2x_sync" pos="6" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap2pub_x2x_async" pos="5" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_usb_h2h_async" pos="4" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_aon2ap_h2x_async" pos="3" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_a5_cs" pos="2" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
        <bits access="rw" name="rst_ap_a5_dbg" pos="1" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
      </reg>
      <reg name="ap_rst2" protect="rw">
        <comment>AP_RST2</comment>
        <bits access="rw" name="rst_apb_reg" pos="0" rst="0x0">
          <comment>Soft Reset. Active High;
0 : in normal mode;
1 : Reset;</comment>
        </bits>
      </reg>
      <reg name="m0_lpc" protect="rw">
        <comment>M0_LPC</comment>
        <bits access="rw" name="main_m0_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m0_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m0_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m1_lpc" protect="rw">
        <comment>M1_LPC</comment>
        <bits access="rw" name="main_m1_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m1_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m1_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m2_lpc" protect="rw">
        <comment>M2_LPC</comment>
        <bits access="rw" name="main_m2_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m2_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m2_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m3_lpc" protect="rw">
        <comment>M3_LPC</comment>
        <bits access="rw" name="main_m3_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m3_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m3_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m4_lpc" protect="rw">
        <comment>M4_LPC</comment>
        <bits access="rw" name="main_m4_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m4_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m4_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m5_lpc" protect="rw">
        <comment>M5_LPC</comment>
        <bits access="rw" name="main_m5_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m5_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m5_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m6_lpc" protect="rw">
        <comment>M6_LPC</comment>
        <bits access="rw" name="main_m6_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m6_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m6_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m7_lpc" protect="rw">
        <comment>M7_LPC</comment>
        <bits access="rw" name="main_m7_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m7_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m7_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m8_lpc" protect="rw">
        <comment>M8_LPC</comment>
        <bits access="rw" name="main_m8_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m8_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m8_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="m9_lpc" protect="rw">
        <comment>M9_LPC</comment>
        <bits access="rw" name="main_m9_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_m9_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_m9_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s0_lpc" protect="rw">
        <comment>S0_LPC</comment>
        <bits access="rw" name="main_s0_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s0_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s0_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s1_lpc" protect="rw">
        <comment>S1_LPC</comment>
        <bits access="rw" name="main_s1_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s1_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s1_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s2_lpc" protect="rw">
        <comment>S2_LPC</comment>
        <bits access="rw" name="main_s2_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s2_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s2_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s3_lpc" protect="rw">
        <comment>S3_LPC</comment>
        <bits access="rw" name="main_s3_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s3_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s3_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s4_lpc" protect="rw">
        <comment>S4_LPC</comment>
        <bits access="rw" name="main_s4_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s4_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s4_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s5_lpc" protect="rw">
        <comment>S5_LPC</comment>
        <bits access="rw" name="main_s5_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s5_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s5_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="s6_lpc" protect="rw">
        <comment>S6_LPC</comment>
        <bits access="rw" name="main_s6_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_s6_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_s6_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="main_lpc" protect="rw">
        <comment>MAIN_LPC</comment>
        <bits access="rw" name="main_pu_num" pos="31:24" rst="0x0"/>
        <bits access="rw" name="main_lp_eb" pos="16" rst="0x1"/>
        <bits access="rw" name="main_lp_num" pos="15:0" rst="0x80"/>
      </reg>
      <reg name="cache_emmc_sdio" protect="rw">
        <comment>CACHE_EMMC_SDIO</comment>
        <bits access="rw" name="arcache_emmc" pos="7:4" rst="0x0">
          <comment>arcache of emmc</comment>
        </bits>
        <bits access="rw" name="awcache_emmc" pos="3:0" rst="0x0">
          <comment>awcache of emmc</comment>
        </bits>
      </reg>
      <reg name="misc_cfg" protect="rw">
        <comment>MISC_CFG</comment>
        <bits access="rw" name="camera_refclk_out_mode" pos="10" rst="0x0">
          <comment>1: If camera fifo is almost full, disable clk_camera_out</comment>
        </bits>
        <bits access="rw" name="camera_refclk_out_en" pos="9" rst="0x0">
          <comment>1: clk_camera_out enable</comment>
        </bits>
        <bits access="rw" name="camera_spiclk_pol" pos="8" rst="0x0">
          <comment>1: invert pix clk polarity.
0: keep pix clk polarity.</comment>
        </bits>
        <bits access="rw" name="ap_ifc_hresp_err_mask" pos="7" rst="0x1">
          <comment>ap ifc dma not operate error response from bus</comment>
        </bits>
        <bits access="rw" name="med_read_bus_sel" pos="6" rst="0x0">
          <comment>med read data from bus instead of flash</comment>
        </bits>
        <bits access="rw" name="cfgsdisable_gic400" pos="0" rst="0x0">
          <comment>gic400 cfgsdisable</comment>
        </bits>
      </reg>
      <reg name="chip_prod_id" protect="rw">
        <comment>CHIP_PROD_ID</comment>
        <bits access="r" name="prod_id" pos="31:16" rst="0x0">
          <comment>production id</comment>
        </bits>
        <bits access="r" name="bond_id" pos="15:12" rst="0x0">
          <comment>bond id</comment>
        </bits>
        <bits access="r" name="metal_id" pos="11:0" rst="0x0">
          <comment>metal id</comment>
        </bits>
      </reg>
      <reg name="cfg_qos0" protect="rw">
        <comment>CFG_QOS0</comment>
        <bits access="rw" name="lzma_awqos" pos="31:28" rst="0x0">
          <comment>lzma_awqos</comment>
        </bits>
        <bits access="rw" name="lzma_arqos" pos="27:24" rst="0x0">
          <comment>lzma_arqos</comment>
        </bits>
        <bits access="rw" name="emmc_awqos" pos="23:20" rst="0x0">
          <comment>emmc_awqos</comment>
        </bits>
        <bits access="rw" name="emmc_arqos" pos="19:16" rst="0x0">
          <comment>emmc_arqos</comment>
        </bits>
        <bits access="rw" name="ce_awqos" pos="15:12" rst="0x0">
          <comment>ce_awqos</comment>
        </bits>
        <bits access="rw" name="ce_arqos" pos="11:8" rst="0x0">
          <comment>ce_arqos</comment>
        </bits>
        <bits access="rw" name="ap_a5_awqos" pos="7:4" rst="0x0">
          <comment>ap_a5_awqos</comment>
        </bits>
        <bits access="rw" name="ap_a5_arqos" pos="3:0" rst="0x0">
          <comment>ap_a5_arqos</comment>
        </bits>
      </reg>
      <reg name="cfg_qos1" protect="rw">
        <comment>CFG_QOS1</comment>
        <bits access="rw" name="aon_awqos" pos="31:28" rst="0x0">
          <comment>aon_awqos</comment>
        </bits>
        <bits access="rw" name="aon_arqos" pos="27:24" rst="0x0">
          <comment>aon_arqos</comment>
        </bits>
        <bits access="rw" name="ap_ifc_awqos" pos="23:20" rst="0x0">
          <comment>ap_ifc_awqos</comment>
        </bits>
        <bits access="rw" name="ap_ifc_arqos" pos="19:16" rst="0x0">
          <comment>ap_ifc_arqos</comment>
        </bits>
        <bits access="rw" name="usb_awqos" pos="15:12" rst="0x0">
          <comment>usb_awqos</comment>
        </bits>
        <bits access="rw" name="usb_arqos" pos="11:8" rst="0x0">
          <comment>usb_arqos</comment>
        </bits>
        <bits access="rw" name="gouda_awqos" pos="7:4" rst="0x0">
          <comment>gouda_awqos</comment>
        </bits>
        <bits access="rw" name="gouda_arqos" pos="3:0" rst="0x0">
          <comment>gouda_arqos</comment>
        </bits>
      </reg>
      <reg name="cfg_qos2" protect="rw">
        <comment>CFG_QOS2</comment>
        <bits access="rw" name="ap_axidma_awqos" pos="15:12" rst="0x0">
          <comment>ap_axidma_awqos</comment>
        </bits>
        <bits access="rw" name="ap_axidma_arqos" pos="11:8" rst="0x0">
          <comment>ap_axidma_arqos</comment>
        </bits>
        <bits access="rw" name="med_awqos" pos="7:4" rst="0x0">
          <comment>med_awqos</comment>
        </bits>
        <bits access="rw" name="med_arqos" pos="3:0" rst="0x0">
          <comment>med_arqos</comment>
        </bits>
      </reg>
      <reg name="debug_monitor" protect="rw">
        <comment>DEBUG_MONITOR</comment>
        <bits access="rw" name="med_dbg_bus_sel" pos="4:0" rst="0x0">
          <comment>med dbg bus select</comment>
        </bits>
      </reg>
      <reg name="xhb_awsparse" protect="rw">
        <comment>XHB_AWSPARSE</comment>
        <bits access="rw" name="xhb_ap2aon_awsparse" pos="3" rst="0x1">
          <comment>ap2aon xhb400 awsparse</comment>
        </bits>
        <bits access="rw" name="xhb_spiflash2_awsparse" pos="2" rst="0x1">
          <comment>spiflash2 xhb400 awsparse</comment>
        </bits>
        <bits access="rw" name="xhb_spiflash1_awsparse" pos="1" rst="0x1">
          <comment>spiflash1 xhb400 awsparse</comment>
        </bits>
        <bits access="rw" name="xhb_ap_ahb_awsparse" pos="0" rst="0x1">
          <comment>ap_ahb xhb400 awsparse</comment>
        </bits>
      </reg>
      <reg name="clk_mnt26m_th0" protect="rw">
        <comment>CLK_MNT26M_TH0</comment>
        <bits access="rw" name="clk_mnt26m_th0" pos="7:0" rst="0x40">
          <comment>monitor counter number of rc26m</comment>
        </bits>
      </reg>
      <reg name="clk_mnt26m_th1" protect="rw">
        <comment>CLK_MNT26M_TH1</comment>
        <bits access="rw" name="clk_mnt26m_th1" pos="15:0" rst="0x3e8">
          <comment>monitor interval counter number of rc26m</comment>
        </bits>
      </reg>
      <reg name="clk_mnt26m_th2" protect="rw">
        <comment>CLK_MNT26M_TH2</comment>
        <bits access="rw" name="clk_mnt26m_th2" pos="6:0" rst="0x20">
          <comment>monitor counter number of xtal26m, low limited</comment>
        </bits>
      </reg>
      <reg name="clk_mnt26m_th3" protect="rw">
        <comment>CLK_MNT26M_TH3</comment>
        <bits access="rw" name="clk_mnt26m_th3" pos="8:0" rst="0x80">
          <comment>monitor counter number of xtal26m, high limited</comment>
        </bits>
      </reg>
      <reg name="clk_mnt32k_th0" protect="rw">
        <comment>CLK_MNT32K_TH0</comment>
        <bits access="rw" name="clk_mnt32k_th0" pos="11:0" rst="0x190">
          <comment>monitor counter number of 32k clock, low limited</comment>
        </bits>
      </reg>
      <reg name="clk_mnt32k_th1" protect="rw">
        <comment>CLK_MNT32K_TH1</comment>
        <bits access="rw" name="clk_mnt32k_th1" pos="11:0" rst="0x6a4">
          <comment>monitor counter number of 32k clock, high limited</comment>
        </bits>
      </reg>
      <reg name="clk_mnt_ctrl" protect="rw">
        <comment>CLK_MNT_CTRL</comment>
        <bits access="rw" name="st_clk_mnt26m" pos="5" rst="0x0"/>
        <bits access="rw" name="st_clk_mnt32k" pos="4" rst="0x0"/>
        <bits access="rw" name="en_int_clk_mnt26m" pos="3" rst="0x0"/>
        <bits access="rw" name="en_int_clk_mnt32k" pos="2" rst="0x0"/>
        <bits access="rw" name="clk_mnt26m_en" pos="1" rst="0x0"/>
        <bits access="rw" name="clk_mnt32k_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="cfg_bridge" protect="rw">
        <comment>CFG_BRIDGE</comment>
        <bits access="r" name="gpt3_p2p_async_fifo_clr_end" pos="31" rst="0x0"/>
        <bits access="rw" name="gpt3_p2p_async_fifo_clr" pos="30" rst="0x0"/>
        <bits access="rw" name="gpt3_p2p_async_sclk_auto_gate_en" pos="29" rst="0x0"/>
        <bits access="rw" name="gpt3_p2p_async_mclk_auto_gate_en" pos="28" rst="0x0"/>
        <bits access="r" name="i2c2_p2p_async_fifo_clr_end" pos="27" rst="0x0"/>
        <bits access="rw" name="i2c2_p2p_async_fifo_clr" pos="26" rst="0x0"/>
        <bits access="rw" name="i2c2_p2p_async_sclk_auto_gate_en" pos="25" rst="0x0"/>
        <bits access="rw" name="i2c2_p2p_async_mclk_auto_gate_en" pos="24" rst="0x0"/>
        <bits access="r" name="i2c1_p2p_async_fifo_clr_end" pos="23" rst="0x0"/>
        <bits access="rw" name="i2c1_p2p_async_fifo_clr" pos="22" rst="0x0"/>
        <bits access="rw" name="i2c1_p2p_async_sclk_auto_gate_en" pos="21" rst="0x0"/>
        <bits access="rw" name="i2c1_p2p_async_mclk_auto_gate_en" pos="20" rst="0x0"/>
        <bits access="r" name="ce2efs_p2p_async_fifo_clr_end" pos="19" rst="0x0"/>
        <bits access="rw" name="ce2efs_p2p_async_fifo_clr" pos="18" rst="0x0"/>
        <bits access="rw" name="ce2efs_p2p_async_sclk_auto_gate_en" pos="17" rst="0x0"/>
        <bits access="rw" name="ce2efs_p2p_async_mclk_auto_gate_en" pos="16" rst="0x0"/>
        <bits access="rw" name="med_h2x_sync_nonbuf_early_resp_en" pos="15" rst="0x0"/>
        <bits access="rw" name="med_h2x_sync_clk_auto_gate_en" pos="14" rst="0x0"/>
        <bits access="rw" name="ap_ifc_h2x_sync_nonbuf_early_resp_en" pos="13" rst="0x0"/>
        <bits access="rw" name="ap_ifc_h2x_sync_clk_auto_gate_en" pos="12" rst="0x0"/>
        <bits access="rw" name="gouda_h2x_sync_nonbuf_early_resp_en" pos="11" rst="0x0"/>
        <bits access="rw" name="gouda_h2x_sync_clk_auto_gate_en" pos="10" rst="0x0"/>
        <bits access="r" name="usb_h2h_async_fifo_clr_end" pos="9" rst="0x0"/>
        <bits access="rw" name="usb_h2h_async_fifo_clr" pos="8" rst="0x0"/>
        <bits access="rw" name="usb_h2h_async_nonbuf_early_resp_en" pos="7" rst="0x0"/>
        <bits access="rw" name="usb_h2h_async_sclk_auto_gate_en" pos="6" rst="0x0"/>
        <bits access="rw" name="usb_h2h_async_mclk_auto_gate_en" pos="5" rst="0x0"/>
        <bits access="r" name="aon2ap_h2x_async_fifo_clr_end" pos="4" rst="0x0"/>
        <bits access="rw" name="aon2ap_h2x_async_fifo_clr" pos="3" rst="0x0"/>
        <bits access="rw" name="aon2ap_h2x_async_nonbuf_early_resp_en" pos="2" rst="0x0"/>
        <bits access="rw" name="aon2ap_h2x_async_sclk_auto_gate_en" pos="1" rst="0x0"/>
        <bits access="rw" name="aon2ap_h2x_async_mclk_auto_gate_en" pos="0" rst="0x0"/>
      </reg>
      <hole size="32"/>
      <reg name="cgm_gate_auto_sel0" protect="rw">
        <comment>CGM_GATE_AUTO_SEL0</comment>
      </reg>
      <reg name="cgm_gate_auto_sel1" protect="rw">
        <comment>CGM_GATE_AUTO_SEL1</comment>
      </reg>
      <reg name="cgm_gate_auto_sel2" protect="rw">
        <comment>CGM_GATE_AUTO_SEL2</comment>
      </reg>
      <reg name="cgm_gate_auto_sel3" protect="rw">
        <comment>CGM_GATE_AUTO_SEL3</comment>
      </reg>
      <reg name="cgm_gate_force_en0" protect="rw">
        <comment>CGM_GATE_FORCE_EN0</comment>
      </reg>
      <reg name="cgm_gate_force_en1" protect="rw">
        <comment>CGM_GATE_FORCE_EN1</comment>
      </reg>
      <reg name="cgm_gate_force_en2" protect="rw">
        <comment>CGM_GATE_FORCE_EN2</comment>
      </reg>
      <reg name="cgm_gate_force_en3" protect="rw">
        <comment>CGM_GATE_FORCE_EN3</comment>
      </reg>
      <reg name="mnt_gate_en_status0" protect="rw">
        <comment>MNT_GATE_EN_STATUS0</comment>
      </reg>
      <reg name="mnt_gate_en_status1" protect="rw">
        <comment>MNT_GATE_EN_STATUS1</comment>
      </reg>
      <reg name="mnt_gate_en_status2" protect="rw">
        <comment>MNT_GATE_EN_STATUS2</comment>
      </reg>
      <reg name="mnt_gate_en_status3" protect="rw">
        <comment>MNT_GATE_EN_STATUS3</comment>
      </reg>
      <reg name="mnt_cgm_busy_status0" protect="rw">
        <comment>MNT_CGM_BUSY_STATUS0</comment>
      </reg>
      <reg name="mnt_cgm_busy_status1" protect="rw">
        <comment>MNT_CGM_BUSY_STATUS1</comment>
      </reg>
      <reg name="mnt_cgm_busy_status2" protect="rw">
        <comment>MNT_CGM_BUSY_STATUS2</comment>
      </reg>
      <reg name="mnt_cgm_busy_status3" protect="rw">
        <comment>MNT_CGM_BUSY_STATUS3</comment>
      </reg>
      <reg name="mnt_cgm_busy_status4" protect="rw">
        <comment>MNT_CGM_BUSY_STATUS4</comment>
      </reg>
      <hole size="96"/>
      <reg name="cfg_clk_uart4" protect="rw">
        <comment>CFG_CLK_UART4</comment>
        <bits access="rw" name="uart4_div_num" pos="29:17" rst="0x1">
          <comment>numerator</comment>
        </bits>
        <bits access="rw" name="uart4_div_denom" pos="16:0" rst="0x7">
          <comment>denominator</comment>
        </bits>
      </reg>
      <reg name="cfg_clk_uart5" protect="rw">
        <comment>CFG_CLK_UART5</comment>
        <bits access="rw" name="uart5_div_num" pos="29:17" rst="0x1">
          <comment>numerator</comment>
        </bits>
        <bits access="rw" name="uart5_div_denom" pos="16:0" rst="0x7">
          <comment>denominator</comment>
        </bits>
      </reg>
      <reg name="cfg_clk_uart6" protect="rw">
        <comment>CFG_CLK_UART6</comment>
        <bits access="rw" name="uart6_div_num" pos="29:17" rst="0x1">
          <comment>numerator</comment>
        </bits>
        <bits access="rw" name="uart6_div_denom" pos="16:0" rst="0x7">
          <comment>denominator</comment>
        </bits>
      </reg>
      <reg name="cfg_clk_spiflash1" protect="rw">
        <comment>CFG_CLK_SPIFLASH1</comment>
        <bits access="rw" name="spiflash1_freq" pos="3:0" rst="0xf">
          <comment>select spiflash1 controller clock frequency. default 26MHz</comment>
        </bits>
      </reg>
      <reg name="cfg_clk_spiflash2" protect="rw">
        <comment>CFG_CLK_SPIFLASH2</comment>
        <bits access="rw" name="spiflash2_freq" pos="3:0" rst="0xf">
          <comment>select spiflash2 controller clock frequency. default 26MHz</comment>
        </bits>
      </reg>
      <reg name="cfg_clk_apcpu_dbgen" protect="rw">
        <comment>CFG_CLK_APCPU_DBGEN</comment>
        <bits access="rw" name="div_disable" pos="3" rst="0x0">
          <comment>1: clock div disable;
0: clock div enable;</comment>
        </bits>
        <bits access="rw" name="div_num" pos="2:0" rst="0x0">
          <comment>0: no div;
1: 2div;
2: 3div;
3: 4div;
4: 5div;
5: 6div;
6: 7div;
7: 8div;</comment>
        </bits>
      </reg>
      <reg name="lp_force" protect="rw">
        <comment>LP_FORCE</comment>
        <bits access="rw" name="lp_force_main" pos="17" rst="0x0"/>
        <bits access="rw" name="lp_force_s6" pos="16" rst="0x0"/>
        <bits access="rw" name="lp_force_s5" pos="15" rst="0x0"/>
        <bits access="rw" name="lp_force_s4" pos="14" rst="0x0"/>
        <bits access="rw" name="lp_force_s3" pos="13" rst="0x0"/>
        <bits access="rw" name="lp_force_s2" pos="12" rst="0x0"/>
        <bits access="rw" name="lp_force_s1" pos="11" rst="0x0"/>
        <bits access="rw" name="lp_force_s0" pos="10" rst="0x0"/>
        <bits access="rw" name="lp_force_m9" pos="9" rst="0x0"/>
        <bits access="rw" name="lp_force_m8" pos="8" rst="0x0"/>
        <bits access="rw" name="lp_force_m7" pos="7" rst="0x0"/>
        <bits access="rw" name="lp_force_m6" pos="6" rst="0x0"/>
        <bits access="rw" name="lp_force_m5" pos="5" rst="0x0"/>
        <bits access="rw" name="lp_force_m4" pos="4" rst="0x0"/>
        <bits access="rw" name="lp_force_m3" pos="3" rst="0x0"/>
        <bits access="rw" name="lp_force_m2" pos="2" rst="0x0"/>
        <bits access="rw" name="lp_force_m1" pos="1" rst="0x0"/>
        <bits access="rw" name="lp_force_m0" pos="0" rst="0x0"/>
      </reg>
      <reg name="sleep_ctrl" protect="rw">
        <comment>SLEEP_CTRL</comment>
        <bits access="r" name="lp_force_ack_main" pos="22" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s6" pos="21" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s5" pos="20" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s4" pos="19" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s3" pos="18" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s2" pos="17" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s1" pos="16" rst="0x0"/>
        <bits access="r" name="lp_force_ack_s0" pos="15" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m9" pos="14" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m8" pos="13" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m7" pos="12" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m6" pos="11" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m5" pos="10" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m4" pos="9" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m3" pos="8" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m2" pos="7" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m1" pos="6" rst="0x0"/>
        <bits access="r" name="lp_force_ack_m0" pos="5" rst="0x0"/>
        <bits access="rw" name="deep_sleep_core_bypass" pos="4" rst="0x0">
          <comment>1: when ap_sys enter deepsleep, this bit can bypass ap_a5 wfi signal, only care about slp_req signal.</comment>
        </bits>
        <bits access="rw" name="light_sleep_rc26m_sel" pos="3" rst="0x0">
          <comment>1: when ap_a5 enter wfi, the ap_a5 clock will auto switch to rc26MHz and the bus clock will auto change along with the ap_a5 clock.</comment>
        </bits>
        <bits access="rw" name="ap_a5_clk_auto_gate" pos="2" rst="0x0">
          <comment>1: when ap_a5 enter wfi, ap_a5 clk will be stopped.</comment>
        </bits>
        <bits access="rw" name="light_sleep_enable" pos="1" rst="0x0">
          <comment>1: when ap_a5 enter wfi, the ap_a5 clock will auto switch to xtal26MHz and the bus clock will auto change along with the ap_a5 clock.</comment>
        </bits>
        <bits access="rw" name="deep_sleep_core_int_disable" pos="0" rst="0x0">
          <comment>1: when ap_sys enter deepsleep, this bit can prevent fiq/irq from waking up ap_a5 exit wfi.</comment>
        </bits>
      </reg>
      <reg name="light_sleep_bypass0" protect="rw">
        <comment>LIGHT_SLEEP_BYPASS0</comment>
        <bits access="rw" name="light_bypass_m9" pos="27" rst="0x0"/>
        <bits access="rw" name="light_bypass_m8" pos="26" rst="0x0"/>
        <bits access="rw" name="light_bypass_m7" pos="25" rst="0x0"/>
        <bits access="rw" name="light_bypass_m6" pos="24" rst="0x0"/>
        <bits access="rw" name="light_bypass_m5" pos="23" rst="0x0"/>
        <bits access="rw" name="light_bypass_m4" pos="22" rst="0x0"/>
        <bits access="rw" name="light_bypass_m3" pos="21" rst="0x0"/>
        <bits access="rw" name="light_bypass_m2" pos="20" rst="0x0"/>
        <bits access="rw" name="light_bypass_m1" pos="19" rst="0x0"/>
        <bits access="rw" name="light_bypass_m0" pos="18" rst="0x0"/>
        <bits access="rw" name="light_bypass_main_lpc" pos="17" rst="0x0"/>
        <bits access="rw" name="light_bypass_s6_lpc" pos="16" rst="0x0"/>
        <bits access="rw" name="light_bypass_s5_lpc" pos="15" rst="0x0"/>
        <bits access="rw" name="light_bypass_s4_lpc" pos="14" rst="0x0"/>
        <bits access="rw" name="light_bypass_s3_lpc" pos="13" rst="0x0"/>
        <bits access="rw" name="light_bypass_s2_lpc" pos="12" rst="0x0"/>
        <bits access="rw" name="light_bypass_s1_lpc" pos="11" rst="0x0"/>
        <bits access="rw" name="light_bypass_s0_lpc" pos="10" rst="0x0"/>
        <bits access="rw" name="light_bypass_m9_lpc" pos="9" rst="0x0"/>
        <bits access="rw" name="light_bypass_m8_lpc" pos="8" rst="0x0"/>
        <bits access="rw" name="light_bypass_m7_lpc" pos="7" rst="0x0"/>
        <bits access="rw" name="light_bypass_m6_lpc" pos="6" rst="0x0"/>
        <bits access="rw" name="light_bypass_m5_lpc" pos="5" rst="0x0"/>
        <bits access="rw" name="light_bypass_m4_lpc" pos="4" rst="0x0"/>
        <bits access="rw" name="light_bypass_m3_lpc" pos="3" rst="0x0"/>
        <bits access="rw" name="light_bypass_m2_lpc" pos="2" rst="0x0"/>
        <bits access="rw" name="light_bypass_m1_lpc" pos="1" rst="0x0"/>
        <bits access="rw" name="light_bypass_m0_lpc" pos="0" rst="0x0"/>
      </reg>
      <reg name="light_sleep_bypass1" protect="rw">
        <comment>LIGHT_SLEEP_BYPASS1</comment>
        <bits access="rw" name="light_bypass_usb_dma" pos="22" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch9" pos="21" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch8" pos="20" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch7" pos="19" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch6" pos="18" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch5" pos="17" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch4" pos="16" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch3" pos="15" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch2" pos="14" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch1" pos="13" rst="0x0"/>
        <bits access="rw" name="light_bypass_ap_ifc_ch0" pos="12" rst="0x0"/>
        <bits access="rw" name="light_bypass_timer2" pos="11" rst="0x0"/>
        <bits access="rw" name="light_bypass_timer1" pos="10" rst="0x0"/>
        <bits access="rw" name="light_bypass_med" pos="9" rst="0x0"/>
        <bits access="rw" name="light_bypass_spi1" pos="8" rst="0x0"/>
        <bits access="rw" name="light_bypass_gpt3" pos="7" rst="0x0"/>
        <bits access="rw" name="light_bypass_i2c2" pos="6" rst="0x0"/>
        <bits access="rw" name="light_bypass_i2c1" pos="5" rst="0x0"/>
        <bits access="rw" name="light_bypass_camera" pos="4" rst="0x0"/>
        <bits access="rw" name="light_bypass_sdmmc" pos="3" rst="0x0"/>
        <bits access="rw" name="light_bypass_uart6" pos="2" rst="0x0"/>
        <bits access="rw" name="light_bypass_uart5" pos="1" rst="0x0"/>
        <bits access="rw" name="light_bypass_uart4" pos="0" rst="0x0"/>
      </reg>
      <reg name="anti_hang" protect="rw">
        <comment>ANTI_HANG</comment>
        <bits access="rw" name="ap_a5_err_resp_en" pos="6" rst="0x1">
          <comment>1: ap a5 can receive error response from matrix;
0: error response from matrix to ap a5 will be masked;</comment>
        </bits>
        <bits access="rw" name="apb3_slave_err_resp_en" pos="5" rst="0x0">
          <comment>lzma/ap_imem/ap_busmon/apb_reg/gouda/tiimer1/timer2/i2c1/i2c2/gpt3/ap_clk</comment>
        </bits>
        <bits access="rw" name="apb2_slave_err_resp_en" pos="4" rst="0x0">
          <comment>uart4/uart5/uart6/sdmmc/camera/ap_ifc</comment>
        </bits>
        <bits access="rw" name="apb1_slave_err_resp_en" pos="3" rst="0x0">
          <comment>med/ce_pub/ce_sec/emmc/spi1</comment>
        </bits>
        <bits access="rw" name="ahb_slave_err_resp_en" pos="2" rst="0x0">
          <comment>spiflash1/spiflash2/ap_axidma/usb</comment>
        </bits>
        <bits access="rw" name="ap2pub_downstream_disable_force" pos="1" rst="0x0"/>
        <bits access="rw" name="ap2pub_downstream_disable_sel" pos="0" rst="0x0"/>
      </reg>
      <hole size="32"/>
      <reg name="ap_apb_rsd0" protect="rw">
        <comment>AP_APB_RSD0</comment>
      </reg>
      <reg name="ap_apb_rsd1" protect="rw">
        <comment>AP_APB_RSD1</comment>
      </reg>
      <reg name="ap_apb_rsd2" protect="rw">
        <comment>AP_APB_RSD2</comment>
      </reg>
      <reg name="ap_apb_rsd3" protect="rw">
        <comment>AP_APB_RSD3</comment>
      </reg>
      <reg name="ap2pub_bridge_status" protect="rw">
        <comment>AP2PUB_BRIDGE_STATUS</comment>
        <bits access="r" name="ap2pub_bridge_trans_idle" pos="2" rst="0x1"/>
        <bits access="r" name="ap2pub_pwr_handshk_clk_req" pos="1" rst="0x0"/>
        <bits access="r" name="ap2pub_axi_detector_overflow" pos="0" rst="0x0"/>
      </reg>
      <reg name="ap2pub_bridge_debug" protect="rw">
        <comment>AP2PUB_BRIDGE_DEBUG</comment>
      </reg>
      <hole size="5568"/>
      <reg name="clk_ap_mode0_set" protect="rw"/>
      <reg name="clk_ap_en0_set" protect="rw"/>
      <reg name="clk_ap_mode1_set" protect="rw"/>
      <reg name="clk_ap_en1_set" protect="rw"/>
      <reg name="clk_ap_mode2_set" protect="rw"/>
      <reg name="clk_ap_en2_set" protect="rw"/>
      <reg name="ap_rst0_set" protect="rw"/>
      <reg name="ap_rst1_set" protect="rw"/>
      <reg name="ap_rst2_set" protect="rw"/>
      <hole size="1952"/>
      <reg name="lp_force_set" protect="rw"/>
      <reg name="sleep_ctrl_set" protect="rw"/>
      <reg name="light_sleep_bypass0_set" protect="rw"/>
      <reg name="light_sleep_bypass1_set" protect="rw"/>
      <reg name="anti_hang_set" protect="rw"/>
      <hole size="5792"/>
      <reg name="clk_ap_mode0_clr" protect="rw"/>
      <reg name="clk_ap_en0_clr" protect="rw"/>
      <reg name="clk_ap_mode1_clr" protect="rw"/>
      <reg name="clk_ap_en1_clr" protect="rw"/>
      <reg name="clk_ap_mode2_clr" protect="rw"/>
      <reg name="clk_ap_en2_clr" protect="rw"/>
      <reg name="ap_rst0_clr" protect="rw"/>
      <reg name="ap_rst1_clr" protect="rw"/>
      <reg name="ap_rst2_clr" protect="rw"/>
      <hole size="1952"/>
      <reg name="lp_force_clr" protect="rw"/>
      <reg name="sleep_ctrl_clr" protect="rw"/>
      <reg name="light_sleep_bypass0_clr" protect="rw"/>
      <reg name="light_sleep_bypass1_clr" protect="rw"/>
      <reg name="anti_hang_clr" protect="rw"/>
    </module>
    <var name="REG_AP_APB_SET_OFFSET" value="0x400"/>
    <var name="REG_AP_APB_CLR_OFFSET" value="0x800"/>
    <instance address="0x04803000" name="AP_APB" type="AP_APB"/>
  </archive>
  <archive relative="ce_sec.xml">
    <module category="System" name="CE_SEC">
      <reg name="ce_debug_dma_status" protect="rw">
        <comment>axi bus status and dma work state status</comment>
        <bits access="r" name="rf_ce_wready" pos="31" rst="0x0">
          <comment>axi write data channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_awready" pos="30" rst="0x0">
          <comment>axi write address channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_arready" pos="29" rst="0x0">
          <comment>axi read address channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_busy" pos="28" rst="0x0">
          <comment>dma is working,and CPU can't access ce registers except ce_clear register.</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_dst_state" pos="26:22" rst="0x0">
          <comment>dma write port state:                                         4'd0: idle                                                           4'd1: write burst calculate                                   4'd2: write burst calculate data number              4'd3: write burst wait enough data                    4'd4: write burst start                                        4'd5: write burst execute                                   4'd6: write burst wait burst end                         4'd7: write burst end</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_src_state" pos="21:17" rst="0x0">
          <comment>dma read port state:                                         4'd0: idle                                                           4'd1: read burst wait enough buffer space        4'd2: read burst wait one cycle                         4'd3: read burst start                                        4'd4: read burst execute                                   4'd5: read burst wait burst end                         4'd6: read burst done</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_cmd_fifo_non_empty" pos="16" rst="0x0">
          <comment>pka cmd fifo is non-empty</comment>
        </bits>
        <bits access="r" name="rf_ce_cmd_fifo_non_empty" pos="15" rst="0x0">
          <comment>cmd fifo is non-empty</comment>
        </bits>
        <bits access="r" name="rf_ce_int_raw_status_vld" pos="14" rst="0x0">
          <comment>interrupt raw status is valid</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_err" pos="13" rst="0x0">
          <comment>ce in error status</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_main_write_state" pos="12:8" rst="0x0">
          <comment>dma control main write port state:                     5'd0: idle                                                           5'd1: STD hash start                                            5'd2: STD start                                                  5'd3: STD wait done                                          5'd4: STD send done                                        5'd5: STD next state judgement                        5'd6: STD pause                                               5'd7: STD done                                                 5'd8: LLIST check node buffer status               5'd9: LLIST load node                                       5'd10: LLIST load node wait                               5'd11: LLIST load node update parameter       5'd12: LLIST load node done                            5'd13: LLIST hash start                                     5'd14: LLIST start                                             5'd15: LLIST wait done                                     5'd16: LLIST send done                                    5'd17: LLIST next start judgement                    5'd18: LLIST pause                                           5'd19: LLIST done</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_pka_main_read_state" pos="7:5" rst="0x0">
          <comment>3'd0: idle                                                      3'd1: pka read instruction start                                                                         3'd2: pka load start                                                                                                    3'd3: pka wait done                                                                                                   3'd4: pka send done                                                                                                 3'd5: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_main_read_state" pos="4:0" rst="0x0">
          <comment>dma control main read port state:                     5'd0: idle                                                                                                                     5'd1: read key/hmac key/aad start                                                            5'd2: wait read key/hmac key/aad done                                                5'd3: read key/hmac key/aad, send done                                             5'd4: read key/hmac key/aad done                                                          5'd5: STD read start                                                                                                5'd6: STD wait done                                                                                           5'd7: STD send done                                                                                        5'd8: STD done,then judgement                                                               5'd9: STD pause                                                                                                     5'd10: STD done                                                                                                     5'd11: LLIST read list                                                                                                  5'd12: LLIST read list wait done                                                                 5'd13: LLIST read list send done                                                              5'd14: LLIST read list done                                                                            5'd15: LLIST read node                                                                                        5'd16: LLIST read node wait                                                                               5'd17: LLIST read node done                                                                      5'd18: LLIST node execution                                                                                    5'd19: LLIST node execution, wait done                                                   5'd20: LLIST node execution, send done                                             5'd21: LLIST node execution done                                                               5'd22: LLIST judge next state                                                                                    5'd23: LLIST pause                                                                                         5'd24: LLIST done                                                                                                        5'd25: read session key start                                                                                  5'd26: read session key done</comment>
        </bits>
      </reg>
      <reg name="ce_debug_aes_status" protect="rw">
        <comment>aes module state</comment>
        <bits access="r" name="rf_ce_fde_rdma_data_status" pos="28:27" rst="0x0">
          <comment>rdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_wdma_data_status" pos="26:25" rst="0x0">
          <comment>wdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_dma_main_read_state" pos="24:20" rst="0x0">
          <comment>dma control main read port state:                     5'd0: idle                                                                                                                     5'd1: read key/hmac key/aad start                                                            5'd2: wait read key/hmac key/aad done                                                5'd3: read key/hmac key/aad, send done                                             5'd4: read key/hmac key/aad done                                                          5'd5: STD read start                                                                                                5'd6: STD wait done                                                                                           5'd7: STD send done                                                                                        5'd8: STD done,then judgement                                                               5'd9: STD pause                                                                                                     5'd10: STD done                                                                                                     5'd11: LLIST read list                                                                                                  5'd12: LLIST read list wait done                                                                 5'd13: LLIST read list send done                                                              5'd14: LLIST read list done                                                                            5'd15: LLIST read node                                                                                        5'd16: LLIST read node wait                                                                               5'd17: LLIST read node done                                                                      5'd18: LLIST node execution                                                                                    5'd19: LLIST node execution, wait done                                                   5'd20: LLIST node execution, send done                                             5'd21: LLIST node execution done                                                               5'd22: LLIST judge next state                                                                                    5'd23: LLIST pause                                                                                         5'd24: LLIST done                                                                                                        5'd25: read session key start                                                                                  5'd26: read session key done</comment>
        </bits>
        <bits access="r" name="rf_ce_rdma_data_status" pos="17:15" rst="0x0">
          <comment>rdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_sm4_status" pos="14:12" rst="0x0">
          <comment>sm4 state:                                                         3'd0: idle                                                                 3'd1: generate key                                            3'd2: round start                                                3'd3: rounding                                                   3'd4: xts generate key                                       3'd5: xts round start                                          3'd6: xts rounding                                             3'd7: done</comment>
        </bits>
        <bits access="r" name="rf_ce_wdma_data_status" pos="11:10" rst="0x0">
          <comment>wdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_aes_status" pos="7:0" rst="0x0">
          <comment>[3:0]: aes read counter;                                    [7:4]: aes work state                                          4'd0: idle                                                           4'd1: key expand                                               4'd2: xts encrypto tweek                                    4'd3: enc/decrpto select                                    4'd4: wait                                                                 4'd5: one block done                                        4'd6: xts encrypto tweek post                            4'd7: xts encrypto tweek pre   '                          4'd8: zero encrypto                                           4'd9: aad ghash                                                4'd10: length ghash                                          4'd11: gcm wait</comment>
        </bits>
      </reg>
      <reg name="ce_debug_tdes_status" protect="rw">
        <comment>tdes module state</comment>
        <bits access="r" name="rf_ce_tdes_status" pos="29:25" rst="0x0">
          <comment>tdes module status:                                           [3:0]: des run cycle counter
[4]: des key check error</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_wvalid_state" pos="24:21" rst="0x0">
          <comment>generate wvalid state:                                       4'd0: idle                                                           4'd1: wait enough data                               4'd2: generate wvalid                                        4'd3: wait enough data when bursting               4'd4: wait wready for next burst data</comment>
        </bits>
        <bits access="r" name="rf_ce_efuse_access_status" pos="20:16" rst="0x0">
          <comment>efuse access status:                                         5'd0: idle                                                           5'd1: read selec between hmac and symmetric                                         5'd2: trng write start                                        5'd3: hmac session key read start                              5'd4: trng write                                                  5'd5: hmac read                                             5'd6: symmetric key1 read start                      5'd7: symmetric key2 read start                      5'd8: symmetric key1 read                              5'd9: symmetric key2 read                              5'd10: done                                                  5'd11: hmac session key read                             5'd12: read huk  after write err                                        5'd13: trng write next                                                   5'd15: iram key done                                                   5'd16: pka non-symmetric key read start                      5'd17: pka non-symmetric key read                      5'd18: pka non-symmetric key write start                             5'd19: pka non-symmetric key write           5'd20: pka non-symmetric key write next   5'd21: ce read non-symmetric key after write err</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_dma_main_write_state" pos="15:13" rst="0x0">
          <comment>3'd0: idle                                                          3'd1: pka store start                                        3'd2: pka wait done                                         3'd3: pka send done                                       3'd4: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_dma_main_write_state" pos="12:8" rst="0x0">
          <comment>dma control main write port state:                     5'd0: idle                                                           5'd1: STD hash start                                            5'd2: STD start                                                  5'd3: STD wait done                                          5'd4: STD send done                                        5'd5: STD next state judgement                        5'd6: STD pause                                               5'd7: STD done                                                 5'd8: LLIST check node buffer status               5'd9: LLIST load node                                       5'd10: LLIST load node wait                               5'd11: LLIST load node update parameter       5'd12: LLIST load node done                            5'd13: LLIST hash start                                     5'd14: LLIST start                                             5'd15: LLIST wait done                                     5'd16: LLIST send done                                    5'd17: LLIST next start judgement                    5'd18: LLIST pause                                           5'd19: LLIST done                                              5'd20: pka store start                                        5'd21: pka wait done                                         5'd22: pka send done                                       5'd23: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_aes_status" pos="7:0" rst="0x0">
          <comment>[3:0]: aes read counter;                                    [7:4]: aes work state                                          4'd0: idle                                                           4'd1: key expand                                               4'd2: xts encrypto tweek                                    4'd3: enc/decrpto select                                    4'd4: wait                                                                 4'd5: one block done                                        4'd6: xts encrypto tweek post                            4'd7: xts encrypto tweek pre   '                          4'd8: zero encrypto                                           4'd9: aad ghash                                                4'd10: length ghash                                          4'd11: gcm wait</comment>
        </bits>
      </reg>
      <reg name="ce_debug_hash_status0" protect="rw">
        <comment>hash module state 0</comment>
      </reg>
      <reg name="ce_debug_hash_status1" protect="rw">
        <comment>hash module state 1</comment>
        <bits access="r" name="rf_ce_hash_status1" pos="9:0" rst="0x0">
          <comment>hash module status:                                          [2:0]: hash state                                            3'd0: idle          3'd1: data request                        3'd2: no-hmac  3'd3: hmac key                           3'd4: first hmac message                                  3'd5: second hmac message                              3'd6: digest out                                                 [8:3]: hash run cycle</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_clk_en" protect="rw">
        <comment>ce module clock enable</comment>
        <bits access="rw" name="rf_ce_fde_aes_clk_en" pos="28" rst="0x0">
          <comment>force fde aes clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_pub_clk_en" pos="25" rst="0x0">
          <comment>force pub rng autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_pub_clk_en" pos="24" rst="0x0">
          <comment>pub trng clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_clk_en" pos="23" rst="0x0">
          <comment>force chacha engine clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_poly_clk_en" pos="22" rst="0x0">
          <comment>force poly engine clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_clk_en" pos="21" rst="0x0">
          <comment>force rng autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_clk_en" pos="20" rst="0x0">
          <comment>force aes key expan autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_axi_clk_en" pos="18" rst="0x0">
          <comment>force dma axi autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_ctrl_clk_en" pos="17" rst="0x0">
          <comment>force dma ctrl autogate  clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_apb_rf_clk_en" pos="16" rst="0x0">
          <comment>force apb regbank autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_ck_en" pos="9" rst="0x0">
          <comment>simon speck clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_ck_en" pos="8" rst="0x0">
          <comment>pka clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacah_poly_ck_en" pos="7" rst="0x0">
          <comment>chacha poly clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_ck_en" pos="6" rst="0x0">
          <comment>sm4 clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_ck_en" pos="5" rst="0x0">
          <comment>trng clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_des_ck_en" pos="4" rst="0x0">
          <comment>des clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_ck_en" pos="3" rst="0x0">
          <comment>hash clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_ck_en" pos="2" rst="0x0">
          <comment>fde aes clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_ck_en" pos="1" rst="0x0">
          <comment>aes clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_ck_en" pos="0" rst="0x0">
          <comment>dma_main clock enable</comment>
        </bits>
      </reg>
      <reg name="ce_int_en" protect="rw">
        <comment>ce interrupt enable</comment>
        <bits access="rw" name="rf_ce_en_pka_rd_efuse_key_addr_int" pos="16" rst="0x0">
          <comment>enable pka load efuse addr  is out of range int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_wr_efuse_key_addr_int" pos="15" rst="0x0">
          <comment>enable pka store efuse addr  is out of range int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_len_err_int" pos="14" rst="0x0">
          <comment>enable pka load or store length is zero int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_cmd_done_done_int" pos="13" rst="0x0">
          <comment>enable ce pka one task done flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_find_prime_err_int" pos="12" rst="0x0">
          <comment>enable can't fime prime int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_div_zero_err_int" pos="11" rst="0x0">
          <comment>enable divisor zero int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_use_efuse_err_int" pos="10" rst="0x0">
          <comment>enable ce use efuse error int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_one_cmd_done_int" pos="9" rst="0x0">
          <comment>enable ce pka one cmd done int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_pka_store_done_int" pos="8" rst="0x0">
          <comment>enable ce pka store done int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_rng_int" pos="7" rst="0x0">
          <comment>enable rng/trng int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_tdes_key_err_int" pos="5" rst="0x0">
          <comment>enable tdes key check error int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_len_err_int" pos="4" rst="0x0">
          <comment>enable src/dst length error int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_efs_all_zero_int" pos="2" rst="0x0">
          <comment>enable the efuse huk check zero int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_efs_huk_unstable_int" pos="1" rst="0x0">
          <comment>enable the efuse huk check unstable int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_cmd_done_int" pos="0" rst="0x0">
          <comment>enable one command done int</comment>
        </bits>
      </reg>
      <reg name="ce_int_status" protect="rw">
        <comment>ce interrupt status</comment>
        <bits access="r" name="rf_ce_pka_rd_efuse_key_addr_int_status" pos="16" rst="0x0">
          <comment>pka load efuse addr  is out of range</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_wr_efuse_key_addr_int_status" pos="15" rst="0x0">
          <comment>pka store efuse addr  is out of range,when the int is valid , ap clear it ,and  then need reset the  ce</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_len_err_int_status" pos="14" rst="0x0">
          <comment>pka load or store length is zero</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_cmd_done_done_int_status" pos="13" rst="0x0">
          <comment>ce pka one task done flag</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_find_prime_err_flag" pos="12" rst="0x0">
          <comment>can't fime prime flag</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_div_zero_err_flag" pos="11" rst="0x0">
          <comment>divisor zero flag</comment>
        </bits>
        <bits access="r" name="rf_ce_use_efuse_err_flag" pos="10" rst="0x0">
          <comment>ce use efuse error flag</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_one_cmd_done_flag" pos="9" rst="0x0">
          <comment>ce pka one cmd done flag</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_store_done_flag" pos="8" rst="0x0">
          <comment>ce pka store done flag</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_int_status" pos="7" rst="0x0">
          <comment>ce rng/trng int status</comment>
        </bits>
        <bits access="r" name="rf_ce_tdes_key_err_int_status" pos="5" rst="0x0">
          <comment>ce tdes key check error int status</comment>
        </bits>
        <bits access="r" name="rf_ce_len_err_int_status" pos="4" rst="0x0">
          <comment>src/dst length error int status</comment>
        </bits>
        <bits access="r" name="rf_ce_efs_all_zero_int_status" pos="2" rst="0x0">
          <comment>when ce write the huk parameters, the efuse ctrl response the error, then ce will check the write huk parameters is 0 or not; if it is 0, then intrrupt</comment>
        </bits>
        <bits access="r" name="rf_ce_efs_huk_unstable_int_status" pos="1" rst="0x0">
          <comment>when ce write the huk parameters, the efuse ctrl response the error, then ce will check the write huk parameters is 0 or not; if it is not 0 &amp; is unstable, then intrrupt</comment>
        </bits>
        <bits access="r" name="rf_ce_cmd_done_int_status" pos="0" rst="0x0">
          <comment>one command done int status,</comment>
        </bits>
      </reg>
      <reg name="ce_int_clear" protect="rw">
        <comment>ce interrupt clear</comment>
        <bits access="rc" name="rf_ce_clear_pka_rd_efuse_key_addr_int" pos="16" rst="0x0">
          <comment>clear pka load efuse addr  is out of range int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_wr_efuse_key_addr_int" pos="15" rst="0x0">
          <comment>clear pka store efuse addr  is out of range int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_len_err_int" pos="14" rst="0x0">
          <comment>clear pka load or store length is zero int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_cmd_done_done_int" pos="13" rst="0x0">
          <comment>clear ce pka one task done flag</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_find_prime_err_int" pos="12" rst="0x0">
          <comment>clear can't fime prime int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_div_zero_err_int" pos="11" rst="0x0">
          <comment>clear divisor zero int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_use_efuse_err_int" pos="10" rst="0x0">
          <comment>clear ce use efuse error flag</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_one_cmd_done_int" pos="9" rst="0x0">
          <comment>clear ce pka one cmd done flag</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_pka_store_done_int" pos="8" rst="0x0">
          <comment>clear ce pka store done flag</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_tdes_key_err_int" pos="5" rst="0x0">
          <comment>clear tdes key check error int status</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_len_err_int" pos="4" rst="0x0">
          <comment>clear error int status</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_efs_all_zero_int" pos="2" rst="0x0">
          <comment>clear the huk is zero int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_efs_huk_unstable_int" pos="1" rst="0x0">
          <comment>clear the huk is unstable int</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_cmd_done_int" pos="0" rst="0x0">
          <comment>clear one command done int status,</comment>
        </bits>
      </reg>
      <reg name="ce_start" protect="rw">
        <comment>start ce</comment>
        <bits access="rc" name="rf_ce_start" pos="0" rst="0x0">
          <comment>start ce one fo the AES/SM4/HASH cipher module</comment>
        </bits>
      </reg>
      <reg name="ce_clear" protect="rw">
        <comment>clear ce</comment>
        <bits access="rc" name="rf_ce_clear" pos="0" rst="0x0">
          <comment>reset ce status one fo the AES/SM4/HASH cipher module</comment>
        </bits>
      </reg>
      <reg name="ce_aes_mode" protect="rw">
        <comment>aes work mode cfg</comment>
        <bits access="rw" name="rf_ce_aes_key_update_n" pos="15" rst="0x0">
          <comment>1: dont update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_xts_iv_rotation" pos="14" rst="0x1">
          <comment>0: rtl rotation, 1: no-rotation</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_key_len_sel" pos="13:12" rst="0x0">
          <comment>00: key 128bits,01:192bits,10,11:256bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_work_mode" pos="11:8" rst="0x0">
          <comment>0000:ECB,0001:CBC,0010:CTR,0011:XTS,0100:CMAC,0101:GCM,0110:GMAC,0111:CCM,1000:CBCMAC,1001:CFB,1010:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_mac_ctr_inc_mode" pos="6:5" rst="0x0">
          <comment>aes mac ctr inc mode:  00: normal mode; 01: low 64bit is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_en" pos="0" rst="0x0">
          <comment>aes module enable</comment>
        </bits>
      </reg>
      <reg name="ce_tdes_mode" protect="rw">
        <comment>tdes work mode cfg</comment>
        <bits access="rw" name="rf_ce_tdes_key_evenodd_check_on" pos="13" rst="0x0">
          <comment>0: disable,  1: enable even/odd check</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_key_even_sel" pos="12" rst="0x0">
          <comment>0:odd check,1:even check</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_work_mode" pos="9:8" rst="0x0">
          <comment>00:ECB,01:CBC</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_en" pos="0" rst="0x0">
          <comment>tdes module enable</comment>
        </bits>
      </reg>
      <reg name="ce_hash_mode" protect="rw">
        <comment>hash work mode cfg</comment>
        <bits access="rw" name="rf_hash_sha3_shake_out_len" pos="23:16" rst="0x0">
          <comment>sha3 shake out length</comment>
        </bits>
        <bits access="rw" name="rf_hash_hmac_pad_sel" pos="13:12" rst="0x0">
          <comment>00: normal hash; 01: ipad ;10: opad; 11: reserved</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_mode" pos="8:4" rst="0x0">
          <comment>hash work module,
5d0: Doesnt work
5d1: MD5
5d2: SHA-1 mode
5d3: SHA-224 mode
5d4: SHA-256 mode
5d5: SHA-384 mode
5d6: SHA-512 mode
5d7: SHA-512/224 mode
5d8: SHA-512/256 mode
5d9: SM3 mode
5d10: SHA3-224
5d11: SHA3-256
5d12: SHA3-384
5d13: SHA3-512
5d14: SHA3-SHAKE128
5d15: SHA3-SHAKE256</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_en" pos="0" rst="0x0">
          <comment>hash module enable</comment>
        </bits>
      </reg>
      <reg name="ce_chacha_poly_mode" protect="rw">
        <comment>chacha poly work mode cfg</comment>
        <bits access="rw" name="rf_ce_chacha_poly_mode" pos="9:8" rst="0x0">
          <comment>00:chacha20 ; 01:poly1305;
10:AEAD_CHACHA20_POLY1305</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_poly_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encrypt,1:decrypt</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_poly_en" pos="0" rst="0x0">
          <comment>chacha poly module enable</comment>
        </bits>
      </reg>
      <reg name="ce_simon_speck_mode" protect="rw">
        <comment>simon speck work mode cfg</comment>
        <bits access="rw" name="rf_ce_simon_speck_key_update_n" pos="15" rst="0x0">
          <comment>1: dont update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_key_len_sel" pos="14:13" rst="0x0">
          <comment>00: key 128bits,01:192bits,10:256bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_work_mode" pos="11:9" rst="0x0">
          <comment>000:ECB,001:CBC,010:CTR,100:CFB,101:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_sel" pos="8" rst="0x0">
          <comment>0:speck; 1:simon</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encrypt,1:decrypt</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_en" pos="0" rst="0x0">
          <comment>chacha poly module enable</comment>
        </bits>
      </reg>
      <reg name="ce_cfg" protect="rw">
        <comment>ce basic configure</comment>
        <bits access="rw" name="rf_ce_src_word_switch" pos="23" rst="0x0">
          <comment>switch source high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_word_switch" pos="22" rst="0x0">
          <comment>switch destination high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_src_byte_switch" pos="21" rst="0x1">
          <comment>source data switch of one word</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_byte_switch" pos="20" rst="0x0">
          <comment>destination data switch of one word</comment>
        </bits>
        <bits access="r" name="rf_ce_key_hdcp_en" pos="18" rst="0x0">
          <comment>0:disable hdcp mode, 1: enable hdcp mode</comment>
        </bits>
        <bits access="r" name="rf_ce_list_update_iv_sec_cnt" pos="17" rst="0x0">
          <comment>list update iv/sec/cnt flag</comment>
        </bits>
        <bits access="r" name="rf_ce_list_data_end_flag" pos="16" rst="0x0">
          <comment>data end in link list mode</comment>
        </bits>
        <bits access="r" name="rf_ce_list_end_flag" pos="15" rst="0x0">
          <comment>list end flag</comment>
        </bits>
        <bits access="r" name="rf_ce_list_aad_flag" pos="14" rst="0x0">
          <comment>0: isn't aad list 1: is aad list</comment>
        </bits>
        <bits access="r" name="rf_ce_list_aad_end_flag" pos="13" rst="0x0">
          <comment>0: aad no-end list 1: aad end list</comment>
        </bits>
        <bits access="rw" name="rf_ce_do_wait_bdone" pos="12" rst="0x1">
          <comment>wait axi B channel bready</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_iram_flag" pos="11" rst="0x0">
          <comment>0:normal mode, 1: iram key or secure ddr key</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_session_key_flag" pos="10" rst="0x0">
          <comment>0: normal mode, 1: aes/sm4 key from session key</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_efuse_flag" pos="9" rst="0x0">
          <comment>0: normal mode, 1: aes/sm4 key from efuse</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_ddr_flag" pos="8" rst="0x0">
          <comment>1: all crypto key in ddr/iram; 0: from registers</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_bypass" pos="7" rst="0x0">
          <comment>0:normal mode, 1: bypass ce</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_aad_flag" pos="6" rst="0x0">
          <comment>0: std flag 1: std aad flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_aad_end_flag" pos="5" rst="0x0">
          <comment>0: std aad no-end flag 1: std aad end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_end_flag" pos="4" rst="0x0">
          <comment>std end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_cmd_ioc" pos="3" rst="0x0">
          <comment>0: enable cmd int output: 1: don't output int</comment>
        </bits>
        <bits access="rw" name="rf_ce_dont_dump_ddr" pos="2" rst="0x0">
          <comment>0: dump from ddr; 1: don't dump</comment>
        </bits>
        <bits access="rw" name="rf_ce_dont_rcv_ddr" pos="1" rst="0x0">
          <comment>0: rcv from ddr; 1: don't rcv</comment>
        </bits>
        <bits access="rw" name="rf_ce_link_mode_flag" pos="0" rst="0x0">
          <comment>0:std mode, 1: link mode</comment>
        </bits>
      </reg>
      <reg name="ce_src_frag_length" protect="rw">
        <comment>dma read port node data length</comment>
        <bits access="rw" name="rf_ce_src_addr_hi" pos="27:24" rst="0x0">
          <comment>source address high 4bits; or aes mac aad address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_src_frag_len" pos="23:0" rst="0x0">
          <comment>source fragment length of each node;  or aes mac aad length</comment>
        </bits>
      </reg>
      <reg name="ce_dst_frag_length" protect="rw">
        <comment>dma write port node data length</comment>
        <bits access="rw" name="rf_ce_dst_addr_hi" pos="27:24" rst="0x0">
          <comment>destination address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_frag_len" pos="23:0" rst="0x0">
          <comment>destination fragment length of each node</comment>
        </bits>
      </reg>
      <reg name="ce_src_addr" protect="rw">
        <comment>dma source address</comment>
      </reg>
      <reg name="ce_dst_addr" protect="rw">
        <comment>dma destination address</comment>
      </reg>
      <reg name="ce_list_length" protect="rw">
        <comment>dma one length</comment>
        <bits access="rw" name="rf_ce_list_ptr_hi" pos="19:16" rst="0x0">
          <comment>ce_list_ptr high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_list_len" pos="11:0" rst="0x0">
          <comment>first list length,support max 256 nodes</comment>
        </bits>
      </reg>
      <reg name="ce_list_ptr" protect="rw">
        <comment>dma list pointer</comment>
      </reg>
      <reg name="ce_aes_tdes_rsa_key_length" protect="rw">
        <comment>aes tdes rsa key length</comment>
        <bits access="rw" name="rf_ce_aes_tdes_rsa_key_addr_hi" pos="27:24" rst="0x0">
          <comment>aes hmac key address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_tdes_rsa_key_len" pos="23:0" rst="0x0">
          <comment>aes hmac key length</comment>
        </bits>
      </reg>
      <reg name="ce_aes_tdes_rsa_key_address" protect="rw">
        <comment>aes tdes rsa key address</comment>
      </reg>
      <reg name="ce_aes_tag_length" protect="rw">
        <comment>aes tag length</comment>
        <bits access="rw" name="rf_ce_aes_tag_addr_hi" pos="11:8" rst="0x0">
          <comment>aes tag address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_tag_len" pos="7:0" rst="0x10">
          <comment>aes tag length</comment>
        </bits>
      </reg>
      <reg name="ce_aes_tag_address" protect="rw">
        <comment>aes tag address</comment>
      </reg>
      <reg name="ce_iv_sec_cnt0" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt1" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt2" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt3" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_aes_des_key10" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key11" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key12" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key13" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key14" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key15" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key16" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key17" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key20" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key21" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key22" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key23" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key24" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key25" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key26" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key27" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_sm4_mode" protect="rw">
        <comment>sm4 work mode cfg</comment>
        <bits access="rw" name="rf_ce_sm4_key_update_n" pos="12" rst="0x0">
          <comment>1: dont update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_xts_inv_rotation" pos="11" rst="0x1">
          <comment>0: rtl rotation, 1: no-rotation</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_work_mode" pos="10:8" rst="0x0">
          <comment>000:ECB,001:CBC,010:CTR,011:XTS,100:CFB,101:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_en" pos="0" rst="0x0">
          <comment>sm4 module enable</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_ip_version" protect="rw">
        <comment>IP version</comment>
        <bits access="r" name="rf_ce_ip_version_hi" pos="31:4" rst="0x40">
          <comment>r4</comment>
        </bits>
        <bits access="rw" name="rf_ce_ip_version_lo" pos="3:0" rst="0x0">
          <comment>px</comment>
        </bits>
      </reg>
      <reg name="ce_pka_mode" protect="rw">
        <comment>pka work mode cfg</comment>
        <bits access="rw" name="rf_ce_pka_cmd_addr_hi" pos="31:28" rst="0x0">
          <comment>pka instruction address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_src_word_switch" pos="27" rst="0x0">
          <comment>switch source high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_dst_word_switch" pos="26" rst="0x0">
          <comment>switch destination high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_src_byte_switch" pos="25" rst="0x1">
          <comment>source data switch of one word</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_dst_byte_switch" pos="24" rst="0x0">
          <comment>destination data switch of one word</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_find_prime_num" pos="23:16" rst="0xff">
          <comment>find prime counter threshold</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_reg_num_sel" pos="1" rst="0x0">
          <comment>pka register number select; 0: 32, 1:16</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_en" pos="0" rst="0x0">
          <comment>pka module enable</comment>
        </bits>
      </reg>
      <reg name="ce_pka_reg_length01" protect="rw">
        <comment>pka register length01</comment>
        <bits access="rw" name="rf_ce_pka_reg_length1" pos="25:16" rst="0x20">
          <comment>ce pka register length1</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_reg_length0" pos="9:0" rst="0x20">
          <comment>ce pka register length0</comment>
        </bits>
      </reg>
      <reg name="ce_pka_reg_length23" protect="rw">
        <comment>pka register length23</comment>
        <bits access="rw" name="rf_ce_pka_reg_length3" pos="25:16" rst="0x20">
          <comment>ce pka register length3</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_reg_length2" pos="9:0" rst="0x20">
          <comment>ce pka register length2</comment>
        </bits>
      </reg>
      <hole size="704"/>
      <reg name="ce_pka_inst_pc" protect="rw">
        <comment>pka instruction pointer</comment>
        <bits access="r" name="rf_ce_pka_div_zero_err_flag" pos="31" rst="0x0">
          <comment>divisor zero</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_infinity_point_flag" pos="30" rst="0x0">
          <comment>ce pka infinity point</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_modinv_err" pos="29" rst="0x0">
          <comment>ce pka mod inv error</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_addsub_co" pos="28" rst="0x0">
          <comment>ce pka add/sub carry</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_find_prime_err_flag" pos="27" rst="0x0">
          <comment>can't fime prime</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_one_cmd_done" pos="25" rst="0x0">
          <comment>1: pka one cmd instruction done</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_store_done" pos="24" rst="0x0">
          <comment>1: pka store instruction done</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_inst_pc" pos="16:0" rst="0x0">
          <comment>pka instruction pointer</comment>
        </bits>
      </reg>
      <reg name="ce_pka_debug0" protect="rw">
        <comment>pka debug info</comment>
      </reg>
      <reg name="ce_pka_debug1" protect="rw">
        <comment>pka debug info</comment>
      </reg>
      <reg name="ce_pka_debug2" protect="rw">
        <comment>pka debug info</comment>
      </reg>
      <reg name="ce_pka_debug3" protect="rw">
        <comment>pka debug info</comment>
      </reg>
      <hole size="96"/>
      <reg name="ce_pf_calc" protect="rw">
        <comment>ce performace counter</comment>
      </reg>
      <reg name="ce_user_flag" protect="rw">
        <comment>ce use flag</comment>
        <bits access="rw" name="rf_ce_efuse_double_bit_en" pos="16" rst="0x1">
          <comment>the signal only can be confgi in the security apb,when the ce write the huk parameter,the bit should be 1'b1;</comment>
        </bits>
        <bits access="r" name="rf_ce_pub_priority_vld" pos="8" rst="0x0">
          <comment>when the siganl is high ,then flag the pub aes/sm4/hash is catch the cmd from the pub cmd buf or the pub is working</comment>
        </bits>
        <bits access="r" name="rf_ce_sec_priority_vld" pos="4" rst="0x0">
          <comment>when the siganl is high ,then flag the sec aes/sm4/hash is catch the cmd from the sec cmd buf or the sec is working</comment>
        </bits>
        <bits access="rw" name="rf_ce_use_flag" pos="0" rst="0x0">
          <comment>ce sec or pub use the ce aes/sm4/hash cicpher module</comment>
        </bits>
      </reg>
      <reg name="ce_axi_axcache" protect="rw">
        <comment>axi bus cache</comment>
        <bits access="rw" name="rf_ce_src_outstanding_num" pos="15:12" rst="0x7">
          <comment>axi read port outstanding number</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_outstanding_num" pos="11:8" rst="0x7">
          <comment>axi write port outstanding number</comment>
        </bits>
        <bits access="rw" name="rf_ce_axi_awcache" pos="7:4" rst="0x0">
          <comment>axi bus wcache</comment>
        </bits>
        <bits access="rw" name="rf_ce_axi_arcache" pos="3:0" rst="0x0">
          <comment>axi bus rcache</comment>
        </bits>
      </reg>
      <reg name="ce_cmd_stop_ctrl" protect="rw">
        <comment>cmd stop ctrl</comment>
        <bits access="rc" name="rf_ce_pka_cmd_stop_clear" pos="12" rst="0x0">
          <comment>to restart</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_cmd_stop_status" pos="9" rst="0x0">
          <comment>1: stop command is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_cmd_stop" pos="8" rst="0x0">
          <comment>0: to execute next cmd; 1: finish current cmd,then stop</comment>
        </bits>
        <bits access="rc" name="rf_ce_cmd_stop_clear" pos="4" rst="0x0">
          <comment>to restart</comment>
        </bits>
        <bits access="r" name="rf_ce_cmd_stop_status" pos="1" rst="0x0">
          <comment>1: stop command is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_cmd_stop" pos="0" rst="0x0">
          <comment>0: to execute next cmd; 1: finish current cmd,then stop</comment>
        </bits>
      </reg>
      <reg name="ce_axi_protect_sel" protect="rw">
        <comment>axi prot sel</comment>
        <bits access="rw" name="pka_dummy" pos="15:12" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="pka_axi_prot_sel_st" pos="11" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pka_axi_prot_sel_ld" pos="10" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pka_axi_prot_sel_cmd" pos="9" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pka_axi_prot_sel_en" pos="8" rst="0x0">
          <comment>0: disable pka side sel; 1: enable pka side axi sel</comment>
        </bits>
        <bits access="rw" name="sec_dummy" pos="7:5" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="sec_axi_prot_sel_wtxt" pos="4" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="sec_axi_prot_sel_rtxt" pos="3" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="sec_axi_prot_sel_rlist" pos="2" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="sec_axi_prot_sel_rkey" pos="1" rst="0x1">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="sec_axi_prot_sel_en" pos="0" rst="0x0">
          <comment>0: disable sec side sel; 1: enable sec side axi sel</comment>
        </bits>
      </reg>
      <reg name="ce_pf_calc_high" protect="rw">
        <comment>ce performace counter high 32 bit</comment>
      </reg>
      <hole size="1216"/>
      <reg name="ce_rng_en" protect="rw">
        <comment>RNG module enable RNG module enable</comment>
        <bits access="rw" name="rf_ce_rng_data_mux_enable" pos="18" rst="0x0">
          <comment>if the signal is high,then the rng data  come from cpu.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_mux_ring_enable" pos="17" rst="0x0">
          <comment>if the signal is high,then the osc rings sel signal come from rf_rng_src_sel_enable.</comment>
        </bits>
        <bits access="rw" name="rf_rng_auto_enable" pos="16" rst="0x1">
          <comment>if the signal is high,then the osc rings is auto choose to work</comment>
        </bits>
        <bits access="rw" name="rf_rng_src_sel_enable" pos="15:8" rst="0xff">
          <comment>the signal control which osc ring is work,when the least bit is high,then the first one osc ring is choose as the entropy.</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_ptest_mode_en" pos="4" rst="0x0">
          <comment>trng source test enable</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_rst_from_cpu" pos="3" rst="0x0">
          <comment>the rst signal to the exotic trng module</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_src_from_cpu_enable" pos="2" rst="0x0">
          <comment>the signal can change when the trng is work ,which can control the trng start or stop by cpu.</comment>
        </bits>
        <bits access="rc" name="rf_ce_trng_src_en" pos="1" rst="0x0">
          <comment>trng source enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_en" pos="0" rst="0x0">
          <comment>RNG module enable bit:
1:enbale RNG module to generate random number when auto mode is not enable</comment>
        </bits>
      </reg>
      <reg name="ce_rng_config" protect="rw">
        <comment>RNG module config RNG module config</comment>
        <bits access="rw" name="number_of_samples_threshold" pos="31:20" rst="0xfff">
          <comment>Threshold bit value for random data , indicates that the cycle of the src_en is high, the max value is 12'hFFF.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_ptest_data_in" pos="16" rst="0x0">
          <comment>when the data_in is 0,the test result should be 1,and the data_in is 1,the test result should be 0;</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_data_valid_threshold" pos="11:8" rst="0x3">
          <comment>Threshold value for rng_data_valid, indicates that when rng_data_valid high, there area at least number of rng_data_valid_threshold words in SRAMthe max value is 4'hf.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_exotic_fault_rst_sel" pos="7" rst="0x0">
          <comment>ce_rng_exotic_fault_rst_sel:                  1'b0:the rst generated by the fault signal,                 1'b1:don't generated the rst signal,the rst signal come from the cpu</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_source_sel" pos="6:5" rst="0x3">
          <comment>local RNG entropty source select</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_data_len_sel" pos="4" rst="0x0">
          <comment>when it's 1,the the post process module need data bitwith is 440bit,else is 256bit</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_trng_sel" pos="3" rst="0x0">
          <comment>the signal select the trng data come from exotic or local trng module 1:exotic 0:local</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_ring_sel" pos="2:0" rst="0x3">
          <comment>select entropy source,the range is 0x0 to 0x7</comment>
        </bits>
      </reg>
      <reg name="ce_rng_data" protect="rw">
        <comment>RNG data for cpu to read RNG data for cpu to read</comment>
      </reg>
      <reg name="ce_rng_sample_period" protect="rw">
        <comment>time interval between two samples time interval between two samples</comment>
        <bits access="rw" name="rf_ce_rng_first_sample_en" pos="31" rst="0x0">
          <comment>enable first level sample</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_first_sample_period" pos="30:16" rst="0x0">
          <comment>sample period between two samples, the value is from 0 to 255</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_second_sample_period" pos="15:0" rst="0x0">
          <comment>sample period between two samples, the value is from 0 to 255</comment>
        </bits>
      </reg>
      <reg name="ce_rng_post_process_en" protect="rw">
        <comment>post process functions select post process functions select</comment>
        <bits access="rw" name="rf_ce_rng_post_eight_en" pos="7" rst="0x0">
          <comment>when it's 1,the the PRNG data  xor with trng data</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_seven_en" pos="6" rst="0x1">
          <comment>when it's 1,the the final post process module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_six_en" pos="5" rst="0x0">
          <comment>when it's 1,the the xor process module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_five_en" pos="4" rst="0x0">
          <comment>when it's 1,the the cycle_code module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_four_en" pos="3" rst="0x0">
          <comment>when it's 1,the the lfsr module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_three_en" pos="2" rst="0x0"/>
        <bits access="rw" name="rf_ce_rng_post_second_en" pos="1" rst="0x0">
          <comment>post data path 1 enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_first_en" pos="0" rst="0x0">
          <comment>post data path 0 enable</comment>
        </bits>
      </reg>
      <reg name="ce_rng_work_status" protect="rw">
        <comment>rng work status rng work status</comment>
        <bits access="r" name="rf_ce_rng_rsa_key_gen_rand_num" pos="31:16" rst="0x0">
          <comment>rand data number when keygen done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_process" pos="15:14" rst="0x0">
          <comment>2'b01:Instantiate ;                                                     2'b10:Reseed ;                                                       2'b11:Genarate.</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_pattern_req" pos="13" rst="0x0">
          <comment>when it's 1,cpu can send next 64bit pattern</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_fail" pos="12" rst="0x0">
          <comment>when it's 1,the drbg KAT test fail</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_done" pos="11" rst="0x0">
          <comment>DRBG KAT test done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_es_test_fail" pos="10" rst="0x0">
          <comment>when it's 1,the start-up/on-demand test fail(1024 sample)</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_es_test_done" pos="9" rst="0x0">
          <comment>start-up/on-demand test done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_test_result" pos="8" rst="0x0">
          <comment>the result of test mode</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_result_vld" pos="7" rst="0x0">
          <comment>when it's 1,indicate that the drbg test result data in 0x260 register is valid (cpu can read to check)</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_data_type" pos="6:5" rst="0x0">
          <comment>2'b01: C [439:0] ;                                                    2'b10: V[439:0] ;                                                        2'b11: reseed_counter[31:0].                                  Corresponds to the data of each process in [15:14] .</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_fifo_empty" pos="4" rst="0x1">
          <comment>the fifo status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_error_fault" pos="3" rst="0x0">
          <comment>the exotic rng module status</comment>
        </bits>
        <bits access="r" name="rf_rng_rsa_pka_busy" pos="2" rst="0x0"/>
        <bits access="r" name="rf_ce_rng_data_valid" pos="1" rst="0x0">
          <comment>when high indicates that RNG module has generate 256 bits random data</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_auto_mode_ongoing" pos="0" rst="0x0">
          <comment>when high indicates that auto mode is ongoing, CPU can't access rng_data register</comment>
        </bits>
      </reg>
      <reg name="ce_rng_timeout_cnt" protect="rw">
        <comment>rng time out counter rng time out counter</comment>
      </reg>
      <reg name="ce_rng_int_en" protect="rw">
        <comment>rng interrupt enable rng interrupt enable</comment>
        <bits access="rw" name="rf_ce_rng_cont_htest_int_en" pos="5" rst="0x0">
          <comment>enable continuous health test interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_sram_short_int_en" pos="4" rst="0x0">
          <comment>enable sram short interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_timeout_int_en" pos="3" rst="0x0">
          <comment>enable timeout interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process2_int_en" pos="2" rst="0x0">
          <comment>enable process2 interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process1_int_en" pos="1" rst="0x0">
          <comment>enable process1 interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process0_int_en" pos="0" rst="0x0">
          <comment>enable process0 interrupt</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sts" protect="rw">
        <comment>rng interrupt status rng interrupt status</comment>
        <bits access="r" name="rf_ce_rng_con_htest_int_sts" pos="5" rst="0x0">
          <comment>continuous health test interrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_sram_short_int_sts" pos="4" rst="0x0">
          <comment>sram_short_interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_timeout_int_sts" pos="3" rst="0x0">
          <comment>timeout interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process2_int_sts" pos="2" rst="0x0">
          <comment>process2 interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process1_int_sts" pos="1" rst="0x0">
          <comment>process1 interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process0_int_sts" pos="0" rst="0x0">
          <comment>process0 interrrupt status</comment>
        </bits>
      </reg>
      <reg name="ce_rng_int_clr" protect="rw">
        <comment>rng interrupt clear rng interrupt clear</comment>
        <bits access="rc" name="rf_ce_rng_clear_con_htest_int" pos="5" rst="0x0">
          <comment>clear continuous health test interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_sram_short_int" pos="4" rst="0x0">
          <comment>clear sram short  interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_timeout_int" pos="3" rst="0x0">
          <comment>clear timeout interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process2_int" pos="2" rst="0x0">
          <comment>clear process2 interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process1_int" pos="1" rst="0x0">
          <comment>clear process1 interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process0_int" pos="0" rst="0x0">
          <comment>clear process0 interrupt</comment>
        </bits>
      </reg>
      <reg name="ce_rng_mode" protect="rw">
        <comment>RNG module work mode RNG module work mode</comment>
        <bits access="rw" name="rf_ce_prng_mode" pos="8" rst="0x0">
          <comment>PRNG work mode:
1: Auto Seed update Mode
0: Mannual seed update Mode</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_mode" pos="1:0" rst="0x0">
          <comment>RNG module work mode:
10: PRNG mode
01: TRNG mode                                           0011: Mixed mode for TRNG</comment>
        </bits>
      </reg>
      <reg name="ce_prng_seed_update" protect="rw">
        <comment>PRNG mode seed update config PRNG mode seed update config</comment>
        <bits access="rc" name="rf_ce_prng_seed_update" pos="0" rst="0x0">
          <comment>When Write to 1, PRNG will update seed to PRNG_SEED_CONFIG register value</comment>
        </bits>
      </reg>
      <reg name="ce_prng_seed_config" protect="rw">
        <comment>PRNG mode seed update config PRNG mode seed update config</comment>
      </reg>
      <reg name="ce_rng_bit_rate" protect="rw">
        <comment>RNG Bit Rate RNG Bit Rate</comment>
        <bits access="r" name="rf_rng_gen_bit_cnt" pos="31:16" rst="0x0">
          <comment>RNG Bit Counter</comment>
        </bits>
        <bits access="r" name="rf_rng_bit_rate" pos="15:0" rst="0x0">
          <comment>RNG Bit number each 10000 clock cycle</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sram_data_threshhold" protect="rw">
        <comment>SRAM data numuber threshold SRAM data numuber threshold</comment>
        <bits access="rw" name="rf_ce_rng_sram_valid_threshholdd" pos="3:0" rst="0x0">
          <comment>SRAM data numuber threshold,</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sram_data_residue_num" protect="rw">
        <comment>rng_sram_data_residue_num rng_sram_data_residue_num</comment>
        <bits access="r" name="rf_ce_rng_sram_data_residue_num" pos="3:0" rst="0x0">
          <comment>rng_sram_data_residue_num</comment>
        </bits>
      </reg>
      <reg name="ce_rng_exotic_fault_counter_config" protect="rw">
        <comment>exotic fault counter rng exotic fault counter config</comment>
        <bits access="rw" name="rf_ce_exotic_fault_counter_config" pos="15:0" rst="0x0">
          <comment>config the fault counter and read the counter</comment>
        </bits>
      </reg>
      <reg name="ce_rng_drbg_seed_cnt" protect="rw">
        <comment>drbg seed count drbg seed count</comment>
        <bits access="rw" name="rf_ce_rng_drbg_seed_cnt" pos="15:0" rst="0xc">
          <comment>config the drbg seed after certain time</comment>
        </bits>
      </reg>
      <reg name="ce_rng_ring_num_cfg_l" protect="rw">
        <comment>config ring ring number config ring ring number</comment>
      </reg>
      <reg name="ce_rng_ring_num_cfg_h" protect="rw">
        <comment>config ring ring number config ring ring number</comment>
      </reg>
      <reg name="ce_rng_health_test_config" protect="rw">
        <comment>rng_health_test_config rng_health_test_config</comment>
        <bits access="rw" name="rf_ce_rng_ones_freq_max" pos="18:8" rst="0x25f">
          <comment>default:11'd607(freq 0/1 in 1024)</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_long_term_bit_max" pos="7:2" rst="0x2f">
          <comment>default:6'd47 (conse 48 0/1)   [23]</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_drbg_test_en" pos="1" rst="0x0">
          <comment>open drbg test(on-demand test)</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_es_test_en" pos="0" rst="0x0">
          <comment>open es test(on-demand test)</comment>
        </bits>
      </reg>
      <reg name="ce_rng_drbg_test_pattern_l" protect="rw">
        <comment>ce_rng_drbg_test_pattern_l ce_rng_drbg_test_pattern_l</comment>
      </reg>
      <reg name="ce_rng_drbg_test_pattern_h" protect="rw">
        <comment>ce_rng_drbg_test_pattern_h ce_rng_drbg_test_pattern_h</comment>
      </reg>
      <reg name="ce_rng_raw_data_to_cpu" protect="rw">
        <comment>raw_random_number raw_random_number</comment>
      </reg>
      <reg name="ce_rng_drbg_test_result" protect="rw">
        <comment>ce_rng_drbg_sha256_result ce_rng_drbg_sha256_result</comment>
      </reg>
      <hole size="1248"/>
      <reg name="ce_session_key0" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key1" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key2" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key3" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key4" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key5" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key6" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key7" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key0" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key1" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key2" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key3" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key4" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key5" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key6" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key7" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_secure_key_use_way" protect="rw">
        <comment>ce secure key work mode</comment>
        <bits access="rw" name="rf_ce_secure_key_trng_write" pos="31" rst="0x0">
          <comment>trng output random data for secure key flag;when 256bits HUK output into efuse,the bit will be zero.</comment>
        </bits>
        <bits access="rw" name="rf_ce_secure_key_cpu_access" pos="30" rst="0x0">
          <comment>cpu access secure key flag;the falling edge is to let efuse controller sync data into efuse memory</comment>
        </bits>
        <bits access="rw" name="rf_ce_secure_key_len" pos="29:21" rst="0x0">
          <comment>secure key length configure for key in efuse feature,when read key from efuse, need know this key length</comment>
        </bits>
        <bits access="rw" name="rf_ce_secure_key2_start_raddr" pos="20:11" rst="0x0">
          <comment>secure key2 start read address of efuse memory</comment>
        </bits>
        <bits access="rw" name="rf_ce_secure_key1_start_raddr" pos="10:1" rst="0x0">
          <comment>secure key1 start read address of efuse memory</comment>
        </bits>
        <bits access="rw" name="rf_ce_secure_key2_en" pos="0" rst="0x0">
          <comment>need to read secure key2 from efuse;when need two key(key1 and key2), this bit should be set.</comment>
        </bits>
      </reg>
      <reg name="ce_huk_key_config" protect="rw">
        <comment>ce huk key config</comment>
        <bits access="rw" name="rf_ce_write_efs_addr" pos="31:16" rst="0x0">
          <comment>HUK key initial address</comment>
        </bits>
        <bits access="rw" name="rf_ce_write_efs_length" pos="7:0" rst="0x20">
          <comment>HUK key length</comment>
        </bits>
      </reg>
      <reg name="ce_pka_key_config" protect="rw">
        <comment>ce pka key config</comment>
        <bits access="rw" name="rf_pka_write_efs_end_addr" pos="25:16" rst="0x3ff">
          <comment>PKA private key end address,default value depends on the parameter value passed by AP to CE top,this register writing funciton is standing off .</comment>
        </bits>
        <bits access="rw" name="rf_pka_write_efs_start_addr" pos="9:0" rst="0x0">
          <comment>PKA private key start address,default value depends on the parameter value passed by AP to CE top ,this register writing funciton is standing off .</comment>
        </bits>
      </reg>
      <hole size="3488"/>
      <reg name="ce_cmd_fifo_entry" protect="rw">
        <comment>ce_cmd_fifo_entry</comment>
      </reg>
      <reg name="ce_cmd_fifo_status" protect="rw">
        <comment>ce_cmd_fifo_status</comment>
      </reg>
      <reg name="ce_rcv_addr_lo" protect="rw">
        <comment>ce_rcv_addr_lo</comment>
      </reg>
      <reg name="ce_dump_addr_lo" protect="rw">
        <comment>ce_dump_addr_lo</comment>
      </reg>
      <reg name="ce_dump_addr_hi" protect="rw">
        <comment>ce_dump_addr_hi</comment>
        <bits access="rw" name="rf_ce_dump_addr_hi" pos="7:4" rst="0x0">
          <comment>ce dump address hi</comment>
        </bits>
        <bits access="rw" name="rf_ce_rcv_addr_hi" pos="3:0" rst="0x0">
          <comment>ce rcv address hi</comment>
        </bits>
      </reg>
      <reg name="ce_finish_cmd_cnt" protect="rw">
        <comment>ce_finish_cmd_cnt</comment>
      </reg>
      <hole size="1856"/>
      <reg name="ce_pka_cmd_fifo_entry" protect="rw">
        <comment>ce_pka_cmd_fifo_entry</comment>
      </reg>
      <reg name="ce_pka_cmd_fifo_status" protect="rw">
        <comment>ce_pka_cmd_fifo_status</comment>
      </reg>
      <reg name="ce_pka_cmd_addr" protect="rw">
        <comment>pka cmd dma source address</comment>
      </reg>
      <reg name="ce_pka_store_addr_hi" protect="rw">
        <comment>pka store dma destination address</comment>
        <bits access="rw" name="rf_ce_pka_store_addr_hi" pos="18:0" rst="0x0">
          <comment>pka store high 19bits addr</comment>
        </bits>
      </reg>
      <reg name="ce_pka_load_addr_hi" protect="rw">
        <comment>pka load address</comment>
        <bits access="rw" name="rf_ce_pka_load_addr_hi" pos="18:0" rst="0x0">
          <comment>pka load high 19bits addr</comment>
        </bits>
      </reg>
      <reg name="ce_pka_finish_cmd_cnt" protect="rw">
        <comment>ce_pka_finish_cmd_cnt</comment>
      </reg>
      <reg name="ce_pka_start" protect="rw">
        <comment>start ce pka</comment>
        <bits access="rc" name="rf_ce_pka_start" pos="0" rst="0x0">
          <comment>start ce pka</comment>
        </bits>
      </reg>
      <reg name="ce_pka_clear" protect="rw">
        <comment>clear ce pka</comment>
        <bits access="rc" name="rf_ce_pka_clear" pos="0" rst="0x0">
          <comment>reset ce pka status</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_pka_rng_force_ssb_bit" protect="rw">
        <comment>ce_pka_rng_force_ssb_bit</comment>
        <bits access="rw" name="rf_ce_pka_rng_force_ssb_bit" pos="0" rst="0x1">
          <comment>force the prime ssb bit is 1</comment>
        </bits>
      </reg>
      <reg name="ce_pka_ctrl_operate_bit" protect="rw">
        <comment>ce_pka_ctrl_operate_bit</comment>
        <bits access="rw" name="ce_pka_store_limit_cfg_disable" pos="0" rst="0x0">
          <comment>this bit control the store inst,
1:when the bit set 1, then the store data from pka ram to ddr don't have any limit;
when the bit set 0, then the store inst need judge the buf can store out or not, the store register index can config through the pka load_rng inst;</comment>
        </bits>
      </reg>
      <reg name="ce_pka_efs_debug_status" protect="rw">
        <comment>pka write efuse and read efuse work status</comment>
        <bits access="r" name="rf_pka_access_efuse_flag" pos="23:20" rst="0x0">
          <comment>bit[23]:reserved                                           bit[22]:pka read efuse cmd vaild;         bit[21]:pka write efuse cmd vaild;        bit[20]:used to control pka load FSM state jump;</comment>
        </bits>
        <bits access="r" name="rf_pka_and_huk_access_efuse_status" pos="19:16" rst="0x0">
          <comment>bit[19]:indicates pka would read efuse  when the huk is reading or writing  efuse;             bit[18]:indicates pka would write efuse  when the huk is reading or writing  efuse;            bit[17]:indicates huk would read efuse  when the  pka is reading or writing  efuse;             bit[16]:indicates huk would write efuse  when the pka is reading or writing  efuse;</comment>
        </bits>
        <bits access="r" name="rf_pka_read_efuse_count" pos="15:8" rst="0x0">
          <comment>depend on read pka private key length,ce top starts to count,when this count</comment>
        </bits>
        <bits access="r" name="rf_pka_write_efuse_count" pos="7:0" rst="0x0">
          <comment>depend on write pka private key length,ce top starts to count</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04004000" name="CE_SEC" type="CE_SEC"/>
  </archive>
  <archive relative="ce_pub.xml">
    <module category="System" name="CE_PUB">
      <reg name="ce_debug_dma_status" protect="rw">
        <comment>axi bus status and dma work state status</comment>
        <bits access="r" name="rf_ce_wready" pos="31" rst="0x0">
          <comment>axi write data channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_awready" pos="30" rst="0x0">
          <comment>axi write address channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_arready" pos="29" rst="0x0">
          <comment>axi read address channel ready</comment>
        </bits>
        <bits access="r" name="rf_ce_busy" pos="28" rst="0x0">
          <comment>dma is working,and CPU can't access ce registers except ce_clear register.</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_dst_state" pos="26:22" rst="0x0">
          <comment>dma write port state:                                         4'd0: idle                                                           4'd1: write burst calculate                                   4'd2: write burst calculate data number              4'd3: write burst wait enough data                    4'd4: write burst start                                        4'd5: write burst execute                                   4'd6: write burst wait burst end                         4'd7: write burst end</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_src_state" pos="21:17" rst="0x0">
          <comment>dma read port state:                                         4'd0: idle                                                           4'd1: read burst wait enough buffer space        4'd2: read burst wait one cycle                         4'd3: read burst start                                        4'd4: read burst execute                                   4'd5: read burst wait burst end                         4'd6: read burst done</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_cmd_fifo_non_empty" pos="16" rst="0x0">
          <comment>fde cmd fifo is non-empty</comment>
        </bits>
        <bits access="r" name="rf_ce_cmd_fifo_non_empty" pos="15" rst="0x0">
          <comment>cmd fifo is non-empty</comment>
        </bits>
        <bits access="r" name="rf_ce_int_raw_status_vld" pos="14" rst="0x0">
          <comment>interrupt raw status is valid</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_err" pos="13" rst="0x0">
          <comment>ce in error status</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_main_write_state" pos="12:8" rst="0x0">
          <comment>dma control main write port state:                     5'd0: idle                                                           5'd1: STD hash start                                            5'd2: STD start                                                  5'd3: STD wait done                                          5'd4: STD send done                                        5'd5: STD next state judgement                        5'd6: STD pause                                               5'd7: STD done                                                 5'd8: LLIST check node buffer status               5'd9: LLIST load node                                       5'd10: LLIST load node wait                               5'd11: LLIST load node update parameter       5'd12: LLIST load node done                            5'd13: LLIST hash start                                     5'd14: LLIST start                                             5'd15: LLIST wait done                                     5'd16: LLIST send done                                    5'd17: LLIST next start judgement                    5'd18: LLIST pause                                           5'd19: LLIST done</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_pka_main_read_state" pos="7:5" rst="0x0">
          <comment>3'd0: idle                                                      3'd1: pka read instruction start                                                                         3'd2: pka load start                                                                                                    3'd3: pka wait done                                                                                                   3'd4: pka send done                                                                                                 3'd5: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_main_read_state" pos="4:0" rst="0x0">
          <comment>dma control main read port state:                     5'd0: idle                                                                                                                     5'd1: read key/hmac key/aad start                                                            5'd2: wait read key/hmac key/aad done                                                5'd3: read key/hmac key/aad, send done                                             5'd4: read key/hmac key/aad done                                                          5'd5: STD read start                                                                                                5'd6: STD wait done                                                                                           5'd7: STD send done                                                                                        5'd8: STD done,then judgement                                                               5'd9: STD pause                                                                                                     5'd10: STD done                                                                                                     5'd11: LLIST read list                                                                                                  5'd12: LLIST read list wait done                                                                 5'd13: LLIST read list send done                                                              5'd14: LLIST read list done                                                                            5'd15: LLIST read node                                                                                        5'd16: LLIST read node wait                                                                               5'd17: LLIST read node done                                                                      5'd18: LLIST node execution                                                                                    5'd19: LLIST node execution, wait done                                                   5'd20: LLIST node execution, send done                                             5'd21: LLIST node execution done                                                               5'd22: LLIST judge next state                                                                                    5'd23: LLIST pause                                                                                         5'd24: LLIST done                                                                                                        5'd25: read session key start                                                                                  5'd26: read session key done</comment>
        </bits>
      </reg>
      <reg name="ce_debug_aes_status" protect="rw">
        <comment>aes module state</comment>
        <bits access="r" name="rf_ce_fde_rdma_data_status" pos="28:27" rst="0x0">
          <comment>rdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_wdma_data_status" pos="26:25" rst="0x0">
          <comment>wdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_dma_main_read_state" pos="24:20" rst="0x0">
          <comment>dma control main read port state:                     5'd0: idle                                                                                                                     5'd1: read key/hmac key/aad start                                                            5'd2: wait read key/hmac key/aad done                                                5'd3: read key/hmac key/aad, send done                                             5'd4: read key/hmac key/aad done                                                          5'd5: STD read start                                                                                                5'd6: STD wait done                                                                                           5'd7: STD send done                                                                                        5'd8: STD done,then judgement                                                               5'd9: STD pause                                                                                                     5'd10: STD done                                                                                                     5'd11: LLIST read list                                                                                                  5'd12: LLIST read list wait done                                                                 5'd13: LLIST read list send done                                                              5'd14: LLIST read list done                                                                            5'd15: LLIST read node                                                                                        5'd16: LLIST read node wait                                                                               5'd17: LLIST read node done                                                                      5'd18: LLIST node execution                                                                                    5'd19: LLIST node execution, wait done                                                   5'd20: LLIST node execution, send done                                             5'd21: LLIST node execution done                                                               5'd22: LLIST judge next state                                                                                    5'd23: LLIST pause                                                                                         5'd24: LLIST done                                                                                                        5'd25: read session key start                                                                                  5'd26: read session key done</comment>
        </bits>
        <bits access="r" name="rf_ce_rdma_data_status" pos="17:15" rst="0x0">
          <comment>rdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_sm4_status" pos="14:12" rst="0x0">
          <comment>sm4 state:                                                         3'd0: idle                                                                 3'd1: generate key                                            3'd2: round start                                                3'd3: rounding                                                   3'd4: xts generate key                                       3'd5: xts round start                                          3'd6: xts rounding                                             3'd7: done</comment>
        </bits>
        <bits access="r" name="rf_ce_wdma_data_status" pos="11:10" rst="0x0">
          <comment>wdma data status:                                             2'd0: idle                                                           2'd1: read start                                                 2'd2: read wait                                                  2'd3: read finish</comment>
        </bits>
        <bits access="r" name="rf_ce_aes_status" pos="7:0" rst="0x0">
          <comment>[3:0]: aes read counter;                                    [7:4]: aes work state                                          4'd0: idle                                                           4'd1: key expand                                               4'd2: xts encrypto tweek                                    4'd3: enc/decrpto select                                    4'd4: wait                                                                 4'd5: one block done                                        4'd6: xts encrypto tweek post                            4'd7: xts encrypto tweek pre   '                          4'd8: zero encrypto                                           4'd9: aad ghash                                                4'd10: length ghash                                          4'd11: gcm wait</comment>
        </bits>
      </reg>
      <reg name="ce_debug_tdes_status" protect="rw">
        <comment>tdes module state</comment>
        <bits access="r" name="rf_ce_tdes_status" pos="29:25" rst="0x0">
          <comment>tdes module status:                                           [3:0]: des run cycle counter
[4]: des key check error</comment>
        </bits>
        <bits access="r" name="rf_ce_dma_wvalid_state" pos="24:21" rst="0x0">
          <comment>generate wvalid state:                                       4'd0: idle                                                           4'd1: wait enough data                               4'd2: generate wvalid                                        4'd3: wait enough data when bursting               4'd4: wait wready for next burst data</comment>
        </bits>
        <bits access="r" name="rf_ce_efuse_access_status" pos="20:16" rst="0x0">
          <comment>efuse access status:                                         5'd0: idle                                                           5'd1: read selec between hmac and symmetric                                         5'd2: trng write start                                        5'd3: hmac session key read start                              5'd4: trng write                                                  5'd5: hmac read                                             5'd6: symmetric key1 read start                      5'd7: symmetric key2 read start                      5'd8: symmetric key1 read                              5'd9: symmetric key2 read                              5'd10: done                                                  5'd11: hmac session key read                             5'd12: read huk  after write err                                        5'd13: trng write next                                                   5'd15: iram key done                                                   5'd16: pka non-symmetric key read start                      5'd17: pka non-symmetric key read                      5'd18: pka non-symmetric key write start                             5'd19: pka non-symmetric key write           5'd20: pka non-symmetric key write next   5'd21: ce read non-symmetric key after write err</comment>
        </bits>
        <bits access="r" name="rf_ce_pka_dma_main_write_state" pos="15:13" rst="0x0">
          <comment>3'd0: idle                                                           3'd1: pka store start                                         3'd2: pka wait done                                          3'd3: pka send done                                         3'd4: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_dma_main_write_state" pos="12:8" rst="0x0">
          <comment>dma control main write port state:                     5'd0: idle                                                           5'd1: STD hash start                                            5'd2: STD start                                                  5'd3: STD wait done                                          5'd4: STD send done                                        5'd5: STD next state judgement                        5'd6: STD pause                                               5'd7: STD done                                                 5'd8: LLIST check node buffer status               5'd9: LLIST load node                                       5'd10: LLIST load node wait                               5'd11: LLIST load node update parameter       5'd12: LLIST load node done                            5'd13: LLIST hash start                                     5'd14: LLIST start                                             5'd15: LLIST wait done                                     5'd16: LLIST send done                                    5'd17: LLIST next start judgement                    5'd18: LLIST pause                                           5'd19: LLIST done                                              5'd20: pka store start                                        5'd21: pka wait done                                         5'd22: pka send done                                       5'd23: pka jump judgement</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_aes_status" pos="7:0" rst="0x0">
          <comment>[3:0]: aes read counter;                                    [7:4]: aes work state                                          4'd0: idle                                                           4'd1: key expand                                               4'd2: xts encrypto tweek                                    4'd3: enc/decrpto select                                    4'd4: wait                                                                 4'd5: one block done                                        4'd6: xts encrypto tweek post                            4'd7: xts encrypto tweek pre   '                          4'd8: zero encrypto                                           4'd9: aad ghash                                                4'd10: length ghash                                          4'd11: gcm wait</comment>
        </bits>
      </reg>
      <reg name="ce_debug_hash_status0" protect="rw">
        <comment>hash module state 0</comment>
      </reg>
      <reg name="ce_debug_hash_status1" protect="rw">
        <comment>hash module state 1</comment>
        <bits access="r" name="rf_ce_hash_status1" pos="9:0" rst="0x0">
          <comment>hash module status:                                          [2:0]: hash state                                            3'd0: idle          3'd1: data request                        3'd2: no-hmac  3'd3: hmac key                           3'd4: first hmac message                                  3'd5: second hmac message                              3'd6: digest out                                                 [8:3]: hash run cycle</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_clk_en" protect="rw">
        <comment>ce module clock enable</comment>
        <bits access="rw" name="rf_ce_fde_aes_clk_en" pos="28" rst="0x0">
          <comment>force fde aes clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_pub_clk_en" pos="25" rst="0x0">
          <comment>force pub rng autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_pub_ck_en" pos="24" rst="0x0">
          <comment>pub trng clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_clk_en" pos="23" rst="0x0">
          <comment>force chacha engine clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_poly_clk_en" pos="22" rst="0x0">
          <comment>force poly engine clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_clk_en" pos="21" rst="0x0">
          <comment>force rng autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_clk_en" pos="20" rst="0x0">
          <comment>force aes key expan autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_axi_clk_en" pos="18" rst="0x0">
          <comment>force dma axi autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_ctrl_clk_en" pos="17" rst="0x0">
          <comment>force dma ctrl autogate  clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_apb_rf_clk_en" pos="16" rst="0x0">
          <comment>force apb regbank autogate clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_ck_en" pos="9" rst="0x0">
          <comment>simon speck clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_pka_ck_en" pos="8" rst="0x0">
          <comment>pka clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacah_poly_ck_en" pos="7" rst="0x0">
          <comment>chacha poly clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_ck_en" pos="6" rst="0x0">
          <comment>sm4 clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_ck_en" pos="5" rst="0x0">
          <comment>trng clock enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_des_ck_en" pos="4" rst="0x0">
          <comment>des clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_ck_en" pos="3" rst="0x0">
          <comment>hash clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_ck_en" pos="2" rst="0x0">
          <comment>fde aes clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_ck_en" pos="1" rst="0x0">
          <comment>aes clock  enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_ck_en" pos="0" rst="0x0">
          <comment>dma_main clock enable</comment>
        </bits>
      </reg>
      <reg name="ce_int_en" protect="rw">
        <comment>ce interrupt enable</comment>
        <bits access="rw" name="rf_ce_fde_en_len_err_int" pos="21" rst="0x0">
          <comment>enable src/dst length error int</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_en_cmd_done_int" pos="20" rst="0x0">
          <comment>enable one command done int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_len_err_int" pos="17" rst="0x0">
          <comment>enable src/dst length error int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_cmd_done_int" pos="16" rst="0x0">
          <comment>enable one command done int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_rng_int" pos="7" rst="0x0">
          <comment>enable rng/trng int</comment>
        </bits>
        <bits access="rw" name="rf_ce_en_tdes_key_err_int" pos="5" rst="0x0">
          <comment>enable tdes key check error int</comment>
        </bits>
      </reg>
      <reg name="ce_int_status" protect="rw">
        <comment>ce interrupt status</comment>
        <bits access="r" name="rf_ce_fde_en_len_err_status" pos="21" rst="0x0">
          <comment>src/dst length error int status</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_en_cmd_done_status" pos="20" rst="0x0">
          <comment>one command done int status,</comment>
        </bits>
        <bits access="r" name="rf_ce_en_len_err_status" pos="17" rst="0x0">
          <comment>src/dst length error int status</comment>
        </bits>
        <bits access="r" name="rf_ce_en_cmd_done_status" pos="16" rst="0x0">
          <comment>one command done int status,</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_int_status" pos="7" rst="0x0">
          <comment>ce rng/trng int status</comment>
        </bits>
        <bits access="r" name="rf_ce_tdes_key_err_int_status" pos="5" rst="0x0">
          <comment>ce tdes key check error int status</comment>
        </bits>
      </reg>
      <reg name="ce_int_clear" protect="rw">
        <comment>ce interrupt clear</comment>
        <bits access="r" name="rf_ce_fde_en_len_err_status" pos="21" rst="0x0">
          <comment>src/dst length error int status</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_en_cmd_done_status" pos="20" rst="0x0">
          <comment>one command done int status,</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_len_err_int" pos="17" rst="0x0">
          <comment>clear error int status</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_cmd_done_int" pos="16" rst="0x0">
          <comment>clear one command done int status,</comment>
        </bits>
        <bits access="rc" name="rf_ce_clear_tdes_key_err_int" pos="5" rst="0x0">
          <comment>clear tdes key check error int status</comment>
        </bits>
      </reg>
      <reg name="ce_start" protect="rw">
        <comment>start ce</comment>
        <bits access="rc" name="rf_ce_start" pos="0" rst="0x0">
          <comment>start ce</comment>
        </bits>
      </reg>
      <reg name="ce_clear" protect="rw">
        <comment>clear ce</comment>
        <bits access="rc" name="rf_ce_clear" pos="0" rst="0x0">
          <comment>reset ce status</comment>
        </bits>
      </reg>
      <reg name="ce_aes_mode" protect="rw">
        <comment>aes work mode cfg</comment>
        <bits access="rw" name="rf_ce_aes_key_update_n" pos="15" rst="0x0">
          <comment>1: dont update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_xts_iv_rotation" pos="14" rst="0x1">
          <comment>0: rtl rotation, 1: no-rotation</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_key_len_sel" pos="13:12" rst="0x0">
          <comment>00: key 128bits,01:192bits,10,11:256bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_work_mode" pos="11:8" rst="0x0">
          <comment>0000:ECB,0001:CBC,0010:CTR,0011:XTS,0100:CMAC,0101:GCM,0110:GMAC,0111:CCM,1000:CBCMAC,1001:CFB,1010:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_mac_ctr_inc_mode" pos="6:5" rst="0x0">
          <comment>aes mac ctr inc mode:  00: normal mode; 01: low 64bit is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_en" pos="0" rst="0x0">
          <comment>aes module enable</comment>
        </bits>
      </reg>
      <reg name="ce_tdes_mode" protect="rw">
        <comment>tdes work mode cfg</comment>
        <bits access="rw" name="rf_ce_tdes_key_evenodd_check_on" pos="13" rst="0x0">
          <comment>0: disable,  1: enable even/odd check</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_key_even_sel" pos="12" rst="0x0">
          <comment>0:odd check,1:even check</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_work_mode" pos="9:8" rst="0x0">
          <comment>00:ECB,01:CBC</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_tdes_en" pos="0" rst="0x0">
          <comment>tdes module enable</comment>
        </bits>
      </reg>
      <reg name="ce_hash_mode" protect="rw">
        <comment>hash work mode cfg</comment>
        <bits access="rw" name="rf_hash_sha3_shake_out_len" pos="23:16" rst="0x0">
          <comment>sha3 shake out length</comment>
        </bits>
        <bits access="rw" name="rf_hash_hmac_pad_sel" pos="13:12" rst="0x0">
          <comment>00: normal hash; 01: ipad ;10: opad; 11: reserved</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_mode" pos="8:4" rst="0x0">
          <comment>hash work module,
5d0: Doesnt work
5d1: MD5
5d2: SHA-1 mode
5d3: SHA-224 mode
5d4: SHA-256 mode
5d5: SHA-384 mode
5d6: SHA-512 mode
5d7: SHA-512/224 mode
5d8: SHA-512/256 mode
5d9: SM3 mode
5d10: SHA3-224
5d11: SHA3-256
5d12: SHA3-384
5d13: SHA3-512
5d14: SHA3-SHAKE128
5d15: SHA3-SHAKE256</comment>
        </bits>
        <bits access="rw" name="rf_ce_hash_en" pos="0" rst="0x0">
          <comment>hash module enable</comment>
        </bits>
      </reg>
      <reg name="ce_chacha_poly_mode" protect="rw">
        <comment>chacha poly work mode cfg</comment>
        <bits access="rw" name="rf_ce_chacha_poly_mode" pos="9:8" rst="0x0">
          <comment>00:chacha20 ; 01:poly1305;
10:AEAD_CHACHA20_POLY1305</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_poly_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encrypt,1:decrypt</comment>
        </bits>
        <bits access="rw" name="rf_ce_chacha_poly_en" pos="0" rst="0x0">
          <comment>chacha poly module enable</comment>
        </bits>
      </reg>
      <reg name="ce_simon_speck_mode" protect="rw">
        <comment>simon speck work mode cfg</comment>
        <bits access="rw" name="rf_ce_simon_speck_key_update_n" pos="15" rst="0x0">
          <comment>1: dont update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_key_len_sel" pos="14:13" rst="0x0">
          <comment>00: key 128bits,01:192bits,10:256bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_work_mode" pos="11:9" rst="0x0">
          <comment>000:ECB,001:CBC,010:CTR,100:CFB,101:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_sel" pos="8" rst="0x0">
          <comment>0:speck; 1:simon</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encrypt,1:decrypt</comment>
        </bits>
        <bits access="rw" name="rf_ce_simon_speck_en" pos="0" rst="0x0">
          <comment>chacha poly module enable</comment>
        </bits>
      </reg>
      <reg name="ce_cfg" protect="rw">
        <comment>ce basic configure</comment>
        <bits access="rw" name="rf_ce_src_word_switch" pos="23" rst="0x0">
          <comment>switch source high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_word_switch" pos="22" rst="0x0">
          <comment>switch destination high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_src_byte_switch" pos="21" rst="0x1">
          <comment>source data switch of one word</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_byte_switch" pos="20" rst="0x0">
          <comment>destination data switch of one word</comment>
        </bits>
        <bits access="r" name="rf_ce_key_hdcp_en" pos="18" rst="0x0">
          <comment>0:disable hdcp mode, 1: enable hdcp mode</comment>
        </bits>
        <bits access="r" name="rf_ce_list_update_iv_sec_cnt" pos="17" rst="0x0">
          <comment>list update iv/sec/cnt flag</comment>
        </bits>
        <bits access="r" name="rf_ce_list_data_end_flag" pos="16" rst="0x0">
          <comment>data end in link list mode</comment>
        </bits>
        <bits access="r" name="rf_ce_list_end_flag" pos="15" rst="0x0">
          <comment>list end flag</comment>
        </bits>
        <bits access="r" name="rf_ce_list_aad_flag" pos="14" rst="0x0">
          <comment>0: isn't aad list 1: is aad list</comment>
        </bits>
        <bits access="r" name="rf_ce_list_aad_end_flag" pos="13" rst="0x0">
          <comment>0: aad no-end list 1: aad end list</comment>
        </bits>
        <bits access="rw" name="rf_ce_do_wait_bdone" pos="12" rst="0x1">
          <comment>wait axi B channel bready</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_iram_flag" pos="11" rst="0x0">
          <comment>0:normal mode, 1: iram key or secure ddr key</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_session_key_flag" pos="10" rst="0x0">
          <comment>0: normal mode, 1: aes/sm4 key from session key</comment>
        </bits>
        <bits access="rw" name="rf_ce_key_in_ddr_flag" pos="8" rst="0x0">
          <comment>1: all crypto key in ddr/iram; 0: from registers</comment>
        </bits>
        <bits access="rw" name="rf_ce_dma_bypass" pos="7" rst="0x0">
          <comment>0:normal mode, 1: bypass ce</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_aad_flag" pos="6" rst="0x0">
          <comment>0: std flag 1: std aad flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_aad_end_flag" pos="5" rst="0x0">
          <comment>0: std aad no-end flag 1: std aad end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_std_mode_end_flag" pos="4" rst="0x0">
          <comment>std end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_cmd_ioc" pos="3" rst="0x0">
          <comment>0: enable cmd int output: 1: don't output int</comment>
        </bits>
        <bits access="rw" name="rf_ce_dont_dump_ddr" pos="2" rst="0x0">
          <comment>0: dump from ddr; 1: don't dump</comment>
        </bits>
        <bits access="rw" name="rf_ce_dont_rcv_ddr" pos="1" rst="0x0">
          <comment>0: rcv from ddr; 1: don't rcv</comment>
        </bits>
        <bits access="rw" name="rf_ce_link_mode_flag" pos="0" rst="0x0">
          <comment>0:std mode, 1: link mode</comment>
        </bits>
      </reg>
      <reg name="ce_src_frag_length" protect="rw">
        <comment>dma read port node data length</comment>
        <bits access="rw" name="rf_ce_src_addr_hi" pos="27:24" rst="0x0">
          <comment>source address high 4bits; or aes mac aad address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_src_frag_len" pos="23:0" rst="0x0">
          <comment>source fragment length of each node;  or aes mac aad length</comment>
        </bits>
      </reg>
      <reg name="ce_dst_frag_length" protect="rw">
        <comment>dma write port node data length</comment>
        <bits access="rw" name="rf_ce_dst_addr_hi" pos="27:24" rst="0x0">
          <comment>destination address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_frag_len" pos="23:0" rst="0x0">
          <comment>destination fragment length of each node</comment>
        </bits>
      </reg>
      <reg name="ce_src_addr" protect="rw">
        <comment>dma source address</comment>
      </reg>
      <reg name="ce_dst_addr" protect="rw">
        <comment>dma destination address</comment>
      </reg>
      <reg name="ce_list_length" protect="rw">
        <comment>dma one length</comment>
        <bits access="rw" name="rf_ce_list_ptr_hi" pos="19:16" rst="0x0">
          <comment>ce_list_ptr high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_list_len" pos="11:0" rst="0x0">
          <comment>first list length,support max 256 nodes</comment>
        </bits>
      </reg>
      <reg name="ce_list_ptr" protect="rw">
        <comment>dma list pointer</comment>
      </reg>
      <reg name="ce_aes_tdes_rsa_key_length" protect="rw">
        <comment>aes tdes rsa key length</comment>
        <bits access="rw" name="rf_ce_aes_tdes_rsa_key_addr_hi" pos="27:24" rst="0x0">
          <comment>aes hmac key address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_tdes_rsa_key_len" pos="23:0" rst="0x0">
          <comment>aes hmac key length</comment>
        </bits>
      </reg>
      <reg name="ce_aes_tdes_rsa_key_address" protect="rw">
        <comment>aes tdes rsa key address</comment>
      </reg>
      <reg name="ce_aes_tag_length" protect="rw">
        <comment>aes tag length</comment>
        <bits access="rw" name="rf_ce_aes_tag_addr_hi" pos="11:8" rst="0x0">
          <comment>aes tag address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_aes_tag_len" pos="7:0" rst="0x10">
          <comment>aes tag length</comment>
        </bits>
      </reg>
      <reg name="ce_aes_tag_address" protect="rw">
        <comment>aes tag address</comment>
      </reg>
      <reg name="ce_iv_sec_cnt0" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt1" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt2" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_iv_sec_cnt3" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_aes_des_key10" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key11" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key12" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key13" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key14" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key15" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key16" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key17" protect="rw">
        <comment>key1</comment>
      </reg>
      <reg name="ce_aes_des_key20" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key21" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key22" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key23" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key24" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key25" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key26" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_aes_des_key27" protect="rw">
        <comment>key2</comment>
      </reg>
      <reg name="ce_sm4_mode" protect="rw">
        <comment>sm4 work mode cfg</comment>
        <bits access="rw" name="rf_ce_sm4_key_update_n" pos="12" rst="0x0">
          <comment>1: dont update key, 0: update key</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_xts_inv_rotation" pos="11" rst="0x1">
          <comment>0: rtl rotation, 1: no-rotation</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_work_mode" pos="10:8" rst="0x0">
          <comment>000:ECB,001:CBC,010:CTR,011:XTS,100:CFB,101:OFB</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_sm4_en" pos="0" rst="0x0">
          <comment>sm4 module enable</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_ip_version" protect="rw">
        <comment>IP version</comment>
        <bits access="r" name="rf_ce_ip_version_hi" pos="31:4" rst="0x40">
          <comment>r4</comment>
        </bits>
        <bits access="rw" name="rf_ce_ip_version_lo" pos="3:0" rst="0x0">
          <comment>px</comment>
        </bits>
      </reg>
      <hole size="1056"/>
      <reg name="ce_pf_calc" protect="rw">
        <comment>ce performace counter</comment>
      </reg>
      <reg name="ce_user_flag" protect="rw">
        <comment>ce use flag</comment>
        <bits access="r" name="rf_ce_pub_priority_vld" pos="8" rst="0x0">
          <comment>when the siganl is high ,then flag the pub aes/sm4/hash is catch the cmd from the pub cmd buf or the pub is working</comment>
        </bits>
        <bits access="r" name="rf_ce_sec_priority_vld" pos="4" rst="0x0">
          <comment>when the siganl is high ,then flag the sec aes/sm4/hash is catch the cmd from the sec cmd buf or the sec is working</comment>
        </bits>
        <bits access="rw" name="rf_ce_use_flag" pos="0" rst="0x0">
          <comment>ce sec or pub use the ce aes/sm4/hash cicpher module</comment>
        </bits>
      </reg>
      <reg name="ce_axi_axcache" protect="rw">
        <comment>axi bus cache</comment>
        <bits access="rw" name="rf_ce_src_outstanding_num" pos="15:12" rst="0x7">
          <comment>axi read port outstanding number</comment>
        </bits>
        <bits access="rw" name="rf_ce_dst_outstanding_num" pos="11:8" rst="0x7">
          <comment>axi write port outstanding number</comment>
        </bits>
        <bits access="rw" name="rf_ce_axi_awcache" pos="7:4" rst="0x0">
          <comment>axi bus wcache</comment>
        </bits>
        <bits access="rw" name="rf_ce_axi_arcache" pos="3:0" rst="0x0">
          <comment>axi bus rcache</comment>
        </bits>
      </reg>
      <reg name="ce_cmd_stop_ctrl" protect="rw">
        <comment>cmd stop ctrl</comment>
        <bits access="rc" name="rf_ce_fde_cmd_stop_clear" pos="22" rst="0x0">
          <comment>fde to restart</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_cmd_stop_status" pos="21" rst="0x0">
          <comment>1: fde stop command is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_cmd_stop" pos="20" rst="0x0">
          <comment>0:fde  to execute next cmd; 1: fde finish current cmd,then stop</comment>
        </bits>
        <bits access="rc" name="rf_ce_cmd_stop_clear" pos="18" rst="0x0">
          <comment>to restart</comment>
        </bits>
        <bits access="r" name="rf_ce_cmd_stop_status" pos="17" rst="0x0">
          <comment>1: stop command is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_cmd_stop" pos="16" rst="0x0">
          <comment>0: to execute next cmd; 1: finish current cmd,then stop</comment>
        </bits>
      </reg>
      <reg name="ce_axi_protect_sel" protect="rw">
        <comment>axi prot sel</comment>
        <bits access="rw" name="fde_dummy" pos="15:13" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="fde_axi_prot_sel_wtxt" pos="12" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="fde_axi_prot_sel_rtxt" pos="11" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="fde_axi_prot_sel_rlist" pos="10" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="fde_axi_prot_sel_rkey" pos="9" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="fde_axi_prot_sel_en" pos="8" rst="0x0">
          <comment>0: disable fde side sel; 1: enable fde side axi sel</comment>
        </bits>
        <bits access="rw" name="pub_dummy" pos="7:5" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="pub_axi_prot_sel_wtxt" pos="4" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pub_axi_prot_sel_rtxt" pos="3" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pub_axi_prot_sel_rlist" pos="2" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pub_axi_prot_sel_rkey" pos="1" rst="0x0">
          <comment>0: non_prot; 1: prot;</comment>
        </bits>
        <bits access="rw" name="pub_axi_prot_sel_en" pos="0" rst="0x0">
          <comment>0: disable pub side sel; 1: enable pub side axi sel</comment>
        </bits>
      </reg>
      <reg name="ce_pf_calc_high" protect="rw">
        <comment>ce performace counter high 32 bit</comment>
      </reg>
      <hole size="1216"/>
      <reg name="ce_rng_en" protect="rw">
        <comment>RNG module enable RNG module enable</comment>
        <bits access="rw" name="rf_ce_rng_data_mux_enable" pos="18" rst="0x0">
          <comment>if the signal is high,then the rng data  come from cpu.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_mux_ring_enable" pos="17" rst="0x0">
          <comment>if the signal is high,then the osc rings sel signal come from rf_rng_src_sel_enable.</comment>
        </bits>
        <bits access="rw" name="rf_rng_auto_enable" pos="16" rst="0x1">
          <comment>if the signal is high,then the osc rings is auto choose to work</comment>
        </bits>
        <bits access="rw" name="rf_rng_src_sel_enable" pos="15:8" rst="0xff">
          <comment>the signal control which osc ring is work,when the least bit is high,then the first one osc ring is choose as the entropy.</comment>
        </bits>
        <bits access="rw" name="rf_ce_trng_ptest_mode_en" pos="4" rst="0x0">
          <comment>trng source test enable</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_rst_from_cpu" pos="3" rst="0x0">
          <comment>the rst signal to the exotic trng module</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_src_from_cpu_enable" pos="2" rst="0x0">
          <comment>the signal can change when the trng is work ,which can control the trng start or stop by cpu.</comment>
        </bits>
        <bits access="rc" name="rf_ce_trng_src_en" pos="1" rst="0x0">
          <comment>trng source enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_en" pos="0" rst="0x0">
          <comment>RNG module enable bit:
1:enbale RNG module to generate random number when auto mode is not enable</comment>
        </bits>
      </reg>
      <reg name="ce_rng_config" protect="rw">
        <comment>RNG module config RNG module config</comment>
        <bits access="rw" name="number_of_samples_threshold" pos="31:20" rst="0xfff">
          <comment>Threshold bit value for random data , indicates that the cycle of the src_en is high, the max value is 12'hFFF.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_ptest_data_in" pos="16" rst="0x0">
          <comment>when the data_in is 0,the test result should be 1,and the data_in is 1,the test result should be 0;</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_data_valid_threshold" pos="11:8" rst="0x3">
          <comment>Threshold value for rng_data_valid, indicates that when rng_data_valid high, there area at least number of rng_data_valid_threshold words in SRAMthe max value is 4'hf.</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_exotic_fault_rst_sel" pos="7" rst="0x0">
          <comment>ce_rng_exotic_fault_rst_sel:                  1'b0:the rst generated by the fault signal,                 1'b1:don't generated the rst signal,the rst signal come from the cpu</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_source_sel" pos="6:5" rst="0x3">
          <comment>local RNG entropty source select</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_data_len_sel" pos="4" rst="0x0">
          <comment>when it's 1,the the post process module need data bitwith is 440bit,else is 256bit</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_trng_sel" pos="3" rst="0x0">
          <comment>the signal select the trng data come from exotic or local trng module 1:exotic 0:local</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_ring_sel" pos="2:0" rst="0x3">
          <comment>select entropy source,the range is 0x0 to 0x7</comment>
        </bits>
      </reg>
      <reg name="ce_rng_data" protect="rw">
        <comment>RNG data for cpu to read RNG data for cpu to read</comment>
      </reg>
      <reg name="ce_rng_sample_period" protect="rw">
        <comment>time interval between two samples time interval between two samples</comment>
        <bits access="rw" name="rf_ce_rng_first_sample_en" pos="31" rst="0x0">
          <comment>enable first level sample</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_first_sample_period" pos="30:16" rst="0x0">
          <comment>sample period between two samples, the value is from 0 to 255</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_second_sample_period" pos="15:0" rst="0x0">
          <comment>sample period between two samples, the value is from 0 to 255</comment>
        </bits>
      </reg>
      <reg name="ce_rng_post_process_en" protect="rw">
        <comment>post process functions select post process functions select</comment>
        <bits access="rw" name="rf_ce_rng_post_eight_en" pos="7" rst="0x0">
          <comment>when it's 1,the the PRNG data  xor with trng data</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_seven_en" pos="6" rst="0x0">
          <comment>when it's 1,the the final post process module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_six_en" pos="5" rst="0x0">
          <comment>when it's 1,the the xor process module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_five_en" pos="4" rst="0x0">
          <comment>when it's 1,the the cycle_code module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_four_en" pos="3" rst="0x1">
          <comment>when it's 1,the the lfsr module is enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_three_en" pos="2" rst="0x0"/>
        <bits access="rw" name="rf_ce_rng_post_second_en" pos="1" rst="0x0">
          <comment>post data path 1 enable</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_post_first_en" pos="0" rst="0x0">
          <comment>post data path 0 enable</comment>
        </bits>
      </reg>
      <reg name="ce_rng_work_status" protect="rw">
        <comment>rng work status rng work status</comment>
        <bits access="r" name="rf_ce_rng_rsa_key_gen_rand_num" pos="31:16" rst="0x0">
          <comment>rand data number when keygen done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_process" pos="15:14" rst="0x0">
          <comment>2'b01:Instantiate ;                                                     2'b10:Reseed ;                                                       2'b11:Genarate.</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_pattern_req" pos="13" rst="0x0">
          <comment>when it's 1,cpu can send next 64bit pattern</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_fail" pos="12" rst="0x0">
          <comment>when it's 1,the drbg KAT test fail</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_done" pos="11" rst="0x0">
          <comment>DRBG KAT test done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_es_test_fail" pos="10" rst="0x0">
          <comment>when it's 1,the start-up/on-demand test fail(1024 sample)</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_es_test_done" pos="9" rst="0x0">
          <comment>start-up/on-demand test done</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_test_result" pos="8" rst="0x0">
          <comment>the result of test mode</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_result_vld" pos="7" rst="0x0">
          <comment>when it's 1,indicate that the drbg test result data in 0x260 register is valid (cpu can read to check)</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_drbg_test_data_type" pos="6:5" rst="0x0">
          <comment>2'b01: C [439:0] ;                                                    2'b10: V[439:0] ;                                                        2'b11: reseed_counter[31:0].                                  Corresponds to the data of each process in [15:14] .</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_fifo_empty" pos="4" rst="0x1">
          <comment>the fifo status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_error_fault" pos="3" rst="0x0">
          <comment>the exotic rng module status</comment>
        </bits>
        <bits access="r" name="rf_rng_rsa_pka_busy" pos="2" rst="0x0"/>
        <bits access="r" name="rf_ce_rng_data_valid" pos="1" rst="0x0">
          <comment>when high indicates that RNG module has generate 256 bits random data</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_auto_mode_ongoing" pos="0" rst="0x0">
          <comment>when high indicates that auto mode is ongoing, CPU can't access rng_data register</comment>
        </bits>
      </reg>
      <reg name="ce_rng_timeout_cnt" protect="rw">
        <comment>rng time out counter rng time out counter</comment>
      </reg>
      <reg name="ce_rng_int_en" protect="rw">
        <comment>rng interrupt enable rng interrupt enable</comment>
        <bits access="rw" name="rf_ce_rng_cont_htest_int_en" pos="5" rst="0x0">
          <comment>enable continuous health test interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_sram_short_int_en" pos="4" rst="0x0">
          <comment>enable sram short interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_timeout_int_en" pos="3" rst="0x0">
          <comment>enable timeout interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process2_int_en" pos="2" rst="0x0">
          <comment>enable process2 interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process1_int_en" pos="1" rst="0x0">
          <comment>enable process1 interrupt</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_process0_int_en" pos="0" rst="0x0">
          <comment>enable process0 interrupt</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sts" protect="rw">
        <comment>rng interrupt status rng interrupt status</comment>
        <bits access="r" name="rf_ce_rng_con_htest_int_sts" pos="5" rst="0x0">
          <comment>continuous health test interrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_sram_short_int_sts" pos="4" rst="0x0">
          <comment>sram_short_interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_timeout_int_sts" pos="3" rst="0x0">
          <comment>timeout interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process2_int_sts" pos="2" rst="0x0">
          <comment>process2 interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process1_int_sts" pos="1" rst="0x0">
          <comment>process1 interrrupt status</comment>
        </bits>
        <bits access="r" name="rf_ce_rng_process0_int_sts" pos="0" rst="0x0">
          <comment>process0 interrrupt status</comment>
        </bits>
      </reg>
      <reg name="ce_rng_int_clr" protect="rw">
        <comment>rng interrupt clear rng interrupt clear</comment>
        <bits access="rc" name="rf_ce_rng_clear_con_htest_int" pos="5" rst="0x0">
          <comment>clear continuous health test interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_sram_short_int" pos="4" rst="0x0">
          <comment>clear sram short  interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_timeout_int" pos="3" rst="0x0">
          <comment>clear timeout interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process2_int" pos="2" rst="0x0">
          <comment>clear process2 interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process1_int" pos="1" rst="0x0">
          <comment>clear process1 interrupt</comment>
        </bits>
        <bits access="rc" name="rf_ce_rng_clear_process0_int" pos="0" rst="0x0">
          <comment>clear process0 interrupt</comment>
        </bits>
      </reg>
      <reg name="ce_rng_mode" protect="rw">
        <comment>RNG module work mode RNG module work mode</comment>
        <bits access="rw" name="rf_ce_prng_mode" pos="8" rst="0x0">
          <comment>PRNG work mode:
1: Auto Seed update Mode
0: Mannual seed update Mode</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_mode" pos="1:0" rst="0x0">
          <comment>RNG module work mode:
10: PRNG mode
01: TRNG mode                                           0011: Mixed mode for TRNG</comment>
        </bits>
      </reg>
      <reg name="ce_prng_seed_update" protect="rw">
        <comment>PRNG mode seed update config PRNG mode seed update config</comment>
        <bits access="rc" name="rf_ce_prng_seed_update" pos="0" rst="0x0">
          <comment>When Write to 1, PRNG will update seed to PRNG_SEED_CONFIG register value</comment>
        </bits>
      </reg>
      <reg name="ce_prng_seed_config" protect="rw">
        <comment>PRNG mode seed update config PRNG mode seed update config</comment>
      </reg>
      <reg name="ce_rng_bit_rate" protect="rw">
        <comment>RNG Bit Rate RNG Bit Rate</comment>
        <bits access="r" name="rf_rng_gen_bit_cnt" pos="31:16" rst="0x0">
          <comment>RNG Bit Counter</comment>
        </bits>
        <bits access="r" name="rf_rng_bit_rate" pos="15:0" rst="0x0">
          <comment>RNG Bit number each 10000 clock cycle</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sram_data_threshhold" protect="rw">
        <comment>SRAM data numuber threshold SRAM data numuber threshold</comment>
        <bits access="rw" name="rf_ce_rng_sram_valid_threshholdd" pos="3:0" rst="0x0">
          <comment>SRAM data numuber threshold,</comment>
        </bits>
      </reg>
      <reg name="ce_rng_sram_data_residue_num" protect="rw">
        <comment>rng_sram_data_residue_num rng_sram_data_residue_num</comment>
        <bits access="r" name="rf_ce_rng_sram_data_residue_num" pos="3:0" rst="0x0">
          <comment>rng_sram_data_residue_num</comment>
        </bits>
      </reg>
      <reg name="ce_rng_exotic_fault_counter_config" protect="rw">
        <comment>exotic fault counter rng exotic fault counter config</comment>
        <bits access="rw" name="rf_ce_exotic_fault_counter_config" pos="15:0" rst="0x0">
          <comment>config the fault counter and read the counter</comment>
        </bits>
      </reg>
      <reg name="ce_rng_drbg_seed_cnt" protect="rw">
        <comment>drbg seed count drbg seed count</comment>
        <bits access="rw" name="rf_ce_rng_drbg_seed_cnt" pos="15:0" rst="0xc">
          <comment>config the drbg seed after certain time</comment>
        </bits>
      </reg>
      <reg name="ce_rng_ring_num_cfg_l" protect="rw">
        <comment>config ring ring number config ring ring number</comment>
      </reg>
      <reg name="ce_rng_ring_num_cfg_h" protect="rw">
        <comment>config ring ring number config ring ring number</comment>
      </reg>
      <reg name="ce_rng_health_test_config" protect="rw">
        <comment>rng_health_test_config rng_health_test_config</comment>
        <bits access="rw" name="rf_ce_rng_ones_freq_max" pos="18:8" rst="0x25f">
          <comment>default:11'd607(freq 0/1 in 1024)</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_long_term_bit_max" pos="7:2" rst="0x2f">
          <comment>default:6'd47 (conse 48 0/1)   [23]</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_drbg_test_en" pos="1" rst="0x0">
          <comment>open drbg test(on-demand test)</comment>
        </bits>
        <bits access="rw" name="rf_ce_rng_es_test_en" pos="0" rst="0x0">
          <comment>open es test(on-demand test)</comment>
        </bits>
      </reg>
      <reg name="ce_rng_drbg_test_pattern_l" protect="rw">
        <comment>ce_rng_drbg_test_pattern_l ce_rng_drbg_test_pattern_l</comment>
      </reg>
      <reg name="ce_rng_drbg_test_pattern_h" protect="rw">
        <comment>ce_rng_drbg_test_pattern_h ce_rng_drbg_test_pattern_h</comment>
      </reg>
      <reg name="ce_rng_raw_data_to_cpu" protect="rw">
        <comment>raw_random_number raw_random_number</comment>
      </reg>
      <reg name="ce_rng_drbg_test_result" protect="rw">
        <comment>ce_rng_drbg_sha256_result ce_rng_drbg_sha256_result</comment>
      </reg>
      <hole size="1248"/>
      <reg name="ce_session_key0" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key1" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key2" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key3" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key4" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key5" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key6" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_session_key7" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key0" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key1" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key2" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key3" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key4" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key5" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key6" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <reg name="ce_iram_key7" protect="rw">
        <comment>session key from secure OS</comment>
      </reg>
      <hole size="3584"/>
      <reg name="ce_cmd_fifo_entry" protect="rw">
        <comment>ce_cmd_fifo_entry</comment>
      </reg>
      <reg name="ce_cmd_fifo_status" protect="rw">
        <comment>ce_cmd_fifo_status</comment>
      </reg>
      <reg name="ce_rcv_addr_lo" protect="rw">
        <comment>ce_rcv_addr_lo</comment>
      </reg>
      <reg name="ce_dump_addr_lo" protect="rw">
        <comment>ce_dump_addr_lo</comment>
      </reg>
      <reg name="ce_dump_addr_hi" protect="rw">
        <comment>ce_dump_addr_hi</comment>
        <bits access="rw" name="rf_ce_dump_addr_hi" pos="7:4" rst="0x0">
          <comment>ce dump address hi</comment>
        </bits>
        <bits access="rw" name="rf_ce_rcv_addr_hi" pos="3:0" rst="0x0">
          <comment>ce rcv address hi</comment>
        </bits>
      </reg>
      <reg name="ce_finish_cmd_cnt" protect="rw">
        <comment>ce_finish_cmd_cnt</comment>
      </reg>
      <hole size="3904"/>
      <reg name="ce_fde_aes_cmd_fifo_entry" protect="rw">
        <comment>ce_fde_aes_cmd_fifo_entry</comment>
      </reg>
      <reg name="ce_fde_aes_cmd_fifo_status" protect="rw">
        <comment>ce_fde_aes_cmd_fifo_status</comment>
      </reg>
      <reg name="ce_fde_aes_rcv_addr_lo" protect="rw">
        <comment>ce_fde_aes_rcv_addr_lo</comment>
      </reg>
      <reg name="ce_fde_aes_dump_addr_lo" protect="rw">
        <comment>ce_fde_aes_dump_addr_lo</comment>
      </reg>
      <reg name="ce_fde_aes_dump_addr_hi" protect="rw">
        <comment>ce_fde_aes_dump_addr_hi</comment>
        <bits access="rw" name="rf_ce_fde_aes_dump_addr_hi" pos="7:4" rst="0x0">
          <comment>ce  fde_aes cipher dump address hi,or aes tag address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_rcv_addr_hi" pos="3:0" rst="0x0">
          <comment>ce  fde_aes cipher rcv address hi</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_finish_cmd_cnt" protect="rw">
        <comment>ce_fde_aes_finish_cmd_cnt</comment>
      </reg>
      <reg name="ce_fde_aes_start" protect="rw">
        <comment>start fde_aes cipher ce</comment>
        <bits access="rc" name="rf_ce_fde_aes_start" pos="0" rst="0x0">
          <comment>start fde_aes cipher ce(TDES/AES/SM4/SM1/SM7/GHASH)</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_clear" protect="rw">
        <comment>clear fde_aes cipher ce</comment>
        <bits access="rc" name="rf_ce_fde_aes_clear" pos="0" rst="0x0">
          <comment>reset ce fde_aes cipher status</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_mode" protect="rw">
        <comment>fde_aes cipher work mode cfg</comment>
        <bits access="rw" name="rf_ce_fde_aes_mac_ctr_inc_mode" pos="21:20" rst="0x0">
          <comment>aes mac ctr inc mode:  00: normal mode; 01: low 64bit is valid</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_key_len_sel" pos="17:16" rst="0x0">
          <comment>00: key 128bits,01:192bits,10,11:256bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_xts_iv_rotation" pos="12" rst="0x1">
          <comment>0: rtl rotation, 1: no-rotation(sm4/aes)</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_work_mode" pos="11:8" rst="0x0">
          <comment>0000:ECB,0001:CBC,0010:CTR,0011:XTS</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_enc_dec_sel" pos="4" rst="0x0">
          <comment>0:encode,1:decode</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_en" pos="0" rst="0x0">
          <comment>fde_aes cipher module enable</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_cfg" protect="rw">
        <comment>ce  fde_aes cipher basic configure</comment>
        <bits access="rw" name="rf_ce_fde_auto_update_iv_sec_cnt" pos="24" rst="0x1">
          <comment>ce fde iv auto add 1b1 each 512Byte msg</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_src_word_switch" pos="23" rst="0x0">
          <comment>fde_aes switch source high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_dst_word_switch" pos="22" rst="0x0">
          <comment>fde_aes switch destination high 32bits and low 32bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_src_byte_switch" pos="21" rst="0x1">
          <comment>fde_aes cipher source data switch of one byte</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_dst_byte_switch" pos="20" rst="0x0">
          <comment>fde_aes cipher destination data switch of one byte</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_list_update_iv_sec_cnt" pos="17" rst="0x0">
          <comment>list update iv/sec/cnt flag</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_aes_list_data_end_flag" pos="16" rst="0x0">
          <comment>fde_aes cipher data end in link list mode</comment>
        </bits>
        <bits access="r" name="rf_ce_fde_aes_list_end_flag" pos="15" rst="0x0">
          <comment>fde_aes cipher list end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_key_in_iram_flag" pos="11" rst="0x0">
          <comment>0:normal mode, 1: iram key or secure ddr key</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_key_in_session_key_flag" pos="10" rst="0x0">
          <comment>0: normal mode, 1: aes key from session key</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_key_in_ddr_flag" pos="8" rst="0x0">
          <comment>1: fde_aes cipher all crypto key in ddr/iram,and the iv also come from drr except the link list mode; 0:fde_aes cipher from registers</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_bypass" pos="7" rst="0x0"/>
        <bits access="rw" name="rf_ce_fde_aes_std_mode_end_flag" pos="4" rst="0x0">
          <comment>fde_aes cipher std end flag</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_cmd_ioc" pos="3" rst="0x0">
          <comment>0: fde_aes cipher enable cmd int output: 1: don't output int</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_dont_dump_ddr" pos="2" rst="0x0">
          <comment>0:fde_aes cipher dump from ddr; 1:fde_aes cipher don't dump</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_dont_rcv_ddr" pos="1" rst="0x0">
          <comment>0:fde_aes cipher rcv from ddr; 1:fde_aes cipher don't rcv</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_link_mode_flag" pos="0" rst="0x0">
          <comment>0:fde_aes cipher std mode, 1:fde_aes cipher link mode</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_list_length" protect="rw">
        <comment>fde_aes cipher dma one length</comment>
        <bits access="rw" name="rf_ce_fde_aes_list_ptr_hi" pos="19:16" rst="0x0">
          <comment>ce_fde_aes_list_ptr high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_list_len" pos="11:0" rst="0x0">
          <comment>fde_aes cipher first list length,support max 40 nodes</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_list_ptr" protect="rw">
        <comment>fde_aes cipher dma list pointer</comment>
      </reg>
      <reg name="ce_fde_aes_src_frag_length" protect="rw">
        <comment>fde_aes cipher dma read port node data length</comment>
        <bits access="rw" name="rf_ce_fde_aes_dst_addr_hi" pos="31:28" rst="0x0">
          <comment>fde_aes cipher destination address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_src_addr_hi" pos="27:24" rst="0x0">
          <comment>fde_aes cipher source address high 4bits; or aes mac aad address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_src_frag_len" pos="23:0" rst="0x0">
          <comment>fde_aes cipher source fragment length of each node;  or aes mac aad length</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_src_addr" protect="rw">
        <comment>fde_aes cipher dma source address</comment>
      </reg>
      <reg name="ce_fde_aes_dst_addr" protect="rw">
        <comment>fde_aes cipher dma destination address</comment>
      </reg>
      <reg name="ce_fde_aes_key_length" protect="rw">
        <comment>fde aes key length</comment>
        <bits access="rw" name="rf_ce_fde_aes_key_addr_hi" pos="27:24" rst="0x0">
          <comment>fde aes key address high 4bits</comment>
        </bits>
        <bits access="rw" name="rf_ce_fde_aes_key_len" pos="23:0" rst="0x0">
          <comment>fde aes key length</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_key_address" protect="rw">
        <comment>fde aes key address</comment>
      </reg>
      <reg name="ce_fde_aes_dst_ddr_sel" protect="rw">
        <comment>fde aes dst ddr select</comment>
        <bits access="rw" name="rf_ce_fde_aes_dst_ddr_sel" pos="0" rst="0x0">
          <comment>axi awprot under key in iram mode
0: non_sec 1: sec</comment>
        </bits>
      </reg>
      <reg name="ce_fde_aes_dummy_reg" protect="rw">
        <comment>ce fde aes dummy register</comment>
        <bits access="rw" name="rf_ce_fde_dummy_reg" pos="7:0" rst="0x0">
          <comment>ce fde aes dummy register</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ce_fde_iv_sec_cnt0" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_fde_iv_sec_cnt1" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_fde_iv_sec_cnt2" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_fde_iv_sec_cnt3" protect="rw">
        <comment>aes tdes iv sector counter</comment>
      </reg>
      <reg name="ce_fde_aes_key10" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key11" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key12" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key13" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key14" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key15" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key16" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key17" protect="rw">
        <comment>fde key1</comment>
      </reg>
      <reg name="ce_fde_aes_key20" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key21" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key22" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key23" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key24" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key25" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key26" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <reg name="ce_fde_aes_key27" protect="rw">
        <comment>fde key2</comment>
      </reg>
      <hole size="768"/>
      <reg name="ce_fde_session_key0" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key1" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key2" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key3" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key4" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key5" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key6" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_session_key7" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key0" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key1" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key2" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key3" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key4" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key5" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key6" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
      <reg name="ce_fde_iram_key7" protect="rw">
        <comment>fde session key from secure OS</comment>
      </reg>
    </module>
    <instance address="0x04002000" name="CE_PUB" type="CE_PUB"/>
  </archive>
  <archive relative="emmc.xml">
    <module category="System" name="EMMC">
      <reg name="blk_cnt" protect="rw">
        <comment>DMA Block Count</comment>
      </reg>
      <reg name="blk_size" protect="rw">
        <comment>Block Size and Count</comment>
        <bits access="rw" name="blk_size" pos="11:0" rst="0x0">
          <comment>Transfer blocks size. This register specifies the block size for block data transfers for CMD17, CMD18, CMD24, CMD25, and CMD53.
0x0000: no data transfer
0x0001: 1 byte</comment>
        </bits>
      </reg>
      <reg name="argumnet" protect="rw">
        <comment>Argument</comment>
      </reg>
      <reg name="tr_mode" protect="rw">
        <comment>Transfer mode and command</comment>
        <bits access="rw" name="boot_ack" pos="31" rst="0x0">
          <comment>Set to indicate the host whether card will send boot ack
1b1: send boot ack
1b0: not send boot ack</comment>
        </bits>
        <bits access="rw" name="cmd_line_boot" pos="30" rst="0x0">
          <comment>Set to begin drive low cmd line and waiting to receive boot data block
1b1: Drive cmd line low
1b0: not drive cmd line</comment>
        </bits>
        <bits access="rw" name="cmd_index" pos="29:24" rst="0x0">
          <comment>Command index, set to the command number (CMD0-63, ACMD0-63)</comment>
        </bits>
        <bits access="rw" name="cmd_type" pos="23:22" rst="0x0">
          <comment>Commend type. There are three types of special commands, Suspend, Resume and Abort. These bits shall bet set to 00b for all other commands.
00: Normal
01/10: Reserved
11: Abort</comment>
        </bits>
        <bits access="rw" name="data_pre_sel" pos="21" rst="0x0">
          <comment>Data present select
0: no data present
1: data present
This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line. It is set to 0 for the following:
1. Commands using only CMD line (e.g., CMD52)
2. Commands with no data transfer but using busy signal on DAT[0] line (R1b or R5b, e.g., CMD38)
3. Resume Command</comment>
        </bits>
        <bits access="rw" name="cmd_ind_chk_en" pos="20" rst="0x0">
          <comment>Command index check enable
0: disable
1: enable
If this bit is set to 1, the HC shall check the index field in the Response to see if it has the same value as the command index. If it is not, it is reported as a Command Index Error. If this bit is set to 0, the Index field is not checked.</comment>
        </bits>
        <bits access="rw" name="cmd_crc_chk_en" pos="19" rst="0x0">
          <comment>Command CRC check enable
0: disable
1: enable
If this bit is set to 1, the HC shall check the CRC field in the Response. If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0, the CRC field is not checked</comment>
        </bits>
        <bits access="rw" name="sub_cmd_flag" pos="18" rst="0x0">
          <comment>Sub Command Flag
0: Main Command
1: Sub Command</comment>
        </bits>
        <bits access="rw" name="resp_type_sel" pos="17:16" rst="0x0">
          <comment>Response type select
00: no response
01: response length 136
10: response length 48
11: response length 48, check Busy after response</comment>
        </bits>
        <bits access="rw" name="resp_int_dis" pos="8" rst="0x0">
          <comment>Response Interrupt Disable
0: Response Interrupt is enabled.
1: Response Interrupt is disabled.
Support response error check function to avoid overhead of response error check by Host Driver. Only R1 or R5 can be checked.
If Host Driver checks response error, sets this bit to 0 and waits Command Complete Interrupt and then checks the response register.
If Host Controller checks response error, sets this bit to 1 and sets Response Error Check Enable to 1, Command Complete Interrupt is disabled by this bit regardless of Command Complete Signal Enable</comment>
        </bits>
        <bits access="rw" name="resp_err_chk_en" pos="7" rst="0x0">
          <comment>Response Error Check Enable
0: Response Error check is disabled
1: Response Error check is enabled.
Support response error check function to avoid overhead of response error check by Host driver. Only R1 or R5 can be checked.
If Host Driver check response error, this bit is set to 0 and Response Interrupt Disable is set to 0,
If Host Controller checks response error, sets this bit to 1 and sets Response Interrupt Disable to 1. Response Type R1/R5 selects either R1 or R5 response type. If an error is detected, Response Error Interrupt is generated in the Error Interrupt Status register.</comment>
        </bits>
        <bits access="rw" name="resp_type" pos="6" rst="0x0">
          <comment>Response Type R1/R5
0: R1 (Memory)
1: R5 (SDIO)
When response error check is enabled, this bit selects either R1 or R5 response types. Two types of response checks are supported: R1 for memory and R5 for SDIO.
Error Statues checked in R1
Bit: 19/20/21/23/25/26/29/30/31
Response Flags Checked in R5:
Bit: 0/1/3/7</comment>
        </bits>
        <bits access="rw" name="mult_blk_sel" pos="5" rst="0x0">
          <comment>Multiple/single block select
0: single block
1: multiple blocks</comment>
        </bits>
        <bits access="rw" name="data_dir_sel" pos="4" rst="0x0">
          <comment>Data transfer direction select
0: write (Host to Card)
1: read (Card to Host)</comment>
        </bits>
        <bits access="rw" name="auto_cmd_en" pos="3:2" rst="0x0">
          <comment>Auto CMD enable
00: disable
01: Auto CMD12 Enable
10: Auto CMD23 Enable
11: Auto CMD auto select
1: Auto CMD12 Enable: Multiple block transfers for memory require CMD12 to stop the transaction. When this bit is set to 1, the HC shall issue CMD12 automatically when last block transfer is completed. The HD shall not set this bit to issue commands that do not require CMD12 to stop data transfer.
2: Auto CMD23 Enable:
When this bit field is set to 10b, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command Register
3: Auto CMD auto select.
When this mode select, selection of auto CMD depends on setting of CMD23 Enable in the Host Ctrl 2 register which indicated whether card support CMD23. If CMD23 Enable=1, auto CMD23 is used and if CMD23 Enable=0, auto CMD12 is used. Use of Auto CMD Auto Select is recommended rather than use of Auto CMD12 Enable or Auto CMD23 Enable.</comment>
        </bits>
        <bits access="rw" name="blk_cnt_en" pos="1" rst="0x0">
          <comment>Block count enable
(This design not support infinite mode, so it is always 1)</comment>
        </bits>
        <bits access="rw" name="dma_en" pos="0" rst="0x0">
          <comment>DMA enable
(This design not support NO-DMA mode, so it is always 1)</comment>
        </bits>
      </reg>
      <reg name="resp0" protect="rw">
        <comment>RESP0</comment>
      </reg>
      <reg name="resp1" protect="rw">
        <comment>RESP1</comment>
      </reg>
      <reg name="resp2" protect="rw">
        <comment>RESP2</comment>
      </reg>
      <reg name="resp3" protect="rw">
        <comment>RESP3</comment>
      </reg>
      <hole size="32"/>
      <reg name="pres_state" protect="rw">
        <comment>DMC AXI channel 0 configuration register</comment>
        <bits access="r" name="sub_cmd_flag" pos="28" rst="0x0">
          <comment>Sub Command Flag
0: Main Command
1: Sub Command</comment>
        </bits>
        <bits access="r" name="cmd_line" pos="24" rst="0x1">
          <comment>CMD line signal level. This status is used to check CMD line level to recover from errors, and for debugging</comment>
        </bits>
        <bits access="r" name="dat_line3_0" pos="23:20" rst="0xf">
          <comment>DAT [3:0] line signal level. This status is used to check DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT [0].
[23]: for DAT[3]
[22]: for DAT[2]
[21]: for DAT[1]
[20]: for DAT[0]</comment>
        </bits>
        <bits access="rw" name="read_active" pos="9" rst="0x0">
          <comment>Read transfer active. This status is used for detecting completion of a read transfer. This bit is set to 1 for either of the following conditions:
1. After the end bit of the read command
2. When writing a 1 to continue Request in the Block Gap Control register to restart a read transfer
This bit is cleared to 0 for either of the following conditions:
1. When the last data block as specified by block length is transferred to the system.
2. When all valid data blocks have been transferred to the system and no current block transfers are being sent as a result of the Stop at Block Gap Request set to 1. A transfer complete interrupt is generated when this bit changes to 0.
0: no valid data
1: transferring data</comment>
        </bits>
        <bits access="r" name="write_acitve" pos="8" rst="0x0">
          <comment>Write transfer active. This status indicates a write transfer is active. If this bit is 0, it means no valid write data exists in the HC. This bit is set in either of the following cases:
1. After the end bit of the write command
2. When writing a 1 to Continue Request in the Block Gap Control register to restart a write transfer
This bit is cleared in either of the following cases:
1. After getting the CRC status of the last data block as specified by the transfer count (Single or Multiple)
2. After getting a CRC status of any block where data transmission is about to be stopped by a Stop at Block Gap Request.
During a write transaction, a Block Gap Event interrupt is generated when this bit is changed to 0, as a result of the Stop at Block Gap Request being set. This status is useful for the HD in determining when to issue commands during write busy.
0: no valid data
1: transferring data</comment>
        </bits>
        <bits access="r" name="dat_line7_4" pos="7:4" rst="0xf">
          <comment>This bit selects 32B or 64B size when splitting AXI burst to DDR bursts.
0 : only 32byte split size
1 : dynamic split size, 32B or 64B, based on AXI transactions</comment>
        </bits>
        <bits access="r" name="dat_line_active" pos="2" rst="0x0">
          <comment>DAT line active. This bit indicates whether one of the DAT line on SD bus is in use.
0: DAT line inactive
1: DAT line active</comment>
        </bits>
        <bits access="r" name="cmd_inh_dat" pos="1" rst="0x0">
          <comment>Command inhibit (DAT)
This status bit is generated if either the DAT Line Active or the Read Transfer Active is 1. If this bit is 0, it indicates the HC can issue the next SD command. Commands with busy signal belong to Command Inhibit (DAT) (e.g., R1b, R5b type). Changing from 1 to 0 generates a Transfer Complete interrupt in the Normal Interrupt status register. Note: The SD Host Driver can save registers in the range of 0x0000 ~ 0x000D for a suspend transaction after this bit has changed from 1 to 0.
0: can issue command that uses the DAT line
1: cannot issue command that uses the DAT line</comment>
        </bits>
        <bits access="r" name="cmd_inh_cmd" pos="0" rst="0x0">
          <comment>Command inhibit (CMD)
If this bit is 0, it indicates the CMD line is not in use and the HC can issue a SD command using the CMD line. This bit is set immediately after the Command register (0x000F) is written. This bit is cleared when the command response is received. Even if the Command Inhibit (DAT) is set to 1, Commands using only the CMD line can be issued if this bit is 0. Changing from 1 to 0 generates a Command complete interrupt in the Normal Interrupt Status register. If the HC cannot issue the command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit shall remain 1 and the Command Complete is not set. Status issuing Auto CMD12 is not read from this bit.</comment>
        </bits>
      </reg>
      <reg name="host_ctrl1" protect="rw">
        <comment>SD Host Control Register1</comment>
        <bits access="rw" name="int_at_blk_gap" pos="19" rst="0x1">
          <comment>Interrupt at block gap. This bit is valid only in 4-bit mode of the SDIO card and selects a sample point in the interrupt cycle. Setting to 1 enables interrupt detection at the block gap for a multiple block transfer. If the SD card cannot signal an interrupt during a multiple block transfer, this bit should be set to 0. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card.</comment>
        </bits>
        <bits access="rw" name="rd_wait_ctrl" pos="18" rst="0x0">
          <comment>Read wait control. The read wait function is optional for SDIO cards. If the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using DAT[2] line. Otherwise, the HC has to stop the SD clock to hold read data, which restricts commands generation. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card. If the card does not support read wait, this bit shall never be set to 1 or DAT line conflict may occur. If this bit is set to 0, Suspend/Resume cannot be supported.
0: disable read wait control
1: enable read wait control</comment>
        </bits>
        <bits access="rw" name="sd8_mode" pos="5" rst="0x0">
          <comment>SD8 bit mode
Extended Data Transfer Width
This bit controls 8-bit bus width mode for embedded device. Support of this function is indicated in 8-bit Support for Embedded Device in the Capabilities register. If a device supports 8-bit bus mode, this bit may be set to 1. If this bit is 0, bus width is controller by Data Transfer Width in the Host Control 1 register.
1: 8-bit Bus Width
0: Bus Width is Selected by Data Transfer Width</comment>
        </bits>
        <bits access="rw" name="dma_sel" pos="4:3" rst="0x0">
          <comment>DMA Select
2b00: SDMA is select
2b01: Reserved
2b10: ADMA2 is select
2b11: ADMA2/3 is select</comment>
        </bits>
        <bits access="rw" name="sd4b_mode" pos="1" rst="0x0">
          <comment>Data transfer width, SD1 or SD4. This bit selects the data width of the HC. The HD shall select it to match the data width of the SD card.
0: 1-bit mode
1: 4-bit mode</comment>
        </bits>
      </reg>
      <reg name="clk_ctrl" protect="rw">
        <comment>SD Control Register2</comment>
        <bits access="rw" name="hw_rst_card" pos="27" rst="0x1">
          <comment>Hardware reset for card
1: Normal work
0: card reset , should be set back to 1 manually</comment>
        </bits>
        <bits access="w" name="sw_rst_dat" pos="26" rst="0x0">
          <comment>Software reset for DAT line. Only part of data circuit is reset. DMA circuit is also reset. The following registers and bits are cleared by this bit:
 Buffer Data Port Register:
 Buffer is cleared and initialized.
 Present State register:
 Buffer Read Enable
 Buffer Write Enable
 Read Transfer Active
 Write Transfer Active
 DAT Line Active
 Command Inhibit (DAT)
 Block Gap Control register:
 Continue Request
 Stop At Block Gap Request
 Normal Interrupt Status register
 Buffer Read Ready
 Buffer Write Ready
 Block Gap Event Transfer Complete
0: work
1: reset</comment>
        </bits>
        <bits access="w" name="sw_rst_cmd" pos="25" rst="0x0">
          <comment>Software reset for CMD line. Only part of command circuit is reset. The following registers and bits are cleared by this bit:
 Present State register
 Command Inhibit (CMD)
 Normal Interrupt Status register
 Command Complete
0: work
1: reset</comment>
        </bits>
        <bits access="w" name="sw_rst_all" pos="24" rst="0x0">
          <comment>Software reset for all. This reset affects the entire HC except for the card detection circuit. Register bits of type ROC, RW, RW1C, RWAC are cleared to 0. During its initialization, the HD shall set this bit to 1 to reset the HC. The HC shall reset this bit to 0 when Capabilities registers are valid and the HD can read them. Additional use of Software Reset for All may not affect the value of the Capabilities registers. If this bit is set to 1, the SD card shall reset itself and must be reinitialized by the HD.
0: work
1: reset</comment>
        </bits>
        <bits access="rw" name="data_timeout_cnt" pos="19:16" rst="0x0">
          <comment>Data timeout counter value. This value determines the interval by which DAT line timeouts are detected. Refer to the Data Timeout Error in the Error Interrupt Status register for information on factors that dictate timeout generation. Timeout clock frequency will be generated by dividing the base clock TMCLK by this value. When setting this register, prevent inadvertent timeout events by clearing the Data Timeout Error Status Enable (in the Error Interrupt Status Enable register).
0000: TMCLK * 2^(16)
0001: TMCLK * 2^(17)

1110: TMCLK * 2^(30)
1111: TMCLK * 2^(31)</comment>
        </bits>
        <bits access="rw" name="freq_div_0_7" pos="15:8" rst="0x0">
          <comment>SDCLK/RCLK Frequency Select
If Freq_div = 0:Base clk
   Freq_div = 1:Base clk/2
   Freq_div = 2:Base clk/4
   Freq_div = 3:Base clk/6

   Freq_div= n:Base clk/(2*n)</comment>
        </bits>
        <bits access="rw" name="freq_div_8_9" pos="7:6" rst="0x0">
          <comment>SDCLK/RCLK Frequency Select[9:8]</comment>
        </bits>
        <bits access="rw" name="sdclk_en" pos="2" rst="0x0">
          <comment>SD clock enable. The HC shall stop SDCLK when writing this bit to 0. SDCLK Frequency Select can be changed when this bit is 0. Then, the HC shall maintain the same clock frequency until SDCLK is stopped (stop at SDCLK = 0). If the HC detects the No Card state, this bit shall be cleared.
0: disable
1: enable</comment>
        </bits>
        <bits access="r" name="int_clk_stable" pos="1" rst="0x0">
          <comment>Internal clock stable. This bit is set to 1 when SD clock is stable after writing to Internal Clock Enable in this register to 1. The SD Host Driver shall wait to set SD Clock Enable until this bit is 1.Note: This is useful when using PLL for a clock oscillator that requires setup time.
0: not ready
1: ready</comment>
        </bits>
        <bits access="rw" name="int_clk_en" pos="0" rst="0x0">
          <comment>Internal clock enable. This bit is set to 0 when the HD is not using the HC or the HC awaits a wakeup event. The HC should stop its internal clock to go to the very low power state. Still, registers shall be able to be read and written. Clock starts to oscillate when this bit is set to 1. When clock oscillation is stable, the HC shall set Internal Clock Stable in this register to 1. This bit shall not affect card detection.
0: stop
1: oscillate
Note:
It is recommended to set this bit to 0  before changing the clock source, and then set it to 1 after the changing is done.
But changing the frequency divider need not to set this bit to 0.</comment>
        </bits>
      </reg>
      <reg name="int_st" protect="rw">
        <comment>Normal and error interrupt status</comment>
        <bits access="rc" name="axi_resp_err" pos="28" rst="0x0">
          <comment>AXI Bus Error
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="resp_error" pos="27" rst="0x0">
          <comment>Response Error
0: no error</comment>
        </bits>
        <bits access="rc" name="adma_error" pos="25" rst="0x0">
          <comment>ADMA Error
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="auto_cmd12_err" pos="24" rst="0x0">
          <comment>Auto CMD12 error. This occurs when detecting that one of the bits in Auto CMD12 Error Status register has changed from 0 to 1. This bit is set to 1 also when Auto CMD12 is not executed due to the previous command error.
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="data_end_bit_err" pos="22" rst="0x0">
          <comment>Data end bit error. This occurs when detecting 0 at the end bit position of read data which uses the DAT line or the end bit position of the CRC status.
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="data_crc_err" pos="21" rst="0x0">
          <comment>Data CRC error. This occurs when detecting CRC error when transferring read data which uses the DAT line or when detecting the Write CRC Status having a value of other than 010.
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="data_timeout_err" pos="20" rst="0x0">
          <comment>Data timeout error. This occurs when detecting one of the following timeout conditions.
1. Busy Timeout for R1b, R5b type
2. Busy Timeout after Write CRC status
3. Write CRC status Timeout
4. Read Data Timeout
0: no error
1: timeout</comment>
        </bits>
        <bits access="rc" name="cmd_ind_err" pos="19" rst="0x0">
          <comment>Command index error. This occurs if a Command Index error occurs in the Command Response.
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="cmd_end_bit_err" pos="18" rst="0x0">
          <comment>Command end bit error. This occurs when detecting that the end bit of a command response is 0.
0: no error
1: end bit error generated</comment>
        </bits>
        <bits access="rc" name="cmd_crc_error" pos="17" rst="0x0">
          <comment>Command CRC error. Command CRC Error is generated in two cases.
1. If a response is returned and the Command Timeout Error is set to 0, this bit is set to 1 when detecting a CRC error in the command response
2. The HC detects a CMD line conflict by monitoring the CMD line when a command is issued. If the HC drives the CMD line to 1 level, but detects 0 levels on the CMD line at the next SDCLK edge, then the HC shall abort the command (stop driving CMD line) and set this bit to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line conflict.
0: no error
1: CRC error generated</comment>
        </bits>
        <bits access="rc" name="cmd_timeout_err" pos="16" rst="0x0">
          <comment>Command timeout error. This occurs only if the no response is returned within 64 SDCLK cycles from the end bit of the command. If the HC detects a CMD line conflict, in which case Command CRC Error shall also be set. This bit shall be set without waiting for 64 SDCLK cycles because the command will be aborted by the HC.
0: no error
1: timeout</comment>
        </bits>
        <bits access="rc" name="err_int" pos="15" rst="0x0">
          <comment>Error Interrupt
If any of the bits in the Error Interrpt Status register are set, then this bit is set. Therefore the Host Driver can efficiently test for an error by checking this bit first. This bit is read only.
0: no error
1: error</comment>
        </bits>
        <bits access="rc" name="adma3_complete" pos="14" rst="0x0">
          <comment>ADMA3 Complete</comment>
        </bits>
        <bits access="rc" name="card_int" pos="8" rst="0x0">
          <comment>Card interrupts. Writing this bit to 1 does not clear this bit. It is cleared by resetting the SD card interrupt factor. In 1-bit mode, the HC shall detect the Card Interrupt without SD Clock to support wakeup. In 4-bit mode, the card interrupt signal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the card and the interrupt to the Host system. When this status has been set and the HD needs to start this interrupt service, Card Interrupt Status Enable in the Normal Interrupt Status register shall be set to 0 in order to clear the card interrupt statuses latched in the HC and stop driving the Host System. After completion of the card interrupt service (the reset factor in the SD card and the interrupt signal may not be asserted), set Card Interrupt Status Enable to 1 and start sampling the interrupt signal again.
0: no card interrupt
1: card interrupt generated</comment>
        </bits>
        <bits access="rc" name="dma_int" pos="3" rst="0x0">
          <comment>DMA interrupt. This status is set if the HC detects the Host DMA Interrupt.
0: no DMA interrupt
1: DMA interrupt generated</comment>
        </bits>
        <bits access="rc" name="tr_complete" pos="1" rst="0x0">
          <comment>Transfer complete. This bit is set when a read/write transaction is completed.
Read Transaction: This bit is set at the falling edge of Read Transfer Active Status. There are two cases in which the Interrupt is generated. The first is when a data transfer is completed as specified by data length (after the last data has been read to the Host System). The second is when data has stopped at the block gap and completed the data transfer by setting the Stop at Block Gap Request in the Block Gap Control register (after valid data has been read to the Host System).
Write Transaction: This bit is set at the falling edge of the DAT Line Active Status. There are two cases in which the Interrupt is generated. The first is when the last data is written to the card as specified by data length and Busy signal is released. The second is when data transfers are stopped at the block gap by setting Stop at Block Gap Request in the Block Gap Control register and data transfers completed (after valid data is written to the SD card and the busy signal is released).
0: no data transfer complete
1: data transfer complete</comment>
        </bits>
        <bits access="rc" name="cmd_complete" pos="0" rst="0x0">
          <comment>Command complete. This bit is set when getting the end bit of the command response (except auto CMD12 and auto CMD23).
Note: Command Timeout Error has higher priority than Command Complete. If both are set to 1, it can be considered that the response was not received correctly.
0: no command complete
1: command complete</comment>
        </bits>
      </reg>
      <reg name="int_st_en" protect="rw">
        <comment>Normal and error interrupt status enable</comment>
        <bits access="rw" name="axi_resp_err_en" pos="28" rst="0x0">
          <comment>AXI Bus Error status enable</comment>
        </bits>
        <bits access="rw" name="resp_error_en" pos="27" rst="0x0">
          <comment>Response Error status enable</comment>
        </bits>
        <bits access="rw" name="adma_error_en" pos="25" rst="0x0">
          <comment>ADMA Error status enable</comment>
        </bits>
        <bits access="rw" name="auto_cmd12_err_en" pos="24" rst="0x0">
          <comment>Auto CMD12 error status enable</comment>
        </bits>
        <bits access="rw" name="data_end_bit_err_en" pos="22" rst="0x0">
          <comment>Data end bit error status enable</comment>
        </bits>
        <bits access="rw" name="data_crc_err_en" pos="21" rst="0x0">
          <comment>Data CRC error status enable</comment>
        </bits>
        <bits access="rw" name="data_timeout_err_en" pos="20" rst="0x0">
          <comment>Data timeout error status enable</comment>
        </bits>
        <bits access="rw" name="cmd_ind_err_en" pos="19" rst="0x0">
          <comment>Command index error status enable</comment>
        </bits>
        <bits access="rw" name="cmd_end_bit_err_en" pos="18" rst="0x0">
          <comment>Command end bit error status enable</comment>
        </bits>
        <bits access="rw" name="cmd_crc_error_en" pos="17" rst="0x0">
          <comment>Command CRC error status enable</comment>
        </bits>
        <bits access="rw" name="cmd_timeout_err_en" pos="16" rst="0x0">
          <comment>Command timeout error status enable</comment>
        </bits>
        <bits access="rw" name="adma3_complete_en" pos="14" rst="0x0">
          <comment>ADMA3 Complete status enable</comment>
        </bits>
        <bits access="rw" name="card_int_en" pos="8" rst="0x0">
          <comment>Card interrupt status enable</comment>
        </bits>
        <bits access="rw" name="dma_int_en" pos="3" rst="0x0">
          <comment>DMA interrupt status enable</comment>
        </bits>
        <bits access="rw" name="tr_complete_en" pos="1" rst="0x0">
          <comment>Transfer complete status enable</comment>
        </bits>
        <bits access="rw" name="cmd_complete_en" pos="0" rst="0x0">
          <comment>Command complete status enable</comment>
        </bits>
      </reg>
      <reg name="int_sig_en" protect="rw">
        <comment>Normal and error interrupt signal enable</comment>
        <bits access="rw" name="axi_resp_err_en" pos="28" rst="0x0">
          <comment>AXI Bus Error signal enable</comment>
        </bits>
        <bits access="rw" name="resp_error_en" pos="27" rst="0x0">
          <comment>Response Error signal enable</comment>
        </bits>
        <bits access="rw" name="adma_error_en" pos="25" rst="0x0">
          <comment>ADMA Error signal enable</comment>
        </bits>
        <bits access="rw" name="auto_cmd12_err_en" pos="24" rst="0x0">
          <comment>Auto CMD12 error signal enable</comment>
        </bits>
        <bits access="rw" name="cur_lmt_err_en" pos="23" rst="0x0">
          <comment>Current limit error signal enable</comment>
        </bits>
        <bits access="rw" name="data_end_bit_err_en" pos="22" rst="0x0">
          <comment>Data end bit error signal enable</comment>
        </bits>
        <bits access="rw" name="data_crc_err_en" pos="21" rst="0x0">
          <comment>Data CRC error signal enable</comment>
        </bits>
        <bits access="rw" name="data_timeout_err_en" pos="20" rst="0x0">
          <comment>Data timeout error signal enable</comment>
        </bits>
        <bits access="rw" name="cmd_ind_err_en" pos="19" rst="0x0">
          <comment>Command index error signal enable</comment>
        </bits>
        <bits access="rw" name="cmd_end_bit_err_en" pos="18" rst="0x0">
          <comment>Command end bit error signal enable</comment>
        </bits>
        <bits access="rw" name="cmd_crc_error_en" pos="17" rst="0x0">
          <comment>Command CRC error signal enable</comment>
        </bits>
        <bits access="rw" name="cmd_timeout_err_en" pos="16" rst="0x0">
          <comment>Command timeout error signal enable</comment>
        </bits>
        <bits access="rw" name="adma3_complete_en" pos="14" rst="0x0">
          <comment>ADMA3 transfer complete signal enable</comment>
        </bits>
        <bits access="rw" name="card_int_en" pos="8" rst="0x0">
          <comment>Card interrupt signal enable</comment>
        </bits>
        <bits access="rw" name="dma_int_en" pos="3" rst="0x0">
          <comment>DMA interrupt signal enable</comment>
        </bits>
        <bits access="rw" name="tr_complete_en" pos="1" rst="0x0">
          <comment>Transfer complete signal enable</comment>
        </bits>
        <bits access="rw" name="cmd_complete_en" pos="0" rst="0x0">
          <comment>Command complete signal enable</comment>
        </bits>
      </reg>
      <reg name="host_ctrl2" protect="rw">
        <comment>Host controller 2 and Auto CMD12 error status</comment>
        <bits access="rw" name="addr_64bit_en" pos="29" rst="0x0">
          <comment>The system address is 32 bit or 64 bits
0: 32 bit address
1: 64 bit address</comment>
        </bits>
        <bits access="r" name="host_ver_4_en" pos="28" rst="0x1">
          <comment>This design is host version 4</comment>
        </bits>
        <bits access="rw" name="cmd23_enable" pos="27" rst="0x0">
          <comment>CMD23 Enable
This bit is used to select Auto CMD23 or Auto CMD12 for ADMA3 data transfer. Refer to Auto CMD Enable in the Transfer Mode Register
0:  AutoCMD auto select CMD12
1:  AutoCMD auto select CMD23</comment>
        </bits>
        <bits access="rw" name="adma2_len_mode" pos="26" rst="0x0">
          <comment>The ADMA2 length mode is 26 bit or 16bit
0: 16 bit data length mode
1: 26 bit data length mode</comment>
        </bits>
        <bits access="rw" name="uhs_mode" pos="19:16" rst="0x0">
          <comment>UHS Mode Select
This field is used to select one of UHS-I mode and effective when 1.8V Signaling Enable is set to 1.
If Preset Value Enable in the SD_CTRL3 register is set to 1, Host controller sets SDCLK Frequency Select, Clock Generator Select in the Clock Control register according to Preset Value registers. In this case, one of preset value registers is selected by this field. Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitch. After setting this field, Host Driver sets SD Clock Enable again.
4b0000: SDR12
4b0001: SDR25
4b0010: SDR50
4b0011: SDR104
4b0100: DDR50
4b0101: HS200
4b0110: HS400
4b0111: HS401 (EMMC5.1) HS400 mode
4b1000: DDR200, SD6.0</comment>
        </bits>
        <bits access="r" name="cmd_not_iss_err" pos="7" rst="0x0">
          <comment>Command not issued error. Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error ([4:1]) in this register.
0: no error
1: not issued</comment>
        </bits>
        <bits access="r" name="acmd_idx_err" pos="4" rst="0x0">
          <comment>Auto CMD index error. This occurs if the Command Index error occurs in response to a command.
0: no error
1: error</comment>
        </bits>
        <bits access="r" name="acmd_end_bit_err" pos="3" rst="0x0">
          <comment>Auto CMD end bit error. This occurs when detecting that the end bit of command response is 0.
0: no error
1: end bit error generated</comment>
        </bits>
        <bits access="r" name="acmd_crc_err" pos="2" rst="0x0">
          <comment>Auto CMD CRC error. This occurs when detecting a CRC error in the command response.
0: no error
1: CRC error generated</comment>
        </bits>
        <bits access="r" name="acmd_timeout_err" pos="1" rst="0x0">
          <comment>Auto CMD timeout error. This occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command. If this bit is set to 1, the other error status bits ([4:2]) are meaningless.
0: no error
1: timeout</comment>
        </bits>
        <bits access="r" name="acmd12_not_exec" pos="0" rst="0x0">
          <comment>Auto CMD12 Not Executed
If memory multiple block data transfer is not started due to command error. This bit is not set because it is not necessary to issue auto cmd12. Setting this bit to 1 means the Host Controller cannot issue auto cmd12 to stop memory multiple block data transfer due to some error. If this bit is set to 1. Other error status bits are meaningless.</comment>
        </bits>
      </reg>
      <reg name="cap1" protect="rw">
        <comment>Capabilities</comment>
        <bits access="r" name="slot_type" pos="31:30" rst="0x0">
          <comment>Slot Type
2b00: Removable Card Slot</comment>
        </bits>
        <bits access="r" name="async_int" pos="29" rst="0x0">
          <comment>Asynchronous Interrupt Support
1b0:Asynchronous  Interrupt Not Supported</comment>
        </bits>
        <bits access="r" name="addr_64bit_sup_v3" pos="28" rst="0x1">
          <comment>64 bit System Bus Support
1b0 64 bit System Bus Support</comment>
        </bits>
        <bits access="r" name="addr_64bit_sup_v4" pos="27" rst="0x1">
          <comment>64 bit System Bus Support
1b0 64 bit System Bus Support</comment>
        </bits>
        <bits access="r" name="v18" pos="26" rst="0x1">
          <comment>Voltage support 1.8 V.
0: 1.8 V not supported
1: 1.8 V supported</comment>
        </bits>
        <bits access="r" name="v30" pos="25" rst="0x0">
          <comment>Voltage support 3.0 V.
0: 3.0 V not supported
1: 3.0 V supported</comment>
        </bits>
        <bits access="r" name="v33" pos="24" rst="0x0">
          <comment>Voltage support 3.3 V.
0: 3.3 V not supported
1: 3.3 V supported</comment>
        </bits>
        <bits access="r" name="susp_res" pos="23" rst="0x0">
          <comment>Suspend/resume support. This bit indicates whether the HC supports Suspend/Resume function. If this bit is 0, the Suspend and Resume mechanism is not supported and the HD shall not issue either Suspend/Resume command.
0: not supported
1: supported</comment>
        </bits>
        <bits access="r" name="dma" pos="22" rst="0x1">
          <comment>DMA support. This bit indicates whether the HC is capable of using DMA to transfer data between system memory and the HC directly.
0: DMA not supported
1: DMA supported</comment>
        </bits>
        <bits access="r" name="high_speed" pos="21" rst="0x1">
          <comment>High speed support. This bit indicates whether the HC and the Host System support High Speed mode and they can supply SD Clock frequency from 25 MHz to 50 MHz
0: high speed not supported
1: high speed supported</comment>
        </bits>
        <bits access="r" name="adma2_support" pos="19" rst="0x1">
          <comment>ADMA2 Support
1b0: ADMA2 is not supported
1b1: ADMA2 is supported</comment>
        </bits>
        <bits access="r" name="sup_8bit" pos="18" rst="0x1">
          <comment>8-bit Support for Device
1b1: 8-bit Bus Width Supported</comment>
        </bits>
        <bits access="r" name="max_blk_size" pos="17:16" rst="0x1">
          <comment>This value indicates the maximum block size that the HD can read and write to the buffer in the HC. The buffer shall transfer this block size without wait cycles.
00: 512 bytes
01: 1024 bytes
10: 2048 bytes
11: 4096 bytes</comment>
        </bits>
        <bits access="r" name="base_clk_frq" pos="15:8" rst="0x0">
          <comment>This value indicates the base (maximum) clock frequency for the SD clock. The unit is MHz If the real frequency is 16.5 MHz, a larger value shall be set, i.e., 010001b (17 MHz) because the HD uses this value to calculate the clock divider value and it shall not exceed the upper limit of the SD clock frequency. The supported range is 10 to 63 MHz If these bits are all 0, the Host System has to get information via another method.
0: get information via another method (Registry Entry)
1: 1 MHz
2: 2 MHz

FF: 255 MHz</comment>
        </bits>
        <bits access="r" name="timeout_clk_unit" pos="7" rst="0x1">
          <comment>This bit shows the unit of base clock frequency used to detect Data Timeout Error.
0: kHz
1: MHz</comment>
        </bits>
        <bits access="r" name="timeout_clk_frq" pos="5:0" rst="0x0">
          <comment>This bit shows the base clock frequency used to detect Data Timeout Error.
0: get information via another method
1: 1 MHz
2: 2 MHz

63: 63 MHz</comment>
        </bits>
      </reg>
      <reg name="cap2" protect="rw">
        <comment>Capabilities 2</comment>
        <bits access="r" name="adma3_support" pos="27" rst="0x1">
          <comment>ADMA3 is support</comment>
        </bits>
        <bits access="r" name="ddr50_sup" pos="2" rst="0x1">
          <comment>DDR50 Support
1b0: DDR50 is Supported</comment>
        </bits>
        <bits access="r" name="sdr104_sup" pos="1" rst="0x1">
          <comment>SDR104 Support
1b0 : SDR104 is  Supported</comment>
        </bits>
        <bits access="r" name="sdr50_sup" pos="0" rst="0x1">
          <comment>SDR50 Support
1b0: SDR50 is Supported</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="frc_evt" protect="rw">
        <comment>Force event register</comment>
        <bits access="w" name="frc_evt_acmd_err" pos="27" rst="0x0">
          <comment>Force Event for Auto CMD Error</comment>
        </bits>
        <bits access="w" name="frc_evt_tun_err" pos="25" rst="0x0">
          <comment>Force Event for tuning Error</comment>
        </bits>
        <bits access="w" name="frc_evt_resp_err" pos="24" rst="0x0">
          <comment>Force Event for Response Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_dat_end" pos="22" rst="0x0">
          <comment>Force Event for Data End Bit Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_dat_crc" pos="21" rst="0x0">
          <comment>Force Event for Data CRC Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_dat_tout" pos="20" rst="0x0">
          <comment>Force Event for Data Timeout Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_ind" pos="19" rst="0x0">
          <comment>Force Event for Command Index Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_end" pos="18" rst="0x0">
          <comment>Force Event for Command End Bit Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_crc" pos="17" rst="0x0">
          <comment>Force Event for Command CRC Error</comment>
        </bits>
        <bits access="w" name="frc_evt_cmd_tout" pos="16" rst="0x0">
          <comment>Force Event for Command Time Out Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd12" pos="7" rst="0x0">
          <comment>Force Event for Command Not Issued By Auto CMD12 Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd_ind" pos="4" rst="0x0">
          <comment>Force Event for Auto CMD Index Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd_end" pos="3" rst="0x0">
          <comment>Force Event for Auto CMD End Bit Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd_crc" pos="2" rst="0x0">
          <comment>Force Event for Auto CMD Timeout Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd_tout" pos="1" rst="0x0">
          <comment>Force Event for Auto CMD Timeout Error</comment>
        </bits>
        <bits access="w" name="frc_evt_acmd_nexec" pos="0" rst="0x0">
          <comment>Force Event for Auto CMD 12 Not Executed
1: Interrupt is generated
0: No Interrupt</comment>
        </bits>
      </reg>
      <reg name="adma_err_sts" protect="rw">
        <comment>ADMA Error State register</comment>
        <bits access="r" name="bresp_err" pos="19:18" rst="0x0">
          <comment>If BRESP = SLVERR or DECERR, then BRESP_ERR is occurred, and this register will indicted the type of Error.
00: OKAY
01: EXOKAY
10: SLVERR
11: DECERR</comment>
        </bits>
        <bits access="r" name="rresp_err" pos="17:16" rst="0x0">
          <comment>If RRESP = SLVERR or DECERR, then RRESP_ERR is occurred, and this register will indicted the type of Error.
00: OKAY
01: EXOKAY
10: SLVERR
11: DECERR</comment>
        </bits>
        <bits access="r" name="adma_length_mismatch" pos="2" rst="0x0">
          <comment>ADMA Length Mismatch Error
1: Error
0: No Error
This error occurs in the following 2 cases:
1) While Block Count Enable being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length
2) Total data length cannot be divided by the block length.</comment>
        </bits>
        <bits access="r" name="adma_err_state" pos="1:0" rst="0x0">
          <comment>ADMA Error State
This field indicates the state of ADMA when error is occurred during ADMA data transfer.
2b00: ST_STOP (Stop DMA), Points next of the error descriptor.
2b01: ST_FDS (Fetch Descriptor), Points the error descriptor
2b10:  Reserved
2b11: ST_TFR (Transfer Data), Points the next of the error descriptor</comment>
        </bits>
      </reg>
      <reg name="adma2_addr_l" protect="rw">
        <comment>ADMA2 System Address Low registers</comment>
      </reg>
      <reg name="adma2_addr_h" protect="rw">
        <comment>ADMA2 System Address High registers</comment>
      </reg>
      <hole size="192"/>
      <reg name="adma3_addr_l" protect="rw">
        <comment>ADMA3 System Address Low registers</comment>
      </reg>
      <reg name="adma3_addr_h" protect="rw">
        <comment>ADMA3 System Address High registers</comment>
      </reg>
      <hole size="992"/>
      <reg name="host_ver" protect="rw">
        <comment>Host version number</comment>
        <bits access="r" name="host_ver" pos="23:16" rst="0x4">
          <comment>This status indicates the Host Controller Spec Version. The upper and lower 4 bits indicate the version.
00: SD Host Specification version 1.0
01 SD Host Specification Version 2.0
02 SD Host Specification Version 3.0
03 SD Host Specification Version 4.0
04 SD Host Specification Version 4.1
Others: reserved</comment>
        </bits>
        <bits access="r" name="slt1_int" pos="0" rst="0x0">
          <comment>One slot, it is equal to the int_to_arm</comment>
        </bits>
      </reg>
      <hole size="2048"/>
      <reg name="dll_cfg" protect="rw">
        <comment>EMMC PHY DLL CFG registers</comment>
        <bits access="r" name="dll_wait_cnt" pos="31:28" rst="0x4">
          <comment>Cycles to wait DLL locked signals.</comment>
        </bits>
        <bits access="rw" name="dll_rdneg_cpst_en" pos="27" rst="0x0">
          <comment>Read negedge delay cell  select
0:use user defined value from CLKNEGRD_DLY_ VAL
1:use dll generated value which referenced form CLKNEGRD_DLY_ VAL</comment>
        </bits>
        <bits access="rw" name="dll_rdpos_cpst_en" pos="26" rst="0x0">
          <comment>Read posedge delay cell  select
0:use user defined value from CLKPOSRD_DLY_VAL
1:use dll generated value which referenced form CLKPOSRD_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="dll_rdcmd_cpst_en" pos="25" rst="0x0">
          <comment>Read cmd delay cell  select
0:use user defined value from CLKCMDRD_DLY_VAL
1:use dll generated value which referenced form CLKCMDRD_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="dll_datwr_cpst_en" pos="24" rst="0x0">
          <comment>write delay cell  select
0:use user defined value from CLKDATWR_DLY_VAL
1:use dll generated value which referenced form CLKDATWR_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="dll_clk_sel" pos="22" rst="0x0">
          <comment>DLL Clock source selection
0: Select 1x clock
1: Select 2x clock</comment>
        </bits>
        <bits access="rw" name="dll_en" pos="21" rst="0x0">
          <comment>DLL enable signal
0:DLL disable
1:DLL enable</comment>
        </bits>
        <bits access="rw" name="dll_clr" pos="20" rst="0x0">
          <comment>DLL clear signal
1:clear DLL</comment>
        </bits>
        <bits access="rw" name="dll_auto_clr_en" pos="19" rst="0x0">
          <comment>Dont  support in this version</comment>
        </bits>
        <bits access="rw" name="dll_cpst_en" pos="18" rst="0x0">
          <comment>DLL output delay value enable</comment>
        </bits>
        <bits access="rw" name="dll_cpst_start" pos="17" rst="0x0">
          <comment>DLL start enable signal, this bit should be write to 1b0 when it is enabled to 1b1</comment>
        </bits>
        <bits access="rw" name="dll_half_mode" pos="16" rst="0x0">
          <comment>DLL lock mode:
0: full cycle lock mode
1: half cycle lock mode</comment>
        </bits>
        <bits access="rw" name="dll_init" pos="14:8" rst="0x1">
          <comment>DLL count initial value, DLL use it as the initial value to count the delay value.</comment>
        </bits>
        <bits access="rw" name="dll_cpst_threshold" pos="7:4" rst="0x0">
          <comment>DLL  change  threshold value, DLL update rd/wr/cmd delay line value if the DLL count delta bigger then DLL_CPST_THRESHOLD</comment>
        </bits>
        <bits access="rw" name="dll_phase_interval" pos="2:1" rst="0x0">
          <comment>DLL phase interval , DLL use it as the interval of phase 1 and phase2</comment>
        </bits>
        <bits access="rw" name="clk_phase_sel" pos="0" rst="0x0">
          <comment>OUPUT clock phase select</comment>
        </bits>
      </reg>
      <reg name="dll_dly" protect="rw">
        <comment>EMMC PHY DLL DLY registers</comment>
        <bits access="rw" name="clknegrd_dly_val" pos="31:24" rst="0x0">
          <comment>Clock Read Data Negedge Delay Value
Based Phase is same as PHY Clock
Refer to description of CLKDATWR_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="clkposrd_dly_val" pos="23:16" rst="0x0">
          <comment>Clock Read Data Posedge Delay Value
Based Phase is same as PHY Clock
Refer to description of CLKDATWR_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="clkcmdrd_dly_val" pos="15:8" rst="0x0">
          <comment>Clock Read Command Line Delay Value
Based Phase is same as PHY Clock
Refer to description of CLKDATWR_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="clkdatwr_dly_val" pos="7:0" rst="0x0">
          <comment>Clock Data Write Line Delay Value
Based Phase is invert of PHY Clock
When DLL_DATWR_CPST_EN is enable,
This register is act as proportion of DLL clock cycle.
E.g.(when DLL_DATWR _CPST_EN==1)
If CLKDATWR _DLY_ VAL ==h40, it means delay h40/h100  1/4  cycle.
If CLKDATWR_DLY_ VAL ==h80, it means delay h80/h100F  1/2  cycle.</comment>
        </bits>
      </reg>
      <reg name="dll_dly_offset" protect="rw">
        <comment>EMMC PHY DLL Offset Read registers</comment>
        <bits access="rw" name="clknegrd_dly_inv" pos="29" rst="0x0">
          <comment>Clock Read Data Negedge Delay Invert</comment>
        </bits>
        <bits access="rw" name="clknegrd_dly_offset" pos="28:24" rst="0x0">
          <comment>Refer to description of CLKDATWR_DLY_OFFSET</comment>
        </bits>
        <bits access="rw" name="clkposrd_dly_inv" pos="21" rst="0x0">
          <comment>Clock Read Data Posedge Delay Invert</comment>
        </bits>
        <bits access="rw" name="clkposrd_dly_offset" pos="20:16" rst="0x0">
          <comment>Refer to description of CLKDATWR_DLY_OFFSET</comment>
        </bits>
        <bits access="rw" name="clkcmdrd_dly_inv" pos="13" rst="0x0">
          <comment>Clock Read Command Line Delay Invert</comment>
        </bits>
        <bits access="rw" name="clkcmdrd_dly_offset" pos="12:8" rst="0x0">
          <comment>Refer to description of CLKDATWR_DLY_OFFSET</comment>
        </bits>
        <bits access="rw" name="clkdatwr_dly_inv" pos="5" rst="0x0">
          <comment>Clock Data Write Line Delay Invert</comment>
        </bits>
        <bits access="rw" name="clkdatwr_dly_offset" pos="4:0" rst="0x0">
          <comment>Data Write Delay offset. The highest bit indicates if it is add or sub.
OFFSET [4]=0:  CLKDATWR_DLY_VAL + OFFSET [3:0]
OFFSET [4]=1:  CLKDATWR_DLY_VAL  OFFSET [3:0].
If DLL_DATWR _CPST_EN==1, the offset is added after the proportion.
E.g. If
Clock cycle (CYC)== 5ns
CLKDATWR _DLY_ VAL (VAL) ==h40, CLKDATWR_DLY_OFFSET (OFSET) == h6,
DLL_CNT(CNT) == h20
 it means delay:
(VAL/h100)*CYC + (CYC * OFSET) / CN =
 (h40/h100)*5ns + (5ns * h6) / h20 2.2ns</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="dll_sts0" protect="rw">
        <comment>EMMC PHY DLL STS0 registers</comment>
        <bits access="r" name="dll_phase1" pos="20" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_phase2" pos="19" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_locked" pos="18" rst="0x0">
          <comment>If use DLL, software should wait this value to 1b1</comment>
        </bits>
        <bits access="r" name="dll_error" pos="17" rst="0x0">
          <comment>If use DLL, soft ware should wait DLL_LOCKED to 1b1 and  at that time ,this bit is 1b0</comment>
        </bits>
        <bits access="r" name="dll_cpst_st" pos="16" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_st" pos="11:8" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_cnt" pos="7:0" rst="0x0">
          <comment>DLL delay cell counts of 1 cycle</comment>
        </bits>
      </reg>
      <reg name="dll_sts1" protect="rw">
        <comment>EMMC PHY DLL STS1 registers</comment>
        <bits access="r" name="clknegrd_dly_cnt" pos="31:24" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="clkposrd_dly_cnt" pos="23:16" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="clkcmdrd_dly_cnt" pos="15:8" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="clkdatwr_dly_cnt" pos="7:0" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="ram_addr_buf_l" protect="rw">
        <comment>EMMC Buffer Processing System Low address</comment>
      </reg>
      <reg name="ram_addr_buf_h" protect="rw">
        <comment>EMMC Buffer Processing System High address</comment>
      </reg>
      <reg name="blk_cnt_buf" protect="rw">
        <comment>EMMC Buffer Processing Block Count</comment>
      </reg>
      <reg name="blk_cnt_io" protect="rw">
        <comment>EMMC IO Processing Block Count</comment>
      </reg>
      <hole size="128"/>
      <reg name="adma2_addr_ing_l" protect="rw">
        <comment>EMMC Processing ADMA2 Low address</comment>
      </reg>
      <reg name="adma2_addr_ing_h" protect="rw">
        <comment>EMMC Processing ADMA2 High address</comment>
      </reg>
      <reg name="adma3_addr_ing_l" protect="rw">
        <comment>EMMC Processing ADMA3 Low address</comment>
      </reg>
      <reg name="adma3_addr_ing_h" protect="rw">
        <comment>EMMC Processing ADMA3 High address</comment>
      </reg>
      <reg name="busy_posi" protect="rw">
        <comment>EMMC Busy/CRC Status Position registers</comment>
        <bits access="rw" name="outr_clk_auto_en" pos="25" rst="0x0">
          <comment>Control the Output clock SD_CLK auto gating
0: disable auto gating
1: enable auto gating</comment>
        </bits>
        <bits access="rw" name="innr_clk_auto_en" pos="24" rst="0x0">
          <comment>Control the internal clock auto gating
0: disable auto gating
1: enable auto gating</comment>
        </bits>
        <bits access="rw" name="crcsts_posi_sts" pos="23:20" rst="0x6">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="rw" name="read_busy_posi_sts" pos="19:16" rst="0xa">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="rw" name="abort_bug_option" pos="15" rst="0x1">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="rw" name="mstrs_prot" pos="14:12" rst="0x0">
          <comment>Master PROT attributes.
It directly maps to the AXI master bus. AWPROT_emmc and ARPROT_emmc port.</comment>
        </bits>
        <bits access="rw" name="sdcard_clk_oe" pos="11" rst="0x1">
          <comment>Control the Output enable of clock SD_CLK
0: Clock OE is 0
1: Clock OE is 1</comment>
        </bits>
        <bits access="rw" name="sdcard_clk_ie" pos="10" rst="0x0">
          <comment>Control the Input enable of clock SD_CLK,
0: Clock IE is 0
1: Clock IE is 1</comment>
        </bits>
        <bits access="rw" name="crcsts_posi_force" pos="9" rst="0x0">
          <comment>CRC Status Position Force Enable
0: use default value
1: use CRCSTS_POSI value
(Debug or designer set only)</comment>
        </bits>
        <bits access="rw" name="read_busy_posi_force" pos="8" rst="0x0">
          <comment>Read Busy Position Force Enable
0: use default value
1: use READ_BUSY_POSI value
(Debug or designer set only)</comment>
        </bits>
        <bits access="rw" name="crcsts_posi_set" pos="7:4" rst="0x0">
          <comment>CRC Status Position Adjustment
This register can adjust the sample position of CRC status, the need of this register is because of the HS200 or HS400 read data or CRC status may delay more cycles than legacy mode
When CRCSTS_POSI_FORCE is set 1 this register is valid, else the actual value is used internal set value.</comment>
        </bits>
        <bits access="rw" name="read_busy_posi_set" pos="3:0" rst="0x0">
          <comment>Read Busy Position Adjustment
This register can adjust the sample position of read busy, the need of this register is because of the HS200 or HS400 read data or CRC status may delay more cycles than legacy mode.
When controller is read busy, the moment of stopping clock may be adjust through this register.
When READ_BUSY_POSI_FORCE is set 1 this register is valid, else the actual value is used internal set value.</comment>
        </bits>
      </reg>
      <reg name="fsm_crcerr_sts" protect="rw">
        <comment>EMMC CRC Error Status registers</comment>
        <bits access="r" name="rdata_crc_error" pos="15:0" rst="0x0">
          <comment>(Debug only)
Bit[15] : Neg 7
Bit[14] : neg 6
Bit[13] : neg 5
Bit[12] : neg 4
Bit[11] : neg 3
Bit[10] : neg 2
Bit[9] : neg 1
Bit[8] : neg 0
Bit[7] : pos 7
Bit[6] : pos 6
Bit[5] : pos 5
Bit[4] : pos 4
Bit[3] : pos 3
Bit[2] : pos 2
Bit[1] : pos 1
Bit[0] : pos 0
The BIT[15:8] just used in DDR mode.</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="fsm_debug0" protect="rw">
        <comment>EMMC FSM Debug0 register</comment>
        <bits access="r" name="clk_pad_out_ind" pos="31" rst="0x0">
          <comment>This bit indicate whether the pad clock is working or stop.
0: clock is stopped.
1: clock is working</comment>
        </bits>
        <bits access="r" name="recv_fsm" pos="19:16" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="trans_fsm" pos="13:8" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="cmd_fsm" pos="4:0" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
      </reg>
      <reg name="fsm_debug1" protect="rw">
        <comment>EMMC FSM Debug1 register</comment>
        <bits access="r" name="adma3_fsm" pos="15:12" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="adma2_fsm" pos="11:9" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="mst_fsm" pos="7:4" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="io_fsm" pos="3:0" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
      </reg>
      <reg name="fsm_debug2" protect="rw">
        <comment>EMMC FSM Debug2 register</comment>
        <bits access="r" name="data_fsm" pos="7:4" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
        <bits access="r" name="addr_fsm" pos="3:0" rst="0x0">
          <comment>(Debug only)</comment>
        </bits>
      </reg>
      <hole size="256"/>
      <reg name="dll_backup" protect="rw">
        <comment>DLL USED BACKUP SIGNAL</comment>
        <bits access="rw" name="oe_ext_optional" pos="4" rst="0x0">
          <comment>Oe_ext_optional( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_slice_en_value" pos="3" rst="0x0">
          <comment>Force slice en value( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_slice_en_force" pos="2" rst="0x0">
          <comment>Force slice enable( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_backup_value" pos="1" rst="0x1">
          <comment>Force dll use backup mode value( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_backup" pos="0" rst="0x0">
          <comment>Force dll use backup mode( Reserved  for  vender asic only)</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04006000" name="EMMC" type="EMMC"/>
  </archive>
  <archive relative="gpt_lite.xml">
    <module category="System" name="GPT_LITE">
      <reg name="cr" protect="rw">
        <comment/>
        <bits access="rw" name="refclk_sel" pos="31" rst="0x1">
          <comment>refclk_sel</comment>
        </bits>
        <bits access="rw" name="tri_cnt_en" pos="12" rst="0x0">
          <comment>Input triger number count enable</comment>
        </bits>
        <bits access="rw" name="tri" pos="11:9" rst="0x0">
          <comment>slave_mode trigger select</comment>
        </bits>
        <bits access="rw" name="arpe" pos="8" rst="0x1">
          <comment>auto preload value</comment>
        </bits>
        <bits access="rw" name="cms" pos="7:6" rst="0x0">
          <comment>Center-aligned mode select 00: disable , other:enable</comment>
        </bits>
        <bits access="rw" name="dir" pos="5" rst="0x0">
          <comment>counter dir , 0: cnt ++ , 1: cnt --</comment>
        </bits>
        <bits access="rw" name="opm" pos="4" rst="0x0">
          <comment>one pulse mode,  0:disable 1:enable</comment>
        </bits>
        <bits access="rw" name="udis" pos="3" rst="0x0">
          <comment>update disable, 0:disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="ckd" pos="2:1" rst="0x0">
          <comment>clock fdts didiver, 01: divided by 2 10:divided by 4, other:bypass</comment>
        </bits>
        <bits access="rw" name="cen" pos="0" rst="0x0">
          <comment>counter enable, 0: disbale, 1:enable</comment>
        </bits>
      </reg>
      <reg name="smcr" protect="rw">
        <comment/>
        <bits access="rw" name="sms" pos="2:0" rst="0x0">
          <comment>slave mode select: 100: slave mode, 101:gate mode, 110:trig mode, others disable</comment>
        </bits>
      </reg>
      <reg name="egr" protect="rw">
        <comment/>
        <bits access="r" name="ug" pos="0" rst="0x0">
          <comment>bit type is changed from w1c to rc. user trigger gen</comment>
        </bits>
      </reg>
      <reg name="ccmr_oc" protect="rw">
        <comment/>
        <bits access="rw" name="oc2ce" pos="15" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc2m" pos="14:12" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc2pe" pos="11" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc2fe" pos="10" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc2s" pos="9:8" rst="0x0">
          <comment>channel source sel, bit[9] 0: output enable, 1 output disable bit[8] 0: use ti2, 1: use ti1</comment>
        </bits>
        <bits access="rw" name="oc1ce" pos="7" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="oc1m" pos="6:4" rst="0x0">
          <comment>output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2</comment>
        </bits>
        <bits access="rw" name="oc1pe" pos="3" rst="0x0">
          <comment>compare value preload 0: disable, 1:enable</comment>
        </bits>
        <bits access="rw" name="oc1fe" pos="2" rst="0x0">
          <comment>no used yet</comment>
        </bits>
        <bits access="rw" name="cc1s" pos="1:0" rst="0x0">
          <comment>channel source sel, bit[0] 0: output enable, 1 output disable bit[1] 0: use ti2, 1: use ti1</comment>
        </bits>
      </reg>
      <reg name="ccmr_ic" protect="rw">
        <comment/>
        <bits access="rw" name="ic2f" pos="13:10" rst="0x0">
          <comment>ti2 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic2psc" pos="9:8" rst="0x0">
          <comment>ti2 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
        <bits access="rw" name="ic1f" pos="5:2" rst="0x0">
          <comment>ti1 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,</comment>
        </bits>
        <bits access="rw" name="ic1psc" pos="1:0" rst="0x0">
          <comment>ti1 prescale, 01:0 div2, 10: div4, others: bypass</comment>
        </bits>
      </reg>
      <reg name="ccer" protect="rw">
        <comment/>
        <bits access="rw" name="cc2p" pos="3" rst="0x0">
          <comment>ti2 polarity</comment>
        </bits>
        <bits access="rw" name="cc2e" pos="2" rst="0x0">
          <comment>ti2 enable</comment>
        </bits>
        <bits access="rw" name="cc1p" pos="1" rst="0x0">
          <comment>ti1 polarity</comment>
        </bits>
        <bits access="rw" name="cc1e" pos="0" rst="0x0">
          <comment>ti1 enable</comment>
        </bits>
      </reg>
      <reg name="cnt" protect="rw">
        <comment/>
        <bits access="r" name="cnt_value" pos="15:0" rst="0x0">
          <comment>cnt_value</comment>
        </bits>
      </reg>
      <reg name="psc" protect="rw">
        <comment/>
        <bits access="rw" name="psc_value" pos="15:0" rst="0x0">
          <comment>cnt prescale value</comment>
        </bits>
      </reg>
      <reg name="arr" protect="rw">
        <comment/>
        <bits access="rw" name="arr_value" pos="15:0" rst="0xffff">
          <comment>cnt max value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr1_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr1_capture" pos="15:0" rst="0xffff">
          <comment>ic1 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr2_ic" protect="rw">
        <comment/>
        <bits access="r" name="timer_ccr2_capture" pos="15:0" rst="0xffff">
          <comment>ic2 capture value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr1_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr1_compare" pos="15:0" rst="0xffff">
          <comment>ic1 compare value</comment>
        </bits>
      </reg>
      <reg name="timer_ccr2_oc" protect="rw">
        <comment/>
        <bits access="rw" name="timer_ccr2_compare" pos="15:0" rst="0xffff">
          <comment>ic2 compare value</comment>
        </bits>
      </reg>
      <reg name="isr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="irsr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="mask" protect="rw">
        <comment/>
        <bits access="rw" name="event_update" pos="31" rst="0x0">
          <comment>cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="rw" name="slave_trig" pos="30" rst="0x0">
          <comment>trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="rw" name="capture_int" pos="15:12" rst="0x0"/>
        <bits access="rw" name="compare_int" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="clr" protect="rw">
        <comment/>
        <bits access="r" name="event_update" pos="31" rst="0x0">
          <comment>bit type is changed from w1c to rc. cnt reach max when dir = 0, cnt reach zeror when dir = 1</comment>
        </bits>
        <bits access="r" name="slave_trig" pos="30" rst="0x0">
          <comment>bit type is changed from w1c to rc. trig gens,  when counter works in slave mode</comment>
        </bits>
        <bits access="r" name="capture_int" pos="15:12" rst="0x0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="r" name="compare_int" pos="3:0" rst="0x0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04809000" name="AP_GPT_LITE" type="GPT_LITE"/>
    <instance address="0x5150d000" name="LPS_GPT_LITE" type="GPT_LITE"/>
  </archive>
  <archive relative="med.xml">
    <module category="System" name="MED">
      <reg name="med_ch0_work_cfg" protect="rw">
        <comment>med_ch0_work_cfg</comment>
        <bits access="rw" name="med_ch0_bypass_en" pos="4" rst="0x0">
          <comment>1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption</comment>
        </bits>
        <bits access="rw" name="med_ch0_enable" pos="0" rst="0x0">
          <comment>1:enable ch0;     0:disable ch0;</comment>
        </bits>
      </reg>
      <reg name="med_ch0_base_addr_cfg" protect="rw">
        <comment>med_ch0_base_addr_cfg</comment>
        <bits access="rw" name="med_ch0_base_addr" pos="31:5" rst="0x0">
          <comment>the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000</comment>
        </bits>
      </reg>
      <reg name="med_ch0_addr_size_cfg" protect="rw">
        <comment>med_ch0_addr_size_cfg</comment>
        <bits access="rw" name="med_ch0_addr_size" pos="23:5" rst="0x0">
          <comment>the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF</comment>
        </bits>
      </reg>
      <reg name="med_ch0_read_addr_remap" protect="rw">
        <comment>med_ch0_read_addr_remap</comment>
        <bits access="rw" name="med_ch0_remap_read_addr" pos="31:5" rst="0x0">
          <comment>the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024</comment>
        </bits>
      </reg>
      <hole size="128"/>
      <reg name="med_ch1_work_cfg" protect="rw">
        <comment>med_ch1_work_cfg</comment>
        <bits access="rw" name="med_ch1_bypass_en" pos="4" rst="0x0">
          <comment>1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption</comment>
        </bits>
        <bits access="rw" name="med_ch1_enable" pos="0" rst="0x0">
          <comment>1:enable ch1;    0:disable ch1;</comment>
        </bits>
      </reg>
      <reg name="med_ch1_base_addr_cfg" protect="rw">
        <comment>med_ch1_base_addr_cfg</comment>
        <bits access="rw" name="med_ch1_base_addr" pos="31:5" rst="0x0">
          <comment>the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000</comment>
        </bits>
      </reg>
      <reg name="med_ch1_addr_size_cfg" protect="rw">
        <comment>med_ch1_addr_size_cfg</comment>
        <bits access="rw" name="med_ch1_addr_size" pos="23:5" rst="0x0">
          <comment>the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF</comment>
        </bits>
      </reg>
      <reg name="med_ch1_read_addr_remap" protect="rw">
        <comment>med_ch1_read_addr_remap</comment>
        <bits access="rw" name="med_ch1_remap_read_addr" pos="31:5" rst="0x0">
          <comment>the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024</comment>
        </bits>
      </reg>
      <hole size="128"/>
      <reg name="med_ch2_work_cfg" protect="rw">
        <comment>med_ch2_work_cfg</comment>
        <bits access="rw" name="med_ch2_bypass_en" pos="4" rst="0x0">
          <comment>1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption</comment>
        </bits>
        <bits access="rw" name="med_ch2_enable" pos="0" rst="0x0">
          <comment>1:enable ch2;    0:disable ch2;</comment>
        </bits>
      </reg>
      <reg name="med_ch2_base_addr_cfg" protect="rw">
        <comment>med_ch2_base_addr_cfg</comment>
        <bits access="rw" name="med_ch2_base_addr" pos="31:5" rst="0x0">
          <comment>the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000</comment>
        </bits>
      </reg>
      <reg name="med_ch2_addr_size_cfg" protect="rw">
        <comment>med_ch2_addr_size_cfg</comment>
        <bits access="rw" name="med_ch2_addr_size" pos="23:5" rst="0x0">
          <comment>the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF</comment>
        </bits>
      </reg>
      <reg name="med_ch2_read_addr_remap" protect="rw">
        <comment>med_ch2_read_addr_remap</comment>
        <bits access="rw" name="med_ch2_remap_read_addr" pos="31:5" rst="0x0">
          <comment>the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024</comment>
        </bits>
      </reg>
      <hole size="128"/>
      <reg name="med_ch3_work_cfg" protect="rw">
        <comment>med_ch3_work_cfg</comment>
        <bits access="rw" name="med_ch3_bypass_en" pos="4" rst="0x0">
          <comment>1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption</comment>
        </bits>
        <bits access="rw" name="med_ch3_enable" pos="0" rst="0x0">
          <comment>1:enable ch3;    0:disable ch3;</comment>
        </bits>
      </reg>
      <reg name="med_ch3_base_addr_cfg" protect="rw">
        <comment>med_ch3_base_addr_cfg</comment>
        <bits access="rw" name="med_ch3_base_addr" pos="31:5" rst="0x0">
          <comment>the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000</comment>
        </bits>
      </reg>
      <reg name="med_ch3_addr_size_cfg" protect="rw">
        <comment>med_ch3_addr_size_cfg</comment>
        <bits access="rw" name="med_ch3_addr_size" pos="23:5" rst="0x0">
          <comment>the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF</comment>
        </bits>
      </reg>
      <reg name="med_ch3_read_addr_remap" protect="rw">
        <comment>med_ch3_read_addr_remap</comment>
        <bits access="rw" name="med_ch3_remap_read_addr" pos="31:5" rst="0x0">
          <comment>the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024</comment>
        </bits>
      </reg>
      <hole size="1024"/>
      <reg name="med_write_addr_remap" protect="rw">
        <comment>med_write_addr_remap</comment>
        <bits access="rw" name="med_remap_write_addr" pos="31:5" rst="0x0">
          <comment>the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu write address is 0x1000_0024,then after med , then address is  is 0x2000_0024</comment>
        </bits>
      </reg>
      <reg name="med_write_base_addr_cfg" protect="rw">
        <comment>med_write_base_addr_cfg</comment>
        <bits access="rw" name="med_write_base_addr" pos="31:5" rst="0x0">
          <comment>the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000</comment>
        </bits>
      </reg>
      <reg name="med_write_addr_size_cfg" protect="rw">
        <comment>med_write_addr_size_cfg</comment>
        <bits access="rw" name="med_write_addr_size" pos="23:5" rst="0x0">
          <comment>the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="med_clr" protect="rw">
        <comment>med_clr</comment>
        <bits access="rc" name="med_write_cnt_clr" pos="5" rst="0x0">
          <comment>1:active,clear the 0x118 address bit31~bit12;</comment>
        </bits>
        <bits access="rc" name="med_simon_clr" pos="4" rst="0x0">
          <comment>1:active,clear the simon core</comment>
        </bits>
        <bits access="rc" name="med_write_ram_clr" pos="1" rst="0x0">
          <comment>1:active,clear the med inner write ram</comment>
        </bits>
        <bits access="rc" name="med_read_ram_clr" pos="0" rst="0x0">
          <comment>1:active,clear the med inner read ram</comment>
        </bits>
      </reg>
      <reg name="med_work_mode" protect="rw">
        <comment>med_work_mode</comment>
        <bits access="rw" name="med_clk_force_on" pos="16" rst="0x0">
          <comment>can force the med clk gate always on, then the clk  freerun</comment>
        </bits>
        <bits access="rw" name="med_write_bus_error_en" pos="10" rst="0x0">
          <comment>when the med send cmd to write flash data, and the slave happen bus error, then the med will back the slave bus error to master.</comment>
        </bits>
        <bits access="rw" name="med_read_bus_error_en" pos="9" rst="0x0">
          <comment>when the med send cmd to read flash data, and the slave happen bus error, then the med will back the slave bus error to master.</comment>
        </bits>
        <bits access="rw" name="med_bus_error_en" pos="8" rst="0x0">
          <comment>enable the med module ahb bus error,when the master access to med, and the access address is error, the med will generate the buss error to master.</comment>
        </bits>
        <bits access="rw" name="med_key_iv_sel" pos="0" rst="0x0">
          <comment>1:sel the key from efuse,                               0: key from soft ware</comment>
        </bits>
      </reg>
      <reg name="med_int_en" protect="rw">
        <comment>med_int_en</comment>
        <bits access="rw" name="med_addr_err_int_en" pos="6" rst="0x0">
          <comment>enable med ahb addr out of range all channel</comment>
        </bits>
        <bits access="rw" name="med_err_resp_int_en" pos="5" rst="0x0">
          <comment>enable med error response int</comment>
        </bits>
        <bits access="rw" name="med_ch3_dis_addr_vld_int_en" pos="4" rst="0x0">
          <comment>enable med channel3 addr error int</comment>
        </bits>
        <bits access="rw" name="med_ch2_dis_addr_vld_int_en" pos="3" rst="0x0">
          <comment>enable med channel2 addr error int</comment>
        </bits>
        <bits access="rw" name="med_ch1_dis_addr_vld_int_en" pos="2" rst="0x0">
          <comment>enable med channel1 addr error int</comment>
        </bits>
        <bits access="rw" name="med_ch0_dis_addr_vld_int_en" pos="1" rst="0x0">
          <comment>enable med channel0 addr error int</comment>
        </bits>
        <bits access="rw" name="med_wr_done_int_en" pos="0" rst="0x0">
          <comment>enable med write done int</comment>
        </bits>
      </reg>
      <reg name="med_int_raw" protect="rw">
        <comment>emd_int_raw</comment>
        <bits access="r" name="med_addr_err_int_raw" pos="6" rst="0x0">
          <comment>med ahb addr out of range all channel status</comment>
        </bits>
        <bits access="r" name="med_err_resp_int_raw" pos="5" rst="0x0">
          <comment>med error response int status</comment>
        </bits>
        <bits access="r" name="med_ch3_dis_addr_vld_int_raw" pos="4" rst="0x0">
          <comment>med channel3 addr error int status</comment>
        </bits>
        <bits access="r" name="med_ch2_dis_addr_vld_int_raw" pos="3" rst="0x0">
          <comment>med channel2 addr error int status</comment>
        </bits>
        <bits access="r" name="med_ch1_dis_addr_vld_int_raw" pos="2" rst="0x0">
          <comment>med channel1 addr error int status</comment>
        </bits>
        <bits access="r" name="med_ch0_dis_addr_vld_int_raw" pos="1" rst="0x0">
          <comment>med channel0 addr error int status</comment>
        </bits>
        <bits access="r" name="med_wr_done_int_raw" pos="0" rst="0x0">
          <comment>med write done int status</comment>
        </bits>
      </reg>
      <reg name="med_int_clear" protect="rw">
        <comment>med_int_clear</comment>
        <bits access="rc" name="med_addr_err_int_clr" pos="6" rst="0x0">
          <comment>clear med ahb addr out of range all channel status</comment>
        </bits>
        <bits access="rc" name="med_err_resp_int_clr" pos="5" rst="0x0">
          <comment>clear med error response int</comment>
        </bits>
        <bits access="rc" name="med_ch3_dis_addr_vld_int_clr" pos="4" rst="0x0">
          <comment>clear med channel3 addr error int</comment>
        </bits>
        <bits access="rc" name="med_ch2_dis_addr_vld_int_clr" pos="3" rst="0x0">
          <comment>clear med channel2 addr error int</comment>
        </bits>
        <bits access="rc" name="med_ch1_dis_addr_vld_int_clr" pos="2" rst="0x0">
          <comment>clear med channel1 addr error int</comment>
        </bits>
        <bits access="rc" name="med_ch0_dis_addr_vld_int_clr" pos="1" rst="0x0">
          <comment>clear med channel0 addr error int</comment>
        </bits>
        <bits access="rc" name="med_wr_done_int_clr" pos="0" rst="0x0">
          <comment>clear med  write done int</comment>
        </bits>
      </reg>
      <reg name="med_error_addr" protect="rw">
        <comment>med_error_addr</comment>
      </reg>
      <reg name="med_status0" protect="rw">
        <comment>med_status0</comment>
        <bits access="r" name="med_write_word_cnt" pos="31:12" rst="0x0"/>
        <bits access="r" name="med_wr_busy" pos="5" rst="0x0"/>
        <bits access="r" name="med_rd_busy" pos="4" rst="0x0"/>
        <bits access="r" name="med_work_busy" pos="3" rst="0x0"/>
        <bits access="r" name="med_mster_ahb_hready" pos="2" rst="0x1"/>
        <bits access="r" name="med_mster_slv_hready" pos="1" rst="0x1"/>
        <bits access="r" name="med_simon_odata_ready" pos="0" rst="0x1"/>
      </reg>
      <reg name="med_status1" protect="rw">
        <comment>med_status1</comment>
      </reg>
      <reg name="med_status2" protect="rw">
        <comment>med_status2</comment>
      </reg>
      <reg name="med_status3" protect="rw">
        <comment>med_status3</comment>
      </reg>
      <reg name="med_soft_key" protect="rw">
        <comment>med_soft_key</comment>
      </reg>
    </module>
    <instance address="0x04000000" name="MED" type="MED"/>
  </archive>
  <archive relative="ap_spi.xml">
    <module category="System" name="AP_SPI">
      <reg name="spi_txd" protect="rw">
        <comment>Transmit word or Receive word Write data to this address initiates a character transmission through TX FIFO
Read this address retrieve data from RX fifo</comment>
      </reg>
      <reg name="spi_clkd" protect="rw">
        <comment>Clock divisor  Clock divisor bit 0 to 15</comment>
        <bits access="rw" name="spi_clkd" pos="15:0" rst="0x3">
          <comment>Specify the clock ratio between spi_sck and clk_spi.
If clk_spi runs at 48 MHz, and spi_sck runs at 12MHz, SPI_CLKD should be 1,
spi_sck = clk_spi/2(n+1).
If IS_FST bit is assert, the valid SPI_CLKD is 0, 1, 2 and 3.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl0" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="sync_3wrd_pol" pos="15" rst="0x0">
          <comment>Sync_polarity, positive or negative pulse for SPI or 3-wire mode ,read command polarity</comment>
        </bits>
        <bits access="rw" name="sync_md" pos="14" rst="0x0">
          <comment>1 : sync mode</comment>
        </bits>
        <bits access="rw" name="is_sck_rev" pos="13" rst="0x0">
          <comment>1 : spi_sck reverse</comment>
        </bits>
        <bits access="rw" name="spi_csn_pre" pos="11:8" rst="0xf">
          <comment>1 bit chip select.
0: cs0 is valid
1: cs0 is invalid</comment>
        </bits>
        <bits access="rw" name="lsb" pos="7" rst="0x0">
          <comment>In default, The input data is shifted high order first into the chip; the output data is shifted out high order first from the Most Significant Bit (MSB) on SO. When this bit is set, the data will be shift out or in from the LSB</comment>
        </bits>
        <bits access="rw" name="chnl_len" pos="6:2" rst="0x0">
          <comment>Transmit data bit number.
0 : 32 bits per word
1 : 1 bits per word

31: 31 bits per word</comment>
        </bits>
        <bits access="rw" name="ng_tx" pos="1" rst="0x1">
          <comment>1 enable TX data shift out at clock neg-edge</comment>
        </bits>
        <bits access="rw" name="ng_rx" pos="0" rst="0x0">
          <comment>1 enable RX data shift in at clock neg-edge</comment>
        </bits>
      </reg>
      <reg name="spi_ctl1" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="do_hold_en" pos="15:14" rst="0x0">
          <comment>00 : default(follow before version)
01 : spi do stay 0 value when in idle
10 : spi do stay 1 value when in idle
11 : spi do stay last-bit value when in idle</comment>
        </bits>
        <bits access="rw" name="is_txmd" pos="13" rst="0x1">
          <comment>1:is tx mode 0:not tx mode</comment>
        </bits>
        <bits access="rw" name="is_rxmd" pos="12" rst="0x1">
          <comment>1:is rx mode 0:not rx mode</comment>
        </bits>
        <bits access="rw" name="sync_csn_sel" pos="11:8" rst="0x0">
          <comment>S8 CD or SYNC signal maps to csn number
0x0001 selects csn0 as cd signal
0x0010 selects csn1 as cd signal
In SPI_HS it must be 0x0000 and disable sync and s8 mode</comment>
        </bits>
        <bits access="rw" name="s8_md" pos="7" rst="0x0">
          <comment>1 : enable S8 mode</comment>
        </bits>
        <bits access="rw" name="cs_h_md" pos="6" rst="0x0">
          <comment>3-wire Melody timing 1, csn high mode enable</comment>
        </bits>
        <bits access="rw" name="s3w_md" pos="5" rst="0x0">
          <comment>1 : enable 3-wire mode</comment>
        </bits>
        <bits access="rw" name="s3w_pos" pos="4:0" rst="0x0">
          <comment>3-wire mode, w/r control position
or the sync pulse position(the pulse will
locates on top of bit N)</comment>
        </bits>
      </reg>
      <reg name="spi_ctl2" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="dma_req_seq_sel" pos="10" rst="0x0">
          <comment>0:DMA TX and RX REQ independent
1:DMA TX REQ are depended on RX REQ status</comment>
        </bits>
        <bits access="rw" name="tx_dma_sel" pos="9" rst="0x0">
          <comment>0: tx_dma_req keep 1 until receiving the tx_dma_ack
1: tx_dma_req is 1 when tx_empty is 1,else 0</comment>
        </bits>
        <bits access="rw" name="rx_dma_sel" pos="8" rst="0x0">
          <comment>0: rx_dma_req keep 1 until receiving the rx_dma_ack
1: rx_dma_req is 1 when rx_full is 1,else 0</comment>
        </bits>
        <bits access="rw" name="rx_only_nhd" pos="7" rst="0x0">
          <comment>0 : working on only receive
mode, when rxf_realfull is high, SPI will be held until rxf_realfull is low
1 : no holding</comment>
        </bits>
        <bits access="rw" name="dma_en" pos="6" rst="0x0">
          <comment>1 enable DMA mode</comment>
        </bits>
        <bits access="rw" name="is_slvd" pos="5" rst="0x0">
          <comment>0 : master
1 : slave, only support microplus mode</comment>
        </bits>
        <bits access="rw" name="s3w_rd_strt" pos="4:0" rst="0x0">
          <comment>Read data start bit, used for 3 wire mode and 3 wire 9bit RW mode.
The 3 wire 9bit RW mode reuse this config registers, it indicated read data start position.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl3" protect="rw">
        <comment>RXF watermark  SPI RX FIFO FULL/EMPTY watermark</comment>
        <bits access="rw" name="rxf_empty_thrhld" pos="12:8" rst="0x10">
          <comment>Receive FIFO data empty threshold. Relative with rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="rw" name="rxf_full_thrhld" pos="4:0" rst="0x10">
          <comment>Receive FIFO data full threshold. Relative with rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_ctl4" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="rx_only_do" pos="15" rst="0x0">
          <comment>working in only receive mode,
0 : SPI send all 0 to slave
1 : SPI send all 1 to slave</comment>
        </bits>
        <bits access="rw" name="is_fst" pos="14" rst="0x0">
          <comment>0 : normal mode
1 : fast mode
Both for matser mode and slave mode,and in master mode SPI_SCK must be quicker  than 1/8 spi_clk</comment>
        </bits>
        <bits access="rw" name="phs_dly" pos="13:12" rst="0x0">
          <comment>Phase delay. Relate to fast mode.
When in normal mode, this bit is not used . Only used for slave mode</comment>
        </bits>
        <bits access="rw" name="sync_clkmask_en" pos="11" rst="0x0">
          <comment>1 Mask out the first clock pulse in SPI mode</comment>
        </bits>
        <bits access="rw" name="sync_half" pos="10" rst="0x0">
          <comment>Sync_half, sync width is half  spi_sck cycle</comment>
        </bits>
        <bits access="rw" name="is_rx_only" pos="9" rst="0x0">
          <comment>1:receive data only.
The bit should be written at last.
Only used for master mode</comment>
        </bits>
        <bits access="rw" name="block_num" pos="8:0" rst="0x0">
          <comment>Number of data words ready to receive in receive only mode. Only used for master mode.</comment>
        </bits>
      </reg>
      <reg name="spi_ctl5" protect="rw">
        <comment>Configure register  This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="itvl_num_sam" pos="15:0" rst="0x0">
          <comment>For master, transmit data interval, programmable n from 0 to 65535, delay is (n*4+3) clock cycle.
For slave, max receive data interval. If the slave has not sampled the edge of spi_clk in the interval(n*4+3), slave will stop the receive process and send timout interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_int_en" protect="rw">
        <comment>Interrupt enable  SPI interrupt enable register</comment>
        <bits access="rw" name="rx_end_int_en" pos="9" rst="0x0">
          <comment>Rx end interrupt enable</comment>
        </bits>
        <bits access="rw" name="tx_end_int_en" pos="8" rst="0x0">
          <comment>Tx end interrupt enable</comment>
        </bits>
        <bits access="rw" name="txf_w_empty_int_en" pos="7" rst="0x0">
          <comment>txf_empty interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_r_full_int_en" pos="6" rst="0x0">
          <comment>Rxf_full interrupt enable</comment>
        </bits>
        <bits access="rw" name="time_out_int_en" pos="5" rst="0x0">
          <comment>Slave mode timeout interrupt enable</comment>
        </bits>
        <bits access="rw" name="rx_ovf_int_en" pos="4" rst="0x0">
          <comment>Rx_overrun_reg interrupt enable</comment>
        </bits>
        <bits access="rw" name="txf_empty_en" pos="3" rst="0x0"/>
        <bits access="rw" name="txf_full_int_en" pos="2" rst="0x0">
          <comment>Tx_fifo_full interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_empty_int_en" pos="1" rst="0x0">
          <comment>Rx_fifo_empty interrupt enable</comment>
        </bits>
        <bits access="rw" name="rxf_full_int_en" pos="0" rst="0x0">
          <comment>Rx_fifo_full interrupt enable</comment>
        </bits>
      </reg>
      <reg name="spi_int_clr" protect="rw">
        <comment>Interrupt clear SPI interrupt clear register</comment>
        <bits access="w" name="rx_end_int_clr" pos="9" rst="0x0">
          <comment>Rx data end interrupt clear</comment>
        </bits>
        <bits access="w" name="tx_end_int_clr" pos="8" rst="0x0">
          <comment>Tx data end interrupt clear</comment>
        </bits>
        <bits access="w" name="time_out_int_clr" pos="5" rst="0x0">
          <comment>Write 1 clear slave mode timeout interrupt</comment>
        </bits>
        <bits access="w" name="rx_ovf_int_clr" pos="4" rst="0x0">
          <comment>Write 1 clear Rx_overrun_reg interrupt</comment>
        </bits>
        <bits access="w" name="txf_empty_int_clr" pos="3" rst="0x0">
          <comment>Write 1 clear Tx_fifo_empty interrupt</comment>
        </bits>
        <bits access="w" name="txf_full_int_clr" pos="2" rst="0x0">
          <comment>Write 1 clear Tx_fifo_full interrupt</comment>
        </bits>
        <bits access="w" name="rxf_empty_int_clr" pos="1" rst="0x0">
          <comment>Write 1 clear Rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="w" name="rxf_full_int_clr" pos="0" rst="0x0">
          <comment>Write 1 clear Rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_int_raw_sts" protect="rw">
        <comment>Raw status  SPI interrupt raw status</comment>
        <bits access="r" name="rx_end_irq" pos="9" rst="0x0">
          <comment>Raw rx data end interrupt, this bit is set when spi controller received RX_DATA_LEN data from slave.</comment>
        </bits>
        <bits access="r" name="tx_end_irq" pos="8" rst="0x0">
          <comment>Raw tx data end interrupt,this bit is set when spi controller send TX_DATA_LEN data.</comment>
        </bits>
        <bits access="r" name="txf_empty_w" pos="7" rst="0x1">
          <comment>Raw txf_empty interrupt, This bit is set when the number of tx fifo data byte is less than the tx empty watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_full_r" pos="6" rst="0x0">
          <comment>Raw rxf_full interrupt.This bit is set when the number of rx fifo data byte is larger than the rx full watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="time_out_raw_sts" pos="5" rst="0x0">
          <comment>Raw slave mode time out interrupt</comment>
        </bits>
        <bits access="r" name="rx_ovf_raw_sts" pos="4" rst="0x0">
          <comment>Raw Rx_overrun_reg interrupt</comment>
        </bits>
        <bits access="r" name="tx_fifo_empty_w" pos="3" rst="0x1">
          <comment>Txf_empty_w(for debug)</comment>
        </bits>
        <bits access="r" name="txf_full_raw_sts" pos="2" rst="0x0">
          <comment>Raw Tx_fifo_full interrupt</comment>
        </bits>
        <bits access="r" name="rxf_empty_raw_sts" pos="1" rst="0x1">
          <comment>Raw rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="r" name="rx_full_raw_sts" pos="0" rst="0x0">
          <comment>Rxf_full_r(for debug)</comment>
        </bits>
      </reg>
      <reg name="spi_int_mask_sts" protect="rw">
        <comment>Mask status  SPI interrupt mask status</comment>
        <bits access="r" name="rx_end_irq_mask_sts" pos="9" rst="0x0">
          <comment>Raw rx data end interrupt, this bit is set when spi controller received RX_DATA_LEN data from slave.</comment>
        </bits>
        <bits access="r" name="tx_end_irq_mask_sts" pos="8" rst="0x0">
          <comment>Raw tx data end interrupt,this bit is set when spi controller send TX_DATA_LEN data.</comment>
        </bits>
        <bits access="r" name="txf_empty_mask_sts" pos="7" rst="0x1">
          <comment>Txf_empty interrupt mask status.</comment>
        </bits>
        <bits access="r" name="rxf_full_mask_sts" pos="6" rst="0x0">
          <comment>Rxf_full interrupt mask status.</comment>
        </bits>
        <bits access="r" name="time_out_mask_sts" pos="5" rst="0x0">
          <comment>Slave mode time out interrupt mask status</comment>
        </bits>
        <bits access="r" name="rx_ovf_mask_sts" pos="4" rst="0x0">
          <comment>Rx_overrun_reg interrupt mask status</comment>
        </bits>
        <bits access="r" name="txf_full_mask_sts" pos="2" rst="0x0">
          <comment>Tx_fifo_full interrupt mask status</comment>
        </bits>
        <bits access="r" name="rxf_empty_mask_sts" pos="1" rst="0x1">
          <comment>Rx_fifo_empty interrupt mask status</comment>
        </bits>
      </reg>
      <reg name="spi_sts1" protect="rw">
        <comment>RXF address  SPI RX FIFO write address and read address</comment>
        <bits access="r" name="rxf_waddr" pos="12:8" rst="0x0">
          <comment>RX FIFO write address</comment>
        </bits>
        <bits access="r" name="rxf_raddr" pos="4:0" rst="0x0">
          <comment>RX FIFO read address</comment>
        </bits>
      </reg>
      <reg name="spi_sts2" protect="rw">
        <comment>latch SPI status  SPI status register</comment>
        <bits access="r" name="spi_cs" pos="12" rst="0x0">
          <comment>Spi_cs(for debug)</comment>
        </bits>
        <bits access="r" name="spi_sck" pos="11" rst="0x0">
          <comment>Spi_sck(for debug)</comment>
        </bits>
        <bits access="r" name="spi_txd" pos="10" rst="0x0">
          <comment>Spi_txd(for debug)</comment>
        </bits>
        <bits access="r" name="spi_rxd" pos="9" rst="0x0">
          <comment>Spi_rxd(for debug)</comment>
        </bits>
        <bits access="r" name="busy" pos="8" rst="0x0">
          <comment>1 transmit process
0 idle state</comment>
        </bits>
        <bits access="r" name="txf_real_empty" pos="7" rst="0x1">
          <comment>TX FIFO has no data</comment>
        </bits>
        <bits access="r" name="txf_real_full" pos="6" rst="0x0">
          <comment>TX FIFO is real full. (not relates to TX full threshold)</comment>
        </bits>
        <bits access="r" name="rxf_real_empty" pos="5" rst="0x1">
          <comment>RX FIFO has no data</comment>
        </bits>
        <bits access="r" name="rxf_real_full" pos="4" rst="0x0">
          <comment>RX FIFO is real full. (not relates to TX full threshold)</comment>
        </bits>
        <bits access="r" name="txf_empty" pos="3" rst="0x1">
          <comment>This bit is set when the number of TX FIFO data byte is less than the TX empty interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="txf_full" pos="2" rst="0x0">
          <comment>This bit is set when the number of TX FIFO data byte is larger than the TX full interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_empty" pos="1" rst="0x1">
          <comment>This bit is set when the number of RX FIFO data byte is less than the RX empty interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
        <bits access="r" name="rxf_full" pos="0" rst="0x0">
          <comment>This bit is set when the number of RX FIFO data byte is larger than the RX full interrupt watermark value. Auto cleared when the condition disappears.</comment>
        </bits>
      </reg>
      <reg name="spi_dspwait" protect="rw">
        <comment>DSP Register This register is used for DSP control</comment>
        <bits access="rw" name="tx_data_swt" pos="7:6" rst="0x0">
          <comment>Write data switch.
2b0: WDATA=PDATA;
2b1: WDATA={PDATA[7:0], PDATA[15:8], PDATA[23:16], PDATA[31:24]};
2b2: WDATA={PDATA[15:0],PDATA[31:16]};
2b3: WDATA={PDATA[23:16], PDATA[31:24], PDATA[7:0], PDATA[15:8]};</comment>
        </bits>
        <bits access="rw" name="rx_data_swt" pos="5:4" rst="0x0">
          <comment>Read data switch.
2b0: RDATA=PDATA;
2b1: RDATA={PDATA[7:0], PDATA[15:8], PDATA[23:16], PDATA[31:24]};
2b2: RDATA={PDATA[15:0],PDATA[31:16]};</comment>
        </bits>
        <bits access="rw" name="spi_dspwait" pos="3:0" rst="0x1">
          <comment>This register is used for DSP control</comment>
        </bits>
      </reg>
      <reg name="spi_sts3" protect="rw">
        <comment>RX conunter monitor This register is used to observe the status</comment>
        <bits access="r" name="rx_cnt" pos="8:0" rst="0x0">
          <comment>working in only receive mode
as master</comment>
        </bits>
      </reg>
      <reg name="spi_ctl6" protect="rw">
        <comment>TXF configuration This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="txf_empty_thrhld" pos="12:8" rst="0x10">
          <comment>TX FIFO data empty threshold. Relative with rx_fifo_empty interrupt</comment>
        </bits>
        <bits access="rw" name="txf_full_thrhld" pos="4:0" rst="0x10">
          <comment>TX FIFO data full threshold. Relative with rx_fifo_full interrupt</comment>
        </bits>
      </reg>
      <reg name="spi_sts4" protect="rw">
        <comment>TXF address This register is used to configuration of the SPI interface</comment>
        <bits access="r" name="txf_waddr" pos="12:8" rst="0x0">
          <comment>TX FIFO write address</comment>
        </bits>
        <bits access="r" name="txf_raddr" pos="4:0" rst="0x0">
          <comment>TX FIFO read address</comment>
        </bits>
      </reg>
      <reg name="spi_fifo_rst" protect="rw">
        <comment>FIFO reset configuration Used to reset TX/RX FIFO</comment>
        <bits access="rw" name="spi_fifo_rst" pos="0" rst="0x0">
          <comment>1 : reset all FIFOs. FIFO address will changed to 0</comment>
        </bits>
      </reg>
      <reg name="spi_ctl7" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="data_line2_en" pos="15" rst="0x0">
          <comment>1: two data line function enable
0: two data line function disable</comment>
        </bits>
        <bits access="rw" name="rgb565_en" pos="14" rst="0x0">
          <comment>1: enable RGB565 data format
0: disable RGB565 data format</comment>
        </bits>
        <bits access="rw" name="rgb666_en" pos="13" rst="0x0">
          <comment>1: enable RGB666 data format
0: disable RGB666 data format</comment>
        </bits>
        <bits access="rw" name="rgb888_en" pos="12" rst="0x0">
          <comment>1: enable RGB888 data format
0: disable RGB888 data format</comment>
        </bits>
        <bits access="rw" name="spi_slv_sel" pos="11" rst="0x0">
          <comment>1: SPI slave in Low speed mode
0: SPI slave in High speed mode</comment>
        </bits>
        <bits access="rw" name="spi_slv_en" pos="10" rst="0x0">
          <comment>Used when SPI slave in High speed mode.
1: enable spi slave rtx
0: disable spi slave rtx</comment>
        </bits>
        <bits access="rw" name="data_in_mode" pos="9" rst="0x0">
          <comment>Use for 3 wire 9bit RW mode and 4 wire 8bit RW mode (SPI_MODE=5 or SPI_MODE=6).
0: Data in and data out of SPI share one IO (SDA).
1: Data in and data out of SPI use separated IO (SDI, SDO).</comment>
        </bits>
        <bits access="rw" name="spi_rx_hld_en" pos="8" rst="0x0">
          <comment>1: enable ahb2apb bridge read hold when rx fifo empty
0: disable ahb2apb bridge read hold</comment>
        </bits>
        <bits access="rw" name="spi_tx_hld_en" pos="7" rst="0x0">
          <comment>1: enable ahb2apb bridge write hold when tx fifo full
0: disable ahb2apb bridge write hold</comment>
        </bits>
        <bits access="rw" name="tx_cmd_set" pos="6" rst="0x0">
          <comment>1: select fmark as the dma request
0: select software dma request</comment>
        </bits>
        <bits access="rw" name="spi_mode" pos="5:3" rst="0x0">
          <comment>Used for master only
0: SPI_MODE disable
1: 3 wire 9 bit, cd bit, SDI/SDO share  one IO
2: 3 wire 9 bit, cd bit, SDI, SDO
3: 4 wire 8 bit, cd pin, SDI/SDO share one IO
4: 4 wire 8 bit, cd pin, SDI, SDO
5: 3 wire 9bit RW mode, 9 bit command and 8 bit read data, cd bit is enable. Design for LCD driver.
6: 4 wire 8bit RW mode, 8bit command and 8 bit read data. Use CD PAD indicates command or data. Design for LCD driver.</comment>
        </bits>
        <bits access="rw" name="csn_i_sel" pos="2:1" rst="0x0">
          <comment>CSN select control:
0: CSN 0
1: CSN 1
2: CSN 2
3: CSN 3</comment>
        </bits>
        <bits access="rw" name="csn_ie_ctl" pos="0" rst="0x0">
          <comment>CSN IE output set(only slave)
0: not support csn input
1: support csn intput</comment>
        </bits>
      </reg>
      <reg name="spi_sts5" protect="rw">
        <comment>Statue Register Used to observe csn error</comment>
        <bits access="r" name="csn_in_err_sync2" pos="4" rst="0x0">
          <comment>1: indicates csn occurring a exception</comment>
        </bits>
        <bits access="r" name="csn_in_sync2" pos="0" rst="0x0">
          <comment>csn for slave</comment>
        </bits>
      </reg>
      <reg name="spi_ctl8" protect="rw">
        <comment>Configure Register Used for configure SPI interface</comment>
        <bits access="rw" name="spi_cd_bit" pos="15" rst="0x0">
          <comment>Spi tx cd bit:
0: indicates command
1: indicates data</comment>
        </bits>
        <bits access="rw" name="spi_cd_bit2" pos="14" rst="0x0">
          <comment>Use for 4 wire 8bit RW mode. Determine CD PAD high or low in read data phase.</comment>
        </bits>
        <bits access="rw" name="cd_data2_sel" pos="13" rst="0x0">
          <comment>Second data line of two data line function select bit:
0: CD PAD as second data line
1: DI PAD as second data line</comment>
        </bits>
        <bits access="rw" name="rgb_pix_mode" pos="12" rst="0x0">
          <comment>Two data line RGB data format mode:
0: 1pixel mode
1: 2/3 pixel mode</comment>
        </bits>
        <bits access="rw" name="data_line2_sw" pos="11" rst="0x0">
          <comment>2-data-line switch. Only valid in 2-data-line mode(DATA_LINE2_EN set to 1):
0: use spi_do as first data line,spi_di as second data line.
1: use spi_di as first data line, spi_do as second data line.</comment>
        </bits>
        <bits access="rw" name="spi_tx_dumy_len" pos="9:4" rst="0x0">
          <comment>Spi tx dummy clock length</comment>
        </bits>
        <bits access="rw" name="spi_tx_data_len_h" pos="3:0" rst="0x0">
          <comment>Indicates tx data length from tx fifo, High 4 bits of spi tx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl9" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="spi_tx_data_len_l" pos="15:0" rst="0x0">
          <comment>Indicates: spi tx data length from tx fifo, Low 16bit of tx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl10" protect="rw">
        <comment>Configure register SPI status register</comment>
        <bits access="rw" name="spi_rx_dumy_len" pos="9:4" rst="0x0">
          <comment>Spi rx dummy clock length</comment>
        </bits>
        <bits access="rw" name="spi_rx_data_len_h" pos="3:0" rst="0x0">
          <comment>Indicates receives data length from slave, high 4 bits of spi rx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl11" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="spi_rx_data_len_l" pos="15:0" rst="0x0">
          <comment>Indicates: spi receives data length from slave, Low 16bit of rx data length</comment>
        </bits>
      </reg>
      <reg name="spi_ctl12" protect="rw">
        <comment>Configure register This register is used to configuration of the SPI interface</comment>
        <bits access="rw" name="sw_tx_req" pos="1" rst="0x0">
          <comment>Software TX data request, for write LCD</comment>
        </bits>
        <bits access="rw" name="sw_rx_req" pos="0" rst="0x0">
          <comment>Software RX data request, for read LCD</comment>
        </bits>
      </reg>
      <reg name="spi_sts6" protect="rw">
        <comment>Statue Register Used to observe TX data counter</comment>
        <bits access="r" name="tx_data_cnt" pos="15:0" rst="0x0">
          <comment>Tx data cnt</comment>
        </bits>
      </reg>
      <reg name="spi_sts7" protect="rw">
        <comment>Statue Register Used to observe TX statue</comment>
        <bits access="r" name="tx_dummy_cnt" pos="15:10" rst="0x0">
          <comment>tx dummy counter</comment>
        </bits>
        <bits access="r" name="tx_data_cnt" pos="3:0" rst="0x0">
          <comment>tx data counter</comment>
        </bits>
      </reg>
      <reg name="spi_sts8" protect="rw">
        <comment>Statue Register Used to observe RX data counter</comment>
        <bits access="r" name="rx_data_cnt" pos="15:0" rst="0x0">
          <comment>Rx data cnt</comment>
        </bits>
      </reg>
      <reg name="spi_sts9" protect="rw">
        <comment>Statue Register Used to observe RX statue</comment>
        <bits access="r" name="rx_dummy_cnt" pos="15:10" rst="0x0">
          <comment>rx dummy counter</comment>
        </bits>
        <bits access="r" name="rx_data_cnt" pos="3:0" rst="0x0">
          <comment>rx data counter</comment>
        </bits>
      </reg>
      <reg name="spi_version" protect="rw">
        <comment>Statue Register Used to observe spi version</comment>
        <bits access="rw" name="spi_version" pos="15:0" rst="0x205">
          <comment>Spi version</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04008000" name="AP_SPI" type="AP_SPI"/>
  </archive>
  <archive relative="wlan.xml">
    <module category="System" name="WLAN">
      <hole size="32"/>
      <reg name="bank_addr" protect="rw">
        <comment/>
      </reg>
      <reg name="offset_addr" protect="rw">
        <comment/>
      </reg>
      <reg name="regwdata" protect="rw">
        <comment/>
      </reg>
      <reg name="regrdata" protect="rw">
        <comment/>
      </reg>
      <reg name="protocol_version" protect="rw">
        <comment/>
        <bits access="r" name="protocol_version" pos="1:0" rst="0x0">
          <comment>protocol_version</comment>
        </bits>
      </reg>
      <reg name="type" protect="rw">
        <comment/>
        <bits access="r" name="type" pos="1:0" rst="0x0">
          <comment>Protocol Type</comment>
        </bits>
      </reg>
      <reg name="subtype" protect="rw">
        <comment/>
        <bits access="r" name="subtype" pos="3:0" rst="0x0">
          <comment>Protocol Subtype</comment>
        </bits>
      </reg>
      <reg name="desaddr_l" protect="rw">
        <comment/>
      </reg>
      <reg name="desaddr_h" protect="rw">
        <comment/>
        <bits access="r" name="desaddr_h" pos="15:0" rst="0x0">
          <comment>Beacon Destination address high</comment>
        </bits>
      </reg>
      <reg name="srcaddr_l" protect="rw">
        <comment/>
      </reg>
      <reg name="srcaddr_h" protect="rw">
        <comment/>
        <bits access="r" name="srcaddr_h" pos="15:0" rst="0x0">
          <comment>Beacon Source address high</comment>
        </bits>
      </reg>
      <reg name="bssidaddr_l" protect="rw">
        <comment/>
      </reg>
      <reg name="bssidaddr_h" protect="rw">
        <comment/>
        <bits access="r" name="bssidaddr_h" pos="15:0" rst="0x0">
          <comment>BSSID address high</comment>
        </bits>
      </reg>
      <reg name="seqcontl" protect="rw">
        <comment/>
        <bits access="r" name="seqcontl" pos="15:0" rst="0x0">
          <comment>Beacon sequence control</comment>
        </bits>
      </reg>
      <reg name="rssival" protect="rw">
        <comment/>
        <bits access="r" name="rssival" pos="7:0" rst="0x0">
          <comment>Wlan rssi value</comment>
        </bits>
      </reg>
      <hole size="512"/>
      <reg name="apb_config" protect="rw">
        <comment/>
        <bits access="rw" name="phyrxenn" pos="16" rst="0x1">
          <comment>RX mode enable signal,0:enable,1:disable</comment>
        </bits>
        <bits access="rw" name="type" pos="13:12" rst="0x0">
          <comment>beacon type,should be 00</comment>
        </bits>
        <bits access="rw" name="subtype" pos="11:8" rst="0x8">
          <comment>beacon type,should be 1000</comment>
        </bits>
        <bits access="rw" name="apb_hold" pos="1" rst="0x1">
          <comment>hold enable from apb,0:disable,1:enable,wlan interrupt can only be cleared by software when this bit set 1 and the walue of registers is kept until the interrupt is cleared</comment>
        </bits>
        <bits access="rw" name="apb_clear" pos="0" rst="0x0">
          <comment>Wlan rssi value</comment>
        </bits>
      </reg>
      <reg name="datardyinterrupt" protect="rw">
        <comment/>
        <bits access="r" name="datardyinterrupt" pos="0" rst="0x0">
          <comment>data receive ready interrupt</comment>
        </bits>
      </reg>
      <hole size="288"/>
      <reg name="framectrl" protect="rw">
        <comment/>
        <bits access="r" name="framectrl" pos="7:0" rst="0x0">
          <comment>Beacon frame control</comment>
        </bits>
      </reg>
      <reg name="duration" protect="rw">
        <comment/>
        <bits access="r" name="duration" pos="15:0" rst="0x0">
          <comment>Beacon duratin</comment>
        </bits>
      </reg>
      <reg name="ht_ctrl" protect="rw">
        <comment/>
      </reg>
      <reg name="tstamp_l" protect="rw">
        <comment/>
      </reg>
      <reg name="tstamp_h" protect="rw">
        <comment/>
      </reg>
      <reg name="bcnintvl" protect="rw">
        <comment/>
        <bits access="r" name="bcnintvl" pos="15:0" rst="0x0">
          <comment>Beacon interval</comment>
        </bits>
      </reg>
      <reg name="capinfo" protect="rw">
        <comment/>
        <bits access="r" name="capinfo" pos="15:0" rst="0x0">
          <comment>Beacon Capbility information</comment>
        </bits>
      </reg>
      <reg name="elmtid" protect="rw">
        <comment/>
        <bits access="r" name="elmtid" pos="7:0" rst="0x0">
          <comment>Beacon SSID Elment ID</comment>
        </bits>
      </reg>
      <reg name="ssidlen" protect="rw">
        <comment/>
        <bits access="r" name="ssidlen" pos="7:0" rst="0x0">
          <comment>Beacon SSID length</comment>
        </bits>
      </reg>
      <reg name="ssidbyte1" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte2" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte3" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte4" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte5" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte6" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte7" protect="rw">
        <comment/>
      </reg>
      <reg name="ssidbyte8" protect="rw">
        <comment/>
      </reg>
      <reg name="out_fcsval" protect="rw">
        <comment/>
      </reg>
    </module>
    <instance address="0x14008000" name="WLAN" type="WLAN"/>
  </archive>
  <archive relative="cp_sysram_patch.xml">
    <module category="System" name="CP_SYSRAM_PATCH">
      <reg name="patch00" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid00" pos="28" rst="0x0">
          <comment>patch_addrs00patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs00" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs00RAM0x10100000-0x1010000f</comment>
        </bits>
      </reg>
      <reg name="patch01" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid01" pos="28" rst="0x0">
          <comment>patch_addrs01patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs01" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs01RAM0x10100010-0x1010001f</comment>
        </bits>
      </reg>
      <reg name="patch02" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid02" pos="28" rst="0x0">
          <comment>patch_addrs02patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs02" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs02RAM0x10100020-0x1010002f</comment>
        </bits>
      </reg>
      <reg name="patch03" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid03" pos="28" rst="0x0">
          <comment>patch_addrs03patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs03" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs03RAM0x10100030-0x1010003f</comment>
        </bits>
      </reg>
      <reg name="patch04" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid04" pos="28" rst="0x0">
          <comment>patch_addrs04patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs04" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs04RAM0x10100040-0x1010004f</comment>
        </bits>
      </reg>
      <reg name="patch05" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid05" pos="28" rst="0x0">
          <comment>patch_addrs05patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs05" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs05RAM0x10100050-0x1010005f</comment>
        </bits>
      </reg>
      <reg name="patch06" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid06" pos="28" rst="0x0">
          <comment>patch_addrs06patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs06" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs06RAM0x10100060-0x1010006f</comment>
        </bits>
      </reg>
      <reg name="patch07" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid07" pos="28" rst="0x0">
          <comment>patch_addrs07patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs07" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs07RAM0x10100070-0x1010007f</comment>
        </bits>
      </reg>
      <reg name="patch08" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid08" pos="28" rst="0x0">
          <comment>patch_addrs08patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs08" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs08RAM0x10100080-0x1010008f</comment>
        </bits>
      </reg>
      <reg name="patch09" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid09" pos="28" rst="0x0">
          <comment>patch_addrs09patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs09" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs09RAM0x10100090-0x1010009f</comment>
        </bits>
      </reg>
      <reg name="patch10" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid10" pos="28" rst="0x0">
          <comment>patch_addrs10patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs10" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs10RAM0x101000a0-0x101000af</comment>
        </bits>
      </reg>
      <reg name="patch11" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid11" pos="28" rst="0x0">
          <comment>patch_addrs11patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs11" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs11RAM0x101000b0-0x101000bf</comment>
        </bits>
      </reg>
      <reg name="patch12" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid12" pos="28" rst="0x0">
          <comment>patch_addrs12patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs12" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs12RAM0x101000c0-0x101000cf</comment>
        </bits>
      </reg>
      <reg name="patch13" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid13" pos="28" rst="0x0">
          <comment>patch_addrs13patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs13" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs13RAM0x101000d0-0x101000df</comment>
        </bits>
      </reg>
      <reg name="patch14" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid14" pos="28" rst="0x0">
          <comment>patch_addrs14patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs14" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs14RAM0x101000e0-0x101000ef</comment>
        </bits>
      </reg>
      <reg name="patch15" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid15" pos="28" rst="0x0">
          <comment>patch_addrs15patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs15" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs15RAM0x101000f0-0x101000ff</comment>
        </bits>
      </reg>
      <reg name="patch16" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid16" pos="28" rst="0x0">
          <comment>patch_addrs16patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs16" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs16RAM0x10100100-0x1010010f</comment>
        </bits>
      </reg>
      <reg name="patch17" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid17" pos="28" rst="0x0">
          <comment>patch_addrs17patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs17" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs17RAM0x10100110-0x1010011f</comment>
        </bits>
      </reg>
      <reg name="patch18" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid18" pos="28" rst="0x0">
          <comment>patch_addrs18patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs18" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs18RAM0x10100120-0x1010012f</comment>
        </bits>
      </reg>
      <reg name="patch19" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid19" pos="28" rst="0x0">
          <comment>patch_addrs19patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs19" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs19RAM0x10100130-0x1010013f</comment>
        </bits>
      </reg>
      <reg name="patch20" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid20" pos="28" rst="0x0">
          <comment>patch_addrs20patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs20" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs20RAM0x10100140-0x1010014f</comment>
        </bits>
      </reg>
      <reg name="patch21" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid21" pos="28" rst="0x0">
          <comment>patch_addrs21patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs21" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs21RAM0x10100150-0x1010015f</comment>
        </bits>
      </reg>
      <reg name="patch22" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid22" pos="28" rst="0x0">
          <comment>patch_addrs22patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs22" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs22RAM0x10100160-0x1010016f</comment>
        </bits>
      </reg>
      <reg name="patch23" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid23" pos="28" rst="0x0">
          <comment>patch_addrs23patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs23" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs23RAM0x10100170-0x1010017f</comment>
        </bits>
      </reg>
      <reg name="patch24" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid24" pos="28" rst="0x0">
          <comment>patch_addrs24patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs24" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs24RAM0x10100180-0x1010018f</comment>
        </bits>
      </reg>
      <reg name="patch25" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid25" pos="28" rst="0x0">
          <comment>patch_addrs25patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs25" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs25RAM0x10100190-0x1010019f</comment>
        </bits>
      </reg>
      <reg name="patch26" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid26" pos="28" rst="0x0">
          <comment>patch_addrs26patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs26" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs26RAM0x101001a0-0x101001af</comment>
        </bits>
      </reg>
      <reg name="patch27" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid27" pos="28" rst="0x0">
          <comment>patch_addrs27patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs27" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs27RAM0x101001b0-0x101001bf</comment>
        </bits>
      </reg>
      <reg name="patch28" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid28" pos="28" rst="0x0">
          <comment>patch_addrs28patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs28" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs28RAM0x101001c0-0x101001cf</comment>
        </bits>
      </reg>
      <reg name="patch29" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid29" pos="28" rst="0x0">
          <comment>patch_addrs29patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs29" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs29RAM0x101001d0-0x101001df</comment>
        </bits>
      </reg>
      <reg name="patch30" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid30" pos="28" rst="0x0">
          <comment>patch_addrs30patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs30" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs30RAM0x101001e0-0x101001ef</comment>
        </bits>
      </reg>
      <reg name="patch31" protect="rw">
        <comment/>
        <bits access="rw" name="patch_valid31" pos="28" rst="0x0">
          <comment>patch_addrs31patch</comment>
        </bits>
        <bits access="rw" name="patch_addrs31" pos="27:0" rst="0x0">
          <comment>ROMpatch_addrs31RAM0x101001f0-0x101001ff</comment>
        </bits>
      </reg>
      <reg name="pagespy0_cfg0" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_enable0" pos="30" rst="0x0">
          <comment>pagespy</comment>
        </bits>
        <bits access="rw" name="pagespy_detectr0" pos="29" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pagespy_detectw0" pos="28" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pagespy_sta_addr0" pos="27:0" rst="0x0">
          <comment>pagespy</comment>
        </bits>
      </reg>
      <reg name="pagespy0_cfg1" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_end_addr0" pos="27:0" rst="0x0">
          <comment>pagespy</comment>
        </bits>
      </reg>
      <reg name="pagespy1_cfg0" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_enable1" pos="30" rst="0x0">
          <comment>pagespy</comment>
        </bits>
        <bits access="rw" name="pagespy_detectr1" pos="29" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pagespy_detectw1" pos="28" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pagespy_sta_addr1" pos="27:0" rst="0x0">
          <comment>pagespy</comment>
        </bits>
      </reg>
      <reg name="pagespy1_cfg1" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_end_addr1" pos="27:0" rst="0x0">
          <comment>pagespy</comment>
        </bits>
      </reg>
      <reg name="pagespy2_cfg0" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_enable2" pos="30" rst="0x0">
          <comment>pagespy</comment>
        </bits>
        <bits access="rw" name="pagespy_detectr2" pos="29" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pagespy_detectw2" pos="28" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pagespy_sta_addr2" pos="27:0" rst="0x0">
          <comment>pagespy</comment>
        </bits>
      </reg>
      <reg name="pagespy2_cfg1" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_end_addr2" pos="27:0" rst="0x0">
          <comment>pagespy</comment>
        </bits>
      </reg>
      <reg name="pagespy3_cfg0" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_enable3" pos="30" rst="0x0">
          <comment>pagespy</comment>
        </bits>
        <bits access="rw" name="pagespy_detectr3" pos="29" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pagespy_detectw3" pos="28" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pagespy_sta_addr3" pos="27:0" rst="0x0">
          <comment>pagespy</comment>
        </bits>
      </reg>
      <reg name="pagespy3_cfg1" protect="rw">
        <comment/>
        <bits access="rw" name="pagespy_end_addr3" pos="27:0" rst="0x0">
          <comment>pagespy</comment>
        </bits>
      </reg>
      <reg name="pagespy0_sta0" protect="rw">
        <comment/>
        <bits access="r" name="pagespy_status0" pos="18" rst="0x0">
          <comment>pagespy1</comment>
        </bits>
        <bits access="r" name="pagespy_hitr0" pos="17" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="r" name="pagespy_hitw0" pos="16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="r" name="pagespy_aid0" pos="15:0" rst="0x0">
          <comment>CPUID</comment>
        </bits>
      </reg>
      <reg name="pagespy0_sta1" protect="rw">
        <comment/>
      </reg>
      <reg name="pagespy1_sta0" protect="rw">
        <comment/>
        <bits access="r" name="pagespy_status1" pos="18" rst="0x0">
          <comment>pagespy1</comment>
        </bits>
        <bits access="r" name="pagespy_hitr1" pos="17" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="r" name="pagespy_hitw1" pos="16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="r" name="pagespy_aid1" pos="15:0" rst="0x0">
          <comment>CPUID</comment>
        </bits>
      </reg>
      <reg name="pagespy1_sta1" protect="rw">
        <comment/>
      </reg>
      <reg name="pagespy2_sta0" protect="rw">
        <comment/>
        <bits access="r" name="pagespy_status2" pos="18" rst="0x0">
          <comment>pagespy1</comment>
        </bits>
        <bits access="r" name="pagespy_hitr2" pos="17" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="r" name="pagespy_hitw2" pos="16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="r" name="pagespy_aid2" pos="15:0" rst="0x0">
          <comment>CPUID</comment>
        </bits>
      </reg>
      <reg name="pagespy2_sta1" protect="rw">
        <comment/>
      </reg>
      <reg name="pagespy3_sta0" protect="rw">
        <comment/>
        <bits access="r" name="pagespy_status3" pos="18" rst="0x0">
          <comment>pagespy1</comment>
        </bits>
        <bits access="r" name="pagespy_hitr3" pos="17" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="r" name="pagespy_hitw3" pos="16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="r" name="pagespy_aid3" pos="15:0" rst="0x0">
          <comment>CPUID</comment>
        </bits>
      </reg>
      <reg name="pagespy3_sta1" protect="rw">
        <comment/>
      </reg>
    </module>
    <instance address="0x14003000" name="CP_SYSRAM_PATCH" type="CP_SYSRAM_PATCH"/>
  </archive>
  <archive relative="cp_freq_bias.xml">
    <module category="System" name="CP_FREQ_BIAS">
      <reg name="raw_int_sts" protect="rw">
        <comment>raw interrupt status Register raw interrupt status Register</comment>
      </reg>
      <reg name="int_en" protect="rw">
        <comment>interrupt enable Register interrupt enable Register</comment>
      </reg>
      <reg name="masked_int_sts" protect="rw">
        <comment>masked interrupt status Register masked interrupt status Register</comment>
      </reg>
      <reg name="int_clr" protect="rw">
        <comment>interrupt clear Register interrupt clear Register</comment>
      </reg>
      <reg name="freq_bias_ctrl_0" protect="rw">
        <comment>tempurature control register tempurature control register</comment>
        <bits access="rw" name="frac_freq_div_en" pos="28">
          <comment>1: frac freq div mode
0:  integer freq div mode</comment>
        </bits>
        <bits access="rw" name="ext_chan_sel_sw" pos="27">
          <comment>1: ext  osc static mode
0:  ext tsx static mode</comment>
        </bits>
        <bits access="rw" name="ext_chan_sel_mode" pos="26">
          <comment>1: sw config ,ext tsx/osc static mode
0:  ext tsx/osc swtich mode</comment>
        </bits>
        <bits access="rw" name="osc_src_mode" pos="25">
          <comment>1: External OSC option
0: Internal OSC option</comment>
        </bits>
        <bits access="rw" name="freq_bias_mode" pos="24">
          <comment>0:hardware mode
1:software mode</comment>
        </bits>
        <bits access="rw" name="osc_temp_comp_shift" pos="23:20">
          <comment>osc left shift control of tempurature offset</comment>
        </bits>
        <bits access="rw" name="temp_comp_shift" pos="19:16">
          <comment>left shift control of tempurature offset</comment>
        </bits>
        <bits access="rw" name="input_flag" pos="15">
          <comment>1:first do OSC
0:first do TSX</comment>
        </bits>
        <bits access="rw" name="switch_enb" pos="14">
          <comment>1:  switch osx tsx enable
0:  switch osx tsx disable</comment>
        </bits>
        <bits access="rw" name="freq_bias_mode1" pos="13">
          <comment>1:  OSC option
0:  TSX option</comment>
        </bits>
        <bits access="rw" name="freq_bias_src_mode" pos="12">
          <comment>1: External TSX option
0: Internal TSX option</comment>
        </bits>
        <bits access="rw" name="srst_osc_inter_thm" pos="11">
          <comment>1: enable osc internal thermal ADS synchronous reset</comment>
        </bits>
        <bits access="rw" name="osc_edge_sel_temp" pos="10">
          <comment>1: sample the osc adc data at the posedge of adc clock
0: sample the osc dac data at the negedge of adc clock</comment>
        </bits>
        <bits access="rw" name="srst_inter_thm" pos="9">
          <comment>1: enable internal thermal ADS synchronous reset</comment>
        </bits>
        <bits access="rw" name="edge_sel_temp" pos="8">
          <comment>1: sample the adc data at the posedge of adc clock
0: sample the dac data at the negedge of adc clock</comment>
        </bits>
        <bits access="rw" name="osc_temp_filter_en" pos="5">
          <comment>enable the osc filter filter in the calculation(update)</comment>
        </bits>
        <bits access="rw" name="filter_en_temp" pos="4">
          <comment>enable the tsx filter filter in the calculation(update)</comment>
        </bits>
        <bits access="rw" name="thm_adc_dump_en" pos="3">
          <comment>enable the thermal ADC data dump to Memory</comment>
        </bits>
        <bits access="rw" name="osc_cal_en_temp" pos="1">
          <comment>enable the osc calcualtion of  tempurature compensation</comment>
        </bits>
        <bits access="rw" name="cal_en_temp" pos="0">
          <comment>enable the tsx calcualtion of  tempurature compensation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_1" protect="rw">
        <comment>the length of intergration the length of intergration</comment>
        <bits access="rw" name="intergration_len_temp" pos="19:0">
          <comment>the length of intergration</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_2" protect="rw">
        <comment>the coef0 of frequency calculation the coef1 of frequency calculation</comment>
        <bits access="rw" name="c0_temp" pos="15:0">
          <comment>c0 of frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_3" protect="rw">
        <comment>the coef1 of frequency calculation the coef2 of frequency calculation</comment>
        <bits access="rw" name="c1_temp" pos="15:0">
          <comment>c0 of frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_4" protect="rw">
        <comment>the coef2 of frequency calculation the coef3 of frequency calculation</comment>
        <bits access="rw" name="c2_temp" pos="15:0">
          <comment>c2of frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_5" protect="rw">
        <comment>the coef3 of frequency calculation the coef4 of frequency calculation</comment>
        <bits access="rw" name="c3_temp" pos="15:0">
          <comment>c0 of frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_6" protect="rw">
        <comment>the reserved  register of frequency calculation the reserved  register of frequency calculation</comment>
      </reg>
      <reg name="freq_bias_ctrl_7" protect="rw">
        <comment>the configur register of external sigma-delta ADC over resampling the configur register of external sigma-delta ADC over resampling</comment>
        <bits access="rw" name="ext_conf_clk_inv_pos" pos="31:28" rst="0x3">
          <comment>external TSX over resampling  output divider clk second inverse  position.</comment>
        </bits>
        <bits access="rw" name="ext_conf_clk_init_pos" pos="27:24" rst="0x1">
          <comment>external TSX over resampling  output divider clk initial inverse position.</comment>
        </bits>
        <bits access="rw" name="ext_conf_cnter_max" pos="20:16" rst="0x3">
          <comment>external TSX over resampling resampling ration over origin signma delta ADC working clk frequency. For example, the origin sampling clk and resmapling clk is 6.5M and 26M, and the ratio is 4 .then the value of this register should be ration-1 =3.</comment>
        </bits>
        <bits access="rw" name="ext_conf_first_pls_pos" pos="15:12" rst="0x3">
          <comment>external TSX over resampling first pulse generate postion in delay chain.
Typital is 1</comment>
        </bits>
        <bits access="rw" name="ext_conf_best_pos" pos="8:4">
          <comment>external TSX over resampling  best sampling positon .</comment>
        </bits>
        <bits access="rw" name="ext_conf_clk_init_val" pos="2">
          <comment>external TSX over resampling  output divider clk init value.</comment>
        </bits>
        <bits access="rw" name="ext_conf_sync_order" pos="1">
          <comment>external TSX over resampling  delay chain sync mode select.
1: high first
0: low first</comment>
        </bits>
        <bits access="rw" name="ext_conf_en" pos="0">
          <comment>external TSX over resampling  work enable</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_8" protect="rw">
        <comment>offset of osc frequency calculation offset of osc frequency calculation</comment>
        <bits access="rw" name="osc_temp_offset" pos="19:0">
          <comment>offset of osc frequency calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_9" protect="rw">
        <comment>the coef0 of  osc frequency calculation the coef1 of  osc frequency calculation</comment>
        <bits access="rw" name="osc_c0_temp" pos="15:0">
          <comment>c0 of  osc frequency calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_soft_val" protect="rw">
        <comment>the freq bias cal val  reg in software mode the freq bias cal val  reg in software mode</comment>
        <bits access="rw" name="freq_bias_soft_val_upd" pos="31">
          <comment>software calculation frequency bias update.Write to this reg will gen an plus.</comment>
        </bits>
        <bits access="rw" name="freq_bias_soft_val" pos="25:0">
          <comment>software calculation frequency bias</comment>
        </bits>
      </reg>
      <reg name="freq_bias_upd_cnter" protect="rw">
        <comment>the counter of frequency calculation done the counter of frequency calculation done</comment>
      </reg>
      <reg name="freq_bias_temp_upd_cnter" protect="rw">
        <comment>the counter of tempurature calculation done the counter of tempurature calculation done</comment>
      </reg>
      <reg name="freq_bias_ctrl_10" protect="rw">
        <comment>the coef1 of osc frequency calculation the coef2 of osc frequency calculation</comment>
        <bits access="rw" name="osc_c1_temp" pos="15:0">
          <comment>c1 of osc frequency calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_11" protect="rw">
        <comment>the coef2 of osc  frequency calculation the coef3 of osc  frequency calculation</comment>
        <bits access="rw" name="osc_c2_temp" pos="15:0">
          <comment>c2 of osc frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_12" protect="rw">
        <comment>the coef3 of  osc frequency calculation the coef4 of  osc frequency calculation</comment>
        <bits access="rw" name="osc_c3_temp" pos="15:0">
          <comment>c3 of osc frequency bias calculation</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_13" protect="rw">
        <comment>switch ctrl switch ctrl</comment>
        <bits access="rw" name="osc_data_num" pos="31:26">
          <comment>osc_data_num</comment>
        </bits>
        <bits access="rw" name="tsx_data_num" pos="25:20">
          <comment>tsx_data_num</comment>
        </bits>
        <bits access="rw" name="adc_delay_num" pos="19:0">
          <comment>adc delay num</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_14" protect="rw">
        <comment>the configur register of external sigma-delta ADC over resampling(frac freq div) the configur register of external sigma-delta ADC over resampling(frac freq div)</comment>
        <bits access="rw" name="ext_conf_toggle_neg" pos="19:16" rst="0x5">
          <comment>external TSX/OSC over resampling  output divider neg clk inverse position.</comment>
        </bits>
        <bits access="rw" name="ext_conf_toggle_pos" pos="15:12" rst="0x1">
          <comment>external TSX/OSC over resampling  output divider pos clk  inverse position.</comment>
        </bits>
        <bits access="rw" name="ext_conf_first_pls_pos" pos="11:8" rst="0x1">
          <comment>external TSX/OSC over resampling first pulse generate postion in delay chain.
Typital is 1</comment>
        </bits>
        <bits access="rw" name="ext_conf_frac_cnter_max" pos="7:4" rst="0x6">
          <comment>external TSX/OSC over resampling resampling ration over origin signma delta ADC working clk frequency. For example, the origin sampling clk and resmapling clk is 26/3.5M and 26M, and the ratio is 3.5 .then the value of this register should be ration*2-1 =6.</comment>
        </bits>
        <bits access="rw" name="ext_conf_frac_clk_sel" pos="2">
          <comment>1: neg clk sample
0: pos clk sample</comment>
        </bits>
        <bits access="rw" name="ext_conf_frac_sync_order" pos="1">
          <comment>external TSX/OSC over resampling  delay chain sync mode select.
1: high first
0: low first</comment>
        </bits>
        <bits access="rw" name="ext_conf_frac_en" pos="0">
          <comment>external TSX/OSC over resampling  work enable</comment>
        </bits>
      </reg>
      <hole size="320"/>
      <reg name="freq_bias_status0" protect="rw">
        <comment>the status  reg of frequency bias calculation  the status  reg of frequency bias calculation</comment>
        <bits access="r" name="freq_raw_bias_upd" pos="31">
          <comment>hardware calculation frequency bias update.Write to this reg will gen an plus</comment>
        </bits>
        <bits access="r" name="freq_bias" pos="25:0">
          <comment>hardware calculation frequency bias value</comment>
        </bits>
      </reg>
      <reg name="freq_bias_status1" protect="rw">
        <comment>the status  reg of tempurature calculation  the status  reg of tempurature calculation</comment>
        <bits access="r" name="freq_bias_integer_upd" pos="31">
          <comment>hardware calculation frequency bias update.Write to this reg will gen an plus</comment>
        </bits>
        <bits access="r" name="freq_bias_temp" pos="19:0">
          <comment>hardware integration value of calculation tempurature</comment>
        </bits>
      </reg>
      <reg name="freq_bias_status2" protect="rw">
        <comment>the status  reg of frequency bias calculation  the status  reg of frequency bias calculation</comment>
        <bits access="r" name="osc_freq_raw_bias_upd" pos="31">
          <comment>hardware calculation frequency bias update.Write to this reg will gen an plus</comment>
        </bits>
        <bits access="r" name="osc_freq_bias" pos="25:0">
          <comment>hardware calculation frequency bias value</comment>
        </bits>
      </reg>
      <reg name="freq_bias_status3" protect="rw">
        <comment>the status  reg of tempurature calculation  the status  reg of tempurature calculation</comment>
        <bits access="r" name="osc_freq_bias_integer_upd" pos="31">
          <comment>hardware calculation frequency bias update.Write to this reg will gen an plus</comment>
        </bits>
        <bits access="r" name="osc_freq_bias_temp" pos="19:0">
          <comment>hardware integration value of calculation tempurature</comment>
        </bits>
      </reg>
      <reg name="freq_bias_status4" protect="rw">
        <comment>the status  reg of tempurature calculation  the status  reg of tempurature calculation</comment>
        <bits access="r" name="freq_bias_sum_upd" pos="31">
          <comment>hardware calculation frequency bias update.Write to this reg will gen an plus</comment>
        </bits>
        <bits access="r" name="freq_bias_sum" pos="25:0">
          <comment>hardware integration value of calculation tempurature</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_15" protect="rw">
        <comment>osc_cal_post  ctrl osc_cal_post  ctrl</comment>
        <bits access="rw" name="osc_rate_deltat" pos="31:16"/>
        <bits access="rw" name="osc_alpha" pos="15:0"/>
      </reg>
      <reg name="freq_bias_ctrl_16" protect="rw">
        <comment>osc_cal_post  ctrl osc_cal_post  ctrl</comment>
        <bits access="rw" name="osc_freq_bias_sel" pos="7" rst="0x1">
          <comment>0 is osc_freq_bias_pre, 1 is osc_freq_bias_post</comment>
        </bits>
        <bits access="rw" name="osc_t2reset_num" pos="6:1">
          <comment>t2reset_cnt th</comment>
        </bits>
        <bits access="rw" name="osc_t2reset_cnt_clr" pos="0">
          <comment>clear osc t2reset_cnt</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_17" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_rate_deltat" pos="31:16"/>
        <bits access="rw" name="tsx_alpha" pos="15:0"/>
      </reg>
      <reg name="freq_bias_ctrl_18" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_freq_bias_sel" pos="31" rst="0x1">
          <comment>0 is tsx_freq_bias_pre, 1 is tsx_freq_bias_post</comment>
        </bits>
        <bits access="rw" name="tsx_fcalth_coef" pos="30:19"/>
        <bits access="rw" name="tsx_ratehys_coef" pos="18:7"/>
        <bits access="rw" name="tsx_smth_coef" pos="6:2"/>
        <bits access="rw" name="tsx_t2reset_cnt_clr" pos="0">
          <comment>clear osc t2reset_cnt</comment>
        </bits>
      </reg>
      <reg name="freq_bias_ctrl_19" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_t2reset_num" pos="31:26">
          <comment>t2reset_cnt th</comment>
        </bits>
        <bits access="rw" name="tsx_fcalth_osft" pos="25:0"/>
      </reg>
      <reg name="freq_bias_ctrl_20" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_age_th_inv" pos="31:16">
          <comment>t2reset_cnt th</comment>
        </bits>
        <bits access="rw" name="tsx_age_th" pos="15:0"/>
      </reg>
      <reg name="freq_bias_ctrl_21" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_maxtemp_rate_th" pos="31:16">
          <comment>t2reset_cnt th</comment>
        </bits>
        <bits access="rw" name="tsx_ratehys_ofst" pos="15:0"/>
      </reg>
      <reg name="freq_bias_ctrl_22" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_23" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_24" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_25" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_26" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_27" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_28" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_29" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_30" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_31" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
      </reg>
      <reg name="freq_bias_ctrl_32" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_rate_tab_val20" pos="15:0"/>
      </reg>
      <reg name="freq_bias_ctrl_33" protect="rw">
        <comment>tsx_cal_post  ctrl tsx_cal_post  ctrl</comment>
        <bits access="rw" name="tsx_smth_sft" pos="22:20"/>
        <bits access="rw" name="tsx_temp_th" pos="19:0"/>
      </reg>
      <reg name="freq_bias_rpt0" protect="rw">
        <comment>freq_bias_rpt0 freq_bias_rpt0</comment>
        <bits access="r" name="osc_temp" pos="19:0"/>
      </reg>
      <reg name="freq_bias_rpt1" protect="rw">
        <comment>freq_bias_rpt1 freq_bias_rpt1</comment>
        <bits access="r" name="osc_temp2" pos="27:0"/>
      </reg>
      <reg name="freq_bias_rpt2" protect="rw">
        <comment>freq_bias_rpt2 freq_bias_rpt2</comment>
        <bits access="r" name="tsx_temp" pos="19:0"/>
      </reg>
      <reg name="freq_bias_rpt3" protect="rw">
        <comment>freq_bias_rpt3 freq_bias_rpt3</comment>
        <bits access="r" name="tsx_temp2" pos="27:0"/>
      </reg>
      <reg name="freq_bias_rpt4" protect="rw">
        <comment>freq_bias_rpt4 freq_bias_rpt4</comment>
        <bits access="r" name="tsx_fcal" pos="25:0"/>
      </reg>
    </module>
    <instance address="0x12080000" name="CP_FREQ_BIAS" type="CP_FREQ_BIAS"/>
  </archive>
  <archive relative="cp_glb.xml">
    <module category="System" name="CP_GLB">
      <reg name="sysctrl00" protect="rw">
        <comment/>
        <bits access="rw" name="slv_disable_req_cp_ltecpu_force" pos="24" rst="0x0">
          <comment>1cp cpulte</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_ltecpu_sel" pos="23" rst="0x0">
          <comment>1cp cpulte0</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_ltedma_force" pos="22" rst="0x0">
          <comment>1cplte dma</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_ltedma_sel" pos="21" rst="0x0">
          <comment>1cplte dma0</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_psram_force" pos="20" rst="0x0">
          <comment>1cppsram</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_psram_sel" pos="19" rst="0x0">
          <comment>1cppsram0</comment>
        </bits>
        <bits access="rw" name="slv_disable_req_cp_gnss_force" pos="18" rst="0x0">
          <comment>1cpgnss</comment>
        </bits>
        <bits access="rw" name="rg_ifc2cp_clk_auto_gate_en" pos="16" rst="0x0">
          <comment>1ifc2cpauto gate</comment>
        </bits>
        <bits access="rw" name="rg_ifc2cp_nonbuf_early_resp_en" pos="15" rst="0x0">
          <comment>1ifcresponds,</comment>
        </bits>
        <bits access="rw" name="rg_cp_ahb_xhb400_awsparse" pos="14" rst="0x1">
          <comment>axiwstrb8bitSahb,AHBawsparse</comment>
        </bits>
        <bits access="rw" name="rg_tsx_sclk_auto_gate_en" pos="13" rst="0x0">
          <comment>1tsx_sclkauto gate</comment>
        </bits>
        <bits access="rw" name="rg_tsx_mclk_auto_gate_en" pos="12" rst="0x0">
          <comment>1tsx_mclkauto gate</comment>
        </bits>
        <bits access="rw" name="rg_tsx_nonbuf_early_resp_en" pos="11" rst="0x0">
          <comment>1bufferbufferresponds</comment>
        </bits>
        <bits access="rw" name="rg_aon2cp_sclk_auto_gate_en" pos="10" rst="0x0">
          <comment>1aon2cp_sclkauto gate</comment>
        </bits>
        <bits access="rw" name="rg_aon2cp_mclk_auto_gate_en" pos="9" rst="0x0">
          <comment>1aon2cp_mclkauto gate</comment>
        </bits>
        <bits access="rw" name="rg_aon2cp_nonbuf_early_resp_en" pos="8" rst="0x0">
          <comment>1aoncpbufferbufferresponds</comment>
        </bits>
        <bits access="rw" name="rg_cp2gnss_xhb400_awsparse" pos="7" rst="0x1">
          <comment>axiwstrb8bitSahbAHBawsparse</comment>
        </bits>
        <bits access="rw" name="rg_cp2aon_xhb400_awsparse" pos="3" rst="0x1">
          <comment>axiwstrb8bitSahbAHBawsparse</comment>
        </bits>
      </reg>
      <reg name="sysctrl01" protect="rw">
        <comment/>
        <bits access="rw" name="arqos_cp_ifc" pos="31:28" rst="0x0">
          <comment>ifc</comment>
        </bits>
        <bits access="rw" name="awqos_cp_ifc" pos="27:24" rst="0x0">
          <comment>ifc</comment>
        </bits>
        <bits access="rw" name="arqos_axidma" pos="23:20" rst="0x0">
          <comment>axidma</comment>
        </bits>
        <bits access="rw" name="awqos_axidma" pos="19:16" rst="0x0">
          <comment>axidma</comment>
        </bits>
        <bits access="rw" name="arqos_f8" pos="15:12" rst="0x0">
          <comment>f8</comment>
        </bits>
        <bits access="rw" name="awqos_f8" pos="11:8" rst="0x0">
          <comment>f8</comment>
        </bits>
        <bits access="rw" name="arqos_cp_a5" pos="7:4" rst="0x0">
          <comment>cp a5</comment>
        </bits>
        <bits access="rw" name="awqos_cp_a5" pos="3:0" rst="0x0">
          <comment>cp a5</comment>
        </bits>
      </reg>
      <reg name="sysctrl02" protect="rw">
        <comment/>
        <bits access="rw" name="arqos_lte_dma" pos="23:20" rst="0x0">
          <comment>lte dma</comment>
        </bits>
        <bits access="rw" name="awqos_lte_dma" pos="19:16" rst="0x0">
          <comment>lte dma</comment>
        </bits>
        <bits access="rw" name="arqos_lte_cpu" pos="15:12" rst="0x0">
          <comment>lte cpu</comment>
        </bits>
        <bits access="rw" name="awqos_lte_cpu" pos="11:8" rst="0x0">
          <comment>lte cpu</comment>
        </bits>
        <bits access="rw" name="arqos_aon_m" pos="7:4" rst="0x0">
          <comment>aon m</comment>
        </bits>
        <bits access="rw" name="awqos_aon_m" pos="3:0" rst="0x0">
          <comment>aon m</comment>
        </bits>
      </reg>
      <reg name="sysctrl03" protect="rw">
        <comment/>
        <bits access="rw" name="lpc_main_early_wakeup_bypass" pos="26" rst="0x0">
          <comment>1lpc_mainwakeupcactive</comment>
        </bits>
        <bits access="rw" name="lp_force_s6" pos="25" rst="0x0">
          <comment>1s6</comment>
        </bits>
        <bits access="rw" name="lp_force_s5" pos="24" rst="0x0">
          <comment>1s5</comment>
        </bits>
        <bits access="rw" name="lp_force_s4" pos="23" rst="0x0">
          <comment>1s4</comment>
        </bits>
        <bits access="rw" name="lp_force_s3" pos="22" rst="0x0">
          <comment>1s3</comment>
        </bits>
        <bits access="rw" name="lp_force_s2" pos="21" rst="0x0">
          <comment>1s2</comment>
        </bits>
        <bits access="rw" name="lp_force_s1" pos="20" rst="0x0">
          <comment>1s1</comment>
        </bits>
        <bits access="rw" name="lp_force_s0" pos="19" rst="0x0">
          <comment>1s0</comment>
        </bits>
        <bits access="rw" name="lp_force_main" pos="18" rst="0x0">
          <comment>1main</comment>
        </bits>
        <bits access="rw" name="lp_force_m4" pos="17" rst="0x0">
          <comment>1m4</comment>
        </bits>
        <bits access="rw" name="lp_force_m3" pos="16" rst="0x0">
          <comment>1m3</comment>
        </bits>
        <bits access="rw" name="lp_force_m2" pos="15" rst="0x0">
          <comment>1m2</comment>
        </bits>
        <bits access="rw" name="lp_force_m1" pos="14" rst="0x0">
          <comment>1m1</comment>
        </bits>
        <bits access="rw" name="lp_force_m0" pos="13" rst="0x0">
          <comment>1m0</comment>
        </bits>
        <bits access="rw" name="lp_eb_s6" pos="12" rst="0x0">
          <comment>1:s6</comment>
        </bits>
        <bits access="rw" name="lp_eb_s5" pos="11" rst="0x0">
          <comment>1:s5</comment>
        </bits>
        <bits access="rw" name="lp_eb_s4" pos="10" rst="0x0">
          <comment>1:s4</comment>
        </bits>
        <bits access="rw" name="lp_eb_s3" pos="9" rst="0x0">
          <comment>1:s3</comment>
        </bits>
        <bits access="rw" name="lp_eb_s2" pos="8" rst="0x0">
          <comment>1:s2</comment>
        </bits>
        <bits access="rw" name="lp_eb_s1" pos="7" rst="0x0">
          <comment>1:s1</comment>
        </bits>
        <bits access="rw" name="lp_eb_s0" pos="6" rst="0x0">
          <comment>1:s0</comment>
        </bits>
        <bits access="rw" name="lp_eb_main" pos="5" rst="0x0">
          <comment>1:main</comment>
        </bits>
        <bits access="rw" name="lp_eb_m4" pos="4" rst="0x0">
          <comment>1:m4</comment>
        </bits>
        <bits access="rw" name="lp_eb_m3" pos="3" rst="0x0">
          <comment>1:m3</comment>
        </bits>
        <bits access="rw" name="lp_eb_m2" pos="2" rst="0x0">
          <comment>1:m2</comment>
        </bits>
        <bits access="rw" name="lp_eb_m1" pos="1" rst="0x0">
          <comment>1:m1</comment>
        </bits>
        <bits access="rw" name="lp_eb_m0" pos="0" rst="0x0">
          <comment>1:m0</comment>
        </bits>
      </reg>
      <reg name="sysctrl04" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_m0" pos="23:16" rst="0x0">
          <comment>m0cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_m0" pos="15:0" rst="0x80">
          <comment>m0cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl05" protect="rw">
        <comment></comment>
        <bits access="rw" name="pu_num_m1" pos="23:16" rst="0x0">
          <comment>m1cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_m1" pos="15:0" rst="0x80">
          <comment>m1cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl06" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_m2" pos="23:16" rst="0x0">
          <comment>m2cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_m2" pos="15:0" rst="0x80">
          <comment>m2cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl07" protect="rw">
        <comment></comment>
        <bits access="rw" name="pu_num_m3" pos="23:16" rst="0x0">
          <comment>m3cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_m3" pos="15:0" rst="0x80">
          <comment>m3cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl08" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_m4" pos="23:16" rst="0x0">
          <comment>m4cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_m4" pos="15:0" rst="0x80">
          <comment>m4cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl09" protect="rw">
        <comment></comment>
        <bits access="rw" name="pu_num_s0" pos="23:16" rst="0x0">
          <comment>s0cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_s0" pos="15:0" rst="0x80">
          <comment>s0cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl10" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_s1" pos="23:16" rst="0x0">
          <comment>s1cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_s1" pos="15:0" rst="0x80">
          <comment>s1cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl11" protect="rw">
        <comment></comment>
        <bits access="rw" name="pu_num_s2" pos="23:16" rst="0x0">
          <comment>s2cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_s2" pos="15:0" rst="0x80">
          <comment>s2cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl12" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_s3" pos="23:16" rst="0x0">
          <comment>s3cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_s3" pos="15:0" rst="0x80">
          <comment>s3cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl13" protect="rw">
        <comment></comment>
        <bits access="rw" name="pu_num_s4" pos="23:16" rst="0x0">
          <comment>s4cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_s4" pos="15:0" rst="0x80">
          <comment>s4cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl14" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_s5" pos="23:16" rst="0x0">
          <comment>s5cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_s5" pos="15:0" rst="0x80">
          <comment>s5cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl15" protect="rw">
        <comment></comment>
        <bits access="rw" name="pu_num_s6" pos="23:16" rst="0x0">
          <comment>s6cycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_s6" pos="15:0" rst="0x80">
          <comment>s6cycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl16" protect="rw">
        <comment/>
        <bits access="rw" name="rg_osc_clkedge_sel" pos="10" rst="0x0">
          <comment>1clk_thm_osc</comment>
        </bits>
        <bits access="rw" name="rg_tsx_clkedge_sel" pos="9" rst="0x0">
          <comment>1clk_thm_tsx</comment>
        </bits>
        <bits access="rw" name="freq_bias_ch3_en" pos="8" rst="0x0">
          <comment>1freq_biasch3</comment>
        </bits>
        <bits access="rw" name="freq_bias_ch2_en" pos="7" rst="0x0">
          <comment>1freq_biasch2</comment>
        </bits>
        <bits access="rw" name="freq_bias_ch1_en" pos="6" rst="0x0">
          <comment>1freq_biasch1</comment>
        </bits>
        <bits access="rw" name="freq_bias_ch0_en" pos="5" rst="0x1">
          <comment>1freq_biasch0</comment>
        </bits>
        <bits access="rw" name="cp_a5_resp_err_mask" pos="4" rst="0x0">
          <comment>1a5axi bresprresp</comment>
        </bits>
        <bits access="rw" name="cp_ifc_hresp_err_mask" pos="3" rst="0x1">
          <comment>1ifcresponderror</comment>
        </bits>
        <bits access="rw" name="wlan_iq_sync_sel" pos="2" rst="0x0">
          <comment>1:wlan_iq0wlan_iq</comment>
        </bits>
      </reg>
      <reg name="sysctrl17" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_cp_ahb_en" pos="12" rst="0x1">
          <comment>1cgm_cp_ahb</comment>
        </bits>
        <bits access="rw" name="cgm_cp_axi_en" pos="11" rst="0x1">
          <comment>1cgm_cp_axi</comment>
        </bits>
        <bits access="rw" name="cgm_cp_a5_en" pos="10" rst="0x1">
          <comment>1cgm_cp_a5</comment>
        </bits>
        <bits access="rw" name="cgm_cp_axi_update" pos="9" rst="0x0">
          <comment>1cgm_cp_update</comment>
        </bits>
        <bits access="rw" name="cgm_cp_ahb_div" pos="8:6" rst="0x1">
          <comment>1cgm_cp_ahb</comment>
        </bits>
        <bits access="rw" name="cgm_cp_axi_div" pos="5:3" rst="0x0">
          <comment>1:cgm_cp_axi</comment>
        </bits>
        <bits access="rw" name="cgm_cp_axi_sel" pos="2:0" rst="0x1">
          <comment>1cgm_cp_axi</comment>
        </bits>
      </reg>
      <reg name="sysctrl18" protect="rw">
        <comment/>
        <bits access="rw" name="freq_bias_ahb_en" pos="29" rst="0x0">
          <comment>1freq_bias_ahb0freq_bias_ahb</comment>
        </bits>
        <bits access="rw" name="aon2cp_ahb_en" pos="28" rst="0x1">
          <comment>1aon2cp_ahb0aon2cp_ahb</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ifc_en" pos="27" rst="0x1">
          <comment>1cp_ahb_ifc0cp_ahb_ifcAPB Master use, can auto gate</comment>
        </bits>
        <bits access="rw" name="cp_apb_ifc_en" pos="26" rst="0x1">
          <comment>1cp_apb_ifc0cp_apb_ifcAPB DMA master use</comment>
        </bits>
        <bits access="rw" name="dap_dap_en" pos="23" rst="0x1">
          <comment>1:dap0dap</comment>
        </bits>
        <bits access="rw" name="freq_bias_func_en" pos="22" rst="0x0">
          <comment>1freq_bias_func0freq_bias_func</comment>
        </bits>
        <bits access="rw" name="wlan_11b_en" pos="21" rst="0x0">
          <comment>1wlan_11b0wlan_11b</comment>
        </bits>
        <bits access="rw" name="cp_ahb_busmon_func_en" pos="20" rst="0x0">
          <comment>1busmon_func0busmon_func</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci2_func_en" pos="19" rst="0x0">
          <comment>1sci2_func0busmon</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci2_conf_en" pos="18" rst="0x0">
          <comment>1sci2_conf0sci2_conf</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci2_mod_en" pos="17" rst="0x0">
          <comment>1sci2_mod0sci2_mod</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci1_func_en" pos="16" rst="0x0">
          <comment>1sci1_func0sci1_func</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci1_mod_en" pos="15" rst="0x0">
          <comment>1sci1_conf0sci1_conf</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sci1_conf_en" pos="14" rst="0x0">
          <comment>1sci1_mod0sci1_mod</comment>
        </bits>
        <bits access="rw" name="cp_ahb_timer3_mod_en" pos="13" rst="0x0">
          <comment>1timer3_mod0timer3_mod</comment>
        </bits>
        <bits access="rw" name="cp_ahb_timer3_conf_en" pos="12" rst="0x0">
          <comment>1timer3_conf0timer3_conf</comment>
        </bits>
        <bits access="rw" name="cp_ahb_timer4_mod_en" pos="11" rst="0x0">
          <comment>1timer4_mod0timer4_mod</comment>
        </bits>
        <bits access="rw" name="cp_ahb_timer4_conf_en" pos="10" rst="0x0">
          <comment>1timer4_conf0timer4_conf</comment>
        </bits>
        <bits access="rw" name="cp_ahb_sysram_conf_en" pos="9" rst="0x0">
          <comment>1sysram_conf0sysram_conf</comment>
        </bits>
        <bits access="rw" name="cp_ahb_axidma_en" pos="8" rst="0x0">
          <comment>1axidma0axidma</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ch3_en" pos="7" rst="0x0">
          <comment>1ahb_ch30ahb_ch3</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ch2_en" pos="6" rst="0x0">
          <comment>1ahb_ch20ahb_ch2</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ch1_en" pos="5" rst="0x0">
          <comment>1ahb_ch10ahb_ch1</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ch0_en" pos="4" rst="0x0">
          <comment>1ahb_ch00ahb_ch0</comment>
        </bits>
        <bits access="rw" name="cp_ahb_ch_dbg_en" pos="3" rst="0x0">
          <comment>1ahb_ch_dbg0ahb_ch_dbg</comment>
        </bits>
        <bits access="rw" name="cp_ahb_f8_en" pos="2" rst="0x0">
          <comment>1ahb_f80ahb_f8</comment>
        </bits>
        <bits access="rw" name="cp_ahb_irq1_en" pos="1" rst="0x1">
          <comment>1ahb_irq10ahb_irq1</comment>
        </bits>
        <bits access="rw" name="cp_ahb_irq0_en" pos="0" rst="0x1">
          <comment>1ahb_irq00ahb_irq0</comment>
        </bits>
      </reg>
      <reg name="sysctrl19" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_thm_osc_en" pos="7" rst="0x0">
          <comment>1:clk_thm_osc_gen0clk_thm_osc_gen</comment>
        </bits>
        <bits access="rw" name="cgm_thm_tsx_en" pos="6" rst="0x0">
          <comment>1:clk_thm_tsx_gen0clk_thm_tsx_gen</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_tsx_en" pos="5" rst="0x0">
          <comment>1:clk_gnss_tsx_gen0clk_gnss_tsx_gen</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_tsx_sel" pos="4" rst="0x1">
          <comment>1:clk_gnss_tsx_mux0clk_gnss_tsx_mux</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_11b_adc_en" pos="3" rst="0x0">
          <comment>1:clk_wcn_11b_adc_gen0clk_wcn_11b_adc_gen</comment>
        </bits>
        <bits access="rw" name="cgm_wdg_32k_en" pos="2" rst="0x0">
          <comment>1:clk_wdg_32k_gen0clk_wdg_32k_gen</comment>
        </bits>
        <bits access="rw" name="cgm_timer_26m_en" pos="1" rst="0x0">
          <comment>1:clk_timer_26m_gen0clk_timer_26m_gen</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_11b_dfe_en" pos="0" rst="0x0">
          <comment>1:clk_wcn_11b_dfe_gen0clk_wcn_11b_dfe_gen</comment>
        </bits>
      </reg>
      <reg name="sysctrl20" protect="rw">
        <comment/>
        <bits access="rw" name="tsx_ip_soft_rst" pos="27" rst="0x0">
          <comment>1rst_osc_26m</comment>
        </bits>
        <bits access="rw" name="tsx_ab_soft_rst" pos="26" rst="0x0">
          <comment>1rst_tsx_ab_m</comment>
        </bits>
        <bits access="rw" name="cp_psram_async_soft_rst" pos="25" rst="0x0">
          <comment>1:async_bridge_cp_soft_rst</comment>
        </bits>
        <bits access="rw" name="cp_ltedma_async_soft_rst" pos="24" rst="0x0">
          <comment>1:cp_ltedma_async_soft_rst_to_lte</comment>
        </bits>
        <bits access="rw" name="cp_ltecpu_async_soft_rst" pos="23" rst="0x0">
          <comment>1:cp_ltecpu_async_soft_rst_to_lte</comment>
        </bits>
        <bits access="rw" name="cp2aon_soft_rst" pos="22" rst="0x0">
          <comment>1rst_cp2aon_aon</comment>
        </bits>
        <bits access="rw" name="cp2gnss_soft_rst" pos="21" rst="0x0">
          <comment>1rst_cp2gnss_cp</comment>
        </bits>
        <bits access="rw" name="aon2cp_soft_rst" pos="20" rst="0x0">
          <comment>1rst_aon2cp_aon</comment>
        </bits>
        <bits access="rw" name="cp_timer4_soft_rst" pos="19" rst="0x0">
          <comment>1rst_timer4_26m</comment>
        </bits>
        <bits access="rw" name="cp_sci1_soft_rst" pos="18" rst="0x0">
          <comment>1rst_sci1</comment>
        </bits>
        <bits access="rw" name="cp_sci2_soft_rst" pos="17" rst="0x0">
          <comment>1rst_sci2</comment>
        </bits>
        <bits access="rw" name="cp_bsumon_apb_soft_rst" pos="16" rst="0x0">
          <comment>1rst_busmon_apb</comment>
        </bits>
        <bits access="rw" name="cp_busmon_m0_soft_rst" pos="15" rst="0x0">
          <comment>1rst_busmon_m0</comment>
        </bits>
        <bits access="rw" name="cp_busmon_m1_soft_rst" pos="14" rst="0x0">
          <comment>1rst_busmon_m1</comment>
        </bits>
        <bits access="rw" name="cp_busmon_m2_soft_rst" pos="13" rst="0x0">
          <comment>1rst_busmon_m2</comment>
        </bits>
        <bits access="rw" name="cp_busmon_m3_soft_rst" pos="12" rst="0x0">
          <comment>1rst_busmon_m3</comment>
        </bits>
        <bits access="rw" name="cp_busmon_m4_soft_rst" pos="11" rst="0x0">
          <comment>1rst_busmon_m4</comment>
        </bits>
        <bits access="rw" name="cp_wlan_soft_rst" pos="10" rst="0x0">
          <comment>1rst_wlan_apb</comment>
        </bits>
        <bits access="rw" name="cp_f8_soft_rst" pos="9" rst="0x0">
          <comment>1rst_f8</comment>
        </bits>
        <bits access="rw" name="cp_axidma_soft_rst" pos="8" rst="0x0">
          <comment>1rst_axidma</comment>
        </bits>
        <bits access="rw" name="cp_imem_axi_soft_rst" pos="7" rst="0x0">
          <comment>1rst_imem_axi</comment>
        </bits>
        <bits access="rw" name="cp_imem_apb_soft_rst" pos="6" rst="0x0">
          <comment>1rst_imem_apb</comment>
        </bits>
        <bits access="rw" name="cp_timer3_soft_rst" pos="5" rst="0x0">
          <comment>1rst_timer3</comment>
        </bits>
        <bits access="rw" name="cp_irq0_soft_rst" pos="4" rst="0x0">
          <comment>1rst_irq0</comment>
        </bits>
        <bits access="rw" name="cp_irq1_soft_rst" pos="3" rst="0x0">
          <comment>1rst_irq1</comment>
        </bits>
        <bits access="rw" name="cp_a5dbg_soft_rst" pos="2" rst="0x0">
          <comment>1rst_a5dbg</comment>
        </bits>
        <bits access="rw" name="cp_a5cs_soft_rst" pos="1" rst="0x0">
          <comment>1rst_a5cs</comment>
        </bits>
        <bits access="rw" name="cp_a5_soft_rst" pos="0" rst="0x0">
          <comment>1rst_a5</comment>
        </bits>
      </reg>
      <reg name="sysctrl21" protect="rw">
        <comment/>
        <bits access="rw" name="cp_axi_auto_gate_en" pos="14" rst="0x0">
          <comment>1:cp_axiauto_gate</comment>
        </bits>
        <bits access="rw" name="cp_a5_auto_gate_en" pos="13" rst="0x0">
          <comment>1:cp_a5auto_gate</comment>
        </bits>
        <bits access="rw" name="cp2freq_ahb_auto_gate_en" pos="12" rst="0x0">
          <comment>1:cp2freq_ahbauto_gate</comment>
        </bits>
        <bits access="rw" name="ifc2cp_ahb_auto_gate_en" pos="9" rst="0x0">
          <comment>1:ifc2cp_ahbauto_gate</comment>
        </bits>
        <bits access="rw" name="aon2cp_ahb_auto_gate_en" pos="8" rst="0x0">
          <comment>1:aon2cp_ahbauto_gate</comment>
        </bits>
        <bits access="rw" name="cp_sci2_auto_gate_en" pos="7" rst="0x0">
          <comment>1:cp_sci2auto_gate</comment>
        </bits>
        <bits access="rw" name="cp_sci1_auto_gate_en" pos="6" rst="0x0">
          <comment>1:cp_sci1auto_gate</comment>
        </bits>
        <bits access="rw" name="cp_ifc_auto_gate_en" pos="5" rst="0x0">
          <comment>1:cp_ifcauto_gate</comment>
        </bits>
        <bits access="rw" name="cp_ifc_ch3_auto_gate_en" pos="4" rst="0x0">
          <comment>1:cp_ifc_ch3auto_gate</comment>
        </bits>
        <bits access="rw" name="cp_ifc_ch2_auto_gate_en" pos="3" rst="0x0">
          <comment>1:cp_ifc_ch2auto_gate</comment>
        </bits>
        <bits access="rw" name="cp_ifc_ch1_auto_gate_en" pos="2" rst="0x0">
          <comment>1:cp_ifc_ch1auto_gate</comment>
        </bits>
        <bits access="rw" name="cp_ifc_ch0_auto_gate_en" pos="1" rst="0x0">
          <comment>1:cp_ifc_ch0auto_gate</comment>
        </bits>
        <bits access="rw" name="cp_ifc_ch_dbg_auto_gate_en" pos="0" rst="0x0">
          <comment>1:cp_ifc_ch_dbgauto_gate</comment>
        </bits>
      </reg>
      <reg name="sysctrl22" protect="rw">
        <comment></comment>
        <bits access="rw" name="cp_apbreg_soft_rst" pos="0" rst="0x0">
          <comment>1:rst_cp_apbreg</comment>
        </bits>
      </reg>
      <reg name="sysstat01" protect="rw">
        <comment/>
      </reg>
      <reg name="sysstat02" protect="rw">
        <comment/>
      </reg>
      <reg name="sysstat03" protect="rw">
        <comment/>
      </reg>
      <reg name="sysstat04" protect="rw">
        <comment/>
        <bits access="r" name="bridge_trans_idle_cp_ltecpu" pos="8">
          <comment>cp ltecputrans idle1</comment>
        </bits>
        <bits access="r" name="pwr_handshk_clk_req_cp_ltecpu" pos="7">
          <comment>cp ltecpupwr_handshk_clk_req</comment>
        </bits>
        <bits access="r" name="axi_detector_overflow_cp_ltecpu" pos="6">
          <comment>cp ltecpuaxi_detector_overflow</comment>
        </bits>
        <bits access="r" name="bridge_trans_idle_cp_ltedma" pos="5">
          <comment>cp ltedmatrans idle1</comment>
        </bits>
        <bits access="r" name="pwr_handshk_clk_req_cp_ltedma" pos="4">
          <comment>cp ltedmapwr_handshk_clk_req</comment>
        </bits>
        <bits access="r" name="axi_detector_overflow_cp_ltedma" pos="3">
          <comment>cp ltedmaaxi_detector_overflow</comment>
        </bits>
        <bits access="r" name="bridge_trans_idle_cp_psram" pos="2">
          <comment>cp psramtrans idle1</comment>
        </bits>
        <bits access="r" name="pwr_handshk_clk_req_cp_psram" pos="1">
          <comment>cp psrampwr_handshk_clk_req</comment>
        </bits>
        <bits access="r" name="axi_detector_overflow_cp_psram" pos="0">
          <comment>cp psramaxi_detector_overflow</comment>
        </bits>
      </reg>
      <reg name="sysstat05" protect="rw">
        <comment/>
        <bits access="r" name="all_slave_force_slp" pos="29">
          <comment>1:slavedeep_sleep</comment>
        </bits>
        <bits access="r" name="all_master_force_slp" pos="28">
          <comment>1:masterdeep_sleep</comment>
        </bits>
        <bits access="r" name="cp_slp_ack" pos="27">
          <comment>1cpdeep_sleepack</comment>
        </bits>
        <bits access="r" name="cp_light_stop" pos="26">
          <comment>1cplight sleep</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s6" pos="25">
          <comment>1s6lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s5" pos="24">
          <comment>1s5lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s4" pos="23">
          <comment>1s4lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s3" pos="22">
          <comment>1s3lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s2" pos="21">
          <comment>1s2lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s1" pos="20">
          <comment>1s1lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_s0" pos="19">
          <comment>1s0lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_main" pos="18">
          <comment>1mainlpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_m4" pos="17">
          <comment>1m4lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_m3" pos="16">
          <comment>1m3lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_m2" pos="15">
          <comment>1m2lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_m1" pos="14">
          <comment>1m1lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="cgm_busy_lpc_m0" pos="13">
          <comment>1m0lpcbusylpcgated</comment>
        </bits>
        <bits access="r" name="lp_stat_s6" pos="12">
          <comment>1:s6</comment>
        </bits>
        <bits access="r" name="lp_stat_s5" pos="11">
          <comment>1:s5</comment>
        </bits>
        <bits access="r" name="lp_stat_s4" pos="10">
          <comment>1:s4</comment>
        </bits>
        <bits access="r" name="lp_stat_s3" pos="9">
          <comment>1:s3</comment>
        </bits>
        <bits access="r" name="lp_stat_s2" pos="8">
          <comment>1:s2</comment>
        </bits>
        <bits access="r" name="lp_stat_s1" pos="7">
          <comment>1:s1</comment>
        </bits>
        <bits access="r" name="lp_stat_s0" pos="6">
          <comment>1:s0</comment>
        </bits>
        <bits access="r" name="lp_stat_main" pos="5">
          <comment>1:main</comment>
        </bits>
        <bits access="r" name="lp_stat_m4" pos="4">
          <comment>1:m4</comment>
        </bits>
        <bits access="r" name="lp_stat_m3" pos="3">
          <comment>1:m3</comment>
        </bits>
        <bits access="r" name="lp_stat_m2" pos="2">
          <comment>1:m2</comment>
        </bits>
        <bits access="r" name="lp_stat_m1" pos="1">
          <comment>1:m1</comment>
        </bits>
        <bits access="r" name="lp_stat_m0" pos="0">
          <comment>1:m0</comment>
        </bits>
      </reg>
      <reg name="sysstat06" protect="rw">
        <comment/>
        <bits access="r" name="force_ack_s6" pos="12">
          <comment>1s6 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s5" pos="11">
          <comment>1s5 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s4" pos="10">
          <comment>1s4 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s3" pos="9">
          <comment>1s3 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s2" pos="8">
          <comment>1s2 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s1" pos="7">
          <comment>1s1 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_s0" pos="6">
          <comment>1s0 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_main" pos="5">
          <comment>1main lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_m4" pos="4">
          <comment>1m4 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_m3" pos="3">
          <comment>1m3 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_m2" pos="2">
          <comment>1m2 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_m1" pos="1">
          <comment>1m1 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
        <bits access="r" name="force_ack_m0" pos="0">
          <comment>1m0 lpcLow_powelp_forceLPlp_force=0</comment>
        </bits>
      </reg>
      <reg name="sysstat07" protect="rw">
        <comment/>
        <bits access="r" name="cp_dbg_monitor" pos="27:20">
          <comment>cp_dbgmonitor</comment>
        </bits>
        <bits access="r" name="busmon_busy4" pos="19">
          <comment>master4</comment>
        </bits>
        <bits access="r" name="busmon_wbusy4" pos="18">
          <comment>master4</comment>
        </bits>
        <bits access="r" name="busmon_rbusy4" pos="17">
          <comment>master4</comment>
        </bits>
        <bits access="r" name="busmon_busy3" pos="16">
          <comment>master3</comment>
        </bits>
        <bits access="r" name="busmon_wbusy3" pos="15">
          <comment>master3</comment>
        </bits>
        <bits access="r" name="busmon_rbusy3" pos="14">
          <comment>master3</comment>
        </bits>
        <bits access="r" name="busmon_busy2" pos="13">
          <comment>master2</comment>
        </bits>
        <bits access="r" name="busmon_wbusy2" pos="12">
          <comment>master2</comment>
        </bits>
        <bits access="r" name="busmon_rbusy2" pos="11">
          <comment>master2</comment>
        </bits>
        <bits access="r" name="busmon_busy1" pos="10">
          <comment>master1</comment>
        </bits>
        <bits access="r" name="busmon_wbusy1" pos="9">
          <comment>master1</comment>
        </bits>
        <bits access="r" name="busmon_rbusy1" pos="8">
          <comment>master1</comment>
        </bits>
        <bits access="r" name="busmon_busy0" pos="7">
          <comment>master0</comment>
        </bits>
        <bits access="r" name="busmon_wbusy0" pos="6">
          <comment>master0</comment>
        </bits>
        <bits access="r" name="busmon_rbusy0" pos="5">
          <comment>master0</comment>
        </bits>
        <bits access="r" name="busmon4_lock" pos="4">
          <comment>master4</comment>
        </bits>
        <bits access="r" name="busmon3_lock" pos="3">
          <comment>master3</comment>
        </bits>
        <bits access="r" name="busmon2_lock" pos="2">
          <comment>master2</comment>
        </bits>
        <bits access="r" name="busmon1_lock" pos="1">
          <comment>master1</comment>
        </bits>
        <bits access="r" name="busmon0_lock" pos="0">
          <comment>master0</comment>
        </bits>
      </reg>
      <reg name="sysstat08" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl23" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl24" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl25" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl26" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl27" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl28" protect="rw">
        <comment/>
        <bits access="rw" name="core_stop_bypass" pos="25" rst="0x0">
          <comment>1:cp deep sleepCP-A5WFIforce LPC</comment>
        </bits>
        <bits access="rw" name="light_bypass_wlan" pos="24" rst="0x1">
          <comment>1:light sleepwlanlight sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_timer4" pos="23" rst="0x1">
          <comment>1:light sleeptimer4light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_timer3" pos="22" rst="0x1">
          <comment>1:light sleeptimer3light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_sci2" pos="21" rst="0x0">
          <comment>1:light sleepsci2light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_sci1" pos="20" rst="0x0">
          <comment>1:light sleepsci1light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_s6" pos="19" rst="0x1">
          <comment>1:light sleeps6light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_s5" pos="18" rst="0x1">
          <comment>1:light sleeps5light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_s4" pos="17" rst="0x1">
          <comment>1:light sleeps4light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_s3" pos="16" rst="0x1">
          <comment>1:light sleeps3light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_s2" pos="15" rst="0x1">
          <comment>1:light sleeps2light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_s1" pos="14" rst="0x1">
          <comment>1:light sleeps1light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_s0" pos="13" rst="0x1">
          <comment>1:light sleeps0light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_m4" pos="12" rst="0x1">
          <comment>1:light sleepm4light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_m3" pos="11" rst="0x1">
          <comment>1:light sleepm3light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_m2" pos="10" rst="0x0">
          <comment>1:light sleepm2light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_m1" pos="9" rst="0x0">
          <comment>1:light sleepm1light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_m0" pos="8" rst="0x1">
          <comment>1:light sleepm0light sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_main_lpc" pos="7" rst="0x0">
          <comment>1:light sleepmain_lpclight sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_m4_lpc" pos="6" rst="0x0">
          <comment>1:light sleepm4_lpclight sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_m3_lpc" pos="5" rst="0x0">
          <comment>1:light sleepm3_lpclight sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_m2_lpc" pos="4" rst="0x0">
          <comment>1:light sleepm2_lpclight sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_m1_lpc" pos="3" rst="0x0">
          <comment>1:light sleepm1_lpclight sleep</comment>
        </bits>
        <bits access="rw" name="light_bypass_m0_lpc" pos="2" rst="0x0">
          <comment>1:light sleepm0_lpclight sleep</comment>
        </bits>
        <bits access="rw" name="cp_light_stop_en" pos="1" rst="0x0">
          <comment>1cplight sleep</comment>
        </bits>
        <bits access="rw" name="core_int_disable" pos="0" rst="0x0">
          <comment>1deep sleepcpu</comment>
        </bits>
      </reg>
      <reg name="sysstat09" protect="rw">
        <comment/>
        <bits access="r" name="reset_dc" pos="31">
          <comment>wlan</comment>
        </bits>
        <bits access="r" name="dc_est_q" pos="30:16">
          <comment>wlan</comment>
        </bits>
        <bits access="r" name="set_dc" pos="15">
          <comment>wlan</comment>
        </bits>
        <bits access="r" name="dc_est_i" pos="14:0">
          <comment>wlan</comment>
        </bits>
      </reg>
      <reg name="sysctrl29" protect="rw">
        <comment/>
        <bits access="rw" name="pu_num_main" pos="23:16" rst="0x0">
          <comment>maincycleclk</comment>
        </bits>
        <bits access="rw" name="lp_num_main" pos="15:0" rst="0x80">
          <comment>maincycle</comment>
        </bits>
      </reg>
      <reg name="sysctrl30" protect="rw">
        <comment/>
        <bits access="rw" name="cp_latch_bitmap" pos="0" rst="0x0">
          <comment>1:cprf_bitmapcp</comment>
        </bits>
      </reg>
      <reg name="sysstat10" protect="rw">
        <comment/>
        <bits access="r" name="latch_cnt_122m88_value_m" pos="31:16">
          <comment>122.88M/26M counterGNSS RTC/CPU/EM LatchLatch48bit16bits1701ms211810ms4822LTE Frame timer3</comment>
        </bits>
        <bits access="r" name="latch_cnt_122m88_value_l" pos="15:0">
          <comment>122.88M/26M counterGNSS RTC/CPU/EM LatchLatch48bit16bits1701ms211810ms4822LTE Frame timer3</comment>
        </bits>
      </reg>
      <reg name="sysstat11" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_wptr" pos="23:16">
          <comment>Bitmap wptrlatchvalid1</comment>
        </bits>
        <bits access="r" name="latch_cnt_122m88_value_h" pos="15:0">
          <comment>122.88M/26M counterGNSS RTC/CPU/EM LatchLatch48bit16bits1701ms211810ms4822LTE Frame timer3</comment>
        </bits>
      </reg>
      <reg name="sysstat12" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num1" pos="31:16">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num0" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat13" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num3" pos="31:16">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num2" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat14" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num5" pos="31:16">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num4" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat15" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num7" pos="31:16">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num6" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat16" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num9" pos="31:16">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num8" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat17" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num11" pos="31:16">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num10" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat18" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num13" pos="31:16">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num12" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat19" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num15" pos="31:16">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
        <bits access="r" name="latch_bitmap_cycle_index_num14" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <hole size="6592"/>
      <reg name="sysctrl00_set" protect="rw"/>
      <hole size="64"/>
      <reg name="sysctrl03_set" protect="rw"/>
      <hole size="384"/>
      <reg name="sysctrl16_set" protect="rw"/>
      <reg name="sysctrl17_set" protect="rw"/>
      <reg name="sysctrl18_set" protect="rw"/>
      <reg name="sysctrl19_set" protect="rw"/>
      <reg name="sysctrl20_set" protect="rw"/>
      <reg name="sysctrl21_set" protect="rw"/>
      <reg name="sysctrl22_set" protect="rw"/>
      <hole size="256"/>
      <reg name="sysctrl23_set" protect="rw"/>
      <reg name="sysctrl24_set" protect="rw"/>
      <reg name="sysctrl25_set" protect="rw"/>
      <reg name="sysctrl26_set" protect="rw"/>
      <reg name="sysctrl27_set" protect="rw"/>
      <reg name="sysctrl28_set" protect="rw"/>
      <hole size="7008"/>
      <reg name="sysctrl00_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="sysctrl03_clr" protect="rw"/>
      <hole size="384"/>
      <reg name="sysctrl16_clr" protect="rw"/>
      <reg name="sysctrl17_clr" protect="rw"/>
      <reg name="sysctrl18_clr" protect="rw"/>
      <reg name="sysctrl19_clr" protect="rw"/>
      <reg name="sysctrl20_clr" protect="rw"/>
      <reg name="sysctrl21_clr" protect="rw"/>
      <reg name="sysctrl22_clr" protect="rw"/>
      <hole size="256"/>
      <reg name="sysctrl23_clr" protect="rw"/>
      <reg name="sysctrl24_clr" protect="rw"/>
      <reg name="sysctrl25_clr" protect="rw"/>
      <reg name="sysctrl26_clr" protect="rw"/>
      <reg name="sysctrl27_clr" protect="rw"/>
      <reg name="sysctrl28_clr" protect="rw"/>
    </module>
    <var name="REG_CP_GLB_SET_OFFSET" value="0x400"/>
    <var name="REG_CP_GLB_CLR_OFFSET" value="0x800"/>
    <instance address="0x120c0000" name="CP_GLB" type="CP_GLB"/>
  </archive>
  <archive relative="gnss_sys.xml">
    <module category="System" name="GNSS_SYS">
      <reg name="ahb_eb0" protect="rw">
        <comment>AHB_EB0</comment>
        <bits access="rw" name="mtx_dump_eb" pos="9" rst="0x1">
          <comment>NEWclk_mtx_dumpGNSS dump</comment>
        </bits>
        <bits access="rw" name="gnss_mtx_eb" pos="8" rst="0x1">
          <comment>L64bitGNSS MTXEBcgm_gnss_mtx_enMTX
cgm_gnss_mtx_en = ~cp2gnss_lp_stat | gnss_mtx_en
cp2gnss_lp_statCP-sysLPC</comment>
        </bits>
        <bits access="rw" name="rfad_spi_wclk_eb" pos="7" rst="0x1">
          <comment>NEWRFAD_SPI</comment>
        </bits>
        <bits access="rw" name="rfad_spi_hclk_eb" pos="6" rst="0x1">
          <comment>NEWRFAD_SPI</comment>
        </bits>
        <bits access="rw" name="pps_wclk_eb" pos="5" rst="0x1">
          <comment>L68bitPPS</comment>
        </bits>
        <bits access="rw" name="pps_hclk_eb" pos="4" rst="0x1">
          <comment>L67bitPPS</comment>
        </bits>
        <bits access="rw" name="rft_wclk_eb" pos="3" rst="0x1">
          <comment>L66bitRFT</comment>
        </bits>
        <bits access="rw" name="rft_hclk_eb" pos="2" rst="0x1">
          <comment>L65bitRFT</comment>
        </bits>
        <bits access="rw" name="lpc_eb" pos="1" rst="0x1">
          <comment>NEWGNSS2PSRAMLPC</comment>
        </bits>
        <bits access="rw" name="clk_reg_eb" pos="0" rst="0x1">
          <comment>NEWclk_top</comment>
        </bits>
      </reg>
      <reg name="gnss_bb_en" protect="rw">
        <comment>GNSS_BB_enable</comment>
        <bits access="rw" name="gnss_bb_67m_en" pos="10" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_pps_clk_en" pos="9" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_viterbi_clk_en" pos="8" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_te_fifo_clk_en" pos="7" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_te_mem_clk_en" pos="6" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_cof_mem_clk_en" pos="5" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_ae_fifo_clk_en" pos="4" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_te_clk_en" pos="3" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_ae_clk_en" pos="2" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_pp_clk_en" pos="1" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_hclk_en" pos="0" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
      </reg>
      <reg name="fun_test_mode" protect="rw">
        <comment>FUN_TEST_MODE</comment>
        <bits access="r" name="ptest_func_mode" pos="0" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
      </reg>
      <hole size="1696"/>
      <reg name="ahb_sys_ctl6" protect="rw">
        <comment>AHB_SYS_CTL6</comment>
        <bits access="r" name="ptest" pos="0" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
      </reg>
      <hole size="4320"/>
      <reg name="platform_id" protect="rw">
        <comment>PLATFORM_ID</comment>
      </reg>
      <reg name="project_id" protect="rw">
        <comment>PROJECT_ID</comment>
      </reg>
      <reg name="derived_id" protect="rw">
        <comment>DERIVED_ID</comment>
        <bits access="r" name="derived_id" pos="15:8" rst="0x0">
          <comment>NOT USEChange the reset value</comment>
        </bits>
        <bits access="r" name="metal_fix_id" pos="7:0" rst="0x0">
          <comment>NOT USEChange the reset value</comment>
        </bits>
      </reg>
      <reg name="manufacture_id" protect="rw">
        <comment>MANUFACTURE_ID</comment>
        <bits access="r" name="process_id" pos="15:8" rst="0x0">
          <comment>NOT USEChange the reset value</comment>
        </bits>
        <bits access="r" name="foundry_id" pos="7:0" rst="0x0">
          <comment>NOT USEChange the reset value</comment>
        </bits>
      </reg>
      <reg name="implementation_id" protect="rw">
        <comment>IMPLEMENTATION_ID</comment>
        <bits access="r" name="mem_compiler" pos="15:8" rst="0x0">
          <comment>NOT USEChange the reset value</comment>
        </bits>
        <bits access="r" name="std_cell" pos="7:0" rst="0x0">
          <comment>NOT USEChange the reset value</comment>
        </bits>
      </reg>
      <hole size="1792"/>
      <reg name="cgm_en_ctrl" protect="rw">
        <comment>CGM_EN_CTRL</comment>
        <bits access="rw" name="gnss_ip_rtc_en" pos="4" rst="0x1">
          <comment>L68bitGNSS_wrap RTC</comment>
        </bits>
        <bits access="rw" name="gnss_ip_adc_en" pos="3" rst="0x1">
          <comment>NEWGNSS_wrap ADC</comment>
        </bits>
        <bits access="rw" name="gnss_ip_bb_pp_en" pos="2" rst="0x1">
          <comment>NEWGNSS_wrap bb_pp</comment>
        </bits>
        <bits access="rw" name="gnss_ip_ae_en" pos="1" rst="0x1">
          <comment>NEW,  GNSS_wrap AE_clk</comment>
        </bits>
        <bits access="rw" name="gnss_ip_en" pos="0" rst="0x1">
          <comment>NEWGNSS_wrap gnss_clk</comment>
        </bits>
      </reg>
      <hole size="352"/>
      <reg name="gnss2psram_lpc_cfg" protect="rw">
        <comment>GNSS2PSRAM_LPC_CFG</comment>
        <bits access="rw" name="gnss2psram_lp_eb" pos="24" rst="0x1">
          <comment>gnss2psramLPC</comment>
        </bits>
        <bits access="rw" name="gnss2psram_lp_pu_num" pos="23:16" rst="0x0">
          <comment>LPCcycle</comment>
        </bits>
        <bits access="rw" name="gnss2psram_lp_num" pos="15:0" rst="0x80">
          <comment>LPCcycle</comment>
        </bits>
      </reg>
      <reg name="gnss2psram_lpc_status" protect="rw">
        <comment>GNSS2PSRAM_LPC_STATUS</comment>
        <bits access="r" name="gnss2psram_lp_status" pos="0" rst="0x1">
          <comment>LPC</comment>
        </bits>
      </reg>
      <reg name="gnss2psram_lpc_force" protect="rw">
        <comment>GNSS2PSRAM_LPC_FORCE</comment>
        <bits access="rw" name="gnss2psram_lp_force" pos="1" rst="0x0">
          <comment>LPCforceLPC</comment>
        </bits>
        <bits access="r" name="gnss2psram_lp_force_ack" pos="0" rst="0x0">
          <comment>force_ack</comment>
        </bits>
      </reg>
      <hole size="24192"/>
      <reg name="ahb_eb0_set" protect="rw"/>
      <reg name="gnss_bb_en_set" protect="rw"/>
      <hole size="8032"/>
      <reg name="cgm_en_ctrl_set" protect="rw"/>
      <hole size="352"/>
      <reg name="gnss2psram_lpc_cfg_set" protect="rw"/>
      <hole size="24256"/>
      <reg name="ahb_eb0_clr" protect="rw"/>
      <reg name="gnss_bb_en_clr" protect="rw"/>
      <hole size="8032"/>
      <reg name="cgm_en_ctrl_clr" protect="rw"/>
      <hole size="352"/>
      <reg name="gnss2psram_lpc_cfg_clr" protect="rw"/>
      <hole size="24256"/>
      <reg name="soft_rst" protect="rw">
        <comment>SOFT_RST</comment>
        <bits access="rw" name="dump_soft_rst" pos="5" rst="0x0">
          <comment>NEWdump1</comment>
        </bits>
        <bits access="rw" name="gnss_soft_rst" pos="4" rst="0x0">
          <comment>L620bitGNSS_wrap1</comment>
        </bits>
        <bits access="rw" name="rft_soft_rst" pos="3" rst="0x0">
          <comment>L619bitRFT1</comment>
        </bits>
        <bits access="rw" name="pps_soft_rst" pos="2" rst="0x0">
          <comment>L64bitPPS1</comment>
        </bits>
        <bits access="rw" name="lpc_soft_rst" pos="1" rst="0x0">
          <comment>NEWLPC1</comment>
        </bits>
        <bits access="rw" name="rfad_spi_soft" pos="0" rst="0x0">
          <comment>NEWRFAD_SPI1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="pwr_on_rstn_index" protect="rw">
        <comment>PWR_ON_RSTN_INDEX</comment>
        <bits access="rw" name="lna_en" pos="1" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="ram_ema" protect="rw">
        <comment>RAM_EMA</comment>
        <bits access="rw" name="gnss_ram_rme_ctrl" pos="14" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
        <bits access="rw" name="gnss_ram_rm_ctrl" pos="13:10" rst="0x2">
          <comment>NOT USE</comment>
        </bits>
      </reg>
      <hole size="416"/>
      <reg name="fpgadebug" protect="rw">
        <comment>FPGADEBUG</comment>
      </reg>
      <hole size="3776"/>
      <reg name="sleep_status" protect="rw">
        <comment>SLEEP_STATUS</comment>
        <bits access="r" name="chip_deep_sleep" pos="0" rst="0x0">
          <comment>NOT CHANGE</comment>
        </bits>
      </reg>
      <hole size="1024"/>
      <reg name="auto_gate_ctrl0" protect="rw">
        <comment>AUTO_GATE_CTRL0</comment>
      </reg>
      <reg name="auto_gate_ctrl1" protect="rw">
        <comment>AUTO_GATE_CTRL1</comment>
      </reg>
      <reg name="auto_gate_ctrl2" protect="rw">
        <comment>AUTO_GATE_CTRL2</comment>
      </reg>
      <reg name="auto_gate_ctrl3" protect="rw">
        <comment>AUTO_GATE_CTRL3</comment>
      </reg>
      <reg name="auto_gate_status0" protect="rw">
        <comment>AUTO_GATE_STATUS0</comment>
      </reg>
      <reg name="auto_gate_status1" protect="rw">
        <comment>AUTO_GATE_STATUS1</comment>
      </reg>
      <reg name="auto_gate_status2" protect="rw">
        <comment>AUTO_GATE_STATUS2</comment>
      </reg>
      <reg name="auto_gate_status3" protect="rw">
        <comment>AUTO_GATE_STATUS3</comment>
      </reg>
      <hole size="224"/>
      <reg name="latch_pulse_num" protect="rw">
        <comment>LATCH_PULSE_NUM</comment>
        <bits access="rw" name="latch_pulse_num" pos="3:0" rst="0xf">
          <comment>GNSSRTC_latchCPU_latch15</comment>
        </bits>
      </reg>
      <reg name="adc_iq_hold_sel" protect="rw">
        <comment>ADC_IQ_HOLD_SEL</comment>
        <bits access="rw" name="adc_iq_hold_sel" pos="0" rst="0x0">
          <comment>GNSS holdIQ0RF-sysholdbit10IQ0</comment>
        </bits>
      </reg>
      <reg name="async_bridge_dbg_singal_w" protect="rw">
        <comment>ASYNC_BRIDGE_DBG_SINGAL_W</comment>
      </reg>
      <reg name="async_bridge_detector_overflow" protect="rw">
        <comment>ASYNC_BRIDGE_DETECTOR_OVERFLOW</comment>
        <bits access="r" name="axi_detector_overflow" pos="0" rst="0x0">
          <comment>overflow</comment>
        </bits>
      </reg>
      <reg name="gps_coexist_in" protect="rw">
        <comment>GPS_COEXIST_IN</comment>
        <bits access="rw" name="gps_coexist_in" pos="0" rst="0x0">
          <comment>GNSS_wrapGPS</comment>
        </bits>
      </reg>
      <reg name="axi_reg_slice_ds_force" protect="rw">
        <comment>AXI_REG_SLICE_DS_FORCE</comment>
        <bits access="rw" name="dowm_sream_disable_force" pos="1" rst="0x0">
          <comment>AXI anti_hang</comment>
        </bits>
        <bits access="rw" name="dowm_sream_disable_force_sel" pos="0" rst="0x1">
          <comment>AXI anti_hangdowm_sream_disable_force0AXIISO_EN</comment>
        </bits>
      </reg>
      <reg name="gnss_axi_qos" protect="rw">
        <comment>AXI_REG_SLICE_DS_FORCE</comment>
        <bits access="rw" name="gnss_awqos" pos="7:4" rst="0x0">
          <comment>GNSS to PSRAM AWQOS config</comment>
        </bits>
        <bits access="rw" name="gnss_arqos" pos="3:0" rst="0x0">
          <comment>GNSS to PSRAM ARQOS config</comment>
        </bits>
      </reg>
      <reg name="gnss_ahb_err_resp_en" protect="rw">
        <comment>AXI_REG_SLICE_DS_FORCE</comment>
        <bits access="rw" name="ahb_err_resp_en" pos="0" rst="0x0">
          <comment>AHB Anti_hang err resp enactive highforce to resp err</comment>
        </bits>
      </reg>
      <hole size="26592"/>
      <reg name="soft_rst_set" protect="rw"/>
      <hole size="5888"/>
      <reg name="latch_pulse_num_set" protect="rw"/>
      <reg name="adc_iq_hold_sel_set" protect="rw"/>
      <hole size="64"/>
      <reg name="gps_coexist_in_set" protect="rw"/>
      <reg name="axi_reg_slice_ds_force_set" protect="rw"/>
      <reg name="gnss_axi_qos_set" protect="rw"/>
      <reg name="gnss_ahb_err_resp_en_set" protect="rw"/>
      <hole size="26592"/>
      <reg name="soft_rst_clr" protect="rw"/>
      <hole size="5888"/>
      <reg name="latch_pulse_num_clr" protect="rw"/>
      <reg name="adc_iq_hold_sel_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="gps_coexist_in_clr" protect="rw"/>
      <reg name="axi_reg_slice_ds_force_clr" protect="rw"/>
      <reg name="gnss_axi_qos_clr" protect="rw"/>
      <reg name="gnss_ahb_err_resp_en_clr" protect="rw"/>
    </module>
    <var name="REG_GNSS_SYS_SET_OFFSET" value="0x1000"/>
    <var name="REG_GNSS_SYS_CLR_OFFSET" value="0x2000"/>
    <instance address="0x1c000000" name="GNSS_SYS" type="GNSS_SYS"/>
  </archive>
  <archive relative="gnss_clk.xml">
    <module category="System" name="GNSS_CLK">
      <hole size="320"/>
      <reg name="cgm_gnss_mtx_sel_cfg" protect="rw">
        <comment>cgm_gnss_mtx_sel_cfg clk_mtx_sel</comment>
        <bits access="rw" name="cgm_gnss_mtx_sel" pos="2:0" rst="0x0">
          <comment>0: 26m, 1: 62.5m, 2: 125m, 3: 133m, 4: 158m, 5:167m</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_gnss_bb_pp_sel_cfg" protect="rw">
        <comment>cgm_gnss_bb_pp_sel_cfg clk_bb_pp_sel</comment>
        <bits access="rw" name="cgm_gnss_bb_pp_sel" pos="16" rst="0x0">
          <comment>not use</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cgm_gnss_adc_sel_cfg" protect="rw">
        <comment>cgm_gnss_adc_sel_cfg clk_adc_sel</comment>
        <bits access="rw" name="cgm_gnss_adc_sel" pos="16" rst="0x0"/>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg0" protect="rw">
        <comment>cgm_busy_src_monitor_cfg0 cgm_busy_monitor</comment>
        <bits access="r" name="cgm_busy_src_monitor0" pos="8:0" rst="0x40">
          <comment>cgm_busy monitor</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x1c010000" name="GNSS_CLK" type="GNSS_CLK"/>
  </archive>
  <archive relative="gnss_spi.xml">
    <module category="System" name="GNSS_SPI">
      <reg name="spi_cfg" protect="rw">
        <comment>SPI_CFG</comment>
        <bits access="rw" name="spi_rw" pos="30" rst="0x0">
          <comment>0: write ; 1 : read</comment>
        </bits>
        <bits access="rw" name="distance" pos="29:26" rst="0x3">
          <comment>SEsclk</comment>
        </bits>
        <bits access="rw" name="frq_div_rd" pos="25:23" rst="0x1">
          <comment>4 + FRQ_DIV_RD*2</comment>
        </bits>
        <bits access="rw" name="frq_div_wr" pos="22:20" rst="0x1">
          <comment>4 + FRQ_DIV_WR*2</comment>
        </bits>
        <bits access="rw" name="cs_inv" pos="19" rst="0x0">
          <comment>
01</comment>
        </bits>
        <bits access="rw" name="dux" pos="18" rst="0x0">
          <comment>01</comment>
        </bits>
        <bits access="rw" name="ms" pos="17" rst="0x0">
          <comment>
0314</comment>
        </bits>
        <bits access="rw" name="rd_inter" pos="16:15" rst="0x2">
          <comment>SPISPIdefault2</comment>
        </bits>
        <bits access="rw" name="rd_edge" pos="14" rst="0x0">
          <comment>
00
1</comment>
        </bits>
        <bits access="rw" name="sec" pos="13" rst="0x0">
          <comment>
0normal
1DIG_RF</comment>
        </bits>
        <bits access="rw" name="cpha" pos="12" rst="0x1">
          <comment>SPI
0:
1</comment>
        </bits>
        <bits access="rw" name="cpol" pos="11" rst="0x0">
          <comment>SPI
0SPIIDLE
1SPIIDLE</comment>
        </bits>
        <bits access="rw" name="spol" pos="10" rst="0x0">
          <comment>SPI
0SPI
1SPI</comment>
        </bits>
        <bits access="rw" name="rx_data_len" pos="9:5" rst="0xf">
          <comment>SPIdefault = 16bit</comment>
        </bits>
        <bits access="rw" name="tx_data_len" pos="4:0" rst="0x1f">
          <comment>SPIdefault = 32bit</comment>
        </bits>
      </reg>
      <reg name="spi_rxdata" protect="rw">
        <comment>SPI_RXDATA</comment>
      </reg>
      <reg name="spi_immdata" protect="rw">
        <comment>SPI_IMMDATA</comment>
      </reg>
      <hole size="32"/>
      <reg name="spi_status" protect="rw">
        <comment>SPI_STATUS</comment>
        <bits access="r" name="spi_status" pos="0" rst="0x0">
          <comment>1SPI0</comment>
        </bits>
      </reg>
      <hole size="32608"/>
      <reg name="spi_cfg_set" protect="rw"/>
      <hole size="32"/>
      <reg name="spi_immdata_set" protect="rw"/>
      <hole size="32672"/>
      <reg name="spi_cfg_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="spi_immdata_clr" protect="rw"/>
    </module>
    <var name="REG_GNSS_SPI_SET_OFFSET" value="0x1000"/>
    <var name="REG_GNSS_SPI_CLR_OFFSET" value="0x2000"/>
    <instance address="0x1c040000" name="GNSS_SPI" type="GNSS_SPI"/>
  </archive>
  <archive relative="iomux.xml">
    <module category="System" name="IOMUX">
      <reg name="pwr_pad_ctl" protect="rw">
        <comment>Reserved address for Power Pad control registers</comment>
        <bits access="rw" name="pwrreg_ms_v_mmc_18_30" pos="20" rst="0x1">
          <comment>Power control pin[MS] for power [V_MMC_18_30]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_v_mmc_18_30" pos="19" rst="0x0">
          <comment>Power control pin[MSOUT] for power [V_MMC_18_30]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_v_mmc_18_30" pos="18" rst="0x0">
          <comment>Power control pin[MSEN] for power [V_MMC_18_30]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_v_lcd_18_33" pos="17" rst="0x1">
          <comment>Power control pin[MS] for power [V_LCD_18_33]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_v_lcd_18_33" pos="16" rst="0x0">
          <comment>Power control pin[MSOUT] for power [V_LCD_18_33]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_v_lcd_18_33" pos="15" rst="0x0">
          <comment>Power control pin[MSEN] for power [V_LCD_18_33]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_vddio_18_33" pos="14" rst="0x1">
          <comment>Power control pin[MS] for power [VDDIO_18_33]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_vddio_18_33" pos="13" rst="0x0">
          <comment>Power control pin[MSOUT] for power [VDDIO_18_33]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_vddio_18_33" pos="12" rst="0x0">
          <comment>Power control pin[MSEN] for power [VDDIO_18_33]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_vsim0" pos="11" rst="0x1">
          <comment>Power control pin[MS] for power [VSIM0]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_vsim0" pos="10" rst="0x0">
          <comment>Power control pin[MSOUT] for power [VSIM0]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_vsim0" pos="9" rst="0x0">
          <comment>Power control pin[MSEN] for power [VSIM0]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_vsim1" pos="8" rst="0x1">
          <comment>Power control pin[MS] for power [VSIM1]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_vsim1" pos="7" rst="0x0">
          <comment>Power control pin[MSOUT] for power [VSIM1]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_vsim1" pos="6" rst="0x0">
          <comment>Power control pin[MSEN] for power [VSIM1]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_vlpvddio1833_1" pos="5" rst="0x1">
          <comment>Power control pin[MS] for power [VLPVDDIO1833_1]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_vlpvddio1833_1" pos="4" rst="0x0">
          <comment>Power control pin[MSOUT] for power [VLPVDDIO1833_1]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_vlpvddio1833_1" pos="3" rst="0x0">
          <comment>Power control pin[MSEN] for power [VLPVDDIO1833_1]</comment>
        </bits>
        <bits access="rw" name="pwrreg_ms_lpvddio_18_33" pos="2" rst="0x1">
          <comment>Power control pin[MS] for power [LPVDDIO_18_33]</comment>
        </bits>
        <bits access="r" name="pwrreg_msout_lpvddio_18_33" pos="1" rst="0x0">
          <comment>Power control pin[MSOUT] for power [LPVDDIO_18_33]</comment>
        </bits>
        <bits access="rw" name="pwrreg_msen_lpvddio_18_33" pos="0" rst="0x0">
          <comment>Power control pin[MSEN] for power [LPVDDIO_18_33]</comment>
        </bits>
      </reg>
      <reg name="pin_ctrl_reg0" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="pin_ctrl_reg1" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="pin_ctrl_reg2" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="pin_ctrl_reg3" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="pin_ctrl_reg4" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="pin_ctrl_reg5" protect="rw">
        <comment>Global Pin control registers</comment>
      </reg>
      <reg name="rfdig_gpio_7" protect="rw">
        <comment>Pad u_RFDIG_GPIO_7 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio7
     3: lte_gpo_8</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_6" protect="rw">
        <comment>Pad u_RFDIG_GPIO_6 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio6
     3: lte_gpo_7</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_5" protect="rw">
        <comment>Pad u_RFDIG_GPIO_5 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio5
     3: lte_gpo_5</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_4" protect="rw">
        <comment>Pad u_RFDIG_GPIO_4 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio4
     3: lte_gpo_4</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_3" protect="rw">
        <comment>Pad u_RFDIG_GPIO_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio3
     3: lte_gpo_3</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_2" protect="rw">
        <comment>Pad u_RFDIG_GPIO_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rf_gpio2
     3: lte_gpo_2</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_1" protect="rw">
        <comment>Pad u_u_RFDIG_GPIO_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: rffe_sda
     1: rf_gpio1
     3: lte_gpo_1</comment>
        </bits>
      </reg>
      <reg name="rfdig_gpio_0" protect="rw">
        <comment>Pad u_RFDIG_GPIO_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: rffe_sck
     1: rf_gpio0
     3: lte_gpo_0</comment>
        </bits>
      </reg>
      <reg name="keyin_4" protect="rw">
        <comment>Pad u_KEYIN_4 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_4
     1: gpio_8
     2: pwm_0
     3: pwm_4
     4: i2c_m2_scl
     6: debug_bus_12
     7: uart_5_rxd</comment>
        </bits>
      </reg>
      <reg name="keyout_5" protect="rw">
        <comment>Pad u_KEYOUT_5 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_5
     1: gpio_11
     2: pwm_3
     3: uart_4_txd
     7: uart_5_rts</comment>
        </bits>
      </reg>
      <reg name="keyin_5" protect="rw">
        <comment>Pad u_KEYIN_5 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_5
     1: gpio_9
     2: pwm_1
     3: pwm_5
     4: i2c_m2_sda
     7: uart_5_txd</comment>
        </bits>
      </reg>
      <reg name="keyout_4" protect="rw">
        <comment>Pad u_KEYOUT_4 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_4
     1: gpio_10
     2: pwm_2
     3: uart_4_rxd
     7: uart_5_cts</comment>
        </bits>
      </reg>
      <reg name="uart_1_rts" protect="rw">
        <comment>Pad u_UART_1_RTS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_1_rts
     1: pwm_3
     2: pwm_11
     3: uart_2_rxd
     4: gpio_15</comment>
        </bits>
      </reg>
      <reg name="uart_1_txd" protect="rw">
        <comment>Pad u_UART_1_TXD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_1_txd
     1: gpio_13</comment>
        </bits>
      </reg>
      <reg name="uart_1_rxd" protect="rw">
        <comment>Pad u_UART_1_RXD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_1_rxd
     1: gpio_12</comment>
        </bits>
      </reg>
      <reg name="uart_1_cts" protect="rw">
        <comment>Pad u_UART_1_CTS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_1_cts
     1: gpio_14
     2: pwm_10
     3: uart_2_txd</comment>
        </bits>
      </reg>
      <reg name="gpio_0" protect="rw">
        <comment>Pad u_GPIO_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_0
     1: spi_2_clk
     3: uart_1_rxd
     4: uart_3_rxd
     5: pwm_8
     6: debug_clk
     7: uart_2_rxd</comment>
        </bits>
      </reg>
      <reg name="gpio_3" protect="rw">
        <comment>Pad u_GPIO_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_3
     1: spi_2_di_1
     3: uart_1_rts
     4: uart_4_txd
     5: pwm_11
     6: debug_bus_2
     7: uart_2_rts</comment>
        </bits>
      </reg>
      <reg name="gpio_2" protect="rw">
        <comment>Pad u_GPIO_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_2
     1: spi_2_dio_0
     3: uart_1_cts
     4: uart_4_rxd
     5: pwm_10
     6: debug_bus_1
     7: uart_2_cts</comment>
        </bits>
      </reg>
      <reg name="gpio_1" protect="rw">
        <comment>Pad u_GPIO_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_1
     1: spi_2_cs_0
     3: uart_1_txd
     4: uart_3_txd
     5: pwm_9
     6: debug_bus_0
     7: uart_2_txd</comment>
        </bits>
      </reg>
      <reg name="gpio_7" protect="rw">
        <comment>Pad u_GPIO_7 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_7
     1: pwm_2
     2: i2c_m2_sda
     3: uart_6_txd
     4: uart_3_txd</comment>
        </bits>
      </reg>
      <reg name="gpio_6" protect="rw">
        <comment>Pad u_GPIO_6 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_6
     1: pwm_1
     2: i2c_m2_scl
     3: uart_6_rxd
     4: uart_3_rxd</comment>
        </bits>
      </reg>
      <reg name="gpio_5" protect="rw">
        <comment>Pad u_GPIO_5 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_5
     1: pwm_0
     3: uart_5_txd
     4: uart_3_rts
     5: test_clkout
     6: debug_bus_4</comment>
        </bits>
      </reg>
      <reg name="gpio_4" protect="rw">
        <comment>Pad u_GPIO_4 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_4
     1: spi_2_cs_1
     3: uart_5_rxd
     4: uart_3_cts
     5: pwm_12
     6: debug_bus_3</comment>
        </bits>
      </reg>
      <reg name="adi_sda" protect="rw">
        <comment>Pad u_ADI_SDA control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ADI_SDA</comment>
        </bits>
      </reg>
      <reg name="adi_scl" protect="rw">
        <comment>Pad u_ADI_SCL control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ADI_SCL</comment>
        </bits>
      </reg>
      <reg name="resetb" protect="rw">
        <comment>Pad u_RESETB control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: RESETB</comment>
        </bits>
      </reg>
      <reg name="osc_32k" protect="rw">
        <comment>Pad u_OSC_32K control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: OSC_32K</comment>
        </bits>
      </reg>
      <reg name="pmic_ext_int" protect="rw">
        <comment>Pad u_PMIC_EXT_INT control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: PMIC_EXT_INT</comment>
        </bits>
      </reg>
      <reg name="chip_pd" protect="rw">
        <comment>Pad u_CHIP_PD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: CHIP_PD</comment>
        </bits>
      </reg>
      <reg name="ptest" protect="rw">
        <comment>Pad u_PTEST control</comment>
      </reg>
      <reg name="clk26m_pmic" protect="rw">
        <comment>Pad u_CLK26M_PMIC control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: clk26m_pmic</comment>
        </bits>
      </reg>
      <reg name="sim_1_rst" protect="rw">
        <comment>Pad u_SIM_1_RST control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_1_rst
     1: gpio_32
     2: pwm_6</comment>
        </bits>
      </reg>
      <reg name="sim_1_dio" protect="rw">
        <comment>Pad u_SIM_1_DIO control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_1_dio
     1: gpio_31
     2: pwm_5</comment>
        </bits>
      </reg>
      <reg name="sim_1_clk" protect="rw">
        <comment>Pad u_SIM_1_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_1_clk
     1: gpio_30
     2: pwm_4</comment>
        </bits>
      </reg>
      <reg name="sim_0_rst" protect="rw">
        <comment>Pad u_SIM_0_RST control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_0_rst</comment>
        </bits>
      </reg>
      <reg name="sim_0_dio" protect="rw">
        <comment>Pad u_SIM_0_DIO control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_0_dio</comment>
        </bits>
      </reg>
      <reg name="sim_0_clk" protect="rw">
        <comment>Pad u_SIM_0_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: sim_0_clk</comment>
        </bits>
      </reg>
      <reg name="sw_clk" protect="rw">
        <comment>Pad u_SW_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ap_jtag_tck
     1: gpio_24
     3: spi_1_clk
     4: sdmmc2_clk
     6: tsx_adc_ch_sel</comment>
        </bits>
      </reg>
      <reg name="sw_dio" protect="rw">
        <comment>Pad u_SW_DIO control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ap_jtag_tms
     1: gpio_25
     3: spi_1_cs_0
     4: sdmmc2_cmd
     6: tsx_adc_clk</comment>
        </bits>
      </reg>
      <reg name="debug_host_tx" protect="rw">
        <comment>Pad u_DEBUG_HOST_TX control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ap_jtag_tdo
     1: gpio_27
     2: debug_host_tx
     3: spi_1_di_1
     4: sdmmc2_data_1
     6: osc_adc_clk</comment>
        </bits>
      </reg>
      <reg name="debug_host_rx" protect="rw">
        <comment>Pad u_DEBUG_HOST_RX control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ap_jtag_tdi
     1: gpio_26
     2: debug_host_rx
     3: spi_1_dio_0
     4: sdmmc2_data_0
     6: tsx_adc_ch_data</comment>
        </bits>
      </reg>
      <reg name="debug_host_clk" protect="rw">
        <comment>Pad u_DEBUG_HOST_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: ap_jtag_trst
     1: gpio_28
     2: debug_host_clk
     3: spi_1_cs_1
     4: sdmmc2_data_2
     6: osc_adc_data</comment>
        </bits>
      </reg>
      <reg name="camera_rst_l" protect="rw">
        <comment>Pad u_CAMERA_RST_L control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: camera_rst_l
     1: pwm_6
     2: i2c_m3_scl
     3: gpio_44
     6: debug_bus_2
     8: DBG_DO_11</comment>
        </bits>
      </reg>
      <reg name="spi_camera_sck" protect="rw">
        <comment>Pad u_SPI_CAMERA_SCK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_camera_sck
     1: pwm_9
     2: gpio_18
     3: aud_da_d1
     6: debug_bus_7</comment>
        </bits>
      </reg>
      <reg name="spi_camera_si_1" protect="rw">
        <comment>Pad u_SPI_CAMERA_SI_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_camera_si_1
     1: i2c_m2_sda
     2: spi_camera_si_0
     3: spi_camera_ssn
     6: debug_bus_6</comment>
        </bits>
      </reg>
      <reg name="spi_camera_si_0" protect="rw">
        <comment>Pad u_SPI_CAMERA_SI_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_camera_si_0
     1: i2c_m2_scl
     2: spi_camera_si_1
     3: gpio_47
     6: CTS
     8: DBG_CLK</comment>
        </bits>
      </reg>
      <reg name="camera_ref_clk" protect="rw">
        <comment>Pad u_CAMERA_REF_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: camera_ref_clk
     1: pwm_8
     2: gpio_46
     6: debug_bus_4
     8: DBG_TRIG</comment>
        </bits>
      </reg>
      <reg name="camera_pwdn" protect="rw">
        <comment>Pad u_CAMERA_PWDN control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: camera_pwdn
     1: pwm_7
     2: i2c_m3_sda
     3: gpio_45
     6: debug_bus_3
     7: GPADC_IN3
     8: DBG_DO_12</comment>
        </bits>
      </reg>
      <reg name="i2s_sdat_i" protect="rw">
        <comment>Pad u_I2S_SDAT_I control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2s1_sdat_i
     1: pwm_10
     2: gpio_21
     3: aud_ad_d0
     4: i2c_m3_scl
     8: DBG_DO_15</comment>
        </bits>
      </reg>
      <reg name="i2s1_sdat_o" protect="rw">
        <comment>Pad u_I2S1_SDAT_O control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: i2s1_sdat_o
     1: pwm_11
     2: gpio_22
     3: aud_sclk
     4: i2c_m3_sda</comment>
        </bits>
      </reg>
      <reg name="i2s1_lrck" protect="rw">
        <comment>Pad u_I2S1_LRCK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2s1_lrck
     1: i2c_m3_sda
     2: gpio_20
     3: aud_ad_sync
     8: DBG_DO_14</comment>
        </bits>
      </reg>
      <reg name="i2s1_bck" protect="rw">
        <comment>Pad u_I2S1_BCK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2s1_bck
     1: i2c_m3_scl
     2: gpio_19
     3: aud_da_d0
     8: DBG_DO_13</comment>
        </bits>
      </reg>
      <reg name="i2s1_mclk" protect="rw">
        <comment>Pad u_I2S1_MCLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x1">
          <comment>Function Mode select
     0: i2s1_mclk
     1: gpio_46</comment>
        </bits>
      </reg>
      <reg name="i2c_m2_scl" protect="rw">
        <comment>Pad u_I2C_M2_SCL control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2c_m2_scl
     1: pwm_4
     2: gpio_42
     3: aud_da_sync
     6: debug_bus_0
     8: DBG_DO_9</comment>
        </bits>
      </reg>
      <reg name="i2c_m2_sda" protect="rw">
        <comment>Pad u_I2C_M2_SDA control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2c_m2_sda
     1: pwm_5
     2: gpio_43
     3: aud_da_d1
     6: debug_bus_1
     8: DBG_DO_10</comment>
        </bits>
      </reg>
      <reg name="nand_sel" protect="rw">
        <comment>Pad u_Nand_sel control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: Nand_sel</comment>
        </bits>
      </reg>
      <reg name="keyout_3" protect="rw">
        <comment>Pad u_KEYOUT_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_3
     1: gpio_35
     3: i2c_m1_sda
     6: debug_clk</comment>
        </bits>
      </reg>
      <reg name="keyout_2" protect="rw">
        <comment>Pad u_KEYOUT_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_2
     1: gpio_34
     3: i2c_m1_scl
     6: debug_bus_15</comment>
        </bits>
      </reg>
      <reg name="keyout_1" protect="rw">
        <comment>Pad u_KEYOUT_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_1
     1: gpio_33
     2: uart_6_txd
     3: pwm_7
     6: debug_bus_14</comment>
        </bits>
      </reg>
      <reg name="keyout_0" protect="rw">
        <comment>Pad u_KEYOUT_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyout_0
     1: gpio_32
     2: uart_6_rxd
     3: pwm_6
     6: debug_bus_13</comment>
        </bits>
      </reg>
      <reg name="keyin_3" protect="rw">
        <comment>Pad u_KEYIN_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_3
     1: gpio_31
     2: uart_4_txd
     6: debug_bus_11</comment>
        </bits>
      </reg>
      <reg name="keyin_2" protect="rw">
        <comment>Pad u_KEYIN_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_2
     1: gpio_30
     2: uart_4_rxd
     6: debug_bus_10</comment>
        </bits>
      </reg>
      <reg name="keyin_1" protect="rw">
        <comment>Pad u_KEYIN_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_1
     1: gpio_29
     2: pwm_15
     6: debug_bus_9</comment>
        </bits>
      </reg>
      <reg name="keyin_0" protect="rw">
        <comment>Pad u_KEYIN_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: keyin_0
     1: gpio_28
     2: pwm_14
     6: debug_bus_8</comment>
        </bits>
      </reg>
      <reg name="lcd_rstb" protect="rw">
        <comment>Pad u_LCD_RSTB control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: lcd_rstb
     2: gpio_41
     6: debug_bus_11</comment>
        </bits>
      </reg>
      <reg name="lcd_fmark" protect="rw">
        <comment>Pad u_LCD_FMARK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: lcd_fmark
     1: spi_flash1_sio_3
     2: gpio_40
     6: debug_bus_10
     7: GPADC_IN2
     8: DBG_DO_8</comment>
        </bits>
      </reg>
      <reg name="spi_lcd_select" protect="rw">
        <comment>Pad u_SPI_LCD_SELECT control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_lcd_select
     1: spi_flash1_sio_2
     2: gpio_39
     6: debug_bus_9
     8: DBG_DO_7</comment>
        </bits>
      </reg>
      <reg name="spi_lcd_cs" protect="rw">
        <comment>Pad u_SPI_LCD_CS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_lcd_cs
     1: spi_flash1_sio_1
     2: gpio_38
     6: debug_bus_8
     8: DBG_DO_6</comment>
        </bits>
      </reg>
      <reg name="spi_lcd_clk" protect="rw">
        <comment>Pad u_SPI_LCD_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_lcd_clk
     1: spi_flash1_sio_0
     2: gpio_37
     6: debug_bus_7
     8: DBG_DO_5</comment>
        </bits>
      </reg>
      <reg name="spi_lcd_sdc" protect="rw">
        <comment>Pad u_SPI_LCD_SDC control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_lcd_sdc
     1: spi_flash1_cs
     2: gpio_36
     6: debug_bus_6
     7: GPADC_IN1
     8: DBG_DO_4</comment>
        </bits>
      </reg>
      <reg name="spi_lcd_sio" protect="rw">
        <comment>Pad u_SPI_LCD_SIO control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: spi_lcd_sio
     1: spi_flash1_clk
     2: gpio_35
     6: debug_bus_5
     8: DBG_DO_3</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_rst" protect="rw">
        <comment>Pad u_SDMMC1_RST control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_RST
     1: gpio_36</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_7" protect="rw">
        <comment>Pad u_SDMMC1_DATA_7 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_7
     1: gpio_27
     2: pwm_13
     3: i2c_m2_sda
     4: spi_1_cs_1
     5: uart_4_txd
     6: spi_flash1_sio_3
     7: timestamp_out
     8: dbgio_data7</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_6" protect="rw">
        <comment>Pad u_SDMMC1_DATA_6 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_6
     1: gpio_26
     2: pwm_12
     3: i2c_m2_scl
     4: spi_1_di_1
     5: uart_4_rxd
     6: spi_flash1_sio_2
     7: timestamp_in
     8: dbgio_data6</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_5" protect="rw">
        <comment>Pad u_SDMMC1_DATA_5 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_5
     1: gpio_25
     2: i2c_m1_sda
     3: timestamp_out
     4: spi_1_dio_0
     5: uart_4_rts
     6: spi_flash1_sio_1
     7: PPS_OUT
     8: dbgio_data5</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_4" protect="rw">
        <comment>Pad u_SDMMC1_DATA_4 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_4
     1: gpio_24
     2: i2c_m1_scl
     3: timestamp_in
     4: spi_1_cs_0
     5: uart_4_cts
     6: spi_flash1_sio_0
     7: Lna_en
     8: dbgio_data4</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_3" protect="rw">
        <comment>Pad u_SDMMC1_DATA_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_3
     1: gpio_21
     2: spi_camera_sck
     3: pwm_15
     4: spi_1_clk
     5: uart_3_txd
     6: spi_flash1_cs
     8: dbgio_data3</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_2" protect="rw">
        <comment>Pad u_SDMMC1_DATA_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_2
     1: gpio_20
     2: spi_camera_si_1
     3: spi_camera_si_0
     4: spi_2_cs_1
     5: uart_3_rxd
     6: spi_flash1_clk
     8: dbgio_data2</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_1" protect="rw">
        <comment>Pad u_SDMMC1_DATA_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_1
     1: gpio_19
     2: spi_camera_si_0
     3: spi_camera_si_1
     4: spi_2_di_1
     5: uart_5_txd
     6: uart_6_rts
     8: dbgio_data1</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_data_0" protect="rw">
        <comment>Pad u_SDMMC1_DATA_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_DATA_0
     1: gpio_18
     2: camera_ref_clk
     3: i2c_m1_sda
     4: spi_2_dio_0
     5: uart_5_rxd
     6: uart_6_cts
     8: dbgio_data0</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_cmd" protect="rw">
        <comment>Pad u_SDMMC1_CMD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_CMD
     1: gpio_17
     2: camera_pwdn
     3: i2c_m1_scl
     4: spi_2_cs_0
     5: uart_2_txd
     6: uart_6_txd
     8: dbgio_cmd</comment>
        </bits>
      </reg>
      <reg name="sdmmc1_clk" protect="rw">
        <comment>Pad u_SDMMC1_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: SDMMC1_CLK
     1: gpio_16
     2: camera_rst_l
     3: pwm_14
     4: spi_2_clk
     5: uart_2_rxd
     6: uart_6_rxd
     8: dbgio_clk</comment>
        </bits>
      </reg>
      <reg name="uart_2_rts" protect="rw">
        <comment>Pad u_UART_2_RTS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_2_rts
     1: gpio_34
     2: uart_2_rxd
     3: i2c_m3_sda
     4: uart_4_txd</comment>
        </bits>
      </reg>
      <reg name="uart_2_cts" protect="rw">
        <comment>Pad u_UART_2_CTS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_2_cts
     1: gpio_33
     2: uart_2_txd
     3: i2c_m3_scl
     4: uart_4_rxd</comment>
        </bits>
      </reg>
      <reg name="uart_2_txd" protect="rw">
        <comment>Pad u_UART_2_TXD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_2_txd
     1: i2c_m1_sda
     2: pwm_13
     3: gpio_32
     4: uart_3_txd</comment>
        </bits>
      </reg>
      <reg name="uart_2_rxd" protect="rw">
        <comment>Pad u_UART_2_RXD control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: uart_2_rxd
     1: i2c_m1_scl
     2: pwm_12
     3: gpio_31
     4: uart_3_rxd</comment>
        </bits>
      </reg>
      <reg name="i2c_m1_sda" protect="rw">
        <comment>Pad u_I2C_M1_SDA control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2c_m1_sda
     1: gpio_30
     2: uart_4_txd
     4: rf_gpio8</comment>
        </bits>
      </reg>
      <reg name="i2c_m1_scl" protect="rw">
        <comment>Pad u_I2C_M1_SCL control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: i2c_m1_scl
     1: gpio_29
     2: uart_4_rxd
     4: rf_gpio9</comment>
        </bits>
      </reg>
      <reg name="gpio_23" protect="rw">
        <comment>Pad u_GPIO_23 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_23
     1: spi_flash1_sio_3
     2: pwm_9
     3: sdmmc2_data_3
     4: rf_gpio8</comment>
        </bits>
      </reg>
      <reg name="gpio_22" protect="rw">
        <comment>Pad u_GPIO_22 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_22
     1: spi_flash1_sio_2
     2: spi_2_cs_1
     3: sdmmc2_data_2
     4: rf_gpio9
     5: osc_adc_data</comment>
        </bits>
      </reg>
      <reg name="gpio_21" protect="rw">
        <comment>Pad u_GPIO_21 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_21
     1: spi_flash1_sio_1
     2: spi_2_di_1
     3: sdmmc2_data_1
     5: osc_adc_clk</comment>
        </bits>
      </reg>
      <reg name="gpio_20" protect="rw">
        <comment>Pad u_GPIO_20 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_20
     1: spi_flash1_sio_0
     2: spi_2_dio_0
     3: sdmmc2_data_0
     4: pwm_15
     5: tsx_adc_ch_data</comment>
        </bits>
      </reg>
      <reg name="gpio_19" protect="rw">
        <comment>Pad u_GPIO_19 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_19
     1: spi_flash1_cs
     2: spi_2_cs_0
     3: sdmmc2_cmd
     4: pwm_14
     5: tsx_adc_clk</comment>
        </bits>
      </reg>
      <reg name="gpio_18" protect="rw">
        <comment>Pad u_GPIO_18 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_18
     1: spi_flash1_clk
     2: spi_2_clk
     3: sdmmc2_clk
     4: pwm_13
     5: tsx_adc_ch_sel
     6: digrf_strobe_s_o</comment>
        </bits>
      </reg>
      <reg name="gpio_17" protect="rw">
        <comment>Pad u_GPIO_17 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_17
     1: uart_3_rxd
     2: pwm_8
     3: i2c_m3_sda
     5: PPS_OUT
     6: uart_2_rts</comment>
        </bits>
      </reg>
      <reg name="gpio_16" protect="rw">
        <comment>Pad u_GPIO_16 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: gpio_16
     1: uart_3_txd
     2: pwm_7
     3: i2c_m3_scl
     4: sdmmc2_data_3
     5: Lna_en
     6: uart_2_cts</comment>
        </bits>
      </reg>
      <reg name="m_spi_d_3" protect="rw">
        <comment>Pad u_M_SPI_D_3 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_D_3</comment>
        </bits>
      </reg>
      <reg name="m_spi_d_2" protect="rw">
        <comment>Pad u_M_SPI_D_2 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_D_2</comment>
        </bits>
      </reg>
      <reg name="m_spi_d_1" protect="rw">
        <comment>Pad u_M_SPI_D_1 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_D_1</comment>
        </bits>
      </reg>
      <reg name="m_spi_d_0" protect="rw">
        <comment>Pad u_M_SPI_D_0 control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_D_0</comment>
        </bits>
      </reg>
      <reg name="m_spi_cs" protect="rw">
        <comment>Pad u_M_SPI_CS control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_CS</comment>
        </bits>
      </reg>
      <reg name="m_spi_clk" protect="rw">
        <comment>Pad u_M_SPI_CLK control</comment>
        <bits access="rw" name="func_sel" pos="5:2" rst="0x0">
          <comment>Function Mode select
     0: M_SPI_CLK</comment>
        </bits>
      </reg>
      <hole size="4896"/>
      <reg name="pad_rfdig_gpio_7" protect="rw">
        <comment>Pad u_RFDIG_GPIO_7 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_6" protect="rw">
        <comment>Pad u_RFDIG_GPIO_6 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_5" protect="rw">
        <comment>Pad u_RFDIG_GPIO_5 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_4" protect="rw">
        <comment>Pad u_RFDIG_GPIO_4 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_3" protect="rw">
        <comment>Pad u_RFDIG_GPIO_3 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_2" protect="rw">
        <comment>Pad u_RFDIG_GPIO_2 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_1" protect="rw">
        <comment>Pad u_u_RFDIG_GPIO_1 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_rfdig_gpio_0" protect="rw">
        <comment>Pad u_RFDIG_GPIO_0 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_4" protect="rw">
        <comment>Pad u_KEYIN_4 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_5" protect="rw">
        <comment>Pad u_KEYOUT_5 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_5" protect="rw">
        <comment>Pad u_KEYIN_5 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_4" protect="rw">
        <comment>Pad u_KEYOUT_4 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_1_rts" protect="rw">
        <comment>Pad u_UART_1_RTS control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_1_txd" protect="rw">
        <comment>Pad u_UART_1_TXD control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_1_rxd" protect="rw">
        <comment>Pad u_UART_1_RXD control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_1_cts" protect="rw">
        <comment>Pad u_UART_1_CTS control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_0" protect="rw">
        <comment>Pad u_GPIO_0 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_3" protect="rw">
        <comment>Pad u_GPIO_3 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_2" protect="rw">
        <comment>Pad u_GPIO_2 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_1" protect="rw">
        <comment>Pad u_GPIO_1 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_7" protect="rw">
        <comment>Pad u_GPIO_7 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_6" protect="rw">
        <comment>Pad u_GPIO_6 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_5" protect="rw">
        <comment>Pad u_GPIO_5 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_4" protect="rw">
        <comment>Pad u_GPIO_4 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_adi_sda" protect="rw">
        <comment>Pad u_ADI_SDA control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_adi_scl" protect="rw">
        <comment>Pad u_ADI_SCL control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_resetb" protect="rw">
        <comment>Pad u_RESETB control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
      </reg>
      <reg name="pad_osc_32k" protect="rw">
        <comment>Pad u_OSC_32K control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_pmic_ext_int" protect="rw">
        <comment>Pad u_PMIC_EXT_INT control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_chip_pd" protect="rw">
        <comment>Pad u_CHIP_PD control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x1">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x1">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_ptest" protect="rw">
        <comment>Pad u_PTEST control</comment>
      </reg>
      <reg name="pad_clk26m_pmic" protect="rw">
        <comment>Pad u_CLK26M_PMIC control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_1_rst" protect="rw">
        <comment>Pad u_SIM_1_RST control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_1_dio" protect="rw">
        <comment>Pad u_SIM_1_DIO control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_1_clk" protect="rw">
        <comment>Pad u_SIM_1_CLK control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_0_rst" protect="rw">
        <comment>Pad u_SIM_0_RST control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x1">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x1">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_0_dio" protect="rw">
        <comment>Pad u_SIM_0_DIO control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x1">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sim_0_clk" protect="rw">
        <comment>Pad u_SIM_0_CLK control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x1">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x1">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sw_clk" protect="rw">
        <comment>Pad u_SW_CLK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sw_dio" protect="rw">
        <comment>Pad u_SW_DIO control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_debug_host_tx" protect="rw">
        <comment>Pad u_DEBUG_HOST_TX control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_debug_host_rx" protect="rw">
        <comment>Pad u_DEBUG_HOST_RX control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_debug_host_clk" protect="rw">
        <comment>Pad u_DEBUG_HOST_CLK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_camera_rst_l" protect="rw">
        <comment>Pad u_CAMERA_RST_L control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_camera_sck" protect="rw">
        <comment>Pad u_SPI_CAMERA_SCK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_camera_si_1" protect="rw">
        <comment>Pad u_SPI_CAMERA_SI_1 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_camera_si_0" protect="rw">
        <comment>Pad u_SPI_CAMERA_SI_0 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="padi_switch" pos="10" rst="0x0">
          <comment>Pad switch control, 1--&gt;analog, 0--&gt;digital</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_camera_ref_clk" protect="rw">
        <comment>Pad u_CAMERA_REF_CLK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_camera_pwdn" protect="rw">
        <comment>Pad u_CAMERA_PWDN control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2s_sdat_i" protect="rw">
        <comment>Pad u_I2S_SDAT_I control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2s1_sdat_o" protect="rw">
        <comment>Pad u_I2S1_SDAT_O control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2s1_lrck" protect="rw">
        <comment>Pad u_I2S1_LRCK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2s1_bck" protect="rw">
        <comment>Pad u_I2S1_BCK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2s1_mclk" protect="rw">
        <comment>Pad u_I2S1_MCLK control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2c_m2_scl" protect="rw">
        <comment>Pad u_I2C_M2_SCL control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2c_m2_sda" protect="rw">
        <comment>Pad u_I2C_M2_SDA control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_nand_sel" protect="rw">
        <comment>Pad u_Nand_sel control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_3" protect="rw">
        <comment>Pad u_KEYOUT_3 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_2" protect="rw">
        <comment>Pad u_KEYOUT_2 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_1" protect="rw">
        <comment>Pad u_KEYOUT_1 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyout_0" protect="rw">
        <comment>Pad u_KEYOUT_0 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_3" protect="rw">
        <comment>Pad u_KEYIN_3 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_2" protect="rw">
        <comment>Pad u_KEYIN_2 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_1" protect="rw">
        <comment>Pad u_KEYIN_1 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_keyin_0" protect="rw">
        <comment>Pad u_KEYIN_0 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_lcd_rstb" protect="rw">
        <comment>Pad u_LCD_RSTB control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_lcd_fmark" protect="rw">
        <comment>Pad u_LCD_FMARK control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_lcd_select" protect="rw">
        <comment>Pad u_SPI_LCD_SELECT control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_lcd_cs" protect="rw">
        <comment>Pad u_SPI_LCD_CS control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_lcd_clk" protect="rw">
        <comment>Pad u_SPI_LCD_CLK control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_lcd_sdc" protect="rw">
        <comment>Pad u_SPI_LCD_SDC control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_spi_lcd_sio" protect="rw">
        <comment>Pad u_SPI_LCD_SIO control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_rst" protect="rw">
        <comment>Pad u_SDMMC1_RST control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_7" protect="rw">
        <comment>Pad u_SDMMC1_DATA_7 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_6" protect="rw">
        <comment>Pad u_SDMMC1_DATA_6 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_5" protect="rw">
        <comment>Pad u_SDMMC1_DATA_5 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_4" protect="rw">
        <comment>Pad u_SDMMC1_DATA_4 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_3" protect="rw">
        <comment>Pad u_SDMMC1_DATA_3 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_2" protect="rw">
        <comment>Pad u_SDMMC1_DATA_2 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_1" protect="rw">
        <comment>Pad u_SDMMC1_DATA_1 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_data_0" protect="rw">
        <comment>Pad u_SDMMC1_DATA_0 control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_cmd" protect="rw">
        <comment>Pad u_SDMMC1_CMD control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_sdmmc1_clk" protect="rw">
        <comment>Pad u_SDMMC1_CLK control</comment>
        <bits access="rw" name="drv" pos="22:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 3mA
    1: Driven strength 6mA
    2: Driven strength 9mA
    3: Driven strength 12mA
    4: Driven strength 15mA
    5: Driven strength 18mA
    6: Driven strength 21mA
    7: Driven strength 24mA
    8: Driven strength 27mA
    9: Driven strength 30mA
    10: Driven strength 33mA
    11: Driven strength 36mA
    12: Driven strength 39mA
    13: Driven strength 42mA
    14: Driven strength 45mA
    15: Driven strength 48mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_2_rts" protect="rw">
        <comment>Pad u_UART_2_RTS control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_2_cts" protect="rw">
        <comment>Pad u_UART_2_CTS control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_2_txd" protect="rw">
        <comment>Pad u_UART_2_TXD control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_uart_2_rxd" protect="rw">
        <comment>Pad u_UART_2_RXD control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2c_m1_sda" protect="rw">
        <comment>Pad u_I2C_M1_SDA control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_i2c_m1_scl" protect="rw">
        <comment>Pad u_I2C_M1_SCL control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x1">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_23" protect="rw">
        <comment>Pad u_GPIO_23 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_22" protect="rw">
        <comment>Pad u_GPIO_22 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_21" protect="rw">
        <comment>Pad u_GPIO_21 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_20" protect="rw">
        <comment>Pad u_GPIO_20 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_19" protect="rw">
        <comment>Pad u_GPIO_19 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_18" protect="rw">
        <comment>Pad u_GPIO_18 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_17" protect="rw">
        <comment>Pad u_GPIO_17 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_gpio_16" protect="rw">
        <comment>Pad u_GPIO_16 control</comment>
        <bits access="rw" name="drv" pos="20:19" rst="0x2">
          <comment>'drv' control for normal mode
    0: Driven strength 2mA
    1: Driven strength 4mA
    2: Driven strength 6mA
    3: Driven strength 8mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x0">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_d_3" protect="rw">
        <comment>Pad u_M_SPI_D_3 control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_d_2" protect="rw">
        <comment>Pad u_M_SPI_D_2 control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_d_1" protect="rw">
        <comment>Pad u_M_SPI_D_1 control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_d_0" protect="rw">
        <comment>Pad u_M_SPI_D_0 control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x1">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_cs" protect="rw">
        <comment>Pad u_M_SPI_CS control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <reg name="pad_m_spi_clk" protect="rw">
        <comment>Pad u_M_SPI_CLK control</comment>
        <bits access="rw" name="drv" pos="21:19" rst="0x1">
          <comment>'drv' control for normal mode
    0: Driven strength 4mA
    1: Driven strength 9mA
    2: Driven strength 13mA
    3: Driven strength 18mA
    4: Driven strength 22mA
    5: Driven strength 27mA
    6: Driven strength 32mA
    7: Driven strength 39mA</comment>
        </bits>
        <bits access="rw" name="dslp_en" pos="18:13" rst="0x3f">
          <comment>Sub-System deepsleep enable</comment>
        </bits>
        <bits access="rw" name="wpus" pos="12" rst="0x0">
          <comment>'wpus' control for normal mode</comment>
        </bits>
        <bits access="rw" name="se" pos="11" rst="0x0">
          <comment>'se' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpu" pos="7" rst="0x0">
          <comment>'wpu' control for normal mode</comment>
        </bits>
        <bits access="rw" name="wpdo" pos="6" rst="0x0">
          <comment>'wpdo' control for normal mode</comment>
        </bits>
        <bits access="rw" name="slp_wpu" pos="3" rst="0x0">
          <comment>'wpu' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_wpdo" pos="2" rst="0x0">
          <comment>'wpdo' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ie" pos="1" rst="0x1">
          <comment>'ie' control for deepsleep mode</comment>
        </bits>
        <bits access="rw" name="slp_oe" pos="0" rst="0x0">
          <comment>'oe' control for deepsleep mode</comment>
        </bits>
      </reg>
      <hole size="21056"/>
      <reg name="pwr_pad_ctl_reserved_set" protect="rw"/>
      <reg name="pin_ctrl_reg0_set" protect="rw"/>
      <reg name="pin_ctrl_reg1_set" protect="rw"/>
      <reg name="pin_ctrl_reg2_set" protect="rw"/>
      <reg name="pin_ctrl_reg3_set" protect="rw"/>
      <reg name="pin_ctrl_reg4_set" protect="rw"/>
      <reg name="pin_ctrl_reg5_set" protect="rw"/>
      <reg name="rfdig_gpio_7_set" protect="rw"/>
      <reg name="rfdig_gpio_6_set" protect="rw"/>
      <reg name="rfdig_gpio_5_set" protect="rw"/>
      <reg name="rfdig_gpio_4_set" protect="rw"/>
      <reg name="rfdig_gpio_3_set" protect="rw"/>
      <reg name="rfdig_gpio_2_set" protect="rw"/>
      <reg name="rfdig_gpio_1_set" protect="rw"/>
      <reg name="rfdig_gpio_0_set" protect="rw"/>
      <reg name="keyin_4_set" protect="rw"/>
      <reg name="keyout_5_set" protect="rw"/>
      <reg name="keyin_5_set" protect="rw"/>
      <reg name="keyout_4_set" protect="rw"/>
      <reg name="uart_1_rts_set" protect="rw"/>
      <reg name="uart_1_txd_set" protect="rw"/>
      <reg name="uart_1_rxd_set" protect="rw"/>
      <reg name="uart_1_cts_set" protect="rw"/>
      <reg name="gpio_0_set" protect="rw"/>
      <reg name="gpio_3_set" protect="rw"/>
      <reg name="gpio_2_set" protect="rw"/>
      <reg name="gpio_1_set" protect="rw"/>
      <reg name="gpio_7_set" protect="rw"/>
      <reg name="gpio_6_set" protect="rw"/>
      <reg name="gpio_5_set" protect="rw"/>
      <reg name="gpio_4_set" protect="rw"/>
      <reg name="adi_sda_set" protect="rw"/>
      <reg name="adi_scl_set" protect="rw"/>
      <reg name="resetb_set" protect="rw"/>
      <reg name="osc_32k_set" protect="rw"/>
      <reg name="pmic_ext_int_set" protect="rw"/>
      <reg name="chip_pd_set" protect="rw"/>
      <hole size="32"/>
      <reg name="clk26m_pmic_set" protect="rw"/>
      <reg name="sim_1_rst_set" protect="rw"/>
      <reg name="sim_1_dio_set" protect="rw"/>
      <reg name="sim_1_clk_set" protect="rw"/>
      <reg name="sim_0_rst_set" protect="rw"/>
      <reg name="sim_0_dio_set" protect="rw"/>
      <reg name="sim_0_clk_set" protect="rw"/>
      <reg name="sw_clk_set" protect="rw"/>
      <reg name="sw_dio_set" protect="rw"/>
      <reg name="debug_host_tx_set" protect="rw"/>
      <reg name="debug_host_rx_set" protect="rw"/>
      <reg name="debug_host_clk_set" protect="rw"/>
      <reg name="camera_rst_l_set" protect="rw"/>
      <reg name="spi_camera_sck_set" protect="rw"/>
      <reg name="spi_camera_si_1_set" protect="rw"/>
      <reg name="spi_camera_si_0_set" protect="rw"/>
      <reg name="camera_ref_clk_set" protect="rw"/>
      <reg name="camera_pwdn_set" protect="rw"/>
      <reg name="i2s_sdat_i_set" protect="rw"/>
      <reg name="i2s1_sdat_o_set" protect="rw"/>
      <reg name="i2s1_lrck_set" protect="rw"/>
      <reg name="i2s1_bck_set" protect="rw"/>
      <reg name="i2s1_mclk_set" protect="rw"/>
      <reg name="i2c_m2_scl_set" protect="rw"/>
      <reg name="i2c_m2_sda_set" protect="rw"/>
      <reg name="nand_sel_set" protect="rw"/>
      <reg name="keyout_3_set" protect="rw"/>
      <reg name="keyout_2_set" protect="rw"/>
      <reg name="keyout_1_set" protect="rw"/>
      <reg name="keyout_0_set" protect="rw"/>
      <reg name="keyin_3_set" protect="rw"/>
      <reg name="keyin_2_set" protect="rw"/>
      <reg name="keyin_1_set" protect="rw"/>
      <reg name="keyin_0_set" protect="rw"/>
      <reg name="lcd_rstb_set" protect="rw"/>
      <reg name="lcd_fmark_set" protect="rw"/>
      <reg name="spi_lcd_select_set" protect="rw"/>
      <reg name="spi_lcd_cs_set" protect="rw"/>
      <reg name="spi_lcd_clk_set" protect="rw"/>
      <reg name="spi_lcd_sdc_set" protect="rw"/>
      <reg name="spi_lcd_sio_set" protect="rw"/>
      <reg name="sdmmc1_rst_set" protect="rw"/>
      <reg name="sdmmc1_data_7_set" protect="rw"/>
      <reg name="sdmmc1_data_6_set" protect="rw"/>
      <reg name="sdmmc1_data_5_set" protect="rw"/>
      <reg name="sdmmc1_data_4_set" protect="rw"/>
      <reg name="sdmmc1_data_3_set" protect="rw"/>
      <reg name="sdmmc1_data_2_set" protect="rw"/>
      <reg name="sdmmc1_data_1_set" protect="rw"/>
      <reg name="sdmmc1_data_0_set" protect="rw"/>
      <reg name="sdmmc1_cmd_set" protect="rw"/>
      <reg name="sdmmc1_clk_set" protect="rw"/>
      <reg name="uart_2_rts_set" protect="rw"/>
      <reg name="uart_2_cts_set" protect="rw"/>
      <reg name="uart_2_txd_set" protect="rw"/>
      <reg name="uart_2_rxd_set" protect="rw"/>
      <reg name="i2c_m1_sda_set" protect="rw"/>
      <reg name="i2c_m1_scl_set" protect="rw"/>
      <reg name="gpio_23_set" protect="rw"/>
      <reg name="gpio_22_set" protect="rw"/>
      <reg name="gpio_21_set" protect="rw"/>
      <reg name="gpio_20_set" protect="rw"/>
      <reg name="gpio_19_set" protect="rw"/>
      <reg name="gpio_18_set" protect="rw"/>
      <reg name="gpio_17_set" protect="rw"/>
      <reg name="gpio_16_set" protect="rw"/>
      <reg name="m_spi_d_3_set" protect="rw"/>
      <reg name="m_spi_d_2_set" protect="rw"/>
      <reg name="m_spi_d_1_set" protect="rw"/>
      <reg name="m_spi_d_0_set" protect="rw"/>
      <reg name="m_spi_cs_set" protect="rw"/>
      <reg name="m_spi_clk_set" protect="rw"/>
      <hole size="4896"/>
      <reg name="pad_rfdig_gpio_7_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_6_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_5_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_4_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_3_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_2_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_1_set" protect="rw"/>
      <reg name="pad_rfdig_gpio_0_set" protect="rw"/>
      <reg name="pad_keyin_4_set" protect="rw"/>
      <reg name="pad_keyout_5_set" protect="rw"/>
      <reg name="pad_keyin_5_set" protect="rw"/>
      <reg name="pad_keyout_4_set" protect="rw"/>
      <reg name="pad_uart_1_rts_set" protect="rw"/>
      <reg name="pad_uart_1_txd_set" protect="rw"/>
      <reg name="pad_uart_1_rxd_set" protect="rw"/>
      <reg name="pad_uart_1_cts_set" protect="rw"/>
      <reg name="pad_gpio_0_set" protect="rw"/>
      <reg name="pad_gpio_3_set" protect="rw"/>
      <reg name="pad_gpio_2_set" protect="rw"/>
      <reg name="pad_gpio_1_set" protect="rw"/>
      <reg name="pad_gpio_7_set" protect="rw"/>
      <reg name="pad_gpio_6_set" protect="rw"/>
      <reg name="pad_gpio_5_set" protect="rw"/>
      <reg name="pad_gpio_4_set" protect="rw"/>
      <reg name="pad_adi_sda_set" protect="rw"/>
      <reg name="pad_adi_scl_set" protect="rw"/>
      <reg name="pad_resetb_set" protect="rw"/>
      <reg name="pad_osc_32k_set" protect="rw"/>
      <reg name="pad_pmic_ext_int_set" protect="rw"/>
      <reg name="pad_chip_pd_set" protect="rw"/>
      <hole size="32"/>
      <reg name="pad_clk26m_pmic_set" protect="rw"/>
      <reg name="pad_sim_1_rst_set" protect="rw"/>
      <reg name="pad_sim_1_dio_set" protect="rw"/>
      <reg name="pad_sim_1_clk_set" protect="rw"/>
      <reg name="pad_sim_0_rst_set" protect="rw"/>
      <reg name="pad_sim_0_dio_set" protect="rw"/>
      <reg name="pad_sim_0_clk_set" protect="rw"/>
      <reg name="pad_sw_clk_set" protect="rw"/>
      <reg name="pad_sw_dio_set" protect="rw"/>
      <reg name="pad_debug_host_tx_set" protect="rw"/>
      <reg name="pad_debug_host_rx_set" protect="rw"/>
      <reg name="pad_debug_host_clk_set" protect="rw"/>
      <reg name="pad_camera_rst_l_set" protect="rw"/>
      <reg name="pad_spi_camera_sck_set" protect="rw"/>
      <reg name="pad_spi_camera_si_1_set" protect="rw"/>
      <reg name="pad_spi_camera_si_0_set" protect="rw"/>
      <reg name="pad_camera_ref_clk_set" protect="rw"/>
      <reg name="pad_camera_pwdn_set" protect="rw"/>
      <reg name="pad_i2s_sdat_i_set" protect="rw"/>
      <reg name="pad_i2s1_sdat_o_set" protect="rw"/>
      <reg name="pad_i2s1_lrck_set" protect="rw"/>
      <reg name="pad_i2s1_bck_set" protect="rw"/>
      <reg name="pad_i2s1_mclk_set" protect="rw"/>
      <reg name="pad_i2c_m2_scl_set" protect="rw"/>
      <reg name="pad_i2c_m2_sda_set" protect="rw"/>
      <reg name="pad_nand_sel_set" protect="rw"/>
      <reg name="pad_keyout_3_set" protect="rw"/>
      <reg name="pad_keyout_2_set" protect="rw"/>
      <reg name="pad_keyout_1_set" protect="rw"/>
      <reg name="pad_keyout_0_set" protect="rw"/>
      <reg name="pad_keyin_3_set" protect="rw"/>
      <reg name="pad_keyin_2_set" protect="rw"/>
      <reg name="pad_keyin_1_set" protect="rw"/>
      <reg name="pad_keyin_0_set" protect="rw"/>
      <reg name="pad_lcd_rstb_set" protect="rw"/>
      <reg name="pad_lcd_fmark_set" protect="rw"/>
      <reg name="pad_spi_lcd_select_set" protect="rw"/>
      <reg name="pad_spi_lcd_cs_set" protect="rw"/>
      <reg name="pad_spi_lcd_clk_set" protect="rw"/>
      <reg name="pad_spi_lcd_sdc_set" protect="rw"/>
      <reg name="pad_spi_lcd_sio_set" protect="rw"/>
      <reg name="pad_sdmmc1_rst_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_7_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_6_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_5_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_4_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_3_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_2_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_1_set" protect="rw"/>
      <reg name="pad_sdmmc1_data_0_set" protect="rw"/>
      <reg name="pad_sdmmc1_cmd_set" protect="rw"/>
      <reg name="pad_sdmmc1_clk_set" protect="rw"/>
      <reg name="pad_uart_2_rts_set" protect="rw"/>
      <reg name="pad_uart_2_cts_set" protect="rw"/>
      <reg name="pad_uart_2_txd_set" protect="rw"/>
      <reg name="pad_uart_2_rxd_set" protect="rw"/>
      <reg name="pad_i2c_m1_sda_set" protect="rw"/>
      <reg name="pad_i2c_m1_scl_set" protect="rw"/>
      <reg name="pad_gpio_23_set" protect="rw"/>
      <reg name="pad_gpio_22_set" protect="rw"/>
      <reg name="pad_gpio_21_set" protect="rw"/>
      <reg name="pad_gpio_20_set" protect="rw"/>
      <reg name="pad_gpio_19_set" protect="rw"/>
      <reg name="pad_gpio_18_set" protect="rw"/>
      <reg name="pad_gpio_17_set" protect="rw"/>
      <reg name="pad_gpio_16_set" protect="rw"/>
      <reg name="pad_m_spi_d_3_set" protect="rw"/>
      <reg name="pad_m_spi_d_2_set" protect="rw"/>
      <reg name="pad_m_spi_d_1_set" protect="rw"/>
      <reg name="pad_m_spi_d_0_set" protect="rw"/>
      <reg name="pad_m_spi_cs_set" protect="rw"/>
      <reg name="pad_m_spi_clk_set" protect="rw"/>
      <hole size="21056"/>
      <reg name="pwr_pad_ctl_reserved_clr" protect="rw"/>
      <reg name="pin_ctrl_reg0_clr" protect="rw"/>
      <reg name="pin_ctrl_reg1_clr" protect="rw"/>
      <reg name="pin_ctrl_reg2_clr" protect="rw"/>
      <reg name="pin_ctrl_reg3_clr" protect="rw"/>
      <reg name="pin_ctrl_reg4_clr" protect="rw"/>
      <reg name="pin_ctrl_reg5_clr" protect="rw"/>
      <reg name="rfdig_gpio_7_clr" protect="rw"/>
      <reg name="rfdig_gpio_6_clr" protect="rw"/>
      <reg name="rfdig_gpio_5_clr" protect="rw"/>
      <reg name="rfdig_gpio_4_clr" protect="rw"/>
      <reg name="rfdig_gpio_3_clr" protect="rw"/>
      <reg name="rfdig_gpio_2_clr" protect="rw"/>
      <reg name="rfdig_gpio_1_clr" protect="rw"/>
      <reg name="rfdig_gpio_0_clr" protect="rw"/>
      <reg name="keyin_4_clr" protect="rw"/>
      <reg name="keyout_5_clr" protect="rw"/>
      <reg name="keyin_5_clr" protect="rw"/>
      <reg name="keyout_4_clr" protect="rw"/>
      <reg name="uart_1_rts_clr" protect="rw"/>
      <reg name="uart_1_txd_clr" protect="rw"/>
      <reg name="uart_1_rxd_clr" protect="rw"/>
      <reg name="uart_1_cts_clr" protect="rw"/>
      <reg name="gpio_0_clr" protect="rw"/>
      <reg name="gpio_3_clr" protect="rw"/>
      <reg name="gpio_2_clr" protect="rw"/>
      <reg name="gpio_1_clr" protect="rw"/>
      <reg name="gpio_7_clr" protect="rw"/>
      <reg name="gpio_6_clr" protect="rw"/>
      <reg name="gpio_5_clr" protect="rw"/>
      <reg name="gpio_4_clr" protect="rw"/>
      <reg name="adi_sda_clr" protect="rw"/>
      <reg name="adi_scl_clr" protect="rw"/>
      <reg name="resetb_clr" protect="rw"/>
      <reg name="osc_32k_clr" protect="rw"/>
      <reg name="pmic_ext_int_clr" protect="rw"/>
      <reg name="chip_pd_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="clk26m_pmic_clr" protect="rw"/>
      <reg name="sim_1_rst_clr" protect="rw"/>
      <reg name="sim_1_dio_clr" protect="rw"/>
      <reg name="sim_1_clk_clr" protect="rw"/>
      <reg name="sim_0_rst_clr" protect="rw"/>
      <reg name="sim_0_dio_clr" protect="rw"/>
      <reg name="sim_0_clk_clr" protect="rw"/>
      <reg name="sw_clk_clr" protect="rw"/>
      <reg name="sw_dio_clr" protect="rw"/>
      <reg name="debug_host_tx_clr" protect="rw"/>
      <reg name="debug_host_rx_clr" protect="rw"/>
      <reg name="debug_host_clk_clr" protect="rw"/>
      <reg name="camera_rst_l_clr" protect="rw"/>
      <reg name="spi_camera_sck_clr" protect="rw"/>
      <reg name="spi_camera_si_1_clr" protect="rw"/>
      <reg name="spi_camera_si_0_clr" protect="rw"/>
      <reg name="camera_ref_clk_clr" protect="rw"/>
      <reg name="camera_pwdn_clr" protect="rw"/>
      <reg name="i2s_sdat_i_clr" protect="rw"/>
      <reg name="i2s1_sdat_o_clr" protect="rw"/>
      <reg name="i2s1_lrck_clr" protect="rw"/>
      <reg name="i2s1_bck_clr" protect="rw"/>
      <reg name="i2s1_mclk_clr" protect="rw"/>
      <reg name="i2c_m2_scl_clr" protect="rw"/>
      <reg name="i2c_m2_sda_clr" protect="rw"/>
      <reg name="nand_sel_clr" protect="rw"/>
      <reg name="keyout_3_clr" protect="rw"/>
      <reg name="keyout_2_clr" protect="rw"/>
      <reg name="keyout_1_clr" protect="rw"/>
      <reg name="keyout_0_clr" protect="rw"/>
      <reg name="keyin_3_clr" protect="rw"/>
      <reg name="keyin_2_clr" protect="rw"/>
      <reg name="keyin_1_clr" protect="rw"/>
      <reg name="keyin_0_clr" protect="rw"/>
      <reg name="lcd_rstb_clr" protect="rw"/>
      <reg name="lcd_fmark_clr" protect="rw"/>
      <reg name="spi_lcd_select_clr" protect="rw"/>
      <reg name="spi_lcd_cs_clr" protect="rw"/>
      <reg name="spi_lcd_clk_clr" protect="rw"/>
      <reg name="spi_lcd_sdc_clr" protect="rw"/>
      <reg name="spi_lcd_sio_clr" protect="rw"/>
      <reg name="sdmmc1_rst_clr" protect="rw"/>
      <reg name="sdmmc1_data_7_clr" protect="rw"/>
      <reg name="sdmmc1_data_6_clr" protect="rw"/>
      <reg name="sdmmc1_data_5_clr" protect="rw"/>
      <reg name="sdmmc1_data_4_clr" protect="rw"/>
      <reg name="sdmmc1_data_3_clr" protect="rw"/>
      <reg name="sdmmc1_data_2_clr" protect="rw"/>
      <reg name="sdmmc1_data_1_clr" protect="rw"/>
      <reg name="sdmmc1_data_0_clr" protect="rw"/>
      <reg name="sdmmc1_cmd_clr" protect="rw"/>
      <reg name="sdmmc1_clk_clr" protect="rw"/>
      <reg name="uart_2_rts_clr" protect="rw"/>
      <reg name="uart_2_cts_clr" protect="rw"/>
      <reg name="uart_2_txd_clr" protect="rw"/>
      <reg name="uart_2_rxd_clr" protect="rw"/>
      <reg name="i2c_m1_sda_clr" protect="rw"/>
      <reg name="i2c_m1_scl_clr" protect="rw"/>
      <reg name="gpio_23_clr" protect="rw"/>
      <reg name="gpio_22_clr" protect="rw"/>
      <reg name="gpio_21_clr" protect="rw"/>
      <reg name="gpio_20_clr" protect="rw"/>
      <reg name="gpio_19_clr" protect="rw"/>
      <reg name="gpio_18_clr" protect="rw"/>
      <reg name="gpio_17_clr" protect="rw"/>
      <reg name="gpio_16_clr" protect="rw"/>
      <reg name="m_spi_d_3_clr" protect="rw"/>
      <reg name="m_spi_d_2_clr" protect="rw"/>
      <reg name="m_spi_d_1_clr" protect="rw"/>
      <reg name="m_spi_d_0_clr" protect="rw"/>
      <reg name="m_spi_cs_clr" protect="rw"/>
      <reg name="m_spi_clk_clr" protect="rw"/>
      <hole size="4896"/>
      <reg name="pad_rfdig_gpio_7_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_6_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_5_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_4_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_3_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_2_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_1_clr" protect="rw"/>
      <reg name="pad_rfdig_gpio_0_clr" protect="rw"/>
      <reg name="pad_keyin_4_clr" protect="rw"/>
      <reg name="pad_keyout_5_clr" protect="rw"/>
      <reg name="pad_keyin_5_clr" protect="rw"/>
      <reg name="pad_keyout_4_clr" protect="rw"/>
      <reg name="pad_uart_1_rts_clr" protect="rw"/>
      <reg name="pad_uart_1_txd_clr" protect="rw"/>
      <reg name="pad_uart_1_rxd_clr" protect="rw"/>
      <reg name="pad_uart_1_cts_clr" protect="rw"/>
      <reg name="pad_gpio_0_clr" protect="rw"/>
      <reg name="pad_gpio_3_clr" protect="rw"/>
      <reg name="pad_gpio_2_clr" protect="rw"/>
      <reg name="pad_gpio_1_clr" protect="rw"/>
      <reg name="pad_gpio_7_clr" protect="rw"/>
      <reg name="pad_gpio_6_clr" protect="rw"/>
      <reg name="pad_gpio_5_clr" protect="rw"/>
      <reg name="pad_gpio_4_clr" protect="rw"/>
      <reg name="pad_adi_sda_clr" protect="rw"/>
      <reg name="pad_adi_scl_clr" protect="rw"/>
      <reg name="pad_resetb_clr" protect="rw"/>
      <reg name="pad_osc_32k_clr" protect="rw"/>
      <reg name="pad_pmic_ext_int_clr" protect="rw"/>
      <reg name="pad_chip_pd_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="pad_clk26m_pmic_clr" protect="rw"/>
      <reg name="pad_sim_1_rst_clr" protect="rw"/>
      <reg name="pad_sim_1_dio_clr" protect="rw"/>
      <reg name="pad_sim_1_clk_clr" protect="rw"/>
      <reg name="pad_sim_0_rst_clr" protect="rw"/>
      <reg name="pad_sim_0_dio_clr" protect="rw"/>
      <reg name="pad_sim_0_clk_clr" protect="rw"/>
      <reg name="pad_sw_clk_clr" protect="rw"/>
      <reg name="pad_sw_dio_clr" protect="rw"/>
      <reg name="pad_debug_host_tx_clr" protect="rw"/>
      <reg name="pad_debug_host_rx_clr" protect="rw"/>
      <reg name="pad_debug_host_clk_clr" protect="rw"/>
      <reg name="pad_camera_rst_l_clr" protect="rw"/>
      <reg name="pad_spi_camera_sck_clr" protect="rw"/>
      <reg name="pad_spi_camera_si_1_clr" protect="rw"/>
      <reg name="pad_spi_camera_si_0_clr" protect="rw"/>
      <reg name="pad_camera_ref_clk_clr" protect="rw"/>
      <reg name="pad_camera_pwdn_clr" protect="rw"/>
      <reg name="pad_i2s_sdat_i_clr" protect="rw"/>
      <reg name="pad_i2s1_sdat_o_clr" protect="rw"/>
      <reg name="pad_i2s1_lrck_clr" protect="rw"/>
      <reg name="pad_i2s1_bck_clr" protect="rw"/>
      <reg name="pad_i2s1_mclk_clr" protect="rw"/>
      <reg name="pad_i2c_m2_scl_clr" protect="rw"/>
      <reg name="pad_i2c_m2_sda_clr" protect="rw"/>
      <reg name="pad_nand_sel_clr" protect="rw"/>
      <reg name="pad_keyout_3_clr" protect="rw"/>
      <reg name="pad_keyout_2_clr" protect="rw"/>
      <reg name="pad_keyout_1_clr" protect="rw"/>
      <reg name="pad_keyout_0_clr" protect="rw"/>
      <reg name="pad_keyin_3_clr" protect="rw"/>
      <reg name="pad_keyin_2_clr" protect="rw"/>
      <reg name="pad_keyin_1_clr" protect="rw"/>
      <reg name="pad_keyin_0_clr" protect="rw"/>
      <reg name="pad_lcd_rstb_clr" protect="rw"/>
      <reg name="pad_lcd_fmark_clr" protect="rw"/>
      <reg name="pad_spi_lcd_select_clr" protect="rw"/>
      <reg name="pad_spi_lcd_cs_clr" protect="rw"/>
      <reg name="pad_spi_lcd_clk_clr" protect="rw"/>
      <reg name="pad_spi_lcd_sdc_clr" protect="rw"/>
      <reg name="pad_spi_lcd_sio_clr" protect="rw"/>
      <reg name="pad_sdmmc1_rst_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_7_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_6_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_5_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_4_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_3_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_2_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_1_clr" protect="rw"/>
      <reg name="pad_sdmmc1_data_0_clr" protect="rw"/>
      <reg name="pad_sdmmc1_cmd_clr" protect="rw"/>
      <reg name="pad_sdmmc1_clk_clr" protect="rw"/>
      <reg name="pad_uart_2_rts_clr" protect="rw"/>
      <reg name="pad_uart_2_cts_clr" protect="rw"/>
      <reg name="pad_uart_2_txd_clr" protect="rw"/>
      <reg name="pad_uart_2_rxd_clr" protect="rw"/>
      <reg name="pad_i2c_m1_sda_clr" protect="rw"/>
      <reg name="pad_i2c_m1_scl_clr" protect="rw"/>
      <reg name="pad_gpio_23_clr" protect="rw"/>
      <reg name="pad_gpio_22_clr" protect="rw"/>
      <reg name="pad_gpio_21_clr" protect="rw"/>
      <reg name="pad_gpio_20_clr" protect="rw"/>
      <reg name="pad_gpio_19_clr" protect="rw"/>
      <reg name="pad_gpio_18_clr" protect="rw"/>
      <reg name="pad_gpio_17_clr" protect="rw"/>
      <reg name="pad_gpio_16_clr" protect="rw"/>
      <reg name="pad_m_spi_d_3_clr" protect="rw"/>
      <reg name="pad_m_spi_d_2_clr" protect="rw"/>
      <reg name="pad_m_spi_d_1_clr" protect="rw"/>
      <reg name="pad_m_spi_d_0_clr" protect="rw"/>
      <reg name="pad_m_spi_cs_clr" protect="rw"/>
      <reg name="pad_m_spi_clk_clr" protect="rw"/>
    </module>
    <var name="REG_IOMUX_SET_OFFSET" value="0x1000"/>
    <var name="REG_IOMUX_CLR_OFFSET" value="0x2000"/>
    <instance address="0x51510000" name="IOMUX" type="IOMUX"/>
  </archive>
  <archive relative="pwrctrl.xml">
    <module category="System" name="PWRCTRL">
      <reg name="pwrctrl_hwen" protect="rw">
        <comment>PWRCTRL_HWEN power domain shutdown/on controled by hardware signal or sofeware register.</comment>
        <bits access="rw" name="cp_pwr_hwen" pos="1" rst="0x0">
          <comment>CP power domain control by:
0:software register
1:hardware signal from IDLE_LPS module</comment>
        </bits>
        <bits access="rw" name="ap_pwr_hwen" pos="0" rst="0x1">
          <comment>AP power domain control by:
0:software register
1:hardware signal from IDLE_LPS module</comment>
        </bits>
      </reg>
      <reg name="ap_pwr_ctrl" protect="rw">
        <comment>AP_PWR_CTRL Register control AP power domani on/off.</comment>
        <bits access="rw" name="ap_pwr_ctrl" pos="0" rst="0x0">
          <comment>AP power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="cp_pwr_ctrl" protect="rw">
        <comment>CP_PWR_CTRL Register control CP power domani on/off.</comment>
        <bits access="rw" name="cp_pwr_ctrl" pos="0" rst="0x0">
          <comment>CP power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="pub_pwr_ctrl" protect="rw">
        <comment>PUB_PWR_CTRL Register control PUB power domani on/off. PUB power domain whil be shutdown when bit[2:0]=2'b11,otherwise power on.</comment>
        <bits access="rw" name="cp_pol" pos="1" rst="0x1">
          <comment>PUB power domain poll register bit for CP A5
0:poll to power on
1:poll to shutdown</comment>
        </bits>
        <bits access="rw" name="ap_pol" pos="0" rst="0x1">
          <comment>PUB power domain poll register bit for AP A5
0:poll to power on
1:poll to shutdown</comment>
        </bits>
      </reg>
      <reg name="rf_pwr_ctrl" protect="rw">
        <comment>RF_PWR_CTRL Register control RF power domani on/off.</comment>
        <bits access="rw" name="rf_pwr_ctrl" pos="0" rst="0x1">
          <comment>RF power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="usb_pwr_ctrl" protect="rw">
        <comment>USB_PWR_CTRL Register control USB power domani on/off.</comment>
        <bits access="rw" name="usb_pwr_ctrl" pos="0" rst="0x1">
          <comment>USB power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="lte_pwr_ctrl" protect="rw">
        <comment>LTE_PWR_CTRL Register control LTE power domani on/off.</comment>
        <bits access="rw" name="lte_pwr_ctrl" pos="0" rst="0x0">
          <comment>LTE power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="gnss_pwr_ctrl" protect="rw">
        <comment>GNSS_PWR_CTRL Register control GNSS power domani on/off.</comment>
        <bits access="rw" name="gnss_pwr_ctrl" pos="0" rst="0x0">
          <comment>GNSS power domain software register control bit
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="ap_pwr_stat" protect="rw">
        <comment>AP_PWR_STAT AP power domain state.</comment>
        <bits access="r" name="ap_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="ap_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="cp_pwr_stat" protect="rw">
        <comment>CP power domain state. CP power domain state.</comment>
        <bits access="r" name="cp_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="cp_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="pub_pwr_stat" protect="rw">
        <comment>PUB_PWR_STAT PUB power domain state.</comment>
        <bits access="r" name="pub_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="pub_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="rf_pwr_stat" protect="rw">
        <comment>RF_PWR_STAT RF power domain state.</comment>
        <bits access="r" name="rf_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="rf_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="usb_pwr_stat" protect="rw">
        <comment>USB_PWR_STAT USB power domain state.</comment>
        <bits access="r" name="usb_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="usb_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="lte_pwr_stat" protect="rw">
        <comment>LTE_PWR_STAT LTE power domain state.</comment>
        <bits access="r" name="lte_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="lte_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="gnss_pwr_stat" protect="rw">
        <comment>GNSS_PWR_STAT GNSS power domain state.</comment>
        <bits access="r" name="gnss_pwr_stable" pos="1" rst="0x0">
          <comment>If power state is stable
0:not stable
1:stable</comment>
        </bits>
        <bits access="r" name="gnss_pwr_state" pos="0" rst="0x0">
          <comment>Current power state of power domain
0:off
1:on</comment>
        </bits>
      </reg>
      <reg name="state_delay" protect="rw">
        <comment>STATE_DELAY Power domain control state machine delay value between two states.</comment>
        <bits access="rw" name="delay_value" pos="15:0" rst="0xff">
          <comment>Power domain control state machine delay value between two states, counts with 26MHz clock.</comment>
        </bits>
      </reg>
      <reg name="pd_m_delay" protect="rw">
        <comment>PD_M_DELAY Power switch mather chain delay value.</comment>
        <bits access="rw" name="delay_value" pos="15:0" rst="0xd0">
          <comment>Power switch mather chain delay value, counts with 26MHz clock.</comment>
        </bits>
      </reg>
      <reg name="pd_d_delay" protect="rw">
        <comment>PD_D_DELAY Power switch daughter chain delay value.</comment>
        <bits access="rw" name="delay_value" pos="15:0" rst="0x500">
          <comment>Power switch daughter chain delay value, counts with 26MHz clock.</comment>
        </bits>
      </reg>
      <reg name="psram_hold_ctrl" protect="rw">
        <comment>PSRAM_HOLD_CTRL Control latch the value of PSRAM IO from PSRAM controller.</comment>
        <bits access="rw" name="latch_en" pos="0" rst="0x0">
          <comment>0:not latch
1:latch</comment>
        </bits>
      </reg>
      <reg name="slp_bypass" protect="rw">
        <comment>SLP_BYPASS Control bypass the sleep handshake action when shutdown power domain.</comment>
        <bits access="rw" name="gnss_slp_bypass" pos="6" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="lte_slp_bypass" pos="5" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="usb_slp_bypass" pos="4" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="rf_slp_bypass" pos="3" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="pub_slp_bypass" pos="2" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="cp_slp_bypass" pos="1" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
        <bits access="rw" name="ap_slp_bypass" pos="0" rst="0x0">
          <comment>0:not bypass
1:bypass</comment>
        </bits>
      </reg>
      <reg name="slp_timeout_flag" protect="rw">
        <comment>SLP_TIMEOUT_FLAG Flag of power domain sleep handshake action timeout.Write &quot;1&quot; to clear relevant bit.</comment>
        <bits access="rw" name="gnss_slp_timeout" pos="6" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="lte_slp_timeout" pos="5" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="usb_slp_timeout" pos="4" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="rf_slp_timeout" pos="3" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="pub_slp_timeout" pos="2" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="cp_slp_timeout" pos="1" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
        <bits access="rw" name="ap_slp_timeout" pos="0" rst="0x0">
          <comment>0:timeout not occur
1:timeout occur</comment>
        </bits>
      </reg>
      <reg name="pwrctrl_int_en_ap" protect="rw">
        <comment>PWRCTRL_INT_EN_AP</comment>
        <bits access="rw" name="pwrctrl_int_en_gnss_sys" pos="6" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_lte_sys" pos="5" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_usb_sys" pos="4" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_rf_sys" pos="3" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_pub_sys" pos="2" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_cp_sys" pos="1" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_ap_sys" pos="0" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
      </reg>
      <reg name="pwrctrl_int_en_cp" protect="rw">
        <comment>PWRCTRL_INT_EN_CP</comment>
        <bits access="rw" name="pwrctrl_int_en_gnss_sys" pos="6" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_lte_sys" pos="5" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_usb_sys" pos="4" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_rf_sys" pos="3" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_pub_sys" pos="2" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_cp_sys" pos="1" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_ap_sys" pos="0" rst="0x0">
          <comment>0:disable irq signal output
1:enable irq signal output</comment>
        </bits>
      </reg>
      <reg name="pwrctrl_sm_state" protect="rw">
        <comment>PWRCTRL_SM_STATE The state value of the power domain state machine.</comment>
        <bits access="r" name="gnss_sm_state" pos="27:24" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="lte_sm_state" pos="23:20" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="usb_sm_state" pos="19:16" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="rf_sm_state" pos="15:12" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="pub_sm_state" pos="11:8" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="cp_sm_state" pos="7:4" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
        <bits access="r" name="ap_sm_state" pos="3:0" rst="0x0">
          <comment>4'h1:CLK_DISA
4'h2:ISO_HOLD
4'h3:RESET
4'h4:PREPON_REQ
4'h5:PWR_OFF
4'h6:PON_REQ
4'h7:ISO_RELEASE
4'h8:RST_RELEASE
4'h9:CLK_ENA
4'ha:PWR_ON
4'hb:PREPOFF_REQ
4'hc:POFF_REQ
4'hd:BUS_HANDSHAKE
others:error state</comment>
        </bits>
      </reg>
      <hole size="7424"/>
      <reg name="pwrctrl_hwen_set" protect="rw"/>
      <hole size="64"/>
      <reg name="pub_pwr_ctrl_set" protect="rw"/>
      <hole size="480"/>
      <reg name="slp_bypass_set" protect="rw"/>
      <reg name="slp_timeout_flag_set" protect="rw"/>
      <reg name="pwrctrl_int_en_ap_set" protect="rw"/>
      <reg name="pwrctrl_int_en_cp_set" protect="rw"/>
      <hole size="7456"/>
      <reg name="pwrctrl_hwen_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="pub_pwr_ctrl_clr" protect="rw"/>
      <hole size="480"/>
      <reg name="slp_bypass_clr" protect="rw"/>
      <reg name="slp_timeout_flag_clr" protect="rw"/>
      <reg name="pwrctrl_int_en_ap_clr" protect="rw"/>
      <reg name="pwrctrl_int_en_cp_clr" protect="rw"/>
    </module>
    <var name="REG_PWRCTRL_SET_OFFSET" value="0x400"/>
    <var name="REG_PWRCTRL_CLR_OFFSET" value="0x800"/>
    <instance address="0x51707000" name="PWRCTRL" type="PWRCTRL"/>
  </archive>
  <archive relative="idle_lps.xml">
    <module category="System" name="IDLE_LPS">
      <reg name="lps_ctrl_ap" protect="rw">
        <comment>LPS_CTRL_AP AP sleep enable register(Enable AP sleep when writing 0x49444c45 to this register, accessed by software only.)</comment>
        <bits access="rw" name="idct_ap" pos="0" rst="0x0">
          <comment>Enable AP sleep
0:disable
1:enable</comment>
        </bits>
      </reg>
      <reg name="ap_sig_en" protect="rw">
        <comment>AP_SIG_EN signal of low power related enable register</comment>
        <bits access="rw" name="ap_dis_val" pos="5" rst="0x1"/>
        <bits access="rw" name="ap_pow_on_en" pos="4" rst="0x1">
          <comment>ap_pow_on_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="ap_cg_en" pos="3" rst="0x1">
          <comment>ap_cg_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="ap_pd_pll_en" pos="2" rst="0x1">
          <comment>ap_pd_pll_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="ap_pd_xtal_en" pos="1" rst="0x1">
          <comment>ap_pd_xtal_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="ap_chip_pd_en" pos="0" rst="0x1">
          <comment>ap_chip_pd_en ctrl
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="ap_lps_sig_time" protect="rw">
        <comment>AP_LPS_SIG_TIME low power related time control register</comment>
        <bits access="rw" name="ap_t4" pos="31:24" rst="0x1">
          <comment>The time from enable clock to obtain clock</comment>
        </bits>
        <bits access="rw" name="ap_t3" pos="23:16" rst="0xa">
          <comment>The time of PLL from power saving state to output normal clock.</comment>
        </bits>
        <bits access="rw" name="ap_t2" pos="15:8" rst="0xa0">
          <comment>The time of OSC circuit from power saving
state to normal state.</comment>
        </bits>
        <bits access="rw" name="ap_t1" pos="7:0" rst="0x1">
          <comment>The time of PMIC boost stabilization.</comment>
        </bits>
      </reg>
      <reg name="lps_ctrl_cp" protect="rw">
        <comment>LPS_CTRL_CP CP sleep enable register(Enable CP sleep when writing 0x49444c45 to this register, accessed by software only.)</comment>
        <bits access="rw" name="idct_cp" pos="0" rst="0x0">
          <comment>Enable CP sleep
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="cp_pm2_sta" protect="rw">
        <comment>CP_PM2_STA mark pm2</comment>
        <bits access="rw" name="cp_pm2_sta" pos="0" rst="0x0">
          <comment>pm2 sta
1:PM2 valid
0:PM2 invalid</comment>
        </bits>
      </reg>
      <reg name="cp_sig_en" protect="rw">
        <comment>CP_SIG_EN signal of low power related enable register</comment>
        <bits access="rw" name="cp_dis_val" pos="5" rst="0x1"/>
        <bits access="rw" name="cp_pow_on_en" pos="4" rst="0x1">
          <comment>cp_pow_on_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="cp_cg_en" pos="3" rst="0x1">
          <comment>cp_cg_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="cp_pd_pll_en" pos="2" rst="0x1">
          <comment>cp_pd_pll_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="cp_pd_xtal_en" pos="1" rst="0x1">
          <comment>cp_pd_xtal_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="cp_chip_pd_en" pos="0" rst="0x1">
          <comment>cp_chip_pd_en ctrl
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="cp_lps_sig_time" protect="rw">
        <comment>CP_LPS_SIG_TIME low power related time control register</comment>
        <bits access="rw" name="cp_t4" pos="31:24" rst="0x1">
          <comment>The time from enable clock to obtain clock</comment>
        </bits>
        <bits access="rw" name="cp_t3" pos="23:16" rst="0xa">
          <comment>The time of PLL from power saving state to output normal clock.</comment>
        </bits>
        <bits access="rw" name="cp_t2" pos="15:8" rst="0xa0">
          <comment>The time of OSC circuit from power saving
state to normal state.</comment>
        </bits>
        <bits access="rw" name="cp_t1" pos="7:0" rst="0x1">
          <comment>The time of PMIC boost stabilization.</comment>
        </bits>
      </reg>
      <reg name="pm2_off_time" protect="rw">
        <comment>PM2_OFF_TIME low power related time control register</comment>
        <bits access="rw" name="n4" pos="31:24" rst="0x2">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="n3" pos="23:16" rst="0x2">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="n2" pos="15:8" rst="0x1">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="n1" pos="7:0" rst="0x1">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
      </reg>
      <reg name="pm2_on_time" protect="rw">
        <comment>AON_CLOCK_EN0 low power related time control register</comment>
        <bits access="rw" name="p4" pos="31:24" rst="0x2">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="p3" pos="23:16" rst="0x2">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="p2" pos="15:8" rst="0x1">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
      </reg>
      <reg name="pm2_on_off_time" protect="rw">
        <comment>PM2_ON_OFF_TIME low power related time control register</comment>
        <bits access="rw" name="p6" pos="31:24" rst="0x20">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="p5" pos="23:16" rst="0x4">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="n6" pos="15:8" rst="0x20">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
        <bits access="rw" name="n5" pos="7:0" rst="0x4">
          <comment>Power domain control state machine delay value between two states, counts with 32KHz clock.</comment>
        </bits>
      </reg>
      <reg name="ap_pm2_sta" protect="rw">
        <comment>AP_PM2_STA mark pm2</comment>
        <bits access="rw" name="ap_pm2_sta" pos="0" rst="0x0">
          <comment>pm2 sta
1:PM2 valid
0:PM2 invalid</comment>
        </bits>
      </reg>
      <reg name="ap_pm2_mode_en" protect="rw">
        <comment>AP_PM2_MODE_EN AP PM2 enable</comment>
        <bits access="rw" name="ap_pm2_mode_en" pos="0" rst="0x0">
          <comment>AP enable PM2 mode
0:enable PM2 mode
1:disable PM2 mode</comment>
        </bits>
      </reg>
      <reg name="aon_sig_en" protect="rw">
        <comment>AON_SIG_EN AON CTRL signal enable</comment>
        <bits access="rw" name="dis_val" pos="6" rst="0x1"/>
        <bits access="rw" name="pd_aon_shutdown_d_b_en" pos="5" rst="0x1">
          <comment>pd_aon_shutdown_d_b ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="pd_aon_shutdown_m_b_en" pos="4" rst="0x1">
          <comment>pd_aon_shutdown_m_b ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="pd_aon_mem" pos="3" rst="0x1">
          <comment>pd_aon_mem ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="rst_aon_n_en" pos="2" rst="0x1">
          <comment>rst_aon_en ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="pd_aon_iso" pos="1" rst="0x1">
          <comment>pd_aon_iso ctrl
1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="clk_en_aon_en" pos="0" rst="0x1">
          <comment>clk_en_aon ctrl
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="sleep_prot_time" protect="rw">
        <comment>SLEEP_PROT_TIME</comment>
        <bits access="rw" name="sleep_prot_time" pos="7:0" rst="0x9">
          <comment>The minimum threshold of deep sleep, to ensure PMIC have complete deep sleep in and deep sleep out.</comment>
        </bits>
      </reg>
      <reg name="eliminate_jitter" protect="rw">
        <comment>ELIMINATE_JITTER</comment>
        <bits access="rw" name="eliminate_time" pos="31:24" rst="0x1">
          <comment>Eliminate jitter delay register</comment>
        </bits>
        <bits access="rw" name="eliminate_en" pos="23:0" rst="0x0">
          <comment>Emilinate the jitter from awake signal when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="ap_lps_sta" protect="rw">
        <comment>AP_LPS_STA</comment>
        <bits access="rw" name="ap_perip_awk_stat" pos="3" rst="0x0">
          <comment>awake valid
0invalid
1valid</comment>
        </bits>
        <bits access="rw" name="ap_pow_ack_stat" pos="2" rst="0x0">
          <comment>AP_POW_ACK sta(ap exit sleep mode)
0POW_ACK value
1POW_ACK value</comment>
        </bits>
        <bits access="rw" name="ap_lps_end_stat" pos="1" rst="0x0">
          <comment>AP_LPS end sta
0:not sleep
1:sleep</comment>
        </bits>
        <bits access="r" name="ap_lps_stat" pos="0" rst="0x0">
          <comment>AP_SYS state
0: normal working
1: low power mode</comment>
        </bits>
      </reg>
      <reg name="cp_inten" protect="rw">
        <comment>CP_INTEN</comment>
        <bits access="rw" name="cp_t9_irq_en" pos="14" rst="0x0">
          <comment>t9_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t8_irq_en" pos="13" rst="0x0">
          <comment>t8_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t7_irq_en" pos="12" rst="0x0">
          <comment>t7_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_load_irq_en" pos="11" rst="0x0">
          <comment>load_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_sys_awk_irq_to_cp_en" pos="10" rst="0x0">
          <comment>ap_sys_awk_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_sys_awk_irq_to_cp_en" pos="9" rst="0x0">
          <comment>cp_sys_awk_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_tstamp_irq_en" pos="8" rst="0x0">
          <comment>tstamp_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t6_irq_en" pos="7" rst="0x0">
          <comment>t6_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t5_irq_en" pos="6" rst="0x0">
          <comment>t5_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t4_irq_en" pos="5" rst="0x0">
          <comment>t4 enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t3_irq_en" pos="4" rst="0x0">
          <comment>t3_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t2_irq_en" pos="3" rst="0x0">
          <comment>t2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_t1_irq_en" pos="2" rst="0x0">
          <comment>t1_irq_enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_p2_irq_en" pos="1" rst="0x0">
          <comment>p2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_p1_irq_en" pos="0" rst="0x0">
          <comment>p1_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cp_int_sta" protect="rw">
        <comment>CP_INT_STA</comment>
        <bits access="rw" name="cp_int_sta" pos="14:0" rst="0x0">
          <comment>clear cp interrupt state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="ap_inten" protect="rw">
        <comment>AP_INTEN ap interrupt enable register</comment>
        <bits access="rw" name="ap_t9_irq_en" pos="14" rst="0x0">
          <comment>t9_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t8_irq_en" pos="13" rst="0x0">
          <comment>t8_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t7_irq_en" pos="12" rst="0x0">
          <comment>t7_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_tstamp_irq_en" pos="11" rst="0x0">
          <comment>tstamp_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_load_irq_en" pos="10" rst="0x0">
          <comment>load_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_sys_awk_irq_to_ap_en" pos="9" rst="0x0">
          <comment>ap_sys_awk_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_sys_awk_irq_to_ap_en" pos="8" rst="0x0">
          <comment>cp_sys_awk_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t6_irq_en" pos="7" rst="0x0">
          <comment>t6_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t5_irq_en" pos="6" rst="0x0">
          <comment>t5_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t4_irq_en" pos="5" rst="0x0">
          <comment>t4 enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t3_irq_en" pos="4" rst="0x0">
          <comment>t3_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t2_irq_en" pos="3" rst="0x0">
          <comment>t2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_t1_irq_en" pos="2" rst="0x0">
          <comment>t1_irq_enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_p2_irq_en" pos="1" rst="0x0">
          <comment>p2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_p1_irq_en" pos="0" rst="0x0">
          <comment>p1_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="ap_int_sta" protect="rw">
        <comment>AP_INT_STA ap interrupt state</comment>
        <bits access="rw" name="ap_int_sta" pos="14:0" rst="0x0">
          <comment>clear ap interrupt state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="ap_awk_en" protect="rw">
        <comment>AP_AWK_EN AP wakeup enable register</comment>
        <bits access="rw" name="ap_p2_awk_en" pos="31" rst="0x0">
          <comment>P2_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_t6_awk_en" pos="30" rst="0x0">
          <comment>T6_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_t5_awk_en" pos="29" rst="0x0">
          <comment>T5_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_t4_awk_en" pos="28" rst="0x0">
          <comment>T4_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_t3_awk_en" pos="27" rst="0x0">
          <comment>T3_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_t2_awk_en" pos="26" rst="0x0">
          <comment>T2_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_t1_awk_en" pos="25" rst="0x0">
          <comment>T1_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_p1_awk_en" pos="24" rst="0x0">
          <comment>P1_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk23_en" pos="23" rst="0x0">
          <comment>AWK23_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk22_en" pos="22" rst="0x0">
          <comment>AWK22_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk21_en" pos="21" rst="0x0">
          <comment>AWK21_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk20_en" pos="20" rst="0x0">
          <comment>AWK20_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk19_en" pos="19" rst="0x0">
          <comment>AWK19_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk18_en" pos="18" rst="0x0">
          <comment>AWK18_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk17_en" pos="17" rst="0x0">
          <comment>AWK17_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk16_en" pos="16" rst="0x0">
          <comment>AWK16_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk15_en" pos="15" rst="0x0">
          <comment>AWK15_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk14_en" pos="14" rst="0x0">
          <comment>AWK14_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk13_en" pos="13" rst="0x0">
          <comment>AWK13_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk12_en" pos="12" rst="0x0">
          <comment>AWK12_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk11_en" pos="11" rst="0x0">
          <comment>AWK11_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk10_en" pos="10" rst="0x0">
          <comment>AWK10_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk9_en" pos="9" rst="0x0">
          <comment>AWK9_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk8_en" pos="8" rst="0x0">
          <comment>AWK8_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk7_en" pos="7" rst="0x0">
          <comment>AWK7_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk6_en" pos="6" rst="0x0">
          <comment>AWK6_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk5_en" pos="5" rst="0x0">
          <comment>AWK5_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk4_en" pos="4" rst="0x0">
          <comment>AWK4_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk3_en" pos="3" rst="0x0">
          <comment>AWK3_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk2_en" pos="2" rst="0x0">
          <comment>AWK2_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_awk1_en" pos="1" rst="0x0">
          <comment>AWK1_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_awk0_en" pos="0" rst="0x0">
          <comment>AWK0_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="ap_awk_st" protect="rw">
        <comment>AP_AWK_ST</comment>
      </reg>
      <reg name="cp_awk_en" protect="rw">
        <comment>CP_AWK_EN CP wakeup enable register</comment>
        <bits access="rw" name="cp_p2_awk_en" pos="31" rst="0x0">
          <comment>P2_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_t6_awk_en" pos="30" rst="0x0">
          <comment>T6_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_t5_awk_en" pos="29" rst="0x0">
          <comment>T5_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_t4_awk_en" pos="28" rst="0x0">
          <comment>T4_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_t3_awk_en" pos="27" rst="0x0">
          <comment>T3_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_t2_awk_en" pos="26" rst="0x0">
          <comment>T2_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_t1_awk_en" pos="25" rst="0x0">
          <comment>T1_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_p1_awk_en" pos="24" rst="0x0">
          <comment>P1_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk23_en" pos="23" rst="0x0">
          <comment>AWK23_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk22_en" pos="22" rst="0x0">
          <comment>AWK22_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk21_en" pos="21" rst="0x0">
          <comment>AWK21_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk20_en" pos="20" rst="0x0">
          <comment>AWK20_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk19_en" pos="19" rst="0x0">
          <comment>AWK19_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk18_en" pos="18" rst="0x0">
          <comment>AWK18_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk17_en" pos="17" rst="0x0">
          <comment>AWK17_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk16_en" pos="16" rst="0x0">
          <comment>AWK16_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk15_en" pos="15" rst="0x0">
          <comment>AWK15_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk14_en" pos="14" rst="0x0">
          <comment>AWK14_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk13_en" pos="13" rst="0x0">
          <comment>AWK13_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk12_en" pos="12" rst="0x0">
          <comment>AWK12_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk11_en" pos="11" rst="0x0">
          <comment>AWK11_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk10_en" pos="10" rst="0x0">
          <comment>AWK10_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk9_en" pos="9" rst="0x0">
          <comment>AWK9_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk8_en" pos="8" rst="0x0">
          <comment>AWK8_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk7_en" pos="7" rst="0x0">
          <comment>AWK7_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk6_en" pos="6" rst="0x0">
          <comment>AWK6_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk5_en" pos="5" rst="0x0">
          <comment>AWK5_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk4_en" pos="4" rst="0x0">
          <comment>AWK4_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk3_en" pos="3" rst="0x0">
          <comment>AWK3_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk2_en" pos="2" rst="0x0">
          <comment>AWK2_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_awk1_en" pos="1" rst="0x0">
          <comment>AWK1_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_awk0_en" pos="0" rst="0x0">
          <comment>AWK0_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cp_awk_st" protect="rw">
        <comment>CP_AWK_ST</comment>
      </reg>
      <reg name="cp_lps_sta" protect="rw">
        <comment>CP_LPS_STA</comment>
        <bits access="rw" name="cp_perip_awk_stat" pos="4" rst="0x0">
          <comment>CP AKW valid
0:disvalid
1:valid</comment>
        </bits>
        <bits access="rw" name="cp_pow_ack_stat" pos="3" rst="0x0">
          <comment>CP_POW_ACK sta(sleep end)
0LOW
1HIGH</comment>
        </bits>
        <bits access="rw" name="cp_lps_end_stat" pos="2" rst="0x0">
          <comment>CP_LPS end sta
0:don't sleep
1:IDLE  end</comment>
        </bits>
        <bits access="rw" name="cp_awk_up_stat" pos="1" rst="0x0">
          <comment>paging awkjust P1 awk
0:no paging awk
1:paging  awk</comment>
        </bits>
        <bits access="rw" name="cp_lps_stat" pos="0" rst="0x0">
          <comment>SYS state
0:  normal working
1:  low power mode</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cp_p1_time" protect="rw">
        <comment>CP_P1_TIME</comment>
      </reg>
      <reg name="cp_p2_time" protect="rw">
        <comment>CP_P2_TIME</comment>
      </reg>
      <reg name="lps_t_time1" protect="rw">
        <comment>LPS_T_TIME1</comment>
      </reg>
      <reg name="lps_t_time2" protect="rw">
        <comment>LPS_T_TIME2</comment>
      </reg>
      <reg name="lps_t_time3" protect="rw">
        <comment>LPS_T_TIME3</comment>
      </reg>
      <reg name="lps_t_time4" protect="rw">
        <comment>LPS_T_TIME4</comment>
      </reg>
      <reg name="lps_t_time5" protect="rw">
        <comment>LPS_T_TIME5</comment>
      </reg>
      <reg name="lps_t_time6" protect="rw">
        <comment>LPS_T_TIME6</comment>
      </reg>
      <reg name="load_en" protect="rw">
        <comment>LOAD_EN</comment>
        <bits access="rw" name="load_en" pos="0" rst="0x0">
          <comment>load_time enable
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_32k_ref" protect="rw">
        <comment>LPS_32K_REF 32K reference counter</comment>
      </reg>
      <reg name="ref_32k_fnl" protect="rw">
        <comment>REF_32K_FNL REF_32K CONT clocked register</comment>
      </reg>
      <reg name="lps_tpctrl" protect="rw">
        <comment>LPS_TPCTRL time stamp register</comment>
        <bits access="rw" name="tstamp_confg" pos="1" rst="0x0">
          <comment>0: bit 0 control the time stamp, bit 0 auto clear to be 0 after time stamp finsihed.
1:time stamp loop</comment>
        </bits>
        <bits access="rw" name="tstamp_en" pos="0" rst="0x0">
          <comment>1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="lps_tp_sta" protect="rw">
        <comment>LPS_TP_STA</comment>
        <bits access="rw" name="tp_sta0" pos="0" rst="0x0">
          <comment>1:tstamp saved
0:nothing</comment>
        </bits>
      </reg>
      <reg name="load_time" protect="rw">
        <comment>LOAD_TIME</comment>
      </reg>
      <reg name="mon_sel" protect="rw">
        <comment>MON_SEL</comment>
        <bits access="rw" name="mon15_sel" pos="31:30" rst="0x0">
          <comment>mon15_sel:
00: select t5_awk
01: select awake[5]
10: select awake[12]
11: select awake[21]</comment>
        </bits>
        <bits access="rw" name="mon14_sel" pos="29:28" rst="0x0">
          <comment>mon14_sel:
00: select t4_awk
01: select awake[4]
10: select awake[11]
11: select awake[20]</comment>
        </bits>
        <bits access="rw" name="mon13_sel" pos="27:26" rst="0x0">
          <comment>mon13_sel:
00: select t3_awk
01: select awake[3]
10: select awake[10]
11: select awake[19]</comment>
        </bits>
        <bits access="rw" name="mon12_sel" pos="25:24" rst="0x0">
          <comment>mon12_sel:
00: select t2_awk
01: select awake[2]
10: select awake[9]
11: select awake[18]</comment>
        </bits>
        <bits access="rw" name="mon11_sel" pos="23:22" rst="0x0">
          <comment>mon11_sel:
00: select t1_awk
01: select awake[1]
10: select awake[8]
11: select awake[17]</comment>
        </bits>
        <bits access="rw" name="mon10_sel" pos="21:20" rst="0x0">
          <comment>mon10_sel:
00: select p2_int
01: select awake[0]
10: select awake[7]
11: select awake[16]</comment>
        </bits>
        <bits access="rw" name="mon9_sel" pos="19:18" rst="0x0">
          <comment>mon9_sel:
00: select p1_awk
01: select chip_pd
10: select awake[6]
11: select awake[15]</comment>
        </bits>
        <bits access="rw" name="mon8_sel" pos="17:16" rst="0x0">
          <comment>mon8_sel:
00: select awake[22]
01: select awake[23]
10: select t6_awk
11: select awake[14]</comment>
        </bits>
        <bits access="rw" name="mon7_sel" pos="15:14" rst="0x0">
          <comment>mon7_sel:
00: select ap_chip_pd
01: select cp_ship_pd
10: select pd_aon_shutdown_d_b.
11: select awake[13]</comment>
        </bits>
        <bits access="rw" name="mon6_sel" pos="13:12" rst="0x0">
          <comment>mon6_sel:
00: select ap_pd_xtal
01: select cp_pd_xtal
10: select pd_aon_shutdown_m_b.
11: select t6_int.</comment>
        </bits>
        <bits access="rw" name="mon5_sel" pos="11:10" rst="0x0">
          <comment>mon5_sel:
00: select ap_pd_pll
01: select cp_pd_pll
10: select pd_aon_mem.
11: select t5_int.</comment>
        </bits>
        <bits access="rw" name="mon4_sel" pos="9:8" rst="0x0">
          <comment>mon4_sel:
00: select ap_lps_cg
01: select cp_lps_cg
10: select rst_aon_n.
11: select t4_int.</comment>
        </bits>
        <bits access="rw" name="mon3_sel" pos="7:6" rst="0x0">
          <comment>mon3_sel:
00: select ap_pow_on_ack
01: select cp_pow_on_ack
10: select pd_aon_iso.
11: select t3_int.</comment>
        </bits>
        <bits access="rw" name="mon2_sel" pos="5:4" rst="0x0">
          <comment>mon2_sel:
00: select ap_pow_on
01: select cp_pow_on
10: select clk_en_aon.
11: select t2_int.</comment>
        </bits>
        <bits access="rw" name="mon1_sel" pos="3:2" rst="0x0">
          <comment>mon1_sel:
00: select idst_ap
01: select idst_cp.
10: select idst_aon
11: select t1_int</comment>
        </bits>
        <bits access="rw" name="mon0_sel" pos="1:0" rst="0x0">
          <comment>mon0_sel:
00: select idct_ap.
01: select idct_cp.
10: select pm2_mode_en.
11: select p1_int</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="lps_res0" protect="rw">
        <comment>LPS_RES0</comment>
      </reg>
      <reg name="lps_res1" protect="rw">
        <comment>LPS_RES1</comment>
      </reg>
      <reg name="lps_res2" protect="rw">
        <comment>LPS_RES2</comment>
      </reg>
      <reg name="lps_res3" protect="rw">
        <comment>LPS_RES3</comment>
      </reg>
      <reg name="lps_res4" protect="rw">
        <comment>LPS_RES4</comment>
      </reg>
      <reg name="lps_res5" protect="rw">
        <comment>LPS_RES5</comment>
      </reg>
      <reg name="lps_res6" protect="rw">
        <comment>LPS_RES6</comment>
      </reg>
      <reg name="lps_res7" protect="rw">
        <comment>LPS_RES7</comment>
      </reg>
      <reg name="lps_res8" protect="rw">
        <comment>LPS_RES8</comment>
      </reg>
      <reg name="lps_res9" protect="rw">
        <comment>LPS_RES9</comment>
      </reg>
      <reg name="lps_res10" protect="rw">
        <comment>LPS_RES10</comment>
      </reg>
      <reg name="lps_res11" protect="rw">
        <comment>LPS_RES11</comment>
      </reg>
      <reg name="cp_p1_en" protect="rw">
        <comment>CP_P1_EN</comment>
        <bits access="rw" name="lps_p1_en" pos="0" rst="0x0">
          <comment>paging timer en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="cp_p2_en" protect="rw">
        <comment>CP_P2_TEN</comment>
        <bits access="rw" name="lps_p2_en" pos="0" rst="0x0">
          <comment>awake timer en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t1_en" protect="rw">
        <comment>LPS_T1_EN</comment>
        <bits access="rw" name="lps_t1_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t2_en" protect="rw">
        <comment>LPS_T2_EN</comment>
        <bits access="rw" name="lps_t2_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t3_en" protect="rw">
        <comment>LPS_T3_EN</comment>
        <bits access="rw" name="lps_t3_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t4_en" protect="rw">
        <comment>LPS_T4_EN</comment>
        <bits access="rw" name="lps_t4_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t5_en" protect="rw">
        <comment>LPS_T5_EN</comment>
        <bits access="rw" name="lps_t5_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t6_en" protect="rw">
        <comment>LPS_T6_EN</comment>
        <bits access="rw" name="lps_t6_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="ap_awk_en1" protect="rw">
        <comment>AP_AWK_EN1</comment>
        <bits access="rw" name="ap_t9_awk_en" pos="2" rst="0x0">
          <comment>T9_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_t8_awk_en" pos="1" rst="0x0">
          <comment>T8_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="ap_t7_awk_en" pos="0" rst="0x0">
          <comment>T7_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="ap_awk_st1" protect="rw">
        <comment>AP_AWK_ST1</comment>
        <bits access="rw" name="ap_awk_sta1" pos="2:0" rst="0x0">
          <comment>clear ap wake state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="cp_awk_en1" protect="rw">
        <comment>CP_AWK_EN1</comment>
        <bits access="rw" name="cp_t9_awk_en" pos="2" rst="0x0">
          <comment>T9_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_t8_awk_en" pos="1" rst="0x0">
          <comment>T8_AWK_EN wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="cp_t7_awk_en" pos="0" rst="0x0">
          <comment>T7_AWK_EN wakeup enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="cp_awk_st1" protect="rw">
        <comment>CP_AWK_ST1</comment>
        <bits access="rw" name="cp_awk_sta1" pos="2:0" rst="0x0">
          <comment>clear ap wake state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="lps_t_time7" protect="rw">
        <comment>LPS_T_TIME7</comment>
      </reg>
      <reg name="lps_t_time8" protect="rw">
        <comment>LPS_T_TIME8</comment>
      </reg>
      <reg name="lps_t_time9" protect="rw">
        <comment>LPS_T_TIME9</comment>
      </reg>
      <reg name="lps_t7_en" protect="rw">
        <comment>LPS_T7_EN</comment>
        <bits access="rw" name="lps_t7_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t8_en" protect="rw">
        <comment>LPS_T8_EN</comment>
        <bits access="rw" name="lps_t8_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="lps_t9_en" protect="rw">
        <comment>LPS_T9_EN</comment>
        <bits access="rw" name="lps_t9_en" pos="0" rst="0x0">
          <comment>target_time en
1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="cp_pm2_mode_en" protect="rw">
        <comment>CP_PM2_MODE_EN CP PM2 enable</comment>
        <bits access="rw" name="cp_pm2_mode_en" pos="0" rst="0x0">
          <comment>CP enable PM2 mode
0:enable PM2 mode
1:disable PM2 mode</comment>
        </bits>
      </reg>
      <hole size="576"/>
      <reg name="cp_inten_set" protect="rw"/>
      <hole size="96"/>
      <reg name="ap_inten_set" protect="rw"/>
      <hole size="96"/>
      <reg name="ap_awk_en_set" protect="rw"/>
      <hole size="96"/>
      <reg name="cp_awk_en_set" protect="rw"/>
      <hole size="608"/>
      <reg name="mon_sel_set" protect="rw"/>
      <hole size="352"/>
      <reg name="cp_inten_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="ap_inten_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="ap_awk_en_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="ap_awk_en1_set" protect="rw"/>
      <reg name="cp_awk_en_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="cp_awk_en1_set" protect="rw"/>
      <hole size="512"/>
      <reg name="mon_sel_clr" protect="rw"/>
      <hole size="704"/>
      <reg name="ap_awk_en1_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="cp_awk_en1_clr" protect="rw"/>
    </module>
    <var name="REG_IDLE_LPS_SET_OFFSET" value="0x160"/>
    <var name="REG_IDLE_LPS_CLR_OFFSET" value="0x210"/>
    <instance address="0x51702000" name="IDLE_LPS" type="IDLE_LPS"/>
  </archive>
  <archive relative="lps_clk.xml">
    <module category="System" name="LPS_CLK">
      <reg name="user_gate_force_off" protect="rw">
        <comment>user_gate_force_off</comment>
        <bits access="rw" name="lps_ahb_ana_wrap3_force_off" pos="17" rst="0x0">
          <comment>lps_ahb_ana_wrap3_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_idle_lps_force_off" pos="16" rst="0x0">
          <comment>lps_ahb_idle_lps_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_pwrctrl_func_force_off" pos="15" rst="0x0">
          <comment>lps_ahb_pwrctrl_func_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_pwrctrl_intf_force_off" pos="14" rst="0x0">
          <comment>lps_ahb_pwrctrl_intf_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_osc_force_off" pos="13" rst="0x0">
          <comment>lps_ahb_keypad_osc_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_always_force_off" pos="12" rst="0x0">
          <comment>lps_ahb_keypad_always_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_force_off" pos="11" rst="0x0">
          <comment>lps_ahb_keypad_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_apb_reg_force_off" pos="10" rst="0x0">
          <comment>lps_ahb_apb_reg_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpt1_force_off" pos="9" rst="0x0">
          <comment>lps_ahb_gpt1_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpio_mod_force_off" pos="8" rst="0x0">
          <comment>lps_ahb_gpio_mod_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpio1_force_off" pos="7" rst="0x0">
          <comment>lps_ahb_gpio1_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_force_off" pos="6" rst="0x0">
          <comment>lps_ahb_uart1_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_always_force_off" pos="5" rst="0x0">
          <comment>lps_ahb_uart1_always_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_mod_force_off" pos="4" rst="0x0">
          <comment>lps_ahb_uart1_mod_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_ahb_to_aon_force_off" pos="3" rst="0x0">
          <comment>lps_ahb_to_aon_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="lps_32k_fr_force_off" pos="2" rst="0x0">
          <comment>lps_32k_fr_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="uart1_bf_div_uart1_always_force_off" pos="1" rst="0x0">
          <comment>uart1_bf_div_uart1_always_force_off force clk on, default : 1'b0</comment>
        </bits>
        <bits access="rw" name="uart1_bf_div_uart1_force_off" pos="0" rst="0x0">
          <comment>uart1_bf_div_uart1_force_off force clk on, default : 1'b0</comment>
        </bits>
      </reg>
      <reg name="user_gate_auto_gate_en" protect="rw">
        <comment>user_gate_auto_gate_en</comment>
        <bits access="rw" name="lps_ahb_ana_wrap3_auto_gate_en" pos="17" rst="0x1">
          <comment>lps_ahb_ana_wrap3_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_idle_lps_auto_gate_en" pos="16" rst="0x1">
          <comment>lps_ahb_idle_lps_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_pwrctrl_func_auto_gate_en" pos="15" rst="0x1">
          <comment>lps_ahb_pwrctrl_func_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_pwrctrl_intf_auto_gate_en" pos="14" rst="0x1">
          <comment>lps_ahb_pwrctrl_intf_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_osc_auto_gate_en" pos="13" rst="0x1">
          <comment>lps_ahb_keypad_osc_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_always_auto_gate_en" pos="12" rst="0x1">
          <comment>lps_ahb_keypad_always_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_keypad_auto_gate_en" pos="11" rst="0x1">
          <comment>lps_ahb_keypad_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_apb_reg_auto_gate_en" pos="10" rst="0x1">
          <comment>lps_ahb_apb_reg_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpt1_auto_gate_en" pos="9" rst="0x1">
          <comment>lps_ahb_gpt1_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpio_mod_auto_gate_en" pos="8" rst="0x1">
          <comment>lps_ahb_gpio_mod_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_gpio1_auto_gate_en" pos="7" rst="0x1">
          <comment>lps_ahb_gpio1_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_auto_gate_en" pos="6" rst="0x1">
          <comment>lps_ahb_uart1_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_always_auto_gate_en" pos="5" rst="0x1">
          <comment>lps_ahb_uart1_always_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_uart1_mod_auto_gate_en" pos="4" rst="0x1">
          <comment>lps_ahb_uart1_mod_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_ahb_to_aon_auto_gate_en" pos="3" rst="0x1">
          <comment>lps_ahb_to_aon_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="lps_32k_fr_auto_gate_en" pos="2" rst="0x1">
          <comment>lps_32k_fr_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="uart1_bf_div_uart1_always_auto_gate_en" pos="1" rst="0x1">
          <comment>uart1_bf_div_uart1_always_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
        <bits access="rw" name="uart1_bf_div_uart1_auto_gate_en" pos="0" rst="0x1">
          <comment>uart1_bf_div_uart1_auto_gate_en auto gate en, default : 1'b1</comment>
        </bits>
      </reg>
      <hole size="256"/>
      <reg name="cgm_uart1_bf_div_sel_cfg" protect="rw">
        <comment>cgm_uart1_bf_div_sel_cfg</comment>
        <bits access="rw" name="cgm_uart1_bf_div_sel" pos="1:0" rst="0x1">
          <comment>cgm_uart1_bf_div_sel: clk_uart1_bf_div source , 0: rtc_32k, 1: xtal_lp_26m, 2: xtal_26m, 3: rc26m_26m, default: 2'h1</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="cgm_lps_ahb_sel_cfg" protect="rw">
        <comment>cgm_lps_ahb_sel_cfg</comment>
        <bits access="rw" name="cgm_lps_ahb_sel" pos="1:0" rst="0x1">
          <comment>cgm_lps_ahb_sel: clk_lps_ahb source , 0: rtc_32k, 1: xtal_lp_26m, 2: xtal_26m, 3: rc26m_26m, default: 2'h1</comment>
        </bits>
      </reg>
      <reg name="cgm_busy_src_monitor_cfg0" protect="rw">
        <comment>cgm_busy_src_monitor_cfg0</comment>
        <bits access="r" name="cgm_busy_src_monitor0" pos="8:0">
          <comment>cgm_busy_src_monitor0, 0:(cgm_uart1_bf_div_sel_ac == 2) &amp; cgm_busy_uart1_bf_div 1:cgm_busy_lps_ahb_sel_2 &amp; cgm_busy_lps_ahb 2:(cgm_uart1_bf_div_sel_ac == 1) &amp; cgm_busy_uart1_bf_div 3:cgm_busy_lps_ahb_sel_1 &amp; cgm_busy_lps_ahb 4:(cgm_uart1_bf_div_sel_ac == 3) &amp; cgm_busy_uart1_bf_div 5:cgm_busy_lps_ahb_sel_3 &amp; cgm_busy_lps_ahb 6:(cgm_uart1_bf_div_sel_ac == 0) &amp; cgm_busy_uart1_bf_div 7:cgm_busy_lps_32k 8:cgm_busy_lps_ahb_sel_0 &amp; cgm_busy_lps_ahb</comment>
        </bits>
      </reg>
      <hole size="1472"/>
      <reg name="user_gate_force_off_set" protect="rw"/>
      <reg name="user_gate_auto_gate_en_set" protect="rw"/>
      <hole size="1984"/>
      <reg name="user_gate_force_off_clr" protect="rw"/>
      <reg name="user_gate_auto_gate_en_clr" protect="rw"/>
    </module>
    <var name="REG_LPS_CLK_SET_OFFSET" value="0x100"/>
    <var name="REG_LPS_CLK_CLR_OFFSET" value="0x200"/>
    <instance address="0x51701000" name="LPS_CLK" type="LPS_CLK"/>
  </archive>
  <archive relative="lps_clk_gen.xml">
    <module category="System" name="LPS_CLK_GEN">
      <hole size="256"/>
      <reg name="soft_cnt_done0_cfg" protect="rw">
        <comment>soft_cnt_done0_cfg</comment>
        <bits access="rw" name="rc26m_26m_soft_cnt_done" pos="0" rst="0x1">
          <comment>rc26m_26m_soft_cnt_done counter wait for source stable</comment>
        </bits>
      </reg>
      <reg name="pll_wait_sel0_cfg" protect="rw">
        <comment>pll_wait_sel0_cfg</comment>
        <bits access="rw" name="rc26m_26m_wait_auto_gate_sel" pos="0" rst="0x1">
          <comment>rc26m_26m_wait_auto_gate_sel pll wait's enable select. 0: sort register control  1: hw auto control</comment>
        </bits>
      </reg>
      <reg name="pll_wait_sw_ctl0_cfg" protect="rw">
        <comment>pll_wait_sw_ctl0_cfg</comment>
        <bits access="rw" name="rc26m_26m_wait_force_en" pos="0" rst="0x1">
          <comment>rc26m_26m_wait_force_en pll wait's enable sw control</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="gate_en_sel0_cfg" protect="rw">
        <comment>gate_en_sel0_cfg</comment>
        <bits access="rw" name="cgm_rtc_32k_ap_auto_gate_sel" pos="6" rst="0x1">
          <comment>cgm_rtc_32k_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_ap_auto_gate_sel" pos="5" rst="0x1">
          <comment>cgm_rc_26m_ap_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_cp_auto_gate_sel" pos="4" rst="0x1">
          <comment>cgm_rtc_32k_cp_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_aon_auto_gate_sel" pos="3" rst="0x1">
          <comment>cgm_rtc_32k_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_aon_auto_gate_sel" pos="2" rst="0x1">
          <comment>cgm_rc_26m_aon_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_lps_auto_gate_sel" pos="1" rst="0x1">
          <comment>cgm_rtc_32k_lps_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_lps_auto_gate_sel" pos="0" rst="0x1">
          <comment>cgm_rc_26m_lps_auto_gate_sel clock gating enable select. 0: soft register control  1: hw(pmu) auto control</comment>
        </bits>
      </reg>
      <reg name="gate_en_sw_ctl0_cfg" protect="rw">
        <comment>gate_en_sw_ctl0_cfg</comment>
        <bits access="rw" name="cgm_rtc_32k_ap_force_en" pos="6" rst="0x1">
          <comment>cgm_rtc_32k_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_ap_force_en" pos="5" rst="0x1">
          <comment>cgm_rc_26m_ap_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_cp_force_en" pos="4" rst="0x1">
          <comment>cgm_rtc_32k_cp_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_aon_force_en" pos="3" rst="0x1">
          <comment>cgm_rtc_32k_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_aon_force_en" pos="2" rst="0x1">
          <comment>cgm_rc_26m_aon_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rtc_32k_lps_force_en" pos="1" rst="0x1">
          <comment>cgm_rtc_32k_lps_force_en clock gating enable sw control</comment>
        </bits>
        <bits access="rw" name="cgm_rc_26m_lps_force_en" pos="0" rst="0x1">
          <comment>cgm_rc_26m_lps_force_en clock gating enable sw control</comment>
        </bits>
      </reg>
      <reg name="monitor_wait_en_status0_cfg" protect="rw">
        <comment>monitor_wait_en_status0_cfg</comment>
        <bits access="r" name="monitor_wait_en_status" pos="0" rst="0x0">
          <comment>monitor_wait_en_status , 0:rc26m_26m</comment>
        </bits>
      </reg>
      <reg name="monitor_gate_auto_en_status0_cfg" protect="rw">
        <comment>monitor_gate_auto_en_status0_cfg</comment>
        <bits access="r" name="monitor_gate_auto_en_status" pos="6:0" rst="0x0">
          <comment>monitor_gate_auto_en_status , 0:cgm_rtc_32k_ap, 1:cgm_rc_26m_ap, 2:cgm_rtc_32k_cp, 3:cgm_rtc_32k_aon, 4:cgm_rc_26m_aon, 5:cgm_rtc_32k_lps, 6:cgm_rc_26m_lps</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51708000" name="LPS_CLK_GEN" type="LPS_CLK_GEN"/>
  </archive>
  <archive relative="pub_apb.xml">
    <module category="System" name="PUB_APB">
      <reg name="apb_eb" protect="rw">
        <comment>module enable module enable</comment>
        <bits access="rw" name="reserved_eb" pos="2" rst="0x0">
          <comment>Reserved Enable. Active High;
0 : Disable ;
1 : Enable ;</comment>
        </bits>
        <bits access="rw" name="mtx_cfg_eb" pos="1" rst="0x0">
          <comment>mtx_cfg Enable. Active High;
0 : Disable ;
1 : Enable ;</comment>
        </bits>
        <bits access="rw" name="pagespy_eb" pos="0" rst="0x0">
          <comment>pagespy Enable. Active High;
0 : Disable ;
1 : Enable ;</comment>
        </bits>
      </reg>
      <reg name="apb_soft_rst" protect="rw">
        <comment>Soft Reset  Soft Reset</comment>
        <bits access="rw" name="reserved_soft_rst" pos="3" rst="0x0">
          <comment>Reserved Soft Reset. Active High;
0 : Keep module in normal mode;
1 : Reset module;</comment>
        </bits>
        <bits access="rw" name="mtx_cfg_rst" pos="2" rst="0x0">
          <comment>mtx_cfg Soft Reset. Active High;
0 : Keep module in normal mode;
1 : Reset module;</comment>
        </bits>
        <bits access="rw" name="dmc400_soft_rst" pos="1" rst="0x0">
          <comment>dmc400 Soft Reset. Active High;
0 : Keep module in normal mode;
1 : Reset module;</comment>
        </bits>
        <bits access="rw" name="pagespy_soft_rst" pos="0" rst="0x0">
          <comment>pagespy Soft Reset. Active High;
0 : Keep module in normal mode;
1 : Reset module;</comment>
        </bits>
      </reg>
      <reg name="debug_ctrl" protect="rw">
        <comment>debug_ctrl debug_ctrl</comment>
      </reg>
      <reg name="slp_ctrl" protect="rw">
        <comment>psram sleep ctrl psram sleep ctrl</comment>
        <bits access="rw" name="half_slp_reg" pos="19" rst="0x0">
          <comment>half_slp_reg</comment>
        </bits>
        <bits access="rw" name="enable" pos="18" rst="0x0">
          <comment>enable</comment>
        </bits>
        <bits access="rw" name="force_reg" pos="17" rst="0x0">
          <comment>force_reg</comment>
        </bits>
        <bits access="rw" name="force_en" pos="16" rst="0x0">
          <comment>force_en</comment>
        </bits>
        <bits access="rw" name="wait_num" pos="15:0" rst="0x0">
          <comment>wait_num</comment>
        </bits>
      </reg>
      <reg name="lps_gate_sel" protect="rw">
        <comment>psram gate_sel psram gate_sel</comment>
        <bits access="rw" name="cgm_gate_auto_sel" pos="9:0" rst="0x3ff">
          <comment>gate_auto_sel</comment>
        </bits>
      </reg>
      <reg name="lps_gate_force" protect="rw">
        <comment>psram gate_force psram gate_force</comment>
        <bits access="rw" name="cgm_gate_force_en" pos="9:0" rst="0x3ff">
          <comment>gate_force_en</comment>
        </bits>
      </reg>
      <reg name="cgm_psram" protect="rw">
        <comment>cgm_psram cgm_psram</comment>
        <bits access="rw" name="sel_2x" pos="7:5" rst="0x0">
          <comment>cgm_psram_2x_sel</comment>
        </bits>
        <bits access="rw" name="div_2x" pos="4:3" rst="0x0">
          <comment>cgm_psram_2x_div</comment>
        </bits>
        <bits access="rw" name="div_1x" pos="1" rst="0x0">
          <comment>cgm_psram_1x_div</comment>
        </bits>
      </reg>
      <reg name="lpc_ctrl0" protect="rw">
        <comment>lpc_ctrl0 lpc_ctrl0</comment>
        <bits access="rw" name="pu_num" pos="23:16" rst="0x0">
          <comment>pu_num</comment>
        </bits>
        <bits access="rw" name="lp_num" pos="15:0" rst="0x80">
          <comment>lp_num</comment>
        </bits>
      </reg>
      <reg name="lpc_ctrl1" protect="rw">
        <comment>lpc_ctrl1 lpc_ctrl1</comment>
        <bits access="rw" name="lp_force" pos="1" rst="0x0">
          <comment>lp_force</comment>
        </bits>
        <bits access="rw" name="lp_eb" pos="0" rst="0x0">
          <comment>lp_eb</comment>
        </bits>
      </reg>
      <reg name="pub_anti_hang" protect="rw">
        <comment>pub_anti_hang pub_anti_hang</comment>
        <bits access="rw" name="error_resp_en" pos="4" rst="0x0">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="reserved2_en" pos="2" rst="0x1">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="reserved1_en" pos="1" rst="0x1">
          <comment>1: enable error response
0: always response OK</comment>
        </bits>
        <bits access="rw" name="pagespy_id_sel" pos="0" rst="0x1">
          <comment>1: select fw ID
0: select matrix id</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="monitor_clk" protect="rw">
        <comment>monitor_clock_status monitor_clock_status</comment>
        <bits access="r" name="cgm_busy_status" pos="21:12" rst="0x0">
          <comment>monitor_cgm_busy_status</comment>
        </bits>
        <bits access="r" name="gate_en_status" pos="9:0" rst="0x0">
          <comment>monitor_gate_en_status</comment>
        </bits>
      </reg>
      <reg name="debug_status" protect="rw">
        <comment>debug_status debug_status</comment>
      </reg>
      <hole size="1600"/>
      <reg name="apb_eb_set" protect="rw"/>
      <reg name="apb_soft_rst_set" protect="rw"/>
      <hole size="64"/>
      <reg name="lps_gate_sel_set" protect="rw"/>
      <reg name="lps_gate_force_set" protect="rw"/>
      <hole size="64"/>
      <reg name="lpc_ctrl1_set" protect="rw"/>
      <reg name="pub_anti_hang_set" protect="rw"/>
      <hole size="1728"/>
      <reg name="apb_eb_clr" protect="rw"/>
      <reg name="apb_soft_rst_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="lps_gate_sel_clr" protect="rw"/>
      <reg name="lps_gate_force_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="lpc_ctrl1_clr" protect="rw"/>
      <reg name="pub_anti_hang_clr" protect="rw"/>
    </module>
    <var name="REG_PUB_APB_SET_OFFSET" value="0x100"/>
    <var name="REG_PUB_APB_CLR_OFFSET" value="0x200"/>
    <instance address="0x51603000" name="PUB_APB" type="PUB_APB"/>
  </archive>
  <archive relative="rf_dfe.xml">
    <module category="System" name="RF_DFE">
      <reg name="general_mode" protect="rw">
        <comment/>
        <bits access="rw" name="reset_mode" pos="14" rst="0x0">
          <comment>1: use external resetn
0: use sw/enable generated internal resetn for rxdp</comment>
        </bits>
        <bits access="rw" name="clk_dac_inv_mode" pos="13" rst="0x0">
          <comment>0: clk_dac
1: clk_dac invert</comment>
        </bits>
        <bits access="rw" name="clk_adc_inv_mode" pos="12" rst="0x0">
          <comment>0: clk_adc
1: clk_adc invert</comment>
        </bits>
        <bits access="rw" name="rx_mode" pos="7:4" rst="0x0">
          <comment>0:no use
1:no use
2:LTE-1.4M
3:LTE-3M
4:LTE-5M
5:LTE-10M
6:LTE-15M
7:LTE-20M
8:no use</comment>
        </bits>
        <bits access="rw" name="adc_clk_mode" pos="2:1" rst="0x0">
          <comment>0:30.72MHz
1:61.44MHz
2:122.88MHz</comment>
        </bits>
        <bits access="rw" name="zf_if_mode" pos="0" rst="0x0">
          <comment>0: IF mode
1: ZF mode</comment>
        </bits>
      </reg>
      <reg name="dfe_clock_gate_enable_reg" protect="rw">
        <comment/>
        <bits access="rw" name="reg_clkgate_en" pos="14" rst="0x0">
          <comment>0: registers module clk gating enabled;
1: registers module clk always on;
new add for debug, should not config</comment>
        </bits>
        <bits access="rw" name="txdp_loft_mode" pos="13" rst="0x0">
          <comment>0: RX CIC1 doesn't work in loft mode;
1: RX CIC1 works in loft mode</comment>
        </bits>
        <bits access="rw" name="sw_resetn" pos="9" rst="0x1">
          <comment>sw controlled resetn for rxdp
0: assert reset
1: not reset</comment>
        </bits>
        <bits access="rw" name="clk_rate_convert_rg" pos="8" rst="0x0">
          <comment>DFE clock shift control. Change in 8910m, when clock_shift enable, only config this bit, no need config rxdp_rc or txdp_rc (deleted)
0: clock shift disabled
1: clock shift enabled. When it is enabled, all DFE clocks except GSM TX clock are working in 17/16 normal frequency</comment>
        </bits>
        <bits access="rw" name="clk_122p88m_en" pos="6" rst="0x1">
          <comment>clock enable for BB LTE @122.88MHz</comment>
        </bits>
        <bits access="rw" name="txdp_nb_dfe_clk_en" pos="4" rst="0x0">
          <comment>clock enable for DFE NB/WT/LTE TX</comment>
        </bits>
        <bits access="rw" name="rxdp_dfe_clk_en" pos="2" rst="0x0">
          <comment>clock enable for DFE RX</comment>
        </bits>
        <bits access="rw" name="txdp_clk_dac_en" pos="1" rst="0x0">
          <comment>clock enable for DAC</comment>
        </bits>
        <bits access="rw" name="rxdp_adc_clk_en" pos="0" rst="0x0">
          <comment>clock eanble for ADC</comment>
        </bits>
      </reg>
      <reg name="rxdp_dcc" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_dcc_load" pos="6" rst="0x0">
          <comment>Start to load DC value, active high. Before next load, set it low firstly</comment>
        </bits>
        <bits access="rw" name="dcc_imgrej_rg" pos="5" rst="0x0">
          <comment>IQ swap in DC module
0: no swap
1. swap</comment>
        </bits>
        <bits access="rw" name="dcc_hold_en_rg" pos="4" rst="0x0">
          <comment>Hold DC accumulator calculation in DC calibration mode</comment>
        </bits>
        <bits access="rw" name="dcc_bypass_rg" pos="3" rst="0x0">
          <comment>This register is not used. But DC module bypass is actrually controlled by register rxdp_bypass_dcc and rxdp_bypass_mode_dcc</comment>
        </bits>
        <bits access="rw" name="dcc_dc_delta_ld_st_rg" pos="2" rst="0x0">
          <comment>Store initial value to DC accumulator at positive edge in DC cancel mode or DC calibration mode.</comment>
        </bits>
        <bits access="rw" name="dcc_dc_calib_en_rg" pos="1" rst="0x0">
          <comment>Load DC value in calibration mode to debug port, only used for debug purpose</comment>
        </bits>
        <bits access="rw" name="dcc_rx_calib_sel_rg" pos="0" rst="0x0">
          <comment>DC module work mode.
0: DC calibration mode
1: DC cancel mode</comment>
        </bits>
      </reg>
      <reg name="rxdp_dc_calib_re" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_dc_calib_re_rg" pos="15:0" rst="0x0">
          <comment>DC real part value used in cancel mode</comment>
        </bits>
      </reg>
      <reg name="rxdp_dc_calib_im" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_dc_calib_im_rg" pos="15:0" rst="0x0">
          <comment>DC image part value used in cancel mode</comment>
        </bits>
      </reg>
      <reg name="rxdp_dc_delta_re" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_dc_delta_re_rg" pos="15:0" rst="0x0">
          <comment>Accumulator initial real part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register</comment>
        </bits>
      </reg>
      <reg name="rxdp_dc_delta_im" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_dc_delta_im_rg" pos="15:0" rst="0x0">
          <comment>Accumulator initial image part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register</comment>
        </bits>
      </reg>
      <reg name="rxdp_dc_cr" protect="rw">
        <comment/>
        <bits access="rw" name="conv_slow_bw_ct_rg" pos="11:9" rst="0x0">
          <comment>Slow convergence control, work with conv_mode_ct_rg register</comment>
        </bits>
        <bits access="rw" name="conv_fast_bw_ct_rg" pos="8:6" rst="0x0">
          <comment>Fast convergence control, work with conv_mode_ct_rg register</comment>
        </bits>
        <bits access="rw" name="conv_tmr_ct_rg" pos="5:2" rst="0x0">
          <comment>Duration time of DC calibration, which is based on sample unit</comment>
        </bits>
        <bits access="rw" name="conv_mode_ct_rg" pos="1:0" rst="0x0">
          <comment>DC convergence loop mode selection.
0: fast
1: slow
2: fast-&gt;slow
3: fast-&gt;hold</comment>
        </bits>
      </reg>
      <reg name="rxdp_gain_ct_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gain_ct_load" pos="13" rst="0x0">
          <comment>load rxdp_gain_ct to DFE.
Write it to 1b'0 before assert it; new add, when [12]=0, need use this bit</comment>
        </bits>
        <bits access="rw" name="rxdp_gain_ct_load_bypass" pos="12" rst="0x1">
          <comment>bypass rxdp_gain_ct_load; new add,
1: direct use [10:0] in static adjust agc gain
0: use [10:0] need load first  for dynamic adjust agc gain</comment>
        </bits>
        <bits access="rw" name="rxdp_gain_ct" pos="10:0" rst="0x0">
          <comment>Gain BB control. [-24db, 47.9375db], step=1/16db;
change the step from 1/8db to 1/16db</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="rxdp_gdeq_coef0_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef0_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of RX group delay coefficient 0</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef0_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef0_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of RX group delay coefficient 0</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef1_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef1_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of RX group delay coefficient 1</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef1_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef1_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of RX group delay coefficient 1</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef2_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef2_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of RX group delay coefficient 2</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef2_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef2_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of RX group delay coefficient 2</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef3_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_coef3_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of RX group delay coefficient 3</comment>
        </bits>
      </reg>
      <reg name="rxdp_gdeq_coef3_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_gdeq_bp_lp_sel" pos="4" rst="0x0">
          <comment>1: LP
0: BP</comment>
        </bits>
        <bits access="rw" name="rxdp_gdeq_coef3_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of RX group delay coefficient 3</comment>
        </bits>
      </reg>
      <reg name="rxdp_adc_wr_buf_fifo" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_adc_smp_rate_rg" pos="6:1" rst="0x0">
          <comment>Read rate of DFE ADC FIFO, which depends on RX mode. 8910m move 0x0060[12:7] to here[6:1]
5'h00: GGE
5'h01: NB/WT</comment>
        </bits>
        <bits access="rw" name="rxdp_adc_wr_en_rg" pos="0" rst="0x1">
          <comment>Write enable of DFE ADC FIFO, active high</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="rxdp_dcc_valid_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_dcc_val_reg" pos="0" rst="0x0">
          <comment>Valid indication of DC value after assert rxdp_dcc_load to avoid metastability. rxdp_dcc_re_o and rxdp_dcc_im_o are stable when this register is high</comment>
        </bits>
      </reg>
      <reg name="rxdp_dcc_re_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_dcc_re_o" pos="15:0" rst="0x0">
          <comment>Real part of DC value, it is stable when rxdp_dcc_val_reg is high</comment>
        </bits>
      </reg>
      <reg name="rxdp_dcc_im_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_dcc_im_o" pos="15:0" rst="0x0">
          <comment>Image part of DC value, it is stable when rxdp_dcc_val_reg is high</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch_ct" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch_dataen0" pos="1" rst="0x1">
          <comment>Data enable of Notch DC
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rxdp_notch_dataen1" pos="0" rst="0x1"/>
      </reg>
      <reg name="rxdp_notch_a0_i_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch_a0_i" pos="11:0" rst="0x0">
          <comment>Coefficient a for real part of Notch DC</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch_a0_q_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch_a0_q" pos="11:0" rst="0x0">
          <comment>Coefficient a for image part of Notch DC</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch_k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch_k0" pos="5:0" rst="0x0">
          <comment>Coefficient k of Notch DC</comment>
        </bits>
      </reg>
      <reg name="rxdp_mirror_remove" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_mrrm_bw_sel" pos="1:0" rst="0x0">
          <comment>mrrm bandwidth selection</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_ct" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_dataen0" pos="1" rst="0x1">
          <comment>Data enable of Notch H 1st core
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rxdp_notch2_dataen1" pos="0" rst="0x1">
          <comment>Data enable of Notch H 2nd core
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_a0_i_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_a0_i" pos="11:0" rst="0x0">
          <comment>Coefficient a for real part of Notch H 1st core</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_a0_q_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_a0_q" pos="11:0" rst="0x0">
          <comment>Coefficient a for image part of Notch H 1st core</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_a1_i_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_a1_i" pos="11:0" rst="0x0">
          <comment>Coefficient a for real part of Notch H 2nd core</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_a1_q_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_a1_q" pos="11:0" rst="0x0">
          <comment>Coefficient a for image part of Notch H 2nd core</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch2_k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_k0" pos="11:6" rst="0x0">
          <comment>Coefficient k of Notch H 1st core</comment>
        </bits>
        <bits access="rw" name="rxdp_notch2_k1" pos="5:0" rst="0x0">
          <comment>Coefficient k of Notch H 2nd core</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef0" pos="15:0" rst="0x0">
          <comment>Coefficient COEF0 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef1" pos="15:0" rst="0x0">
          <comment>Coefficient COEF1 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef2_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef2" pos="15:0" rst="0x0">
          <comment>Coefficient COEF2 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef3" pos="15:0" rst="0x0">
          <comment>Coefficient COEF3 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef4_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef4" pos="15:0" rst="0x0">
          <comment>Coefficient COEF4 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef5_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef5" pos="15:0" rst="0x0">
          <comment>Coefficient COEF5 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef6_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef6" pos="15:0" rst="0x0">
          <comment>Coefficient COEF6 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef7_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef7" pos="15:0" rst="0x0">
          <comment>Coefficient COEF7 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef8_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef8" pos="15:0" rst="0x0">
          <comment>Coefficient COEF8 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef9_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef9" pos="15:0" rst="0x0">
          <comment>Coefficient COEF9 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef10_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef10" pos="15:0" rst="0x0">
          <comment>Coefficient COEF10 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef11_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef11" pos="15:0" rst="0x0">
          <comment>Coefficient COEF11 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef12_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef12" pos="15:0" rst="0x0">
          <comment>Coefficient COEF12 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef13_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef13" pos="15:0" rst="0x0">
          <comment>Coefficient COEF13 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef14_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef14" pos="15:0" rst="0x0">
          <comment>Coefficient COEF14 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef15_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef15" pos="15:0" rst="0x0">
          <comment>Coefficient COEF15 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef16_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef16" pos="15:0" rst="0x0">
          <comment>Coefficient COEF16 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef17_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef17" pos="15:0" rst="0x0">
          <comment>Coefficient COEF17 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef18_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef18" pos="15:0" rst="0x0">
          <comment>Coefficient COEF18 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef19_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef19" pos="15:0" rst="0x0">
          <comment>Coefficient COEF19 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef20_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef20" pos="15:0" rst="0x0">
          <comment>Coefficient COEF20 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef21_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef21" pos="15:0" rst="0x0">
          <comment>Coefficient COEF21 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef22_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef22" pos="15:0" rst="0x0">
          <comment>Coefficient COEF22 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_aci_filter_coef23_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_aci_fir_coef23" pos="15:0" rst="0x0">
          <comment>Coefficient COEF23 of ACI filter</comment>
        </bits>
      </reg>
      <reg name="rxdp_mixer_freq_in_reg0" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_mixer_freq_p0" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of frequency offset for Mixer</comment>
        </bits>
      </reg>
      <reg name="rxdp_mixer_freq_in_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_mixer_freq_p1" pos="7:0" rst="0x0">
          <comment>Bit [23:16] of frequency offset for Mixer</comment>
        </bits>
      </reg>
      <reg name="rxdp_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rssi3_enable" pos="11" rst="0x0">
          <comment>RSSI3 enable</comment>
        </bits>
        <bits access="rw" name="rxdp_rssi3_ushift" pos="10:8" rst="0x0">
          <comment>RSSI3 ushift value</comment>
        </bits>
        <bits access="rw" name="rxdp_rssi_ob_enable" pos="7" rst="0x0">
          <comment>Outband RSSI enable</comment>
        </bits>
        <bits access="rw" name="rxdp_rssi_ib_enable" pos="6" rst="0x0">
          <comment>Inband RSSI enable</comment>
        </bits>
        <bits access="rw" name="rxdp_rssi_ob_ushift" pos="5:3" rst="0x0">
          <comment>Outband RSSI ushift value</comment>
        </bits>
        <bits access="rw" name="rxdp_rssi_ib_ushift" pos="2:0" rst="0x0">
          <comment>Inband RSSI ushift value</comment>
        </bits>
      </reg>
      <reg name="rxdp_imbc_wa_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_imbc_wa" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_wq_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_imbc_wq" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_misc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_imbc_bw_fast_ct_rg" pos="10:7" rst="0x0"/>
        <bits access="rw" name="rxdp_imbc_bw_slow_ct" pos="6:3" rst="0x0"/>
        <bits access="rw" name="rxdp_imbc_hold_dr" pos="2" rst="0x0"/>
        <bits access="rw" name="rxdp_imbc_calc_rels" pos="1" rst="0x0"/>
        <bits access="rw" name="rxdp_imbc_load" pos="0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_wa_out_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_imbc_wa_out" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_wq_out_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_imbc_wq_out" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_out_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_imbc_val_out" pos="0" rst="0x0"/>
      </reg>
      <reg name="rxdp_rc_rate_ofs_period_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_rate_ofs_period" pos="9:0" rst="0x10"/>
      </reg>
      <reg name="rxdp_rc_rate_ofs_hi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_rate_ofs_hi" pos="7:0" rst="0x80"/>
      </reg>
      <reg name="rxdp_rc_rate_ofs_lo_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_rate_ofs_lo" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="start_max_min_ib_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="start_max_min_ib_rssi" pos="0" rst="0x0">
          <comment>start inband RSSI max and min measurement</comment>
        </bits>
      </reg>
      <reg name="count_16lsb_ib_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16lsb_ib_rssi" pos="15:0" rst="0x7800">
          <comment>timer count[15:0] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="count_16msb_ib_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16msb_ib_rssi" pos="15:0" rst="0x0">
          <comment>timer count[31:16] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="load_max_min_ib_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_max_min_ib_rssi" pos="0" rst="0x0">
          <comment>start to load max and min measurement report. Before next load, set it low firstly</comment>
        </bits>
      </reg>
      <reg name="rssi_min_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_min_val_reg_ib_rssi" pos="10" rst="0x0">
          <comment>valid of max and min measurement report</comment>
        </bits>
        <bits access="r" name="rssi_min_reg_ib_rssi" pos="9:0" rst="0x0">
          <comment>inband RSSI min value</comment>
        </bits>
      </reg>
      <reg name="rssi_max_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_reg_ib_rssi" pos="9:0" rst="0x0">
          <comment>inband RSSI max value, it is stable when rssi_max_min_val_reg_ib_rssi is high</comment>
        </bits>
      </reg>
      <reg name="int_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_int_ib_rssi" pos="2" rst="0x0">
          <comment>interrupt status to be able to start to load max and min measurement report</comment>
        </bits>
        <bits access="rw" name="int_mask_ib_rssi" pos="1" rst="0x0">
          <comment>interrupt mask</comment>
        </bits>
        <bits access="rw" name="int_clear_ib_rssi" pos="0" rst="0x0">
          <comment>interrupt clear</comment>
        </bits>
      </reg>
      <reg name="load_ib_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_ib_rssi" pos="0" rst="0x0">
          <comment>indication to read instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_val_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_val_reg_ib_rssi" pos="0" rst="0x0">
          <comment>valid of instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_ib_rssi" pos="9:0" rst="0x0">
          <comment>inband RSSI instant value</comment>
        </bits>
      </reg>
      <reg name="start_max_min_ob_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="start_max_min_ob_rssi" pos="0" rst="0x0">
          <comment>start outband RSSI max and min measurement</comment>
        </bits>
      </reg>
      <reg name="count_16lsb_ob_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16lsb_ob_rssi" pos="15:0" rst="0x7800">
          <comment>timer count[15:0] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="count_16msb_ob_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16msb_ob_rssi" pos="15:0" rst="0x0">
          <comment>timer count[31:16] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="load_max_min_ob_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_max_min_ob_rssi" pos="0" rst="0x0">
          <comment>indication to read max and min measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_max_min_val_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_min_val_reg_ob_rssi" pos="0" rst="0x0">
          <comment>valid of max and min measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_min_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_min_reg_ob_rssi" pos="9:0" rst="0x0">
          <comment>outband RSSI min value</comment>
        </bits>
      </reg>
      <reg name="rssi_max_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_reg_ob_rssi" pos="9:0" rst="0x0">
          <comment>outband RSSI max value</comment>
        </bits>
      </reg>
      <reg name="int_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_int_ob_rssi" pos="2" rst="0x0">
          <comment>interrupt status to be able to start to load max and min measurement report</comment>
        </bits>
        <bits access="rw" name="int_mask_ob_rssi" pos="1" rst="0x0">
          <comment>interrupt mask</comment>
        </bits>
        <bits access="rw" name="int_clear_ob_rssi" pos="0" rst="0x0">
          <comment>interrupt clear</comment>
        </bits>
      </reg>
      <reg name="load_ob_rssi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_ob_rssi" pos="0" rst="0x0">
          <comment>indication to read instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_val_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_val_reg_ob_rssi" pos="0" rst="0x0">
          <comment>valid of instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_wd_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_wd_ob_rssi" pos="9:0" rst="0x0">
          <comment>outband RSSI instant value for WD</comment>
        </bits>
      </reg>
      <reg name="rssi_up_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_up_ob_rssi" pos="9:0" rst="0x0">
          <comment>outband RSSI instant value for UP</comment>
        </bits>
      </reg>
      <reg name="rssi_dn_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_dn_ob_rssi" pos="9:0" rst="0x0">
          <comment>outband RSSI instant value for DN</comment>
        </bits>
      </reg>
      <reg name="rxdp_rc_stretch_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_stretch" pos="7:0" rst="0x8"/>
      </reg>
      <reg name="rxdp_rc_rate_ofs_rest_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_rate_ofs_rest" pos="9:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_bypass_control_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_bypass_gainbb" pos="14" rst="0x0">
          <comment>Gain_BB</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_notch2_2" pos="13" rst="0x0">
          <comment>Notrch(H) 2nd core</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_notch2_1" pos="12" rst="0x0">
          <comment>Notrch(H) 1st core</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_dnbh1" pos="11" rst="0x0">
          <comment>Deci. HBF1</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_aci_lpf" pos="10" rst="0x0">
          <comment>ACI Filter</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_gdeq" pos="7" rst="0x0">
          <comment>Group Delay Equ</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_notch1_1" pos="5" rst="0x0">
          <comment>Notch(DC)</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mixer" pos="4" rst="0x0">
          <comment>Mixer</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_rc" pos="3" rst="0x0">
          <comment>RC</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_dcc" pos="1" rst="0x0">
          <comment>DC Calib.&amp;Cancel</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_cic1" pos="0" rst="0x0">
          <comment>Deci.CIC1</comment>
        </bits>
      </reg>
      <reg name="rxdp_bypass_control_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_bypass_dnhb2" pos="6" rst="0x0">
          <comment>dnhb2</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_imbc" pos="5" rst="0x0">
          <comment>imbc</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mrrm" pos="4" rst="0x0">
          <comment>mrrm</comment>
        </bits>
      </reg>
      <reg name="rxdp_bypass_mode_control_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_bypass_mode_gainbb" pos="14" rst="0x0">
          <comment>Gain_BB</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_notch2_2" pos="13" rst="0x0">
          <comment>Notrch(H) 2nd core</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_notch2_1" pos="12" rst="0x0">
          <comment>Notrch(H) 1st core</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_dnbh1" pos="11" rst="0x0">
          <comment>Deci. HBF1</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_aci_lpf" pos="10" rst="0x0">
          <comment>ACI Filter</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_gdeq" pos="7" rst="0x0">
          <comment>Group Delay Equ</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_notch1_1" pos="5" rst="0x0">
          <comment>Notch(DC)</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_mixer" pos="4" rst="0x0">
          <comment>Mixer</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_rc" pos="3" rst="0x0">
          <comment>RC</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_dcc" pos="1" rst="0x0">
          <comment>DC Calib.&amp;Cancel</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_cic1" pos="0" rst="0x0">
          <comment>Deci.CIC1</comment>
        </bits>
      </reg>
      <reg name="rxdp_bypass_mode_control_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_bypass_mode_dnhb2" pos="6" rst="0x0">
          <comment>dnhb2</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_imbc" pos="5" rst="0x0">
          <comment>imbc</comment>
        </bits>
        <bits access="rw" name="rxdp_bypass_mode_mrrm" pos="4" rst="0x0">
          <comment>mrrm</comment>
        </bits>
      </reg>
      <reg name="rxdp_dcc_re_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_dcc_re_real" pos="15:0" rst="0x0">
          <comment>instant value of rxdp_dcc_re, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rxdp_dcc_im_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_dcc_im_real" pos="15:0" rst="0x0">
          <comment>instant value of rxdp_dcc_im, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rssi_real_ib_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_real_ib_rssi" pos="9:0" rst="0x230">
          <comment>instant value of rssi_reg_ib_rssi, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rssi_wd_real_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_wd_real_ob_rssi" pos="9:0" rst="0x0">
          <comment>instant value of rssi_reg_wd_ob_rssi, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rssi_up_real_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_up_real_ob_rssi" pos="9:0" rst="0x0">
          <comment>instant value of rssi_reg_up_ob_rssi, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rssi_dn_real_ob_rssi" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_dn_real_ob_rssi" pos="9:0" rst="0x0">
          <comment>instant value of rssi_reg_dn_ob_rssi, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rxdp_imbc_wa_out_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_imbc_wa_out_real" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_imbc_wq_out_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_imbc_wq_out_real" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="start_max_min_rssi3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="start_max_min_rssi3" pos="0" rst="0x0">
          <comment>start RSSI3 max and min measurement</comment>
        </bits>
      </reg>
      <reg name="count_16lsb_rssi3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16lsb_rssi3" pos="15:0" rst="0x7800">
          <comment>timer count[15:0] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="count_16msb_rssi3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="count_16msb_rssi3" pos="15:0" rst="0x0">
          <comment>timer count[31:16] for max and min measurement report after start</comment>
        </bits>
      </reg>
      <reg name="load_max_min_rssi3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_max_min_rssi3" pos="0" rst="0x0">
          <comment>start to load max and min measurement report. Before next load, set it low firstly</comment>
        </bits>
      </reg>
      <reg name="rssi_min_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_min_val_reg_rssi3" pos="10" rst="0x0">
          <comment>valid of max and min measurement report</comment>
        </bits>
        <bits access="r" name="rssi_min_reg_rssi3" pos="9:0" rst="0x0">
          <comment>RSSI3 min value</comment>
        </bits>
      </reg>
      <reg name="rssi_max_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_max_reg_rssi3" pos="9:0" rst="0x0">
          <comment>RSSI3 max value, it is stable when rssi_max_min_val_reg_rssi3 is high</comment>
        </bits>
      </reg>
      <reg name="int_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_int_rssi3" pos="2" rst="0x0">
          <comment>interrupt status to be able to start to load max and min measurement report</comment>
        </bits>
        <bits access="rw" name="int_mask_rssi3" pos="1" rst="0x0">
          <comment>interrupt mask</comment>
        </bits>
        <bits access="rw" name="int_clear_rssi3" pos="0" rst="0x0">
          <comment>interrupt clear</comment>
        </bits>
      </reg>
      <reg name="load_rssi3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="load_rssi3" pos="0" rst="0x0">
          <comment>indication to read instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_val_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_val_reg_rssi3" pos="0" rst="0x0">
          <comment>valid of instant measurement report</comment>
        </bits>
      </reg>
      <reg name="rssi_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_rssi3" pos="9:0" rst="0x0">
          <comment>RSSI3 instant value</comment>
        </bits>
      </reg>
      <reg name="rssi_real_rssi3" protect="rw">
        <comment/>
        <bits access="r" name="rssi_reg_real_rssi3" pos="9:0" rst="0x230">
          <comment>instant value of rssi_reg_rssi3, new add for debug</comment>
        </bits>
      </reg>
      <reg name="rxdp_notch_cordic_enable_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch_cordic_gain_sel" pos="4:3" rst="0x1"/>
        <bits access="rw" name="rxdp_notch2_cordic1_enable" pos="2" rst="0x0"/>
        <bits access="rw" name="rxdp_notch2_cordic0_enable" pos="1" rst="0x0"/>
        <bits access="rw" name="rxdp_notch1_cordic_enable" pos="0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch1_cordic_amp_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch1_cordic_amp" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch1_cordic_zin_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch1_cordic_zin" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic0_amp_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_cordic0_amp" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic0_zin_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_cordic0_zin" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic1_amp_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_cordic1_amp" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic1_zin_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_notch2_cordic1_zin" pos="13:0" rst="0x0"/>
      </reg>
      <reg name="txdp_cfr_th_liner_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_cfr_th_liner" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txdp_sine_rate_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_sine_rate" pos="7:0" rst="0x1"/>
      </reg>
      <reg name="txdp_rc_stretch_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_rc_stretch" pos="7:0" rst="0x8"/>
      </reg>
      <reg name="txdp_rc_rate_ofs_rest_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_rc_rate_ofs_rest" pos="9:0" rst="0x0"/>
      </reg>
      <reg name="txdp_rc_rate_ofs_period_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_rc_rate_ofs_period" pos="9:0" rst="0x10"/>
      </reg>
      <reg name="txdp_rc_rate_ofs_hi_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_rc_rate_ofs_hi" pos="7:0" rst="0x80"/>
      </reg>
      <reg name="txdp_rc_rate_ofs_lo_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_rc_rate_ofs_lo" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="clk_convert_rate_reg" protect="rw">
        <comment/>
        <bits access="rw" name="clk_convert_rate_b" pos="15:8" rst="0x10"/>
        <bits access="rw" name="clk_convert_rate_a" pos="7:0" rst="0x11"/>
      </reg>
      <reg name="rxdp_notch1_cordic_dout_i_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch1_cordic_dout_i" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch1_cordic_dout_q_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch1_cordic_dout_q" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic0_dout_i_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch2_cordic0_dout_i" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic0_dout_q_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch2_cordic0_dout_q" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic1_dout_i_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch2_cordic1_dout_i" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch2_cordic1_dout_q_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch2_cordic1_dout_q" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxdp_notch_gen_val_reg" protect="rw">
        <comment/>
        <bits access="r" name="rxdp_notch2_cordic1_dout_val" pos="2" rst="0x0"/>
        <bits access="r" name="rxdp_notch2_cordic0_dout_val" pos="1" rst="0x0"/>
        <bits access="r" name="rxdp_notch1_cordic_dout_val" pos="0" rst="0x0"/>
      </reg>
      <reg name="resetn_notch_gen_reg" protect="rw">
        <comment/>
        <bits access="rw" name="resetn_notch_gen" pos="0" rst="0x0"/>
      </reg>
      <reg name="dfe_dump_smp_rate_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dfe_dump_smp_rate" pos="7:0" rst="0x3"/>
      </reg>
      <hole size="1440"/>
      <reg name="txdp_wedge_gain_ct_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_gain_ct_load" pos="13" rst="0x0">
          <comment>load txdp_wedge_gain_ct to DFE. Write it to 1b'0 before assert it, new add, when [12]=0, need use this bit</comment>
        </bits>
        <bits access="rw" name="txdp_wedge_gain_ct_load_bypass" pos="12" rst="0x1">
          <comment>bypass txdp_wedge_gain_ct_load; new add, 1: direct use [10:0] in static adjust agc gain 0: use [10:0] need load first  for dynamic adjust agc gain</comment>
        </bits>
        <bits access="rw" name="txdp_wedge_gain_ct" pos="10:0" rst="0x0">
          <comment>Gain control of NB/WT TX. [-24db, 47.9375db], step=1/16db; change the step from 1/8db to 1/16db</comment>
        </bits>
      </reg>
      <hole size="672"/>
      <reg name="txdp_wedge_am_shrink_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_shrink" pos="7:0" rst="0x0"/>
      </reg>
      <hole size="32"/>
      <reg name="txdp_wedge_pm_shift_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_shift" pos="1:0" rst="0x0"/>
      </reg>
      <reg name="txdp_wedge_am_p0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p0" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p1" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p2_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p2" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p3" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p4_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p4" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p5_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p5" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p6_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p6" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p7_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p7" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p8_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p8" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p9_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p9" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p10_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p10" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p11_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p11" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p12_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p12" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p13_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p13" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p14_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p14" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p15_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p15" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_am_p16_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_am_p16" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p0" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p1" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p2_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p2" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p3_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p3" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p4_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p4" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p5_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p5" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p6_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p6" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p7_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p7" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p8_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p8" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p9_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p9" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p10_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p10" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p11_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p11" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p12_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p12" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p13_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p13" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p14_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p14" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p15_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p15" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <reg name="txdp_wedge_pm_p16_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_wedge_pm_p16" pos="9:0" rst="0x0">
          <comment>Amplitude compensation curve of DPD</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="aclr_coef4" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef04" pos="9:0" rst="0x0">
          <comment>Coefficient 4 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef5" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef05" pos="9:0" rst="0x0">
          <comment>Coefficient 5 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef6" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef06" pos="9:0" rst="0x0">
          <comment>Coefficient 6 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef7" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef07" pos="9:0" rst="0x0">
          <comment>Coefficient 7 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="clk_convert_rate_load" protect="rw">
        <comment/>
        <bits access="rw" name="clk_convert_rate_load" pos="0" rst="0x0"/>
      </reg>
      <reg name="clk_dac_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="clk_dac_test_sel" pos="3:2" rst="0x0">
          <comment>resource of clk_dac when test mode.
00: clk_122p88m
01: clk_61p44m
10: clk_30p72m
11: clk_adc_gge_nb</comment>
        </bits>
        <bits access="rw" name="clk_dac_test_en" pos="1" rst="0x0">
          <comment>enable clk_dac when test mode</comment>
        </bits>
        <bits access="rw" name="clk_dac_sel" pos="0" rst="0x0">
          <comment>0: clk_dac is from function mode
1: clk_dac is from test mode</comment>
        </bits>
      </reg>
      <reg name="txdp_delay_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_delay" pos="7:0" rst="0x0">
          <comment>txdp_delay</comment>
        </bits>
      </reg>
      <reg name="aclr_coef0" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef00" pos="9:0" rst="0x0">
          <comment>Coefficient 0 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef1" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef01" pos="9:0" rst="0x0">
          <comment>Coefficient 1 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef2" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef02" pos="9:0" rst="0x0">
          <comment>Coefficient 2 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef3" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef03" pos="9:0" rst="0x0">
          <comment>Coefficient 3 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef0_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef0_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of coefficient 0 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef0_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef0_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of coefficient 0 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef1_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef1_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of coefficient 1 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef1_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef1_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of coefficient 1 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef2_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef2_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of coefficient 2 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef2_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef2_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of coefficient 2 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef3_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef3_rg_lo" pos="15:0" rst="0x0">
          <comment>Bit [15:0] of coefficient 3 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_gdeq_coef3_rg_2" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_gdeq_coef3_rg_hi" pos="3:0" rst="0x0">
          <comment>Bit [19:16] of coefficient 3 of group delay equ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <hole size="384"/>
      <reg name="txdp_loft_offset_i_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_offset_i" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_offset_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_offset" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_phase_err_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_phase_err" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_amp_err_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_amp_err" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_rssi_reg" protect="rw">
        <comment/>
        <bits access="r" name="txdp_loft_rssi_err" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_tone_amp_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_tone_amp" pos="11:0" rst="0x1ff"/>
      </reg>
      <reg name="txdp_loft_tone_fre_reg0" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_tone_fre0" pos="15:0" rst="0xd555"/>
      </reg>
      <reg name="txdp_loft_tone_fre_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_tone_fre1" pos="6:0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_misc0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_loft_sincos_en" pos="15" rst="0x0"/>
        <bits access="rw" name="txdp_loft_din_loft_sel" pos="14" rst="0x0"/>
        <bits access="rw" name="txdp_loft_cali_en" pos="13" rst="0x0"/>
        <bits access="rw" name="txdp_loft_cancel_bypass" pos="12" rst="0x0"/>
        <bits access="rw" name="txdp_loft_offset_dr" pos="11" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="txdp_loft_phase_err_dr" pos="10" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="txdp_loft_amp_err_dr" pos="9" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="txdp_loft_flg_loft_calib" pos="8" rst="0x0"/>
        <bits access="rw" name="txdp_loft_bpf_enable" pos="7" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="txdp_loft_bpf_bypass" pos="6" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="txdp_loft_rssi_ushift" pos="5:3" rst="0x0"/>
        <bits access="rw" name="txdp_loft_rssi_period_idx" pos="2" rst="0x0"/>
        <bits access="rw" name="txdp_loft_rssi_enable" pos="1" rst="0x0"/>
        <bits access="rw" name="txdp_loft_rssi_load" pos="0" rst="0x0"/>
      </reg>
      <reg name="txdp_loft_gain1_reg" protect="rw">
        <comment/>
        <bits access="r" name="txdp_loft_rssi_val" pos="13" rst="0x0"/>
        <bits access="rw" name="txdp_loft_gain1_ct" pos="12:7" rst="0x0"/>
        <bits access="rw" name="txdp_loft_gain1_ct_dyn" pos="6:1" rst="0x0"/>
        <bits access="rw" name="txdp_loft_gain1_ct_sel" pos="0" rst="0x0"/>
      </reg>
      <reg name="data_format_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="nb_tx_rx_loop" pos="8" rst="0x0">
          <comment>BB TX data loopback to BB RX</comment>
        </bits>
        <bits access="rw" name="rx_iq_swap" pos="7" rst="0x0">
          <comment>BB RX IQ swap.
1: swap;
0: normal</comment>
        </bits>
        <bits access="rw" name="tx_iq_swap" pos="6" rst="0x0">
          <comment>BB TX IQ swap.
1: swap;
0: normal</comment>
        </bits>
        <bits access="rw" name="adc_iq_swap" pos="5" rst="0x0">
          <comment>ADC IQ swap.
1: swap;
0: normal</comment>
        </bits>
        <bits access="rw" name="dac_iq_swap" pos="4" rst="0x0">
          <comment>DAC IQ swap. 1: swap; 0: normal</comment>
        </bits>
        <bits access="rw" name="rx_off_bin_en" pos="3" rst="0x0">
          <comment>BB RX.
0: two's complement
1: offset binary</comment>
        </bits>
        <bits access="rw" name="tx_off_bin_en" pos="2" rst="0x0">
          <comment>BB TX.
0: two's complement
1: offset binary</comment>
        </bits>
        <bits access="rw" name="adc_off_bin_en" pos="1" rst="0x0">
          <comment>RF ADC.
0: two's complement
1: offset binary</comment>
        </bits>
        <bits access="rw" name="dac_off_bin_en" pos="0" rst="0x1">
          <comment>RF DAC.
0: two's complement
1: offset binary</comment>
        </bits>
      </reg>
      <reg name="txdp_loft_rssi_reg_real" protect="rw">
        <comment/>
        <bits access="r" name="txdp_loft_rssi_err_real" pos="15:0" rst="0x0">
          <comment>instant value of txdp_loft_rssi_err</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="temper_tsx_ct" protect="rw">
        <comment/>
        <bits access="r" name="temper_tsx_pout_val_rg" pos="9" rst="0x0">
          <comment>valid indication of temper_dout after assert temper_pout_load to avoid metastability. Thetemper_dout is stable when this register is high</comment>
        </bits>
        <bits access="rw" name="temper_tsx_pout_load" pos="8" rst="0x0">
          <comment>start to load the result of temper_dout. Before next load, set it low firstly</comment>
        </bits>
        <bits access="rw" name="temper_tsx_lpf3_bypass" pos="7" rst="0x0"/>
        <bits access="rw" name="temper_tsx_ushift" pos="6:4" rst="0x0">
          <comment>bandwidth select</comment>
        </bits>
        <bits access="rw" name="temper_tsx_bw_sel" pos="3:2" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="temper_tsx_lpf_bypass" pos="1" rst="0x0"/>
        <bits access="rw" name="temper_tsx_hold_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="temper_tsx_dout_reg" protect="rw">
        <comment/>
        <bits access="r" name="temper_tsx_dout" pos="15:0" rst="0x0">
          <comment>temper_dout value</comment>
        </bits>
      </reg>
      <reg name="tsx_temp_clk_ct" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_clk_en" pos="7" rst="0x0">
          <comment>clock enable for temper</comment>
        </bits>
        <bits access="rw" name="temper_tsx_clk_freq_sel" pos="6:5" rst="0x0">
          <comment>divide mode of clock from analog for Temcomp
0: not divide
1: 1/2 divide
2: 1/4 divide
3: 1/8 divide</comment>
        </bits>
        <bits access="rw" name="temper_tsx_clk_phase_sel" pos="4" rst="0x0">
          <comment>clock invert for Temcomp
0: clock invert disable
1: clock invert enable</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_a11_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_a11" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_a12_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_a12" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_g1_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_g1" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_a21_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_a21" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_a22_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_a22" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_lpf_g2_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_tsx_lpf_g2" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_tsx_dout_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="temper_tsx_dout_real" pos="15:0" rst="0x8000">
          <comment>instant value of temper_dout</comment>
        </bits>
      </reg>
      <hole size="448"/>
      <reg name="temper_ct" protect="rw">
        <comment/>
        <bits access="r" name="temper_pout_val_rg" pos="9" rst="0x0">
          <comment>valid indication of temper_dout after assert temper_pout_load to avoid metastability. Thetemper_dout is stable when this register is high</comment>
        </bits>
        <bits access="rw" name="temper_pout_load" pos="8" rst="0x0">
          <comment>start to load the result of temper_dout. Before next load, set it low firstly</comment>
        </bits>
        <bits access="rw" name="temper_lpf3_bypass" pos="7" rst="0x0"/>
        <bits access="rw" name="temper_ushift" pos="6:4" rst="0x0">
          <comment>bandwidth select</comment>
        </bits>
        <bits access="rw" name="temper_bw_sel" pos="3:2" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="temper_lpf_bypass" pos="1" rst="0x0"/>
        <bits access="rw" name="temper_hold_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="temper_dout_reg" protect="rw">
        <comment/>
        <bits access="r" name="temper_dout" pos="15:0" rst="0x0">
          <comment>temper_dout value</comment>
        </bits>
      </reg>
      <reg name="osc_temp_clk_ct" protect="rw">
        <comment/>
        <bits access="rw" name="temper_clk_en" pos="7" rst="0x0">
          <comment>clock enable for temper</comment>
        </bits>
        <bits access="rw" name="temper_clk_freq_sel" pos="6:5" rst="0x0">
          <comment>divide mode of clock from analog for Temcomp
0: not divide
1: 1/2 divide
2: 1/4 divide
3: 1/8 divide</comment>
        </bits>
        <bits access="rw" name="temper_clk_phase_sel" pos="4" rst="0x0">
          <comment>clock invert for Temcomp
0: clock invert disable
1: clock invert enable</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="temper_lpf_a11_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_a11" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_lpf_a12_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_a12" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_lpf_g1_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_g1" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_lpf_a21_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_a21" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_lpf_a22_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_a22" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <reg name="temper_lpf_g2_rg" protect="rw">
        <comment/>
        <bits access="rw" name="temper_lpf_g2" pos="13:0" rst="0x0">
          <comment>Coefficient of filter</comment>
        </bits>
      </reg>
      <hole size="256"/>
      <reg name="temper_dout_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="temper_dout_real" pos="15:0" rst="0x8000">
          <comment>instant value of temper_dout</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="dfe_sw_clkgate_en_rg" protect="rw">
        <comment/>
        <bits access="rw" name="dfe_sw_clkgate_en" pos="0" rst="0x0">
          <comment>dfe_sw_clkgate_en</comment>
        </bits>
      </reg>
      <reg name="mon_ct" protect="rw">
        <comment/>
        <bits access="rw" name="dfe_monitor_swap" pos="4" rst="0x0">
          <comment>swap of dfe_monitor[15:8] and dfe_monitor[7:0]</comment>
        </bits>
        <bits access="rw" name="dfe_monitor_sel" pos="3:0" rst="0x0">
          <comment>dfe_monitor select</comment>
        </bits>
      </reg>
      <reg name="dac_offset_re_rg" protect="rw">
        <comment/>
        <bits access="rw" name="dac_offset_re" pos="11:0" rst="0x0">
          <comment>The offset on DAC real part</comment>
        </bits>
      </reg>
      <reg name="dac_offset_im_rg" protect="rw">
        <comment/>
        <bits access="rw" name="dac_offset_im" pos="11:0" rst="0x0">
          <comment>The offset on DAC image part</comment>
        </bits>
      </reg>
      <reg name="dac_tx_amp_re_rg" protect="rw">
        <comment/>
        <bits access="rw" name="dac_tx_amp_re" pos="11:0" rst="0x0">
          <comment>The DAC real part on test mode</comment>
        </bits>
      </reg>
      <reg name="dac_tx_amp_im_rg" protect="rw">
        <comment/>
        <bits access="rw" name="dac_tx_amp_im" pos="11:0" rst="0x0">
          <comment>The DAC image part on test mode</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="data_dac_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="data_dac_sel" pos="14:13" rst="0x0">
          <comment>select of function DAC data or test DAC data
00/01: select function DAC data including sine waveform
10: select test DAC data in txdp
11: select test DAC data in txdp</comment>
        </bits>
        <bits access="rw" name="sine_enable_rg" pos="12" rst="0x0">
          <comment>enable sine generation module</comment>
        </bits>
        <bits access="rw" name="rxdp_test_dac_en_rg" pos="11" rst="0x0">
          <comment>enable of test DAC data in rxdp</comment>
        </bits>
        <bits access="rw" name="rxdp_test_dac_sel_rg" pos="10:6" rst="0x0">
          <comment>select of test DAC data in rxdp</comment>
        </bits>
        <bits access="rw" name="txdp_test_dac_en_rg" pos="5" rst="0x0">
          <comment>enable of test DAC data in txdp</comment>
        </bits>
        <bits access="rw" name="txdp_test_dac_sel_rg" pos="4:0" rst="0x0">
          <comment>select of test DAC data in txdp</comment>
        </bits>
      </reg>
      <reg name="sincos_amp" protect="rw">
        <comment/>
        <bits access="rw" name="sincos_amp_rg" pos="11:0" rst="0x1ff">
          <comment>sine amp</comment>
        </bits>
      </reg>
      <reg name="sincos_fre_lo" protect="rw">
        <comment/>
        <bits access="rw" name="sincos_fre_rg_lo" pos="15:0" rst="0xd555">
          <comment>sine frequency[15:0]</comment>
        </bits>
      </reg>
      <reg name="sincos_fre_hi" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_bypass_loft" pos="8" rst="0x0">
          <comment>LOFT</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_loft" pos="7" rst="0x0">
          <comment>LOFT</comment>
        </bits>
        <bits access="rw" name="sincos_fre_rg_hi" pos="6:0" rst="0x0">
          <comment>sine frequence[22:16]</comment>
        </bits>
      </reg>
      <reg name="txdp_bypass_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_bypass_uphb5" pos="13" rst="0x0">
          <comment>UPHBF(3)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_uphb4" pos="12" rst="0x0">
          <comment>UPHBF(2)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_gdeq" pos="11" rst="0x0">
          <comment>Group Delay Equ.</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_polariq_ampm" pos="9" rst="0x0">
          <comment>AMPM of DPD</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_polariq" pos="7" rst="0x0">
          <comment>Whole DPD</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_rc" pos="6" rst="0x0">
          <comment>RC</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_gain" pos="5" rst="0x0">
          <comment>Gain</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_cfr" pos="3" rst="0x0">
          <comment>CFR</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_uphb1" pos="2" rst="0x0">
          <comment>UPHBF(1)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_aclr_lpf" pos="1" rst="0x0">
          <comment>ACLR LPF</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_ampequ" pos="0" rst="0x0">
          <comment>ampequ, new add</comment>
        </bits>
      </reg>
      <reg name="txdp_bypass_mode_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_bypass_mode_uphb5" pos="13" rst="0x0">
          <comment>UPHBF(3)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_uphb4" pos="12" rst="0x0">
          <comment>UPHBF(2)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_gdeq" pos="11" rst="0x0">
          <comment>Group Delay Equ.</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_polariq_ampm" pos="9" rst="0x0">
          <comment>AMPM of DPD</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_polariq" pos="7" rst="0x0">
          <comment>Whole DPD</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_rc" pos="6" rst="0x0">
          <comment>RC</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_gain" pos="5" rst="0x0">
          <comment>Gain</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_cfr" pos="3" rst="0x0">
          <comment>CFR</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_uphb1" pos="2" rst="0x0">
          <comment>UPHBF(1)</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_aclr_lpf" pos="1" rst="0x0">
          <comment>ACLR LPF</comment>
        </bits>
        <bits access="rw" name="txdp_bypass_mode_ampequ" pos="0" rst="0x0">
          <comment>ampequ</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="reserved_all_zeros_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rsv_all_zero" pos="15:0" rst="0x0">
          <comment>all zero bits, reserved for ECO</comment>
        </bits>
      </reg>
      <reg name="reserved_all_ones_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rsv_all_ones" pos="15:0" rst="0xffff">
          <comment>all one bits, reserved for ECO</comment>
        </bits>
      </reg>
      <reg name="pwr_rf_acc_len_reg" protect="rw">
        <comment/>
        <bits access="rw" name="pwr_rf_acc_len_rg" pos="15:0" rst="0x0">
          <comment>all one bits, reserved for ECO</comment>
        </bits>
      </reg>
      <reg name="pwr_rf_acc_misc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="pwr_adc_off_bin_en" pos="5" rst="0x0"/>
        <bits access="rw" name="pwr_rf_ushift_rg" pos="4:2" rst="0x0">
          <comment>pwr_rf_ushift_rg</comment>
        </bits>
        <bits access="rw" name="pwr_rf_start_rg" pos="1" rst="0x0">
          <comment>pwr_rf_start_rg</comment>
        </bits>
        <bits access="rw" name="pwr_rf_polar_rg" pos="0" rst="0x0">
          <comment>pwr_rf_polar_rg</comment>
        </bits>
      </reg>
      <reg name="pwr_rf_acc_report_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwr_rf_o" pos="11:1" rst="0x4c0"/>
        <bits access="r" name="pwr_rf_calc_done" pos="0" rst="0x0"/>
      </reg>
      <hole size="96"/>
      <reg name="txdp_clk_gate_enable_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_clkgate_en" pos="14" rst="0x0"/>
        <bits access="rw" name="txdp_aclr_clkgate_en" pos="13" rst="0x0"/>
        <bits access="rw" name="txdp_uphb1_clkgate_en" pos="12" rst="0x0"/>
        <bits access="rw" name="txdp_gain_clkgate_en" pos="9" rst="0x0"/>
        <bits access="rw" name="txdp_rc_clkgate_en" pos="8" rst="0x0"/>
        <bits access="rw" name="txdp_dpd_clkgate_en" pos="7" rst="0x0"/>
        <bits access="rw" name="txdp_gdeq_clkgate_en" pos="6" rst="0x0"/>
        <bits access="rw" name="txdp_uphb4_clkgate_en" pos="5" rst="0x0"/>
        <bits access="rw" name="txdp_uphb5_clkgate_en" pos="4" rst="0x0"/>
        <bits access="rw" name="txdp_loft_clkgate_en" pos="2" rst="0x0"/>
        <bits access="rw" name="txdp_sine_clkgate_en" pos="0" rst="0x0">
          <comment>1: clk always on, 0: clk gating by hardware</comment>
        </bits>
      </reg>
      <reg name="rxdp_clk_gate_enable_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_rc_clkgate_en" pos="0" rst="0x0">
          <comment>1: clk always on, 0: clk gating by hardware</comment>
        </bits>
      </reg>
      <reg name="rxdp_clk_gate_enable_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="rxdp_imbc_clkgate_en" pos="15" rst="0x0"/>
        <bits access="rw" name="rxdp_mixer_clkgate_en" pos="14" rst="0x0"/>
        <bits access="rw" name="rxdp_notch1_clkgate_en" pos="13" rst="0x0"/>
        <bits access="rw" name="rxdp_gdeq_clkgate_en" pos="12" rst="0x0"/>
        <bits access="rw" name="rxdp_ob_clkgate_en" pos="10" rst="0x0"/>
        <bits access="rw" name="rxdp_mrrm_clkgate_en" pos="9" rst="0x0"/>
        <bits access="rw" name="rxdp_dnhb1_clkgate_en" pos="8" rst="0x0"/>
        <bits access="rw" name="rxdp_aci_clkgate_en" pos="7" rst="0x0"/>
        <bits access="rw" name="rxdp_notch2_clkgate_en" pos="6" rst="0x0"/>
        <bits access="rw" name="rxdp_gainbb_clkgate_en" pos="5" rst="0x0"/>
        <bits access="rw" name="rxdp_dnhb2_clkgate_en" pos="4" rst="0x0"/>
        <bits access="rw" name="rxdp_ib_clkgate_en" pos="3" rst="0x0"/>
        <bits access="rw" name="rxdp_notch_gen_clkgate_en" pos="1" rst="0x0"/>
        <bits access="rw" name="rxdp_rssi3_clkgate_en" pos="0" rst="0x0">
          <comment>1: clk always on, 0: clk gating by hardware</comment>
        </bits>
      </reg>
      <reg name="test_dac_bits_sel_register" protect="rw">
        <comment/>
        <bits access="rw" name="test_dac_bits_sel" pos="2:0" rst="0x0">
          <comment>determine dac bits position when test mode.
0:[11:0],
1:[12:1],
2:[13:2],
3:[14:3],
4:[15:4]</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_coef0_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_coef0_rg" pos="11:0" rst="0x0">
          <comment>Bit [11:0] of coefficient 0 of ampequ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_coef1_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_coef1_rg" pos="11:0" rst="0x0">
          <comment>Bit [11:0] of coefficient 1 of ampequ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_coef2_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_coef2_rg" pos="11:0" rst="0x0">
          <comment>Bit [11:0] of coefficient 2 of ampequ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_coef3_rg_1" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_coef3_rg" pos="11:0" rst="0x0">
          <comment>Bit [11:0] of coefficient 3 of ampequ. for NB/LTE/eMTC TX</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_g" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_g_rg" pos="15:0" rst="0x0">
          <comment>Bit [27:12] of gain for ampequ.  for NB/LTE/eMTC TX, must  config for all tx, init value 0x400</comment>
        </bits>
      </reg>
      <reg name="txdp_ampequ_g_ext_reg" protect="rw">
        <comment/>
        <bits access="rw" name="txdp_ampequ_g_ext" pos="11:0" rst="0x0">
          <comment>Bit [11:0] of gain for ampequ. It works with register txdp_ampequ_g_rg</comment>
        </bits>
      </reg>
      <reg name="fifo_sample_rate_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="fifo_a_smp_rate_rg" pos="10:4" rst="0x3">
          <comment>read interval for FIFO A, new add change with different rx mode</comment>
        </bits>
        <bits access="rw" name="fifo_b_smp_rate_rg" pos="3:0" rst="0x3">
          <comment>read interval for FIFO B, new add change with different rx mode</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="fifo_status_reg" protect="rw">
        <comment/>
        <bits access="r" name="fifo_dump_full_status" pos="15" rst="0x0">
          <comment>FIFO dump full</comment>
        </bits>
        <bits access="r" name="fifo_dump_empty_status" pos="14" rst="0x1">
          <comment>FIFO dump empty</comment>
        </bits>
        <bits access="r" name="fifo_txdp_rc_full_status" pos="13" rst="0x0">
          <comment>FIFO txdp_rc full</comment>
        </bits>
        <bits access="r" name="fifo_txdp_rc_empty_status" pos="12" rst="0x1">
          <comment>FIFO txdp_rc empty</comment>
        </bits>
        <bits access="r" name="fifo_rxdp_rc_full_status" pos="11" rst="0x0">
          <comment>FIFO rxdp_rc full</comment>
        </bits>
        <bits access="r" name="fifo_rxdp_rc_empty_status" pos="10" rst="0x1">
          <comment>FIFO rxdp_rc empty</comment>
        </bits>
        <bits access="r" name="fifo_adc_full_status" pos="9" rst="0x0">
          <comment>FIFO ADC full</comment>
        </bits>
        <bits access="r" name="fifo_adc_empty_status" pos="8" rst="0x1">
          <comment>FIFO ADC empty, this FIFO used between ADC and DFE</comment>
        </bits>
        <bits access="r" name="fifo_b_full_status" pos="3" rst="0x0">
          <comment>FIFO B full</comment>
        </bits>
        <bits access="r" name="fifo_b_empty_status" pos="2" rst="0x1">
          <comment>FIFO B empty, this FIFO used when LVDS RX for adc-dfe-lvds-bb</comment>
        </bits>
        <bits access="r" name="fifo_a_full_status" pos="1" rst="0x0">
          <comment>FIFO A full</comment>
        </bits>
        <bits access="r" name="fifo_a_empty_status" pos="0" rst="0x1">
          <comment>FIFO A empty, this FIFO used when normal RX or LVDS TX for adc-dfe-lvds-bb</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="dfe_dump_reg" protect="rw">
        <comment/>
        <bits access="rw" name="sel_clk_dump_w" pos="11:8" rst="0x0">
          <comment>clock frequency select when dump FIFO write
0000: clk_122p88m_m
0001: clk_adc
001x: clk_245p76m
01xx: clk_245p76m_m
1xxx: clk_pwd</comment>
        </bits>
        <bits access="rw" name="dfe_dump_vld_sel" pos="5:4" rst="0x0">
          <comment>valid width select when dump
00: 1 cycle period (245.76M)
01: 2 cycle period (245.76M)
10: 3 cycle period (245.76M)
11: 4 cycle period (245.76M)</comment>
        </bits>
        <bits access="rw" name="dfe_dump_en" pos="3" rst="0x0">
          <comment>enable dump</comment>
        </bits>
        <bits access="rw" name="dfe_dump_resetn" pos="2" rst="0x0"/>
        <bits access="rw" name="dfe_dump_sel" pos="1:0" rst="0x0">
          <comment>dump node selection. It works with register sel_clk_dump_w for correct clock.
0: dump RX data from DFE, sel_clk_dump_w can be clk_122p88m_m/clk_61p44m_m/lvds2dfe_clk_dig_ref
1: dump TX data from BB, sel_clk_dump_w can be clk_122p88m_m/clk_61p44m_m/lvds2dfe_clk_dig_ref
2: dump RXDP data, sel_clk_dump_w can be clk_rxdp/clk_rxdp_m
3: dump TXDP data, sel_clk_dump_w can be clk_txdp/clk_245p76m_m(clk_txdp_m)/clk_pwd
others: dump data from LVDS, sel_clk_dump_w can be can be lvds2dfe_clk</comment>
        </bits>
      </reg>
      <reg name="aclr_coef8" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef08" pos="9:0" rst="0x0">
          <comment>Coefficient 8 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef9" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef09" pos="9:0" rst="0x0">
          <comment>Coefficient 9 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef10" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef10" pos="9:0" rst="0x0">
          <comment>Coefficient 10 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef11" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef11" pos="9:0" rst="0x0">
          <comment>Coefficient 11 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef12" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef12" pos="9:0" rst="0x0">
          <comment>Coefficient 12 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef13" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef13" pos="9:0" rst="0x0">
          <comment>Coefficient 13 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef14" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef14" pos="9:0" rst="0x0">
          <comment>Coefficient 14 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef15" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef15" pos="9:0" rst="0x0">
          <comment>Coefficient 15 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef16" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef16" pos="9:0" rst="0x0">
          <comment>Coefficient 16 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef17" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef17" pos="9:0" rst="0x0">
          <comment>Coefficient 17 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef18" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef18" pos="9:0" rst="0x0">
          <comment>Coefficient 18 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef19" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef19" pos="9:0" rst="0x0">
          <comment>Coefficient 19 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef20" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef20" pos="9:0" rst="0x0">
          <comment>Coefficient 20 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef21" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef21" pos="9:0" rst="0x0">
          <comment>Coefficient 21 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef22" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef22" pos="9:0" rst="0x0">
          <comment>Coefficient 22 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="aclr_coef23" protect="rw">
        <comment/>
        <bits access="rw" name="aclr_coef23" pos="9:0" rst="0x0">
          <comment>Coefficient 23 of ACLR filter, new add</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_dcc_load" pos="6" rst="0x0">
          <comment>Start to load DC value, active high. Before next load, set it low firstly</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_imgrej_rg" pos="5" rst="0x0">
          <comment>IQ swap in DC module
0: no swap
1. swap</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_hold_en_rg" pos="4" rst="0x0">
          <comment>Hold DC accumulator calculation in DC calibration mode</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_bypass_rg" pos="3" rst="0x0">
          <comment>This register is used.</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_dc_delta_ld_st_rg" pos="2" rst="0x0">
          <comment>Store initial value to DC accumulator at positive edge in DC cancel mode or DC calibration mode.</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_dc_calib_en_rg" pos="1" rst="0x0">
          <comment>Load DC value in calibration mode to debug port, only used for debug purpose</comment>
        </bits>
        <bits access="rw" name="pwd_dcc_rx_calib_sel_rg" pos="0" rst="0x0">
          <comment>DC module work mode.
0: DC calibration mode
1: DC cancel mode</comment>
        </bits>
      </reg>
      <reg name="pwd_dc_calib_re" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_dc_calib_re_rg" pos="9:0" rst="0x0">
          <comment>DC real part value used in cancel mode</comment>
        </bits>
      </reg>
      <reg name="pwd_dc_calib_im" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_dc_calib_im_rg" pos="9:0" rst="0x0">
          <comment>DC image part value used in cancel mode</comment>
        </bits>
      </reg>
      <reg name="pwd_dc_delta_re" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_dc_delta_re_rg" pos="9:0" rst="0x0">
          <comment>Accumulator initial real part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register</comment>
        </bits>
      </reg>
      <reg name="pwd_dc_delta_im" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_dc_delta_im_rg" pos="9:0" rst="0x0">
          <comment>Accumulator initial image part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register</comment>
        </bits>
      </reg>
      <reg name="pwd_dc_cr" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_conv_slow_bw_ct_rg" pos="11:9" rst="0x0">
          <comment>Slow convergence control, work with conv_mode_ct_rg register</comment>
        </bits>
        <bits access="rw" name="pwd_conv_fast_bw_ct_rg" pos="8:6" rst="0x0">
          <comment>Fast convergence control, work with conv_mode_ct_rg register</comment>
        </bits>
        <bits access="rw" name="pwd_conv_tmr_ct_rg" pos="5:2" rst="0x0">
          <comment>Duration time of DC calibration, which is based on sample unit</comment>
        </bits>
        <bits access="rw" name="pwd_conv_mode_ct_rg" pos="1:0" rst="0x0">
          <comment>DC convergence loop mode selection.
0: fast
1: slow
2: fast-&gt;slow
3: fast-&gt;hold</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc_valid_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwd_dcc_val_reg" pos="0" rst="0x0">
          <comment>Valid indication of DC value after assert rxdp_dcc_load to avoid metastability. rxdp_dcc_re_o and rxdp_dcc_im_o are stable when this register is high</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc_re_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwd_dcc_re_o" pos="9:0" rst="0x0">
          <comment>Real part of DC value, it is stable when pwd_dcc_val_reg is high</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc_im_o_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwd_dcc_im_o" pos="9:0" rst="0x0">
          <comment>Image part of DC value, it is stable when pwd_dcc_val_reg is high</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc_re_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwd_dcc_re_real" pos="9:0" rst="0x0">
          <comment>instant value of rxdp_dcc_re, new add for debug</comment>
        </bits>
      </reg>
      <reg name="pwd_dcc_im_real_reg" protect="rw">
        <comment/>
        <bits access="r" name="pwd_dcc_im_real" pos="9:0" rst="0x0">
          <comment>instant value of rxdp_dcc_im, new add for debug</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x50032000" name="RF_DFE" type="RF_DFE"/>
  </archive>
  <archive relative="rf_bitmap.xml">
    <module category="System" name="RF_BITMAP">
      <reg name="sysctrl1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_clk_cnt_sel" pos="11" rst="0x0">
          <comment>1:LTE BBPLL tuned 122.88M0untuned 26M</comment>
        </bits>
        <bits access="rw" name="rg_adj_cnt_122m88_ms_num_val_sel" pos="10" rst="0x0">
          <comment>122.88m01</comment>
        </bits>
        <bits access="rw" name="rg_adj_cnt_122m88_ms_num_enable" pos="9" rst="0x0">
          <comment>122.88m</comment>
        </bits>
        <bits access="rw" name="rg_adj_cnt_122m88_enable" pos="8" rst="0x0">
          <comment>122.88M counter</comment>
        </bits>
        <bits access="rw" name="rg_latch_cnt_122m88_enable" pos="7" rst="0x0">
          <comment>Latch 122.88m counter</comment>
        </bits>
        <bits access="rw" name="rg_gnss_latch_cnt_122m88_enable" pos="6" rst="0x0">
          <comment>GNSS RTC/CPU/EM Latch 122.88m counter</comment>
        </bits>
        <bits access="rw" name="rg_cnt_122m88_clr" pos="5" rst="0x0">
          <comment>Tuned 122.88M counter</comment>
        </bits>
        <bits access="rw" name="rg_cnt_122m88_enable" pos="4" rst="0x0">
          <comment>Tuned 122.88M counter</comment>
        </bits>
        <bits access="rw" name="rg_latch_wptr_enable" pos="3" rst="0x0">
          <comment>latch bitmap wptr</comment>
        </bits>
        <bits access="rw" name="rg_gnss_latch_wptr_enable" pos="2" rst="0x0">
          <comment>GNSS RTC/CPU/EM Latch bitmap wptr</comment>
        </bits>
        <bits access="rw" name="rg_bitmap_wptr_clr" pos="1" rst="0x0">
          <comment>bitmap0wptr</comment>
        </bits>
        <bits access="rw" name="rg_bitmap_enable" pos="0" rst="0x0">
          <comment>Bitmap</comment>
        </bits>
      </reg>
      <reg name="sysctrl2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_bitmap_cycle_index_num" pos="7:0" rst="0x7f">
          <comment>Bitmap0-1270-255,Bitmap</comment>
        </bits>
      </reg>
      <reg name="sysctrl3" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cnt_122m88_ms_num_l" pos="15:0" rst="0xdfff">
          <comment>122.88M1ms26M1ms0x658F</comment>
        </bits>
      </reg>
      <reg name="sysctrl4" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cnt_122m88_ms_num_h" pos="1:0" rst="0x1">
          <comment>122.88M1ms26M1ms0x0</comment>
        </bits>
      </reg>
      <reg name="sysctrl5" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cnt_122m88_adj_val_l" pos="15:0" rst="0x0">
          <comment>122.88M/26M counter</comment>
        </bits>
      </reg>
      <reg name="sysctrl6" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cnt_122m88_adj_val_m" pos="15:0" rst="0x0">
          <comment>122.88M/26M counter</comment>
        </bits>
      </reg>
      <reg name="sysctrl7" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cnt_122m88_adj_val_h" pos="15:0" rst="0x0">
          <comment>122.88M/26M counter</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="sysstat1" protect="rw">
        <comment/>
        <bits access="r" name="latch_cnt_122m88_value_l" pos="15:0">
          <comment>122.88M/26M counterGNSS RTC/CPU/EM LatchLatch48bit1701ms211810ms4822LTE Frame timer3</comment>
        </bits>
      </reg>
      <reg name="sysstat2" protect="rw">
        <comment/>
        <bits access="r" name="latch_cnt_122m88_value_m" pos="15:0">
          <comment>122.88M/26M counterGNSS RTC/CPU/EM LatchLatch48bit1701ms211810ms4822LTE Frame timer3</comment>
        </bits>
      </reg>
      <reg name="sysstat3" protect="rw">
        <comment/>
        <bits access="r" name="latch_cnt_122m88_value_h" pos="15:0">
          <comment>122.88M/26M counterGNSS RTC/CPU/EM LatchLatch48bit1701ms211810ms4822LTE Frame timer3</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="sysstat7" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_wptr" pos="7:0">
          <comment>Bitmap wptrlatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat8" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num0" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat9" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num1" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat10" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num2" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat11" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num3" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat12" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num4" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat13" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num5" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat14" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num6" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat15" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num7" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat16" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num8" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat17" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num9" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat18" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num10" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat19" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num11" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat20" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num12" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat21" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num13" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat22" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num14" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <reg name="sysstat23" protect="rw">
        <comment/>
        <bits access="r" name="latch_bitmap_cycle_index_num15" pos="15:0">
          <comment>Bitmaplatchvalid1</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="sysctrl11" protect="rw">
        <comment/>
        <bits access="rw" name="lte_gnss_mail_flag" pos="15:0" rst="0x0">
          <comment>LTE-GNSSbit</comment>
        </bits>
      </reg>
      <reg name="sysctrl12" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer0" pos="15:0" rst="0x0">
          <comment>Bitmap</comment>
        </bits>
      </reg>
      <reg name="sysctrl13" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer1" pos="15:0" rst="0x0">
          <comment>Bitmap</comment>
        </bits>
      </reg>
      <reg name="sysctrl14" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer2" pos="15:0" rst="0x0">
          <comment>Bitmap</comment>
        </bits>
      </reg>
      <reg name="sysctrl15" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer3" pos="15:0" rst="0x0">
          <comment>Bitmap</comment>
        </bits>
      </reg>
      <reg name="sysctrl16" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer4" pos="15:0" rst="0x0">
          <comment>Bitmap</comment>
        </bits>
      </reg>
      <reg name="sysctrl17" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer5" pos="15:0" rst="0x0">
          <comment>Bitmap</comment>
        </bits>
      </reg>
      <reg name="sysctrl18" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer6" pos="15:0" rst="0x0">
          <comment>Bitmap</comment>
        </bits>
      </reg>
      <reg name="sysctrl19" protect="rw">
        <comment/>
        <bits access="rw" name="lte_use_rf_timer7" pos="15:0" rst="0x0">
          <comment>Bitmap</comment>
        </bits>
      </reg>
      <hole size="6816"/>
      <reg name="sysctrl1_set" protect="rw"/>
      <hole size="1056"/>
      <reg name="sysctrl11_set" protect="rw"/>
      <reg name="sysctrl12_set" protect="rw"/>
      <reg name="sysctrl13_set" protect="rw"/>
      <reg name="sysctrl14_set" protect="rw"/>
      <reg name="sysctrl15_set" protect="rw"/>
      <reg name="sysctrl16_set" protect="rw"/>
      <reg name="sysctrl17_set" protect="rw"/>
      <reg name="sysctrl18_set" protect="rw"/>
      <reg name="sysctrl19_set" protect="rw"/>
      <hole size="6816"/>
      <reg name="sysctrl1_clr" protect="rw"/>
      <hole size="1056"/>
      <reg name="sysctrl11_clr" protect="rw"/>
      <reg name="sysctrl12_clr" protect="rw"/>
      <reg name="sysctrl13_clr" protect="rw"/>
      <reg name="sysctrl14_clr" protect="rw"/>
      <reg name="sysctrl15_clr" protect="rw"/>
      <reg name="sysctrl16_clr" protect="rw"/>
      <reg name="sysctrl17_clr" protect="rw"/>
      <reg name="sysctrl18_clr" protect="rw"/>
      <reg name="sysctrl19_clr" protect="rw"/>
    </module>
    <var name="REG_RF_BITMAP_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_BITMAP_CLR_OFFSET" value="0x800"/>
    <instance address="0x50036000" name="RF_BITMAP" type="RF_BITMAP"/>
  </archive>
  <archive relative="rf_ana.xml">
    <module category="System" name="RF_ANA">
      <reg name="bandgap_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="bg_cal_r_d_bb" pos="15:12" rst="0x7">
          <comment>bandgap trim</comment>
        </bits>
        <bits access="rw" name="ldo_levelshifter_out" pos="11:9" rst="0x2">
          <comment>ISM TXABB LDO output voltage selection
ISM TXABB  LDO output voltage control signal
000     0.84V                     100   0.96V
001     0.87V                     101   0.99V
010     0.9V                        110   1.02V
011     0.93V                     111    1.05V</comment>
        </bits>
        <bits access="rw" name="ldo_levelshifter_cp_tune" pos="8:7" rst="0x2">
          <comment>Top LevelShIft LDO ripple cancelling cap control signal to mitigate VDD variation effect conotrol VDD_input
00    1.8V
01    1.5V
10    1.2V
11    1.2V</comment>
        </bits>
      </reg>
      <reg name="ldo_pu_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="lna_ldo_en_in_bb" pos="15" rst="0x0">
          <comment>LNA ldo power up</comment>
        </bits>
        <bits access="rw" name="lna_ldo_fast_charge_en_bb" pos="14" rst="0x0">
          <comment>LNA ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="rxabb_ldo_en_bb" pos="13" rst="0x0">
          <comment>RX ABB ldo power up</comment>
        </bits>
        <bits access="rw" name="rxabb_ldo_fc_pulse_bb" pos="12" rst="0x0">
          <comment>RX ABB ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="adc_ldo_bias_en_bb" pos="11" rst="0x0">
          <comment>ADC LDO bias enable</comment>
        </bits>
        <bits access="rw" name="adc_ldo_en_bb" pos="10" rst="0x0">
          <comment>ADC LDO enable</comment>
        </bits>
        <bits access="rw" name="txflt_ldo_en_bb" pos="9" rst="0x0">
          <comment>TX filter ldo power up</comment>
        </bits>
        <bits access="rw" name="txflt_ldo_fc_pulse_bb" pos="8" rst="0x0">
          <comment>TX filter ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="dac_ldo_en_bb" pos="7" rst="0x0">
          <comment>DAC LDO enable</comment>
        </bits>
        <bits access="rw" name="dac_ldo_fc_pulse_bb" pos="6" rst="0x0">
          <comment>DAC LDO fast charge</comment>
        </bits>
        <bits access="rw" name="pwdadc_ldo_bias_en_bb" pos="5" rst="0x0">
          <comment>PWDADC LDO bias enable, only used in ditital domain</comment>
        </bits>
        <bits access="rw" name="pwdadc_ldo_en_bb" pos="4" rst="0x0">
          <comment>PWDADC LDO enable, only used in digital domain</comment>
        </bits>
      </reg>
      <reg name="ldo_pu_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_ldo_bias_en_bb" pos="15" rst="0x0">
          <comment>rxpll gro ldo bias en</comment>
        </bits>
        <bits access="rw" name="rxpll_gro_ldo_en_bb" pos="14" rst="0x0">
          <comment>rxpll gro ldo en</comment>
        </bits>
        <bits access="rw" name="rxpll_presc_ldo_en_bb" pos="13" rst="0x0">
          <comment>RXPLL presc ldo power up</comment>
        </bits>
        <bits access="rw" name="rxpll_presc_ldo_fast_charge_en_bb" pos="12" rst="0x0">
          <comment>RXPLL presc ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_dig_en_bb" pos="11" rst="0x0">
          <comment>RXPLL RDAC ldo digital power up</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_vref_en_bb" pos="10" rst="0x0">
          <comment>RXPLL RDAC ldo vref power up</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_vref_fc_en_bb" pos="9" rst="0x0">
          <comment>RXPLL RDAC ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="rxvco_ldo_en_bb" pos="8" rst="0x0">
          <comment>RX VCO ldo power up</comment>
        </bits>
        <bits access="rw" name="rxvco_ldo_fc_bb" pos="7" rst="0x0">
          <comment>RX VCO ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="rxvco_ldo_load_bb" pos="6" rst="0x0">
          <comment>RX VCO ldo load en</comment>
        </bits>
        <bits access="rw" name="rxvco_buf_ldo_en_bb" pos="5" rst="0x0">
          <comment>RX VCO buffer ldo power up</comment>
        </bits>
        <bits access="rw" name="rxvco_buf_ldo_fc_bb" pos="4" rst="0x0">
          <comment>RX VCO buffer ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="rxvco_buf_ldo_load_bb" pos="3" rst="0x0">
          <comment>RX VCO buffer ldo load en</comment>
        </bits>
        <bits access="rw" name="rxvco_tc_en_bb" pos="2" rst="0x0">
          <comment>RX VCO TC power up</comment>
        </bits>
        <bits access="rw" name="rxvco_tc_fc_bb" pos="1" rst="0x0">
          <comment>RX VCO TC fast charge en</comment>
        </bits>
      </reg>
      <reg name="ldo_pu_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_ldo_bias_en_bb" pos="15" rst="0x0">
          <comment>txpll gro ldo bias en</comment>
        </bits>
        <bits access="rw" name="txpll_gro_ldo_en_bb" pos="14" rst="0x0">
          <comment>txpll gro ldo en</comment>
        </bits>
        <bits access="rw" name="txpll_presc_ldo_en_bb" pos="13" rst="0x0">
          <comment>TXPLL presc ldo power up</comment>
        </bits>
        <bits access="rw" name="txpll_presc_ldo_fast_charge_en_bb" pos="12" rst="0x0">
          <comment>TXPLL presc ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_dig_en_bb" pos="11" rst="0x0">
          <comment>TXPLL RDAC ldo digital power up</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_vref_en_bb" pos="10" rst="0x0">
          <comment>TXPLL RDAC ldo vref power up</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_vref_fc_en_bb" pos="9" rst="0x0">
          <comment>TXPLL RDAC ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_en_bb" pos="8" rst="0x0">
          <comment>TX VCO ldo power up</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_fc_bb" pos="7" rst="0x0">
          <comment>TX VCO ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_load_bb" pos="6" rst="0x0">
          <comment>TX VCO ldo load en</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_en_bb" pos="5" rst="0x0">
          <comment>TX VCO buffer ldo power up</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_fc_bb" pos="4" rst="0x0">
          <comment>TX VCO buffer ldo fast charge en</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_load_bb" pos="3" rst="0x0">
          <comment>TX VCO buffer ldo load en</comment>
        </bits>
        <bits access="rw" name="txvco_tc_en_bb" pos="2" rst="0x0">
          <comment>TX VCO TC power up</comment>
        </bits>
        <bits access="rw" name="txvco_tc_fc_bb" pos="1" rst="0x0">
          <comment>TX VCO TC fast charge en</comment>
        </bits>
      </reg>
      <reg name="trx_pu_0" protect="rw">
        <comment/>
        <bits access="rw" name="pu_bg_bb" pos="15" rst="0x1">
          <comment>Pu of bandgap</comment>
        </bits>
        <bits access="rw" name="pu_mdll_bb" pos="14" rst="0x0">
          <comment>pu_mdll_bb</comment>
        </bits>
        <bits access="rw" name="mdll_startup_bb" pos="13" rst="0x0">
          <comment>mdll start up</comment>
        </bits>
        <bits access="rw" name="pu_xdrv_bb" pos="12" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
pu xdrv buffer</comment>
        </bits>
      </reg>
      <reg name="trx_pu_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_bias_en_bb" pos="15" rst="0x0">
          <comment>rxvco_bias_en</comment>
        </bits>
        <bits access="rw" name="rxvco_ibias_en_bb" pos="14" rst="0x0">
          <comment>rxvco_ibias_en</comment>
        </bits>
        <bits access="rw" name="rxvco_vcoh_sel_bb" pos="13" rst="0x0">
          <comment>rxvcoh pu</comment>
        </bits>
        <bits access="rw" name="rxvco_vcol_sel_bb" pos="12" rst="0x0">
          <comment>rxvcol pu</comment>
        </bits>
        <bits access="rw" name="rxvco_pkdet_en_bb" pos="11" rst="0x0">
          <comment>rxvco_pkdet enable</comment>
        </bits>
        <bits access="rw" name="pu_rxpll_presc_bb" pos="10" rst="0x0">
          <comment>pu_rxpll_presc_bb</comment>
        </bits>
        <bits access="rw" name="pu_rxpll_gro_bb" pos="9" rst="0x0">
          <comment>pu_rxpll_gro_bb</comment>
        </bits>
        <bits access="rw" name="pu_rxpll_rdac_bb" pos="8" rst="0x0">
          <comment>pu_rxpll_rdac_bb</comment>
        </bits>
        <bits access="rw" name="rxpll_gro_rstn_bb" pos="7" rst="0x0">
          <comment>rxpll_gro_rstn_bb</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_rstn_bb" pos="6" rst="0x0">
          <comment>rxpll_rdac reset</comment>
        </bits>
      </reg>
      <reg name="trx_pu_2" protect="rw">
        <comment/>
        <bits access="rw" name="pu_lna_bb" pos="15" rst="0x0">
          <comment>LNA power up</comment>
        </bits>
        <bits access="rw" name="lna_pkd_en_bb" pos="14" rst="0x0">
          <comment>lna peak detector enable</comment>
        </bits>
        <bits access="rw" name="pga_en_bb" pos="13" rst="0x0">
          <comment>RX PGA enable</comment>
        </bits>
        <bits access="rw" name="pga_pkd_en_bb" pos="12" rst="0x0">
          <comment>rx pga peak detector enable</comment>
        </bits>
        <bits access="rw" name="pu_pga_bb" pos="11" rst="0x0">
          <comment>RX PGA DCDC IDAC power up</comment>
        </bits>
        <bits access="rw" name="pu_rxflt_bb" pos="10" rst="0x0">
          <comment>RX filter DCDC IDAC power up</comment>
        </bits>
        <bits access="rw" name="rxflt_rstn_bb" pos="9" rst="0x0">
          <comment>RX filter OPA negative reset</comment>
        </bits>
        <bits access="rw" name="rxflt_en_bb" pos="8" rst="0x0">
          <comment>RX filter enable</comment>
        </bits>
        <bits access="rw" name="pu_rxmixer_bb" pos="7" rst="0x0">
          <comment>rx mixer power up</comment>
        </bits>
        <bits access="rw" name="pu_tia_bb" pos="6" rst="0x0">
          <comment>tia power up</comment>
        </bits>
        <bits access="rw" name="adc_bias_en_bb" pos="5" rst="0x0">
          <comment>ADC enable</comment>
        </bits>
        <bits access="rw" name="adc_ref_enh_bb" pos="4" rst="0x0">
          <comment>ADC enable</comment>
        </bits>
        <bits access="rw" name="adc_clk_enh_bb" pos="3" rst="0x0">
          <comment>ADC enable</comment>
        </bits>
        <bits access="rw" name="adc_enh_bb" pos="2" rst="0x0">
          <comment>ADC enable</comment>
        </bits>
        <bits access="rw" name="adc_rstn_bb" pos="1" rst="0x0">
          <comment>ADC reset negative</comment>
        </bits>
      </reg>
      <reg name="trx_pu_3" protect="rw">
        <comment/>
        <bits access="rw" name="txvco_bias_en_bb" pos="15" rst="0x0">
          <comment>txvco_bias_en</comment>
        </bits>
        <bits access="rw" name="txvco_ibias_en_bb" pos="14" rst="0x0">
          <comment>txvco_ibias_en</comment>
        </bits>
        <bits access="rw" name="txvco_vcoh_sel_bb" pos="13" rst="0x0">
          <comment>txvcoh pu</comment>
        </bits>
        <bits access="rw" name="txvco_vcol_sel_bb" pos="12" rst="0x0">
          <comment>txvcol pu</comment>
        </bits>
        <bits access="rw" name="txvco_pkdet_en_bb" pos="11" rst="0x0">
          <comment>peak detector enable</comment>
        </bits>
        <bits access="rw" name="pu_txpll_presc_bb" pos="10" rst="0x0">
          <comment>pu_txpll_presc_bb</comment>
        </bits>
        <bits access="rw" name="pu_txpll_gro_bb" pos="9" rst="0x0"/>
        <bits access="rw" name="pu_txpll_rdac_bb" pos="8" rst="0x0">
          <comment>txpll RDAC power up</comment>
        </bits>
        <bits access="rw" name="txpll_gro_rstn_bb" pos="7" rst="0x0">
          <comment>txpll_gro_rstn_bb</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_rstn_bb" pos="6" rst="0x0">
          <comment>txpll RDAC reset</comment>
        </bits>
      </reg>
      <reg name="trx_pu_4" protect="rw">
        <comment/>
        <bits access="rw" name="txflt_rstn_bb" pos="15" rst="0x0">
          <comment>TX filter reset negative</comment>
        </bits>
        <bits access="rw" name="pu_dac_bb" pos="14" rst="0x0">
          <comment>DAC power up control</comment>
        </bits>
        <bits access="rw" name="dac_rstn_bb" pos="13" rst="0x0">
          <comment>DAC reset negative</comment>
        </bits>
        <bits access="rw" name="txmixer_en_bb" pos="12" rst="0x0">
          <comment>TX mixer work on enable</comment>
        </bits>
        <bits access="rw" name="pu_txflt_bb" pos="11" rst="0x0">
          <comment>TX filter power up control</comment>
        </bits>
        <bits access="rw" name="pu_txrf_bb" pos="10" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
txrf power on conrol</comment>
        </bits>
        <bits access="rw" name="txpad_en_bb" pos="9" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
TX PA driver work on enable</comment>
        </bits>
        <bits access="rw" name="pu_pwd_bb" pos="8" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
power detector power up</comment>
        </bits>
        <bits access="rw" name="pwdadc_rstn_bb" pos="7" rst="0x0">
          <comment>PWDADC reset negative</comment>
        </bits>
        <bits access="rw" name="pu_pwd_pga_bb" pos="6" rst="0x0">
          <comment>PWD PGA power up</comment>
        </bits>
        <bits access="rw" name="pwdadc_bias_en_bb" pos="5" rst="0x0">
          <comment>PWDADC enable</comment>
        </bits>
        <bits access="rw" name="pwdadc_ref_enh_bb" pos="4" rst="0x0">
          <comment>PWDADC enable</comment>
        </bits>
        <bits access="rw" name="pwdadc_clk_enh_bb" pos="3" rst="0x0">
          <comment>PWDADC enable</comment>
        </bits>
        <bits access="rw" name="pwdadc_enh_bb" pos="2" rst="0x0">
          <comment>PWDADC enable</comment>
        </bits>
        <bits access="rw" name="pwd_rstn_bb" pos="1" rst="0x0">
          <comment>PWD reset negative</comment>
        </bits>
      </reg>
      <reg name="trx_pu_5" protect="rw">
        <comment/>
        <bits access="rw" name="pu_dly_pwd_bb" pos="14" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
power detector power up delay</comment>
        </bits>
        <bits access="rw" name="pu_dly_txflt_bb" pos="13" rst="0x0">
          <comment>TX filter power up delay</comment>
        </bits>
        <bits access="rw" name="pu_dly_txrf_bb" pos="12" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
txrf power on conrol delay</comment>
        </bits>
      </reg>
      <reg name="mdll_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="mdll_div_bit_bb" pos="15:12" rst="0x7">
          <comment>Frequency division ratio of loop,
5~10.</comment>
        </bits>
        <bits access="rw" name="mdll_dither_en_bb" pos="11" rst="0x0">
          <comment>Dither control enable</comment>
        </bits>
        <bits access="rw" name="mdll_band_bit_bb" pos="10:8" rst="0x4">
          <comment>mdll_band_bit_bb</comment>
        </bits>
        <bits access="rw" name="mdll_band_sel_bb" pos="7" rst="0x1">
          <comment>mdll_band_sel_bb</comment>
        </bits>
        <bits access="rw" name="mdll_dither_bit_bb" pos="6:4" rst="0x4">
          <comment>Dither control bit</comment>
        </bits>
        <bits access="rw" name="mdll_cp_ibit_bb" pos="3:1" rst="0x1">
          <comment>mdll_cp_ibit_bb</comment>
        </bits>
        <bits access="rw" name="mdll_dither_mode_bb" pos="0" rst="0x0">
          <comment>Dither control mode selection</comment>
        </bits>
      </reg>
      <reg name="mdll_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="mdll_regu_vcosel_bb" pos="15:13" rst="0x4">
          <comment>Reset voltage control</comment>
        </bits>
        <bits access="rw" name="mdll_clk_divn_bb" pos="12:11" rst="0x0">
          <comment>Frequency division 1/2/4 of clock output buffer
01 /1; 10 /2; 11 /4;</comment>
        </bits>
        <bits access="rw" name="mdll_refclk_test_en_bb" pos="10" rst="0x0">
          <comment>mdll_refclk_test_en_bb</comment>
        </bits>
        <bits access="rw" name="mdll_vctrl_test_en_bb" pos="9" rst="0x0">
          <comment>mdll_vctrl_test_en_bb</comment>
        </bits>
        <bits access="rw" name="disable_refclk_rxpll_bb" pos="8" rst="0x0">
          <comment>disable_refclk_rxpll_bb</comment>
        </bits>
        <bits access="rw" name="disable_refclk_txpll_bb" pos="7" rst="0x0">
          <comment>disable_refclk_txpll_bb</comment>
        </bits>
      </reg>
      <reg name="xtal_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="xtal_iptat_en_bb" pos="1" rst="0x0">
          <comment>ptat current enable, for tsenadc.
TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="xtal26m_refpll_crf_en_bb" pos="0" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
      </reg>
      <reg name="rxvco_ldo_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_ldo_vcomode_sel_bb" pos="15" rst="0x1"/>
        <bits access="rw" name="rxvco_ldo_powermode_sel_bb" pos="14" rst="0x0"/>
        <bits access="rw" name="rxvco_ldo_short_en_bb" pos="13" rst="0x0"/>
        <bits access="rw" name="rxvco_ldo_out_bb" pos="12:10" rst="0x5"/>
        <bits access="rw" name="rxvco_ldo_trim_bb" pos="9:6" rst="0x7"/>
      </reg>
      <reg name="rxvco_buf_ldo_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_buf_ldo_vcomode_sel_bb" pos="15" rst="0x1"/>
        <bits access="rw" name="rxvco_buf_ldo_powermode_sel_bb" pos="14" rst="0x0"/>
        <bits access="rw" name="rxvco_buf_ldo_short_en_bb" pos="13" rst="0x0"/>
        <bits access="rw" name="rxvco_buf_ldo_out_bb" pos="12:10" rst="0x5"/>
        <bits access="rw" name="rxvco_buf_ldo_trim_bb" pos="9:6" rst="0x7"/>
      </reg>
      <reg name="rxvco_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_bias_extra_bb" pos="15" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_bias_sel_bb" pos="14" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_ktc_ctat_bb" pos="13:11" rst="0x3"/>
        <bits access="rw" name="rxvco_ktc_ptat_bb" pos="10:8" rst="0x3"/>
        <bits access="rw" name="rxvco_var_short_bb" pos="7" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_varbias_rcsel_bb" pos="6:5" rst="0x3"/>
        <bits access="rw" name="rxvco_varbias_vbsel_ctat_bb" pos="4:3" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_varbias_vbsel_ptat_bb" pos="2:1" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_var_reverse_bb" pos="0" rst="0x0">
          <comment>varactor bias reverse seleted</comment>
        </bits>
      </reg>
      <reg name="rxvco_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_varcom_bb" pos="15:13" rst="0x4"/>
        <bits access="rw" name="rxvco_vardif_bb" pos="12:10" rst="0x4"/>
        <bits access="rw" name="rxvco_pkd_pdt_bb" pos="9:7" rst="0x2"/>
        <bits access="rw" name="rxvco_pkd_ref_bb" pos="6:4" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_pkd_ref_ctrl_bb" pos="3" rst="0x0">
          <comment>tbd</comment>
        </bits>
      </reg>
      <reg name="rxvco_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxvco_cm_sca_ctrl_bb" pos="15:12" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="rxvco_lcl_div1_bb" pos="11" rst="0x0">
          <comment>rxvco_lcl_div1</comment>
        </bits>
        <bits access="rw" name="rxvco_lcl_div2_bb" pos="10" rst="0x0">
          <comment>rxvco_lcl_div2</comment>
        </bits>
        <bits access="rw" name="rxvco_lte_en_bb" pos="9" rst="0x0">
          <comment>rxvco lte en</comment>
        </bits>
      </reg>
      <reg name="rxpll_ldo_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_presc_ldo_ref_trim_bb" pos="15:12" rst="0x7">
          <comment>FBDIV LDO VREF TRIM750mV</comment>
        </bits>
        <bits access="rw" name="rxpll_presc_ldo_out_bb" pos="11:9" rst="0x5">
          <comment>FBDIV LDO VOUT950mV</comment>
        </bits>
        <bits access="rw" name="rxpll_presc_ldo_cripple_bb" pos="8:7" rst="0x2">
          <comment>FBDIV LDO1.2V VDD2</comment>
        </bits>
        <bits access="rw" name="rxpll_gro_ldo_in_trim_bb" pos="6:3" rst="0x7">
          <comment>GRO Master LDO VREF TRIM750mV</comment>
        </bits>
        <bits access="rw" name="rxpll_gro_ldo_out_trim_bb" pos="2:1" rst="0x0">
          <comment>GRO Master LDO VOUT950mV</comment>
        </bits>
      </reg>
      <reg name="rxpll_ldo_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_ldo_cp_trim_bb" pos="15:13" rst="0x3">
          <comment>GRO Master LDO CP TRIM</comment>
        </bits>
        <bits access="rw" name="rxpll_gro_ldo_res_adjust_bb" pos="12:11" rst="0x2">
          <comment>GRO Master Slave LDO VDDRES</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_dig_ref_trim_bb" pos="10:7" rst="0x7">
          <comment>RDAC DIG LDO VREF TRIM,750mV</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_dig_out_bb" pos="6:4" rst="0x5">
          <comment>RDAC DIG LDO VOUT,950mV</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_dig_cripple_bb" pos="3:2" rst="0x2">
          <comment>RDAC DIG LDO , 1.2V VDD2</comment>
        </bits>
      </reg>
      <reg name="rxpll_ldo_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_rdac_ldo_vref_ref_trim_bb" pos="15:12" rst="0x7">
          <comment>RDAC VREF LDO VREF TRIM,750mV</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_vref_out_bb" pos="11:8" rst="0x5">
          <comment>RDAC VREF LDO VOUT,880mV</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_ldo_vref_cripple_bb" pos="7:6" rst="0x2">
          <comment>RDAC VREF LDO , 1.2V VDD2</comment>
        </bits>
        <bits access="rw" name="rxpll_fbdiv_vddres_bb" pos="5:3" rst="0x4">
          <comment>FBDIV VDDRES</comment>
        </bits>
      </reg>
      <reg name="rxpll_gro_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_reg0_bb" pos="15:0" rst="0x0">
          <comment>&lt;3&gt; mdllslave ldonmosmdll&lt;41mdll&gt;=40
&lt;4&gt; rxpll_gro_ldo_in_trim_en</comment>
        </bits>
      </reg>
      <reg name="rxpll_gro_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_reg1_bb" pos="15:0" rst="0x2aa3">
          <comment>[15]mod23_enb [14]mod3_dly_more [13:4]clk_sample &amp; clk_dig dly [3:2]pfd [1:0]gro mode</comment>
        </bits>
      </reg>
      <reg name="rxpll_gro_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_reg2_bb" pos="15:0" rst="0x4">
          <comment>[1:0]clk_en for tdc cal
[2]gro mode3dn_en=0up_en</comment>
        </bits>
      </reg>
      <reg name="rxpll_gro_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_gro_reg3_bb" pos="15:0" rst="0x0">
          <comment>reserved</comment>
        </bits>
      </reg>
      <reg name="rxpll_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxpll_rdac_vlow_selb_bb" pos="15:13" rst="0x0">
          <comment>vlow sel, 0~1/3vh, 1~1/5vh 3~1/9vh 7~0</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_clk_edgesel_bb" pos="12" rst="0x0">
          <comment>rdac clk edge sel</comment>
        </bits>
        <bits access="rw" name="rxpll_fbcsel_bit_bb" pos="11:9" rst="0x0">
          <comment>rxpll_fbdiv sdm clk &amp; ndiv load dly,0~dly more</comment>
        </bits>
        <bits access="rw" name="rxpll_sdmclk_sel_bb" pos="8" rst="0x0">
          <comment>rxpll_sdmclk_sel_bb</comment>
        </bits>
        <bits access="rw" name="rxpll_open_en_bb" pos="7" rst="0x0">
          <comment>RXPLL open loop enable</comment>
        </bits>
        <bits access="rw" name="rxpll_rdac_rcflt_r_bb" pos="6:4" rst="0x0">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="lna_sel_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="en_lna_wifi_bb" pos="15" rst="0x0">
          <comment>LNA wifi selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_h1_bb" pos="14" rst="0x0">
          <comment>LNA lte hb 1 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_h2_bb" pos="13" rst="0x0">
          <comment>LNA lte hb 2 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_m1_bb" pos="12" rst="0x0">
          <comment>LNA lte mb 1 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_m2_bb" pos="11" rst="0x0">
          <comment>LNA lte mb 2 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_m3_bb" pos="10" rst="0x0">
          <comment>LNA lte mb 3 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_m4_bb" pos="9" rst="0x0">
          <comment>LNA lte mb 4 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_m5_bb" pos="8" rst="0x0">
          <comment>LNA lte mb 5 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_gnss_bb" pos="7" rst="0x0">
          <comment>LNA lte gnss selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_l1_bb" pos="6" rst="0x0">
          <comment>LNA lte lb 1 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_l2_bb" pos="5" rst="0x0">
          <comment>LNA lte lb 2 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_l3_bb" pos="4" rst="0x0">
          <comment>LNA lte lb 3 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_l4_bb" pos="3" rst="0x0">
          <comment>LNA lte lb 4 selection</comment>
        </bits>
        <bits access="rw" name="en_lna_lte_l5_bb" pos="2" rst="0x0">
          <comment>LNA lte lb 5 selection</comment>
        </bits>
        <bits access="rw" name="rxmixer_vco_sel5g_bb" pos="1" rst="0x0">
          <comment>rxmixer LO signal selection, high for 5g VCO, low for 4g VCO;</comment>
        </bits>
        <bits access="rw" name="rxmixer_vco_selrx_bb" pos="0" rst="0x0">
          <comment>rxmixer LO signal selection, high for rx VCO, low for tx VCO;</comment>
        </bits>
      </reg>
      <reg name="lna_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="lna_power_res_bit_bb" pos="15:13" rst="0x7">
          <comment>lna_power_res_control</comment>
        </bits>
        <bits access="rw" name="lna_ldo_bypass_bb" pos="12" rst="0x0">
          <comment>LNA LDO bypass, work at 1.2V</comment>
        </bits>
        <bits access="rw" name="lna_ldo_cp_tune_bb" pos="11:10" rst="0x2">
          <comment>LNA LDO ripple cancelling cap control signal to mitigate VDD variation effect conotrol</comment>
        </bits>
        <bits access="rw" name="lna_ldo_out_bb" pos="9:7" rst="0x4">
          <comment>LNA LDO output voltage control signal 000 0.825V; 001 0.85V; 010 0.875; V011 0.9V; 100 0.925V; 101 0.95V; 110 0.975V; 111 1.0V;</comment>
        </bits>
        <bits access="rw" name="lna_gain0_bit_bb" pos="6" rst="0x1">
          <comment>lna gain0, not used</comment>
        </bits>
        <bits access="rw" name="lna_resf_en_bb" pos="3" rst="0x1">
          <comment>LNA Feedback resistor enable</comment>
        </bits>
      </reg>
      <reg name="lna_pkd_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="lna_pkd_pdt_bb" pos="15:13" rst="0x4">
          <comment>LNA peak detector threshold level control signa</comment>
        </bits>
        <bits access="rw" name="lna_pkd_ref_1_bb" pos="12:10" rst="0x3">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="lna_pkd_ref_2_bb" pos="9:7" rst="0x3">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="lna_pkd_ref_ctrl_bb" pos="6" rst="0x0">
          <comment>LNA peak detector threshold level control signal.</comment>
        </bits>
        <bits access="rw" name="lna_in_capbank_bb" pos="5:3" rst="0x4">
          <comment>LNA input matching capbank tune</comment>
        </bits>
      </reg>
      <reg name="rxmixer_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="rxmixer_lodc_h_bb" pos="15" rst="0x0">
          <comment>Lo dc level high mode</comment>
        </bits>
        <bits access="rw" name="rxmixer_lodc_lte_bit_bb" pos="14:13" rst="0x2">
          <comment>Lo dc level for lte mode</comment>
        </bits>
        <bits access="rw" name="tia_rin_bit_bb" pos="12:11" rst="0x1">
          <comment>Rin of tia. 00 for 50ohm, 11 for 250ohm</comment>
        </bits>
        <bits access="rw" name="tia_bypass_bb" pos="10" rst="0x0">
          <comment>Tia bypass mode</comment>
        </bits>
        <bits access="rw" name="lna_h2_capbank_bb" pos="9:7" rst="0x4">
          <comment>LNA mixer matching capbank tune high band2</comment>
        </bits>
        <bits access="rw" name="lna_m3_capbank_bb" pos="6:4" rst="0x4">
          <comment>LNA mixer matching capbank tune middle band3</comment>
        </bits>
      </reg>
      <reg name="pga_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxabb_ldo_out_bb" pos="15:13" rst="0x5">
          <comment>RX ABB LDO output voltage control signal 000 0.825V; 001 0.85V; 010 0.875; V011 0.9V; 100 0.925V; 101 0.95V; 110 0.975V; 111 1.0V;</comment>
        </bits>
        <bits access="rw" name="rxabb_ldo_cp_tun_bb" pos="12:11" rst="0x2">
          <comment>RX ABB LDO ripple cancelling cap control signal to mitigate VDD variation effect conotrol</comment>
        </bits>
        <bits access="rw" name="pga_i_bit_bb" pos="10:9" rst="0x1">
          <comment>Current of pga. 00 for 1.2mA, 11 for 3.5mA, 01 and 10 for 1.8mA.</comment>
        </bits>
        <bits access="rw" name="pga_rs_bit_bb" pos="8:4" rst="0x2">
          <comment>Rs control, 1st pole and 2nd pole control, only valid when pga_blk_mode=1</comment>
        </bits>
        <bits access="rw" name="pga_op_millercc_bit_bb" pos="3:2" rst="0x3">
          <comment>00 for 100f01 and 10 for 200f11 for 300f</comment>
        </bits>
        <bits access="rw" name="pga_op_millercn_bit_bb" pos="1:0" rst="0x3">
          <comment>00 is invalid01 and 10 for 150fF11 for 300fF.</comment>
        </bits>
      </reg>
      <reg name="pga_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="pga_bw_mode_bb" pos="15:13" rst="0x5">
          <comment>Bw control, 000 for 700KHz, 101 for 10MHz</comment>
        </bits>
        <bits access="rw" name="pga_cf_bit_bb" pos="12:8" rst="0xe">
          <comment>Cf control, 1st pole control, only valid when pga_blk_mode=1</comment>
        </bits>
        <bits access="rw" name="pga_blk_mode_bb" pos="7" rst="0x0">
          <comment>Gsm blokcer mode enable or test model for external control the capacitor and resistor in pga</comment>
        </bits>
        <bits access="rw" name="pga_rpre_bit_bb" pos="6:5" rst="0x3">
          <comment>Rpre control, blk fliter bw control, only valid when pga_blk_mode=1</comment>
        </bits>
        <bits access="rw" name="pga_c2nd_bit_bb" pos="4:3" rst="0x3">
          <comment>2nd pole control, only valid when pga_blk_mode=1</comment>
        </bits>
        <bits access="rw" name="pga_bw_tune_bit_bb" pos="2:0" rst="0x3">
          <comment>Bw tune. 000 for 0.8*bw, 111 for 1.5*bw.</comment>
        </bits>
      </reg>
      <reg name="pga_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="pga_ctun_bit_bb" pos="15:7" rst="0x82">
          <comment>tuning512*40fF</comment>
        </bits>
        <bits access="rw" name="pga_pkd_ref1_bb" pos="6:4" rst="0x4">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="pga_pkd_ref2_bb" pos="3:1" rst="0x3">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="pga_pkd_ref_ctrl_bb" pos="0" rst="0x0">
          <comment>LNA peak detector threshold level control signal.</comment>
        </bits>
      </reg>
      <reg name="pga_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="pga_pkd_rctime_sel_bb" pos="15:14" rst="0x0">
          <comment>time for charge and discharge</comment>
        </bits>
        <bits access="rw" name="pga_pkd_ibias_sel_bb" pos="13:12" rst="0x0">
          <comment>bias current of the pkd op</comment>
        </bits>
        <bits access="rw" name="rxabb_ldo_trim_bb" pos="11:8" rst="0x7">
          <comment>ldo vout ctrl word</comment>
        </bits>
        <bits access="rw" name="pga_cm_con_bb" pos="7:5" rst="0x3">
          <comment>pga op vocm ctrl word</comment>
        </bits>
      </reg>
      <reg name="rxabb_dccal_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rx_dccal_i_bit_bb" pos="15:8" rst="0x80">
          <comment>Dc offset calibration</comment>
        </bits>
        <bits access="rw" name="rx_dccal_q_bit_bb" pos="7:0" rst="0x80">
          <comment>Dc offset calibration</comment>
        </bits>
      </reg>
      <reg name="rxabb_dccal_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rx_dccal_range_bit_bb" pos="15:14" rst="0x2">
          <comment>Dc offset calibration range</comment>
        </bits>
      </reg>
      <reg name="rxflt_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rxflt_aux_en_bb" pos="15" rst="0x0">
          <comment>aux input for filter enable</comment>
        </bits>
        <bits access="rw" name="rxflt_bwmode_bit_bb" pos="14:12" rst="0x5">
          <comment>bandwith selection</comment>
        </bits>
        <bits access="rw" name="rxflt_bwtun_bit_bb" pos="11:8" rst="0x6">
          <comment>bandwith tuning</comment>
        </bits>
        <bits access="rw" name="rxflt_if_swap_bb" pos="7" rst="0x0">
          <comment>IQ swap, not use</comment>
        </bits>
        <bits access="rw" name="rxflt_if_en_bb" pos="6" rst="0x0">
          <comment>bandpass mode enable, set 0</comment>
        </bits>
        <bits access="rw" name="rxflt_if_freq_bit_bb" pos="5:3" rst="0x0">
          <comment>center frequency selection (not use)</comment>
        </bits>
      </reg>
      <reg name="rxflt_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="anti_kick_back_filter_bw_bb" pos="15:14" rst="0x1">
          <comment>anti_kick_back_filter_bw_control</comment>
        </bits>
        <bits access="rw" name="rxflt_op_millercc_bit_bb" pos="13:12" rst="0x3">
          <comment>00 for 100f01 and 10 for 200f11 for 300f</comment>
        </bits>
        <bits access="rw" name="rxflt_op_millercn_bit_bb" pos="11:10" rst="0x3">
          <comment>00 is invalid01 and 10 for 150fF11 for 300fF.</comment>
        </bits>
        <bits access="rw" name="rxflt_i_bit_bb" pos="9:8" rst="0x1">
          <comment>RX filter bias current select</comment>
        </bits>
      </reg>
      <reg name="rxflt_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="rxflt_bwtun_c1_bb" pos="15:8" rst="0x0">
          <comment> and tuning</comment>
        </bits>
        <bits access="rw" name="rxflt_bwtun_c2_bb" pos="7:1" rst="0x0">
          <comment> and tuning</comment>
        </bits>
      </reg>
      <reg name="adc_ldo_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="adc_ldo_cp_trim_bb" pos="15:13" rst="0x3">
          <comment>ADC LDO for charge pump output voltage control signal</comment>
        </bits>
        <bits access="rw" name="adc_ldo_in_trim_bb" pos="12:9" rst="0x7">
          <comment>ADC LDO input voltage control signal</comment>
        </bits>
        <bits access="rw" name="adc_ldo_out_trim_bb" pos="8:7" rst="0x1">
          <comment>ADC LDO output voltage control signal</comment>
        </bits>
      </reg>
      <reg name="adc_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="adc_clk_rst_ctrl_bb" pos="15:14" rst="0x1">
          <comment>Rst time control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="adc_clk_vin_delay_ctrl_bb" pos="13:12" rst="0x1">
          <comment>Signal in delay control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="adc_clkout_polarity_bb" pos="11" rst="0x0">
          <comment>CLOCK OUT polarity,0:rising edge,1:falling edge</comment>
        </bits>
        <bits access="rw" name="adc_en_latch_adjust_bb" pos="10:9" rst="0x1">
          <comment>Compare time control</comment>
        </bits>
        <bits access="rw" name="adc_loop_delay_ctrl_bb" pos="8:5" rst="0x4">
          <comment>Loop delay time control</comment>
        </bits>
        <bits access="rw" name="adc_msb_delay_ctrl_bb" pos="4:3" rst="0x1">
          <comment>MSB compare time control</comment>
        </bits>
        <bits access="rw" name="adc_ns_charge_set_time_ctrl_bb" pos="2:1" rst="0x1">
          <comment>Noise shaping charge set time control</comment>
        </bits>
        <bits access="rw" name="adc_ns_enh_bb" pos="0" rst="0x0">
          <comment>Noise shaping enable</comment>
        </bits>
      </reg>
      <reg name="adc_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="adc_os_code_q_bb" pos="14:10" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_code_0p5_q_bb" pos="9" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_code_0p25_q_bb" pos="8" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_code_i_bb" pos="6:2" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_code_0p5_i_bb" pos="1" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_code_0p25_i_bb" pos="0" rst="0x0">
          <comment>Offset control</comment>
        </bits>
      </reg>
      <reg name="adc_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="adc_ns_vcm_ctrl_bb" pos="15:13" rst="0x0">
          <comment>Ns common mode voltage control</comment>
        </bits>
        <bits access="rw" name="adc_os_cap_flow_i_bb" pos="12" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_os_cap_flow_q_bb" pos="11" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="adc_res_adjust_bb" pos="10:9" rst="0x1"/>
        <bits access="rw" name="adc_residual_comp_en_bb" pos="8" rst="0x0">
          <comment>Residual compare enable</comment>
        </bits>
        <bits access="rw" name="adc_samp_hold_ctrl_bb" pos="7:6" rst="0x0">
          <comment>Sample clock delay control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="adc_stb_ctrl_bb" pos="5:3" rst="0x0">
          <comment>STB control</comment>
        </bits>
        <bits access="rw" name="adc_input_os_vcm_ctrl_bb" pos="2:0" rst="0x0">
          <comment>ADC vcm calibration</comment>
        </bits>
      </reg>
      <reg name="adc_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="adc_vcm_ctrl_bb" pos="15:13" rst="0x0">
          <comment>common mode voltage control</comment>
        </bits>
        <bits access="rw" name="adc_vrp_ctrl_bb" pos="12:9" rst="0x0">
          <comment>Vrp reference voltage control</comment>
        </bits>
        <bits access="rw" name="adc_vrp_i_ctrl_bb" pos="8:5" rst="0x6">
          <comment>Vrp control</comment>
        </bits>
        <bits access="rw" name="adc_clk_sel_bb" pos="4:3" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="adc_ns_slap_ctrl_bb" pos="1" rst="0x1">
          <comment>Ns slap control</comment>
        </bits>
        <bits access="rw" name="adc_input_short_bb" pos="0" rst="0x0">
          <comment>ADC input short for calibration</comment>
        </bits>
      </reg>
      <reg name="adc_rsv_0" protect="rw">
        <comment/>
      </reg>
      <reg name="pwdadc_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="pwdadc_clk_rst_ctrl_bb" pos="15:14" rst="0x1">
          <comment>Rst time control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="pwdadc_clk_vin_delay_ctrl_bb" pos="13:12" rst="0x1">
          <comment>Signal in delay control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="pwdadc_clkout_polarity_bb" pos="11" rst="0x0">
          <comment>CLOCK OUT polarity,0:rising edge,1:falling edge</comment>
        </bits>
        <bits access="rw" name="pwdadc_en_latch_adjust_bb" pos="10:9" rst="0x1">
          <comment>Compare time control</comment>
        </bits>
        <bits access="rw" name="pwdadc_loop_delay_ctrl_bb" pos="8:5" rst="0x4">
          <comment>Loop delay time control</comment>
        </bits>
        <bits access="rw" name="pwdadc_msb_delay_ctrl_bb" pos="4:3" rst="0x1">
          <comment>MSB compare time control</comment>
        </bits>
        <bits access="rw" name="pwdadc_ns_charge_set_time_ctrl_bb" pos="2:1" rst="0x1">
          <comment>Noise shaping charge set time control</comment>
        </bits>
        <bits access="rw" name="pwdadc_ns_enh_bb" pos="0" rst="0x0">
          <comment>Noise shaping enable</comment>
        </bits>
      </reg>
      <reg name="pwdadc_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="pwdadc_ns_slap_ctrl_bb" pos="15" rst="0x1">
          <comment>Ns slap control</comment>
        </bits>
        <bits access="rw" name="pwdadc_ns_vcm_ctrl_bb" pos="14:12" rst="0x0">
          <comment>Ns common mode voltage control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_cap_flow_i_bb" pos="11" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_cap_flow_q_bb" pos="10" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_code_0p5_i_bb" pos="9" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_code_0p5_q_bb" pos="8" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_code_0p25_i_bb" pos="7" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_code_0p25_q_bb" pos="6" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_os_code_i_bb" pos="5:1" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_input_short_bb" pos="0" rst="0x0">
          <comment>PWDADC input short for calibration</comment>
        </bits>
      </reg>
      <reg name="pwdadc_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="pwdadc_os_code_q_bb" pos="15:11" rst="0x0">
          <comment>Offset control</comment>
        </bits>
        <bits access="rw" name="pwdadc_res_adjust_bb" pos="10:9" rst="0x1"/>
        <bits access="rw" name="pwdadc_residual_comp_en_bb" pos="8" rst="0x0">
          <comment>Residual compare enable</comment>
        </bits>
        <bits access="rw" name="pwdadc_samp_hold_ctrl_bb" pos="7:6" rst="0x0">
          <comment>Sample clock delay control, 00:0*inv, 01:2*inv, 10:4*inv, 11:6*inv</comment>
        </bits>
        <bits access="rw" name="pwdadc_stb_ctrl_bb" pos="5:3" rst="0x0">
          <comment>STB control</comment>
        </bits>
        <bits access="rw" name="pwdadc_clk_sel_bb" pos="2:1" rst="0x1">
          <comment>PWDADC clk selection</comment>
        </bits>
      </reg>
      <reg name="pwdadc_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="pwdadc_vcm_ctrl_bb" pos="15:13" rst="0x0">
          <comment>common mode voltage control</comment>
        </bits>
        <bits access="rw" name="pwdadc_vrp_ctrl_bb" pos="12:9" rst="0x0">
          <comment>Vrp reference voltage control</comment>
        </bits>
        <bits access="rw" name="pwdadc_vrp_i_ctrl_bb" pos="8:5" rst="0x6">
          <comment>Vrp control</comment>
        </bits>
        <bits access="rw" name="pwdadc_input_os_vcm_ctrl_bb" pos="4:2" rst="0x0">
          <comment>PWDADC vcm calibration</comment>
        </bits>
      </reg>
      <reg name="rx_gain_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="lna_gain_bb" pos="15:14" rst="0x3">
          <comment>lna gain control</comment>
        </bits>
        <bits access="rw" name="lna_bias_bb" pos="13:12" rst="0x2">
          <comment>lna bias control</comment>
        </bits>
        <bits access="rw" name="lna_vbc_bit_bb" pos="11:9" rst="0x2">
          <comment>LNA common gate bias select.</comment>
        </bits>
        <bits access="rw" name="pga_gain_bit_bb" pos="8:7" rst="0x3">
          <comment>Pga gain control, 11 for 4k Rf, 00 for 0.5k Rf.</comment>
        </bits>
        <bits access="rw" name="rxflt_gain_bit_bb" pos="6:3" rst="0xb">
          <comment>filter gain selection</comment>
        </bits>
        <bits access="rw" name="lna_resf_bit_bb" pos="2:0" rst="0x0">
          <comment>Rf of lna for impendance matching</comment>
        </bits>
      </reg>
      <reg name="rx_reserve1" protect="rw">
        <comment/>
        <bits access="rw" name="rx_reserve1_bb" pos="15:0" rst="0x0">
          <comment>[4] rxflt_bypass
[3:2] pga_dcoc_ictrl_bit&lt;1:0&gt;
[1:0] flt_dcoc_ictrl_bit&lt;1:0&gt;</comment>
        </bits>
      </reg>
      <reg name="rx_reserve2" protect="rw">
        <comment/>
        <bits access="rw" name="rx_reserve2_bb" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rx_reserve3" protect="rw">
        <comment/>
        <bits access="rw" name="rx_reserve3_bb" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txvco_ldo_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="txvco_ldo_vcomode_sel_bb" pos="15" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_powermode_sel_bb" pos="14" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_short_en_bb" pos="13" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_out_bb" pos="12:10" rst="0x5">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvco_ldo_trim_bb" pos="9:6" rst="0x7">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="txvco_buf_ldo_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="txvcobuf_ldo_vcomode_sel_bb" pos="15" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_powermode_sel_bb" pos="14" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_short_en_bb" pos="13" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_out_bb" pos="12:10" rst="0x5">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txvcobuf_ldo_trim_bb" pos="9:6" rst="0x7">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="txvco_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="txvco_bias_extra_bb" pos="15" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_bias_sel_bb" pos="14" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_ktc_ctat_bb" pos="13:11" rst="0x4"/>
        <bits access="rw" name="txvco_ktc_ptat_bb" pos="10:8" rst="0x4"/>
        <bits access="rw" name="txvco_var_short_bb" pos="7" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_varbias_rcsel_bb" pos="6:5" rst="0x3"/>
        <bits access="rw" name="txvco_varbias_vbsel_ctat_bb" pos="4:3" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_varbias_vbsel_ptat_bb" pos="2:1" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_var_reverse_bb" pos="0" rst="0x0">
          <comment>varactor bias reverse seleted</comment>
        </bits>
      </reg>
      <reg name="txvco_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="txvco_varcom_bb" pos="15:13" rst="0x4"/>
        <bits access="rw" name="txvco_vardif_bb" pos="12:10" rst="0x4"/>
        <bits access="rw" name="txvco_pkd_pdt_bb" pos="9:7" rst="0x2"/>
        <bits access="rw" name="txvco_pkd_ref_bb" pos="6:4" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_pkd_ref_ctrl_bb" pos="3" rst="0x0">
          <comment>tbd</comment>
        </bits>
      </reg>
      <reg name="txvco_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="txvco_cm_sca_ctrl_bb" pos="15:12" rst="0x0">
          <comment>tbd</comment>
        </bits>
        <bits access="rw" name="txvco_lcl_div1_bb" pos="11" rst="0x0">
          <comment>txvco_lcl_div1</comment>
        </bits>
        <bits access="rw" name="txvco_lcl_div2_bb" pos="10" rst="0x0">
          <comment>txvco_lcl_div2</comment>
        </bits>
        <bits access="rw" name="txvco_tx_en_bb" pos="8" rst="0x0">
          <comment>txvco_tx_en_bb</comment>
        </bits>
        <bits access="rw" name="txvco_rxlte_en_bb" pos="7" rst="0x0">
          <comment>txvco_rxlte_en_bb</comment>
        </bits>
        <bits access="rw" name="txvco_gnss_en_bb" pos="6" rst="0x0">
          <comment>txvco_gnss_en_bb</comment>
        </bits>
        <bits access="rw" name="txvco_rx_div1_en_bb" pos="5" rst="0x0">
          <comment>txvco_rx_div1_en_bb</comment>
        </bits>
        <bits access="rw" name="txrfdiv_div2_en_bb" pos="4" rst="0x0">
          <comment>txrfdiv_div2_en_bb</comment>
        </bits>
        <bits access="rw" name="txrfdiv_div4_en_bb" pos="3" rst="0x0">
          <comment>txrfdiv_div4_en_bb</comment>
        </bits>
        <bits access="rw" name="txrfdiv_lte_en_bb" pos="2" rst="0x0">
          <comment>txrfdiv_lte_en_bb</comment>
        </bits>
        <bits access="rw" name="txrfdiv_pwd_en_bb" pos="1" rst="0x0">
          <comment>txrfdiv_pwd_en_bb</comment>
        </bits>
      </reg>
      <reg name="txpll_ldo_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_presc_ldo_ref_trim_bb" pos="15:12" rst="0x7">
          <comment>FBDIV LDO VREF TRIM750mV</comment>
        </bits>
        <bits access="rw" name="txpll_presc_ldo_out_bb" pos="11:9" rst="0x5">
          <comment>FBDIV LDO VOUT950mV</comment>
        </bits>
        <bits access="rw" name="txpll_presc_ldo_cripple_bb" pos="8:7" rst="0x2">
          <comment>FBDIV LDO1.2V VDD2</comment>
        </bits>
        <bits access="rw" name="txpll_gro_ldo_in_trim_bb" pos="6:3" rst="0x7">
          <comment>GRO Master LDO VREF TRIM750mV</comment>
        </bits>
        <bits access="rw" name="txpll_gro_ldo_out_trim_bb" pos="2:1" rst="0x0">
          <comment>GRO Master LDO VOUT950mV</comment>
        </bits>
      </reg>
      <reg name="txpll_ldo_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_ldo_cp_trim_bb" pos="15:13" rst="0x3">
          <comment>GRO Master LDO CP TRIM</comment>
        </bits>
        <bits access="rw" name="txpll_gro_ldo_res_adjust_bb" pos="12:11" rst="0x2">
          <comment>GRO Master Slave LDO VDDRES</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_dig_ref_trim_bb" pos="10:7" rst="0x7">
          <comment>RDAC DIG LDO VREF TRIM,750mV</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_dig_out_bb" pos="6:4" rst="0x5">
          <comment>RDAC DIG LDO VOUT,950mV</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_dig_cripple_bb" pos="3:2" rst="0x2">
          <comment>RDAC DIG LDO , 1.2V VDD2</comment>
        </bits>
      </reg>
      <reg name="txpll_ldo_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_rdac_ldo_vref_ref_trim_bb" pos="15:12" rst="0x7">
          <comment>RDAC VREF LDO VREF TRIM,750mV</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_vref_out_bb" pos="11:8" rst="0x5">
          <comment>RDAC VREF LDO VOUT,880mV</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_ldo_vref_cripple_bb" pos="7:6" rst="0x2">
          <comment>RDAC VREF LDO , 1.2V VDD2</comment>
        </bits>
        <bits access="rw" name="txpll_fbdiv_vddres_bb" pos="5:3" rst="0x4">
          <comment>FBDIV VDDRES</comment>
        </bits>
      </reg>
      <reg name="txpll_gro_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_reg0_bb" pos="15:0" rst="0x0">
          <comment>&lt;3&gt; mdllslave ldonmosmdll&lt;41mdll&gt;=40
&lt;4&gt; txpll_gro_ldo_in_trim_en</comment>
        </bits>
      </reg>
      <reg name="txpll_gro_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_reg1_bb" pos="15:0" rst="0x2aa3">
          <comment>[15]mod23_enb [14]mod3_dly_more [13:4]clk_sample &amp; clk_dig dly [3:2]pfd [1:0]gro mode</comment>
        </bits>
      </reg>
      <reg name="txpll_gro_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_reg2_bb" pos="15:0" rst="0x4">
          <comment>[1:0]clk_en for tdc cal
[2]gro mode3dn_en=0up_en</comment>
        </bits>
      </reg>
      <reg name="txpll_gro_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_gro_reg3_bb" pos="15:0" rst="0x0">
          <comment>reserved</comment>
        </bits>
      </reg>
      <reg name="txpll_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="txpll_rdac_vlow_selb_bb" pos="15:13" rst="0x0">
          <comment>vlow sel, 0~1/3vh, 1~1/5vh 3~1/9vh 7~0</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_clk_edgesel_bb" pos="12" rst="0x0">
          <comment>rdac clk edge sel</comment>
        </bits>
        <bits access="rw" name="txpll_fbcsel_bit_bb" pos="11:9" rst="0x0">
          <comment>rxpll_fbdiv sdm clk &amp; ndiv load dly,0~dly more</comment>
        </bits>
        <bits access="rw" name="txpll_sdmclk_sel_bb" pos="8" rst="0x0">
          <comment>rxpll_sdmclk_sel_bb</comment>
        </bits>
        <bits access="rw" name="txpll_open_en_bb" pos="7" rst="0x0">
          <comment>RXPLL open loop enable</comment>
        </bits>
        <bits access="rw" name="txpll_rdac_rcflt_r_bb" pos="6:4" rst="0x0">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="txrf_gain" protect="rw">
        <comment/>
        <bits access="rw" name="txrf_ph45_en_bb" pos="15" rst="0x1">
          <comment>45 degree slice enable</comment>
        </bits>
        <bits access="rw" name="txflt_ph45_en_bb" pos="14" rst="0x1">
          <comment>45 degree signal output enable</comment>
        </bits>
        <bits access="rw" name="txrf_gain1_bit_bb" pos="13:9" rst="0x1e">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
driver and mixer slice control</comment>
        </bits>
        <bits access="rw" name="txrf_gain2_bit_bb" pos="8:4" rst="0x1f">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
driver gain setting</comment>
        </bits>
        <bits access="rw" name="txrf_gain3_bit_bb" pos="3:1" rst="0x5">
          <comment>mixer input rc filter attenuation</comment>
        </bits>
      </reg>
      <reg name="txrf_gain_compensation" protect="rw">
        <comment/>
        <bits access="rw" name="txrf_gain2c_bit_bb" pos="15:12" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
0 deg driver gain compensation setting</comment>
        </bits>
        <bits access="rw" name="txrf_gain2c_p45_bit_bb" pos="11:8" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
+45 deg driver gain compensation setting</comment>
        </bits>
        <bits access="rw" name="txrf_gain2c_n45_bit_bb" pos="7:4" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
-45 deg driver gain compensation setting</comment>
        </bits>
        <bits access="rw" name="txpad_bias_ibit_bb" pos="3:1" rst="0x3">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
pad gm current bias tuning</comment>
        </bits>
      </reg>
      <reg name="txrf_gain_adj" protect="rw">
        <comment/>
        <bits access="rw" name="txpad_aux_vbit_bb" pos="15:14" rst="0x1">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
pad mgtr voltage bias tuning</comment>
        </bits>
        <bits access="rw" name="txpad_cas_vbit_bb" pos="13:12" rst="0x1">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
pad cascade voltage bias tuning</comment>
        </bits>
        <bits access="rw" name="txrf_sw_sel1_bb" pos="11" rst="0x1">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
output switch size control</comment>
        </bits>
        <bits access="rw" name="txrf_sw_sel2_bb" pos="10" rst="0x1">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
output switch size control</comment>
        </bits>
        <bits access="rw" name="txrf_en_bbload_bb" pos="9" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
45 degree load banlance for filter</comment>
        </bits>
        <bits access="rw" name="txrf_bandbalance_bit_bb" pos="8:7" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
attenuation before mixer for band difference</comment>
        </bits>
        <bits access="rw" name="txrf_hb1_en_bb" pos="6" rst="0x1">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
high band branch1 enable</comment>
        </bits>
        <bits access="rw" name="txrf_hb2_en_bb" pos="5" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
high band branch2 enable</comment>
        </bits>
        <bits access="rw" name="txrf_lb1_en_bb" pos="4" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
low band branch1 enable</comment>
        </bits>
        <bits access="rw" name="txrf_lb2_en_bb" pos="3" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
low band branch2 enable</comment>
        </bits>
      </reg>
      <reg name="txrf_matchcap" protect="rw">
        <comment/>
        <bits access="rw" name="txpad_cap_bit_bb" pos="15:12" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
frequence selection for different band.</comment>
        </bits>
        <bits access="rw" name="txpad_cap_ulb_bit_bb" pos="11:10" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
frequence selection for different band. Ulb</comment>
        </bits>
        <bits access="rw" name="txpad_deq_bit_bb" pos="9:8" rst="0x0">
          <comment>driver banlun deQ tuning</comment>
        </bits>
        <bits access="rw" name="txrf_rcflt_rbit_bb" pos="7:6" rst="0x2"/>
        <bits access="rw" name="txrf_mix_r2r_cbit_bb" pos="5" rst="0x0"/>
      </reg>
      <reg name="txflt_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="txflt_ldo_out_bb" pos="15:13" rst="0x4">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txflt_ldo_cp_tune_bb" pos="12:11" rst="0x2">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="tx_dccal_en_bb" pos="10" rst="0x0">
          <comment>caplatch enable</comment>
        </bits>
        <bits access="rw" name="tx_dccal_clk_edgesel_bb" pos="9" rst="0x0">
          <comment>cal_clk edge selection</comment>
        </bits>
        <bits access="rw" name="txflt_cc_bb" pos="8:7" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txflt_cn_bb" pos="6:5" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="txflt_ibias_bit_bb" pos="4:3" rst="0x2">
          <comment>ibias current control</comment>
        </bits>
        <bits access="rw" name="txflt_vcm_ref_bb" pos="2:0" rst="0x3">
          <comment>TX filter output CM ctrl</comment>
        </bits>
      </reg>
      <reg name="txflt_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="txflt_hp_bit_bb" pos="15:14" rst="0x0">
          <comment>input high pass freq. control</comment>
        </bits>
        <bits access="rw" name="txflt_testin_en_bb" pos="13" rst="0x0">
          <comment>test mode enable</comment>
        </bits>
        <bits access="rw" name="txflt_bw_bit_bb" pos="12:10" rst="0x5">
          <comment>filter bandwidth control</comment>
        </bits>
        <bits access="rw" name="txflt_bwtun_bit_bb" pos="9:2" rst="0x41">
          <comment>filter bandwidth tuning control</comment>
        </bits>
        <bits access="rw" name="txflt_buffer_ibit_bb" pos="1:0" rst="0x2">
          <comment>TX filter output buffer current control</comment>
        </bits>
      </reg>
      <reg name="dac_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="dac_range_bit_bb" pos="15:14" rst="0x2">
          <comment>Vp_diff 00/01300mv;10600mv;11750mv</comment>
        </bits>
        <bits access="rw" name="dac_auxout_en_bb" pos="13" rst="0x0">
          <comment>dac_auxout_en_bb</comment>
        </bits>
        <bits access="rw" name="dac_iout_en_bb" pos="12" rst="0x0">
          <comment>dac_iout_en_bb</comment>
        </bits>
        <bits access="rw" name="dac_muxen_bit_bb" pos="11:10" rst="0x1">
          <comment>bit[0]:en for tx
bit[1]:en for test</comment>
        </bits>
        <bits access="rw" name="dac_clkedge_sel_bb" pos="9" rst="0x1">
          <comment>0: negative;1: positive</comment>
        </bits>
        <bits access="rw" name="dac_vhigh_bit_bb" pos="8:6" rst="0x5">
          <comment>vhigh control, 000:600mv, 001:644mv, 010:692mv, 011:738mv, 100:788mv, 101:835mv, 110:882mv, 111:930mv;</comment>
        </bits>
        <bits access="rw" name="dac_core_bit_bb" pos="5:3" rst="0x4">
          <comment>dac_core_bit_bb</comment>
        </bits>
      </reg>
      <reg name="dac_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="dac_tia_cmi_bit_bb" pos="11:10" rst="0x2">
          <comment>tia input common mode voltage, 00:450mv, 01:550mv, 10:650mv, 11:750mv</comment>
        </bits>
        <bits access="rw" name="dac_tia_cmo_bit_bb" pos="9:8" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="dac_tia_opamp_fbcap_bit_bb" pos="7:6" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="dac_ldo_cp_tune_bb" pos="5:4" rst="0x2">
          <comment>LDO</comment>
        </bits>
        <bits access="rw" name="dac_ldo_out_bb" pos="3:1" rst="0x4">
          <comment>LDO out voltage control</comment>
        </bits>
      </reg>
      <reg name="gnss_clkgen_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_bufsel_bb" pos="15:14" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_div_bb" pos="13:9" rst="0x6">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_vres_bb" pos="8:6" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_bufsel_bb" pos="5:4" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_div_bb" pos="3:0" rst="0x4">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="gnss_clkgen_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_clkgen_m4_clk_vres_bb" pos="15:13" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_bufsel_bb" pos="12:11" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_div_bb" pos="10:6" rst="0x6">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_vres_bb" pos="5:3" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_tsx_adc_clk_bufsel_bb" pos="2:1" rst="0x1">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="gnss_clkgen_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_clkgen_tsx_adc_clk_div_bb" pos="15:12" rst="0x8">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_tsx_adc_clk_vres_bb" pos="11:9" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_ana_adc_clk_bufsel_bb" pos="8:7" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_ana_adc_clk_div_bb" pos="6:0" rst="0x7">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="gnss_clkgen_ctrl_3" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_clkgen_ana_adc_clk_vres_bb" pos="15:13" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_mux_bb" pos="12:11" rst="0x2">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_mux_bb" pos="10:9" rst="0x2">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_div_frac_en_bb" pos="8" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_frac_divf_bb" pos="7:5" rst="0x1">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_frac_divn_bb" pos="4:2" rst="0x4">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_frac_sel_bb" pos="1" rst="0x0">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="gnss_clkgen_ctrl_4" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_div_en_bb" pos="15" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_adc_clk_out_en_bb" pos="14" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_div_en_bb" pos="13" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_m4_clk_en_bb" pos="12" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_div_en_bb" pos="11" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_pp_clk_en_bb" pos="10" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_tsx_adc_clk_div_en_bb" pos="9" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_tsx_adc_clk_en_bb" pos="8" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_ana_adc_clk_div_en_bb" pos="7" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="gnss_clkgen_ana_adc_clk_en_bb" pos="6" rst="0x0">
          <comment>TBD</comment>
        </bits>
      </reg>
      <reg name="rxflt_dccal" protect="rw">
        <comment/>
        <bits access="rw" name="rxflt_dccal_i_bit_bb" pos="15:8" rst="0x80">
          <comment>Dc offset calibration rxflt input</comment>
        </bits>
        <bits access="rw" name="rxflt_dccal_q_bit_bb" pos="7:0" rst="0x80">
          <comment>Dc offset calibration rxflt input</comment>
        </bits>
      </reg>
      <reg name="tx_reserve_0" protect="rw">
        <comment/>
        <bits access="rw" name="lte_tx_rsv_09_h_bb" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="tx_reserve_1" protect="rw">
        <comment/>
        <bits access="rw" name="lte_tx_rsv_09_l_bb" pos="15:8" rst="0x2">
          <comment>[0] LTE_TX_VCO_DIV_BUF_EN
[1] LTE_TX_VCO_RX_DIV1_EN</comment>
        </bits>
        <bits access="rw" name="lte_tx_rsv_18_bb" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="pwd_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_pga_res_bit_bb" pos="15:12" rst="0x0"/>
        <bits access="rw" name="pwd_mgain_bit_bb" pos="11:9" rst="0x0">
          <comment>to AVDDRF_18 &amp; AVSS_CLK
power detector mixer gain selection</comment>
        </bits>
        <bits access="rw" name="pwd_pga_ldo_res_adj_bb" pos="8:7" rst="0x1"/>
        <bits access="rw" name="pwd_pga_cn_bit_bb" pos="6:5" rst="0x3"/>
        <bits access="rw" name="pwd_pga_cc_bit_bb" pos="4:3" rst="0x3"/>
      </reg>
      <reg name="pwd_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_pga_cap_bit_bb" pos="15:12" rst="0x7"/>
      </reg>
      <reg name="pwd_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="pwd_cal_i_bb" pos="15:10" rst="0x20">
          <comment>Pwd pga dc offset calibration</comment>
        </bits>
        <bits access="rw" name="pwd_cal_i_done_bb" pos="9" rst="0x1">
          <comment>pwd_cal_i_done_bb</comment>
        </bits>
        <bits access="rw" name="pwd_cal_i_en_bb" pos="8" rst="0x0">
          <comment>Pwd pga dc offset calibration enable</comment>
        </bits>
        <bits access="rw" name="pwd_cal_q_bb" pos="7:2" rst="0x20">
          <comment>Pwd pga dc offset calibration</comment>
        </bits>
        <bits access="rw" name="pwd_cal_q_done_bb" pos="1" rst="0x1">
          <comment>pwd_cal_q_done_bb</comment>
        </bits>
        <bits access="rw" name="pwd_cal_q_en_bb" pos="0" rst="0x0">
          <comment>Pwd pga dc offset calibration enable</comment>
        </bits>
      </reg>
      <reg name="ts_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="ts_ldo_en_bb" pos="15" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO enable</comment>
        </bits>
        <bits access="rw" name="ts_ldo_fast_charge_en_bb" pos="14" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO fast charge</comment>
        </bits>
        <bits access="rw" name="pu_ts_bb" pos="13" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
TS power up</comment>
        </bits>
        <bits access="rw" name="ts_pwdint_en_bb" pos="12" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Voltage measurement mode</comment>
        </bits>
        <bits access="rw" name="ts_pwdext_en_bb" pos="11" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Voltage measurement mode</comment>
        </bits>
        <bits access="rw" name="ts_xtaltest_en_bb" pos="10" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Voltage measurement mode</comment>
        </bits>
        <bits access="rw" name="ts_chopper_en_bb" pos="9" rst="0x1">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Chopper enable</comment>
        </bits>
        <bits access="rw" name="ts_div_bit_bb" pos="8:5" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Chopper clock select</comment>
        </bits>
        <bits access="rw" name="ts_refsel_bit_bb" pos="4:3" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC reference selection</comment>
        </bits>
        <bits access="rw" name="ts_adc_ibit_bb" pos="2:0" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
The SDMADC bias current. 000 is 2uA.</comment>
        </bits>
      </reg>
      <reg name="ts_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="ts_vbe_bit_bb" pos="15:8" rst="0x20">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
VBE control, which is used to calibrate the non-linearity of temperature sensor.</comment>
        </bits>
        <bits access="rw" name="ts_resetn_bb" pos="7" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Reset</comment>
        </bits>
        <bits access="rw" name="ts_testmode_en_bb" pos="6" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
TS Test mode power up</comment>
        </bits>
        <bits access="rw" name="ts_vbe_sdmbit_bb" pos="5" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
VBE non linearity calibration using another SDMADC</comment>
        </bits>
        <bits access="rw" name="ts_beta_en_bb" pos="4" rst="0x1">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Biploar core beta dependance calibration</comment>
        </bits>
        <bits access="rw" name="ts_clksel_bit_bb" pos="3:2" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC CLK select. 00 1/8 MCLK; 01 1/4 MCLK; 10 1/2 MCLK; 11 MCLK</comment>
        </bits>
        <bits access="rw" name="ts_clk_edgesel_bb" pos="1" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Clk edge selected for MCLK</comment>
        </bits>
        <bits access="rw" name="ts_clk_divedge_sel_bb" pos="0" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
Clk edge selected for internal MCLK divider.</comment>
        </bits>
      </reg>
      <reg name="ts_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="ts_ldo_cp_tune_bb" pos="15:14" rst="0x1">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO psr improved</comment>
        </bits>
        <bits access="rw" name="ts_ldo_out_bb" pos="13:11" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO output voltage seltect for 1.5V</comment>
        </bits>
      </reg>
      <reg name="cm_reserve1" protect="rw">
        <comment/>
        <bits access="rw" name="cm_reserve1_bb" pos="15:0" rst="0x0">
          <comment>[0] additional control bit for pwd_pga_cap_bit
[1] ISO signal for clk26m_lp_uart, 0 for isolation, vcore_top domain</comment>
        </bits>
      </reg>
      <reg name="cm_reserve2" protect="rw">
        <comment/>
        <bits access="rw" name="cm_reserve2_bb" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="cm_reserve3" protect="rw">
        <comment/>
        <bits access="rw" name="cm_reserve3_bb" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="revid_reg" protect="rw">
        <comment/>
        <bits access="r" name="revid" pos="7:0" rst="0x0">
          <comment>revid</comment>
        </bits>
      </reg>
      <reg name="test_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="tx_if_en_bb" pos="15" rst="0x0">
          <comment>TX IF test interface open enable</comment>
        </bits>
        <bits access="rw" name="dac_out_en_bb" pos="14" rst="0x0">
          <comment>DAC out test interface open enable</comment>
        </bits>
        <bits access="rw" name="pll_test_en_bb" pos="13" rst="0x0">
          <comment>CLK of PLL test enable</comment>
        </bits>
        <bits access="rw" name="test_mdll_vctrl_sw_en_bb" pos="12" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_ldoref_adc_sw_en_bb" pos="11" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_clk_mdll_sw_en_bb" pos="10" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_bg_cal_r_en_bb" pos="9" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK
Band gap iref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_txvco_sw_en_bb" pos="8" rst="0x0">
          <comment>TX VCO ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_txvcobuf_sw_en_bb" pos="7" rst="0x0">
          <comment>TX VCOBUF ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_rxabb_sw_en_bb" pos="6" rst="0x0">
          <comment>RX ABB ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_rxvco_sw_en_bb" pos="5" rst="0x0">
          <comment>RX VCO ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_rxvcobuf_sw_en_bb" pos="4" rst="0x0">
          <comment>RX VCOBUF ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_txvco_en_bb" pos="3" rst="0x0">
          <comment>txvco_test_en</comment>
        </bits>
        <bits access="rw" name="rx_5g_test_en_bb" pos="2" rst="0x0">
          <comment>rx_5g_test_en</comment>
        </bits>
        <bits access="rw" name="rx_4g_test_en_bb" pos="1" rst="0x0">
          <comment>rx_4g_test_en</comment>
        </bits>
        <bits access="rw" name="rx_lo_test_en_bb" pos="0" rst="0x0">
          <comment>rx_lo_test_en</comment>
        </bits>
      </reg>
      <reg name="test_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="test_clk_ts_sw_en_bb" pos="15" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_vl_ts_sw_en_bb" pos="14" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_vr_ts_sw_en_bb" pos="13" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_vref_ts_sw_en_bb" pos="12" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_vpa_ts_sw_en_bb" pos="11" rst="0x0">
          <comment>to VDDIO &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="test_ldoref_rxpll_rdac_sw_en_bb" pos="10" rst="0x0">
          <comment>RX PLL RDAC ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_ldoref_txpll_rdac_sw_en_bb" pos="9" rst="0x0">
          <comment>TX PLL RDAC ldo vref test switch enable</comment>
        </bits>
        <bits access="rw" name="test_iq_adcinput_sw_en_bb" pos="8" rst="0x0">
          <comment>ADC INPUT TEST EN</comment>
        </bits>
        <bits access="rw" name="cal_rxiq_div2_en_bb" pos="7" rst="0x0">
          <comment>rxiq calibration signal divide by 2 enable</comment>
        </bits>
        <bits access="rw" name="cal_rxiq_div4_en_bb" pos="6" rst="0x0">
          <comment>rxiq calibration signal divide by 4 enable</comment>
        </bits>
        <bits access="rw" name="cal_rxiq_att_ctrl_bb" pos="5:1" rst="0x8">
          <comment>rxiq calibration signal ATT CTRL</comment>
        </bits>
      </reg>
      <reg name="cal_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="cal_txiq_sel_bb" pos="15" rst="0x0">
          <comment>0:cal sig from padrv; 1: cal sig from ext pa;</comment>
        </bits>
        <bits access="rw" name="cal_txiq_en_bb" pos="14" rst="0x0"/>
        <bits access="rw" name="cal_rxiq_mix_sel_bb" pos="13" rst="0x0"/>
        <bits access="rw" name="cal_rxiq_en_bb" pos="12" rst="0x0"/>
        <bits access="rw" name="txpad_att_ctl_bb" pos="11:10" rst="0x0"/>
        <bits access="rw" name="tx_ed_ibp_bb" pos="9:7" rst="0x2">
          <comment>ed ptat current source adjust</comment>
        </bits>
        <bits access="rw" name="tx_ed_ibg_bb" pos="6:4" rst="0x2">
          <comment>ed bg current source adjust</comment>
        </bits>
        <bits access="rw" name="cal_rxiq_att_adj_bb" pos="3:0" rst="0x4">
          <comment>rxiq calibration signal ATT adjust</comment>
        </bits>
      </reg>
      <reg name="rf_output_readonly_0" protect="rw">
        <comment/>
        <bits access="r" name="tx_dccal_outi_bb" pos="15" rst="0x0">
          <comment>from AVDDRF_12_RF &amp; AVSS_RF
TX dc cal output I</comment>
        </bits>
        <bits access="r" name="tx_dccal_outq_bb" pos="14" rst="0x0">
          <comment>from AVDDRF_12_RF &amp; AVSS_RF
TX dc cal output Q</comment>
        </bits>
        <bits access="r" name="lna_pkd_out_1_bb" pos="13" rst="0x0">
          <comment>from AVDDRF_12_LNA &amp; AVSS_LNA
LNA peak detector output signal</comment>
        </bits>
        <bits access="r" name="lna_pkd_out_2_bb" pos="12" rst="0x0">
          <comment>from AVDDRF_12_LNA &amp; AVSS_LNA
LNA peak detector output signal</comment>
        </bits>
        <bits access="r" name="pga_pkd_out_bb" pos="11:10" rst="0x0">
          <comment>from AVDDRF_12_CLK &amp; AVSS_RXABB
RX PGA peak detector output signal</comment>
        </bits>
        <bits access="r" name="rxvco_pkdet_out_bb" pos="9" rst="0x0">
          <comment>from AVDDRF_12_RX &amp; AVSS_LNA
RX VCO peak detector output</comment>
        </bits>
        <bits access="r" name="txvco_pkdet_out_bb" pos="8" rst="0x0">
          <comment>from AVDDRF_12_RF &amp; AVSS_RF
TX VCO peak detector output</comment>
        </bits>
        <bits access="r" name="rxpll_lock_bb" pos="7" rst="0x0">
          <comment>RXPLL lock flag, generated by DLPF;</comment>
        </bits>
        <bits access="r" name="txpll_lock_bb" pos="6" rst="0x0">
          <comment>TXPLL lock flag, generated by DLPF;</comment>
        </bits>
      </reg>
      <reg name="rf_output_readonly_1" protect="rw">
        <comment/>
        <bits access="r" name="adc_conv_done_i_wi_ns_bb" pos="15" rst="0x0"/>
        <bits access="r" name="adc_conv_done_q_wi_ns_bb" pos="14" rst="0x0"/>
        <bits access="r" name="adc_conv_done_i_wo_ns_bb" pos="13" rst="0x0"/>
        <bits access="r" name="adc_conv_done_q_wo_ns_bb" pos="12" rst="0x0"/>
        <bits access="r" name="pwdadc_conv_done_i_wi_ns_bb" pos="11" rst="0x0"/>
        <bits access="r" name="pwdadc_conv_done_q_wi_ns_bb" pos="10" rst="0x0"/>
        <bits access="r" name="pwdadc_conv_done_i_wo_ns_bb" pos="9" rst="0x0"/>
        <bits access="r" name="pwdadc_conv_done_q_wo_ns_bb" pos="8" rst="0x0"/>
      </reg>
      <reg name="tsenadc_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="rg_tsen_adcldo_en_bb" pos="15" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADCLDO enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_adcldo_v_bb" pos="14:11" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO output setting</comment>
        </bits>
        <bits access="rw" name="rg_tsen_adcldoref_bb" pos="10:6" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
LDO trim setting(VREF)</comment>
        </bits>
        <bits access="rw" name="rg_tsen_chop_clksel_bb" pos="1:0" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
CHOP CLK setting
00:/8192
01:/4096
10:/2048
11:/1024</comment>
        </bits>
      </reg>
      <reg name="tsenadc_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_tsen_clksel_bb" pos="15:14" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
SAMPLE CLK setting
00:/4
01:/4
10:/2
11:/1</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_bias_bb" pos="13:12" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC BIAS setting
00:10uA
01:5uA
10:15uA
11:20uA</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_capchop_en_bb" pos="11" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC CAPCHOP CK enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_chop_en_bb" pos="10" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC CHOP CK enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_data_edge_sel_bb" pos="9" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC sample edge select:
0:positive edge 1:negative edge</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_en_bb" pos="8" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC enable</comment>
        </bits>
      </reg>
      <reg name="tsenadc_ctrl_2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_tsen_sdadc_input_en_bb" pos="15" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC input RC enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_offset_en_bb" pos="14" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC offset cancel enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_rst_bb" pos="13" rst="0x1">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC reset signal, 0 to reset</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_ugbuf_en_bb" pos="12" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC input UGBUF enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_vcmi_bb" pos="11:10" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC_input CM setting</comment>
        </bits>
        <bits access="rw" name="rg_tsen_sdadc_vcmo_bb" pos="9:8" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC_output CM setting</comment>
        </bits>
        <bits access="rw" name="rg_tsen_test_clk_sel_bb" pos="7" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
CLK_TSEN_TEST channel select enable:
0: choose CLK path from 1.8V CLK_TSEN_26M
1: choose CLK path from 0.9V CLK_TSEN_TEST</comment>
        </bits>
        <bits access="rw" name="rg_tsen_ugbuf_bias_bb" pos="6:5" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC BIAS setting
00:10uA
01:5uA
10:15uA
11:20uA</comment>
        </bits>
        <bits access="rw" name="rg_tsen_ugbuf_chop_en_bb" pos="4" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC UGBUF CHOP CK enable</comment>
        </bits>
        <bits access="rw" name="rg_tsen_ugbuf_ctrl_bb" pos="3:2" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK
ADC_UGBUF GBW setting</comment>
        </bits>
      </reg>
      <reg name="apc_ctrl_0" protect="rw">
        <comment/>
        <bits access="rw" name="apc_bprc_bb" pos="15" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="apc_hv_gain_bit_bb" pos="14:12" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="apc_lv_gain_bit_bb" pos="11:9" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="apc_pga_ibit_bb" pos="8:7" rst="0x2">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
        <bits access="rw" name="pu_ramp_dac_bb" pos="6" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
      </reg>
      <reg name="apc_ctrl_1" protect="rw">
        <comment/>
        <bits access="rw" name="ramp_dac_din_bb" pos="9:0" rst="0x0">
          <comment>TO AVDDDCXO_18 &amp; AVSS_CLK</comment>
        </bits>
      </reg>
      <hole size="4928"/>
      <reg name="bandgap_ctrl_0_set" protect="rw"/>
      <reg name="ldo_pu_ctrl_0_set" protect="rw"/>
      <reg name="ldo_pu_ctrl_1_set" protect="rw"/>
      <reg name="ldo_pu_ctrl_2_set" protect="rw"/>
      <reg name="trx_pu_0_set" protect="rw"/>
      <reg name="trx_pu_1_set" protect="rw"/>
      <reg name="trx_pu_2_set" protect="rw"/>
      <reg name="trx_pu_3_set" protect="rw"/>
      <reg name="trx_pu_4_set" protect="rw"/>
      <reg name="trx_pu_5_set" protect="rw"/>
      <reg name="mdll_ctrl_0_set" protect="rw"/>
      <reg name="mdll_ctrl_1_set" protect="rw"/>
      <reg name="xtal_ctrl_0_set" protect="rw"/>
      <reg name="rxvco_ldo_ctrl_set" protect="rw"/>
      <reg name="rxvco_buf_ldo_ctrl_set" protect="rw"/>
      <reg name="rxvco_ctrl_0_set" protect="rw"/>
      <reg name="rxvco_ctrl_1_set" protect="rw"/>
      <reg name="rxvco_ctrl_2_set" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_0_set" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_1_set" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_2_set" protect="rw"/>
      <reg name="rxpll_gro_ctrl_0_set" protect="rw"/>
      <reg name="rxpll_gro_ctrl_1_set" protect="rw"/>
      <reg name="rxpll_gro_ctrl_2_set" protect="rw"/>
      <reg name="rxpll_gro_ctrl_3_set" protect="rw"/>
      <reg name="rxpll_ctrl_0_set" protect="rw"/>
      <reg name="lna_sel_ctrl_set" protect="rw"/>
      <reg name="lna_ctrl_set" protect="rw"/>
      <reg name="lna_pkd_ctrl_set" protect="rw"/>
      <reg name="rxmixer_ctrl_set" protect="rw"/>
      <reg name="pga_ctrl_0_set" protect="rw"/>
      <reg name="pga_ctrl_1_set" protect="rw"/>
      <reg name="pga_ctrl_2_set" protect="rw"/>
      <reg name="pga_ctrl_3_set" protect="rw"/>
      <reg name="rxabb_dccal_ctrl_0_set" protect="rw"/>
      <reg name="rxabb_dccal_ctrl_1_set" protect="rw"/>
      <reg name="rxflt_ctrl_0_set" protect="rw"/>
      <reg name="rxflt_ctrl_1_set" protect="rw"/>
      <reg name="rxflt_ctrl_2_set" protect="rw"/>
      <reg name="adc_ldo_ctrl_set" protect="rw"/>
      <reg name="adc_ctrl_0_set" protect="rw"/>
      <reg name="adc_ctrl_1_set" protect="rw"/>
      <reg name="adc_ctrl_2_set" protect="rw"/>
      <reg name="adc_ctrl_3_set" protect="rw"/>
      <reg name="adc_rsv_0_set" protect="rw"/>
      <reg name="pwdadc_ctrl_0_set" protect="rw"/>
      <reg name="pwdadc_ctrl_1_set" protect="rw"/>
      <reg name="pwdadc_ctrl_2_set" protect="rw"/>
      <reg name="pwdadc_ctrl_3_set" protect="rw"/>
      <reg name="rx_gain_ctrl_set" protect="rw"/>
      <reg name="rx_reserve1_set" protect="rw"/>
      <reg name="rx_reserve2_set" protect="rw"/>
      <reg name="rx_reserve3_set" protect="rw"/>
      <reg name="txvco_ldo_ctrl_set" protect="rw"/>
      <reg name="txvco_buf_ldo_ctrl_set" protect="rw"/>
      <reg name="txvco_ctrl_0_set" protect="rw"/>
      <reg name="txvco_ctrl_1_set" protect="rw"/>
      <reg name="txvco_ctrl_2_set" protect="rw"/>
      <reg name="txpll_ldo_ctrl_0_set" protect="rw"/>
      <reg name="txpll_ldo_ctrl_1_set" protect="rw"/>
      <reg name="txpll_ldo_ctrl_2_set" protect="rw"/>
      <reg name="txpll_gro_ctrl_0_set" protect="rw"/>
      <reg name="txpll_gro_ctrl_1_set" protect="rw"/>
      <reg name="txpll_gro_ctrl_2_set" protect="rw"/>
      <reg name="txpll_gro_ctrl_3_set" protect="rw"/>
      <reg name="txpll_ctrl_0_set" protect="rw"/>
      <reg name="txrf_gain_set" protect="rw"/>
      <reg name="txrf_gain_compensation_set" protect="rw"/>
      <reg name="txrf_gain_adj_set" protect="rw"/>
      <reg name="txrf_matchcap_set" protect="rw"/>
      <reg name="txflt_ctrl_0_set" protect="rw"/>
      <reg name="txflt_ctrl_1_set" protect="rw"/>
      <reg name="dac_ctrl_0_set" protect="rw"/>
      <reg name="dac_ctrl_1_set" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_0_set" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_1_set" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_2_set" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_3_set" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_4_set" protect="rw"/>
      <reg name="rxflt_dccal_set" protect="rw"/>
      <reg name="tx_reserve_0_set" protect="rw"/>
      <reg name="tx_reserve_1_set" protect="rw"/>
      <reg name="pwd_ctrl_0_set" protect="rw"/>
      <reg name="pwd_ctrl_1_set" protect="rw"/>
      <reg name="pwd_ctrl_2_set" protect="rw"/>
      <reg name="ts_ctrl_0_set" protect="rw"/>
      <reg name="ts_ctrl_1_set" protect="rw"/>
      <reg name="ts_ctrl_2_set" protect="rw"/>
      <reg name="cm_reserve1_set" protect="rw"/>
      <reg name="cm_reserve2_set" protect="rw"/>
      <reg name="cm_reserve3_set" protect="rw"/>
      <hole size="32"/>
      <reg name="test_ctrl_0_set" protect="rw"/>
      <reg name="test_ctrl_1_set" protect="rw"/>
      <reg name="cal_ctrl_0_set" protect="rw"/>
      <hole size="64"/>
      <reg name="tsenadc_ctrl_0_set" protect="rw"/>
      <reg name="tsenadc_ctrl_1_set" protect="rw"/>
      <reg name="tsenadc_ctrl_2_set" protect="rw"/>
      <reg name="apc_ctrl_0_set" protect="rw"/>
      <reg name="apc_ctrl_1_set" protect="rw"/>
      <hole size="4928"/>
      <reg name="bandgap_ctrl_0_clr" protect="rw"/>
      <reg name="ldo_pu_ctrl_0_clr" protect="rw"/>
      <reg name="ldo_pu_ctrl_1_clr" protect="rw"/>
      <reg name="ldo_pu_ctrl_2_clr" protect="rw"/>
      <reg name="trx_pu_0_clr" protect="rw"/>
      <reg name="trx_pu_1_clr" protect="rw"/>
      <reg name="trx_pu_2_clr" protect="rw"/>
      <reg name="trx_pu_3_clr" protect="rw"/>
      <reg name="trx_pu_4_clr" protect="rw"/>
      <reg name="trx_pu_5_clr" protect="rw"/>
      <reg name="mdll_ctrl_0_clr" protect="rw"/>
      <reg name="mdll_ctrl_1_clr" protect="rw"/>
      <reg name="xtal_ctrl_0_clr" protect="rw"/>
      <reg name="rxvco_ldo_ctrl_clr" protect="rw"/>
      <reg name="rxvco_buf_ldo_ctrl_clr" protect="rw"/>
      <reg name="rxvco_ctrl_0_clr" protect="rw"/>
      <reg name="rxvco_ctrl_1_clr" protect="rw"/>
      <reg name="rxvco_ctrl_2_clr" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_0_clr" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_1_clr" protect="rw"/>
      <reg name="rxpll_ldo_ctrl_2_clr" protect="rw"/>
      <reg name="rxpll_gro_ctrl_0_clr" protect="rw"/>
      <reg name="rxpll_gro_ctrl_1_clr" protect="rw"/>
      <reg name="rxpll_gro_ctrl_2_clr" protect="rw"/>
      <reg name="rxpll_gro_ctrl_3_clr" protect="rw"/>
      <reg name="rxpll_ctrl_0_clr" protect="rw"/>
      <reg name="lna_sel_ctrl_clr" protect="rw"/>
      <reg name="lna_ctrl_clr" protect="rw"/>
      <reg name="lna_pkd_ctrl_clr" protect="rw"/>
      <reg name="rxmixer_ctrl_clr" protect="rw"/>
      <reg name="pga_ctrl_0_clr" protect="rw"/>
      <reg name="pga_ctrl_1_clr" protect="rw"/>
      <reg name="pga_ctrl_2_clr" protect="rw"/>
      <reg name="pga_ctrl_3_clr" protect="rw"/>
      <reg name="rxabb_dccal_ctrl_0_clr" protect="rw"/>
      <reg name="rxabb_dccal_ctrl_1_clr" protect="rw"/>
      <reg name="rxflt_ctrl_0_clr" protect="rw"/>
      <reg name="rxflt_ctrl_1_clr" protect="rw"/>
      <reg name="rxflt_ctrl_2_clr" protect="rw"/>
      <reg name="adc_ldo_ctrl_clr" protect="rw"/>
      <reg name="adc_ctrl_0_clr" protect="rw"/>
      <reg name="adc_ctrl_1_clr" protect="rw"/>
      <reg name="adc_ctrl_2_clr" protect="rw"/>
      <reg name="adc_ctrl_3_clr" protect="rw"/>
      <reg name="adc_rsv_0_clr" protect="rw"/>
      <reg name="pwdadc_ctrl_0_clr" protect="rw"/>
      <reg name="pwdadc_ctrl_1_clr" protect="rw"/>
      <reg name="pwdadc_ctrl_2_clr" protect="rw"/>
      <reg name="pwdadc_ctrl_3_clr" protect="rw"/>
      <reg name="rx_gain_ctrl_clr" protect="rw"/>
      <reg name="rx_reserve1_clr" protect="rw"/>
      <reg name="rx_reserve2_clr" protect="rw"/>
      <reg name="rx_reserve3_clr" protect="rw"/>
      <reg name="txvco_ldo_ctrl_clr" protect="rw"/>
      <reg name="txvco_buf_ldo_ctrl_clr" protect="rw"/>
      <reg name="txvco_ctrl_0_clr" protect="rw"/>
      <reg name="txvco_ctrl_1_clr" protect="rw"/>
      <reg name="txvco_ctrl_2_clr" protect="rw"/>
      <reg name="txpll_ldo_ctrl_0_clr" protect="rw"/>
      <reg name="txpll_ldo_ctrl_1_clr" protect="rw"/>
      <reg name="txpll_ldo_ctrl_2_clr" protect="rw"/>
      <reg name="txpll_gro_ctrl_0_clr" protect="rw"/>
      <reg name="txpll_gro_ctrl_1_clr" protect="rw"/>
      <reg name="txpll_gro_ctrl_2_clr" protect="rw"/>
      <reg name="txpll_gro_ctrl_3_clr" protect="rw"/>
      <reg name="txpll_ctrl_0_clr" protect="rw"/>
      <reg name="txrf_gain_clr" protect="rw"/>
      <reg name="txrf_gain_compensation_clr" protect="rw"/>
      <reg name="txrf_gain_adj_clr" protect="rw"/>
      <reg name="txrf_matchcap_clr" protect="rw"/>
      <reg name="txflt_ctrl_0_clr" protect="rw"/>
      <reg name="txflt_ctrl_1_clr" protect="rw"/>
      <reg name="dac_ctrl_0_clr" protect="rw"/>
      <reg name="dac_ctrl_1_clr" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_0_clr" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_1_clr" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_2_clr" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_3_clr" protect="rw"/>
      <reg name="gnss_clkgen_ctrl_4_clr" protect="rw"/>
      <reg name="rxflt_dccal_clr" protect="rw"/>
      <reg name="tx_reserve_0_clr" protect="rw"/>
      <reg name="tx_reserve_1_clr" protect="rw"/>
      <reg name="pwd_ctrl_0_clr" protect="rw"/>
      <reg name="pwd_ctrl_1_clr" protect="rw"/>
      <reg name="pwd_ctrl_2_clr" protect="rw"/>
      <reg name="ts_ctrl_0_clr" protect="rw"/>
      <reg name="ts_ctrl_1_clr" protect="rw"/>
      <reg name="ts_ctrl_2_clr" protect="rw"/>
      <reg name="cm_reserve1_clr" protect="rw"/>
      <reg name="cm_reserve2_clr" protect="rw"/>
      <reg name="cm_reserve3_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="test_ctrl_0_clr" protect="rw"/>
      <reg name="test_ctrl_1_clr" protect="rw"/>
      <reg name="cal_ctrl_0_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="tsenadc_ctrl_0_clr" protect="rw"/>
      <reg name="tsenadc_ctrl_1_clr" protect="rw"/>
      <reg name="tsenadc_ctrl_2_clr" protect="rw"/>
      <reg name="apc_ctrl_0_clr" protect="rw"/>
      <reg name="apc_ctrl_1_clr" protect="rw"/>
    </module>
    <var name="REG_RF_ANA_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_ANA_CLR_OFFSET" value="0x800"/>
    <instance address="0x50031000" name="RF_ANA" type="RF_ANA"/>
  </archive>
  <archive relative="rf_dig_rtc.xml">
    <module category="System" name="RF_DIG_RTC">
      <reg name="reg_00_reg" protect="rw">
        <comment/>
        <bits access="rw" name="step_offset_update" pos="4" rst="0x0"/>
        <bits access="rw" name="xtal_sel_vref_vdig" pos="3" rst="0x0"/>
        <bits access="rw" name="xtal_sel_vrtc_vdig" pos="2" rst="0x0"/>
        <bits access="rw" name="pu_xtal_reg" pos="1" rst="0x1"/>
        <bits access="rw" name="pu_xtal_ana_sel_src" pos="0" rst="0x0">
          <comment>[0]:pu_xtal from BB;[1]pu xtal from reg</comment>
        </bits>
      </reg>
      <reg name="reg_18_reg" protect="rw">
        <comment/>
        <bits access="rw" name="step_offset_normal" pos="15:8" rst="0x0">
          <comment>32k gen div step_offset Normal mode</comment>
        </bits>
        <bits access="rw" name="step_offset_lp" pos="7:0" rst="0x0">
          <comment>32k gen div step_offset LP mode</comment>
        </bits>
      </reg>
      <reg name="reg_1c_reg" protect="rw">
        <comment/>
        <bits access="rw" name="lp_mode_delay" pos="7:6" rst="0x0">
          <comment>pu_xtal cycle select  2'b00: 4us; 2'b01:8us; 2'b10:12us; 2'b11:20us</comment>
        </bits>
        <bits access="rw" name="lp_mode_en_dr" pos="5" rst="0x0"/>
        <bits access="rw" name="lp_mode_en_reg" pos="4" rst="0x1"/>
        <bits access="rw" name="change_reg_flag_dr" pos="3" rst="0x0"/>
        <bits access="rw" name="change_reg_flag_reg" pos="2" rst="0x1"/>
        <bits access="rw" name="lp_mode_h_dr" pos="1" rst="0x0"/>
        <bits access="rw" name="lp_mode_h_reg" pos="0" rst="0x1"/>
      </reg>
      <reg name="reg_c4_reg" protect="rw">
        <comment/>
        <bits access="rw" name="enable_clk_26m_lp_uart" pos="14" rst="0x1">
          <comment>enable clk 26m lp uart to lps</comment>
        </bits>
        <bits access="rw" name="enable_clk_26m" pos="13" rst="0x1">
          <comment>enable clk 26m lp to analog</comment>
        </bits>
        <bits access="rw" name="xtal26m_plls2_en" pos="12" rst="0x1">
          <comment>BBPLL2 ref clk 26m enable</comment>
        </bits>
        <bits access="rw" name="xtal26m_plls1_en" pos="11" rst="0x1">
          <comment>BBPLL1 ref clk 26m enable</comment>
        </bits>
        <bits access="rw" name="xtal26m_interface_en" pos="10" rst="0x1">
          <comment>clk_26m_interface enable</comment>
        </bits>
        <bits access="rw" name="xtal26m_pllcal_en" pos="9" rst="0x1">
          <comment>RFPLL refcal clk 26m</comment>
        </bits>
        <bits access="rw" name="xtal26m_pwadc_en" pos="8" rst="0x1">
          <comment>pwdadc clk 26m enable</comment>
        </bits>
        <bits access="rw" name="xtal_osc_ibit_l" pos="7:4" rst="0x0">
          <comment>xtal_osc_ibit lp mode</comment>
        </bits>
        <bits access="rw" name="xtal_osc_ibit_n" pos="3:0" rst="0x8">
          <comment>xtal_osc_ibit normal mode</comment>
        </bits>
      </reg>
      <reg name="reg_c8_reg" protect="rw">
        <comment/>
        <bits access="rw" name="xtal_cfix_bit_l" pos="13" rst="0x0">
          <comment>xtal_cfix_bit lp mode</comment>
        </bits>
        <bits access="rw" name="xtal_cfix_bit_n" pos="12" rst="0x0">
          <comment>xtal_cfix_bit normal mode</comment>
        </bits>
        <bits access="rw" name="xtal_fixi_bit_l" pos="11:6" rst="0x1">
          <comment>xtal_fixi_bit lp mode</comment>
        </bits>
        <bits access="rw" name="xtal_fixi_bit_n" pos="5:0" rst="0x20">
          <comment>xtal_fixi_bit normal mode</comment>
        </bits>
      </reg>
      <reg name="reg_cc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="xdrv_aux1_power_bit" pos="10:8" rst="0x4">
          <comment>xdrv aux1 parameter</comment>
        </bits>
        <bits access="rw" name="xtal_reg_bit" pos="7:4" rst="0xc">
          <comment>XTAL parameter</comment>
        </bits>
        <bits access="rw" name="xdrv_reg_bit" pos="3:0" rst="0xc">
          <comment>xdrv parameter</comment>
        </bits>
      </reg>
      <reg name="reg_d0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="xtal_capbank_bit_l" pos="15:8" rst="0x4e">
          <comment>CADC bit lp mode</comment>
        </bits>
        <bits access="rw" name="xtal_capbank_bit_n" pos="7:0" rst="0x4e">
          <comment>CADC bit normal mode</comment>
        </bits>
      </reg>
      <reg name="reg_d4_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rtc_reser_l" pos="15:0" rst="0xff00">
          <comment>RTC</comment>
        </bits>
      </reg>
      <reg name="reg_d8_reg" protect="rw">
        <comment/>
        <bits access="rw" name="rtc_reser_n" pos="15:0" rst="0xff00">
          <comment>RTC</comment>
        </bits>
      </reg>
      <reg name="reg_dc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="psm_sw_cnt_l" pos="15:0" rst="0x7ef4">
          <comment>normal mode switch to PSM counter</comment>
        </bits>
      </reg>
      <reg name="reg_e0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="psm_sw_cnt_h" pos="15:0" rst="0x0">
          <comment>normal mode switch to PSM counter</comment>
        </bits>
      </reg>
      <hole size="1696"/>
      <reg name="reg_00_reg_set" protect="rw"/>
      <reg name="reg_18_reg_set" protect="rw"/>
      <reg name="reg_1c_reg_set" protect="rw"/>
      <reg name="reg_c4_reg_set" protect="rw"/>
      <reg name="reg_c8_reg_set" protect="rw"/>
      <reg name="reg_cc_reg_set" protect="rw"/>
      <reg name="reg_d0_reg_set" protect="rw"/>
      <reg name="reg_d4_reg_set" protect="rw"/>
      <reg name="reg_d8_reg_set" protect="rw"/>
      <reg name="reg_dc_reg_set" protect="rw"/>
      <reg name="reg_e0_reg_set" protect="rw"/>
      <hole size="1696"/>
      <reg name="reg_00_reg_clr" protect="rw"/>
      <reg name="reg_18_reg_clr" protect="rw"/>
      <reg name="reg_1c_reg_clr" protect="rw"/>
      <reg name="reg_c4_reg_clr" protect="rw"/>
      <reg name="reg_c8_reg_clr" protect="rw"/>
      <reg name="reg_cc_reg_clr" protect="rw"/>
      <reg name="reg_d0_reg_clr" protect="rw"/>
      <reg name="reg_d4_reg_clr" protect="rw"/>
      <reg name="reg_d8_reg_clr" protect="rw"/>
      <reg name="reg_dc_reg_clr" protect="rw"/>
      <reg name="reg_e0_reg_clr" protect="rw"/>
    </module>
    <var name="REG_RF_DIG_RTC_SET_OFFSET" value="0x100"/>
    <var name="REG_RF_DIG_RTC_CLR_OFFSET" value="0x200"/>
    <instance address="0x50034000" name="RF_DIG_RTC" type="RF_DIG_RTC"/>
  </archive>
  <archive relative="rf_intf.xml">
    <module category="System" name="RF_INTF">
      <hole size="2048"/>
      <reg name="apb_reg_int0" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int0" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int1" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int2" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int3" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int3" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int4" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int4" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int5" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int5" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int6" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int6" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int7" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int7" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int8" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int8" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int9" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int9" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res10" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res10" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res11" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res11" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res12" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res12" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res13" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res13" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res14" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res14" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <reg name="apb_reg_int_res15" protect="rw">
        <comment/>
        <bits access="rw" name="rg_apb_reg_int_res15" pos="15:0" rst="0x0">
          <comment>CP-A5riscv</comment>
        </bits>
      </reg>
      <hole size="1536"/>
      <reg name="int_clear0" protect="rw">
        <comment/>
        <bits access="rw" name="rg_irq_clr_l" pos="15:0" rst="0x0">
          <comment>riscvbit10</comment>
        </bits>
      </reg>
      <reg name="int_clear1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_irq_clr_h" pos="15:0" rst="0x0">
          <comment>riscvbit10</comment>
        </bits>
      </reg>
      <reg name="int2tmcu0" protect="rw">
        <comment/>
        <bits access="r" name="irq_out_l" pos="15:0" rst="0x0">
          <comment>riscvbit</comment>
        </bits>
      </reg>
      <reg name="int2tmcu1" protect="rw">
        <comment/>
        <bits access="r" name="irq_out_h" pos="15:0" rst="0x0">
          <comment>riscvbit</comment>
        </bits>
      </reg>
      <reg name="irq_enable0" protect="rw">
        <comment/>
        <bits access="rw" name="rg_irq_en_l" pos="15:0" rst="0xffff">
          <comment>riscvbit</comment>
        </bits>
      </reg>
      <reg name="irq_enable1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_irq_en_h" pos="15:0" rst="0xffff">
          <comment>riscvbit</comment>
        </bits>
      </reg>
      <reg name="irq_raw0" protect="rw">
        <comment/>
        <bits access="r" name="irq_raw_l" pos="15:0" rst="0x0">
          <comment>riscvbit</comment>
        </bits>
      </reg>
      <reg name="irq_raw1" protect="rw">
        <comment/>
        <bits access="r" name="irq_raw_h" pos="15:0" rst="0x0">
          <comment>riscvbit</comment>
        </bits>
      </reg>
      <reg name="irq_select" protect="rw">
        <comment/>
        <bits access="rw" name="rg_irq_sel" pos="15:0" rst="0x0">
          <comment>riscvbitriscv</comment>
        </bits>
      </reg>
      <reg name="afc_freq_bbpll1" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_bbpll11" pos="15:0" rst="0x0">
          <comment>BBPLL1 AFC</comment>
        </bits>
      </reg>
      <reg name="afc_freq_bbpll12" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_bbpll12" pos="15:8" rst="0x0">
          <comment>BBPLL1 AFC</comment>
        </bits>
        <bits access="rw" name="freq_offset_bbpll22" pos="7:0" rst="0x0">
          <comment>BBPLL2 AFC</comment>
        </bits>
      </reg>
      <reg name="afc_freq_bbpll2" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_bbpll21" pos="15:0" rst="0x0">
          <comment>BBPLL2 AFC</comment>
        </bits>
      </reg>
      <reg name="afc_freq_offset_mode" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_enable_bbpll2" pos="3" rst="0x0">
          <comment>BBPLL1 AFCbit</comment>
        </bits>
        <bits access="rw" name="freq_offset_enable_bbpll1" pos="2" rst="0x0">
          <comment>BBPLL1 AFCbit</comment>
        </bits>
        <bits access="rw" name="freq_offset_mode_bbpll2" pos="1" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="freq_offset_mode_bbpll1" pos="0" rst="0x0">
          <comment>reserved</comment>
        </bits>
      </reg>
      <reg name="freq_offset_ini_bbpll1_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_ini_bbpll11" pos="15:0" rst="0x0">
          <comment>BBPLL1</comment>
        </bits>
      </reg>
      <reg name="freq_offset_ini_bbpll1_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_ini_bbpll22" pos="15:8" rst="0x0">
          <comment>BBPLL1</comment>
        </bits>
        <bits access="rw" name="freq_offset_ini_bbpll12" pos="7:0" rst="0x0">
          <comment>BBPLL2</comment>
        </bits>
      </reg>
      <reg name="freq_offset_ini_bbpll2_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="freq_offset_ini_bbpll21" pos="15:0" rst="0x0">
          <comment>BBPLL2</comment>
        </bits>
      </reg>
      <reg name="bbpll1_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="plls1_ldo_out_bb" pos="15:13" rst="0x4">
          <comment>plls1 ldo output. TBD</comment>
        </bits>
        <bits access="rw" name="plls1_cpbias_bit_bb" pos="12:10" rst="0x4">
          <comment>plls1_cpbias_bit_bb</comment>
        </bits>
        <bits access="rw" name="plls1_cpc_ibit_bb" pos="9:7" rst="0x4">
          <comment>plls1_cpc_ibit_bb</comment>
        </bits>
        <bits access="rw" name="plls1_cpr_ibit_bb" pos="6:4" rst="0x4">
          <comment>plls1_cpr_ibit_bb</comment>
        </bits>
        <bits access="rw" name="plls1_notch_en_bb" pos="2" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="plls1_ldo_en_bb" pos="1" rst="0x1">
          <comment>plls1 ldo enable</comment>
        </bits>
        <bits access="rw" name="plls1_ldo_fast_charge_en_bb" pos="0" rst="0x1">
          <comment>plls1 ldo fast charge enable</comment>
        </bits>
      </reg>
      <reg name="bbpll1_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="pll_ldo_fastcharge_cnt_rx" pos="15:14" rst="0x0"/>
        <bits access="rw" name="pll_dly_num_pfd_rx" pos="13:11" rst="0x1"/>
        <bits access="rw" name="pll_lpmode_en_rx" pos="10" rst="0x0"/>
        <bits access="rw" name="pll_pcon_mode_rx" pos="9" rst="0x1"/>
        <bits access="rw" name="pll_refmulti2_en_rx" pos="8" rst="0x1"/>
        <bits access="rw" name="pll_high_test_rx" pos="7" rst="0x0"/>
        <bits access="rw" name="pll_low_test_rx" pos="6" rst="0x0"/>
        <bits access="rw" name="pll_test_en_rx" pos="5" rst="0x0"/>
        <bits access="rw" name="pll_sdm_clk_test_en_rx" pos="4" rst="0x0"/>
        <bits access="rw" name="pll_sdm_clk_sel_rst_rx" pos="3" rst="0x1"/>
        <bits access="rw" name="pll_sdm_clk_sel_nor_rx" pos="2" rst="0x0"/>
        <bits access="rw" name="pu_pll_dr_rx" pos="1" rst="0x0"/>
        <bits access="rw" name="pu_pll_reg_rx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll1_reg3" protect="rw">
        <comment/>
      </reg>
      <reg name="bbpll1_reg5" protect="rw">
        <comment/>
        <bits access="rw" name="pll_sdm_freq_rx1" pos="15:0" rst="0x24ec"/>
      </reg>
      <reg name="bbpll1_reg6" protect="rw">
        <comment/>
        <bits access="rw" name="pll_sdm_freq_rx0" pos="15:0" rst="0x4ec4"/>
      </reg>
      <reg name="bbpll1_reg7" protect="rw">
        <comment/>
        <bits access="rw" name="reser_sdm_rx" pos="15:8" rst="0x2">
          <comment>[8]:clk fbc inv
[9]:ref clk 52m
[10]:freq update</comment>
        </bits>
        <bits access="rw" name="int_dec_sel_rx" pos="7:5" rst="0x3"/>
        <bits access="rw" name="dither_bypass_rx" pos="4" rst="0x1"/>
        <bits access="rw" name="ss_en_rx" pos="3" rst="0x0"/>
        <bits access="rw" name="ss_squre_tri_sel_rx" pos="2" rst="0x0"/>
        <bits access="rw" name="pll_sdm_resetn_dr_rx" pos="1" rst="0x0"/>
        <bits access="rw" name="pll_sdm_resetn_reg_rx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll1_reg8" protect="rw">
        <comment/>
        <bits access="rw" name="pll_ss_devi_ct_rx" pos="15:8" rst="0x0"/>
        <bits access="rw" name="pll_ss_peri_ct_rx" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="bbpll1_reg9" protect="rw">
        <comment/>
      </reg>
      <reg name="bbpll1_rega" protect="rw">
        <comment/>
        <bits access="rw" name="sdm_reset_time_sel_rx" pos="14:13" rst="0x1"/>
        <bits access="rw" name="sdmclk_sel_time_sel_rx" pos="12:11" rst="0x1"/>
        <bits access="rw" name="pll_clk_dfe_sel_reg_rx" pos="10:9" rst="0x3"/>
        <bits access="rw" name="pll_clk_adc_sel_reg_rx" pos="8:7" rst="0x1"/>
        <bits access="rw" name="pll_clk_adc_en_reg_rx" pos="6" rst="0x0"/>
        <bits access="rw" name="pll_clk_adc_dfe_en_reg_rx" pos="5" rst="0x0"/>
        <bits access="rw" name="pll_clkout_en_reg_rx" pos="4:1" rst="0xf"/>
        <bits access="rw" name="clk_gen_en_reg_rx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll1_regb" protect="rw">
        <comment/>
        <bits access="r" name="pu_pll_rx" pos="15" rst="0x0"/>
        <bits access="r" name="pll_lock_rx" pos="14" rst="0x0"/>
        <bits access="r" name="rxpll_sx_cal_state" pos="13:11" rst="0x0">
          <comment>RXPLL cal state, ECO</comment>
        </bits>
        <bits access="r" name="pll_lock_steady_rx" pos="10" rst="0x0"/>
      </reg>
      <reg name="bbpll1_regd" protect="rw">
        <comment/>
        <bits access="rw" name="plls1_ldo_cp_tune_bb" pos="7:6" rst="0x2"/>
        <bits access="rw" name="resetn_spll_rx" pos="5" rst="0x1"/>
        <bits access="rw" name="vco_reset_dis_rx" pos="4" rst="0x1"/>
        <bits access="rw" name="pll_clkout_en_counter_sel_rx" pos="3:2" rst="0x1"/>
        <bits access="rw" name="lock_counter_sel_rx" pos="1:0" rst="0x1"/>
      </reg>
      <reg name="bbpll2_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="plls2_ldo_out_bb" pos="15:13" rst="0x4">
          <comment>plls2 ldo output. TBD</comment>
        </bits>
        <bits access="rw" name="plls2_cpbias_bit_bb" pos="12:10" rst="0x4">
          <comment>plls2_cpbias_bit_bb</comment>
        </bits>
        <bits access="rw" name="plls2_cpc_ibit_bb" pos="9:7" rst="0x4">
          <comment>plls2_cpc_ibit_bb</comment>
        </bits>
        <bits access="rw" name="plls2_cpr_ibit_bb" pos="6:4" rst="0x4">
          <comment>plls2_cpr_ibit_bb</comment>
        </bits>
        <bits access="rw" name="plls2_notch_en_bb" pos="2" rst="0x0">
          <comment>TBD</comment>
        </bits>
        <bits access="rw" name="plls2_ldo_en_bb" pos="1" rst="0x1">
          <comment>plls2 ldo enable</comment>
        </bits>
        <bits access="rw" name="plls2_ldo_fast_charge_en_bb" pos="0" rst="0x1">
          <comment>plls2 ldo fast charge enable</comment>
        </bits>
      </reg>
      <reg name="bbpll2_reg2" protect="rw">
        <comment/>
        <bits access="rw" name="pll_ldo_fastcharge_cnt_tx" pos="15:14" rst="0x0"/>
        <bits access="rw" name="pll_dly_num_pfd_tx" pos="13:11" rst="0x1"/>
        <bits access="rw" name="pll_lpmode_en_tx" pos="10" rst="0x0"/>
        <bits access="rw" name="pll_pcon_mode_tx" pos="9" rst="0x1"/>
        <bits access="rw" name="pll_refmulti2_en_tx" pos="8" rst="0x1"/>
        <bits access="rw" name="pll_high_test_tx" pos="7" rst="0x0"/>
        <bits access="rw" name="pll_low_test_tx" pos="6" rst="0x0"/>
        <bits access="rw" name="pll_test_en_tx" pos="5" rst="0x0"/>
        <bits access="rw" name="pll_sdm_clk_test_en_tx" pos="4" rst="0x0"/>
        <bits access="rw" name="pll_sdm_clk_sel_rst_tx" pos="3" rst="0x1"/>
        <bits access="rw" name="pll_sdm_clk_sel_nor_tx" pos="2" rst="0x0"/>
        <bits access="rw" name="pu_pll_dr_tx" pos="1" rst="0x0"/>
        <bits access="rw" name="pu_pll_reg_tx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll2_reg3" protect="rw">
        <comment/>
      </reg>
      <reg name="bbpll2_reg5" protect="rw">
        <comment/>
        <bits access="rw" name="pll_sdm_freq_tx1" pos="15:0" rst="0x25cf"/>
      </reg>
      <reg name="bbpll2_reg6" protect="rw">
        <comment/>
        <bits access="rw" name="pll_sdm_freq_tx0" pos="15:0" rst="0x29bf"/>
      </reg>
      <reg name="bbpll2_reg7" protect="rw">
        <comment/>
        <bits access="rw" name="reser_sdm_tx" pos="15:8" rst="0x2">
          <comment>[8]:clk fbc inv
[9]:ref clk 52m
[10]:freq update</comment>
        </bits>
        <bits access="rw" name="int_dec_sel_tx" pos="7:5" rst="0x3"/>
        <bits access="rw" name="dither_bypass_tx" pos="4" rst="0x1"/>
        <bits access="rw" name="ss_en_tx" pos="3" rst="0x0"/>
        <bits access="rw" name="ss_squre_tri_sel_tx" pos="2" rst="0x0"/>
        <bits access="rw" name="pll_sdm_resetn_dr_tx" pos="1" rst="0x0"/>
        <bits access="rw" name="pll_sdm_resetn_reg_tx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll2_reg8" protect="rw">
        <comment/>
        <bits access="rw" name="pll_ss_devi_ct_tx" pos="15:8" rst="0x0"/>
        <bits access="rw" name="pll_ss_peri_ct_tx" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="bbpll2_reg9" protect="rw">
        <comment/>
      </reg>
      <reg name="bbpll2_rega" protect="rw">
        <comment/>
        <bits access="rw" name="sdm_reset_time_sel_tx" pos="14:13" rst="0x1"/>
        <bits access="rw" name="sdmclk_sel_time_sel_tx" pos="12:11" rst="0x1"/>
        <bits access="rw" name="pll_clk_adc_sel_reg_tx" pos="8:7" rst="0x2"/>
        <bits access="rw" name="pll_clk_adc_en_reg_tx" pos="6" rst="0x0"/>
        <bits access="rw" name="pll_clk_adc_dfe_en_reg_tx" pos="5" rst="0x0"/>
        <bits access="rw" name="pll_clkout_en_reg_tx" pos="4:1" rst="0xf"/>
        <bits access="rw" name="clk_gen_en_reg_tx" pos="0" rst="0x1"/>
      </reg>
      <reg name="bbpll2_regb" protect="rw">
        <comment/>
        <bits access="r" name="pu_pll_tx" pos="15" rst="0x0"/>
        <bits access="r" name="pll_lock_tx" pos="14" rst="0x0"/>
        <bits access="r" name="pll_sdm_resetn_tx" pos="13" rst="0x0"/>
        <bits access="r" name="pll_sdm_clk_sel_tx" pos="12" rst="0x0"/>
        <bits access="r" name="pll_clk_ready_tx" pos="11" rst="0x0"/>
        <bits access="r" name="pll_lock_steady_tx" pos="10" rst="0x0"/>
      </reg>
      <reg name="bbpll2_regd" protect="rw">
        <comment/>
        <bits access="rw" name="plls2_ldo_cp_tune_bb" pos="7:6" rst="0x2"/>
        <bits access="rw" name="resetn_spll_tx" pos="5" rst="0x1"/>
        <bits access="rw" name="vco_reset_dis_tx" pos="4" rst="0x1"/>
        <bits access="rw" name="pll_clkout_en_counter_sel_tx" pos="3:2" rst="0x1"/>
        <bits access="rw" name="lock_counter_sel_tx" pos="1:0" rst="0x1"/>
      </reg>
      <reg name="clk_gen_reg0" protect="rw">
        <comment/>
        <bits access="rw" name="rg_freq_clk_div_3" pos="11:9" rst="0x4">
          <comment></comment>
        </bits>
        <bits access="rw" name="rg_freq_clk_div_2" pos="8:6" rst="0x4">
          <comment></comment>
        </bits>
        <bits access="rw" name="rg_freq_clk_div_1" pos="5:3" rst="0x4">
          <comment></comment>
        </bits>
        <bits access="rw" name="rg_freq_clk_div_0" pos="2:0" rst="0x4">
          <comment></comment>
        </bits>
      </reg>
      <reg name="clk_gen_reg1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_inv_clk_div" pos="7:4" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="rg_enable_clk_div" pos="3:0" rst="0x0">
          <comment>bit</comment>
        </bits>
      </reg>
      <reg name="txpll_freq_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txpll_freq_m" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_m" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txpll_freq_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_h" pos="2:0" rst="0x0"/>
      </reg>
      <reg name="txpll_sdm_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_sdm_soft_rst_n" pos="6" rst="0x0">
          <comment>sdm rstn</comment>
        </bits>
        <bits access="rw" name="rg_txpll_freq_offset_enable" pos="5" rst="0x0">
          <comment>sdm input divN offset en</comment>
        </bits>
        <bits access="rw" name="rg_txpll_dither_bypass_reg" pos="4" rst="0x1">
          <comment>sdm dither for frac spur</comment>
        </bits>
        <bits access="rw" name="rg_txpll_fbc_inv_reg" pos="3" rst="0x0">
          <comment>sdm clk inv</comment>
        </bits>
        <bits access="rw" name="rg_txpll_int_dec_sel_reg" pos="2:0" rst="0x3">
          <comment>0 sel int, 1sel 1bit frac, 2sel 2bit frac. 3sel 3bit frac</comment>
        </bits>
      </reg>
      <reg name="txpll_freq_offset_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_offset_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txpll_freq_offset_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_offset_h" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="txpll_freq_offset_ini_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_offset_ini_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txpll_freq_offset_ini_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_freq_offset_ini_h" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="txpll_sx_ctrl1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_afc_delay_vco" pos="15:14" rst="0x0">
          <comment>afc for vco wait time control</comment>
        </bits>
        <bits access="rw" name="rg_txpll_afc_bit_num" pos="13:12" rst="0x3">
          <comment>0 for 8bit cband calibration, 3 for 11bit cband calibration</comment>
        </bits>
        <bits access="rw" name="rg_txpll_afc_count_time" pos="11:10" rst="0x0">
          <comment>afccounter counttime control:
0--2^5/26M   1--2^6/26M
2--2^7/26M   3--2^8/26M</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_afc_bypass" pos="9" rst="0x0">
          <comment>a-afc bypass</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_cal_resetn" pos="8" rst="0x0">
          <comment>cal top rstn</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_aac_bypass" pos="7" rst="0x0">
          <comment>aac bypass</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_aac_pkd_delay" pos="6:5" rst="0x0">
          <comment>vco pkd wait time control:
0--500ns  1--750ns  2--1us  3--1.25us</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_aac_adder_step_sel" pos="4:3" rst="0x0">
          <comment>aac cal done vcobias adder control:
0--1  1--2  2--3  3--4</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_aac_cal_init_delay" pos="2:0" rst="0x1">
          <comment>aac cal init delay control,1~1us</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_ctrl2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_rf_sx_agc_resetn" pos="8" rst="0x0">
          <comment>pll agc rstn</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_agc_en" pos="7" rst="0x0">
          <comment>pll agc en</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_agc_cnt_time" pos="6:5" rst="0x0">
          <comment>pll agc counttime control</comment>
        </bits>
        <bits access="rw" name="rg_txpll_afc_sdm_en" pos="4" rst="0x1"/>
        <bits access="rw" name="rg_txpll_afc_delay_charging" pos="3:1" rst="0x2">
          <comment>afc charging delay control, 0~0, 7~3.5us</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_sx_afc_startl2h" pos="0" rst="0x0">
          <comment>vco calibration start signal</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_ctrl3" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_sx_caldone_lock_en" pos="12" rst="0x0"/>
        <bits access="rw" name="rg_txpll_sx_lock_dly" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="txpll_sx_ctrl4" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_afc_cal_freq_in_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="txpll_sx_ctrl5" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_afc_cal_freq_in_h" pos="0" rst="0x0"/>
      </reg>
      <reg name="txpll_sx_ctrl6" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_afc_sel_dpll" pos="12" rst="0x0">
          <comment>0 sel a-afc cbank, 1 sel d-afc cbank</comment>
        </bits>
        <bits access="rw" name="rg_txpll_afc_sel_reg" pos="11" rst="0x0">
          <comment>0 for auto afc; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_afc_vco_cap" pos="10:0" rst="0x400">
          <comment>vco cbank spi</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_ctrl7" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_vco_bias_sel_reg" pos="12" rst="0x0">
          <comment>0 for auto aac; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_vco_bias" pos="11:8" rst="0xf">
          <comment>vco bias spi</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_open_en_sel_reg" pos="7" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_open_en" pos="6" rst="0x0">
          <comment>pll loop open en</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_cnt_en_sel_reg" pos="5" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_cnt_en" pos="4" rst="0x0">
          <comment>afccounter enable control, high active</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_cal_en_sel_reg" pos="3" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pll_cal_en" pos="2" rst="0x0">
          <comment>afccounter rst control, high active</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pu_vco_pkd_sel_reg" pos="1" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_txpll_rf_pu_vco_pkd" pos="0" rst="0x0">
          <comment>vco peakdetector en</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat1" protect="rw">
        <comment/>
        <bits access="r" name="txpll_afc_start_ack" pos="10">
          <comment>a-afc start signal</comment>
        </bits>
        <bits access="r" name="txpll_aac_start_ack" pos="9">
          <comment>aac start signal</comment>
        </bits>
        <bits access="r" name="txpll_rf_sx_aac_state" pos="8:7">
          <comment>aac state</comment>
        </bits>
        <bits access="r" name="txpll_rf_sx_cal_state" pos="6:4">
          <comment>cal top state</comment>
        </bits>
        <bits access="r" name="txpll_cal_done_agc" pos="3">
          <comment>agc cal done signal</comment>
        </bits>
        <bits access="r" name="txpll_cal_done_afc" pos="2">
          <comment>a-afc cal done signal</comment>
        </bits>
        <bits access="r" name="txpll_cal_done_aac" pos="1">
          <comment>aac cal done signal</comment>
        </bits>
        <bits access="r" name="txpll_cal_done_top" pos="0">
          <comment>cal top cal done signal, same as afc cal done</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat2" protect="rw">
        <comment/>
        <bits access="r" name="txpll_afc_err_min" pos="15:0">
          <comment>a-afc err min, for debug</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat3" protect="rw">
        <comment/>
        <bits access="r" name="da_afc_vco_cap_tx" pos="10:0">
          <comment>vco cbank</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat4" protect="rw">
        <comment/>
        <bits access="r" name="da_rf_pll_open_en_tx" pos="7" rst="0x0">
          <comment>pll loop en</comment>
        </bits>
        <bits access="r" name="da_rf_pll_cnt_en_tx" pos="6" rst="0x0">
          <comment>afccount en</comment>
        </bits>
        <bits access="r" name="da_rf_pll_cal_en_tx" pos="5" rst="0x0">
          <comment>afccount rst</comment>
        </bits>
        <bits access="r" name="da_rf_pu_vco_pkd_tx" pos="4" rst="0x0">
          <comment>vco pkd en</comment>
        </bits>
        <bits access="r" name="da_rf_vco_bias_tx" pos="3:0" rst="0x0">
          <comment>vco bias</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat5" protect="rw">
        <comment/>
        <bits access="r" name="ad_rf_pll_cnt_tx" pos="15:0">
          <comment>afccount output fot a-afc &amp; agc</comment>
        </bits>
      </reg>
      <reg name="txpll_sx_stat6" protect="rw">
        <comment/>
        <bits access="r" name="ad_rf_vco_pkd_out_tx" pos="0">
          <comment>vco pkd output fot aac</comment>
        </bits>
      </reg>
      <reg name="rxpll_freq_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_freq_m" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_m" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_freq_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_h" pos="2:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_sdm_ctrl" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_sdm_soft_rst_n" pos="6" rst="0x0">
          <comment>sdm rstn</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_freq_offset_enable" pos="5" rst="0x0">
          <comment>sdm input divN offset en</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_dither_bypass_reg" pos="4" rst="0x1">
          <comment>sdm dither for frac spur</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_fbc_inv_reg" pos="3" rst="0x0">
          <comment>sdm clk inv</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_int_dec_sel_reg" pos="2:0" rst="0x3">
          <comment>0 sel int, 1sel 1bit frac, 2sel 2bit frac. 3sel 3bit frac</comment>
        </bits>
      </reg>
      <reg name="rxpll_freq_offset_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_offset_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_freq_offset_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_offset_h" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_freq_offset_ini_l" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_offset_ini_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_freq_offset_ini_h" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_freq_offset_ini_h" pos="7:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_sx_ctrl1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_afc_delay_vco" pos="15:14" rst="0x0">
          <comment>afc for vco wait time control</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_afc_bit_num" pos="13:12" rst="0x3">
          <comment>0 for 8bit cband calibration, 3 for 11bit cband calibration</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_afc_count_time" pos="11:10" rst="0x0">
          <comment>afccounter counttime control:
0--2^5/26M   1--2^6/26M
2--2^7/26M   3--2^8/26M</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_afc_bypass" pos="9" rst="0x0">
          <comment>a-afc bypass</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_cal_resetn" pos="8" rst="0x0">
          <comment>cal top rstn</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_aac_bypass" pos="7" rst="0x0">
          <comment>aac bypass</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_aac_pkd_delay" pos="6:5" rst="0x0">
          <comment>vco pkd wait time control:
0--500ns  1--750ns  2--1us  3--1.25us</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_aac_adder_step_sel" pos="4:3" rst="0x0">
          <comment>aac cal done vcobias adder control:
0--1  1--2  2--3  3--4</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_aac_cal_init_delay" pos="2:0" rst="0x1">
          <comment>aac cal init delay control:</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_ctrl2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_rf_sx_agc_resetn" pos="8" rst="0x0">
          <comment>pll agc rstn</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_agc_en" pos="7" rst="0x0">
          <comment>pll agc en</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_agc_cnt_time" pos="6:5" rst="0x0">
          <comment>pll agc counttime control</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_afc_sdm_en" pos="4" rst="0x0"/>
        <bits access="rw" name="rg_rxpll_afc_delay_charging" pos="3:1" rst="0x2">
          <comment>afc charging delay control, 0~0, 7~3.5us</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_sx_afc_startl2h" pos="0" rst="0x0">
          <comment>vco calibration start signal</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_ctrl3" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_sx_caldone_lock_en" pos="12" rst="0x0"/>
        <bits access="rw" name="rg_rxpll_sx_lock_dly" pos="11:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_sx_ctrl4" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_afc_cal_freq_in_l" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rxpll_sx_ctrl5" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_afc_cal_freq_in_h" pos="0" rst="0x0"/>
      </reg>
      <reg name="rxpll_sx_ctrl6" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_afc_sel_dpll" pos="12" rst="0x0">
          <comment>0 sel a-afc cbank, 1 sel d-afc cbank</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_afc_sel_reg" pos="11" rst="0x0">
          <comment>0 for auto afc; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_afc_vco_cap" pos="10:0" rst="0x400">
          <comment>vco cbank spi</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_ctrl7" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_vco_bias_sel_reg" pos="12" rst="0x0">
          <comment>0 for auto aac; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_vco_bias" pos="11:8" rst="0xf">
          <comment>vco bias spi</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_open_en_sel_reg" pos="7" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_open_en" pos="6" rst="0x0">
          <comment>pll loop open en</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_cnt_en_sel_reg" pos="5" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_cnt_en" pos="4" rst="0x0">
          <comment>afccounter enable control, high active</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_cal_en_sel_reg" pos="3" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pll_cal_en" pos="2" rst="0x0">
          <comment>afccounter rst control, high active</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pu_vco_pkd_sel_reg" pos="1" rst="0x0">
          <comment>0 for auto ; 1 for manual</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_rf_pu_vco_pkd" pos="0" rst="0x0">
          <comment>vco peakdetector en</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_stat1" protect="rw">
        <comment/>
      </reg>
      <reg name="rxpll_sx_stat2" protect="rw">
        <comment/>
      </reg>
      <reg name="rxpll_sx_stat3" protect="rw">
        <comment/>
        <bits access="r" name="da_afc_vco_cap_rx" pos="10:0">
          <comment>vco cbank</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_stat4" protect="rw">
        <comment/>
        <bits access="r" name="da_rf_pll_open_en_rx" pos="7" rst="0x0">
          <comment>pll loop en</comment>
        </bits>
        <bits access="r" name="da_rf_pll_cnt_en_rx" pos="6" rst="0x0">
          <comment>afccount en</comment>
        </bits>
        <bits access="r" name="da_rf_pll_cal_en_rx" pos="5" rst="0x0">
          <comment>afccount rst</comment>
        </bits>
        <bits access="r" name="da_rf_pu_vco_pkd_rx" pos="4" rst="0x0">
          <comment>vco pkd en</comment>
        </bits>
        <bits access="r" name="da_rf_vco_bias_rx" pos="3:0" rst="0x0">
          <comment>vco bias</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_stat5" protect="rw">
        <comment/>
        <bits access="r" name="ad_rf_pll_cnt_rx" pos="15:0">
          <comment>afccount output fot a-afc &amp; agc</comment>
        </bits>
      </reg>
      <reg name="rxpll_sx_stat6" protect="rw">
        <comment/>
        <bits access="r" name="ad_rf_vco_pkd_out_rx" pos="0">
          <comment>vco pkd output fot aac</comment>
        </bits>
      </reg>
      <reg name="peak_det_clr" protect="rw">
        <comment/>
        <bits access="rw" name="rg_peak_det_auto_ctrl_en" pos="11:8" rst="0x0">
          <comment>peak detectoradc_en1bit</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_clr" pos="7:4" rst="0x0">
          <comment>peak detector</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_en" pos="3:0" rst="0x0">
          <comment>peak detectorbit</comment>
        </bits>
      </reg>
      <reg name="peak_det_sta" protect="rw">
        <comment/>
        <bits access="r" name="peak_det_int" pos="11:8">
          <comment>peak detectorbit</comment>
        </bits>
        <bits access="r" name="peak_det_flag_sync" pos="7:4">
          <comment>peak detector</comment>
        </bits>
        <bits access="r" name="ad_peak_det_flag" pos="3:0">
          <comment>peak detector</comment>
        </bits>
      </reg>
      <reg name="peak_det_num1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_peak_det_num1" pos="15:8" rst="0x80">
          <comment>peak detector</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_num0" pos="7:0" rst="0x80">
          <comment>peak detector</comment>
        </bits>
      </reg>
      <reg name="peak_det_num2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_peak_det_num3" pos="15:8" rst="0x80">
          <comment>peak detector</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_num2" pos="7:0" rst="0x80">
          <comment>peak detector</comment>
        </bits>
      </reg>
      <reg name="peak_det_trig_num1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_peak_det_trig_num1" pos="15:8" rst="0x7f">
          <comment>peak detector</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_trig_num0" pos="7:0" rst="0x7f">
          <comment>peak detector</comment>
        </bits>
      </reg>
      <reg name="peak_det_trig_num2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_peak_det_trig_num3" pos="15:8" rst="0x7f">
          <comment>peak detector</comment>
        </bits>
        <bits access="rw" name="rg_peak_det_trig_num2" pos="7:0" rst="0x7f">
          <comment>peak detector</comment>
        </bits>
      </reg>
      <hole size="5376"/>
      <reg name="int_clear0_set" protect="rw"/>
      <reg name="int_clear1_set" protect="rw"/>
      <hole size="64"/>
      <reg name="irq_enable0_set" protect="rw"/>
      <reg name="irq_enable1_set" protect="rw"/>
      <hole size="64"/>
      <reg name="irq_select_set" protect="rw"/>
      <hole size="96"/>
      <reg name="afc_freq_offset_mode_set" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll1_reg1_set" protect="rw"/>
      <reg name="bbpll1_reg2_set" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll1_reg7_set" protect="rw"/>
      <hole size="64"/>
      <reg name="bbpll1_rega_set" protect="rw"/>
      <hole size="32"/>
      <reg name="bbpll1_regd_set" protect="rw"/>
      <reg name="bbpll2_reg1_set" protect="rw"/>
      <reg name="bbpll2_reg2_set" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll2_reg7_set" protect="rw"/>
      <hole size="64"/>
      <reg name="bbpll2_rega_set" protect="rw"/>
      <hole size="32"/>
      <reg name="bbpll2_regd_set" protect="rw"/>
      <reg name="clk_gen_reg0_set" protect="rw"/>
      <reg name="clk_gen_reg1_set" protect="rw"/>
      <hole size="96"/>
      <reg name="txpll_sdm_ctrl_set" protect="rw"/>
      <hole size="128"/>
      <reg name="txpll_sx_ctrl1_set" protect="rw"/>
      <reg name="txpll_sx_ctrl2_set" protect="rw"/>
      <hole size="128"/>
      <reg name="txpll_sx_ctrl7_set" protect="rw"/>
      <hole size="288"/>
      <reg name="rxpll_sdm_ctrl_set" protect="rw"/>
      <hole size="128"/>
      <reg name="rxpll_sx_ctrl1_set" protect="rw"/>
      <reg name="rxpll_sx_ctrl2_set" protect="rw"/>
      <hole size="128"/>
      <reg name="rxpll_sx_ctrl7_set" protect="rw"/>
      <hole size="192"/>
      <reg name="peak_det_clr_set" protect="rw"/>
      <hole size="5536"/>
      <reg name="int_clear0_clr" protect="rw"/>
      <reg name="int_clear1_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="irq_enable0_clr" protect="rw"/>
      <reg name="irq_enable1_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="irq_select_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="afc_freq_offset_mode_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll1_reg1_clr" protect="rw"/>
      <reg name="bbpll1_reg2_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll1_reg7_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="bbpll1_rega_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="bbpll1_regd_clr" protect="rw"/>
      <reg name="bbpll2_reg1_clr" protect="rw"/>
      <reg name="bbpll2_reg2_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="bbpll2_reg7_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="bbpll2_rega_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="bbpll2_regd_clr" protect="rw"/>
      <reg name="clk_gen_reg0_clr" protect="rw"/>
      <reg name="clk_gen_reg1_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="txpll_sdm_ctrl_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="txpll_sx_ctrl1_clr" protect="rw"/>
      <reg name="txpll_sx_ctrl2_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="txpll_sx_ctrl7_clr" protect="rw"/>
      <hole size="288"/>
      <reg name="rxpll_sdm_ctrl_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="rxpll_sx_ctrl1_clr" protect="rw"/>
      <reg name="rxpll_sx_ctrl2_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="rxpll_sx_ctrl7_clr" protect="rw"/>
      <hole size="192"/>
      <reg name="peak_det_clr_clr" protect="rw"/>
    </module>
    <var name="REG_RF_INTF_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_INTF_CLR_OFFSET" value="0x800"/>
    <instance address="0x50030000" name="RF_INTF" type="RF_INTF"/>
  </archive>
  <archive relative="rffe.xml">
    <module category="System" name="RFFE">
      <reg name="cmd_mipi0" protect="rw">
        <comment/>
        <bits access="rw" name="cmd_mipi_low" pos="15:0" rst="0x0">
          <comment>cmd_mipi_sr[15:0]</comment>
        </bits>
      </reg>
      <reg name="cmd_mipi1" protect="rw">
        <comment/>
        <bits access="rw" name="cmd_mipi_high" pos="15:0" rst="0x0">
          <comment>cmd_mipi_sr[31:16],when write this reg,start the RFFE</comment>
        </bits>
      </reg>
      <reg name="data_mipi0" protect="rw">
        <comment/>
        <bits access="rw" name="data_mipi_low" pos="15:0" rst="0x0">
          <comment>data_mipi_sr[15:0]</comment>
        </bits>
      </reg>
      <reg name="data_mipi1" protect="rw">
        <comment/>
        <bits access="rw" name="data_mipi_high" pos="15:0" rst="0x0">
          <comment>data_mipi_sr[31:16]</comment>
        </bits>
      </reg>
      <reg name="data_out0" protect="rw">
        <comment/>
        <bits access="rw" name="data_out_low" pos="15:0" rst="0x0">
          <comment>data_out_mipi[15:0]</comment>
        </bits>
      </reg>
      <reg name="data_out1" protect="rw">
        <comment/>
        <bits access="rw" name="data_out_high" pos="15:0" rst="0x0">
          <comment>data_out_mipi[31:16]</comment>
        </bits>
      </reg>
      <reg name="data_valid" protect="rw">
        <comment/>
        <bits access="r" name="data_valid" pos="3:0" rst="0x0">
          <comment>data_valid_byte[3:0]</comment>
        </bits>
      </reg>
      <reg name="mipi_status" protect="rw">
        <comment/>
        <bits access="r" name="master_busy_mipi_dly" pos="1" rst="0x0">
          <comment>master_busy_mipi_dly</comment>
        </bits>
        <bits access="r" name="cmd_done_status" pos="0" rst="0x0">
          <comment>cmd_done_status</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x50038000" name="RFFE" type="RFFE"/>
  </archive>
  <archive relative="rf_rxdlpf.xml">
    <module category="System" name="RF_RXDLPF">
      <reg name="dlpf_ctrl_reg" protect="rw">
        <comment/>
        <bits access="rw" name="notch_en_sel_status3" pos="15" rst="0x0">
          <comment>DLPF notch bypass status3
1: notch bypass when the value of dlpf_det_status is less than 3</comment>
        </bits>
        <bits access="rw" name="sdm_bypass" pos="14" rst="0x0">
          <comment>DLPF sdm bypass</comment>
        </bits>
        <bits access="rw" name="notch_en_sel_status2" pos="13" rst="0x0">
          <comment>DLPF notch bypass status2
1: notch bypass when the value of dlpf_det_status is less than 2</comment>
        </bits>
        <bits access="rw" name="tdc_cal_clk_inv" pos="12" rst="0x0">
          <comment>gro mode tdc cal clk out inverse</comment>
        </bits>
        <bits access="rw" name="pha_err_clk_inv" pos="11" rst="0x0">
          <comment>gro mode phase err clk out inverse</comment>
        </bits>
        <bits access="rw" name="tdc_dout_clk_inv" pos="10" rst="0x0">
          <comment>gro mode tdc cal reg clk inverse</comment>
        </bits>
        <bits access="rw" name="pha_dout_clk_inv" pos="9" rst="0x0">
          <comment>gro mode phase err reg clk inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_mdll_num" pos="8:6" rst="0x5">
          <comment>DLPF MDLL mode
000: 26x2MHz
001: 26x3MHz
010: 26x4MHz
011: 26x5MHz
100: 26x6MHz
101: 26x7MHz
110: 26x8MHz
111: 26x9MHz</comment>
        </bits>
        <bits access="rw" name="dlpf_notch_bypass" pos="5" rst="0x0">
          <comment>DLPF notch bypass</comment>
        </bits>
        <bits access="rw" name="dlpf_clk_inv1_reg" pos="4" rst="0x0">
          <comment>DLPF output clock inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_clk_inv0_reg" pos="3" rst="0x0">
          <comment>DLPF input clock inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_lock_mode" pos="2" rst="0x1">
          <comment>DLPF lock mode</comment>
        </bits>
        <bits access="rw" name="dlpf_en" pos="1" rst="0x0">
          <comment>enable DLPF</comment>
        </bits>
      </reg>
      <reg name="dlpf_dr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_dr_mode" pos="14" rst="0x0">
          <comment>DLPF output direct control</comment>
        </bits>
        <bits access="rw" name="dlpf_dr_value" pos="13:0" rst="0x2000">
          <comment>DLPF output direct value</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_pha_offset_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_pha_offset" pos="15:0" rst="0xc8">
          <comment>DLPF afc phase offset</comment>
        </bits>
      </reg>
      <reg name="dlpf_kdco_pha_offset_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_kdco_pha_offset" pos="15:0" rst="0xc8">
          <comment>DLPF kdco phase offset</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_afc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_afc" pos="12:0" rst="0xa8">
          <comment>DLPF gain kp afc</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_afc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_afc" pos="15:0" rst="0x3f">
          <comment>DLPF gain ki afc</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_2m_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_2m" pos="12:0" rst="0x698">
          <comment>DLPF gain kp 2m</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_2m_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_2m" pos="15:0" rst="0x27d">
          <comment>DLPF gain ki 2m</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_200k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_200k" pos="12:0" rst="0xa8">
          <comment>DLPF gain kp 200k</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_200k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_200k" pos="15:0" rst="0x3f">
          <comment>DLPF gain ki 200k</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_gain0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir0_gain0" pos="15:0" rst="0xf8dd">
          <comment>DLPF IIR0 gain0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_gain1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir0_gain1" pos="15:0" rst="0x391">
          <comment>DLPF IIR0 gain1[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_gain0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain0" pos="15:0" rst="0x8522">
          <comment>DLPF IIR1 gain0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_gain1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain1" pos="15:0" rst="0x3d6e">
          <comment>DLPF IIR1 gain1[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir_gain_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain1_msb" pos="3" rst="0x0">
          <comment>DLPF IIR1 gain1[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir1_gain0_msb" pos="2" rst="0x0">
          <comment>DLPF IIR1 gain0[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir0_gain1_msb" pos="1" rst="0x0">
          <comment>DLPF IIR0 gain1[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir0_gain0_msb" pos="0" rst="0x0">
          <comment>DLPF IIR0 gain0[16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_diff_sel_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_diff_sel" pos="2:0" rst="0x2">
          <comment>dlpf_diff_sel value is set to reserved value</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>afc_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_diff_thr_msb" pos="15:0" rst="0x8">
          <comment>afc_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_cnt_thr" pos="15:0" rst="0x64">
          <comment>minimum value of afc_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>lock_2m_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_diff_thr_msb" pos="15:0" rst="0x8">
          <comment>lock_2m_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_cnt_thr" pos="15:0" rst="0xc8">
          <comment>minimum value of lock_2m_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>lock_200k_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_diff_thr_msb" pos="15:0" rst="0x2">
          <comment>lock_200k_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_cnt_thr" pos="15:0" rst="0x258">
          <comment>minimum value of lock_200k_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer0_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer0_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer0_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer0_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer0_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer0_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer1_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer1_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer1_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer1_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer1_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer1_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer2_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer2_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer2_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer2_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer2_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer2_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_capture_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_capture_en" pos="0" rst="0x0">
          <comment>DLPF capture enable to dump internal values</comment>
        </bits>
      </reg>
      <reg name="dlpf_status0_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_afc_code" pos="12:2" rst="0x400">
          <comment>real time afc_code</comment>
        </bits>
        <bits access="r" name="dlpf_det_status" pos="1:0" rst="0x0">
          <comment>DLPF detect status</comment>
        </bits>
      </reg>
      <reg name="dlpf_status1_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_kdco_code" pos="13:0" rst="0x2000">
          <comment>read time kdco_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_code_status" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_afc_code_reg" pos="10:0" rst="0x0">
          <comment>captured afc_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_kdco_code_status" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_kdco_code_reg" pos="13:0" rst="0x0">
          <comment>captured kdco_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_tdc_code_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_tdc_code" pos="15:0" rst="0x0">
          <comment>tdc_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_l_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_l" pos="15:0" rst="0x0">
          <comment>dlpf_sum0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_m_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_m" pos="15:0" rst="0x0">
          <comment>dlpf_sum0[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_h_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_h" pos="6:0" rst="0x0">
          <comment>dlpf_sum0[38:32]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_data_lsb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir0_data_lsb" pos="15:0" rst="0x0">
          <comment>iir0_data[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_data_msb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir0_data_msb" pos="15:0" rst="0x0">
          <comment>iir0_data[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_data_lsb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir1_data_lsb" pos="15:0" rst="0x0">
          <comment>iir1_data[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_data_msb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir1_data_msb" pos="15:0" rst="0x0">
          <comment>iir1_data[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_ctrl_bit_reg" protect="rw">
        <comment/>
        <bits access="rw" name="capture_data_sel_tdc" pos="8" rst="0x1"/>
        <bits access="rw" name="sel_clk_out2_inv" pos="7" rst="0x0"/>
        <bits access="rw" name="sel_clk_out1_inv" pos="6" rst="0x0"/>
        <bits access="rw" name="kdco_polar_sel" pos="5" rst="0x0"/>
        <bits access="rw" name="kdco_agc_mode" pos="4" rst="0x0"/>
        <bits access="rw" name="2m_lock_bypass" pos="3" rst="0x0"/>
        <bits access="rw" name="afc_bypass" pos="2" rst="0x0"/>
        <bits access="rw" name="iir1_bypass" pos="1" rst="0x0"/>
        <bits access="rw" name="iir0_bypass" pos="0" rst="0x0"/>
      </reg>
      <reg name="gro_phase_tdc_cal" protect="rw">
        <comment/>
        <bits access="r" name="phase_tdc_cal" pos="15:0" rst="0x0"/>
      </reg>
      <hole size="6720"/>
      <reg name="dlpf_ctrl_reg_set" protect="rw"/>
      <hole size="1376"/>
      <reg name="dlpf_ctrl_bit_reg_set" protect="rw"/>
      <hole size="6752"/>
      <reg name="dlpf_ctrl_reg_clr" protect="rw"/>
      <hole size="1376"/>
      <reg name="dlpf_ctrl_bit_reg_clr" protect="rw"/>
    </module>
    <var name="REG_RF_RXDLPF_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_RXDLPF_CLR_OFFSET" value="0x800"/>
    <instance address="0x50037000" name="RF_RXDLPF" type="RF_RXDLPF"/>
  </archive>
  <archive relative="rf_sysctrl.xml">
    <module category="System" name="RF_SYSCTRL">
      <reg name="sysctrl1" protect="rw">
        <comment/>
        <bits access="rw" name="rg_sys_ctrl_pu_bbpll2_dr" pos="2" rst="0x0">
          <comment>1: pu_bbpll2 by reg
0: pu_bbpll2 by idle hw</comment>
        </bits>
        <bits access="rw" name="rg_sys_ctrl_pu_bbpll2" pos="1" rst="0x0">
          <comment>1:BBPLL2</comment>
        </bits>
        <bits access="rw" name="rg_sys_ctrl_pu_bbpll1" pos="0" rst="0x0">
          <comment>1:BBPLL1</comment>
        </bits>
      </reg>
      <reg name="sysctrl2" protect="rw">
        <comment/>
        <bits access="rw" name="rg_enable_clk26m_aux1" pos="2" rst="0x0">
          <comment>1clk 26m aux1</comment>
        </bits>
        <bits access="rw" name="rg_enable_clk26m_tsx_thm" pos="1" rst="0x0">
          <comment>1clk 26m tsx adc</comment>
        </bits>
        <bits access="rw" name="rg_enable_clk26m_osc_thm" pos="0" rst="0x0">
          <comment>1clk 26m osc adc</comment>
        </bits>
      </reg>
      <reg name="sysctrl3" protect="rw">
        <comment/>
        <bits access="rw" name="rg_bitmap_lte_rx_on" pos="10" rst="0x0">
          <comment>1lte rx onbitmapTXRXlte rx on</comment>
        </bits>
        <bits access="rw" name="gnss_coexist_ext" pos="9" rst="0x0">
          <comment>1ltegnssbitgnssgnssiq0</comment>
        </bits>
        <bits access="rw" name="gnss_int_mask_bit" pos="8" rst="0x0">
          <comment>1gnssbit</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_adc_wcn_clk_sel" pos="7" rst="0x1">
          <comment>1gnss adcgnss pll 66/33m
0gnss adcwifi pll 66/33mLTEgnssbbpll1bbpll1</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_adc_wcn_clk_en" pos="6" rst="0x0">
          <comment>1gnss adcwifi pll 66/33m</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_bb_pp_wcn_clk_sel" pos="5" rst="0x1">
          <comment>1gnss ppgnss pll 66/33m
0gnss ppwifi pll 66/33mLTEgnssbbpll1bbpll1</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_bb_pp_wcn_clk_en" pos="4" rst="0x0">
          <comment>1gnss ppwifi pll 66/33m</comment>
        </bits>
        <bits access="rw" name="rfdig_latch_gnss" pos="3" rst="0x0">
          <comment>1capture gnss ae/te</comment>
        </bits>
        <bits access="rw" name="rg_lte_iq_sel_0" pos="2" rst="0x0">
          <comment>1LTEIQ0</comment>
        </bits>
        <bits access="rw" name="rg_wifi_iq_sel_0" pos="1" rst="0x1">
          <comment>1WIFIIQ0</comment>
        </bits>
        <bits access="rw" name="rg_gnss_iq_sel_0" pos="0" rst="0x1">
          <comment>1GNSSIQ0</comment>
        </bits>
      </reg>
      <reg name="sysctrl4" protect="rw">
        <comment/>
        <bits access="rw" name="rg_ram_clk_auto_cg" pos="7:6" rst="0x3">
          <comment>1:riscv ramauto gate</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_sclk_auto_gate_en" pos="5" rst="0x0">
          <comment>1aonrfahb async bridge slaveauto gate</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_mclk_auto_gate_en" pos="4" rst="0x0">
          <comment>1aonrfahb async bridge masterauto gate</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_nonbuf_early_resp_en" pos="3" rst="0x0">
          <comment>1aonrfahb async bridge early response</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_sclk_auto_gate_en" pos="2" rst="0x0">
          <comment>1rfaonahb async bridge slaveauto gate</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_mclk_auto_gate_en" pos="1" rst="0x0">
          <comment>1rfaonahb async bridge masterauto gate</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_nonbuf_early_resp_en" pos="0" rst="0x0">
          <comment>1rfaonahb async bridge early response</comment>
        </bits>
      </reg>
      <reg name="sysctrl5" protect="rw">
        <comment/>
        <bits access="rw" name="rg_pwd_adc_clkedge_sel" pos="13" rst="0x0">
          <comment>1power detector adc</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_sel_rxdlpf_afc" pos="12" rst="0x0">
          <comment>1:adda test mode=5,rxdlpf mode, debug data sel dafc and tdc_code
0:adda test mode=5,rxdlpf mode, debug data sel kdco and tdc_code</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_sel_txdlpf_afc" pos="11" rst="0x0">
          <comment>1:adda test mode=4,txdlpf mode, debug data sel dafc and tdc_code
0:adda test mode=4,txdlpf mode, debug data sel kdco and tdc_code</comment>
        </bits>
        <bits access="rw" name="rg_osc_adc_clkedge_sel" pos="10" rst="0x0">
          <comment>1oscadc</comment>
        </bits>
        <bits access="rw" name="rg_tsx_adc_clkedge_sel" pos="9" rst="0x0">
          <comment>1tsxadc</comment>
        </bits>
        <bits access="rw" name="rg_rf_test_pad_en" pos="8" rst="0x0">
          <comment>1rf analog pad
0rf analog padhigh-z</comment>
        </bits>
        <bits access="rw" name="rg_hresp_err_mask" pos="7" rst="0x0">
          <comment>1riscvAHB response error</comment>
        </bits>
        <bits access="rw" name="rg_dfe_dump_sel_bit" pos="6:4" rst="0x0">
          <comment>dfe dump
000dfe dump
0014
0013
0102
0111</comment>
        </bits>
        <bits access="rw" name="rg_adc_clkedge_sel" pos="3" rst="0x0">
          <comment>1adc</comment>
        </bits>
        <bits access="rw" name="rg_rtc_clkedge_sel" pos="2" rst="0x1">
          <comment>1rf analogrtc</comment>
        </bits>
        <bits access="rw" name="rg_lte_dac_clkedge_sel" pos="1" rst="0x1">
          <comment>1rf analogdac</comment>
        </bits>
        <bits access="rw" name="rg_lte_dac_clk_en" pos="0" rst="0x1">
          <comment>1rf analogdac</comment>
        </bits>
      </reg>
      <reg name="sysctrl6" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxdlpf_soft_rst" pos="7" rst="0x1">
          <comment>1rxdlpf</comment>
        </bits>
        <bits access="rw" name="rg_txdlpf_soft_rst" pos="6" rst="0x1">
          <comment>1txdlpf</comment>
        </bits>
        <bits access="rw" name="rg_dfe_thm_osc_soft_rst" pos="5" rst="0x1">
          <comment>1dfe osc temper</comment>
        </bits>
        <bits access="rw" name="rg_dfe_thm_tsx_soft_rst" pos="4" rst="0x1">
          <comment>1dfe tsx temper</comment>
        </bits>
        <bits access="rw" name="rg_dfe_pwd_soft_rst" pos="3" rst="0x1">
          <comment>1dfe pwd</comment>
        </bits>
        <bits access="rw" name="rg_dfe_txdp_soft_rst" pos="2" rst="0x1">
          <comment>1dfe tx</comment>
        </bits>
        <bits access="rw" name="rg_dfe_rxdp_soft_rst" pos="1" rst="0x1">
          <comment>1dfe rx</comment>
        </bits>
        <bits access="rw" name="rg_dfe_cgu_soft_rst" pos="0" rst="0x0">
          <comment>1dfe clkrst</comment>
        </bits>
      </reg>
      <reg name="sysctrl7" protect="rw">
        <comment/>
        <bits access="rw" name="ptest_func_atspeed_sel" pos="2" rst="0x0">
          <comment>no use</comment>
        </bits>
        <bits access="rw" name="rg_mipi_clk_half_en" pos="1" rst="0x0">
          <comment>1mipi13m
0mipi26m</comment>
        </bits>
        <bits access="rw" name="rg_usid_change_en" pos="0" rst="0x0">
          <comment>1usidtrigger</comment>
        </bits>
      </reg>
      <reg name="sysctrl8" protect="rw">
        <comment/>
        <bits access="rw" name="rg_thm_osc_26m_auto_gate_en" pos="14" rst="0x0">
          <comment>1rf analogosc 26mauto gate</comment>
        </bits>
        <bits access="rw" name="rg_thm_tsx_26m_auto_gate_en" pos="13" rst="0x0">
          <comment>1rf analogtsx 26mauto gate</comment>
        </bits>
        <bits access="rw" name="rg_bbpll_122m_auto_gate_en" pos="12" rst="0x0">
          <comment>1rf analogbbpll2 122.88mauto gate</comment>
        </bits>
        <bits access="rw" name="rg_bbpll_245m_auto_gate_en" pos="11" rst="0x0">
          <comment>1rf analogbbpll2 245.76mauto gate</comment>
        </bits>
        <bits access="rw" name="rg_wcn_bbpll_80m_auto_gate_en" pos="10" rst="0x0">
          <comment>1rf analogbbpll1 80mauto gate</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_auto_gate_en" pos="7" rst="0x0">
          <comment>1aonrfAHB async bridgeauto gate</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_auto_gate_en" pos="6" rst="0x0">
          <comment>1rfaonAHB async bridgeauto gate</comment>
        </bits>
        <bits access="rw" name="rg_cgm_dfe_245m76_en" pos="5" rst="0x1">
          <comment>1dfe245.76malways 1</comment>
        </bits>
        <bits access="rw" name="rg_cgm_26m_interface_en" pos="4" rst="0x1">
          <comment>1rf dig26malways 1</comment>
        </bits>
        <bits access="rw" name="rg_cgm_ahb_en" pos="3" rst="0x1">
          <comment>1rf_digahbalways 1</comment>
        </bits>
        <bits access="rw" name="rg_ahb_freq_auto_sel" pos="2" rst="0x0">
          <comment>1ahbrg_cgm_chb_sel10PLLahb26m</comment>
        </bits>
        <bits access="rw" name="rg_cgm_ahb_sel" pos="1:0" rst="0x0">
          <comment>00dcxo 26m
01wifi bbpll 80m
10lte bbpll 122.88m
11gnss pll 133m</comment>
        </bits>
      </reg>
      <reg name="sysctrl9" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cgm_thm_tsx_bist_en" pos="14" rst="0x1">
          <comment>1ATEtsen bist</comment>
        </bits>
        <bits access="rw" name="rg_cgm_thm_tsx_pad_en" pos="13" rst="0x0">
          <comment>1PADtsx</comment>
        </bits>
        <bits access="rw" name="rg_cgm_thm_tsx_dfe_en" pos="12" rst="0x1">
          <comment>1DFEtsx</comment>
        </bits>
        <bits access="rw" name="rg_cgm_thm_osc_pad_en" pos="11" rst="0x0">
          <comment>1PADosc</comment>
        </bits>
        <bits access="rw" name="rg_cgm_thm_osc_en" pos="10" rst="0x1">
          <comment>1dfe osc</comment>
        </bits>
        <bits access="rw" name="rg_cgm_lte_adc_en" pos="9" rst="0x1">
          <comment>1dfe adc</comment>
        </bits>
        <bits access="rw" name="rg_pwd_dfe_pwd_en" pos="8" rst="0x1">
          <comment>1dfe pwd</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_peak_det_en" pos="7" rst="0x1">
          <comment>1peak detector26m</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_bbpll2_en" pos="6" rst="0x1">
          <comment>1bbpll2 sdm26m</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_bbpll1_en" pos="5" rst="0x1">
          <comment>1bbpll1 sdm26m</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_txpll_cal_en" pos="4" rst="0x1">
          <comment>1txpll calibration26m</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_rxpll_cal_en" pos="3" rst="0x1">
          <comment>1rxpll calibration26m</comment>
        </bits>
        <bits access="rw" name="rg_26m_interface_intf_en" pos="2" rst="0x1">
          <comment>1rf interface reg26m</comment>
        </bits>
        <bits access="rw" name="rg_rffe_clk_en" pos="1" rst="0x1">
          <comment>1rffe</comment>
        </bits>
        <bits access="rw" name="rg_rtc_clk_en" pos="0" rst="0x1">
          <comment>1rtc</comment>
        </bits>
      </reg>
      <reg name="sysctrl10" protect="rw">
        <comment/>
        <bits access="rw" name="rg_cgm_rf_bitmap_en" pos="12" rst="0x1">
          <comment>1rf bitmap</comment>
        </bits>
        <bits access="rw" name="rg_ahb_wdg_en" pos="11" rst="0x1">
          <comment>1wdg</comment>
        </bits>
        <bits access="rw" name="rg_ahb_timer0_en" pos="10" rst="0x1">
          <comment>1timer</comment>
        </bits>
        <bits access="rw" name="rg_ahb_pulp_en" pos="9" rst="0x1">
          <comment>1riscv</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_en" pos="8" rst="0x1">
          <comment>1aonrf AHB</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_en" pos="7" rst="0x1">
          <comment>1rfaon AHB</comment>
        </bits>
        <bits access="rw" name="rg_ahb_txdlpf_en" pos="6" rst="0x1">
          <comment>1txdlpf</comment>
        </bits>
        <bits access="rw" name="rg_ahb_rxdlpf_en" pos="5" rst="0x1">
          <comment>1rxdlpf</comment>
        </bits>
        <bits access="rw" name="rg_ahb_spi2ahb_en" pos="4" rst="0x1">
          <comment>1spi2ahb</comment>
        </bits>
        <bits access="rw" name="rg_ahb_ram_en" pos="3" rst="0x1">
          <comment>1riscv ram</comment>
        </bits>
        <bits access="rw" name="rg_ahb_intf_en" pos="2" rst="0x1">
          <comment>1rf interface regahb</comment>
        </bits>
        <bits access="rw" name="rg_ahb_dfe_en" pos="1" rst="0x1">
          <comment>1dfe</comment>
        </bits>
        <bits access="rw" name="rg_ahb_bus_en" pos="0" rst="0x1">
          <comment>1matrix</comment>
        </bits>
      </reg>
      <reg name="sysctrl11" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rx_gro_out2_rxdlpf_en" pos="7" rst="0x1">
          <comment>1rxdlpf gro out2</comment>
        </bits>
        <bits access="rw" name="rg_rx_gro_out1_rxdlpf_en" pos="6" rst="0x1">
          <comment>1rxdlpf gro out1</comment>
        </bits>
        <bits access="rw" name="rg_tx_gro_out2_txdlpf_en" pos="5" rst="0x1">
          <comment>1txdlpf gro out2</comment>
        </bits>
        <bits access="rw" name="rg_tx_gro_out1_txdlpf_en" pos="4" rst="0x1">
          <comment>1txdlpf gro out1</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_sdm_rxsdm_en" pos="3" rst="0x1">
          <comment>1rxpll sdm</comment>
        </bits>
        <bits access="rw" name="rg_txpll_sdm_txsdm_en" pos="2" rst="0x1">
          <comment>1txpll sdm</comment>
        </bits>
        <bits access="rw" name="rg_cgm_lpll_sdm_en" pos="1" rst="0x1">
          <comment>1lte bbpll sdm</comment>
        </bits>
        <bits access="rw" name="rg_cgm_wpll_sdm_en" pos="0" rst="0x1">
          <comment>1wifi bbpll sdm</comment>
        </bits>
      </reg>
      <reg name="sysctrl12" protect="rw">
        <comment/>
        <bits access="rw" name="thm_osc_26m_cnt_done_bypass" pos="15" rst="0x1">
          <comment>1oscbypass
0puenable</comment>
        </bits>
        <bits access="rw" name="thm_tsx_26m_cnt_done_bypass" pos="14" rst="0x1">
          <comment>1tsxbypass
0puenable</comment>
        </bits>
        <bits access="rw" name="adc_122m_cnt_done_bypass" pos="13" rst="0x1">
          <comment>1adcbypass
0puenable</comment>
        </bits>
        <bits access="rw" name="bbpll_122m_cnt_done_bypass" pos="12" rst="0x1">
          <comment>1bbpll2bypass
0pulock</comment>
        </bits>
        <bits access="rw" name="bbpll_245m_cnt_done_bypass" pos="11" rst="0x1">
          <comment>1bbpll2bypass
0pulock</comment>
        </bits>
        <bits access="rw" name="wcn_bbpll_80m_cnt_done_bypass" pos="10" rst="0x1">
          <comment>1bbpll1bypass
0pulock</comment>
        </bits>
        <bits access="rw" name="gnss_pll_198m_cnt_done_bypass" pos="9" rst="0x1">
          <comment>1gnss pllbypass
0pulock</comment>
        </bits>
        <bits access="rw" name="gnss_pll_397m_cnt_done_bypass" pos="8" rst="0x1">
          <comment>1gnss pllbypass
0pulock</comment>
        </bits>
        <bits access="rw" name="thm_osc_26m_soft_cnt_done" pos="7" rst="0x1">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="thm_tsx_26m_soft_cnt_done" pos="6" rst="0x1">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="adc_122m_soft_cnt_done" pos="5" rst="0x1">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="bbpll_122m_soft_cnt_done" pos="4" rst="0x1">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="bbpll_245m_soft_cnt_done" pos="3" rst="0x1">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="wcn_bbpll_80m_soft_cnt_done" pos="2" rst="0x1">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="gnss_pll_198m_soft_cnt_done" pos="1" rst="0x1">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="gnss_pll_397m_soft_cnt_done" pos="0" rst="0x1">
          <comment>1</comment>
        </bits>
      </reg>
      <reg name="sysctrl13" protect="rw">
        <comment/>
        <bits access="rw" name="thm_osc_26m_wait_force_en" pos="15" rst="0x1">
          <comment>1wait auto gate sel=0</comment>
        </bits>
        <bits access="rw" name="thm_tsx_26m_wait_force_en" pos="14" rst="0x1">
          <comment>1wait auto gate sel=0</comment>
        </bits>
        <bits access="rw" name="adc_122m_wait_force_en" pos="13" rst="0x1">
          <comment>1wait auto gate sel=0</comment>
        </bits>
        <bits access="rw" name="bbpll_122m_wait_force_en" pos="12" rst="0x1">
          <comment>1wait auto gate sel=0</comment>
        </bits>
        <bits access="rw" name="bbpll_245m_wait_force_en" pos="11" rst="0x1">
          <comment>1wait auto gate sel=0</comment>
        </bits>
        <bits access="rw" name="wcn_bbpll_80m_wait_force_en" pos="10" rst="0x1">
          <comment>1wait auto gate sel=0</comment>
        </bits>
        <bits access="rw" name="gnss_pll_198m_wait_force_en" pos="9" rst="0x1">
          <comment>1wait auto gate sel=0</comment>
        </bits>
        <bits access="rw" name="gnss_pll_397m_wait_force_en" pos="8" rst="0x1">
          <comment>1wait auto gate sel=0</comment>
        </bits>
        <bits access="rw" name="thm_osc_26m_wait_auto_gate_sel" pos="7" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="thm_tsx_26m_wait_auto_gate_sel" pos="6" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="adc_122m_wait_auto_gate_sel" pos="5" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="bbpll_122m_wait_auto_gate_sel" pos="4" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="bbpll_245m_wait_auto_gate_sel" pos="3" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="wcn_bbpll_80m_wait_auto_gate_sel" pos="2" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="gnss_pll_198m_wait_auto_gate_sel" pos="1" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="gnss_pll_397m_wait_auto_gate_sel" pos="0" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
      </reg>
      <reg name="sysctrl14" protect="rw">
        <comment/>
        <bits access="rw" name="gnss_div_pll_397m_33m1_auto_gate_sel" pos="7" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_56m7_auto_gate_sel" pos="6" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_132m3_auto_gate_sel" pos="5" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_158m8_auto_gate_sel" pos="4" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_33m1_force_en" pos="3" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_56m7_force_en" pos="2" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_132m3_force_en" pos="1" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="gnss_div_pll_397m_158m8_force_en" pos="0" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
      </reg>
      <reg name="sysctrl15" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_gnss_pll_397m_pub_auto_gate_sel" pos="12" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_122_88m_lte_auto_gate_sel" pos="11" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_245_76m_lte_auto_gate_sel" pos="10" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_thm_osc_26m_cp_auto_gate_sel" pos="9" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_thm_tsx_26m_cp_auto_gate_sel" pos="8" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_adc_iq_cp_auto_gate_sel" pos="7" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_cp_auto_gate_sel" pos="6" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_cp_auto_gate_sel" pos="5" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_cp_auto_gate_sel" pos="4" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_57m_ap_auto_gate_sel" pos="3" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_ap_auto_gate_sel" pos="2" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_ap_auto_gate_sel" pos="1" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_ap_auto_gate_sel" pos="0" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
      </reg>
      <reg name="sysctrl16" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_adc_iq_gnss_auto_gate_sel" pos="14" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_gnss_auto_gate_sel" pos="13" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_158m_gnss_auto_gate_sel" pos="12" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_gnss_auto_gate_sel" pos="11" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_33m_aon_auto_gate_sel" pos="10" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_aon_auto_gate_sel" pos="9" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_aon_auto_gate_sel" pos="8" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_aon_auto_gate_sel" pos="7" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_thm_osc_26m_rf_auto_gate_sel" pos="6" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_thm_tsx_26m_rf_auto_gate_sel" pos="5" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_adc_iq_rf_auto_gate_sel" pos="4" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_rf_auto_gate_sel" pos="3" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_rf_auto_gate_sel" pos="2" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_122_88m_rf_auto_gate_sel" pos="1" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_245_76m_rf_auto_gate_sel" pos="0" rst="0x1">
          <comment>1auto gating</comment>
        </bits>
      </reg>
      <reg name="sysctrl17" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_gnss_pll_397m_pub_force_en" pos="12" rst="0x1">
          <comment>1auto gate sel=0</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_122_88m_lte_force_en" pos="11" rst="0x1">
          <comment>1auto gate sel=1</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_245_76m_lte_force_en" pos="10" rst="0x1">
          <comment>1auto gate sel=2</comment>
        </bits>
        <bits access="rw" name="cgm_thm_osc_26m_cp_force_en" pos="9" rst="0x1">
          <comment>1auto gate sel=3</comment>
        </bits>
        <bits access="rw" name="cgm_thm_tsx_26m_cp_force_en" pos="8" rst="0x1">
          <comment>1auto gate sel=4</comment>
        </bits>
        <bits access="rw" name="cgm_adc_iq_cp_force_en" pos="7" rst="0x1">
          <comment>1auto gate sel=5</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_cp_force_en" pos="6" rst="0x1">
          <comment>1auto gate sel=6</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_cp_force_en" pos="5" rst="0x1">
          <comment>1auto gate sel=7</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_cp_force_en" pos="4" rst="0x1">
          <comment>1auto gate sel=8</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_57m_ap_force_en" pos="3" rst="0x1">
          <comment>1auto gate sel=9</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_ap_force_en" pos="2" rst="0x1">
          <comment>1auto gate sel=10</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_ap_force_en" pos="1" rst="0x1">
          <comment>1auto gate sel=11</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_ap_force_en" pos="0" rst="0x1">
          <comment>1auto gate sel=12</comment>
        </bits>
      </reg>
      <reg name="sysctrl18" protect="rw">
        <comment/>
        <bits access="rw" name="cgm_adc_iq_gnss_force_en" pos="14" rst="0x1">
          <comment>1auto gate sel=14</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_gnss_force_en" pos="13" rst="0x1">
          <comment>1auto gate sel=15</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_158m_gnss_force_en" pos="12" rst="0x1">
          <comment>1auto gate sel=16</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_gnss_force_en" pos="11" rst="0x1">
          <comment>1auto gate sel=17</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_33m_aon_force_en" pos="10" rst="0x1">
          <comment>1auto gate sel=18</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_aon_force_en" pos="9" rst="0x1">
          <comment>1auto gate sel=19</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_198_5m_aon_force_en" pos="8" rst="0x1">
          <comment>1auto gate sel=20</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_397m_aon_force_en" pos="7" rst="0x1">
          <comment>1auto gate sel=21</comment>
        </bits>
        <bits access="rw" name="cgm_thm_osc_26m_rf_force_en" pos="6" rst="0x1">
          <comment>1auto gate sel=22</comment>
        </bits>
        <bits access="rw" name="cgm_thm_tsx_26m_rf_force_en" pos="5" rst="0x1">
          <comment>1auto gate sel=23</comment>
        </bits>
        <bits access="rw" name="cgm_adc_iq_rf_force_en" pos="4" rst="0x1">
          <comment>1auto gate sel=24</comment>
        </bits>
        <bits access="rw" name="cgm_gnss_pll_133m_rf_force_en" pos="3" rst="0x1">
          <comment>1auto gate sel=25</comment>
        </bits>
        <bits access="rw" name="cgm_wcn_bbpll_80m_rf_force_en" pos="2" rst="0x1">
          <comment>1auto gate sel=26</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_122_88m_rf_force_en" pos="1" rst="0x1">
          <comment>1auto gate sel=27</comment>
        </bits>
        <bits access="rw" name="cgm_bbpll_245_76m_rf_force_en" pos="0" rst="0x1">
          <comment>1auto gate sel=28</comment>
        </bits>
      </reg>
      <reg name="sysctrl19" protect="rw">
        <comment/>
        <bits access="rw" name="rg_tsen_bist_soft_rst" pos="3" rst="0x0">
          <comment>1ATEtsen bist</comment>
        </bits>
        <bits access="rw" name="rg_rf_bitmap_soft_rst" pos="2" rst="0x0">
          <comment>1bitmap</comment>
        </bits>
        <bits access="rw" name="rg_rf2aon_soft_rst" pos="1" rst="0x0">
          <comment>1rfaonAHB async bridge</comment>
        </bits>
        <bits access="rw" name="rg_aon2rf_soft_rst" pos="0" rst="0x0">
          <comment>1aonrfAHB async bridge</comment>
        </bits>
      </reg>
      <reg name="sysctrl20" protect="rw">
        <comment/>
        <bits access="rw" name="rg_dfe_reg_soft_rst" pos="15" rst="0x0">
          <comment>1dfe</comment>
        </bits>
        <bits access="rw" name="rg_intf_clkgen_soft_rst" pos="14" rst="0x0">
          <comment>1rf interfaceclk div</comment>
        </bits>
        <bits access="rw" name="rg_intf_irq_ctrl_soft_rst" pos="13" rst="0x0">
          <comment>1rf interfaceirq handler</comment>
        </bits>
        <bits access="rw" name="rg_intf_peak_det_soft_rst" pos="12" rst="0x0">
          <comment>1rf interfacepeak det</comment>
        </bits>
        <bits access="rw" name="rg_intf_apb_reg_soft_rst" pos="11" rst="0x0">
          <comment>1rf interface</comment>
        </bits>
        <bits access="rw" name="rg_spi2ahb_soft_rst" pos="10" rst="0x0">
          <comment>1spi2ahb</comment>
        </bits>
        <bits access="rw" name="rg_rtc_soft_rst" pos="9" rst="0x0">
          <comment>1riscvrf dig rtc</comment>
        </bits>
        <bits access="rw" name="rg_ana_regs_soft_rst" pos="8" rst="0x0">
          <comment>1rf analog reg</comment>
        </bits>
        <bits access="rw" name="rg_rffe_soft_rst" pos="7" rst="0x0">
          <comment>1rffe</comment>
        </bits>
        <bits access="rw" name="rg_wdg_soft_rst" pos="6" rst="0x0">
          <comment>1wdg</comment>
        </bits>
        <bits access="rw" name="rg_timer0_soft_rst" pos="5" rst="0x0">
          <comment>1timer0</comment>
        </bits>
        <bits access="rw" name="rg_rxdlpf_reg_soft_rst" pos="4" rst="0x0">
          <comment>1rxdlpf</comment>
        </bits>
        <bits access="rw" name="rg_txdlpf_reg_soft_rst" pos="3" rst="0x0">
          <comment>1txdlpf</comment>
        </bits>
        <bits access="rw" name="rg_ram_soft_rst" pos="2" rst="0x0">
          <comment>1riscv ram</comment>
        </bits>
        <bits access="rw" name="rg_dbg_soft_rst" pos="1" rst="0x0">
          <comment>1riscvdebug</comment>
        </bits>
        <bits access="rw" name="rg_riscv_soft_rst" pos="0" rst="0x1">
          <comment>1riscv</comment>
        </bits>
      </reg>
      <reg name="sysctrl21" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rf_gpio_o" pos="9:0" rst="0x0">
          <comment>1rfdig gpio</comment>
        </bits>
      </reg>
      <reg name="sysctrl22" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rf_gpio_oen" pos="9:0" rst="0x3ff">
          <comment>1rfidg gpio</comment>
        </bits>
      </reg>
      <reg name="sysctrl23" protect="rw">
        <comment/>
        <bits access="rw" name="rg_simc_pa_on" pos="11" rst="0x0">
          <comment>1rg_simc_pa_en=0PAsimc auto gate</comment>
        </bits>
        <bits access="rw" name="rg_simc_pa_en" pos="10" rst="0x0">
          <comment>1APCrg_simc_pa_on_thsimc auto gatesimc</comment>
        </bits>
        <bits access="rw" name="rg_simc_pa_on_th" pos="9:0" rst="0x0">
          <comment>simcPA</comment>
        </bits>
      </reg>
      <reg name="sysctrl24" protect="rw">
        <comment/>
        <bits access="rw" name="rg_sysctrl_soft_rst" pos="0" rst="0x0">
          <comment>1sysctrl</comment>
        </bits>
      </reg>
      <reg name="sysctrl25" protect="rw">
        <comment/>
        <bits access="rw" name="rg_rxpll_gro_rstn_hw_ctrl_en" pos="14" rst="0x1">
          <comment>1rf analoggro rstAAFCOPEN_EN</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_dlpf_rstn_hw_ctrl_en" pos="13" rst="0x1">
          <comment>1rf analogdlpfdlpf rstnAAFCOPEN_EN</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_pkden_hw_ctrl_en" pos="12" rst="0x1">
          <comment>1rf analogvco pkdetAAFCvco pkdet</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_open_hw_ctrl_en" pos="11" rst="0x1">
          <comment>1rf analogopen_enAAFCOPEN_EN</comment>
        </bits>
        <bits access="rw" name="rg_txpll_gro_rstn_hw_ctrl_en" pos="10" rst="0x1">
          <comment>1rf analoggro rstAAFCOPEN_EN</comment>
        </bits>
        <bits access="rw" name="rg_txpll_dlpf_rstn_hw_ctrl_en" pos="9" rst="0x1">
          <comment>1rf analogdlpfdlpf rstnAAFCOPEN_EN</comment>
        </bits>
        <bits access="rw" name="rg_txpll_pkden_hw_ctrl_en" pos="8" rst="0x1">
          <comment>1rf analogvco pkdetAAFCvco pkdet</comment>
        </bits>
        <bits access="rw" name="rg_txpll_open_hw_ctrl_en" pos="7" rst="0x1">
          <comment>1rf analogopen_enAAFCOPEN_EN</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_mode_sel" pos="6:4" rst="0x0">
          <comment>adda
000adcdferam
001adcdferam
010dfe dumpram
011dac
100txdlpf
101txdlpf
110rxdlpf
111rxdlpf</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_mode" pos="3" rst="0x0">
          <comment>1adda</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_dac_sel" pos="2" rst="0x0">
          <comment>1dacramdfe
0dacramdfe</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_en" pos="1" rst="0x0">
          <comment>1adda</comment>
        </bits>
        <bits access="rw" name="rg_adda_test_soft_rst" pos="0" rst="0x1">
          <comment>1adda</comment>
        </bits>
      </reg>
      <reg name="sysstat1" protect="rw">
        <comment/>
        <bits access="r" name="rf_gpio_i" pos="9:0" rst="0x0">
          <comment>rfdig gpio</comment>
        </bits>
      </reg>
      <reg name="sysstat2" protect="rw">
        <comment/>
        <bits access="r" name="rf_dbg_monitor" pos="7:0" rst="0x0">
          <comment>rfdig monitor</comment>
        </bits>
      </reg>
      <reg name="sysctrl26" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain0" pos="15:0" rst="0x0">
          <comment>wifi agc gain table0wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl27" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain1" pos="15:0" rst="0x0">
          <comment>wifi agc gain table1wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl28" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain2" pos="15:0" rst="0x0">
          <comment>wifi agc gain table2wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl29" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain3" pos="15:0" rst="0x0">
          <comment>wifi agc gain table3wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl30" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain4" pos="15:0" rst="0x0">
          <comment>wifi agc gain table4wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl31" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain5" pos="15:0" rst="0x0">
          <comment>wifi agc gain table5wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl32" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain6" pos="15:0" rst="0x0">
          <comment>wifi agc gain table6wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl33" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain7" pos="15:0" rst="0x0">
          <comment>wifi agc gain table7wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl34" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain8" pos="15:0" rst="0x0">
          <comment>wifi agc gain table8wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl35" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain9" pos="15:0" rst="0x0">
          <comment>wifi agc gain table9wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl36" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain10" pos="15:0" rst="0x0">
          <comment>wifi agc gain table10wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl37" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain11" pos="15:0" rst="0x0">
          <comment>wifi agc gain table11wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl38" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain12" pos="15:0" rst="0x0">
          <comment>wifi agc gain table12wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl39" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain13" pos="15:0" rst="0x0">
          <comment>wifi agc gain table13wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl40" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain14" pos="15:0" rst="0x0">
          <comment>wifi agc gain table14wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl41" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain15" pos="15:0" rst="0x0">
          <comment>wifi agc gain table15wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysstat3" protect="rw">
        <comment/>
        <bits access="r" name="wlan_gain_index" pos="3:0" rst="0x0">
          <comment>wlanauto gac index</comment>
        </bits>
      </reg>
      <reg name="sysctrl42" protect="rw">
        <comment/>
        <bits access="rw" name="rg_gain_out_sel_wifi" pos="4" rst="0x0">
          <comment>1WIFIrf analogagc gainauto gac indexwifi_gain0-15rf analogwifi gain pga/rxflt dccal i/q
0LTEGNSSrf analogagc gainpga/rxflt dccal i/q</comment>
        </bits>
        <bits access="rw" name="rg_dc_qcal_sel" pos="3:2" rst="0x0">
          <comment>00rf analogpga I
01rf analogpga Idfedac sine
10rf analogpga Idfedac sine
11rf analogpga I0</comment>
        </bits>
        <bits access="rw" name="rg_dc_ical_sel" pos="1:0" rst="0x0">
          <comment>00rf analogpga Q
01rf analogpga Qdfedac sine
10rf analogpga Qdfedac sine
11rf analogpga Q0</comment>
        </bits>
      </reg>
      <reg name="sysctrl43" protect="rw">
        <comment/>
        <bits access="rw" name="rg_dc_qcal_offset" pos="15:8" rst="0x0">
          <comment>rf analogpga Idfedac sineoffset</comment>
        </bits>
        <bits access="rw" name="rg_dc_ical_offset" pos="7:0" rst="0x0">
          <comment>rf analogpga Qdfedac sineoffset</comment>
        </bits>
      </reg>
      <reg name="sysctrl44" protect="rw">
        <comment/>
      </reg>
      <reg name="sysctrl45" protect="rw">
        <comment/>
      </reg>
      <reg name="sysstat4" protect="rw">
        <comment/>
      </reg>
      <reg name="sysstat5" protect="rw">
        <comment/>
        <bits access="r" name="cgm_ahb_sel_ac" pos="9:8" rst="0x0">
          <comment>ahb clkahb freq sel</comment>
        </bits>
        <bits access="r" name="adda_test_mem_full" pos="0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="sysctrl46" protect="rw">
        <comment/>
        <bits access="rw" name="rg_txpll_gro_auto_ctrl_en" pos="11" rst="0x1">
          <comment>1txpll gro</comment>
        </bits>
        <bits access="rw" name="rg_rxpll_gro_auto_ctrl_en" pos="10" rst="0x1">
          <comment>1rxpll gro</comment>
        </bits>
        <bits access="rw" name="rg_pll_gro_stab_time" pos="9:0" rst="0x186">
          <comment>txpll/rxpll gro</comment>
        </bits>
      </reg>
      <reg name="sysctrl47" protect="rw">
        <comment/>
        <bits access="rw" name="rg_adc_enh_bb_force" pos="14" rst="0x1">
          <comment>LTE2GNSS RXadc_enh_bb_force=0ADCadc_enh_bb=0adc_enh_bb_force=1ADCrg_adc_auto_ctrl_en</comment>
        </bits>
        <bits access="rw" name="rg_adc_clk_enh_bb_force" pos="13" rst="0x1">
          <comment>LTE2GNSS RXadc_clk_enh_bb_force=0ADCadc_clk_enh_bb=0adc_clk_enh_bb_force=1ADCrg_adc_auto_ctrl_en</comment>
        </bits>
        <bits access="rw" name="rg_adc_auto_ctrl_en" pos="12" rst="0x0">
          <comment>1adc</comment>
        </bits>
        <bits access="rw" name="rg_adc_bias_en_cnt" pos="11:0" rst="0x186">
          <comment>adc bias</comment>
        </bits>
      </reg>
      <reg name="sysctrl48" protect="rw">
        <comment/>
        <bits access="rw" name="rg_adc_clk_enh_cnt" pos="11:0" rst="0x30c">
          <comment>adc clk enh</comment>
        </bits>
      </reg>
      <reg name="sysctrl49" protect="rw">
        <comment/>
        <bits access="rw" name="rg_pwdadc_auto_ctrl_en" pos="12" rst="0x0">
          <comment>1pwdadc</comment>
        </bits>
        <bits access="rw" name="rg_pwdadc_bias_en_cnt" pos="11:0" rst="0x186">
          <comment>pwdadc bias</comment>
        </bits>
      </reg>
      <reg name="sysctrl50" protect="rw">
        <comment/>
        <bits access="rw" name="rg_pwdadc_clk_enh_cnt" pos="11:0" rst="0x30c">
          <comment>pwdadc clk enh</comment>
        </bits>
      </reg>
      <reg name="sysctrl51" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain0_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table0Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain0_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table0Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl52" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain1_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table1Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain1_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table1Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl53" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain2_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table2Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain2_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table2Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl54" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain3_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table3Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain3_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table3Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl55" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain4_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table4Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain4_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table4Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl56" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain5_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table5Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain5_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table5Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl57" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain6_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table6Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain6_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table6Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl58" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain7_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table7Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain7_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table7Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl59" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain8_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table8Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain8_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table8Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl60" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain9_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table9Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain9_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table9Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl61" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain10_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table10Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain10_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table10Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl62" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain11_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table11Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain11_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table11Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl63" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain12_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table12Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain12_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table12Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl64" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain13_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table13Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain13_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table13Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl65" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain14_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table14Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain14_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table14Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl66" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain15_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table15Qpga dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain15_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table15Ipga dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl67" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain0_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table0Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain0_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table0Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl68" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain1_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table1Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain1_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table1Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl69" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain2_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table2Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain2_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table2Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl70" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain3_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table3Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain3_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table3Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl71" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain4_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table4Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain4_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table4Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl72" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain5_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table5Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain5_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table5Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl73" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain6_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table6Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain6_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table6Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl74" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain7_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table7Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain7_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table7Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl75" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain8_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table8Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain8_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table8Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl76" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain9_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table9Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain9_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table9Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl77" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain10_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table10Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain10_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table10Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl78" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain11_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table11Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain11_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table11Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl79" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain12_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table12Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain12_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table12Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl80" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain13_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table13Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain13_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table13Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl81" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain14_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table14Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain14_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table14Irxflt dc</comment>
        </bits>
      </reg>
      <reg name="sysctrl82" protect="rw">
        <comment/>
        <bits access="rw" name="rg_wifi_gain15_rxflt_dccal_q" pos="15:8" rst="0x80">
          <comment>wifi gain table15Qrxflt dc</comment>
        </bits>
        <bits access="rw" name="rg_wifi_gain15_rxflt_dccal_i" pos="7:0" rst="0x80">
          <comment>wifi gain table15Irxflt dc</comment>
        </bits>
      </reg>
      <hole size="5408"/>
      <reg name="sysctrl1_set" protect="rw"/>
      <reg name="sysctrl2_set" protect="rw"/>
      <reg name="sysctrl3_set" protect="rw"/>
      <reg name="sysctrl4_set" protect="rw"/>
      <reg name="sysctrl5_set" protect="rw"/>
      <reg name="sysctrl6_set" protect="rw"/>
      <reg name="sysctrl7_set" protect="rw"/>
      <reg name="sysctrl8_set" protect="rw"/>
      <reg name="sysctrl9_set" protect="rw"/>
      <reg name="sysctrl10_set" protect="rw"/>
      <reg name="sysctrl11_set" protect="rw"/>
      <reg name="sysctrl12_set" protect="rw"/>
      <reg name="sysctrl13_set" protect="rw"/>
      <reg name="sysctrl14_set" protect="rw"/>
      <reg name="sysctrl15_set" protect="rw"/>
      <reg name="sysctrl16_set" protect="rw"/>
      <reg name="sysctrl17_set" protect="rw"/>
      <reg name="sysctrl18_set" protect="rw"/>
      <reg name="sysctrl19_set" protect="rw"/>
      <reg name="sysctrl20_set" protect="rw"/>
      <reg name="sysctrl21_set" protect="rw"/>
      <reg name="sysctrl22_set" protect="rw"/>
      <reg name="sysctrl23_set" protect="rw"/>
      <reg name="sysctrl24_set" protect="rw"/>
      <reg name="sysctrl25_set" protect="rw"/>
      <hole size="608"/>
      <reg name="sysctrl42_set" protect="rw"/>
      <reg name="sysctrl43_set" protect="rw"/>
      <hole size="128"/>
      <reg name="sysctrl46_set" protect="rw"/>
      <reg name="sysctrl47_set" protect="rw"/>
      <reg name="sysctrl48_set" protect="rw"/>
      <reg name="sysctrl49_set" protect="rw"/>
      <reg name="sysctrl50_set" protect="rw"/>
      <hole size="6432"/>
      <reg name="sysctrl1_clr" protect="rw"/>
      <reg name="sysctrl2_clr" protect="rw"/>
      <reg name="sysctrl3_clr" protect="rw"/>
      <reg name="sysctrl4_clr" protect="rw"/>
      <reg name="sysctrl5_clr" protect="rw"/>
      <reg name="sysctrl6_clr" protect="rw"/>
      <reg name="sysctrl7_clr" protect="rw"/>
      <reg name="sysctrl8_clr" protect="rw"/>
      <reg name="sysctrl9_clr" protect="rw"/>
      <reg name="sysctrl10_clr" protect="rw"/>
      <reg name="sysctrl11_clr" protect="rw"/>
      <reg name="sysctrl12_clr" protect="rw"/>
      <reg name="sysctrl13_clr" protect="rw"/>
      <reg name="sysctrl14_clr" protect="rw"/>
      <reg name="sysctrl15_clr" protect="rw"/>
      <reg name="sysctrl16_clr" protect="rw"/>
      <reg name="sysctrl17_clr" protect="rw"/>
      <reg name="sysctrl18_clr" protect="rw"/>
      <reg name="sysctrl19_clr" protect="rw"/>
      <reg name="sysctrl20_clr" protect="rw"/>
      <reg name="sysctrl21_clr" protect="rw"/>
      <reg name="sysctrl22_clr" protect="rw"/>
      <reg name="sysctrl23_clr" protect="rw"/>
      <reg name="sysctrl24_clr" protect="rw"/>
      <reg name="sysctrl25_clr" protect="rw"/>
      <hole size="608"/>
      <reg name="sysctrl42_clr" protect="rw"/>
      <reg name="sysctrl43_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="sysctrl46_clr" protect="rw"/>
      <reg name="sysctrl47_clr" protect="rw"/>
      <reg name="sysctrl48_clr" protect="rw"/>
      <reg name="sysctrl49_clr" protect="rw"/>
      <reg name="sysctrl50_clr" protect="rw"/>
    </module>
    <var name="REG_RF_SYSCTRL_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_SYSCTRL_CLR_OFFSET" value="0x800"/>
    <instance address="0x50035000" name="RF_SYSCTRL" type="RF_SYSCTRL"/>
  </archive>
  <archive relative="rf_txdlpf.xml">
    <module category="System" name="RF_TXDLPF">
      <reg name="dlpf_ctrl_reg" protect="rw">
        <comment/>
        <bits access="rw" name="notch_en_sel_status3" pos="15" rst="0x0">
          <comment>DLPF notch bypass status3
1: notch bypass when the value of dlpf_det_status is less than 3</comment>
        </bits>
        <bits access="rw" name="sdm_bypass" pos="14" rst="0x0">
          <comment>DLPF sdm bypass</comment>
        </bits>
        <bits access="rw" name="notch_en_sel_status2" pos="13" rst="0x0">
          <comment>DLPF notch bypass status2
1: notch bypass when the value of dlpf_det_status is less than 2</comment>
        </bits>
        <bits access="rw" name="tdc_cal_clk_inv" pos="12" rst="0x0">
          <comment>gro mode tdc cal clk out inverse</comment>
        </bits>
        <bits access="rw" name="pha_err_clk_inv" pos="11" rst="0x0">
          <comment>gro mode phase err clk out inverse</comment>
        </bits>
        <bits access="rw" name="tdc_dout_clk_inv" pos="10" rst="0x0">
          <comment>gro mode tdc cal reg clk inverse</comment>
        </bits>
        <bits access="rw" name="pha_dout_clk_inv" pos="9" rst="0x0">
          <comment>gro mode phase err reg clk inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_mdll_num" pos="8:6" rst="0x5">
          <comment>DLPF MDLL mode
000: 26x2MHz
001: 26x3MHz
010: 26x4MHz
011: 26x5MHz
100: 26x6MHz
101: 26x7MHz
110: 26x8MHz
111: 26x9MHz</comment>
        </bits>
        <bits access="rw" name="dlpf_notch_bypass" pos="5" rst="0x0">
          <comment>DLPF notch bypass</comment>
        </bits>
        <bits access="rw" name="dlpf_clk_inv1_reg" pos="4" rst="0x0">
          <comment>DLPF output clock inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_clk_inv0_reg" pos="3" rst="0x0">
          <comment>DLPF input clock inverse</comment>
        </bits>
        <bits access="rw" name="dlpf_lock_mode" pos="2" rst="0x1">
          <comment>DLPF lock mode</comment>
        </bits>
        <bits access="rw" name="dlpf_en" pos="1" rst="0x0">
          <comment>enable DLPF</comment>
        </bits>
      </reg>
      <reg name="dlpf_dr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_dr_mode" pos="14" rst="0x0">
          <comment>DLPF output direct control</comment>
        </bits>
        <bits access="rw" name="dlpf_dr_value" pos="13:0" rst="0x2000">
          <comment>DLPF output direct value</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_pha_offset_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_pha_offset" pos="15:0" rst="0xc8">
          <comment>DLPF afc phase offset</comment>
        </bits>
      </reg>
      <reg name="dlpf_kdco_pha_offset_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_kdco_pha_offset" pos="15:0" rst="0xc8">
          <comment>DLPF kdco phase offset</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_afc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_afc" pos="12:0" rst="0xa8">
          <comment>DLPF gain kp afc</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_afc_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_afc" pos="15:0" rst="0x3f">
          <comment>DLPF gain ki afc</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_2m_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_2m" pos="12:0" rst="0x698">
          <comment>DLPF gain kp 2m</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_2m_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_2m" pos="15:0" rst="0x27d">
          <comment>DLPF gain ki 2m</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_kp_200k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_kp_200k" pos="12:0" rst="0xa8">
          <comment>DLPF gain kp 200k</comment>
        </bits>
      </reg>
      <reg name="dlpf_gain_ki_200k_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_gain_ki_200k" pos="15:0" rst="0x3f">
          <comment>DLPF gain ki 200k</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_gain0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir0_gain0" pos="15:0" rst="0xf8dd">
          <comment>DLPF IIR0 gain0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_gain1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir0_gain1" pos="15:0" rst="0x391">
          <comment>DLPF IIR0 gain1[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_gain0_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain0" pos="15:0" rst="0x8522">
          <comment>DLPF IIR1 gain0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_gain1_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain1" pos="15:0" rst="0x3d6e">
          <comment>DLPF IIR1 gain1[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir_gain_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_iir1_gain1_msb" pos="3" rst="0x0">
          <comment>DLPF IIR1 gain1[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir1_gain0_msb" pos="2" rst="0x0">
          <comment>DLPF IIR1 gain0[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir0_gain1_msb" pos="1" rst="0x0">
          <comment>DLPF IIR0 gain1[16]</comment>
        </bits>
        <bits access="rw" name="dlpf_iir0_gain0_msb" pos="0" rst="0x0">
          <comment>DLPF IIR0 gain0[16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_diff_sel_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_diff_sel" pos="2:0" rst="0x2">
          <comment>dlpf_diff_sel value is set to reserved value</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>afc_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_diff_thr_msb" pos="15:0" rst="0x8">
          <comment>afc_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_afc_cnt_thr" pos="15:0" rst="0x64">
          <comment>minimum value of afc_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>lock_2m_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_diff_thr_msb" pos="15:0" rst="0x8">
          <comment>lock_2m_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_2m_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_2m_cnt_thr" pos="15:0" rst="0xc8">
          <comment>minimum value of lock_2m_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_diff_thr_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_diff_thr_lsb" pos="15:0" rst="0x0">
          <comment>lock_200k_diff_thr[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_diff_thr_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_diff_thr_msb" pos="15:0" rst="0x2">
          <comment>lock_200k_diff_thr[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_lock_200k_cnt_thr_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_lock_200k_cnt_thr" pos="15:0" rst="0x258">
          <comment>minimum value of lock_200k_cnt_thr is 5</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer0_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer0_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer0_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer0_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer0_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer0_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer1_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer1_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer1_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer1_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer1_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer1_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer2_cnt_lsb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer2_cnt_lsb" pos="15:0" rst="0x64">
          <comment>timer2_cnt[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_timer2_cnt_msb_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_timer2_cnt_msb" pos="15:0" rst="0x0">
          <comment>timer2_cnt[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_capture_reg" protect="rw">
        <comment/>
        <bits access="rw" name="dlpf_capture_en" pos="0" rst="0x0">
          <comment>DLPF capture enable to dump internal values</comment>
        </bits>
      </reg>
      <reg name="dlpf_status0_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_afc_code" pos="12:2" rst="0x400">
          <comment>real time afc_code</comment>
        </bits>
        <bits access="r" name="dlpf_det_status" pos="1:0" rst="0x0">
          <comment>DLPF detect status</comment>
        </bits>
      </reg>
      <reg name="dlpf_status1_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_kdco_code" pos="13:0" rst="0x2000">
          <comment>read time kdco_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_afc_code_status" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_afc_code_reg" pos="10:0" rst="0x0">
          <comment>captured afc_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_kdco_code_status" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_kdco_code_reg" pos="13:0" rst="0x0">
          <comment>captured kdco_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_tdc_code_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_tdc_code" pos="15:0" rst="0x0">
          <comment>tdc_code</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_l_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_l" pos="15:0" rst="0x0">
          <comment>dlpf_sum0[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_m_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_m" pos="15:0" rst="0x0">
          <comment>dlpf_sum0[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_sum0_h_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_sum0_h" pos="6:0" rst="0x0">
          <comment>dlpf_sum0[38:32]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_data_lsb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir0_data_lsb" pos="15:0" rst="0x0">
          <comment>iir0_data[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir0_data_msb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir0_data_msb" pos="15:0" rst="0x0">
          <comment>iir0_data[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_data_lsb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir1_data_lsb" pos="15:0" rst="0x0">
          <comment>iir1_data[15:0]</comment>
        </bits>
      </reg>
      <reg name="dlpf_iir1_data_msb_reg" protect="rw">
        <comment/>
        <bits access="r" name="dlpf_iir1_data_msb" pos="15:0" rst="0x0">
          <comment>iir1_data[31:16]</comment>
        </bits>
      </reg>
      <reg name="dlpf_ctrl_bit_reg" protect="rw">
        <comment/>
        <bits access="rw" name="capture_data_sel_tdc" pos="8" rst="0x1"/>
        <bits access="rw" name="sel_clk_out2_inv" pos="7" rst="0x0"/>
        <bits access="rw" name="sel_clk_out1_inv" pos="6" rst="0x0"/>
        <bits access="rw" name="kdco_polar_sel" pos="5" rst="0x0"/>
        <bits access="rw" name="kdco_agc_mode" pos="4" rst="0x0"/>
        <bits access="rw" name="2m_lock_bypass" pos="3" rst="0x0"/>
        <bits access="rw" name="afc_bypass" pos="2" rst="0x0"/>
        <bits access="rw" name="iir1_bypass" pos="1" rst="0x0"/>
        <bits access="rw" name="iir0_bypass" pos="0" rst="0x0"/>
      </reg>
      <reg name="gro_phase_tdc_cal" protect="rw">
        <comment/>
        <bits access="r" name="phase_tdc_cal" pos="15:0" rst="0x0"/>
      </reg>
      <hole size="6720"/>
      <reg name="dlpf_ctrl_reg_set" protect="rw"/>
      <hole size="1376"/>
      <reg name="dlpf_ctrl_bit_reg_set" protect="rw"/>
      <hole size="6752"/>
      <reg name="dlpf_ctrl_reg_clr" protect="rw"/>
      <hole size="1376"/>
      <reg name="dlpf_ctrl_bit_reg_clr" protect="rw"/>
    </module>
    <var name="REG_RF_TXDLPF_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_TXDLPF_CLR_OFFSET" value="0x800"/>
    <instance address="0x50033000" name="RF_TXDLPF" type="RF_TXDLPF"/>
  </archive>
  <archive relative="rf_tsen.xml">
    <module category="System" name="RF_TSEN">
      <reg name="tst_tsen_bist_cfg" protect="rw">
        <comment/>
        <bits access="rw" name="tst_tsen_bist_bypass" pos="13" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_cfg0" pos="12:10" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_cfg1" pos="9:7" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_cfg2" pos="6:4" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_cfg3" pos="3:1" rst="0x0"/>
      </reg>
      <reg name="tst_tsen_bist_time_sel" protect="rw">
        <comment/>
        <bits access="rw" name="tst_tsen_bist_code_in" pos="12:10" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_code_sel" pos="9" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_time_sel_cfg3" pos="8:7" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_time_sel_cfg2" pos="6:5" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_time_sel_cfg1" pos="4:3" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_time_sel_cfg0" pos="2:1" rst="0x0"/>
        <bits access="rw" name="tst_tsen_bist_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="tst_bist_sel" protect="rw">
        <comment/>
        <bits access="rw" name="pad_oe_osc_data" pos="12" rst="0x0"/>
        <bits access="rw" name="pad_ie_osc_data" pos="11" rst="0x0"/>
        <bits access="rw" name="pad_oe_osc_clk" pos="10" rst="0x0"/>
        <bits access="rw" name="pad_ie_osc_clk" pos="9" rst="0x0"/>
        <bits access="rw" name="pad_oe_tsx_adc_ch_sel" pos="8" rst="0x0"/>
        <bits access="rw" name="pad_ie_tsx_adc_ch_sel" pos="7" rst="0x0"/>
        <bits access="rw" name="pad_oe_tsx_data" pos="6" rst="0x0"/>
        <bits access="rw" name="pad_ie_tsx_data" pos="5" rst="0x0"/>
        <bits access="rw" name="pad_oe_tsx_clk" pos="4" rst="0x0"/>
        <bits access="rw" name="pad_ie_tsx_clk" pos="3" rst="0x0"/>
        <bits access="rw" name="tsen_adc_ch_sel_pad" pos="2" rst="0x0"/>
        <bits access="rw" name="tsen_adc_ch_sel_src" pos="1" rst="0x0"/>
        <bits access="rw" name="tsen_adc_rst_sel_src" pos="0" rst="0x0"/>
      </reg>
      <reg name="tst_bist_res" protect="rw">
        <comment/>
        <bits access="r" name="tsen_bist_code" pos="3:1"/>
        <bits access="r" name="tst_tsen_bist_done" pos="0"/>
      </reg>
      <reg name="tst_tsen_c0_test_res0" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c0_res0" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c0_test_res1" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c0_res1" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c0_test_res2" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c0_res2" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c0_test_res3" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c0_res3" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c1_test_res0" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c1_res0" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c1_test_res1" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c1_res1" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c1_test_res2" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c1_res2" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c1_test_res3" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c1_res3" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c2_test_res0" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c2_res0" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c2_test_res1" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c2_res1" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c2_test_res2" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c2_res2" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c2_test_res3" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c2_res3" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c3_test_res0" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c3_res0" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c3_test_res1" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c3_res1" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c3_test_res2" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c3_res2" pos="15:0"/>
      </reg>
      <reg name="tst_tsen_c3_test_res3" protect="rw">
        <comment/>
        <bits access="r" name="tst_tsen_c3_res3" pos="15:0"/>
      </reg>
      <hole size="7552"/>
      <reg name="tst_tsen_bist_cfg_set" protect="rw"/>
      <reg name="tst_tsen_bist_time_sel_set" protect="rw"/>
      <reg name="tst_bist_sel_set" protect="rw"/>
      <hole size="8096"/>
      <reg name="tst_tsen_bist_cfg_clr" protect="rw"/>
      <reg name="tst_tsen_bist_time_sel_clr" protect="rw"/>
      <reg name="tst_bist_sel_clr" protect="rw"/>
    </module>
    <var name="REG_RF_TSEN_SET_OFFSET" value="0x400"/>
    <var name="REG_RF_TSEN_CLR_OFFSET" value="0x800"/>
    <instance address="0x5003b000" name="RF_TSEN" type="RF_TSEN"/>
  </archive>
  <archive relative="reg_fw_sysctrl.xml">
    <module category="System" name="REG_FW_SYSCTRL">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="ahb2ahb_ab_dap_ctrl_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_funcdma_sts_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_funcdma_ctrl_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="apt_trigger_sel_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="dma_req_ctrl_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="emmc_slice_phy_ctrl_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_out_val_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_th_val_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_ctrl_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_debug_host_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart3_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart2_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mipi_csi_cfg_reg_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_soft_rst_ctrl1_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en3_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en2_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en1_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en0_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel3_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel2_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel1_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel0_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_en1_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_en0_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_lpc_ctrl_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_delay_num_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_en_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_mode_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rstctrl_lte_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clken_lte_intf_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clken_lte_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_soft_rst_ctrl0_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_1" protect="rw">
        <comment>REG_RD_CTRL_1 REG_RD_CTRL_1</comment>
        <bits access="rw" name="cfg_aon_io_core_ie_3_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_2_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_1_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_0_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_ahb2ahb_sync_cfg_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="dap_djtag_en_cfg_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_autogate_en_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_qos_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_anti_hang_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="plls_sts_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sysctrl_reg0_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_sts_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_ctrl_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_sts_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_ctrl_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="axi2axi_pub_sts_1_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="axi2axi_pub_sts_0_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2axi_pub_sts_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2axi_pub_ctrl_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_dap_sts_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="ahb2ahb_ab_dap_ctrl_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_funcdma_sts_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_funcdma_ctrl_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="apt_trigger_sel_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="dma_req_ctrl_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="emmc_slice_phy_ctrl_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_out_val_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_th_val_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc_calib_ctrl_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_debug_host_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart3_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart2_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mipi_csi_cfg_reg_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_soft_rst_ctrl1_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en3_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en2_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en1_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_force_en0_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel3_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel2_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel1_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_auto_sel0_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_en1_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_clock_en0_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_lpc_ctrl_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_delay_num_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_en_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_autogate_mode_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rstctrl_lte_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clken_lte_intf_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clken_lte_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_soft_rst_ctrl0_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_1" protect="rw">
        <comment>REG_WR_CTRL_1 REG_WR_CTRL_1</comment>
        <bits access="rw" name="cfg_aon_io_core_ie_3_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_2_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_1_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_io_core_ie_0_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_ahb2ahb_sync_cfg_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="dap_djtag_en_cfg_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_mtx_slice_autogate_en_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_qos_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_aon_anti_hang_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="plls_sts_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sysctrl_reg0_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_sts_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_lps2aon_ctrl_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_sts_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_aon2lps_ctrl_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="axi2axi_pub_sts_1_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="axi2axi_pub_sts_0_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2axi_pub_sts_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2axi_pub_ctrl_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ahb2ahb_ab_dap_sts_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array0" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY0 BIT_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_ctrl_addr_array0" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array1" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY1 BIT_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_ctrl_addr_array1" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array2" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY2 BIT_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_ctrl_addr_array2" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array3" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY3 BIT_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_ctrl_addr_array3" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array4" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY4 BIT_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_ctrl_addr_array4" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array5" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY5 BIT_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_ctrl_addr_array5" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array6" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY6 BIT_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_ctrl_addr_array6" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array7" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY7 BIT_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_ctrl_addr_array7" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array8" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY8 BIT_CTRL_ADDR_ARRAY8</comment>
        <bits access="rw" name="bit_ctrl_addr_array8" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array8</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array9" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY9 BIT_CTRL_ADDR_ARRAY9</comment>
        <bits access="rw" name="bit_ctrl_addr_array9" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array9</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array10" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY10 BIT_CTRL_ADDR_ARRAY10</comment>
        <bits access="rw" name="bit_ctrl_addr_array10" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array10</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array11" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY11 BIT_CTRL_ADDR_ARRAY11</comment>
        <bits access="rw" name="bit_ctrl_addr_array11" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array11</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array12" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY12 BIT_CTRL_ADDR_ARRAY12</comment>
        <bits access="rw" name="bit_ctrl_addr_array12" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array12</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array13" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY13 BIT_CTRL_ADDR_ARRAY13</comment>
        <bits access="rw" name="bit_ctrl_addr_array13" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array13</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array14" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY14 BIT_CTRL_ADDR_ARRAY14</comment>
        <bits access="rw" name="bit_ctrl_addr_array14" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array14</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array15" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY15 BIT_CTRL_ADDR_ARRAY15</comment>
        <bits access="rw" name="bit_ctrl_addr_array15" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array15</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_array0" protect="rw">
        <comment>BIT_CTRL_ARRAY0 BIT_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_ctrl_array1" protect="rw">
        <comment>BIT_CTRL_ARRAY1 BIT_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_ctrl_array2" protect="rw">
        <comment>BIT_CTRL_ARRAY2 BIT_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_ctrl_array3" protect="rw">
        <comment>BIT_CTRL_ARRAY3 BIT_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_ctrl_array4" protect="rw">
        <comment>BIT_CTRL_ARRAY4 BIT_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_ctrl_array5" protect="rw">
        <comment>BIT_CTRL_ARRAY5 BIT_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_ctrl_array6" protect="rw">
        <comment>BIT_CTRL_ARRAY6 BIT_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_ctrl_array7" protect="rw">
        <comment>BIT_CTRL_ARRAY7 BIT_CTRL_ARRAY7</comment>
      </reg>
      <reg name="bit_ctrl_array8" protect="rw">
        <comment>BIT_CTRL_ARRAY8 BIT_CTRL_ARRAY8</comment>
      </reg>
      <reg name="bit_ctrl_array9" protect="rw">
        <comment>BIT_CTRL_ARRAY9 BIT_CTRL_ARRAY9</comment>
      </reg>
      <reg name="bit_ctrl_array10" protect="rw">
        <comment>BIT_CTRL_ARRAY10 BIT_CTRL_ARRAY10</comment>
      </reg>
      <reg name="bit_ctrl_array11" protect="rw">
        <comment>BIT_CTRL_ARRAY11 BIT_CTRL_ARRAY11</comment>
      </reg>
      <reg name="bit_ctrl_array12" protect="rw">
        <comment>BIT_CTRL_ARRAY12 BIT_CTRL_ARRAY12</comment>
      </reg>
      <reg name="bit_ctrl_array13" protect="rw">
        <comment>BIT_CTRL_ARRAY13 BIT_CTRL_ARRAY13</comment>
      </reg>
      <reg name="bit_ctrl_array14" protect="rw">
        <comment>BIT_CTRL_ARRAY14 BIT_CTRL_ARRAY14</comment>
      </reg>
      <reg name="bit_ctrl_array15" protect="rw">
        <comment>BIT_CTRL_ARRAY15 BIT_CTRL_ARRAY15</comment>
      </reg>
    </module>
    <instance address="0x51305000" name="REG_FW_SYSCTRL" type="REG_FW_SYSCTRL"/>
  </archive>
  <archive relative="reg_fw_pwrctrl.xml">
    <module category="System" name="REG_FW_PWRCTRL">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="pwrctrl_sm_state_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_cp_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_ap_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="slp_timeout_flag_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="slp_bypass_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="psram_hold_ctrl_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pd_d_delay_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pd_m_delay_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="state_delay_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gnss_pwr_stat_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_pwr_stat_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_pwr_stat_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rf_pwr_stat_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pub_pwr_stat_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pwr_stat_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pwr_stat_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gnss_pwr_ctrl_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_pwr_ctrl_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_pwr_ctrl_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rf_pwr_ctrl_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pub_pwr_ctrl_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pwr_ctrl_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pwr_ctrl_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_hwen_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="pwrctrl_sm_state_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_cp_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_int_en_ap_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="slp_timeout_flag_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="slp_bypass_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="psram_hold_ctrl_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pd_d_delay_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pd_m_delay_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="state_delay_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gnss_pwr_stat_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_pwr_stat_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_pwr_stat_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rf_pwr_stat_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pub_pwr_stat_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pwr_stat_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pwr_stat_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gnss_pwr_ctrl_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lte_pwr_ctrl_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_pwr_ctrl_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rf_pwr_ctrl_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pub_pwr_ctrl_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pwr_ctrl_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pwr_ctrl_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pwrctrl_hwen_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array0" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY0 BIT_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_ctrl_addr_array0" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array1" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY1 BIT_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_ctrl_addr_array1" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array2" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY2 BIT_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_ctrl_addr_array2" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array3" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY3 BIT_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_ctrl_addr_array3" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array4" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY4 BIT_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_ctrl_addr_array4" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array5" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY5 BIT_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_ctrl_addr_array5" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array6" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY6 BIT_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_ctrl_addr_array6" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array7" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY7 BIT_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_ctrl_addr_array7" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_array0" protect="rw">
        <comment>BIT_CTRL_ARRAY0 BIT_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_ctrl_array1" protect="rw">
        <comment>BIT_CTRL_ARRAY1 BIT_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_ctrl_array2" protect="rw">
        <comment>BIT_CTRL_ARRAY2 BIT_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_ctrl_array3" protect="rw">
        <comment>BIT_CTRL_ARRAY3 BIT_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_ctrl_array4" protect="rw">
        <comment>BIT_CTRL_ARRAY4 BIT_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_ctrl_array5" protect="rw">
        <comment>BIT_CTRL_ARRAY5 BIT_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_ctrl_array6" protect="rw">
        <comment>BIT_CTRL_ARRAY6 BIT_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_ctrl_array7" protect="rw">
        <comment>BIT_CTRL_ARRAY7 BIT_CTRL_ARRAY7</comment>
      </reg>
    </module>
    <instance address="0x51315000" name="REG_FW_PWRCTRL" type="REG_FW_PWRCTRL"/>
  </archive>
  <archive relative="reg_fw_lps_apb.xml">
    <module category="System" name="REG_FW_LPS_APB">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="cfg_io_deep_sleep_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pu_clk26m_lp_iso_cfg_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_uart_swj_share_cfg_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_lp_ctrl_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc26m_pu_ctrl_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efs_por_read_block89_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efs_por_read_block3_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_por_usb_phy_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="iomux_g4_func_sel_latch_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_iram_ctrl_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="iispll_wait_number_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mpll_wait_number_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="apll_wait_number_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_plls_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_cause_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_reset_enable_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_boot_mode_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_gpt_lite_clock_sel_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_uart1_clock_sel_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_lps_ahb_clock_sel_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_psram_half_slp_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_debug_bond_option_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_rc26m_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart1_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_busy_status_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_gate_en_status_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_force_en_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_auto_sel_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_en_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efuse_por_read_disable_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_lps_soft_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_sys_soft_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_1" protect="rw">
        <comment>REG_RD_CTRL_1 REG_RD_CTRL_1</comment>
        <bits access="rw" name="cfg_simc_io_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_lps_io_core_ie_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="cfg_io_deep_sleep_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pu_clk26m_lp_iso_cfg_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="usb_uart_swj_share_cfg_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_lp_ctrl_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rc26m_pu_ctrl_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efs_por_read_block89_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efs_por_read_block3_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_por_usb_phy_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="iomux_g4_func_sel_latch_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_iram_ctrl_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="iispll_wait_number_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mpll_wait_number_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="apll_wait_number_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_plls_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_cause_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_reset_enable_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_boot_mode_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_gpt_lite_clock_sel_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_uart1_clock_sel_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_lps_ahb_clock_sel_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_psram_half_slp_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_debug_bond_option_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_rc26m_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart1_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_busy_status_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_gate_en_status_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_force_en_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_auto_sel_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_clk_en_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="efuse_por_read_disable_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_lps_soft_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="reset_sys_soft_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_1" protect="rw">
        <comment>REG_WR_CTRL_1 REG_WR_CTRL_1</comment>
        <bits access="rw" name="cfg_simc_io_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_lps_io_core_ie_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array0" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY0 BIT_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_ctrl_addr_array0" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array1" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY1 BIT_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_ctrl_addr_array1" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array2" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY2 BIT_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_ctrl_addr_array2" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array3" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY3 BIT_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_ctrl_addr_array3" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array4" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY4 BIT_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_ctrl_addr_array4" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array5" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY5 BIT_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_ctrl_addr_array5" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array6" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY6 BIT_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_ctrl_addr_array6" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array7" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY7 BIT_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_ctrl_addr_array7" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_array0" protect="rw">
        <comment>BIT_CTRL_ARRAY0 BIT_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_ctrl_array1" protect="rw">
        <comment>BIT_CTRL_ARRAY1 BIT_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_ctrl_array2" protect="rw">
        <comment>BIT_CTRL_ARRAY2 BIT_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_ctrl_array3" protect="rw">
        <comment>BIT_CTRL_ARRAY3 BIT_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_ctrl_array4" protect="rw">
        <comment>BIT_CTRL_ARRAY4 BIT_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_ctrl_array5" protect="rw">
        <comment>BIT_CTRL_ARRAY5 BIT_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_ctrl_array6" protect="rw">
        <comment>BIT_CTRL_ARRAY6 BIT_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_ctrl_array7" protect="rw">
        <comment>BIT_CTRL_ARRAY7 BIT_CTRL_ARRAY7</comment>
      </reg>
    </module>
    <instance address="0x51316000" name="REG_FW_LPS_APB" type="REG_FW_LPS_APB"/>
  </archive>
  <archive relative="reg_fw_idle_lps.xml">
    <module category="System" name="REG_FW_IDLE_LPS">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="lps_t_time5_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time4_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time3_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time2_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time1_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p2_time_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p1_time_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_lps_sta_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_st_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_en_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_st_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_en_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_int_sta_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_inten_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_int_sta_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_inten_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_lps_sta_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="eliminate_jitter_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sleep_prot_time_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_sig_en_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pm2_mode_en_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pm2_sta_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_on_off_time_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_on_time_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_off_time_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_lps_sig_time_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_sig_en_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pm2_sta_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_ctrl_cp_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_lps_sig_time_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_sig_en_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_ctrl_ap_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_1" protect="rw">
        <comment>REG_RD_CTRL_1 REG_RD_CTRL_1</comment>
        <bits access="rw" name="cp_awk_st1_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_en1_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_st1_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_en1_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t6_en_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t5_en_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t4_en_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t3_en_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t2_en_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t1_en_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p2_en_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p1_en_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res11_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res10_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res9_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res8_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res7_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res6_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res5_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res4_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res3_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res2_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res1_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res0_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mon_sel_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="load_time_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_tp_sta_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_tpctrl_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ref_32k_fnl_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_32k_ref_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="load_en_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time6_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_2" protect="rw">
        <comment>REG_RD_CTRL_2 REG_RD_CTRL_2</comment>
        <bits access="rw" name="cp_pm2_mode_en_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t9_en_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t8_en_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t7_en_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time9_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time8_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time7_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="lps_t_time5_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time4_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time3_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time2_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time1_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p2_time_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p1_time_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_lps_sta_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_st_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_en_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_st_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_en_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_int_sta_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_inten_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_int_sta_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_inten_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_lps_sta_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="eliminate_jitter_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sleep_prot_time_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="aon_sig_en_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pm2_mode_en_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_pm2_sta_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_on_off_time_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_on_time_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pm2_off_time_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_lps_sig_time_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_sig_en_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_pm2_sta_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_ctrl_cp_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_lps_sig_time_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_sig_en_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_ctrl_ap_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_1" protect="rw">
        <comment>REG_WR_CTRL_1 REG_WR_CTRL_1</comment>
        <bits access="rw" name="cp_awk_st1_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_awk_en1_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_st1_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_awk_en1_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t6_en_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t5_en_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t4_en_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t3_en_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t2_en_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t1_en_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p2_en_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cp_p1_en_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res11_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res10_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res9_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res8_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res7_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res6_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res5_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res4_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res3_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res2_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res1_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_res0_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mon_sel_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="load_time_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_tp_sta_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_tpctrl_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ref_32k_fnl_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_32k_ref_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="load_en_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time6_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_2" protect="rw">
        <comment>REG_WR_CTRL_2 REG_WR_CTRL_2</comment>
        <bits access="rw" name="cp_pm2_mode_en_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t9_en_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t8_en_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t7_en_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time9_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time8_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lps_t_time7_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array0" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY0 BIT_WR_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array0" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array1" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY1 BIT_WR_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array1" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array2" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY2 BIT_WR_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array2" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array3" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY3 BIT_WR_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array3" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array4" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY4 BIT_WR_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array4" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array5" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY5 BIT_WR_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array5" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array6" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY6 BIT_WR_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array6" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array7" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY7 BIT_WR_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array7" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array8" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY8 BIT_WR_CTRL_ADDR_ARRAY8</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array8" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array8</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array9" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY9 BIT_WR_CTRL_ADDR_ARRAY9</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array9" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array9</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array10" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY10 BIT_WR_CTRL_ADDR_ARRAY10</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array10" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array10</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array11" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY11 BIT_WR_CTRL_ADDR_ARRAY11</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array11" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array11</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array12" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY12 BIT_WR_CTRL_ADDR_ARRAY12</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array12" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array12</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array13" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY13 BIT_WR_CTRL_ADDR_ARRAY13</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array13" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array13</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array14" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY14 BIT_WR_CTRL_ADDR_ARRAY14</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array14" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array14</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_addr_array15" protect="rw">
        <comment>BIT_WR_CTRL_ADDR_ARRAY15 BIT_WR_CTRL_ADDR_ARRAY15</comment>
        <bits access="rw" name="bit_wr_ctrl_addr_array15" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array15</comment>
        </bits>
      </reg>
      <reg name="bit_wr_ctrl_array0" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY0 BIT_WR_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_wr_ctrl_array1" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY1 BIT_WR_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_wr_ctrl_array2" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY2 BIT_WR_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_wr_ctrl_array3" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY3 BIT_WR_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_wr_ctrl_array4" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY4 BIT_WR_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_wr_ctrl_array5" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY5 BIT_WR_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_wr_ctrl_array6" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY6 BIT_WR_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_wr_ctrl_array7" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY7 BIT_WR_CTRL_ARRAY7</comment>
      </reg>
      <reg name="bit_wr_ctrl_array8" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY8 BIT_WR_CTRL_ARRAY8</comment>
      </reg>
      <reg name="bit_wr_ctrl_array9" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY9 BIT_WR_CTRL_ARRAY9</comment>
      </reg>
      <reg name="bit_wr_ctrl_array10" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY10 BIT_WR_CTRL_ARRAY10</comment>
      </reg>
      <reg name="bit_wr_ctrl_array11" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY11 BIT_WR_CTRL_ARRAY11</comment>
      </reg>
      <reg name="bit_wr_ctrl_array12" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY12 BIT_WR_CTRL_ARRAY12</comment>
      </reg>
      <reg name="bit_wr_ctrl_array13" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY13 BIT_WR_CTRL_ARRAY13</comment>
      </reg>
      <reg name="bit_wr_ctrl_array14" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY14 BIT_WR_CTRL_ARRAY14</comment>
      </reg>
      <reg name="bit_wr_ctrl_array15" protect="rw">
        <comment>BIT_WR_CTRL_ARRAY15 BIT_WR_CTRL_ARRAY15</comment>
      </reg>
    </module>
    <instance address="0x51314000" name="REG_FW_IDLE_LPS" type="REG_FW_IDLE_LPS"/>
  </archive>
  <archive relative="lps_apb.xml">
    <module category="System" name="LPS_APB">
      <reg name="reset_sys_soft" protect="rw">
        <comment>RESET_SYS_SOFT</comment>
        <bits access="rw" name="chip_soft_reset" pos="7" rst="0x0"/>
        <bits access="rw" name="rf_sys_soft_reset" pos="6" rst="0x0"/>
        <bits access="rw" name="pub_sys_soft_reset" pos="5" rst="0x0"/>
        <bits access="rw" name="usb_sys_soft_reset" pos="4" rst="0x0"/>
        <bits access="rw" name="gnss_sys_soft_reset" pos="3" rst="0x0"/>
        <bits access="rw" name="lte_sys_soft_reset" pos="2" rst="0x0"/>
        <bits access="rw" name="cp_sys_soft_reset" pos="1" rst="0x0"/>
        <bits access="rw" name="ap_sys_soft_reset" pos="0" rst="0x0"/>
      </reg>
      <reg name="reset_lps_soft" protect="rw">
        <comment>RESET_LPS_SOFT</comment>
        <bits access="rw" name="rtc_timer_soft_reset" pos="7" rst="0x0"/>
        <bits access="rw" name="rc26m_calib_soft_reset" pos="6" rst="0x0"/>
        <bits access="rw" name="iomux_g4_soft_reset" pos="5" rst="0x0"/>
        <bits access="rw" name="ana_wrap3_soft_reset" pos="4" rst="0x0"/>
        <bits access="rw" name="uart1_soft_reset" pos="3" rst="0x0"/>
        <bits access="rw" name="keypad_soft_reset" pos="2" rst="0x0"/>
        <bits access="rw" name="gpio1_soft_reset" pos="1" rst="0x0"/>
        <bits access="rw" name="gpt1_soft_reset" pos="0" rst="0x0"/>
      </reg>
      <reg name="efuse_por_read_disable" protect="rw">
        <comment>EFUSE_POR_READ_DISABLE</comment>
        <bits access="rw" name="efuse_sel_flag" pos="2:1" rst="0x0">
          <comment>reference &quot;efuse_design_specification.docx&quot;</comment>
        </bits>
        <bits access="rw" name="efuse_por_read_disable" pos="0" rst="0x0"/>
      </reg>
      <reg name="lps_clk_en" protect="rw">
        <comment>LPS_CLK_EN</comment>
        <bits access="rw" name="lps_ahb_aon_en" pos="7" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rtc_timer_en" pos="6" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pwrctrl_en" pos="5" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="uart1_en" pos="4" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="keypad_en" pos="3" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="idle_lps_en" pos="2" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gpt1_en" pos="1" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gpio1_en" pos="0" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="lps_clk_auto_sel" protect="rw">
        <comment>LPS_CLK_AUTO_SEL</comment>
      </reg>
      <reg name="lps_clk_force_en" protect="rw">
        <comment>LPS_CLK_FORCE_EN</comment>
      </reg>
      <reg name="lps_clk_gate_en_status" protect="rw">
        <comment>LPS_CLK_GATE_EN_STATUS</comment>
      </reg>
      <reg name="lps_clk_busy_status" protect="rw">
        <comment>LPS_CLK_BUSY_STATUS</comment>
      </reg>
      <reg name="cfg_clk_uart1" protect="rw">
        <comment>CFG_CLK_UART1</comment>
        <bits access="rw" name="cfg_clk_uart1_update" pos="31" rst="0x0"/>
        <bits access="rw" name="cfg_clk_uart1_demod" pos="29:16" rst="0x7"/>
        <bits access="rw" name="cfg_clk_uart1_num" pos="9:0" rst="0x1"/>
      </reg>
      <reg name="cfg_clk_rc26m" protect="rw">
        <comment>CFG_CLK_RC26M</comment>
        <bits access="rw" name="cfg_clk_rc26m_update" pos="31" rst="0x0"/>
        <bits access="rw" name="cfg_clk_rc26m_demod" pos="29:16" rst="0x1"/>
        <bits access="rw" name="cfg_clk_rc26m_num" pos="9:0" rst="0x1"/>
      </reg>
      <reg name="cfg_debug_bond_option" protect="rw">
        <comment>CFG_DEBUG_BOND_OPTION</comment>
        <bits access="rw" name="bond_sec_dap_en" pos="18" rst="0x0"/>
        <bits access="rw" name="bond_fdma_boot_cpu_en" pos="17" rst="0x0"/>
        <bits access="rw" name="bond_dbghost_en" pos="16" rst="0x0"/>
        <bits access="rw" name="bond_pad_jtag_en" pos="15" rst="0x0"/>
        <bits access="rw" name="bond_djtag_en" pos="14" rst="0x0"/>
        <bits access="rw" name="bond_swd_dbg_sys_en" pos="13" rst="0x0"/>
        <bits access="rw" name="bond_fdma_en" pos="12" rst="0x0"/>
        <bits access="rw" name="bond_cp_ca5_spniden" pos="11" rst="0x0"/>
        <bits access="rw" name="bond_cp_ca5_spiden" pos="10" rst="0x0"/>
        <bits access="rw" name="bond_cp_ca5_niden" pos="9" rst="0x0"/>
        <bits access="rw" name="bond_cp_ca5_dbgen" pos="8" rst="0x0"/>
        <bits access="rw" name="bond_cp_ca5_dap_deviceen" pos="7" rst="0x0"/>
        <bits access="rw" name="bond_ap_ca5_spniden" pos="6" rst="0x0"/>
        <bits access="rw" name="bond_ap_ca5_spiden" pos="5" rst="0x0"/>
        <bits access="rw" name="bond_ap_ca5_niden" pos="4" rst="0x0"/>
        <bits access="rw" name="bond_ap_ca5_dbgen" pos="3" rst="0x0"/>
        <bits access="rw" name="bond_ap_ca5_dap_deviceen" pos="2" rst="0x0"/>
        <bits access="rw" name="bond_swd_jtag_en" pos="1" rst="0x0"/>
        <bits access="r" name="bond_option_wr_flag" pos="0" rst="0x0"/>
      </reg>
      <reg name="cfg_psram_half_slp" protect="rw">
        <comment>CFG_PSRAM_HALF_SLP</comment>
        <bits access="rw" name="half_slp_req" pos="0" rst="0x0">
          <comment>0: PSRAM macro do not in half-sleep mode when PSRAM controller power-down
1: PSRAM macro in  half-sleep mode when PSRAM controller power-down</comment>
        </bits>
      </reg>
      <reg name="cfg_lps_ahb_clock_sel" protect="rw">
        <comment>CFG_LPS_AHB_CLOCK_SEL</comment>
        <bits access="rw" name="cgm_lps_ahb_sel" pos="1:0" rst="0x2">
          <comment>0:rtc_32k
1:xtal_lp_26m
2:xtal_26m
3:rc_26m</comment>
        </bits>
      </reg>
      <reg name="cfg_uart1_clock_sel" protect="rw">
        <comment>CFG_UART1_CLOCK_SEL</comment>
        <bits access="rw" name="cgm_uart1_bf_div_sel" pos="1:0" rst="0x2">
          <comment>0:rtc_32k
1:xtal_lp_2tm
2:xtal_26m
3:rc_26m</comment>
        </bits>
      </reg>
      <reg name="cfg_gpt_lite_clock_sel" protect="rw">
        <comment>CFG_GPT_LITE_CLOCK_SEL</comment>
        <bits access="rw" name="cgm_gpt_lite_sel" pos="1:0" rst="0x2">
          <comment>0:rtc_32k
1:xtal_lp_2tm
2:xtal_26m
3:rc_26m</comment>
        </bits>
      </reg>
      <reg name="cfg_boot_mode" protect="rw">
        <comment>CFG_BOOT_MODE</comment>
        <bits access="r" name="function_test_mode" pos="10" rst="0x0"/>
        <bits access="rw" name="boot_mode_sw" pos="9:4" rst="0x0"/>
        <bits access="rw" name="boot_mode_pin" pos="2:0" rst="0x0">
          <comment>This contains the state of boot mode pins latched during Reset.
bit 0: Force download.
bit 1: EMMC boot.
bit 2: Unused.</comment>
        </bits>
      </reg>
      <reg name="cfg_reset_enable" protect="rw">
        <comment>CFG_RESET_ENABLE</comment>
        <bits access="rw" name="dbghost_reset_ap_cpu_enable" pos="12" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dbghost_reset_enable" pos="11" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pub_mem_fw_invalid_reset_raw_enable" pos="10" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_mem_fw_invalid_reset_raw_enable" pos="9" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_mem_fw_invalid_reset_raw_enable" pos="8" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pub_mem_fw_invalid_reset_enable" pos="7" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_mem_fw_invalid_reset_enable" pos="6" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_mem_fw_invalid_reset_enable" pos="5" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="invalid_clk_26m_reset_enable" pos="4" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="invalid_clk_32k_reset_enable" pos="3" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rf_wdt_reset_enable" pos="2" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_wdt_reset_enable" pos="1" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_wdt_reset_enable" pos="0" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="reset_cause" protect="rw">
        <comment>RESET_CAUSE</comment>
        <bits access="rw" name="soft_reset" pos="14" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="funcdma_reset_ap_cpu" pos="13" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dbghost_reset_ap_cpu" pos="12" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dbghost_reset" pos="11" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pub_mem_fw_invalid_reset_raw" pos="10" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_mem_fw_invalid_reset_raw" pos="9" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_mem_fw_invalid_reset_raw" pos="8" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pub_mem_fw_invalid_reset" pos="7" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="aon_mem_fw_invalid_reset" pos="6" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_mem_fw_invalid_reset" pos="5" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="invalid_clk_26m_reset" pos="4" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="invalid_clk_32k_reset" pos="3" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rf_wdt_reset" pos="2" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="cp_wdt_reset" pos="1" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ap_wdt_reset" pos="0" rst="0x0">
          <comment>0: disable
1: enable</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="cfg_plls" protect="rw">
        <comment>CFG_PLLS</comment>
        <bits access="rw" name="bbpll_pd_sel" pos="21" rst="0x1">
          <comment>0: select hardware auto control signal
1: select bbpll_pd_force as control signal</comment>
        </bits>
        <bits access="rw" name="bbpll_pd_force" pos="20" rst="0x0">
          <comment>0: power-up
1: power-down</comment>
        </bits>
        <bits access="rw" name="iispll_clkout_en_mode" pos="19" rst="0x0">
          <comment>select hardware control mode:(valid when iispll_clkout_en_sel bit is &quot;0&quot;)
0: idle_lps output signal control
1: clock plan signal auto control</comment>
        </bits>
        <bits access="rw" name="iispll_clkout_en_sel" pos="18" rst="0x1">
          <comment>0: select hardware auto control signal
1: select iispll_clkout_en_force as control signal</comment>
        </bits>
        <bits access="rw" name="iispll_clkout_en_force" pos="17" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="iispll_pd_sel" pos="16" rst="0x1">
          <comment>0: select hardware auto control signal
1: select iispll_pd_force as control signal</comment>
        </bits>
        <bits access="rw" name="iispll_pd_force" pos="15" rst="0x1">
          <comment>0: power-up
1: power-down</comment>
        </bits>
        <bits access="rw" name="mpll_pub_sel" pos="14" rst="0x0">
          <comment>0: MPLL clock is not selected in PUB_SYS
1: MPLL clock is secected in PUB_SYS</comment>
        </bits>
        <bits access="rw" name="mpll_clkout_en_mode" pos="13" rst="0x0">
          <comment>select hardware control mode:(valid when mpll_clkout_en_sel bit is &quot;0&quot;)
0: idle_lps output signal control
1: clock plan signal auto control</comment>
        </bits>
        <bits access="rw" name="mpll_clkout_en_sel" pos="12" rst="0x1">
          <comment>0: select hardware auto control signal
1: select mpll_clkout_en_force as control signal</comment>
        </bits>
        <bits access="rw" name="mpll_clkout_en_force" pos="11" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="mpll_pd_sel" pos="10" rst="0x1">
          <comment>0: select hardware auto control signal
1: select mpll_pd_force as control signal</comment>
        </bits>
        <bits access="rw" name="mpll_pd_force" pos="9" rst="0x0">
          <comment>0: power-up
1: power-down</comment>
        </bits>
        <bits access="rw" name="apll_ap_sel" pos="8" rst="0x0">
          <comment>0: APLL clock is not selected in AP_SYS
1: APLL clock is secected in AP_SYS</comment>
        </bits>
        <bits access="rw" name="apll_cp_sel" pos="7" rst="0x0">
          <comment>0: APLL clock is not selected in CP_SYS
1: APLL clock is secected in CP_SYS</comment>
        </bits>
        <bits access="rw" name="apll_pub_sel" pos="6" rst="0x0">
          <comment>0: APLL clock is not selected in PUB_SYS
1: APLL clock is secected in PUB_SYS</comment>
        </bits>
        <bits access="rw" name="apll_aon_sel" pos="5" rst="0x0">
          <comment>0: APLL clock is not selected in AON_SYS
1: APLL clock is secected in AON_SYS</comment>
        </bits>
        <bits access="rw" name="apll_clkout_en_mode" pos="4" rst="0x0">
          <comment>select hardware control mode:(valid when apll_clkout_en_sel bit is &quot;0&quot;)
0: idle_lps output signal control
1: clock plan signal auto control</comment>
        </bits>
        <bits access="rw" name="apll_clkout_en_sel" pos="3" rst="0x1">
          <comment>0: select hardware auto control signal
1: select apll_clkout_en_force as control signal</comment>
        </bits>
        <bits access="rw" name="apll_clkout_en_force" pos="2" rst="0x1">
          <comment>0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="apll_pd_sel" pos="1" rst="0x1">
          <comment>0: select hardware auto control signal
1: select apll_pd_force as control signal</comment>
        </bits>
        <bits access="rw" name="apll_pd_force" pos="0" rst="0x0">
          <comment>0: power-up
1: power-down</comment>
        </bits>
      </reg>
      <reg name="apll_wait_number" protect="rw">
        <comment>APLL_WAIT_NUMBER</comment>
        <bits access="rw" name="apll_clkout_en_high" pos="29:16" rst="0x28b0">
          <comment>From PLL_CLKOUT_EN posedge to PLL_PRECHARGE posedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="apll_precharge_high" pos="15:5" rst="0x30d">
          <comment>From PLL_RST negedge to PLL_PRECHARGE posedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="apll_rst_low" pos="4:0" rst="0x10">
          <comment>From PLL_PD negedge to PLL_RST negedge,use 26M clock count.</comment>
        </bits>
      </reg>
      <reg name="mpll_wait_number" protect="rw">
        <comment>MPLL_WAIT_NUMBER</comment>
        <bits access="rw" name="mpll_clkout_en_high" pos="29:16" rst="0x28b0">
          <comment>From PLL_CLKOUT_EN negedge to PLL_PRECHARGE negedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="mpll_precharge_high" pos="15:5" rst="0x30d">
          <comment>From PLL_RST negedge to PLL_PRECHARGE posedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="mpll_rst_low" pos="4:0" rst="0x10">
          <comment>From PLL_PD negedge to PLL_RST negedge,use 26M clock count.</comment>
        </bits>
      </reg>
      <reg name="iispll_wait_number" protect="rw">
        <comment>IISMPLL_WAIT_NUMBER</comment>
        <bits access="rw" name="iispll_clkout_en_high" pos="29:16" rst="0x28b0">
          <comment>From PLL_CLKOUT_EN negedge to PLL_PRECHARGE negedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="iispll_precharge_high" pos="15:5" rst="0x30d">
          <comment>From PLL_RST negedge to PLL_PRECHARGE posedge(if pll_precharge_en set to &quot;1&quot;),use 26M clock count.</comment>
        </bits>
        <bits access="rw" name="iispll_rst_low" pos="4:0" rst="0x10">
          <comment>From PLL_PD negedge to PLL_RST negedge,use 26M clock count.</comment>
        </bits>
      </reg>
      <reg name="aon_iram_ctrl" protect="rw">
        <comment>AON_IRAM_CTRL</comment>
        <bits access="r" name="aon_iram2_pu_delay" pos="18" rst="0x0">
          <comment>AON_IRAM2 PU_DELAY port value</comment>
        </bits>
        <bits access="r" name="aon_iram1_pu_delay" pos="17" rst="0x0">
          <comment>AON_IRAM1 PU_DELAY port value</comment>
        </bits>
        <bits access="r" name="aon_iram0_pu_delay" pos="16" rst="0x0">
          <comment>AON_IRAM0 PU_DELAY port value</comment>
        </bits>
        <bits access="rw" name="aon_iram2_ctrl_hw" pos="15:14" rst="0x0">
          <comment>AON_IRAM2 hardware control. It work when chip in deep-sleep, and recover to normal mode when wake-up:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram1_ctrl_hw" pos="13:12" rst="0x0">
          <comment>AON_IRAM1 hardware control. It work when chip in deep-sleep, and recover to normal mode when wake-up:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram0_ctrl_hw" pos="11:10" rst="0x0">
          <comment>AON_IRAM0 hardware control. It work when chip in deep-sleep, and recover to normal mode when wake-up:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram2_ctrl_sw" pos="9:8" rst="0x0">
          <comment>AON_IRAM2 software control:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram1_ctrl_sw" pos="7:6" rst="0x0">
          <comment>AON_IRAM1 software control:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram0_ctrl_sw" pos="5:4" rst="0x0">
          <comment>AON_IRAM0 software control:
00: normal mode
01: retention mode
10: shut-down mode
11: normal mode</comment>
        </bits>
        <bits access="rw" name="aon_iram2_ctrl_mode_sel" pos="2" rst="0x0">
          <comment>1: AON_IRAM2 control by aon_iram2_ctrl_hw[1:0]
0: AON_IRAM2 control by aon_iram2_ctrl_sw</comment>
        </bits>
        <bits access="rw" name="aon_iram1_ctrl_mode_sel" pos="1" rst="0x0">
          <comment>1: AON_IRAM1 control by aon_iram1_ctrl_hw[1:0]
0: AON_IRAM1 control by aon_iram1_ctrl_sw</comment>
        </bits>
        <bits access="rw" name="aon_iram0_ctrl_mode_sel" pos="0" rst="0x0">
          <comment>1: AON_IRAM0 control by aon_iram0_ctrl_hw[1:0]
0: AON_IRAM0 control by aon_iram0_ctrl_sw</comment>
        </bits>
      </reg>
      <reg name="iomux_g4_func_sel_latch" protect="rw">
        <comment>IOMUX_G4_FUNC_SEL_LATCH</comment>
        <bits access="rw" name="iomux_g4_func_sel_latch" pos="0" rst="0x0">
          <comment>This bit will be set to &quot;1&quot; by hardware to latch G4 pad function select when deepsleep, software should write &quot;0&quot; to release after iomux reinitial.</comment>
        </bits>
      </reg>
      <reg name="cfg_por_usb_phy" protect="rw">
        <comment>CFG_POR_USB_PHY</comment>
        <bits access="rw" name="usb_por_rst" pos="3" rst="0x0">
          <comment>power on reset,reset all state machines,
1: the transmit and receive FSM are reset,
0: the transmit and receive FSM are operational</comment>
        </bits>
        <bits access="rw" name="usb_iso_sw_en" pos="2" rst="0x0">
          <comment>1: ISO Cell Enable, signals will be gated and output iso value
0: ISO Cell Disable, normal mode</comment>
        </bits>
        <bits access="rw" name="usb_ps_pd_l" pos="1" rst="0x0">
          <comment>Digital in USBPHY Power gating control (large switch), when power up ,need delay 100us after PD_S set to 1'b0;
1: power gating the USB2.0 CORE
0: enable the CORE power</comment>
        </bits>
        <bits access="rw" name="usb_ps_pd_s" pos="0" rst="0x0">
          <comment>Digital in USBPHY Power gating control (small switch)
1: power gating the USB2.0 CORE power
0: enable the CORE power</comment>
        </bits>
      </reg>
      <reg name="efs_por_read_block3" protect="rw">
        <comment>EFS_POR_READ_BLOCK3</comment>
      </reg>
      <reg name="efs_por_read_block89" protect="rw">
        <comment>EFS_POR_READ_BLOCK89</comment>
      </reg>
      <reg name="rc26m_pu_ctrl" protect="rw">
        <comment>RC26M_PU_CTRL</comment>
        <bits access="rw" name="rc26m_pu_sw" pos="1" rst="0x1">
          <comment>1: power up
0: power down</comment>
        </bits>
        <bits access="rw" name="rc26m_pu_ctrl_mode" pos="0" rst="0x0">
          <comment>1: hw mode, RC26M PU controlled by &quot;pd_xtal&quot; hardware signal from IDLE_LPS module.
0: sw mode, RC26M PU controlled by &quot;rc26m_pu_sw&quot; register bit.</comment>
        </bits>
      </reg>
      <reg name="aon_ahb_lp_ctrl" protect="rw">
        <comment>AON_AHB_LP_CTRL</comment>
        <bits access="rw" name="aon_ahb_lslp_sel" pos="6" rst="0x0">
          <comment>0: xtal_26m
1: rc26m</comment>
        </bits>
        <bits access="rw" name="aon_ahb_lslp_ctrl_en_cp" pos="5" rst="0x1">
          <comment>1: Aon ahb clock auto switch to 26M (bit[5] decide witch clock switch to) when CP_SYS in lightsleep mode(with also bit4 is &quot;1&quot;), and switch back to the clock witch software set(see &quot;cgm_aon_ahb_sel_cfg&quot; register at address 0x51508828) when wake-up.
0: Disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_lslp_ctrl_en_ap" pos="4" rst="0x1">
          <comment>1: Aon ahb clock auto switch to 26M (bit[5] decide witch clock switch to) when AP_SYS in lightsleep mode(with also bit5 is &quot;1&quot;), and switch back to the clock witch software set(see &quot;cgm_aon_ahb_sel_cfg&quot; register at address 0x51508828) when wake-up.
0: Disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_dslp_sel" pos="3" rst="0x0">
          <comment>0: xtal_26m
1: rc26m</comment>
        </bits>
        <bits access="rw" name="aon_ahb_dslp_slow_ctrl_en" pos="2" rst="0x1">
          <comment>1: Aon ahb clock auto switch to RC32K when chip in deepsleep mode, and switch back when wake-up (bit[3] decide witch clock switch back to). Hardware control signal is &quot;pd_pll&quot; from IDLE_LPS module.
0: Disable.</comment>
        </bits>
        <bits access="rw" name="aon_ahb_dslp_fast_ctrl_en" pos="1" rst="0x1">
          <comment>1: Aon ahb clock auto switch to 26M (bit[3] decide witch clock switch to) when chip in deepsleep mode, and switch back to the clock witch software set(see &quot;cgm_aon_ahb_sel_cfg&quot; register at address 0x51508828) when wake-up. Hardware control signal is &quot;pow_on&quot; from IDLE_LPS module.
0: Disable.</comment>
        </bits>
        <bits access="rw" name="lps_ahb_dslp_ctrl_en" pos="0" rst="0x0">
          <comment>1: Lps ahb clock auto switch to RC32K when chip in deepsleep mode, and switch back to the clock witch software set(see &quot;CFG_LPS_AHB_CLOCK_SEL&quot; register at address 0x51705030) when wake-up. Hardware control signal is &quot;pd_pll&quot; from IDLE_LPS module.
0: Disable.</comment>
        </bits>
      </reg>
      <reg name="usb_uart_swj_share_cfg" protect="rw">
        <comment>USB_UART_SWJ_SHARE_CFG</comment>
        <bits access="rw" name="usb_bypass_fs" pos="1" rst="0x0">
          <comment>1: uart or swj in use
0: USB in use</comment>
        </bits>
        <bits access="rw" name="uart_swj_sel" pos="0" rst="0x0">
          <comment>1: swj in use(with bit1 also set to &quot;1&quot;).
0: uart in use(with bit1 also set to &quot;1&quot;).</comment>
        </bits>
      </reg>
      <reg name="pu_clk26m_lp_iso_cfg" protect="rw">
        <comment>PU_CLK26M_LP_ISO_CFG</comment>
        <bits access="rw" name="pu_clk26m_lp_iso" pos="0" rst="0x1">
          <comment>1: ISO cell no work.
0: ISO work, signal clk_26m_lp clamp to &quot;0&quot;.</comment>
        </bits>
      </reg>
      <reg name="cfg_io_deep_sleep" protect="rw">
        <comment>CFG_IO_DEEP_SLEEP</comment>
        <bits access="rw" name="dslp_wp_io_sys1" pos="17" rst="0x0">
          <comment>0 : software mode: dslp_io_sys1 and dslp_wp_sys1 signal controlled by bit[2] and bit[3] of this register.
1 : hardware mode:  dslp_io_sys1 and dslp_wp_sys1 signal controlled by idst_cp signal of IDLE_LPS module.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_io_sys0" pos="16" rst="0x0">
          <comment>0 : software mode: dslp_io_sys0 and dslp_wp_sys0 signal controlled by bit[0] and bit[1] of this register.
1 : hardware mode:  dslp_io_sys0 and dslp_wp_sys0 signal controlled by idst_ap signal of IDLE_LPS module.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys5" pos="11" rst="0x0">
          <comment>pinmux dslp_wp_sys5 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys5" pos="10" rst="0x0">
          <comment>pinmux dslp_io_sys5 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys4" pos="9" rst="0x0">
          <comment>pinmux dslp_wp_sys4 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys4" pos="8" rst="0x0">
          <comment>pinmux dslp_io_sys4 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys3" pos="7" rst="0x0">
          <comment>pinmux dslp_wp_sys3 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys3" pos="6" rst="0x0">
          <comment>pinmux dslp_io_sys3 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys2" pos="5" rst="0x0">
          <comment>pinmux dslp_wp_sys2 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys2" pos="4" rst="0x0">
          <comment>pinmux dslp_io_sys2 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys1_sw" pos="3" rst="0x0">
          <comment>pinmux dslp_wp_sys1 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys1_sw" pos="2" rst="0x0">
          <comment>pinmux dslp_io_sys1 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_wp_sys0_sw" pos="1" rst="0x0">
          <comment>pinmux dslp_wp_sys0 signal control.</comment>
        </bits>
        <bits access="rw" name="dslp_io_sys0_sw" pos="0" rst="0x0">
          <comment>pinmux dslp_io_sys0 signal control.</comment>
        </bits>
      </reg>
      <reg name="cfg_lps_io_core_ie" protect="rw">
        <comment>CFG_LPS_IO_CORE_IE</comment>
      </reg>
      <reg name="cfg_simc_io" protect="rw">
        <comment>CFG_SIMC_IO</comment>
        <bits access="rw" name="core_out_sim_1_rst_sel" pos="15" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_oe_sim_1_dio_sel" pos="14" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_1_dio_sel" pos="13" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_1_clk_sel" pos="12" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_rst_sel" pos="11" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_oe_sim_0_dio_sel" pos="10" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_dio_sel" pos="9" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_clk_sel" pos="8" rst="0x0">
          <comment>0: sel hardware signal
1: sel software signal</comment>
        </bits>
        <bits access="rw" name="core_out_sim_1_rst_sw" pos="7" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_oe_sim_1_dio_sw" pos="6" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_out_sim_1_dio_sw" pos="5" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_out_sim_1_clk_sw" pos="4" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_rst_sw" pos="3" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_oe_sim_0_dio_sw" pos="2" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_dio_sw" pos="1" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
        <bits access="rw" name="core_out_sim_0_clk_sw" pos="0" rst="0x0">
          <comment>software control signal, valid when related sel bit is &quot;1&quot;</comment>
        </bits>
      </reg>
      <hole size="7072"/>
      <reg name="reset_sys_soft_set" protect="rw"/>
      <reg name="reset_lps_soft_set" protect="rw"/>
      <reg name="efuse_por_read_disable_set" protect="rw"/>
      <reg name="lps_clk_en_set" protect="rw"/>
      <reg name="lps_clk_auto_sel_set" protect="rw"/>
      <reg name="lps_clk_force_en_set" protect="rw"/>
      <hole size="64"/>
      <reg name="cfg_clk_uart1_set" protect="rw"/>
      <reg name="cfg_clk_rc26m_set" protect="rw"/>
      <hole size="192"/>
      <reg name="cfg_reset_enable_set" protect="rw"/>
      <reg name="reset_cause_set" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_plls_set" protect="rw"/>
      <hole size="96"/>
      <reg name="aon_iram_ctrl_set" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_por_usb_phy_set" protect="rw"/>
      <hole size="64"/>
      <reg name="rc26m_pu_ctrl_set" protect="rw"/>
      <reg name="aon_ahb_lp_ctrl_set" protect="rw"/>
      <reg name="usb_uart_swj_share_cfg_set" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_io_deep_sleep_set" protect="rw"/>
      <reg name="cfg_lps_io_core_ie_set" protect="rw"/>
      <reg name="cfg_simc_io_set" protect="rw"/>
      <hole size="7072"/>
      <reg name="reset_sys_soft_clr" protect="rw"/>
      <reg name="reset_lps_soft_clr" protect="rw"/>
      <reg name="efuse_por_read_disable_clr" protect="rw"/>
      <reg name="lps_clk_en_clr" protect="rw"/>
      <reg name="lps_clk_auto_sel_clr" protect="rw"/>
      <reg name="lps_clk_force_en_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="cfg_clk_uart1_clr" protect="rw"/>
      <reg name="cfg_clk_rc26m_clr" protect="rw"/>
      <hole size="192"/>
      <reg name="cfg_reset_enable_clr" protect="rw"/>
      <reg name="reset_cause_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_plls_clr" protect="rw"/>
      <hole size="96"/>
      <reg name="aon_iram_ctrl_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_por_usb_phy_clr" protect="rw"/>
      <hole size="64"/>
      <reg name="rc26m_pu_ctrl_clr" protect="rw"/>
      <reg name="aon_ahb_lp_ctrl_clr" protect="rw"/>
      <reg name="usb_uart_swj_share_cfg_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="cfg_io_deep_sleep_clr" protect="rw"/>
      <reg name="cfg_lps_io_core_ie_clr" protect="rw"/>
      <reg name="cfg_simc_io_clr" protect="rw"/>
    </module>
    <var name="REG_LPS_APB_SET_OFFSET" value="0x400"/>
    <var name="REG_LPS_APB_CLR_OFFSET" value="0x800"/>
    <instance address="0x51705000" name="LPS_APB" type="LPS_APB"/>
  </archive>
  <archive relative="reg_fw_iomux.xml">
    <module category="System" name="REG_FW_IOMUX">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="adi_sda_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_4_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_5_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_6_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_7_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_1_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_2_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_3_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_0_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_cts_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_rxd_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_txd_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_rts_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_4_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_5_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_5_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_4_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_0_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_1_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_2_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_3_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_4_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_5_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_6_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_7_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg5_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg4_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg3_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg2_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg1_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg0_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_1" protect="rw">
        <comment>REG_RD_CTRL_1 REG_RD_CTRL_1</comment>
        <bits access="rw" name="nand_sel_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m2_sda_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m2_scl_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_mclk_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_bck_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_lrck_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_sdat_o_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s_sdat_i_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_pwdn_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_ref_clk_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_si_0_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_si_1_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_sck_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_rst_l_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_clk_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_rx_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_tx_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sw_dio_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sw_clk_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_clk_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_dio_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_rst_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_clk_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_dio_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_rst_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk26m_pmic_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ptest_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="chip_pd_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pmic_ext_int_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="osc_32k_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="resetb_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="adi_scl_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_2" protect="rw">
        <comment>REG_RD_CTRL_2 REG_RD_CTRL_2</comment>
        <bits access="rw" name="i2c_m1_scl_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m1_sda_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_rxd_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_txd_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_cts_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_rts_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_clk_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_cmd_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_0_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_1_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_2_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_3_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_4_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_5_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_6_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_7_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_rst_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_sio_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_sdc_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_clk_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_cs_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_select_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lcd_fmark_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lcd_rstb_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_0_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_1_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_2_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_3_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_0_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_1_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_2_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_3_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_3" protect="rw">
        <comment>REG_RD_CTRL_3 REG_RD_CTRL_3</comment>
        <bits access="rw" name="m_spi_clk_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_cs_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_0_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_1_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_2_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_3_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_16_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_17_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_18_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_19_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_20_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_21_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_22_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_23_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="adi_sda_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_4_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_5_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_6_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_7_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_1_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_2_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_3_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_0_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_cts_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_rxd_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_txd_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_1_rts_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_4_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_5_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_5_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_4_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_0_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_1_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_2_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_3_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_4_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_5_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_6_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="rfdig_gpio_7_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg5_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg4_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg3_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg2_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg1_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pin_ctrl_reg0_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_1" protect="rw">
        <comment>REG_WR_CTRL_1 REG_WR_CTRL_1</comment>
        <bits access="rw" name="nand_sel_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m2_sda_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m2_scl_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_mclk_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_bck_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_lrck_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s1_sdat_o_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2s_sdat_i_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_pwdn_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_ref_clk_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_si_0_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_si_1_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_camera_sck_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="camera_rst_l_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_clk_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_rx_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_host_tx_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sw_dio_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sw_clk_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_clk_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_dio_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_0_rst_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_clk_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_dio_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sim_1_rst_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk26m_pmic_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ptest_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="chip_pd_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="pmic_ext_int_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="osc_32k_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="resetb_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="adi_scl_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_2" protect="rw">
        <comment>REG_WR_CTRL_2 REG_WR_CTRL_2</comment>
        <bits access="rw" name="i2c_m1_scl_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="i2c_m1_sda_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_rxd_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_txd_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_cts_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="uart_2_rts_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_clk_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_cmd_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_0_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_1_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_2_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_3_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_4_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_5_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_6_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_data_7_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sdmmc1_rst_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_sio_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_sdc_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_clk_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_cs_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="spi_lcd_select_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lcd_fmark_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lcd_rstb_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_0_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_1_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_2_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyin_3_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_0_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_1_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_2_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="keyout_3_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_3" protect="rw">
        <comment>REG_WR_CTRL_3 REG_WR_CTRL_3</comment>
        <bits access="rw" name="m_spi_clk_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_cs_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_0_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_1_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_2_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m_spi_d_3_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_16_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_17_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_18_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_19_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_20_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_21_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_22_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="gpio_23_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array0" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY0 BIT_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_ctrl_addr_array0" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array1" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY1 BIT_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_ctrl_addr_array1" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array2" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY2 BIT_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_ctrl_addr_array2" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array3" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY3 BIT_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_ctrl_addr_array3" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array4" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY4 BIT_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_ctrl_addr_array4" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array5" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY5 BIT_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_ctrl_addr_array5" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array6" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY6 BIT_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_ctrl_addr_array6" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array7" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY7 BIT_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_ctrl_addr_array7" pos="13:0" rst="0x3fff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_array0" protect="rw">
        <comment>BIT_CTRL_ARRAY0 BIT_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_ctrl_array1" protect="rw">
        <comment>BIT_CTRL_ARRAY1 BIT_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_ctrl_array2" protect="rw">
        <comment>BIT_CTRL_ARRAY2 BIT_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_ctrl_array3" protect="rw">
        <comment>BIT_CTRL_ARRAY3 BIT_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_ctrl_array4" protect="rw">
        <comment>BIT_CTRL_ARRAY4 BIT_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_ctrl_array5" protect="rw">
        <comment>BIT_CTRL_ARRAY5 BIT_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_ctrl_array6" protect="rw">
        <comment>BIT_CTRL_ARRAY6 BIT_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_ctrl_array7" protect="rw">
        <comment>BIT_CTRL_ARRAY7 BIT_CTRL_ARRAY7</comment>
      </reg>
    </module>
    <instance address="0x51306000" name="REG_FW_IOMUX" type="REG_FW_IOMUX"/>
  </archive>
  <archive relative="reg_fw_ap_apb.xml">
    <module category="System" name="REG_FW_AP_APB">
      <reg name="reg_rd_ctrl_0" protect="rw">
        <comment>REG_RD_CTRL_0 REG_RD_CTRL_0</comment>
        <bits access="rw" name="cfg_qos1_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_qos0_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="chip_prod_id_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="misc_cfg_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cache_emmc_sdio_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="main_lpc_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s6_lpc_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s5_lpc_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s4_lpc_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s3_lpc_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s2_lpc_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s1_lpc_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s0_lpc_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m9_lpc_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m8_lpc_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m7_lpc_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m6_lpc_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m5_lpc_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m4_lpc_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m3_lpc_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m2_lpc_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m1_lpc_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m0_lpc_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst2_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst1_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst0_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en2_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode2_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en1_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode1_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en0_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode0_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_1" protect="rw">
        <comment>REG_RD_CTRL_1 REG_RD_CTRL_1</comment>
        <bits access="rw" name="cfg_clk_spiflash1_rd_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart6_rd_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart5_rd_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart4_rd_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status4_rd_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status3_rd_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status2_rd_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status1_rd_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status0_rd_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status3_rd_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status2_rd_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status1_rd_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status0_rd_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en3_rd_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en2_rd_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en1_rd_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en0_rd_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel3_rd_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel2_rd_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel1_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel0_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_bridge_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt_ctrl_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt32k_th1_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt32k_th0_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th3_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th2_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th1_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th0_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="xhb_awsparse_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_monitor_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_qos2_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_rd_ctrl_2" protect="rw">
        <comment>REG_RD_CTRL_2 REG_RD_CTRL_2</comment>
        <bits access="rw" name="ap2pub_bridge_debug_rd_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap2pub_bridge_status_rd_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd3_rd_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd2_rd_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd1_rd_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd0_rd_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="anti_hang_rd_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="light_sleep_bypass1_rd_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="light_sleep_bypass0_rd_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sleep_ctrl_rd_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lp_force_rd_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_apcpu_dbgen_rd_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_spiflash2_rd_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_0" protect="rw">
        <comment>REG_WR_CTRL_0 REG_WR_CTRL_0</comment>
        <bits access="rw" name="cfg_qos1_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_qos0_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="chip_prod_id_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="misc_cfg_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cache_emmc_sdio_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="main_lpc_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s6_lpc_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s5_lpc_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s4_lpc_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s3_lpc_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s2_lpc_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s1_lpc_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="s0_lpc_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m9_lpc_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m8_lpc_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m7_lpc_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m6_lpc_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m5_lpc_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m4_lpc_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m3_lpc_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m2_lpc_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m1_lpc_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="m0_lpc_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst2_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst1_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_rst0_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en2_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode2_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en1_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode1_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_en0_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_ap_mode0_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_1" protect="rw">
        <comment>REG_WR_CTRL_1 REG_WR_CTRL_1</comment>
        <bits access="rw" name="cfg_clk_spiflash1_wr_sec" pos="31" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart6_wr_sec" pos="30" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart5_wr_sec" pos="29" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_uart4_wr_sec" pos="28" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status4_wr_sec" pos="27" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status3_wr_sec" pos="26" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status2_wr_sec" pos="25" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status1_wr_sec" pos="24" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_cgm_busy_status0_wr_sec" pos="23" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status3_wr_sec" pos="22" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status2_wr_sec" pos="21" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status1_wr_sec" pos="20" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="mnt_gate_en_status0_wr_sec" pos="19" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en3_wr_sec" pos="18" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en2_wr_sec" pos="17" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en1_wr_sec" pos="16" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_force_en0_wr_sec" pos="15" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel3_wr_sec" pos="14" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel2_wr_sec" pos="13" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel1_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cgm_gate_auto_sel0_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_bridge_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt_ctrl_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt32k_th1_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt32k_th0_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th3_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th2_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th1_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="clk_mnt26m_th0_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="xhb_awsparse_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="debug_monitor_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_qos2_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="reg_wr_ctrl_2" protect="rw">
        <comment>REG_WR_CTRL_2 REG_WR_CTRL_2</comment>
        <bits access="rw" name="ap2pub_bridge_debug_wr_sec" pos="12" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap2pub_bridge_status_wr_sec" pos="11" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd3_wr_sec" pos="10" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd2_wr_sec" pos="9" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd1_wr_sec" pos="8" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="ap_apb_rsd0_wr_sec" pos="7" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="anti_hang_wr_sec" pos="6" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="light_sleep_bypass1_wr_sec" pos="5" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="light_sleep_bypass0_wr_sec" pos="4" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="sleep_ctrl_wr_sec" pos="3" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="lp_force_wr_sec" pos="2" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_apcpu_dbgen_wr_sec" pos="1" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
        <bits access="rw" name="cfg_clk_spiflash2_wr_sec" pos="0" rst="0x0">
          <comment>control reg read security attribute:
0: Non security.
1: Security.</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array0" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY0 BIT_CTRL_ADDR_ARRAY0</comment>
        <bits access="rw" name="bit_ctrl_addr_array0" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array0</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array1" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY1 BIT_CTRL_ADDR_ARRAY1</comment>
        <bits access="rw" name="bit_ctrl_addr_array1" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array1</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array2" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY2 BIT_CTRL_ADDR_ARRAY2</comment>
        <bits access="rw" name="bit_ctrl_addr_array2" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array2</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array3" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY3 BIT_CTRL_ADDR_ARRAY3</comment>
        <bits access="rw" name="bit_ctrl_addr_array3" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array3</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array4" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY4 BIT_CTRL_ADDR_ARRAY4</comment>
        <bits access="rw" name="bit_ctrl_addr_array4" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array4</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array5" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY5 BIT_CTRL_ADDR_ARRAY5</comment>
        <bits access="rw" name="bit_ctrl_addr_array5" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array5</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array6" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY6 BIT_CTRL_ADDR_ARRAY6</comment>
        <bits access="rw" name="bit_ctrl_addr_array6" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array6</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array7" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY7 BIT_CTRL_ADDR_ARRAY7</comment>
        <bits access="rw" name="bit_ctrl_addr_array7" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array7</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array8" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY8 BIT_CTRL_ADDR_ARRAY8</comment>
        <bits access="rw" name="bit_ctrl_addr_array8" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array8</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array9" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY9 BIT_CTRL_ADDR_ARRAY9</comment>
        <bits access="rw" name="bit_ctrl_addr_array9" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array9</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array10" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY10 BIT_CTRL_ADDR_ARRAY10</comment>
        <bits access="rw" name="bit_ctrl_addr_array10" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array10</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array11" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY11 BIT_CTRL_ADDR_ARRAY11</comment>
        <bits access="rw" name="bit_ctrl_addr_array11" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array11</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array12" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY12 BIT_CTRL_ADDR_ARRAY12</comment>
        <bits access="rw" name="bit_ctrl_addr_array12" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array12</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array13" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY13 BIT_CTRL_ADDR_ARRAY13</comment>
        <bits access="rw" name="bit_ctrl_addr_array13" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array13</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array14" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY14 BIT_CTRL_ADDR_ARRAY14</comment>
        <bits access="rw" name="bit_ctrl_addr_array14" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array14</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_addr_array15" protect="rw">
        <comment>BIT_CTRL_ADDR_ARRAY15 BIT_CTRL_ADDR_ARRAY15</comment>
        <bits access="rw" name="bit_ctrl_addr_array15" pos="11:0" rst="0xfff">
          <comment>the addr[32:0] of bit control array15</comment>
        </bits>
      </reg>
      <reg name="bit_ctrl_array0" protect="rw">
        <comment>BIT_CTRL_ARRAY0 BIT_CTRL_ARRAY0</comment>
      </reg>
      <reg name="bit_ctrl_array1" protect="rw">
        <comment>BIT_CTRL_ARRAY1 BIT_CTRL_ARRAY1</comment>
      </reg>
      <reg name="bit_ctrl_array2" protect="rw">
        <comment>BIT_CTRL_ARRAY2 BIT_CTRL_ARRAY2</comment>
      </reg>
      <reg name="bit_ctrl_array3" protect="rw">
        <comment>BIT_CTRL_ARRAY3 BIT_CTRL_ARRAY3</comment>
      </reg>
      <reg name="bit_ctrl_array4" protect="rw">
        <comment>BIT_CTRL_ARRAY4 BIT_CTRL_ARRAY4</comment>
      </reg>
      <reg name="bit_ctrl_array5" protect="rw">
        <comment>BIT_CTRL_ARRAY5 BIT_CTRL_ARRAY5</comment>
      </reg>
      <reg name="bit_ctrl_array6" protect="rw">
        <comment>BIT_CTRL_ARRAY6 BIT_CTRL_ARRAY6</comment>
      </reg>
      <reg name="bit_ctrl_array7" protect="rw">
        <comment>BIT_CTRL_ARRAY7 BIT_CTRL_ARRAY7</comment>
      </reg>
      <reg name="bit_ctrl_array8" protect="rw">
        <comment>BIT_CTRL_ARRAY8 BIT_CTRL_ARRAY8</comment>
      </reg>
      <reg name="bit_ctrl_array9" protect="rw">
        <comment>BIT_CTRL_ARRAY9 BIT_CTRL_ARRAY9</comment>
      </reg>
      <reg name="bit_ctrl_array10" protect="rw">
        <comment>BIT_CTRL_ARRAY10 BIT_CTRL_ARRAY10</comment>
      </reg>
      <reg name="bit_ctrl_array11" protect="rw">
        <comment>BIT_CTRL_ARRAY11 BIT_CTRL_ARRAY11</comment>
      </reg>
      <reg name="bit_ctrl_array12" protect="rw">
        <comment>BIT_CTRL_ARRAY12 BIT_CTRL_ARRAY12</comment>
      </reg>
      <reg name="bit_ctrl_array13" protect="rw">
        <comment>BIT_CTRL_ARRAY13 BIT_CTRL_ARRAY13</comment>
      </reg>
      <reg name="bit_ctrl_array14" protect="rw">
        <comment>BIT_CTRL_ARRAY14 BIT_CTRL_ARRAY14</comment>
      </reg>
      <reg name="bit_ctrl_array15" protect="rw">
        <comment>BIT_CTRL_ARRAY15 BIT_CTRL_ARRAY15</comment>
      </reg>
    </module>
    <instance address="0x5132a000" name="REG_FW_AP_APB" type="REG_FW_AP_APB"/>
  </archive>
  <archive relative="slv_fw_lps_ifc.xml">
    <module category="System" name="SLV_FW_LPS_IFC">
      <reg name="port0_default_address_0" protect="rw">
        <comment>port0 default address, bit 0 ~ 15. port0 default address, bit 0 ~ 15.</comment>
        <bits access="rw" name="port0_default_address_0" pos="15:0" rst="0xdf00"/>
      </reg>
      <reg name="port_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int write-clear</comment>
        </bits>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_raw" protect="rw">
        <comment>Original interrupt reg %d Original interrupt reg %d</comment>
        <bits access="r" name="port_0_r_raw" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_fin" protect="rw">
        <comment>Final interrupt reg %d Final interrupt reg %d</comment>
        <bits access="r" name="port_0_r_fin" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="uart1_rd_sec" pos="17:16" rst="0x3">
          <comment>control uart1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="idle_lps_rd_sec" pos="15:14" rst="0x3">
          <comment>control idle_lps_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpio1_rd_sec" pos="13:12" rst="0x3">
          <comment>control gpio1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="apb_reg_rd_sec" pos="11:10" rst="0x3">
          <comment>control apb_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="keypad_rd_sec" pos="9:8" rst="0x3">
          <comment>control keypad_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pwrctrl_rd_sec" pos="7:6" rst="0x3">
          <comment>control pwrctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="rtc_timer_rd_sec" pos="5:4" rst="0x3">
          <comment>control rtc_timer_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap3_rd_sec" pos="3:2" rst="0x3">
          <comment>control ana_wrap3_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="lps_ifc_rd_sec" pos="1:0" rst="0x3">
          <comment>control lps_ifc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="uart1_wr_sec" pos="17:16" rst="0x3">
          <comment>control uart1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="idle_lps_wr_sec" pos="15:14" rst="0x3">
          <comment>control idle_lps_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpio1_wr_sec" pos="13:12" rst="0x3">
          <comment>control gpio1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="apb_reg_wr_sec" pos="11:10" rst="0x3">
          <comment>control apb_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="keypad_wr_sec" pos="9:8" rst="0x3">
          <comment>control keypad_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pwrctrl_wr_sec" pos="7:6" rst="0x3">
          <comment>control pwrctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="rtc_timer_wr_sec" pos="5:4" rst="0x3">
          <comment>control rtc_timer_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap3_wr_sec" pos="3:2" rst="0x3">
          <comment>control ana_wrap3_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="lps_ifc_wr_sec" pos="1:0" rst="0x3">
          <comment>control lps_ifc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="id0_first_addr_0" protect="rw">
        <comment>id0 first_addr control id0 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id0_last_addr_0" protect="rw">
        <comment>id0 last_addr control id0 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id0_mstid_0" protect="rw">
        <comment>id0 mstid_0 master id control id0 mstid_0 master id control</comment>
      </reg>
      <reg name="id0_mstid_1" protect="rw">
        <comment>id0 mstid_1 master id control id0 mstid_1 master id control</comment>
      </reg>
      <reg name="id0_mstid_2" protect="rw">
        <comment>id0 mstid_2 master id control id0 mstid_2 master id control</comment>
      </reg>
      <reg name="id0_mstid_3" protect="rw">
        <comment>id0 mstid_3 master id control id0 mstid_3 master id control</comment>
      </reg>
      <reg name="id0_mstid_4" protect="rw">
        <comment>id0 mstid_4 master id control id0 mstid_4 master id control</comment>
      </reg>
      <reg name="id0_mstid_5" protect="rw">
        <comment>id0 mstid_5 master id control id0 mstid_5 master id control</comment>
      </reg>
      <reg name="id0_mstid_6" protect="rw">
        <comment>id0 mstid_6 master id control id0 mstid_6 master id control</comment>
      </reg>
      <reg name="id0_mstid_7" protect="rw">
        <comment>id0 mstid_7 master id control id0 mstid_7 master id control</comment>
      </reg>
      <reg name="id1_first_addr_0" protect="rw">
        <comment>id1 first_addr control id1 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id1_last_addr_0" protect="rw">
        <comment>id1 last_addr control id1 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id1_mstid_0" protect="rw">
        <comment>id1 mstid_0 master id control id1 mstid_0 master id control</comment>
      </reg>
      <reg name="id1_mstid_1" protect="rw">
        <comment>id1 mstid_1 master id control id1 mstid_1 master id control</comment>
      </reg>
      <reg name="id1_mstid_2" protect="rw">
        <comment>id1 mstid_2 master id control id1 mstid_2 master id control</comment>
      </reg>
      <reg name="id1_mstid_3" protect="rw">
        <comment>id1 mstid_3 master id control id1 mstid_3 master id control</comment>
      </reg>
      <reg name="id1_mstid_4" protect="rw">
        <comment>id1 mstid_4 master id control id1 mstid_4 master id control</comment>
      </reg>
      <reg name="id1_mstid_5" protect="rw">
        <comment>id1 mstid_5 master id control id1 mstid_5 master id control</comment>
      </reg>
      <reg name="id1_mstid_6" protect="rw">
        <comment>id1 mstid_6 master id control id1 mstid_6 master id control</comment>
      </reg>
      <reg name="id1_mstid_7" protect="rw">
        <comment>id1 mstid_7 master id control id1 mstid_7 master id control</comment>
      </reg>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clk_gate_bypass clk_gate_bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clk_gate_bypass</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51300000" name="SLV_FW_LPS_IFC" type="SLV_FW_LPS_IFC"/>
  </archive>
  <archive relative="slv_fw_ap_ifc.xml">
    <module category="System" name="SLV_FW_AP_IFC">
      <reg name="port0_default_address_0" protect="rw">
        <comment>port0 default address, bit 0 ~ 15. port0 default address, bit 0 ~ 15.</comment>
        <bits access="rw" name="port0_default_address_0" pos="15:0" rst="0xe000"/>
      </reg>
      <reg name="port_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int write-clear</comment>
        </bits>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_raw" protect="rw">
        <comment>Original interrupt reg %d Original interrupt reg %d</comment>
        <bits access="r" name="port_0_r_raw" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_fin" protect="rw">
        <comment>Final interrupt reg %d Final interrupt reg %d</comment>
        <bits access="r" name="port_0_r_fin" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="uart4_rd_sec" pos="11:10" rst="0x3">
          <comment>control uart4_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart5_rd_sec" pos="9:8" rst="0x3">
          <comment>control uart5_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart6_rd_sec" pos="7:6" rst="0x3">
          <comment>control uart6_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sdmmc_rd_sec" pos="5:4" rst="0x3">
          <comment>control sdmmc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="camera_rd_sec" pos="3:2" rst="0x3">
          <comment>control camera_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_ifc_rd_sec" pos="1:0" rst="0x3">
          <comment>control ap_ifc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="uart4_wr_sec" pos="11:10" rst="0x3">
          <comment>control uart4_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart5_wr_sec" pos="9:8" rst="0x3">
          <comment>control uart5_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart6_wr_sec" pos="7:6" rst="0x3">
          <comment>control uart6_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sdmmc_wr_sec" pos="5:4" rst="0x3">
          <comment>control sdmmc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="camera_wr_sec" pos="3:2" rst="0x3">
          <comment>control camera_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_ifc_wr_sec" pos="1:0" rst="0x3">
          <comment>control ap_ifc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="id0_first_addr_0" protect="rw">
        <comment>id0 first_addr control id0 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id0_last_addr_0" protect="rw">
        <comment>id0 last_addr control id0 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id0_mstid_0" protect="rw">
        <comment>id0 mstid_0 master id control id0 mstid_0 master id control</comment>
      </reg>
      <reg name="id0_mstid_1" protect="rw">
        <comment>id0 mstid_1 master id control id0 mstid_1 master id control</comment>
      </reg>
      <reg name="id0_mstid_2" protect="rw">
        <comment>id0 mstid_2 master id control id0 mstid_2 master id control</comment>
      </reg>
      <reg name="id0_mstid_3" protect="rw">
        <comment>id0 mstid_3 master id control id0 mstid_3 master id control</comment>
      </reg>
      <reg name="id0_mstid_4" protect="rw">
        <comment>id0 mstid_4 master id control id0 mstid_4 master id control</comment>
      </reg>
      <reg name="id0_mstid_5" protect="rw">
        <comment>id0 mstid_5 master id control id0 mstid_5 master id control</comment>
      </reg>
      <reg name="id0_mstid_6" protect="rw">
        <comment>id0 mstid_6 master id control id0 mstid_6 master id control</comment>
      </reg>
      <reg name="id0_mstid_7" protect="rw">
        <comment>id0 mstid_7 master id control id0 mstid_7 master id control</comment>
      </reg>
      <reg name="id1_first_addr_0" protect="rw">
        <comment>id1 first_addr control id1 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id1_last_addr_0" protect="rw">
        <comment>id1 last_addr control id1 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id1_mstid_0" protect="rw">
        <comment>id1 mstid_0 master id control id1 mstid_0 master id control</comment>
      </reg>
      <reg name="id1_mstid_1" protect="rw">
        <comment>id1 mstid_1 master id control id1 mstid_1 master id control</comment>
      </reg>
      <reg name="id1_mstid_2" protect="rw">
        <comment>id1 mstid_2 master id control id1 mstid_2 master id control</comment>
      </reg>
      <reg name="id1_mstid_3" protect="rw">
        <comment>id1 mstid_3 master id control id1 mstid_3 master id control</comment>
      </reg>
      <reg name="id1_mstid_4" protect="rw">
        <comment>id1 mstid_4 master id control id1 mstid_4 master id control</comment>
      </reg>
      <reg name="id1_mstid_5" protect="rw">
        <comment>id1 mstid_5 master id control id1 mstid_5 master id control</comment>
      </reg>
      <reg name="id1_mstid_6" protect="rw">
        <comment>id1 mstid_6 master id control id1 mstid_6 master id control</comment>
      </reg>
      <reg name="id1_mstid_7" protect="rw">
        <comment>id1 mstid_7 master id control id1 mstid_7 master id control</comment>
      </reg>
      <reg name="id2_first_addr_0" protect="rw">
        <comment>id2 first_addr control id2 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id2_last_addr_0" protect="rw">
        <comment>id2 last_addr control id2 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id2_mstid_0" protect="rw">
        <comment>id2 mstid_0 master id control id2 mstid_0 master id control</comment>
      </reg>
      <reg name="id2_mstid_1" protect="rw">
        <comment>id2 mstid_1 master id control id2 mstid_1 master id control</comment>
      </reg>
      <reg name="id2_mstid_2" protect="rw">
        <comment>id2 mstid_2 master id control id2 mstid_2 master id control</comment>
      </reg>
      <reg name="id2_mstid_3" protect="rw">
        <comment>id2 mstid_3 master id control id2 mstid_3 master id control</comment>
      </reg>
      <reg name="id2_mstid_4" protect="rw">
        <comment>id2 mstid_4 master id control id2 mstid_4 master id control</comment>
      </reg>
      <reg name="id2_mstid_5" protect="rw">
        <comment>id2 mstid_5 master id control id2 mstid_5 master id control</comment>
      </reg>
      <reg name="id2_mstid_6" protect="rw">
        <comment>id2 mstid_6 master id control id2 mstid_6 master id control</comment>
      </reg>
      <reg name="id2_mstid_7" protect="rw">
        <comment>id2 mstid_7 master id control id2 mstid_7 master id control</comment>
      </reg>
      <reg name="id3_first_addr_0" protect="rw">
        <comment>id3 first_addr control id3 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id3_last_addr_0" protect="rw">
        <comment>id3 last_addr control id3 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id3_mstid_0" protect="rw">
        <comment>id3 mstid_0 master id control id3 mstid_0 master id control</comment>
      </reg>
      <reg name="id3_mstid_1" protect="rw">
        <comment>id3 mstid_1 master id control id3 mstid_1 master id control</comment>
      </reg>
      <reg name="id3_mstid_2" protect="rw">
        <comment>id3 mstid_2 master id control id3 mstid_2 master id control</comment>
      </reg>
      <reg name="id3_mstid_3" protect="rw">
        <comment>id3 mstid_3 master id control id3 mstid_3 master id control</comment>
      </reg>
      <reg name="id3_mstid_4" protect="rw">
        <comment>id3 mstid_4 master id control id3 mstid_4 master id control</comment>
      </reg>
      <reg name="id3_mstid_5" protect="rw">
        <comment>id3 mstid_5 master id control id3 mstid_5 master id control</comment>
      </reg>
      <reg name="id3_mstid_6" protect="rw">
        <comment>id3 mstid_6 master id control id3 mstid_6 master id control</comment>
      </reg>
      <reg name="id3_mstid_7" protect="rw">
        <comment>id3 mstid_7 master id control id3 mstid_7 master id control</comment>
      </reg>
      <reg name="id4_first_addr_0" protect="rw">
        <comment>id4 first_addr control id4 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id4_last_addr_0" protect="rw">
        <comment>id4 last_addr control id4 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id4_mstid_0" protect="rw">
        <comment>id4 mstid_0 master id control id4 mstid_0 master id control</comment>
      </reg>
      <reg name="id4_mstid_1" protect="rw">
        <comment>id4 mstid_1 master id control id4 mstid_1 master id control</comment>
      </reg>
      <reg name="id4_mstid_2" protect="rw">
        <comment>id4 mstid_2 master id control id4 mstid_2 master id control</comment>
      </reg>
      <reg name="id4_mstid_3" protect="rw">
        <comment>id4 mstid_3 master id control id4 mstid_3 master id control</comment>
      </reg>
      <reg name="id4_mstid_4" protect="rw">
        <comment>id4 mstid_4 master id control id4 mstid_4 master id control</comment>
      </reg>
      <reg name="id4_mstid_5" protect="rw">
        <comment>id4 mstid_5 master id control id4 mstid_5 master id control</comment>
      </reg>
      <reg name="id4_mstid_6" protect="rw">
        <comment>id4 mstid_6 master id control id4 mstid_6 master id control</comment>
      </reg>
      <reg name="id4_mstid_7" protect="rw">
        <comment>id4 mstid_7 master id control id4 mstid_7 master id control</comment>
      </reg>
      <reg name="id5_first_addr_0" protect="rw">
        <comment>id5 first_addr control id5 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id5_last_addr_0" protect="rw">
        <comment>id5 last_addr control id5 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id5_mstid_0" protect="rw">
        <comment>id5 mstid_0 master id control id5 mstid_0 master id control</comment>
      </reg>
      <reg name="id5_mstid_1" protect="rw">
        <comment>id5 mstid_1 master id control id5 mstid_1 master id control</comment>
      </reg>
      <reg name="id5_mstid_2" protect="rw">
        <comment>id5 mstid_2 master id control id5 mstid_2 master id control</comment>
      </reg>
      <reg name="id5_mstid_3" protect="rw">
        <comment>id5 mstid_3 master id control id5 mstid_3 master id control</comment>
      </reg>
      <reg name="id5_mstid_4" protect="rw">
        <comment>id5 mstid_4 master id control id5 mstid_4 master id control</comment>
      </reg>
      <reg name="id5_mstid_5" protect="rw">
        <comment>id5 mstid_5 master id control id5 mstid_5 master id control</comment>
      </reg>
      <reg name="id5_mstid_6" protect="rw">
        <comment>id5 mstid_6 master id control id5 mstid_6 master id control</comment>
      </reg>
      <reg name="id5_mstid_7" protect="rw">
        <comment>id5 mstid_7 master id control id5 mstid_7 master id control</comment>
      </reg>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clk_gate_bypass clk_gate_bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clk_gate_bypass</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51321000" name="SLV_FW_AP_IFC" type="SLV_FW_AP_IFC"/>
  </archive>
  <archive relative="slv_fw_ap_ahb.xml">
    <module category="System" name="SLV_FW_AP_AHB">
      <reg name="port0_default_address_0" protect="rw">
        <comment>port0 default address, bit 0 ~ 26. port0 default address, bit 0 ~ 26.</comment>
        <bits access="rw" name="port0_default_address_0" pos="26:0" rst="0x7fff000"/>
      </reg>
      <reg name="port_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int write-clear</comment>
        </bits>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_raw" protect="rw">
        <comment>Original interrupt reg %d Original interrupt reg %d</comment>
        <bits access="r" name="port_0_r_raw" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_fin" protect="rw">
        <comment>Final interrupt reg %d Final interrupt reg %d</comment>
        <bits access="r" name="port_0_r_fin" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="emmc_rd_sec" pos="31:30" rst="0x3">
          <comment>control emmc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spi1_rd_sec" pos="29:28" rst="0x3">
          <comment>control spi1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="lzma_rd_sec" pos="27:26" rst="0x3">
          <comment>control lzma_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_imem_rd_sec" pos="25:24" rst="0x3">
          <comment>control ap_imem_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_busmon_rd_sec" pos="23:22" rst="0x3">
          <comment>control ap_busmon_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="apb_reg_rd_sec" pos="21:20" rst="0x3">
          <comment>control apb_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gouda_reg_rd_sec" pos="19:18" rst="0x3">
          <comment>control gouda_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_0_rd_sec" pos="17:16" rst="0x3">
          <comment>control timer1_0_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_wd_rd_sec" pos="15:14" rst="0x3">
          <comment>control timer1_wd_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_1_rd_sec" pos="13:12" rst="0x3">
          <comment>control timer1_1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer2_rd_sec" pos="11:10" rst="0x3">
          <comment>control timer2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer5_rd_sec" pos="9:8" rst="0x3">
          <comment>control timer5_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c1_rd_sec" pos="7:6" rst="0x3">
          <comment>control i2c1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c2_rd_sec" pos="5:4" rst="0x3">
          <comment>control i2c2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt3_rd_sec" pos="3:2" rst="0x3">
          <comment>control gpt3_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_clk_rd_sec" pos="1:0" rst="0x3">
          <comment>control ap_clk_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="rd_sec_1" protect="rw">
        <comment>rd 1 sec control rd 1 sec control</comment>
        <bits access="rw" name="spiflash1_reg_rd_sec" pos="15:14" rst="0x3">
          <comment>control spiflash1_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spiflash2_reg_rd_sec" pos="13:12" rst="0x3">
          <comment>control spiflash2_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gouda_rd_sec" pos="11:10" rst="0x3">
          <comment>control gouda_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_axidma_rd_sec" pos="9:8" rst="0x3">
          <comment>control ap_axidma_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="usb_rd_sec" pos="7:6" rst="0x3">
          <comment>control usb_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="med_rd_sec" pos="5:4" rst="0x3">
          <comment>control med_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ce_pub_rd_sec" pos="3:2" rst="0x3">
          <comment>control ce_pub_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ce_sec_rd_sec" pos="1:0" rst="0x3">
          <comment>control ce_sec_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="emmc_wr_sec" pos="31:30" rst="0x3">
          <comment>control emmc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spi1_wr_sec" pos="29:28" rst="0x3">
          <comment>control spi1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="lzma_wr_sec" pos="27:26" rst="0x3">
          <comment>control lzma_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_imem_wr_sec" pos="25:24" rst="0x3">
          <comment>control ap_imem_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_busmon_wr_sec" pos="23:22" rst="0x3">
          <comment>control ap_busmon_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="apb_reg_wr_sec" pos="21:20" rst="0x3">
          <comment>control apb_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gouda_reg_wr_sec" pos="19:18" rst="0x3">
          <comment>control gouda_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_0_wr_sec" pos="17:16" rst="0x3">
          <comment>control timer1_0_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_wd_wr_sec" pos="15:14" rst="0x3">
          <comment>control timer1_wd_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer1_1_wr_sec" pos="13:12" rst="0x3">
          <comment>control timer1_1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer2_wr_sec" pos="11:10" rst="0x3">
          <comment>control timer2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="timer5_wr_sec" pos="9:8" rst="0x3">
          <comment>control timer5_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c1_wr_sec" pos="7:6" rst="0x3">
          <comment>control i2c1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c2_wr_sec" pos="5:4" rst="0x3">
          <comment>control i2c2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt3_wr_sec" pos="3:2" rst="0x3">
          <comment>control gpt3_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_clk_wr_sec" pos="1:0" rst="0x3">
          <comment>control ap_clk_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_1" protect="rw">
        <comment>wr 1 sec control wr 1 sec control</comment>
        <bits access="rw" name="spiflash1_reg_wr_sec" pos="15:14" rst="0x3">
          <comment>control spiflash1_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spiflash2_reg_wr_sec" pos="13:12" rst="0x3">
          <comment>control spiflash2_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gouda_wr_sec" pos="11:10" rst="0x3">
          <comment>control gouda_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ap_axidma_wr_sec" pos="9:8" rst="0x3">
          <comment>control ap_axidma_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="usb_wr_sec" pos="7:6" rst="0x3">
          <comment>control usb_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="med_wr_sec" pos="5:4" rst="0x3">
          <comment>control med_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ce_pub_wr_sec" pos="3:2" rst="0x3">
          <comment>control ce_pub_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ce_sec_wr_sec" pos="1:0" rst="0x3">
          <comment>control ce_sec_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="id0_first_addr_0" protect="rw">
        <comment>id0 first_addr control id0 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id0_last_addr_0" protect="rw">
        <comment>id0 last_addr control id0 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id0_mstid_0" protect="rw">
        <comment>id0 mstid_0 master id control id0 mstid_0 master id control</comment>
      </reg>
      <reg name="id0_mstid_1" protect="rw">
        <comment>id0 mstid_1 master id control id0 mstid_1 master id control</comment>
      </reg>
      <reg name="id0_mstid_2" protect="rw">
        <comment>id0 mstid_2 master id control id0 mstid_2 master id control</comment>
      </reg>
      <reg name="id0_mstid_3" protect="rw">
        <comment>id0 mstid_3 master id control id0 mstid_3 master id control</comment>
      </reg>
      <reg name="id0_mstid_4" protect="rw">
        <comment>id0 mstid_4 master id control id0 mstid_4 master id control</comment>
      </reg>
      <reg name="id0_mstid_5" protect="rw">
        <comment>id0 mstid_5 master id control id0 mstid_5 master id control</comment>
      </reg>
      <reg name="id0_mstid_6" protect="rw">
        <comment>id0 mstid_6 master id control id0 mstid_6 master id control</comment>
      </reg>
      <reg name="id0_mstid_7" protect="rw">
        <comment>id0 mstid_7 master id control id0 mstid_7 master id control</comment>
      </reg>
      <reg name="id1_first_addr_0" protect="rw">
        <comment>id1 first_addr control id1 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id1_last_addr_0" protect="rw">
        <comment>id1 last_addr control id1 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id1_mstid_0" protect="rw">
        <comment>id1 mstid_0 master id control id1 mstid_0 master id control</comment>
      </reg>
      <reg name="id1_mstid_1" protect="rw">
        <comment>id1 mstid_1 master id control id1 mstid_1 master id control</comment>
      </reg>
      <reg name="id1_mstid_2" protect="rw">
        <comment>id1 mstid_2 master id control id1 mstid_2 master id control</comment>
      </reg>
      <reg name="id1_mstid_3" protect="rw">
        <comment>id1 mstid_3 master id control id1 mstid_3 master id control</comment>
      </reg>
      <reg name="id1_mstid_4" protect="rw">
        <comment>id1 mstid_4 master id control id1 mstid_4 master id control</comment>
      </reg>
      <reg name="id1_mstid_5" protect="rw">
        <comment>id1 mstid_5 master id control id1 mstid_5 master id control</comment>
      </reg>
      <reg name="id1_mstid_6" protect="rw">
        <comment>id1 mstid_6 master id control id1 mstid_6 master id control</comment>
      </reg>
      <reg name="id1_mstid_7" protect="rw">
        <comment>id1 mstid_7 master id control id1 mstid_7 master id control</comment>
      </reg>
      <reg name="id2_first_addr_0" protect="rw">
        <comment>id2 first_addr control id2 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id2_last_addr_0" protect="rw">
        <comment>id2 last_addr control id2 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id2_mstid_0" protect="rw">
        <comment>id2 mstid_0 master id control id2 mstid_0 master id control</comment>
      </reg>
      <reg name="id2_mstid_1" protect="rw">
        <comment>id2 mstid_1 master id control id2 mstid_1 master id control</comment>
      </reg>
      <reg name="id2_mstid_2" protect="rw">
        <comment>id2 mstid_2 master id control id2 mstid_2 master id control</comment>
      </reg>
      <reg name="id2_mstid_3" protect="rw">
        <comment>id2 mstid_3 master id control id2 mstid_3 master id control</comment>
      </reg>
      <reg name="id2_mstid_4" protect="rw">
        <comment>id2 mstid_4 master id control id2 mstid_4 master id control</comment>
      </reg>
      <reg name="id2_mstid_5" protect="rw">
        <comment>id2 mstid_5 master id control id2 mstid_5 master id control</comment>
      </reg>
      <reg name="id2_mstid_6" protect="rw">
        <comment>id2 mstid_6 master id control id2 mstid_6 master id control</comment>
      </reg>
      <reg name="id2_mstid_7" protect="rw">
        <comment>id2 mstid_7 master id control id2 mstid_7 master id control</comment>
      </reg>
      <reg name="id3_first_addr_0" protect="rw">
        <comment>id3 first_addr control id3 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id3_last_addr_0" protect="rw">
        <comment>id3 last_addr control id3 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id3_mstid_0" protect="rw">
        <comment>id3 mstid_0 master id control id3 mstid_0 master id control</comment>
      </reg>
      <reg name="id3_mstid_1" protect="rw">
        <comment>id3 mstid_1 master id control id3 mstid_1 master id control</comment>
      </reg>
      <reg name="id3_mstid_2" protect="rw">
        <comment>id3 mstid_2 master id control id3 mstid_2 master id control</comment>
      </reg>
      <reg name="id3_mstid_3" protect="rw">
        <comment>id3 mstid_3 master id control id3 mstid_3 master id control</comment>
      </reg>
      <reg name="id3_mstid_4" protect="rw">
        <comment>id3 mstid_4 master id control id3 mstid_4 master id control</comment>
      </reg>
      <reg name="id3_mstid_5" protect="rw">
        <comment>id3 mstid_5 master id control id3 mstid_5 master id control</comment>
      </reg>
      <reg name="id3_mstid_6" protect="rw">
        <comment>id3 mstid_6 master id control id3 mstid_6 master id control</comment>
      </reg>
      <reg name="id3_mstid_7" protect="rw">
        <comment>id3 mstid_7 master id control id3 mstid_7 master id control</comment>
      </reg>
      <reg name="id4_first_addr_0" protect="rw">
        <comment>id4 first_addr control id4 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id4_last_addr_0" protect="rw">
        <comment>id4 last_addr control id4 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id4_mstid_0" protect="rw">
        <comment>id4 mstid_0 master id control id4 mstid_0 master id control</comment>
      </reg>
      <reg name="id4_mstid_1" protect="rw">
        <comment>id4 mstid_1 master id control id4 mstid_1 master id control</comment>
      </reg>
      <reg name="id4_mstid_2" protect="rw">
        <comment>id4 mstid_2 master id control id4 mstid_2 master id control</comment>
      </reg>
      <reg name="id4_mstid_3" protect="rw">
        <comment>id4 mstid_3 master id control id4 mstid_3 master id control</comment>
      </reg>
      <reg name="id4_mstid_4" protect="rw">
        <comment>id4 mstid_4 master id control id4 mstid_4 master id control</comment>
      </reg>
      <reg name="id4_mstid_5" protect="rw">
        <comment>id4 mstid_5 master id control id4 mstid_5 master id control</comment>
      </reg>
      <reg name="id4_mstid_6" protect="rw">
        <comment>id4 mstid_6 master id control id4 mstid_6 master id control</comment>
      </reg>
      <reg name="id4_mstid_7" protect="rw">
        <comment>id4 mstid_7 master id control id4 mstid_7 master id control</comment>
      </reg>
      <reg name="id5_first_addr_0" protect="rw">
        <comment>id5 first_addr control id5 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id5_last_addr_0" protect="rw">
        <comment>id5 last_addr control id5 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id5_mstid_0" protect="rw">
        <comment>id5 mstid_0 master id control id5 mstid_0 master id control</comment>
      </reg>
      <reg name="id5_mstid_1" protect="rw">
        <comment>id5 mstid_1 master id control id5 mstid_1 master id control</comment>
      </reg>
      <reg name="id5_mstid_2" protect="rw">
        <comment>id5 mstid_2 master id control id5 mstid_2 master id control</comment>
      </reg>
      <reg name="id5_mstid_3" protect="rw">
        <comment>id5 mstid_3 master id control id5 mstid_3 master id control</comment>
      </reg>
      <reg name="id5_mstid_4" protect="rw">
        <comment>id5 mstid_4 master id control id5 mstid_4 master id control</comment>
      </reg>
      <reg name="id5_mstid_5" protect="rw">
        <comment>id5 mstid_5 master id control id5 mstid_5 master id control</comment>
      </reg>
      <reg name="id5_mstid_6" protect="rw">
        <comment>id5 mstid_6 master id control id5 mstid_6 master id control</comment>
      </reg>
      <reg name="id5_mstid_7" protect="rw">
        <comment>id5 mstid_7 master id control id5 mstid_7 master id control</comment>
      </reg>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clk_gate_bypass clk_gate_bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clk_gate_bypass</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51322000" name="SLV_FW_AP_AHB" type="SLV_FW_AP_AHB"/>
  </archive>
  <archive relative="slv_fw_aon_ifc.xml">
    <module category="System" name="SLV_FW_AON_IFC">
      <reg name="port0_default_address_0" protect="rw">
        <comment>port0 default address, bit 0 ~ 15. port0 default address, bit 0 ~ 15.</comment>
        <bits access="rw" name="port0_default_address_0" pos="15:0" rst="0xdf00"/>
      </reg>
      <reg name="port_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int write-clear</comment>
        </bits>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_raw" protect="rw">
        <comment>Original interrupt reg %d Original interrupt reg %d</comment>
        <bits access="r" name="port_0_r_raw" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_fin" protect="rw">
        <comment>Final interrupt reg %d Final interrupt reg %d</comment>
        <bits access="r" name="port_0_r_fin" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="uart2_rd_sec" pos="11:10" rst="0x3">
          <comment>control uart2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart3_rd_sec" pos="9:8" rst="0x3">
          <comment>control uart3_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dbg_uart_rd_sec" pos="7:6" rst="0x3">
          <comment>control dbg_uart_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aif_rd_sec" pos="5:4" rst="0x3">
          <comment>control aif_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_ifc_rd_sec" pos="3:2" rst="0x3">
          <comment>control aon_ifc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dbg_host_rd_sec" pos="1:0" rst="0x3">
          <comment>control dbg_host_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="uart2_wr_sec" pos="11:10" rst="0x3">
          <comment>control uart2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="uart3_wr_sec" pos="9:8" rst="0x3">
          <comment>control uart3_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dbg_uart_wr_sec" pos="7:6" rst="0x3">
          <comment>control dbg_uart_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aif_wr_sec" pos="5:4" rst="0x3">
          <comment>control aif_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_ifc_wr_sec" pos="3:2" rst="0x3">
          <comment>control aon_ifc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dbg_host_wr_sec" pos="1:0" rst="0x3">
          <comment>control dbg_host_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="id0_first_addr_0" protect="rw">
        <comment>id0 first_addr control id0 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id0_last_addr_0" protect="rw">
        <comment>id0 last_addr control id0 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id0_mstid_0" protect="rw">
        <comment>id0 mstid_0 master id control id0 mstid_0 master id control</comment>
      </reg>
      <reg name="id0_mstid_1" protect="rw">
        <comment>id0 mstid_1 master id control id0 mstid_1 master id control</comment>
      </reg>
      <reg name="id0_mstid_2" protect="rw">
        <comment>id0 mstid_2 master id control id0 mstid_2 master id control</comment>
      </reg>
      <reg name="id0_mstid_3" protect="rw">
        <comment>id0 mstid_3 master id control id0 mstid_3 master id control</comment>
      </reg>
      <reg name="id0_mstid_4" protect="rw">
        <comment>id0 mstid_4 master id control id0 mstid_4 master id control</comment>
      </reg>
      <reg name="id0_mstid_5" protect="rw">
        <comment>id0 mstid_5 master id control id0 mstid_5 master id control</comment>
      </reg>
      <reg name="id0_mstid_6" protect="rw">
        <comment>id0 mstid_6 master id control id0 mstid_6 master id control</comment>
      </reg>
      <reg name="id0_mstid_7" protect="rw">
        <comment>id0 mstid_7 master id control id0 mstid_7 master id control</comment>
      </reg>
      <reg name="id1_first_addr_0" protect="rw">
        <comment>id1 first_addr control id1 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="15:0" rst="0xffff"/>
      </reg>
      <reg name="id1_last_addr_0" protect="rw">
        <comment>id1 last_addr control id1 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="id1_mstid_0" protect="rw">
        <comment>id1 mstid_0 master id control id1 mstid_0 master id control</comment>
      </reg>
      <reg name="id1_mstid_1" protect="rw">
        <comment>id1 mstid_1 master id control id1 mstid_1 master id control</comment>
      </reg>
      <reg name="id1_mstid_2" protect="rw">
        <comment>id1 mstid_2 master id control id1 mstid_2 master id control</comment>
      </reg>
      <reg name="id1_mstid_3" protect="rw">
        <comment>id1 mstid_3 master id control id1 mstid_3 master id control</comment>
      </reg>
      <reg name="id1_mstid_4" protect="rw">
        <comment>id1 mstid_4 master id control id1 mstid_4 master id control</comment>
      </reg>
      <reg name="id1_mstid_5" protect="rw">
        <comment>id1 mstid_5 master id control id1 mstid_5 master id control</comment>
      </reg>
      <reg name="id1_mstid_6" protect="rw">
        <comment>id1 mstid_6 master id control id1 mstid_6 master id control</comment>
      </reg>
      <reg name="id1_mstid_7" protect="rw">
        <comment>id1 mstid_7 master id control id1 mstid_7 master id control</comment>
      </reg>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clk_gate_bypass clk_gate_bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clk_gate_bypass</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51301000" name="SLV_FW_AON_IFC" type="SLV_FW_AON_IFC"/>
  </archive>
  <archive relative="slv_fw_aon_ahb.xml">
    <module category="System" name="SLV_FW_AON_AHB">
      <reg name="port0_default_address_0" protect="rw">
        <comment>port0 default address, bit 0 ~ 26. port0 default address, bit 0 ~ 26.</comment>
        <bits access="rw" name="port0_default_address_0" pos="26:0" rst="0x7fff00"/>
      </reg>
      <reg name="port_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss int write-clear</comment>
        </bits>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_raw" protect="rw">
        <comment>Original interrupt reg %d Original interrupt reg %d</comment>
        <bits access="r" name="port_0_r_raw" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_fin" protect="rw">
        <comment>Final interrupt reg %d Final interrupt reg %d</comment>
        <bits access="r" name="port_0_r_fin" pos="1" rst="0x0">
          <comment>Port 0 read channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="idle_timer_rd_sec" pos="31:30" rst="0x3">
          <comment>control idle_timer_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_clk_pre_rd_sec" pos="29:28" rst="0x3">
          <comment>control aon_clk_pre_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_clk_core_rd_sec" pos="27:26" rst="0x3">
          <comment>control aon_clk_core_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aud_2ad_rd_sec" pos="25:24" rst="0x3">
          <comment>control aud_2ad_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt2_rd_sec" pos="23:22" rst="0x3">
          <comment>control gpt2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spi2_rd_sec" pos="21:20" rst="0x3">
          <comment>control spi2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt1_rd_sec" pos="19:18" rst="0x3">
          <comment>control gpt1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="djtag_cfg_rd_sec" pos="17:16" rst="0x3">
          <comment>control djtag_cfg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap2_rd_sec" pos="15:14" rst="0x3">
          <comment>control ana_wrap2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="iomux_rd_sec" pos="13:12" rst="0x3">
          <comment>control iomux_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dmc400_rd_sec" pos="11:10" rst="0x3">
          <comment>control dmc400_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="psram_phy_rd_sec" pos="9:8" rst="0x3">
          <comment>control psram_phy_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pagespy_rd_sec" pos="7:6" rst="0x3">
          <comment>control pagespy_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pub_apb_reg_rd_sec" pos="5:4" rst="0x3">
          <comment>control pub_apb_reg_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dap_rd_sec" pos="3:2" rst="0x3">
          <comment>control dap_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pub_nic_gpv_rd_sec" pos="1:0" rst="0x3">
          <comment>control pub_nic_gpv_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="rd_sec_1" protect="rw">
        <comment>rd 1 sec control rd 1 sec control</comment>
        <bits access="rw" name="spinlock_rd_sec" pos="25:24" rst="0x3">
          <comment>control spinlock_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_rd_sec" pos="23:22" rst="0x3">
          <comment>control adi_mst_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_sp0_rd_sec" pos="21:20" rst="0x3">
          <comment>control adi_mst_sp0_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_sp1_rd_sec" pos="19:18" rst="0x3">
          <comment>control adi_mst_sp1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="efuse_rd_sec" pos="17:16" rst="0x3">
          <comment>control efuse_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="tzpc_rd_sec" pos="15:14" rst="0x3">
          <comment>control tzpc_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sys_ctrl_rd_sec" pos="13:12" rst="0x3">
          <comment>control sys_ctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap1_rd_sec" pos="11:10" rst="0x3">
          <comment>control ana_wrap1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="mon_ctrl_rd_sec" pos="9:8" rst="0x3">
          <comment>control mon_ctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpio2_rd_sec" pos="7:6" rst="0x3">
          <comment>control gpio2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c3_rd_sec" pos="5:4" rst="0x3">
          <comment>control i2c3_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="scc_top_rd_sec" pos="3:2" rst="0x3">
          <comment>control scc_top_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sysmail_rd_sec" pos="1:0" rst="0x3">
          <comment>control sysmail_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="idle_timer_wr_sec" pos="31:30" rst="0x3">
          <comment>control idle_timer_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_clk_pre_wr_sec" pos="29:28" rst="0x3">
          <comment>control aon_clk_pre_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aon_clk_core_wr_sec" pos="27:26" rst="0x3">
          <comment>control aon_clk_core_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="aud_2ad_wr_sec" pos="25:24" rst="0x3">
          <comment>control aud_2ad_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt2_wr_sec" pos="23:22" rst="0x3">
          <comment>control gpt2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="spi2_wr_sec" pos="21:20" rst="0x3">
          <comment>control spi2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpt1_wr_sec" pos="19:18" rst="0x3">
          <comment>control gpt1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="djtag_cfg_wr_sec" pos="17:16" rst="0x3">
          <comment>control djtag_cfg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap2_wr_sec" pos="15:14" rst="0x3">
          <comment>control ana_wrap2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="iomux_wr_sec" pos="13:12" rst="0x3">
          <comment>control iomux_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dmc400_wr_sec" pos="11:10" rst="0x3">
          <comment>control dmc400_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="psram_phy_wr_sec" pos="9:8" rst="0x3">
          <comment>control psram_phy_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pagespy_wr_sec" pos="7:6" rst="0x3">
          <comment>control pagespy_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pub_apb_reg_wr_sec" pos="5:4" rst="0x3">
          <comment>control pub_apb_reg_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="dap_wr_sec" pos="3:2" rst="0x3">
          <comment>control dap_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="pub_nic_gpv_wr_sec" pos="1:0" rst="0x3">
          <comment>control pub_nic_gpv_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="wr_sec_1" protect="rw">
        <comment>wr 1 sec control wr 1 sec control</comment>
        <bits access="rw" name="spinlock_wr_sec" pos="25:24" rst="0x3">
          <comment>control spinlock_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_wr_sec" pos="23:22" rst="0x3">
          <comment>control adi_mst_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_sp0_wr_sec" pos="21:20" rst="0x3">
          <comment>control adi_mst_sp0_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="adi_mst_sp1_wr_sec" pos="19:18" rst="0x3">
          <comment>control adi_mst_sp1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="efuse_wr_sec" pos="17:16" rst="0x3">
          <comment>control efuse_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="tzpc_wr_sec" pos="15:14" rst="0x3">
          <comment>control tzpc_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sys_ctrl_wr_sec" pos="13:12" rst="0x3">
          <comment>control sys_ctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="ana_wrap1_wr_sec" pos="11:10" rst="0x3">
          <comment>control ana_wrap1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="mon_ctrl_wr_sec" pos="9:8" rst="0x3">
          <comment>control mon_ctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="gpio2_wr_sec" pos="7:6" rst="0x3">
          <comment>control gpio2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="i2c3_wr_sec" pos="5:4" rst="0x3">
          <comment>control i2c3_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="scc_top_wr_sec" pos="3:2" rst="0x3">
          <comment>control scc_top_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
        <bits access="rw" name="sysmail_wr_sec" pos="1:0" rst="0x3">
          <comment>control sysmail_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access</comment>
        </bits>
      </reg>
      <reg name="id0_first_addr_0" protect="rw">
        <comment>id0 first_addr control id0 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id0_last_addr_0" protect="rw">
        <comment>id0 last_addr control id0 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id0_mstid_0" protect="rw">
        <comment>id0 mstid_0 master id control id0 mstid_0 master id control</comment>
      </reg>
      <reg name="id0_mstid_1" protect="rw">
        <comment>id0 mstid_1 master id control id0 mstid_1 master id control</comment>
      </reg>
      <reg name="id0_mstid_2" protect="rw">
        <comment>id0 mstid_2 master id control id0 mstid_2 master id control</comment>
      </reg>
      <reg name="id0_mstid_3" protect="rw">
        <comment>id0 mstid_3 master id control id0 mstid_3 master id control</comment>
      </reg>
      <reg name="id0_mstid_4" protect="rw">
        <comment>id0 mstid_4 master id control id0 mstid_4 master id control</comment>
      </reg>
      <reg name="id0_mstid_5" protect="rw">
        <comment>id0 mstid_5 master id control id0 mstid_5 master id control</comment>
      </reg>
      <reg name="id0_mstid_6" protect="rw">
        <comment>id0 mstid_6 master id control id0 mstid_6 master id control</comment>
      </reg>
      <reg name="id0_mstid_7" protect="rw">
        <comment>id0 mstid_7 master id control id0 mstid_7 master id control</comment>
      </reg>
      <reg name="id1_first_addr_0" protect="rw">
        <comment>id1 first_addr control id1 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id1_last_addr_0" protect="rw">
        <comment>id1 last_addr control id1 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id1_mstid_0" protect="rw">
        <comment>id1 mstid_0 master id control id1 mstid_0 master id control</comment>
      </reg>
      <reg name="id1_mstid_1" protect="rw">
        <comment>id1 mstid_1 master id control id1 mstid_1 master id control</comment>
      </reg>
      <reg name="id1_mstid_2" protect="rw">
        <comment>id1 mstid_2 master id control id1 mstid_2 master id control</comment>
      </reg>
      <reg name="id1_mstid_3" protect="rw">
        <comment>id1 mstid_3 master id control id1 mstid_3 master id control</comment>
      </reg>
      <reg name="id1_mstid_4" protect="rw">
        <comment>id1 mstid_4 master id control id1 mstid_4 master id control</comment>
      </reg>
      <reg name="id1_mstid_5" protect="rw">
        <comment>id1 mstid_5 master id control id1 mstid_5 master id control</comment>
      </reg>
      <reg name="id1_mstid_6" protect="rw">
        <comment>id1 mstid_6 master id control id1 mstid_6 master id control</comment>
      </reg>
      <reg name="id1_mstid_7" protect="rw">
        <comment>id1 mstid_7 master id control id1 mstid_7 master id control</comment>
      </reg>
      <reg name="id2_first_addr_0" protect="rw">
        <comment>id2 first_addr control id2 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id2_last_addr_0" protect="rw">
        <comment>id2 last_addr control id2 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id2_mstid_0" protect="rw">
        <comment>id2 mstid_0 master id control id2 mstid_0 master id control</comment>
      </reg>
      <reg name="id2_mstid_1" protect="rw">
        <comment>id2 mstid_1 master id control id2 mstid_1 master id control</comment>
      </reg>
      <reg name="id2_mstid_2" protect="rw">
        <comment>id2 mstid_2 master id control id2 mstid_2 master id control</comment>
      </reg>
      <reg name="id2_mstid_3" protect="rw">
        <comment>id2 mstid_3 master id control id2 mstid_3 master id control</comment>
      </reg>
      <reg name="id2_mstid_4" protect="rw">
        <comment>id2 mstid_4 master id control id2 mstid_4 master id control</comment>
      </reg>
      <reg name="id2_mstid_5" protect="rw">
        <comment>id2 mstid_5 master id control id2 mstid_5 master id control</comment>
      </reg>
      <reg name="id2_mstid_6" protect="rw">
        <comment>id2 mstid_6 master id control id2 mstid_6 master id control</comment>
      </reg>
      <reg name="id2_mstid_7" protect="rw">
        <comment>id2 mstid_7 master id control id2 mstid_7 master id control</comment>
      </reg>
      <reg name="id3_first_addr_0" protect="rw">
        <comment>id3 first_addr control id3 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id3_last_addr_0" protect="rw">
        <comment>id3 last_addr control id3 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id3_mstid_0" protect="rw">
        <comment>id3 mstid_0 master id control id3 mstid_0 master id control</comment>
      </reg>
      <reg name="id3_mstid_1" protect="rw">
        <comment>id3 mstid_1 master id control id3 mstid_1 master id control</comment>
      </reg>
      <reg name="id3_mstid_2" protect="rw">
        <comment>id3 mstid_2 master id control id3 mstid_2 master id control</comment>
      </reg>
      <reg name="id3_mstid_3" protect="rw">
        <comment>id3 mstid_3 master id control id3 mstid_3 master id control</comment>
      </reg>
      <reg name="id3_mstid_4" protect="rw">
        <comment>id3 mstid_4 master id control id3 mstid_4 master id control</comment>
      </reg>
      <reg name="id3_mstid_5" protect="rw">
        <comment>id3 mstid_5 master id control id3 mstid_5 master id control</comment>
      </reg>
      <reg name="id3_mstid_6" protect="rw">
        <comment>id3 mstid_6 master id control id3 mstid_6 master id control</comment>
      </reg>
      <reg name="id3_mstid_7" protect="rw">
        <comment>id3 mstid_7 master id control id3 mstid_7 master id control</comment>
      </reg>
      <reg name="id4_first_addr_0" protect="rw">
        <comment>id4 first_addr control id4 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id4_last_addr_0" protect="rw">
        <comment>id4 last_addr control id4 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id4_mstid_0" protect="rw">
        <comment>id4 mstid_0 master id control id4 mstid_0 master id control</comment>
      </reg>
      <reg name="id4_mstid_1" protect="rw">
        <comment>id4 mstid_1 master id control id4 mstid_1 master id control</comment>
      </reg>
      <reg name="id4_mstid_2" protect="rw">
        <comment>id4 mstid_2 master id control id4 mstid_2 master id control</comment>
      </reg>
      <reg name="id4_mstid_3" protect="rw">
        <comment>id4 mstid_3 master id control id4 mstid_3 master id control</comment>
      </reg>
      <reg name="id4_mstid_4" protect="rw">
        <comment>id4 mstid_4 master id control id4 mstid_4 master id control</comment>
      </reg>
      <reg name="id4_mstid_5" protect="rw">
        <comment>id4 mstid_5 master id control id4 mstid_5 master id control</comment>
      </reg>
      <reg name="id4_mstid_6" protect="rw">
        <comment>id4 mstid_6 master id control id4 mstid_6 master id control</comment>
      </reg>
      <reg name="id4_mstid_7" protect="rw">
        <comment>id4 mstid_7 master id control id4 mstid_7 master id control</comment>
      </reg>
      <reg name="id5_first_addr_0" protect="rw">
        <comment>id5 first_addr control id5 first_addr control</comment>
        <bits access="rw" name="first_addr_0" pos="26:0" rst="0x7ffffff"/>
      </reg>
      <reg name="id5_last_addr_0" protect="rw">
        <comment>id5 last_addr control id5 last_addr control</comment>
        <bits access="rw" name="last_addr_0" pos="26:0" rst="0x0"/>
      </reg>
      <reg name="id5_mstid_0" protect="rw">
        <comment>id5 mstid_0 master id control id5 mstid_0 master id control</comment>
      </reg>
      <reg name="id5_mstid_1" protect="rw">
        <comment>id5 mstid_1 master id control id5 mstid_1 master id control</comment>
      </reg>
      <reg name="id5_mstid_2" protect="rw">
        <comment>id5 mstid_2 master id control id5 mstid_2 master id control</comment>
      </reg>
      <reg name="id5_mstid_3" protect="rw">
        <comment>id5 mstid_3 master id control id5 mstid_3 master id control</comment>
      </reg>
      <reg name="id5_mstid_4" protect="rw">
        <comment>id5 mstid_4 master id control id5 mstid_4 master id control</comment>
      </reg>
      <reg name="id5_mstid_5" protect="rw">
        <comment>id5 mstid_5 master id control id5 mstid_5 master id control</comment>
      </reg>
      <reg name="id5_mstid_6" protect="rw">
        <comment>id5 mstid_6 master id control id5 mstid_6 master id control</comment>
      </reg>
      <reg name="id5_mstid_7" protect="rw">
        <comment>id5 mstid_7 master id control id5 mstid_7 master id control</comment>
      </reg>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clk_gate_bypass clk_gate_bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clk_gate_bypass</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51302000" name="SLV_FW_AON_AHB" type="SLV_FW_AON_AHB"/>
  </archive>
  <archive relative="mst_flt_aon_rf.xml">
    <module category="System" name="MST_FLT_AON_RF">
      <reg name="mst_filter_id0" protect="rw">
        <comment>mst_filter_id0 mst_filter_id0</comment>
      </reg>
      <reg name="mst_filter_id1" protect="rw">
        <comment>mst_filter_id1 mst_filter_id1</comment>
      </reg>
      <reg name="mst_filter_id2" protect="rw">
        <comment>mst_filter_id2 mst_filter_id2</comment>
      </reg>
      <reg name="mst_filter_id3" protect="rw">
        <comment>mst_filter_id3 mst_filter_id3</comment>
      </reg>
      <reg name="mst_filter_id4" protect="rw">
        <comment>mst_filter_id4 mst_filter_id4</comment>
      </reg>
      <reg name="mst_filter_id5" protect="rw">
        <comment>mst_filter_id5 mst_filter_id5</comment>
      </reg>
      <reg name="mst_filter_id6" protect="rw">
        <comment>mst_filter_id6 mst_filter_id6</comment>
      </reg>
      <reg name="mst_filter_id7" protect="rw">
        <comment>mst_filter_id7 mst_filter_id7</comment>
      </reg>
      <reg name="mst_filter_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="mst_filter_int_en" pos="0" rst="0x0">
          <comment>read/write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_raw0" protect="rw">
        <comment>Original interrupt reg  Original interrupt reg</comment>
        <bits access="r" name="mst_filter_int_raw0" pos="0" rst="0x0">
          <comment>read/write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_status0" protect="rw">
        <comment>Interrupt status reg  Interrupt status reg</comment>
        <bits access="r" name="mst_filter_int_status0" pos="0" rst="0x0">
          <comment>read/write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="mst_filter_int_clr" pos="0" rst="0x0">
          <comment>read/write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="mst_filter_debug_reg0" protect="rw">
        <comment>debug register debug register</comment>
      </reg>
      <reg name="mst_filter_debug_reg2" protect="rw">
        <comment>debug register debug register</comment>
        <bits access="r" name="mst_filter_debug_hwrite" pos="8" rst="0x0"/>
        <bits access="r" name="mst_filter_debug_hauser" pos="7:0" rst="0x0">
          <comment>when miss, latch hauser</comment>
        </bits>
      </reg>
      <reg name="mst_filter_resp" protect="rw">
        <comment>response error reg responce error reg</comment>
        <bits access="rw" name="mst_filter_resp_en" pos="0" rst="0x0">
          <comment>read/write channel address miss int write-clear</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51304000" name="MST_FLT_AON_RF" type="MST_FLT_AON_RF"/>
  </archive>
  <archive relative="mst_flt_aon_cp.xml">
    <module category="System" name="MST_FLT_AON_CP">
      <reg name="mst_filter_id0" protect="rw">
        <comment>mst_filter_id0 mst_filter_id0</comment>
      </reg>
      <reg name="mst_filter_id1" protect="rw">
        <comment>mst_filter_id1 mst_filter_id1</comment>
      </reg>
      <reg name="mst_filter_id2" protect="rw">
        <comment>mst_filter_id2 mst_filter_id2</comment>
      </reg>
      <reg name="mst_filter_id3" protect="rw">
        <comment>mst_filter_id3 mst_filter_id3</comment>
      </reg>
      <reg name="mst_filter_id4" protect="rw">
        <comment>mst_filter_id4 mst_filter_id4</comment>
      </reg>
      <reg name="mst_filter_id5" protect="rw">
        <comment>mst_filter_id5 mst_filter_id5</comment>
      </reg>
      <reg name="mst_filter_id6" protect="rw">
        <comment>mst_filter_id6 mst_filter_id6</comment>
      </reg>
      <reg name="mst_filter_id7" protect="rw">
        <comment>mst_filter_id7 mst_filter_id7</comment>
      </reg>
      <reg name="mst_filter_int_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="mst_filter_int_en" pos="0" rst="0x0">
          <comment>read/write channel address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_raw0" protect="rw">
        <comment>Original interrupt reg  Original interrupt reg</comment>
        <bits access="r" name="mst_filter_int_raw0" pos="0" rst="0x0">
          <comment>read/write channel address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_status0" protect="rw">
        <comment>Interrupt status reg  Interrupt status reg</comment>
        <bits access="r" name="mst_filter_int_status0" pos="0" rst="0x0">
          <comment>read/write channel address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="mst_filter_int_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="mst_filter_int_clr" pos="0" rst="0x0">
          <comment>read/write channel address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="mst_filter_debug_reg0" protect="rw">
        <comment>debug register debug register</comment>
      </reg>
      <reg name="mst_filter_debug_reg2" protect="rw">
        <comment>debug register debug register</comment>
        <bits access="r" name="mst_filter_debug_hwrite" pos="8" rst="0x0"/>
        <bits access="r" name="mst_filter_debug_hauser" pos="7:0" rst="0x0">
          <comment>when miss, latch hauser</comment>
        </bits>
      </reg>
      <reg name="mst_filter_resp" protect="rw">
        <comment>response error reg responce error reg</comment>
        <bits access="rw" name="mst_filter_resp_en" pos="0" rst="0x0">
          <comment>read/write channel address miss int write-clear</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51303000" name="MST_FLT_AON_CP" type="MST_FLT_AON_CP"/>
  </archive>
  <archive relative="mem_fw_spiflash2.xml">
    <module category="System" name="MEM_FW_SPIFLASH2">
      <reg name="port0_default_r_addr_0" protect="rw">
        <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10). default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_r_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <reg name="port0_default_w_addr_0" protect="rw">
        <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10). default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_w_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <hole size="1984"/>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clock gate bypass clock gate bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clock gate bypass</comment>
        </bits>
      </reg>
      <hole size="2016"/>
      <reg name="port_int_w_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_w_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_w_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_w_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="0" rst="0x0">
          <comment>Port 0 read address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_r_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="0" rst="0x0">
          <comment>Port 0 read address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_r_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_r_raw" pos="0" rst="0x0">
          <comment>Port 0 read address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_r_fin" pos="0" rst="0x0">
          <comment>Port 0 read address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <hole size="3840"/>
      <reg name="port_0_w_debug_addr" protect="rw">
        <comment>Debug address register for port 0 write channel Debug address register for port 0 write channel</comment>
        <bits access="r" name="w_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 write channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_w_debug_id" protect="rw">
        <comment>Debug id register for port 0 write channel Debug id register for port 0 write channel</comment>
        <bits access="r" name="w_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 write channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_addr" protect="rw">
        <comment>Debug address register for port 0 read channel Debug address register for port 0 read channel</comment>
        <bits access="r" name="r_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 read channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_id" protect="rw">
        <comment>Debug id register for port 0 read channel Debug id register for port 0 read channel</comment>
        <bits access="r" name="r_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 read channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <hole size="8064"/>
      <reg name="seg_default_first_addr" protect="rw">
        <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte) Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_last_addr" protect="rw">
        <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte) Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_mst_r_id0" protect="rw">
        <comment>Default Segment Read Master ID select 0~31 Default Segment Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_r_id1" protect="rw">
        <comment>Default Segment Read Master ID select 32~63 Default Segment Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_r_id2" protect="rw">
        <comment>Default Segment Read Master ID select 64~95 Default Segment Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_r_id3" protect="rw">
        <comment>Default Segment Read Master ID select 96~127 Default Segment Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_r_id4" protect="rw">
        <comment>Default Segment Read Master ID select 128~159 Default Segment Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_r_id5" protect="rw">
        <comment>Default Segment Read Master ID select 160~191 Default Segment Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_r_id6" protect="rw">
        <comment>Default Segment Read Master ID select 192~223 Default Segment Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_r_id7" protect="rw">
        <comment>Default Segment Read Master ID select 224~255 Default Segment Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_default_mst_w_id0" protect="rw">
        <comment>Default Segment write Master ID select 0~31 Default Segment write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_w_id1" protect="rw">
        <comment>Default Segment write Master ID select 32~63 Default Segment write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_w_id2" protect="rw">
        <comment>Default Segment write Master ID select 64~95 Default Segment write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_w_id3" protect="rw">
        <comment>Default Segment write Master ID select 96~127 Default Segment write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_w_id4" protect="rw">
        <comment>Default Segment write Master ID select 128~159 Default Segment write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_w_id5" protect="rw">
        <comment>Default Segment write Master ID select 160~191 Default Segment write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_w_id6" protect="rw">
        <comment>Default Segment write Master ID select 192~223 Default Segment write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_w_id7" protect="rw">
        <comment>Default Segment write Master ID select 224~255 Default Segment write Master ID select 224~255</comment>
      </reg>
      <hole size="15808"/>
      <reg name="seg_0_first_addr" protect="rw">
        <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte) Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_last_addr" protect="rw">
        <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte) Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_mst_r_id0" protect="rw">
        <comment>Segment 0 Read Master ID select 0~31 Segment 0 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_r_id1" protect="rw">
        <comment>Segment 0 Read Master ID select 32~63 Segment 0 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_r_id2" protect="rw">
        <comment>Segment 0 Read Master ID select 64~95 Segment 0 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_r_id3" protect="rw">
        <comment>Segment 0 Read Master ID select 96~127 Segment 0 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_r_id4" protect="rw">
        <comment>Segment 0 Read Master ID select 128~159 Segment 0 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_r_id5" protect="rw">
        <comment>Segment 0 Read Master ID select 160~191 Segment 0 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_r_id6" protect="rw">
        <comment>Segment 0 Read Master ID select 192~223 Segment 0 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_r_id7" protect="rw">
        <comment>Segment 0 Read Master ID select 224~255 Segment 0 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_0_mst_w_id0" protect="rw">
        <comment>Segment 0 Write Master ID select 0~31 Segment 0 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_w_id1" protect="rw">
        <comment>Segment 0 Write Master ID select 32~63 Segment 0 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_w_id2" protect="rw">
        <comment>Segment 0 Write Master ID select 64~95 Segment 0 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_w_id3" protect="rw">
        <comment>Segment 0 Write Master ID select 96~127 Segment 0 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_w_id4" protect="rw">
        <comment>Segment 0 Write Master ID select 128~159 Segment 0 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_w_id5" protect="rw">
        <comment>Segment 0 Write Master ID select 160~191 Segment 0 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_w_id6" protect="rw">
        <comment>Segment 0 Write Master ID select 192~223 Segment 0 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_w_id7" protect="rw">
        <comment>Segment 0 Write Master ID select 224~255 Segment 0 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_1_first_addr" protect="rw">
        <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte) Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_last_addr" protect="rw">
        <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte) Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_mst_r_id0" protect="rw">
        <comment>Segment 1 Read Master ID select 0~31 Segment 1 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_r_id1" protect="rw">
        <comment>Segment 1 Read Master ID select 32~63 Segment 1 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_r_id2" protect="rw">
        <comment>Segment 1 Read Master ID select 64~95 Segment 1 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_r_id3" protect="rw">
        <comment>Segment 1 Read Master ID select 96~127 Segment 1 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_r_id4" protect="rw">
        <comment>Segment 1 Read Master ID select 128~159 Segment 1 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_r_id5" protect="rw">
        <comment>Segment 1 Read Master ID select 160~191 Segment 1 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_r_id6" protect="rw">
        <comment>Segment 1 Read Master ID select 192~223 Segment 1 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_r_id7" protect="rw">
        <comment>Segment 1 Read Master ID select 224~255 Segment 1 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_1_mst_w_id0" protect="rw">
        <comment>Segment 1 Write Master ID select 0~31 Segment 1 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_w_id1" protect="rw">
        <comment>Segment 1 Write Master ID select 32~63 Segment 1 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_w_id2" protect="rw">
        <comment>Segment 1 Write Master ID select 64~95 Segment 1 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_w_id3" protect="rw">
        <comment>Segment 1 Write Master ID select 96~127 Segment 1 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_w_id4" protect="rw">
        <comment>Segment 1 Write Master ID select 128~159 Segment 1 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_w_id5" protect="rw">
        <comment>Segment 1 Write Master ID select 160~191 Segment 1 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_w_id6" protect="rw">
        <comment>Segment 1 Write Master ID select 192~223 Segment 1 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_w_id7" protect="rw">
        <comment>Segment 1 Write Master ID select 224~255 Segment 1 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_2_first_addr" protect="rw">
        <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte) Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_last_addr" protect="rw">
        <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte) Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_mst_r_id0" protect="rw">
        <comment>Segment 2 Read Master ID select 0~31 Segment 2 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_r_id1" protect="rw">
        <comment>Segment 2 Read Master ID select 32~63 Segment 2 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_r_id2" protect="rw">
        <comment>Segment 2 Read Master ID select 64~95 Segment 2 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_r_id3" protect="rw">
        <comment>Segment 2 Read Master ID select 96~127 Segment 2 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_r_id4" protect="rw">
        <comment>Segment 2 Read Master ID select 128~159 Segment 2 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_r_id5" protect="rw">
        <comment>Segment 2 Read Master ID select 160~191 Segment 2 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_r_id6" protect="rw">
        <comment>Segment 2 Read Master ID select 192~223 Segment 2 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_r_id7" protect="rw">
        <comment>Segment 2 Read Master ID select 224~255 Segment 2 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_2_mst_w_id0" protect="rw">
        <comment>Segment 2 Write Master ID select 0~31 Segment 2 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_w_id1" protect="rw">
        <comment>Segment 2 Write Master ID select 32~63 Segment 2 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_w_id2" protect="rw">
        <comment>Segment 2 Write Master ID select 64~95 Segment 2 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_w_id3" protect="rw">
        <comment>Segment 2 Write Master ID select 96~127 Segment 2 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_w_id4" protect="rw">
        <comment>Segment 2 Write Master ID select 128~159 Segment 2 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_w_id5" protect="rw">
        <comment>Segment 2 Write Master ID select 160~191 Segment 2 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_w_id6" protect="rw">
        <comment>Segment 2 Write Master ID select 192~223 Segment 2 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_w_id7" protect="rw">
        <comment>Segment 2 Write Master ID select 224~255 Segment 2 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_3_first_addr" protect="rw">
        <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte) Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_last_addr" protect="rw">
        <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte) Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_mst_r_id0" protect="rw">
        <comment>Segment 3 Read Master ID select 0~31 Segment 3 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_r_id1" protect="rw">
        <comment>Segment 3 Read Master ID select 32~63 Segment 3 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_r_id2" protect="rw">
        <comment>Segment 3 Read Master ID select 64~95 Segment 3 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_r_id3" protect="rw">
        <comment>Segment 3 Read Master ID select 96~127 Segment 3 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_r_id4" protect="rw">
        <comment>Segment 3 Read Master ID select 128~159 Segment 3 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_r_id5" protect="rw">
        <comment>Segment 3 Read Master ID select 160~191 Segment 3 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_r_id6" protect="rw">
        <comment>Segment 3 Read Master ID select 192~223 Segment 3 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_r_id7" protect="rw">
        <comment>Segment 3 Read Master ID select 224~255 Segment 3 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_3_mst_w_id0" protect="rw">
        <comment>Segment 3 Write Master ID select 0~31 Segment 3 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_w_id1" protect="rw">
        <comment>Segment 3 Write Master ID select 32~63 Segment 3 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_w_id2" protect="rw">
        <comment>Segment 3 Write Master ID select 64~95 Segment 3 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_w_id3" protect="rw">
        <comment>Segment 3 Write Master ID select 96~127 Segment 3 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_w_id4" protect="rw">
        <comment>Segment 3 Write Master ID select 128~159 Segment 3 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_w_id5" protect="rw">
        <comment>Segment 3 Write Master ID select 160~191 Segment 3 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_w_id6" protect="rw">
        <comment>Segment 3 Write Master ID select 192~223 Segment 3 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_w_id7" protect="rw">
        <comment>Segment 3 Write Master ID select 224~255 Segment 3 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_4_first_addr" protect="rw">
        <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte) Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_last_addr" protect="rw">
        <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte) Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_mst_r_id0" protect="rw">
        <comment>Segment 4 Read Master ID select 0~31 Segment 4 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_r_id1" protect="rw">
        <comment>Segment 4 Read Master ID select 32~63 Segment 4 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_r_id2" protect="rw">
        <comment>Segment 4 Read Master ID select 64~95 Segment 4 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_r_id3" protect="rw">
        <comment>Segment 4 Read Master ID select 96~127 Segment 4 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_r_id4" protect="rw">
        <comment>Segment 4 Read Master ID select 128~159 Segment 4 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_r_id5" protect="rw">
        <comment>Segment 4 Read Master ID select 160~191 Segment 4 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_r_id6" protect="rw">
        <comment>Segment 4 Read Master ID select 192~223 Segment 4 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_r_id7" protect="rw">
        <comment>Segment 4 Read Master ID select 224~255 Segment 4 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_4_mst_w_id0" protect="rw">
        <comment>Segment 4 Write Master ID select 0~31 Segment 4 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_w_id1" protect="rw">
        <comment>Segment 4 Write Master ID select 32~63 Segment 4 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_w_id2" protect="rw">
        <comment>Segment 4 Write Master ID select 64~95 Segment 4 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_w_id3" protect="rw">
        <comment>Segment 4 Write Master ID select 96~127 Segment 4 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_w_id4" protect="rw">
        <comment>Segment 4 Write Master ID select 128~159 Segment 4 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_w_id5" protect="rw">
        <comment>Segment 4 Write Master ID select 160~191 Segment 4 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_w_id6" protect="rw">
        <comment>Segment 4 Write Master ID select 192~223 Segment 4 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_w_id7" protect="rw">
        <comment>Segment 4 Write Master ID select 224~255 Segment 4 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_5_first_addr" protect="rw">
        <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte) Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_last_addr" protect="rw">
        <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte) Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_mst_r_id0" protect="rw">
        <comment>Segment 5 Read Master ID select 0~31 Segment 5 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_r_id1" protect="rw">
        <comment>Segment 5 Read Master ID select 32~63 Segment 5 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_r_id2" protect="rw">
        <comment>Segment 5 Read Master ID select 64~95 Segment 5 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_r_id3" protect="rw">
        <comment>Segment 5 Read Master ID select 96~127 Segment 5 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_r_id4" protect="rw">
        <comment>Segment 5 Read Master ID select 128~159 Segment 5 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_r_id5" protect="rw">
        <comment>Segment 5 Read Master ID select 160~191 Segment 5 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_r_id6" protect="rw">
        <comment>Segment 5 Read Master ID select 192~223 Segment 5 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_r_id7" protect="rw">
        <comment>Segment 5 Read Master ID select 224~255 Segment 5 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_5_mst_w_id0" protect="rw">
        <comment>Segment 5 Write Master ID select 0~31 Segment 5 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_w_id1" protect="rw">
        <comment>Segment 5 Write Master ID select 32~63 Segment 5 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_w_id2" protect="rw">
        <comment>Segment 5 Write Master ID select 64~95 Segment 5 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_w_id3" protect="rw">
        <comment>Segment 5 Write Master ID select 96~127 Segment 5 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_w_id4" protect="rw">
        <comment>Segment 5 Write Master ID select 128~159 Segment 5 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_w_id5" protect="rw">
        <comment>Segment 5 Write Master ID select 160~191 Segment 5 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_w_id6" protect="rw">
        <comment>Segment 5 Write Master ID select 192~223 Segment 5 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_w_id7" protect="rw">
        <comment>Segment 5 Write Master ID select 224~255 Segment 5 Write Master ID select 224~255</comment>
      </reg>
    </module>
    <instance address="0x51328000" name="MEM_FW_SPIFLASH2" type="MEM_FW_SPIFLASH2"/>
  </archive>
  <archive relative="mem_fw_spiflash1.xml">
    <module category="System" name="MEM_FW_SPIFLASH1">
      <reg name="port0_default_r_addr_0" protect="rw">
        <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10). default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_r_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <reg name="port0_default_w_addr_0" protect="rw">
        <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10). default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_w_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <hole size="1984"/>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clock gate bypass clock gate bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clock gate bypass</comment>
        </bits>
      </reg>
      <hole size="2016"/>
      <reg name="port_int_w_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_w_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_w_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_w_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="0" rst="0x0">
          <comment>Port 0 read address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_r_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="0" rst="0x0">
          <comment>Port 0 read address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_r_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_r_raw" pos="0" rst="0x0">
          <comment>Port 0 read address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_r_fin" pos="0" rst="0x0">
          <comment>Port 0 read address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <hole size="3840"/>
      <reg name="port_0_w_debug_addr" protect="rw">
        <comment>Debug address register for port 0 write channel Debug address register for port 0 write channel</comment>
        <bits access="r" name="w_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 write channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_w_debug_id" protect="rw">
        <comment>Debug id register for port 0 write channel Debug id register for port 0 write channel</comment>
        <bits access="r" name="w_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 write channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_addr" protect="rw">
        <comment>Debug address register for port 0 read channel Debug address register for port 0 read channel</comment>
        <bits access="r" name="r_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 read channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_id" protect="rw">
        <comment>Debug id register for port 0 read channel Debug id register for port 0 read channel</comment>
        <bits access="r" name="r_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 read channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <hole size="8064"/>
      <reg name="seg_default_first_addr" protect="rw">
        <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte) Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_last_addr" protect="rw">
        <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte) Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_mst_r_id0" protect="rw">
        <comment>Default Segment Read Master ID select 0~31 Default Segment Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_r_id1" protect="rw">
        <comment>Default Segment Read Master ID select 32~63 Default Segment Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_r_id2" protect="rw">
        <comment>Default Segment Read Master ID select 64~95 Default Segment Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_r_id3" protect="rw">
        <comment>Default Segment Read Master ID select 96~127 Default Segment Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_r_id4" protect="rw">
        <comment>Default Segment Read Master ID select 128~159 Default Segment Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_r_id5" protect="rw">
        <comment>Default Segment Read Master ID select 160~191 Default Segment Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_r_id6" protect="rw">
        <comment>Default Segment Read Master ID select 192~223 Default Segment Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_r_id7" protect="rw">
        <comment>Default Segment Read Master ID select 224~255 Default Segment Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_default_mst_w_id0" protect="rw">
        <comment>Default Segment write Master ID select 0~31 Default Segment write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_w_id1" protect="rw">
        <comment>Default Segment write Master ID select 32~63 Default Segment write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_w_id2" protect="rw">
        <comment>Default Segment write Master ID select 64~95 Default Segment write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_w_id3" protect="rw">
        <comment>Default Segment write Master ID select 96~127 Default Segment write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_w_id4" protect="rw">
        <comment>Default Segment write Master ID select 128~159 Default Segment write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_w_id5" protect="rw">
        <comment>Default Segment write Master ID select 160~191 Default Segment write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_w_id6" protect="rw">
        <comment>Default Segment write Master ID select 192~223 Default Segment write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_w_id7" protect="rw">
        <comment>Default Segment write Master ID select 224~255 Default Segment write Master ID select 224~255</comment>
      </reg>
      <hole size="15808"/>
      <reg name="seg_0_first_addr" protect="rw">
        <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte) Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_last_addr" protect="rw">
        <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte) Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_mst_r_id0" protect="rw">
        <comment>Segment 0 Read Master ID select 0~31 Segment 0 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_r_id1" protect="rw">
        <comment>Segment 0 Read Master ID select 32~63 Segment 0 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_r_id2" protect="rw">
        <comment>Segment 0 Read Master ID select 64~95 Segment 0 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_r_id3" protect="rw">
        <comment>Segment 0 Read Master ID select 96~127 Segment 0 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_r_id4" protect="rw">
        <comment>Segment 0 Read Master ID select 128~159 Segment 0 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_r_id5" protect="rw">
        <comment>Segment 0 Read Master ID select 160~191 Segment 0 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_r_id6" protect="rw">
        <comment>Segment 0 Read Master ID select 192~223 Segment 0 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_r_id7" protect="rw">
        <comment>Segment 0 Read Master ID select 224~255 Segment 0 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_0_mst_w_id0" protect="rw">
        <comment>Segment 0 Write Master ID select 0~31 Segment 0 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_w_id1" protect="rw">
        <comment>Segment 0 Write Master ID select 32~63 Segment 0 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_w_id2" protect="rw">
        <comment>Segment 0 Write Master ID select 64~95 Segment 0 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_w_id3" protect="rw">
        <comment>Segment 0 Write Master ID select 96~127 Segment 0 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_w_id4" protect="rw">
        <comment>Segment 0 Write Master ID select 128~159 Segment 0 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_w_id5" protect="rw">
        <comment>Segment 0 Write Master ID select 160~191 Segment 0 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_w_id6" protect="rw">
        <comment>Segment 0 Write Master ID select 192~223 Segment 0 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_w_id7" protect="rw">
        <comment>Segment 0 Write Master ID select 224~255 Segment 0 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_1_first_addr" protect="rw">
        <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte) Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_last_addr" protect="rw">
        <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte) Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_mst_r_id0" protect="rw">
        <comment>Segment 1 Read Master ID select 0~31 Segment 1 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_r_id1" protect="rw">
        <comment>Segment 1 Read Master ID select 32~63 Segment 1 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_r_id2" protect="rw">
        <comment>Segment 1 Read Master ID select 64~95 Segment 1 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_r_id3" protect="rw">
        <comment>Segment 1 Read Master ID select 96~127 Segment 1 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_r_id4" protect="rw">
        <comment>Segment 1 Read Master ID select 128~159 Segment 1 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_r_id5" protect="rw">
        <comment>Segment 1 Read Master ID select 160~191 Segment 1 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_r_id6" protect="rw">
        <comment>Segment 1 Read Master ID select 192~223 Segment 1 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_r_id7" protect="rw">
        <comment>Segment 1 Read Master ID select 224~255 Segment 1 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_1_mst_w_id0" protect="rw">
        <comment>Segment 1 Write Master ID select 0~31 Segment 1 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_w_id1" protect="rw">
        <comment>Segment 1 Write Master ID select 32~63 Segment 1 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_w_id2" protect="rw">
        <comment>Segment 1 Write Master ID select 64~95 Segment 1 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_w_id3" protect="rw">
        <comment>Segment 1 Write Master ID select 96~127 Segment 1 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_w_id4" protect="rw">
        <comment>Segment 1 Write Master ID select 128~159 Segment 1 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_w_id5" protect="rw">
        <comment>Segment 1 Write Master ID select 160~191 Segment 1 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_w_id6" protect="rw">
        <comment>Segment 1 Write Master ID select 192~223 Segment 1 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_w_id7" protect="rw">
        <comment>Segment 1 Write Master ID select 224~255 Segment 1 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_2_first_addr" protect="rw">
        <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte) Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_last_addr" protect="rw">
        <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte) Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_mst_r_id0" protect="rw">
        <comment>Segment 2 Read Master ID select 0~31 Segment 2 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_r_id1" protect="rw">
        <comment>Segment 2 Read Master ID select 32~63 Segment 2 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_r_id2" protect="rw">
        <comment>Segment 2 Read Master ID select 64~95 Segment 2 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_r_id3" protect="rw">
        <comment>Segment 2 Read Master ID select 96~127 Segment 2 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_r_id4" protect="rw">
        <comment>Segment 2 Read Master ID select 128~159 Segment 2 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_r_id5" protect="rw">
        <comment>Segment 2 Read Master ID select 160~191 Segment 2 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_r_id6" protect="rw">
        <comment>Segment 2 Read Master ID select 192~223 Segment 2 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_r_id7" protect="rw">
        <comment>Segment 2 Read Master ID select 224~255 Segment 2 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_2_mst_w_id0" protect="rw">
        <comment>Segment 2 Write Master ID select 0~31 Segment 2 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_w_id1" protect="rw">
        <comment>Segment 2 Write Master ID select 32~63 Segment 2 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_w_id2" protect="rw">
        <comment>Segment 2 Write Master ID select 64~95 Segment 2 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_w_id3" protect="rw">
        <comment>Segment 2 Write Master ID select 96~127 Segment 2 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_w_id4" protect="rw">
        <comment>Segment 2 Write Master ID select 128~159 Segment 2 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_w_id5" protect="rw">
        <comment>Segment 2 Write Master ID select 160~191 Segment 2 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_w_id6" protect="rw">
        <comment>Segment 2 Write Master ID select 192~223 Segment 2 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_w_id7" protect="rw">
        <comment>Segment 2 Write Master ID select 224~255 Segment 2 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_3_first_addr" protect="rw">
        <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte) Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_last_addr" protect="rw">
        <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte) Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_mst_r_id0" protect="rw">
        <comment>Segment 3 Read Master ID select 0~31 Segment 3 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_r_id1" protect="rw">
        <comment>Segment 3 Read Master ID select 32~63 Segment 3 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_r_id2" protect="rw">
        <comment>Segment 3 Read Master ID select 64~95 Segment 3 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_r_id3" protect="rw">
        <comment>Segment 3 Read Master ID select 96~127 Segment 3 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_r_id4" protect="rw">
        <comment>Segment 3 Read Master ID select 128~159 Segment 3 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_r_id5" protect="rw">
        <comment>Segment 3 Read Master ID select 160~191 Segment 3 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_r_id6" protect="rw">
        <comment>Segment 3 Read Master ID select 192~223 Segment 3 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_r_id7" protect="rw">
        <comment>Segment 3 Read Master ID select 224~255 Segment 3 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_3_mst_w_id0" protect="rw">
        <comment>Segment 3 Write Master ID select 0~31 Segment 3 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_w_id1" protect="rw">
        <comment>Segment 3 Write Master ID select 32~63 Segment 3 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_w_id2" protect="rw">
        <comment>Segment 3 Write Master ID select 64~95 Segment 3 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_w_id3" protect="rw">
        <comment>Segment 3 Write Master ID select 96~127 Segment 3 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_w_id4" protect="rw">
        <comment>Segment 3 Write Master ID select 128~159 Segment 3 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_w_id5" protect="rw">
        <comment>Segment 3 Write Master ID select 160~191 Segment 3 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_w_id6" protect="rw">
        <comment>Segment 3 Write Master ID select 192~223 Segment 3 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_w_id7" protect="rw">
        <comment>Segment 3 Write Master ID select 224~255 Segment 3 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_4_first_addr" protect="rw">
        <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte) Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_last_addr" protect="rw">
        <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte) Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_mst_r_id0" protect="rw">
        <comment>Segment 4 Read Master ID select 0~31 Segment 4 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_r_id1" protect="rw">
        <comment>Segment 4 Read Master ID select 32~63 Segment 4 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_r_id2" protect="rw">
        <comment>Segment 4 Read Master ID select 64~95 Segment 4 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_r_id3" protect="rw">
        <comment>Segment 4 Read Master ID select 96~127 Segment 4 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_r_id4" protect="rw">
        <comment>Segment 4 Read Master ID select 128~159 Segment 4 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_r_id5" protect="rw">
        <comment>Segment 4 Read Master ID select 160~191 Segment 4 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_r_id6" protect="rw">
        <comment>Segment 4 Read Master ID select 192~223 Segment 4 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_r_id7" protect="rw">
        <comment>Segment 4 Read Master ID select 224~255 Segment 4 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_4_mst_w_id0" protect="rw">
        <comment>Segment 4 Write Master ID select 0~31 Segment 4 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_w_id1" protect="rw">
        <comment>Segment 4 Write Master ID select 32~63 Segment 4 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_w_id2" protect="rw">
        <comment>Segment 4 Write Master ID select 64~95 Segment 4 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_w_id3" protect="rw">
        <comment>Segment 4 Write Master ID select 96~127 Segment 4 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_w_id4" protect="rw">
        <comment>Segment 4 Write Master ID select 128~159 Segment 4 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_w_id5" protect="rw">
        <comment>Segment 4 Write Master ID select 160~191 Segment 4 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_w_id6" protect="rw">
        <comment>Segment 4 Write Master ID select 192~223 Segment 4 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_w_id7" protect="rw">
        <comment>Segment 4 Write Master ID select 224~255 Segment 4 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_5_first_addr" protect="rw">
        <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte) Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_last_addr" protect="rw">
        <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte) Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_mst_r_id0" protect="rw">
        <comment>Segment 5 Read Master ID select 0~31 Segment 5 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_r_id1" protect="rw">
        <comment>Segment 5 Read Master ID select 32~63 Segment 5 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_r_id2" protect="rw">
        <comment>Segment 5 Read Master ID select 64~95 Segment 5 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_r_id3" protect="rw">
        <comment>Segment 5 Read Master ID select 96~127 Segment 5 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_r_id4" protect="rw">
        <comment>Segment 5 Read Master ID select 128~159 Segment 5 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_r_id5" protect="rw">
        <comment>Segment 5 Read Master ID select 160~191 Segment 5 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_r_id6" protect="rw">
        <comment>Segment 5 Read Master ID select 192~223 Segment 5 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_r_id7" protect="rw">
        <comment>Segment 5 Read Master ID select 224~255 Segment 5 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_5_mst_w_id0" protect="rw">
        <comment>Segment 5 Write Master ID select 0~31 Segment 5 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_w_id1" protect="rw">
        <comment>Segment 5 Write Master ID select 32~63 Segment 5 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_w_id2" protect="rw">
        <comment>Segment 5 Write Master ID select 64~95 Segment 5 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_w_id3" protect="rw">
        <comment>Segment 5 Write Master ID select 96~127 Segment 5 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_w_id4" protect="rw">
        <comment>Segment 5 Write Master ID select 128~159 Segment 5 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_w_id5" protect="rw">
        <comment>Segment 5 Write Master ID select 160~191 Segment 5 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_w_id6" protect="rw">
        <comment>Segment 5 Write Master ID select 192~223 Segment 5 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_w_id7" protect="rw">
        <comment>Segment 5 Write Master ID select 224~255 Segment 5 Write Master ID select 224~255</comment>
      </reg>
    </module>
    <instance address="0x51326000" name="MEM_FW_SPIFLASH1" type="MEM_FW_SPIFLASH1"/>
  </archive>
  <archive relative="mem_fw_pub_mem.xml">
    <module category="System" name="MEM_FW_PUB_MEM">
      <reg name="port0_default_r_addr_0" protect="rw">
        <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10). default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_r_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default r address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <reg name="port0_default_w_addr_0" protect="rw">
        <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10). default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_w_addr_0" pos="16:0" rst="0x1ffff">
          <comment>default w address 0 register(1K-Byte address, bit 26 ~ bit 10).</comment>
        </bits>
      </reg>
      <hole size="1984"/>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clock gate bypass clock gate bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clock gate bypass</comment>
        </bits>
      </reg>
      <hole size="2016"/>
      <reg name="port_int_w_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_w_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_w_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_w_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="0" rst="0x0">
          <comment>Port 0 read address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_r_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="0" rst="0x0">
          <comment>Port 0 read address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_r_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_r_raw" pos="0" rst="0x0">
          <comment>Port 0 read address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_r_fin" pos="0" rst="0x0">
          <comment>Port 0 read address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <hole size="3840"/>
      <reg name="port_0_w_debug_addr" protect="rw">
        <comment>Debug address register for port 0 write channel Debug address register for port 0 write channel</comment>
        <bits access="r" name="w_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 write channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_w_debug_id" protect="rw">
        <comment>Debug id register for port 0 write channel Debug id register for port 0 write channel</comment>
        <bits access="r" name="w_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 write channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_addr" protect="rw">
        <comment>Debug address register for port 0 read channel Debug address register for port 0 read channel</comment>
        <bits access="r" name="r_addr_0" pos="16:0" rst="0x0">
          <comment>Port 0 read channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_id" protect="rw">
        <comment>Debug id register for port 0 read channel Debug id register for port 0 read channel</comment>
        <bits access="r" name="r_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 read channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <hole size="8064"/>
      <reg name="seg_default_first_addr" protect="rw">
        <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte) Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_last_addr" protect="rw">
        <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte) Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_mst_r_id0" protect="rw">
        <comment>Default Segment Read Master ID select 0~31 Default Segment Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_r_id1" protect="rw">
        <comment>Default Segment Read Master ID select 32~63 Default Segment Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_r_id2" protect="rw">
        <comment>Default Segment Read Master ID select 64~95 Default Segment Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_r_id3" protect="rw">
        <comment>Default Segment Read Master ID select 96~127 Default Segment Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_r_id4" protect="rw">
        <comment>Default Segment Read Master ID select 128~159 Default Segment Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_r_id5" protect="rw">
        <comment>Default Segment Read Master ID select 160~191 Default Segment Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_r_id6" protect="rw">
        <comment>Default Segment Read Master ID select 192~223 Default Segment Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_r_id7" protect="rw">
        <comment>Default Segment Read Master ID select 224~255 Default Segment Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_default_mst_w_id0" protect="rw">
        <comment>Default Segment write Master ID select 0~31 Default Segment write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_w_id1" protect="rw">
        <comment>Default Segment write Master ID select 32~63 Default Segment write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_w_id2" protect="rw">
        <comment>Default Segment write Master ID select 64~95 Default Segment write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_w_id3" protect="rw">
        <comment>Default Segment write Master ID select 96~127 Default Segment write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_w_id4" protect="rw">
        <comment>Default Segment write Master ID select 128~159 Default Segment write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_w_id5" protect="rw">
        <comment>Default Segment write Master ID select 160~191 Default Segment write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_w_id6" protect="rw">
        <comment>Default Segment write Master ID select 192~223 Default Segment write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_w_id7" protect="rw">
        <comment>Default Segment write Master ID select 224~255 Default Segment write Master ID select 224~255</comment>
      </reg>
      <hole size="15808"/>
      <reg name="seg_0_first_addr" protect="rw">
        <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte) Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_last_addr" protect="rw">
        <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte) Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_mst_r_id0" protect="rw">
        <comment>Segment 0 Read Master ID select 0~31 Segment 0 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_r_id1" protect="rw">
        <comment>Segment 0 Read Master ID select 32~63 Segment 0 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_r_id2" protect="rw">
        <comment>Segment 0 Read Master ID select 64~95 Segment 0 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_r_id3" protect="rw">
        <comment>Segment 0 Read Master ID select 96~127 Segment 0 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_r_id4" protect="rw">
        <comment>Segment 0 Read Master ID select 128~159 Segment 0 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_r_id5" protect="rw">
        <comment>Segment 0 Read Master ID select 160~191 Segment 0 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_r_id6" protect="rw">
        <comment>Segment 0 Read Master ID select 192~223 Segment 0 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_r_id7" protect="rw">
        <comment>Segment 0 Read Master ID select 224~255 Segment 0 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_0_mst_w_id0" protect="rw">
        <comment>Segment 0 Write Master ID select 0~31 Segment 0 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_w_id1" protect="rw">
        <comment>Segment 0 Write Master ID select 32~63 Segment 0 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_w_id2" protect="rw">
        <comment>Segment 0 Write Master ID select 64~95 Segment 0 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_w_id3" protect="rw">
        <comment>Segment 0 Write Master ID select 96~127 Segment 0 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_w_id4" protect="rw">
        <comment>Segment 0 Write Master ID select 128~159 Segment 0 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_w_id5" protect="rw">
        <comment>Segment 0 Write Master ID select 160~191 Segment 0 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_w_id6" protect="rw">
        <comment>Segment 0 Write Master ID select 192~223 Segment 0 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_w_id7" protect="rw">
        <comment>Segment 0 Write Master ID select 224~255 Segment 0 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_1_first_addr" protect="rw">
        <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte) Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_last_addr" protect="rw">
        <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte) Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_mst_r_id0" protect="rw">
        <comment>Segment 1 Read Master ID select 0~31 Segment 1 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_r_id1" protect="rw">
        <comment>Segment 1 Read Master ID select 32~63 Segment 1 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_r_id2" protect="rw">
        <comment>Segment 1 Read Master ID select 64~95 Segment 1 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_r_id3" protect="rw">
        <comment>Segment 1 Read Master ID select 96~127 Segment 1 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_r_id4" protect="rw">
        <comment>Segment 1 Read Master ID select 128~159 Segment 1 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_r_id5" protect="rw">
        <comment>Segment 1 Read Master ID select 160~191 Segment 1 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_r_id6" protect="rw">
        <comment>Segment 1 Read Master ID select 192~223 Segment 1 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_r_id7" protect="rw">
        <comment>Segment 1 Read Master ID select 224~255 Segment 1 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_1_mst_w_id0" protect="rw">
        <comment>Segment 1 Write Master ID select 0~31 Segment 1 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_w_id1" protect="rw">
        <comment>Segment 1 Write Master ID select 32~63 Segment 1 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_w_id2" protect="rw">
        <comment>Segment 1 Write Master ID select 64~95 Segment 1 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_w_id3" protect="rw">
        <comment>Segment 1 Write Master ID select 96~127 Segment 1 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_w_id4" protect="rw">
        <comment>Segment 1 Write Master ID select 128~159 Segment 1 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_w_id5" protect="rw">
        <comment>Segment 1 Write Master ID select 160~191 Segment 1 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_w_id6" protect="rw">
        <comment>Segment 1 Write Master ID select 192~223 Segment 1 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_w_id7" protect="rw">
        <comment>Segment 1 Write Master ID select 224~255 Segment 1 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_2_first_addr" protect="rw">
        <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte) Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_last_addr" protect="rw">
        <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte) Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_mst_r_id0" protect="rw">
        <comment>Segment 2 Read Master ID select 0~31 Segment 2 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_r_id1" protect="rw">
        <comment>Segment 2 Read Master ID select 32~63 Segment 2 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_r_id2" protect="rw">
        <comment>Segment 2 Read Master ID select 64~95 Segment 2 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_r_id3" protect="rw">
        <comment>Segment 2 Read Master ID select 96~127 Segment 2 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_r_id4" protect="rw">
        <comment>Segment 2 Read Master ID select 128~159 Segment 2 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_r_id5" protect="rw">
        <comment>Segment 2 Read Master ID select 160~191 Segment 2 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_r_id6" protect="rw">
        <comment>Segment 2 Read Master ID select 192~223 Segment 2 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_r_id7" protect="rw">
        <comment>Segment 2 Read Master ID select 224~255 Segment 2 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_2_mst_w_id0" protect="rw">
        <comment>Segment 2 Write Master ID select 0~31 Segment 2 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_w_id1" protect="rw">
        <comment>Segment 2 Write Master ID select 32~63 Segment 2 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_w_id2" protect="rw">
        <comment>Segment 2 Write Master ID select 64~95 Segment 2 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_w_id3" protect="rw">
        <comment>Segment 2 Write Master ID select 96~127 Segment 2 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_w_id4" protect="rw">
        <comment>Segment 2 Write Master ID select 128~159 Segment 2 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_w_id5" protect="rw">
        <comment>Segment 2 Write Master ID select 160~191 Segment 2 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_w_id6" protect="rw">
        <comment>Segment 2 Write Master ID select 192~223 Segment 2 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_w_id7" protect="rw">
        <comment>Segment 2 Write Master ID select 224~255 Segment 2 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_3_first_addr" protect="rw">
        <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte) Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_last_addr" protect="rw">
        <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte) Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_mst_r_id0" protect="rw">
        <comment>Segment 3 Read Master ID select 0~31 Segment 3 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_r_id1" protect="rw">
        <comment>Segment 3 Read Master ID select 32~63 Segment 3 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_r_id2" protect="rw">
        <comment>Segment 3 Read Master ID select 64~95 Segment 3 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_r_id3" protect="rw">
        <comment>Segment 3 Read Master ID select 96~127 Segment 3 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_r_id4" protect="rw">
        <comment>Segment 3 Read Master ID select 128~159 Segment 3 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_r_id5" protect="rw">
        <comment>Segment 3 Read Master ID select 160~191 Segment 3 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_r_id6" protect="rw">
        <comment>Segment 3 Read Master ID select 192~223 Segment 3 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_r_id7" protect="rw">
        <comment>Segment 3 Read Master ID select 224~255 Segment 3 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_3_mst_w_id0" protect="rw">
        <comment>Segment 3 Write Master ID select 0~31 Segment 3 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_w_id1" protect="rw">
        <comment>Segment 3 Write Master ID select 32~63 Segment 3 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_w_id2" protect="rw">
        <comment>Segment 3 Write Master ID select 64~95 Segment 3 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_w_id3" protect="rw">
        <comment>Segment 3 Write Master ID select 96~127 Segment 3 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_w_id4" protect="rw">
        <comment>Segment 3 Write Master ID select 128~159 Segment 3 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_w_id5" protect="rw">
        <comment>Segment 3 Write Master ID select 160~191 Segment 3 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_w_id6" protect="rw">
        <comment>Segment 3 Write Master ID select 192~223 Segment 3 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_w_id7" protect="rw">
        <comment>Segment 3 Write Master ID select 224~255 Segment 3 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_4_first_addr" protect="rw">
        <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte) Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_last_addr" protect="rw">
        <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte) Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_mst_r_id0" protect="rw">
        <comment>Segment 4 Read Master ID select 0~31 Segment 4 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_r_id1" protect="rw">
        <comment>Segment 4 Read Master ID select 32~63 Segment 4 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_r_id2" protect="rw">
        <comment>Segment 4 Read Master ID select 64~95 Segment 4 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_r_id3" protect="rw">
        <comment>Segment 4 Read Master ID select 96~127 Segment 4 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_r_id4" protect="rw">
        <comment>Segment 4 Read Master ID select 128~159 Segment 4 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_r_id5" protect="rw">
        <comment>Segment 4 Read Master ID select 160~191 Segment 4 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_r_id6" protect="rw">
        <comment>Segment 4 Read Master ID select 192~223 Segment 4 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_r_id7" protect="rw">
        <comment>Segment 4 Read Master ID select 224~255 Segment 4 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_4_mst_w_id0" protect="rw">
        <comment>Segment 4 Write Master ID select 0~31 Segment 4 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_w_id1" protect="rw">
        <comment>Segment 4 Write Master ID select 32~63 Segment 4 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_w_id2" protect="rw">
        <comment>Segment 4 Write Master ID select 64~95 Segment 4 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_w_id3" protect="rw">
        <comment>Segment 4 Write Master ID select 96~127 Segment 4 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_w_id4" protect="rw">
        <comment>Segment 4 Write Master ID select 128~159 Segment 4 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_w_id5" protect="rw">
        <comment>Segment 4 Write Master ID select 160~191 Segment 4 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_w_id6" protect="rw">
        <comment>Segment 4 Write Master ID select 192~223 Segment 4 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_w_id7" protect="rw">
        <comment>Segment 4 Write Master ID select 224~255 Segment 4 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_5_first_addr" protect="rw">
        <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte) Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_last_addr" protect="rw">
        <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte) Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_mst_r_id0" protect="rw">
        <comment>Segment 5 Read Master ID select 0~31 Segment 5 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_r_id1" protect="rw">
        <comment>Segment 5 Read Master ID select 32~63 Segment 5 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_r_id2" protect="rw">
        <comment>Segment 5 Read Master ID select 64~95 Segment 5 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_r_id3" protect="rw">
        <comment>Segment 5 Read Master ID select 96~127 Segment 5 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_r_id4" protect="rw">
        <comment>Segment 5 Read Master ID select 128~159 Segment 5 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_r_id5" protect="rw">
        <comment>Segment 5 Read Master ID select 160~191 Segment 5 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_r_id6" protect="rw">
        <comment>Segment 5 Read Master ID select 192~223 Segment 5 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_r_id7" protect="rw">
        <comment>Segment 5 Read Master ID select 224~255 Segment 5 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_5_mst_w_id0" protect="rw">
        <comment>Segment 5 Write Master ID select 0~31 Segment 5 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_w_id1" protect="rw">
        <comment>Segment 5 Write Master ID select 32~63 Segment 5 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_w_id2" protect="rw">
        <comment>Segment 5 Write Master ID select 64~95 Segment 5 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_w_id3" protect="rw">
        <comment>Segment 5 Write Master ID select 96~127 Segment 5 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_w_id4" protect="rw">
        <comment>Segment 5 Write Master ID select 128~159 Segment 5 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_w_id5" protect="rw">
        <comment>Segment 5 Write Master ID select 160~191 Segment 5 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_w_id6" protect="rw">
        <comment>Segment 5 Write Master ID select 192~223 Segment 5 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_w_id7" protect="rw">
        <comment>Segment 5 Write Master ID select 224~255 Segment 5 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_6_first_addr" protect="rw">
        <comment>Segment 6 first address, the actual address should right shift 10-bit (1K-Byte) Segment 6 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 6 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_6_last_addr" protect="rw">
        <comment>Segment 6 last address, the actual address should right shift 10-bit (1K-Byte) Segment 6 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 6 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_6_mst_r_id0" protect="rw">
        <comment>Segment 6 Read Master ID select 0~31 Segment 6 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_6_mst_r_id1" protect="rw">
        <comment>Segment 6 Read Master ID select 32~63 Segment 6 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_6_mst_r_id2" protect="rw">
        <comment>Segment 6 Read Master ID select 64~95 Segment 6 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_6_mst_r_id3" protect="rw">
        <comment>Segment 6 Read Master ID select 96~127 Segment 6 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_6_mst_r_id4" protect="rw">
        <comment>Segment 6 Read Master ID select 128~159 Segment 6 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_6_mst_r_id5" protect="rw">
        <comment>Segment 6 Read Master ID select 160~191 Segment 6 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_6_mst_r_id6" protect="rw">
        <comment>Segment 6 Read Master ID select 192~223 Segment 6 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_6_mst_r_id7" protect="rw">
        <comment>Segment 6 Read Master ID select 224~255 Segment 6 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_6_mst_w_id0" protect="rw">
        <comment>Segment 6 Write Master ID select 0~31 Segment 6 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_6_mst_w_id1" protect="rw">
        <comment>Segment 6 Write Master ID select 32~63 Segment 6 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_6_mst_w_id2" protect="rw">
        <comment>Segment 6 Write Master ID select 64~95 Segment 6 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_6_mst_w_id3" protect="rw">
        <comment>Segment 6 Write Master ID select 96~127 Segment 6 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_6_mst_w_id4" protect="rw">
        <comment>Segment 6 Write Master ID select 128~159 Segment 6 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_6_mst_w_id5" protect="rw">
        <comment>Segment 6 Write Master ID select 160~191 Segment 6 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_6_mst_w_id6" protect="rw">
        <comment>Segment 6 Write Master ID select 192~223 Segment 6 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_6_mst_w_id7" protect="rw">
        <comment>Segment 6 Write Master ID select 224~255 Segment 6 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_7_first_addr" protect="rw">
        <comment>Segment 7 first address, the actual address should right shift 10-bit (1K-Byte) Segment 7 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="16:0" rst="0x1ffff">
          <comment>Segment 7 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_7_last_addr" protect="rw">
        <comment>Segment 7 last address, the actual address should right shift 10-bit (1K-Byte) Segment 7 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="16:0" rst="0x0">
          <comment>Segment 7 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_7_mst_r_id0" protect="rw">
        <comment>Segment 7 Read Master ID select 0~31 Segment 7 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_7_mst_r_id1" protect="rw">
        <comment>Segment 7 Read Master ID select 32~63 Segment 7 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_7_mst_r_id2" protect="rw">
        <comment>Segment 7 Read Master ID select 64~95 Segment 7 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_7_mst_r_id3" protect="rw">
        <comment>Segment 7 Read Master ID select 96~127 Segment 7 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_7_mst_r_id4" protect="rw">
        <comment>Segment 7 Read Master ID select 128~159 Segment 7 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_7_mst_r_id5" protect="rw">
        <comment>Segment 7 Read Master ID select 160~191 Segment 7 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_7_mst_r_id6" protect="rw">
        <comment>Segment 7 Read Master ID select 192~223 Segment 7 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_7_mst_r_id7" protect="rw">
        <comment>Segment 7 Read Master ID select 224~255 Segment 7 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_7_mst_w_id0" protect="rw">
        <comment>Segment 7 Write Master ID select 0~31 Segment 7 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_7_mst_w_id1" protect="rw">
        <comment>Segment 7 Write Master ID select 32~63 Segment 7 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_7_mst_w_id2" protect="rw">
        <comment>Segment 7 Write Master ID select 64~95 Segment 7 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_7_mst_w_id3" protect="rw">
        <comment>Segment 7 Write Master ID select 96~127 Segment 7 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_7_mst_w_id4" protect="rw">
        <comment>Segment 7 Write Master ID select 128~159 Segment 7 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_7_mst_w_id5" protect="rw">
        <comment>Segment 7 Write Master ID select 160~191 Segment 7 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_7_mst_w_id6" protect="rw">
        <comment>Segment 7 Write Master ID select 192~223 Segment 7 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_7_mst_w_id7" protect="rw">
        <comment>Segment 7 Write Master ID select 224~255 Segment 7 Write Master ID select 224~255</comment>
      </reg>
    </module>
    <instance address="0x51330000" name="MEM_FW_PUB_MEM" type="MEM_FW_PUB_MEM"/>
  </archive>
  <archive relative="mem_fw_ap_imem.xml">
    <module category="System" name="MEM_FW_AP_IMEM">
      <reg name="port0_default_r_addr_0" protect="rw">
        <comment>default r address 0 register(1K-Byte address, bit 22 ~ bit 10). default r address 0 register(1K-Byte address, bit 22 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_r_addr_0" pos="12:0" rst="0x1fff">
          <comment>default r address 0 register(1K-Byte address, bit 22 ~ bit 10).</comment>
        </bits>
      </reg>
      <reg name="port0_default_w_addr_0" protect="rw">
        <comment>default w address 0 register(1K-Byte address, bit 22 ~ bit 10). default w address 0 register(1K-Byte address, bit 22 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_w_addr_0" pos="12:0" rst="0x1fff">
          <comment>default w address 0 register(1K-Byte address, bit 22 ~ bit 10).</comment>
        </bits>
      </reg>
      <hole size="1984"/>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clock gate bypass clock gate bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clock gate bypass</comment>
        </bits>
      </reg>
      <hole size="2016"/>
      <reg name="port_int_w_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_w_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_w_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_w_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="0" rst="0x0">
          <comment>Port 0 read address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_r_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="0" rst="0x0">
          <comment>Port 0 read address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_r_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_r_raw" pos="0" rst="0x0">
          <comment>Port 0 read address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_r_fin" pos="0" rst="0x0">
          <comment>Port 0 read address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <hole size="3840"/>
      <reg name="port_0_w_debug_addr" protect="rw">
        <comment>Debug address register for port 0 write channel Debug address register for port 0 write channel</comment>
        <bits access="r" name="w_addr_0" pos="12:0" rst="0x0">
          <comment>Port 0 write channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_w_debug_id" protect="rw">
        <comment>Debug id register for port 0 write channel Debug id register for port 0 write channel</comment>
        <bits access="r" name="w_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 write channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_addr" protect="rw">
        <comment>Debug address register for port 0 read channel Debug address register for port 0 read channel</comment>
        <bits access="r" name="r_addr_0" pos="12:0" rst="0x0">
          <comment>Port 0 read channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_id" protect="rw">
        <comment>Debug id register for port 0 read channel Debug id register for port 0 read channel</comment>
        <bits access="r" name="r_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 read channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <hole size="8064"/>
      <reg name="seg_default_first_addr" protect="rw">
        <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte) Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_last_addr" protect="rw">
        <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte) Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_mst_r_id0" protect="rw">
        <comment>Default Segment Read Master ID select 0~31 Default Segment Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_r_id1" protect="rw">
        <comment>Default Segment Read Master ID select 32~63 Default Segment Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_r_id2" protect="rw">
        <comment>Default Segment Read Master ID select 64~95 Default Segment Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_r_id3" protect="rw">
        <comment>Default Segment Read Master ID select 96~127 Default Segment Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_r_id4" protect="rw">
        <comment>Default Segment Read Master ID select 128~159 Default Segment Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_r_id5" protect="rw">
        <comment>Default Segment Read Master ID select 160~191 Default Segment Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_r_id6" protect="rw">
        <comment>Default Segment Read Master ID select 192~223 Default Segment Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_r_id7" protect="rw">
        <comment>Default Segment Read Master ID select 224~255 Default Segment Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_default_mst_w_id0" protect="rw">
        <comment>Default Segment write Master ID select 0~31 Default Segment write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_w_id1" protect="rw">
        <comment>Default Segment write Master ID select 32~63 Default Segment write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_w_id2" protect="rw">
        <comment>Default Segment write Master ID select 64~95 Default Segment write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_w_id3" protect="rw">
        <comment>Default Segment write Master ID select 96~127 Default Segment write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_w_id4" protect="rw">
        <comment>Default Segment write Master ID select 128~159 Default Segment write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_w_id5" protect="rw">
        <comment>Default Segment write Master ID select 160~191 Default Segment write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_w_id6" protect="rw">
        <comment>Default Segment write Master ID select 192~223 Default Segment write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_w_id7" protect="rw">
        <comment>Default Segment write Master ID select 224~255 Default Segment write Master ID select 224~255</comment>
      </reg>
      <hole size="15808"/>
      <reg name="seg_0_first_addr" protect="rw">
        <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte) Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_last_addr" protect="rw">
        <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte) Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_mst_r_id0" protect="rw">
        <comment>Segment 0 Read Master ID select 0~31 Segment 0 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_r_id1" protect="rw">
        <comment>Segment 0 Read Master ID select 32~63 Segment 0 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_r_id2" protect="rw">
        <comment>Segment 0 Read Master ID select 64~95 Segment 0 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_r_id3" protect="rw">
        <comment>Segment 0 Read Master ID select 96~127 Segment 0 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_r_id4" protect="rw">
        <comment>Segment 0 Read Master ID select 128~159 Segment 0 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_r_id5" protect="rw">
        <comment>Segment 0 Read Master ID select 160~191 Segment 0 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_r_id6" protect="rw">
        <comment>Segment 0 Read Master ID select 192~223 Segment 0 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_r_id7" protect="rw">
        <comment>Segment 0 Read Master ID select 224~255 Segment 0 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_0_mst_w_id0" protect="rw">
        <comment>Segment 0 Write Master ID select 0~31 Segment 0 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_w_id1" protect="rw">
        <comment>Segment 0 Write Master ID select 32~63 Segment 0 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_w_id2" protect="rw">
        <comment>Segment 0 Write Master ID select 64~95 Segment 0 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_w_id3" protect="rw">
        <comment>Segment 0 Write Master ID select 96~127 Segment 0 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_w_id4" protect="rw">
        <comment>Segment 0 Write Master ID select 128~159 Segment 0 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_w_id5" protect="rw">
        <comment>Segment 0 Write Master ID select 160~191 Segment 0 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_w_id6" protect="rw">
        <comment>Segment 0 Write Master ID select 192~223 Segment 0 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_w_id7" protect="rw">
        <comment>Segment 0 Write Master ID select 224~255 Segment 0 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_1_first_addr" protect="rw">
        <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte) Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_last_addr" protect="rw">
        <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte) Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_mst_r_id0" protect="rw">
        <comment>Segment 1 Read Master ID select 0~31 Segment 1 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_r_id1" protect="rw">
        <comment>Segment 1 Read Master ID select 32~63 Segment 1 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_r_id2" protect="rw">
        <comment>Segment 1 Read Master ID select 64~95 Segment 1 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_r_id3" protect="rw">
        <comment>Segment 1 Read Master ID select 96~127 Segment 1 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_r_id4" protect="rw">
        <comment>Segment 1 Read Master ID select 128~159 Segment 1 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_r_id5" protect="rw">
        <comment>Segment 1 Read Master ID select 160~191 Segment 1 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_r_id6" protect="rw">
        <comment>Segment 1 Read Master ID select 192~223 Segment 1 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_r_id7" protect="rw">
        <comment>Segment 1 Read Master ID select 224~255 Segment 1 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_1_mst_w_id0" protect="rw">
        <comment>Segment 1 Write Master ID select 0~31 Segment 1 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_w_id1" protect="rw">
        <comment>Segment 1 Write Master ID select 32~63 Segment 1 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_w_id2" protect="rw">
        <comment>Segment 1 Write Master ID select 64~95 Segment 1 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_w_id3" protect="rw">
        <comment>Segment 1 Write Master ID select 96~127 Segment 1 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_w_id4" protect="rw">
        <comment>Segment 1 Write Master ID select 128~159 Segment 1 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_w_id5" protect="rw">
        <comment>Segment 1 Write Master ID select 160~191 Segment 1 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_w_id6" protect="rw">
        <comment>Segment 1 Write Master ID select 192~223 Segment 1 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_w_id7" protect="rw">
        <comment>Segment 1 Write Master ID select 224~255 Segment 1 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_2_first_addr" protect="rw">
        <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte) Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_last_addr" protect="rw">
        <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte) Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_mst_r_id0" protect="rw">
        <comment>Segment 2 Read Master ID select 0~31 Segment 2 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_r_id1" protect="rw">
        <comment>Segment 2 Read Master ID select 32~63 Segment 2 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_r_id2" protect="rw">
        <comment>Segment 2 Read Master ID select 64~95 Segment 2 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_r_id3" protect="rw">
        <comment>Segment 2 Read Master ID select 96~127 Segment 2 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_r_id4" protect="rw">
        <comment>Segment 2 Read Master ID select 128~159 Segment 2 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_r_id5" protect="rw">
        <comment>Segment 2 Read Master ID select 160~191 Segment 2 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_r_id6" protect="rw">
        <comment>Segment 2 Read Master ID select 192~223 Segment 2 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_r_id7" protect="rw">
        <comment>Segment 2 Read Master ID select 224~255 Segment 2 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_2_mst_w_id0" protect="rw">
        <comment>Segment 2 Write Master ID select 0~31 Segment 2 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_w_id1" protect="rw">
        <comment>Segment 2 Write Master ID select 32~63 Segment 2 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_w_id2" protect="rw">
        <comment>Segment 2 Write Master ID select 64~95 Segment 2 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_w_id3" protect="rw">
        <comment>Segment 2 Write Master ID select 96~127 Segment 2 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_w_id4" protect="rw">
        <comment>Segment 2 Write Master ID select 128~159 Segment 2 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_w_id5" protect="rw">
        <comment>Segment 2 Write Master ID select 160~191 Segment 2 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_w_id6" protect="rw">
        <comment>Segment 2 Write Master ID select 192~223 Segment 2 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_w_id7" protect="rw">
        <comment>Segment 2 Write Master ID select 224~255 Segment 2 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_3_first_addr" protect="rw">
        <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte) Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_last_addr" protect="rw">
        <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte) Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_mst_r_id0" protect="rw">
        <comment>Segment 3 Read Master ID select 0~31 Segment 3 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_r_id1" protect="rw">
        <comment>Segment 3 Read Master ID select 32~63 Segment 3 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_r_id2" protect="rw">
        <comment>Segment 3 Read Master ID select 64~95 Segment 3 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_r_id3" protect="rw">
        <comment>Segment 3 Read Master ID select 96~127 Segment 3 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_r_id4" protect="rw">
        <comment>Segment 3 Read Master ID select 128~159 Segment 3 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_r_id5" protect="rw">
        <comment>Segment 3 Read Master ID select 160~191 Segment 3 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_r_id6" protect="rw">
        <comment>Segment 3 Read Master ID select 192~223 Segment 3 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_r_id7" protect="rw">
        <comment>Segment 3 Read Master ID select 224~255 Segment 3 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_3_mst_w_id0" protect="rw">
        <comment>Segment 3 Write Master ID select 0~31 Segment 3 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_w_id1" protect="rw">
        <comment>Segment 3 Write Master ID select 32~63 Segment 3 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_w_id2" protect="rw">
        <comment>Segment 3 Write Master ID select 64~95 Segment 3 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_w_id3" protect="rw">
        <comment>Segment 3 Write Master ID select 96~127 Segment 3 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_w_id4" protect="rw">
        <comment>Segment 3 Write Master ID select 128~159 Segment 3 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_w_id5" protect="rw">
        <comment>Segment 3 Write Master ID select 160~191 Segment 3 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_w_id6" protect="rw">
        <comment>Segment 3 Write Master ID select 192~223 Segment 3 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_w_id7" protect="rw">
        <comment>Segment 3 Write Master ID select 224~255 Segment 3 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_4_first_addr" protect="rw">
        <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte) Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_last_addr" protect="rw">
        <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte) Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_mst_r_id0" protect="rw">
        <comment>Segment 4 Read Master ID select 0~31 Segment 4 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_r_id1" protect="rw">
        <comment>Segment 4 Read Master ID select 32~63 Segment 4 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_r_id2" protect="rw">
        <comment>Segment 4 Read Master ID select 64~95 Segment 4 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_r_id3" protect="rw">
        <comment>Segment 4 Read Master ID select 96~127 Segment 4 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_r_id4" protect="rw">
        <comment>Segment 4 Read Master ID select 128~159 Segment 4 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_r_id5" protect="rw">
        <comment>Segment 4 Read Master ID select 160~191 Segment 4 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_r_id6" protect="rw">
        <comment>Segment 4 Read Master ID select 192~223 Segment 4 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_r_id7" protect="rw">
        <comment>Segment 4 Read Master ID select 224~255 Segment 4 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_4_mst_w_id0" protect="rw">
        <comment>Segment 4 Write Master ID select 0~31 Segment 4 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_w_id1" protect="rw">
        <comment>Segment 4 Write Master ID select 32~63 Segment 4 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_w_id2" protect="rw">
        <comment>Segment 4 Write Master ID select 64~95 Segment 4 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_w_id3" protect="rw">
        <comment>Segment 4 Write Master ID select 96~127 Segment 4 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_w_id4" protect="rw">
        <comment>Segment 4 Write Master ID select 128~159 Segment 4 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_w_id5" protect="rw">
        <comment>Segment 4 Write Master ID select 160~191 Segment 4 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_w_id6" protect="rw">
        <comment>Segment 4 Write Master ID select 192~223 Segment 4 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_w_id7" protect="rw">
        <comment>Segment 4 Write Master ID select 224~255 Segment 4 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_5_first_addr" protect="rw">
        <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte) Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="12:0" rst="0x1fff">
          <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_last_addr" protect="rw">
        <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte) Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="12:0" rst="0x0">
          <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_mst_r_id0" protect="rw">
        <comment>Segment 5 Read Master ID select 0~31 Segment 5 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_r_id1" protect="rw">
        <comment>Segment 5 Read Master ID select 32~63 Segment 5 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_r_id2" protect="rw">
        <comment>Segment 5 Read Master ID select 64~95 Segment 5 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_r_id3" protect="rw">
        <comment>Segment 5 Read Master ID select 96~127 Segment 5 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_r_id4" protect="rw">
        <comment>Segment 5 Read Master ID select 128~159 Segment 5 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_r_id5" protect="rw">
        <comment>Segment 5 Read Master ID select 160~191 Segment 5 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_r_id6" protect="rw">
        <comment>Segment 5 Read Master ID select 192~223 Segment 5 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_r_id7" protect="rw">
        <comment>Segment 5 Read Master ID select 224~255 Segment 5 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_5_mst_w_id0" protect="rw">
        <comment>Segment 5 Write Master ID select 0~31 Segment 5 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_w_id1" protect="rw">
        <comment>Segment 5 Write Master ID select 32~63 Segment 5 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_w_id2" protect="rw">
        <comment>Segment 5 Write Master ID select 64~95 Segment 5 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_w_id3" protect="rw">
        <comment>Segment 5 Write Master ID select 96~127 Segment 5 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_w_id4" protect="rw">
        <comment>Segment 5 Write Master ID select 128~159 Segment 5 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_w_id5" protect="rw">
        <comment>Segment 5 Write Master ID select 160~191 Segment 5 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_w_id6" protect="rw">
        <comment>Segment 5 Write Master ID select 192~223 Segment 5 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_w_id7" protect="rw">
        <comment>Segment 5 Write Master ID select 224~255 Segment 5 Write Master ID select 224~255</comment>
      </reg>
    </module>
    <instance address="0x51324000" name="MEM_FW_AP_IMEM" type="MEM_FW_AP_IMEM"/>
  </archive>
  <archive relative="mem_fw_aon_imem.xml">
    <module category="System" name="MEM_FW_AON_IMEM">
      <reg name="port0_default_r_addr_0" protect="rw">
        <comment>default r address 0 register(1K-Byte address, bit 16 ~ bit 10). default r address 0 register(1K-Byte address, bit 16 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_r_addr_0" pos="6:0" rst="0x7f">
          <comment>default r address 0 register(1K-Byte address, bit 16 ~ bit 10).</comment>
        </bits>
      </reg>
      <reg name="port0_default_w_addr_0" protect="rw">
        <comment>default w address 0 register(1K-Byte address, bit 16 ~ bit 10). default w address 0 register(1K-Byte address, bit 16 ~ bit 10).</comment>
        <bits access="rw" name="port0_default_w_addr_0" pos="6:0" rst="0x7f">
          <comment>default w address 0 register(1K-Byte address, bit 16 ~ bit 10).</comment>
        </bits>
      </reg>
      <hole size="1984"/>
      <reg name="clk_gate_bypass" protect="rw">
        <comment>clock gate bypass clock gate bypass</comment>
        <bits access="rw" name="fw_resp_en" pos="1" rst="0x0">
          <comment>0: don't response error; 1: response error.</comment>
        </bits>
        <bits access="rw" name="clk_gate_bypass" pos="0" rst="0x0">
          <comment>clock gate bypass</comment>
        </bits>
      </reg>
      <hole size="2016"/>
      <reg name="port_int_w_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_w_en" pos="0" rst="0x0">
          <comment>Port 0 write address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_w_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_w_clr" pos="0" rst="0x0">
          <comment>Port 0 write address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_w_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_w_raw" pos="0" rst="0x0">
          <comment>Port 0 write address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_w_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_w_fin" pos="0" rst="0x0">
          <comment>Port 0 write address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_en" protect="rw">
        <comment>Interrupt enable reg Interrupt enable reg</comment>
        <bits access="rw" name="port_0_r_en" pos="0" rst="0x0">
          <comment>Port 0 read address miss int enable
1: Enable
0: Disable</comment>
        </bits>
      </reg>
      <reg name="port_int_r_clr" protect="rw">
        <comment>Interrupt write-clear reg Interrupt write-clear reg</comment>
        <bits access="rc" name="port_0_r_clr" pos="0" rst="0x0">
          <comment>Port 0 read address miss int write-clear</comment>
        </bits>
      </reg>
      <reg name="port_int_r_raw" protect="rw">
        <comment>Original interrupt reg Original interrupt reg</comment>
        <bits access="r" name="port_0_r_raw" pos="0" rst="0x0">
          <comment>Port 0 read address miss original int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <reg name="port_int_r_fin" protect="rw">
        <comment>Final interrupt reg Final interrupt reg</comment>
        <bits access="r" name="port_0_r_fin" pos="0" rst="0x0">
          <comment>Port 0 read address miss final int
1: Address Miss
0: Normal</comment>
        </bits>
      </reg>
      <hole size="3840"/>
      <reg name="port_0_w_debug_addr" protect="rw">
        <comment>Debug address register for port 0 write channel Debug address register for port 0 write channel</comment>
        <bits access="r" name="w_addr_0" pos="6:0" rst="0x0">
          <comment>Port 0 write channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_w_debug_id" protect="rw">
        <comment>Debug id register for port 0 write channel Debug id register for port 0 write channel</comment>
        <bits access="r" name="w_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 write channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_addr" protect="rw">
        <comment>Debug address register for port 0 read channel Debug address register for port 0 read channel</comment>
        <bits access="r" name="r_addr_0" pos="6:0" rst="0x0">
          <comment>Port 0 read channel address, 1K-Byte</comment>
        </bits>
      </reg>
      <reg name="port_0_r_debug_id" protect="rw">
        <comment>Debug id register for port 0 read channel Debug id register for port 0 read channel</comment>
        <bits access="r" name="r_id_0" pos="7:0" rst="0x0">
          <comment>Port 0 read channel id, MSB is prot[1]</comment>
        </bits>
      </reg>
      <hole size="8064"/>
      <reg name="seg_default_first_addr" protect="rw">
        <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte) Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment default first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_last_addr" protect="rw">
        <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte) Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment default last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_default_mst_r_id0" protect="rw">
        <comment>Default Segment Read Master ID select 0~31 Default Segment Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_r_id1" protect="rw">
        <comment>Default Segment Read Master ID select 32~63 Default Segment Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_r_id2" protect="rw">
        <comment>Default Segment Read Master ID select 64~95 Default Segment Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_r_id3" protect="rw">
        <comment>Default Segment Read Master ID select 96~127 Default Segment Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_r_id4" protect="rw">
        <comment>Default Segment Read Master ID select 128~159 Default Segment Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_r_id5" protect="rw">
        <comment>Default Segment Read Master ID select 160~191 Default Segment Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_r_id6" protect="rw">
        <comment>Default Segment Read Master ID select 192~223 Default Segment Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_r_id7" protect="rw">
        <comment>Default Segment Read Master ID select 224~255 Default Segment Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_default_mst_w_id0" protect="rw">
        <comment>Default Segment write Master ID select 0~31 Default Segment write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_default_mst_w_id1" protect="rw">
        <comment>Default Segment write Master ID select 32~63 Default Segment write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_default_mst_w_id2" protect="rw">
        <comment>Default Segment write Master ID select 64~95 Default Segment write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_default_mst_w_id3" protect="rw">
        <comment>Default Segment write Master ID select 96~127 Default Segment write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_default_mst_w_id4" protect="rw">
        <comment>Default Segment write Master ID select 128~159 Default Segment write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_default_mst_w_id5" protect="rw">
        <comment>Default Segment write Master ID select 160~191 Default Segment write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_default_mst_w_id6" protect="rw">
        <comment>Default Segment write Master ID select 192~223 Default Segment write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_default_mst_w_id7" protect="rw">
        <comment>Default Segment write Master ID select 224~255 Default Segment write Master ID select 224~255</comment>
      </reg>
      <hole size="15808"/>
      <reg name="seg_0_first_addr" protect="rw">
        <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte) Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_last_addr" protect="rw">
        <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte) Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_0_mst_r_id0" protect="rw">
        <comment>Segment 0 Read Master ID select 0~31 Segment 0 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_r_id1" protect="rw">
        <comment>Segment 0 Read Master ID select 32~63 Segment 0 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_r_id2" protect="rw">
        <comment>Segment 0 Read Master ID select 64~95 Segment 0 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_r_id3" protect="rw">
        <comment>Segment 0 Read Master ID select 96~127 Segment 0 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_r_id4" protect="rw">
        <comment>Segment 0 Read Master ID select 128~159 Segment 0 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_r_id5" protect="rw">
        <comment>Segment 0 Read Master ID select 160~191 Segment 0 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_r_id6" protect="rw">
        <comment>Segment 0 Read Master ID select 192~223 Segment 0 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_r_id7" protect="rw">
        <comment>Segment 0 Read Master ID select 224~255 Segment 0 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_0_mst_w_id0" protect="rw">
        <comment>Segment 0 Write Master ID select 0~31 Segment 0 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_0_mst_w_id1" protect="rw">
        <comment>Segment 0 Write Master ID select 32~63 Segment 0 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_0_mst_w_id2" protect="rw">
        <comment>Segment 0 Write Master ID select 64~95 Segment 0 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_0_mst_w_id3" protect="rw">
        <comment>Segment 0 Write Master ID select 96~127 Segment 0 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_0_mst_w_id4" protect="rw">
        <comment>Segment 0 Write Master ID select 128~159 Segment 0 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_0_mst_w_id5" protect="rw">
        <comment>Segment 0 Write Master ID select 160~191 Segment 0 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_0_mst_w_id6" protect="rw">
        <comment>Segment 0 Write Master ID select 192~223 Segment 0 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_0_mst_w_id7" protect="rw">
        <comment>Segment 0 Write Master ID select 224~255 Segment 0 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_1_first_addr" protect="rw">
        <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte) Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_last_addr" protect="rw">
        <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte) Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_1_mst_r_id0" protect="rw">
        <comment>Segment 1 Read Master ID select 0~31 Segment 1 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_r_id1" protect="rw">
        <comment>Segment 1 Read Master ID select 32~63 Segment 1 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_r_id2" protect="rw">
        <comment>Segment 1 Read Master ID select 64~95 Segment 1 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_r_id3" protect="rw">
        <comment>Segment 1 Read Master ID select 96~127 Segment 1 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_r_id4" protect="rw">
        <comment>Segment 1 Read Master ID select 128~159 Segment 1 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_r_id5" protect="rw">
        <comment>Segment 1 Read Master ID select 160~191 Segment 1 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_r_id6" protect="rw">
        <comment>Segment 1 Read Master ID select 192~223 Segment 1 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_r_id7" protect="rw">
        <comment>Segment 1 Read Master ID select 224~255 Segment 1 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_1_mst_w_id0" protect="rw">
        <comment>Segment 1 Write Master ID select 0~31 Segment 1 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_1_mst_w_id1" protect="rw">
        <comment>Segment 1 Write Master ID select 32~63 Segment 1 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_1_mst_w_id2" protect="rw">
        <comment>Segment 1 Write Master ID select 64~95 Segment 1 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_1_mst_w_id3" protect="rw">
        <comment>Segment 1 Write Master ID select 96~127 Segment 1 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_1_mst_w_id4" protect="rw">
        <comment>Segment 1 Write Master ID select 128~159 Segment 1 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_1_mst_w_id5" protect="rw">
        <comment>Segment 1 Write Master ID select 160~191 Segment 1 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_1_mst_w_id6" protect="rw">
        <comment>Segment 1 Write Master ID select 192~223 Segment 1 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_1_mst_w_id7" protect="rw">
        <comment>Segment 1 Write Master ID select 224~255 Segment 1 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_2_first_addr" protect="rw">
        <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte) Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_last_addr" protect="rw">
        <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte) Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_2_mst_r_id0" protect="rw">
        <comment>Segment 2 Read Master ID select 0~31 Segment 2 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_r_id1" protect="rw">
        <comment>Segment 2 Read Master ID select 32~63 Segment 2 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_r_id2" protect="rw">
        <comment>Segment 2 Read Master ID select 64~95 Segment 2 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_r_id3" protect="rw">
        <comment>Segment 2 Read Master ID select 96~127 Segment 2 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_r_id4" protect="rw">
        <comment>Segment 2 Read Master ID select 128~159 Segment 2 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_r_id5" protect="rw">
        <comment>Segment 2 Read Master ID select 160~191 Segment 2 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_r_id6" protect="rw">
        <comment>Segment 2 Read Master ID select 192~223 Segment 2 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_r_id7" protect="rw">
        <comment>Segment 2 Read Master ID select 224~255 Segment 2 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_2_mst_w_id0" protect="rw">
        <comment>Segment 2 Write Master ID select 0~31 Segment 2 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_2_mst_w_id1" protect="rw">
        <comment>Segment 2 Write Master ID select 32~63 Segment 2 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_2_mst_w_id2" protect="rw">
        <comment>Segment 2 Write Master ID select 64~95 Segment 2 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_2_mst_w_id3" protect="rw">
        <comment>Segment 2 Write Master ID select 96~127 Segment 2 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_2_mst_w_id4" protect="rw">
        <comment>Segment 2 Write Master ID select 128~159 Segment 2 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_2_mst_w_id5" protect="rw">
        <comment>Segment 2 Write Master ID select 160~191 Segment 2 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_2_mst_w_id6" protect="rw">
        <comment>Segment 2 Write Master ID select 192~223 Segment 2 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_2_mst_w_id7" protect="rw">
        <comment>Segment 2 Write Master ID select 224~255 Segment 2 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_3_first_addr" protect="rw">
        <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte) Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_last_addr" protect="rw">
        <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte) Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_3_mst_r_id0" protect="rw">
        <comment>Segment 3 Read Master ID select 0~31 Segment 3 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_r_id1" protect="rw">
        <comment>Segment 3 Read Master ID select 32~63 Segment 3 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_r_id2" protect="rw">
        <comment>Segment 3 Read Master ID select 64~95 Segment 3 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_r_id3" protect="rw">
        <comment>Segment 3 Read Master ID select 96~127 Segment 3 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_r_id4" protect="rw">
        <comment>Segment 3 Read Master ID select 128~159 Segment 3 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_r_id5" protect="rw">
        <comment>Segment 3 Read Master ID select 160~191 Segment 3 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_r_id6" protect="rw">
        <comment>Segment 3 Read Master ID select 192~223 Segment 3 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_r_id7" protect="rw">
        <comment>Segment 3 Read Master ID select 224~255 Segment 3 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_3_mst_w_id0" protect="rw">
        <comment>Segment 3 Write Master ID select 0~31 Segment 3 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_3_mst_w_id1" protect="rw">
        <comment>Segment 3 Write Master ID select 32~63 Segment 3 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_3_mst_w_id2" protect="rw">
        <comment>Segment 3 Write Master ID select 64~95 Segment 3 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_3_mst_w_id3" protect="rw">
        <comment>Segment 3 Write Master ID select 96~127 Segment 3 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_3_mst_w_id4" protect="rw">
        <comment>Segment 3 Write Master ID select 128~159 Segment 3 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_3_mst_w_id5" protect="rw">
        <comment>Segment 3 Write Master ID select 160~191 Segment 3 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_3_mst_w_id6" protect="rw">
        <comment>Segment 3 Write Master ID select 192~223 Segment 3 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_3_mst_w_id7" protect="rw">
        <comment>Segment 3 Write Master ID select 224~255 Segment 3 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_4_first_addr" protect="rw">
        <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte) Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 4 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_last_addr" protect="rw">
        <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte) Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 4 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_4_mst_r_id0" protect="rw">
        <comment>Segment 4 Read Master ID select 0~31 Segment 4 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_r_id1" protect="rw">
        <comment>Segment 4 Read Master ID select 32~63 Segment 4 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_r_id2" protect="rw">
        <comment>Segment 4 Read Master ID select 64~95 Segment 4 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_r_id3" protect="rw">
        <comment>Segment 4 Read Master ID select 96~127 Segment 4 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_r_id4" protect="rw">
        <comment>Segment 4 Read Master ID select 128~159 Segment 4 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_r_id5" protect="rw">
        <comment>Segment 4 Read Master ID select 160~191 Segment 4 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_r_id6" protect="rw">
        <comment>Segment 4 Read Master ID select 192~223 Segment 4 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_r_id7" protect="rw">
        <comment>Segment 4 Read Master ID select 224~255 Segment 4 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_4_mst_w_id0" protect="rw">
        <comment>Segment 4 Write Master ID select 0~31 Segment 4 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_4_mst_w_id1" protect="rw">
        <comment>Segment 4 Write Master ID select 32~63 Segment 4 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_4_mst_w_id2" protect="rw">
        <comment>Segment 4 Write Master ID select 64~95 Segment 4 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_4_mst_w_id3" protect="rw">
        <comment>Segment 4 Write Master ID select 96~127 Segment 4 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_4_mst_w_id4" protect="rw">
        <comment>Segment 4 Write Master ID select 128~159 Segment 4 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_4_mst_w_id5" protect="rw">
        <comment>Segment 4 Write Master ID select 160~191 Segment 4 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_4_mst_w_id6" protect="rw">
        <comment>Segment 4 Write Master ID select 192~223 Segment 4 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_4_mst_w_id7" protect="rw">
        <comment>Segment 4 Write Master ID select 224~255 Segment 4 Write Master ID select 224~255</comment>
      </reg>
      <hole size="448"/>
      <reg name="seg_5_first_addr" protect="rw">
        <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte) Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="first_addr" pos="6:0" rst="0x7f">
          <comment>Segment 5 first address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_last_addr" protect="rw">
        <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte) Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        <bits access="rw" name="last_addr" pos="6:0" rst="0x0">
          <comment>Segment 5 last address, the actual address should right shift 10-bit (1K-Byte)</comment>
        </bits>
      </reg>
      <reg name="seg_5_mst_r_id0" protect="rw">
        <comment>Segment 5 Read Master ID select 0~31 Segment 5 Read Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_r_id1" protect="rw">
        <comment>Segment 5 Read Master ID select 32~63 Segment 5 Read Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_r_id2" protect="rw">
        <comment>Segment 5 Read Master ID select 64~95 Segment 5 Read Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_r_id3" protect="rw">
        <comment>Segment 5 Read Master ID select 96~127 Segment 5 Read Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_r_id4" protect="rw">
        <comment>Segment 5 Read Master ID select 128~159 Segment 5 Read Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_r_id5" protect="rw">
        <comment>Segment 5 Read Master ID select 160~191 Segment 5 Read Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_r_id6" protect="rw">
        <comment>Segment 5 Read Master ID select 192~223 Segment 5 Read Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_r_id7" protect="rw">
        <comment>Segment 5 Read Master ID select 224~255 Segment 5 Read Master ID select 224~255</comment>
      </reg>
      <reg name="seg_5_mst_w_id0" protect="rw">
        <comment>Segment 5 Write Master ID select 0~31 Segment 5 Write Master ID select 0~31</comment>
      </reg>
      <reg name="seg_5_mst_w_id1" protect="rw">
        <comment>Segment 5 Write Master ID select 32~63 Segment 5 Write Master ID select 32~63</comment>
      </reg>
      <reg name="seg_5_mst_w_id2" protect="rw">
        <comment>Segment 5 Write Master ID select 64~95 Segment 5 Write Master ID select 64~95</comment>
      </reg>
      <reg name="seg_5_mst_w_id3" protect="rw">
        <comment>Segment 5 Write Master ID select 96~127 Segment 5 Write Master ID select 96~127</comment>
      </reg>
      <reg name="seg_5_mst_w_id4" protect="rw">
        <comment>Segment 5 Write Master ID select 128~159 Segment 5 Write Master ID select 128~159</comment>
      </reg>
      <reg name="seg_5_mst_w_id5" protect="rw">
        <comment>Segment 5 Write Master ID select 160~191 Segment 5 Write Master ID select 160~191</comment>
      </reg>
      <reg name="seg_5_mst_w_id6" protect="rw">
        <comment>Segment 5 Write Master ID select 192~223 Segment 5 Write Master ID select 192~223</comment>
      </reg>
      <reg name="seg_5_mst_w_id7" protect="rw">
        <comment>Segment 5 Write Master ID select 224~255 Segment 5 Write Master ID select 224~255</comment>
      </reg>
    </module>
    <instance address="0x51312000" name="MEM_FW_AON_IMEM" type="MEM_FW_AON_IMEM"/>
  </archive>
  <archive relative="mst_ctrl_ap.xml">
    <module category="System" name="MST_CTRL_AP">
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="emmc_rd_sec" pos="4:3" rst="0x0">
          <comment>control master emmc_rd_sec rd security operation:
00: Non security operation.
01/10: assign to master arprot[1]
11:Security operation</comment>
        </bits>
        <bits access="rw" name="lzma_rd_sec" pos="2" rst="0x0">
          <comment>control master lzma_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="gouda_rd_sec" pos="1" rst="0x0">
          <comment>control master gouda_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="usb_rd_sec" pos="0" rst="0x0">
          <comment>control master usb_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="emmc_wr_sec" pos="4:3" rst="0x0">
          <comment>control master emmc_wr_sec wr security operation:
00: Non security operation.
01/10: assign to master arprot[1]
11:Security operation</comment>
        </bits>
        <bits access="rw" name="lzma_wr_sec" pos="2" rst="0x0">
          <comment>control master lzma_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="gouda_wr_sec" pos="1" rst="0x0">
          <comment>control master gouda_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="usb_wr_sec" pos="0" rst="0x0">
          <comment>control master usb_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51320000" name="MST_CTRL_AP" type="MST_CTRL_AP"/>
  </archive>
  <archive relative="mst_ctrl_aon_pub.xml">
    <module category="System" name="MST_CTRL_AON_PUB">
      <reg name="rd_sec_0" protect="rw">
        <comment>rd 0 sec control rd 0 sec control</comment>
        <bits access="rw" name="cp_sys_aon_rd_sec" pos="5" rst="0x0">
          <comment>control master cp_sys_aon_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="rf_sys_aon_rd_sec" pos="4" rst="0x0">
          <comment>control master rf_sys_aon_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="dap_aon_rd_sec" pos="3" rst="0x0">
          <comment>control master dap_aon_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="fdma_aon_rd_sec" pos="2" rst="0x1">
          <comment>control master fdma_aon_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="cp_sys_pub_rd_sec" pos="1" rst="0x0">
          <comment>control master cp_sys_pub_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="gnss_sys_pub_rd_sec" pos="0" rst="0x0">
          <comment>control master gnss_sys_pub_rd_sec rd security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
      </reg>
      <reg name="wr_sec_0" protect="rw">
        <comment>wr 0 sec control wr 0 sec control</comment>
        <bits access="rw" name="cp_sys_aon_wr_sec" pos="5" rst="0x0">
          <comment>control master cp_sys_aon_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="rf_sys_aon_wr_sec" pos="4" rst="0x0">
          <comment>control master rf_sys_aon_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="dap_aon_wr_sec" pos="3" rst="0x0">
          <comment>control master dap_aon_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="fdma_aon_wr_sec" pos="2" rst="0x1">
          <comment>control master fdma_aon_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="cp_sys_pub_wr_sec" pos="1" rst="0x0">
          <comment>control master cp_sys_pub_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
        <bits access="rw" name="gnss_sys_pub_wr_sec" pos="0" rst="0x0">
          <comment>control master gnss_sys_pub_wr_sec wr security operation:
0: Non security operation.
1: Security operation.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51310000" name="MST_CTRL_AON_PUB" type="MST_CTRL_AON_PUB"/>
  </archive>
  <archive relative="usbc.xml">
    <module category="System" name="USBC">
      <reg name="otg_pai" protect="rw">
        <comment>OTG function address/Powe/TX interrupt register</comment>
        <bits access="r" name="ep" pos="31:16" rst="0x0">
          <comment>EP x TX Interrupt. Signals that the Transmit interrupt has been received from this endpoint</comment>
        </bits>
        <bits access="rw" name="sfcn" pos="14" rst="0x0">
          <comment>Soft Connect. If Soft Connect/Disconnect feature is enabled, then the USB D+/D- lines are enabled when this bit is set by the CPU and tri-stated when this bit is cleared by the CPU. Note: Only valid in Peripheral Mode</comment>
        </bits>
        <bits access="rw" name="hsen" pos="13" rst="0x0">
          <comment>HS Enable. When set by the CPU, the core will negotiate for High-speed mode when the device is reset by the hub. If not set, the device will only operate in Full-speed mode.</comment>
        </bits>
        <bits access="r" name="hsmd" pos="12" rst="0x0">
          <comment>HS Mode. When set, this read-only bit indicates High-speed mode successfully negotiated during USB reset. In Peripheral Mode, becomes valid when USB reset completes (as indicated by USB reset interrupt). In Host Mode, becomes valid when Reset bit is cleared. Remains valid for the duration of the session.</comment>
        </bits>
        <bits access="r" name="rst" pos="11" rst="0x0">
          <comment>Reset. This bit is set when Reset signaling is present on the bus. Note: This bit is Read/Write from the CPU in Host Mode but Read-Only in Peripheral Mode.</comment>
        </bits>
        <bits access="rw" name="rsm" pos="10" rst="0x0">
          <comment>Resume. Set by the CPU to generate Resume signaling when the function is in Suspend mode. The CPU should clear this bit after 10 ms (a maximum of 15 ms) to end Resume signaling. In Host mode, this bit is also automatically set when Resume signaling from the target is detected while the core is suspended.</comment>
        </bits>
        <bits access="r" name="susp" pos="9" rst="0x0">
          <comment>Suspend Mode. In Host mode, this bit is set by the CPU to enter Suspend mode. In Peripheral mode, this bit is set on entry into Suspend mode. It is cleared when the CPU reads the interrupt register, or sets the Resume bit above.</comment>
        </bits>
        <bits access="rw" name="suspm" pos="8" rst="0x1">
          <comment>Enable Suspend M. Set by the CPU to enable the SUSPENDM output</comment>
        </bits>
        <bits access="rw" name="func_addr" pos="6:0" rst="0x0">
          <comment>Function address</comment>
        </bits>
      </reg>
      <reg name="otg_intrx_inttxen" protect="rw">
        <comment>OTG RX interrupt register/TX interrupt enable register</comment>
        <bits access="r" name="tx_ep" pos="31:16" rst="0xffff">
          <comment>EP x TX Interrupt Mask</comment>
        </bits>
        <bits access="r" name="rx_ep" pos="15:1" rst="0x0">
          <comment>EP x RX Interrupt (x=0 to15)Signals that the Receive interrupt has been received from this endpoint.
0: Masks the Transmit interrupt from the endpoint x
1: The interrupt is allowed</comment>
        </bits>
      </reg>
      <reg name="otg_intrxen_usb" protect="rw">
        <comment>OTG RX interrupt enable/Common USB interrupt register</comment>
        <bits access="rw" name="vben" pos="31" rst="0x0">
          <comment>VBUS Error Enable.Enables the VBUS interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="sreqen" pos="30" rst="0x0">
          <comment>Session Request Enable.Enables the SREQ interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="dscen" pos="29" rst="0x0">
          <comment>Disconnect Enable.Enables the DISCON interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="conen" pos="28" rst="0x0">
          <comment>Connect Enable.Enables the CONN interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="sofen" pos="27" rst="0x1">
          <comment>Start of Frame Enable.Enables the SOF interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="rsten" pos="26" rst="0x0">
          <comment>Reset/Babble Enable.Enables the RST interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="resen" pos="25" rst="0x1">
          <comment>Resume Enable.Enables the RES interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="rw" name="sspen" pos="24" rst="0x1">
          <comment>Suspend Enable.Enables the SUSP interrupt bit in OTG_INTUSB</comment>
        </bits>
        <bits access="r" name="vbe" pos="23" rst="0x0">
          <comment>VBUS Error. Set when VBus drops below the VBus Valid threshold during a session. Note: Only valid in Peripheral mode.</comment>
        </bits>
        <bits access="r" name="sreq" pos="22" rst="0x0">
          <comment>Session Request. Set when Session Request signaling has been detected. Note: Only valid when the core is A-device.</comment>
        </bits>
        <bits access="r" name="discon" pos="21" rst="0x0">
          <comment>Disconnect.HOST: Set when a device disconnect is detected (HOSTDISCON going high). PERIPHERAL: Set when a session ends.</comment>
        </bits>
        <bits access="r" name="conn" pos="20" rst="0x0">
          <comment>Connect. Set when a device connection is detected (HOSTDISCON signal going low). Note: Only valid in Host mode.</comment>
        </bits>
        <bits access="r" name="sof" pos="19" rst="0x0">
          <comment>Start of Frame.Set when a new frame starts.</comment>
        </bits>
        <bits access="r" name="rst" pos="18" rst="0x0">
          <comment>Reset/Babble
PERIPHERAL: Set when Reset signaling is detected on the USB. HOST: Set when babble condition is detected.</comment>
        </bits>
        <bits access="r" name="res" pos="17" rst="0x0">
          <comment>Resume. Set when Resume signaling is detected on the bus while the core is in Suspend mode.</comment>
        </bits>
        <bits access="r" name="susp" pos="16" rst="0x0">
          <comment>Suspend. Set when Suspend signaling is detected on the bus. Note: Only valid in Peripheral mode.</comment>
        </bits>
        <bits access="r" name="rx_ep" pos="15:1" rst="0x7fff">
          <comment>EP x RX Interrupt Mask (x = 1 to 15)
0: Masks the Receive interrupt from the endpoint x
1: Allows the interrupt</comment>
        </bits>
      </reg>
      <reg name="otg_fit" protect="rw">
        <comment>OTG frame number/INDEX/Test Mode register</comment>
        <bits access="rw" name="frh" pos="31" rst="0x0">
          <comment>Force Host.he Application Software sets this bit to instruct the core to enter Host mode when the Session bit is set, regardless of whether it is connected to any peripheral. The state of the CID input, Host Disconnect and Line State signals are ignored. The core will then remain in Host mode until the Session bit is cleared, even if a device is disconnected, and if the Force_Host bit remains set, will re-enter Host mode the next time the Session bit is set. While in this mode, the status of the HOSTDISCON signal from the PHY may be read from bit 7 of the DevCtl register.The operating speed is determined from the FHS and FFS bits as follows:
00 : Low speed
01 : Full speed
10: High speed
11: undefined</comment>
        </bits>
        <bits access="rw" name="fifoa" pos="30" rst="0x0">
          <comment>FIFO Aceess.The CPU sets this bit to transfer the packet in the Endpoint 0 TX FIFO to the Endpoint 0 RX FIFO. The bit is cleared automatically.</comment>
        </bits>
        <bits access="rw" name="ffs" pos="29" rst="0x0">
          <comment>Force full-speed.This bit forces the core into full-speed mode when it receives a USB reset.</comment>
        </bits>
        <bits access="rw" name="fhs" pos="28" rst="0x0">
          <comment>Force high-speed.This bit forces the core into high-speed mode when it receives a USB reset.</comment>
        </bits>
        <bits access="rw" name="tstpkt" pos="27" rst="0x0">
          <comment>Test Packet.The CPU sets this bit to enter the Test_Packet test mode. In this mode, the MUSBMHDRC repetitively transmits on the bus a 53-byte test packet, the form of which is defined in the Universal Serial Bus Specification Revision 2.0, Section 7.1.20. The test packet has a fixed format and must be loaded into the Endpoint 0 FIFO before the test mode is entered.
Note: Only valid in high-speed mode</comment>
        </bits>
        <bits access="rw" name="tstk" pos="26" rst="0x0">
          <comment>Test K-state.The CPU sets this bit to enter the Test_K test mode. In this mode, the MUSBMHDRC transmits a continuous K on the bus.
Note: Only valid in high-speed mode</comment>
        </bits>
        <bits access="rw" name="tstj" pos="25" rst="0x0">
          <comment>Test J-state.The CPU sets this bit to enter the Test_J test mode. In this mode, the MUSBMHDRC transmits a continuous J on the bus.
Note: Only valid in high-speed mode.</comment>
        </bits>
        <bits access="rw" name="tstnak" pos="24" rst="0x0">
          <comment>Test SE0/NAK.The CPU sets this bit to enter the Test_SE0_NAK test mode. In this mode, the MUSBMHDRC remains in High-speed mode but responds to any valid IN token with a NAK.
Note: Only valid in high-speed mode.</comment>
        </bits>
        <bits access="rw" name="epno" pos="19:16" rst="0x0">
          <comment>Endpoint Number.This field programs the current active endpoint</comment>
        </bits>
        <bits access="r" name="fmno" pos="10:0" rst="0x0">
          <comment>Current frame number.Shows the current frame number</comment>
        </bits>
      </reg>
      <reg name="otg_csr0" protect="rw">
        <comment>EP0 control and status register</comment>
        <bits access="rw" name="disp" pos="27" rst="0x0">
          <comment>Host:Dis Ping, The CPU writes a 1 to this bit to instruct the core not to issue PING tokens in data and status phases of a high-speed Control transfer (for use with devices that do not respond to PING)..
Device:Reserved</comment>
        </bits>
        <bits access="rw" name="dtwe" pos="26" rst="0x0">
          <comment>Host:Data Toggle Write Enable, The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see Data Toggle bit, below). This bit is automatically cleared once the new value is written.
Device:Reserved</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Host:Data toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If D10 is high, this bit  may be written with the required setting of the data toggle. If D10 is low, any value written to this bit is ignored.
Device:Reserved</comment>
        </bits>
        <bits access="rw" name="ff" pos="24" rst="0x0">
          <comment>Host:Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared. Note:  FlushFIFO has no effect unless TxPktRdy or RxPktRdy is set.
Device:Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared. Note:  FlushFIFO has no effect unless TxPktRdy or RxPktRdy is set.</comment>
        </bits>
        <bits access="rw" name="nakto" pos="23" rst="0x0">
          <comment>Host:NAK Timeout This bit will be set when Endpoint 0 is halted following the receipt of NAK responses for longer than the time set by the NAKLimit0 register. The CPU should clear this bit to allow the endpoint to continue.
Device:Serviced RX Packet Ready. The software sets this bit in order to clear the Rx Packet Ready (RRDY) bit. Writing zero has no effect.
Device:Serviced Setup End. The software sets this bit in order to clear the Setup End (STE) bit. Writing zero has no effect.</comment>
        </bits>
        <bits access="rw" name="stp" pos="22" rst="0x0">
          <comment>Host:StatusPkt The CPU sets this bit at the same time as the TxPktRdy or ReqPkt bit is set, to perform a status stage transaction. Setting this bit ensures that the data toggle is set to 1 so that a DATA1 packet is used for the Status Stage transaction.
Device:Send Stall. The software sets this bit to terminate the current transaction. The STALL handshake will be transmitted and after that this bit is cleared automatically.</comment>
        </bits>
        <bits access="rw" name="rep" pos="21" rst="0x0">
          <comment>Host:ReqPkt. The CPU sets this bit to request an IN transaction. It is cleared when RxPktRdy is set.
Device:Setup End. This bit will be set when a control transaction ends before the Data End (DE) bit has been set. An interrupt will be generated and the FIFO flushed at this time. The bit is cleared by the software setting the Serviced Setup End (SSE) bit.</comment>
        </bits>
        <bits access="rw" name="err" pos="20" rst="0x0">
          <comment>Host:Error. This bit will be set when three attempts have been made to perform a transaction with no response from the peripheral. The CPU should clear this bit. An interrupt is generated when this bit is set.
Device:Data End. The software sets this bit when:
 Setting TRDY for the last data packet.
 Clearing RRDY after unloading the last data packet.
 Setting TRDY for a zero length data packet. This bit is cleared automatically. Writing zero has no effect.</comment>
        </bits>
        <bits access="rw" name="sp" pos="19" rst="0x0">
          <comment>Host:SetupPkt The CPU sets this bit, at the same time as the TxPktRdy bit is set, to send a SETUP token instead of an OUT token for the transaction. Note: Setting this bit also clears the Data Toggle.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The software should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rsta" pos="18" rst="0x0">
          <comment>Host:TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.
Device:TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="17" rst="0x0">
          <comment>Host:TxPktRdy The CPU sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is also generated at this point (if enabled).
Device:TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>Host:RxPktRdy This bit is set when a data packet has been received. An interrupt is generated (if enabled) when this bit is set. The CPU should clear this bit when the packet has been read from the FIFO.
Device:RX Packet Ready. This bit is set when the data packet is received. An interrupt is generated when RRDY is set (unless disabled). This bit can be cleared by software by setting SRDY bit.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiple</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum payload transmitted.Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="otg_rxcnt_txtype0" protect="rw">
        <comment>OTG RX bytes received/EP0 type register</comment>
        <bits access="rw" name="naklimit" pos="27:24" rst="0x0">
          <comment>Frames to NAK</comment>
        </bits>
        <bits access="r" name="speed" pos="23:22" rst="0x0">
          <comment>Operation speed
00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="r" name="rxcnt0" pos="6:0" rst="0x0">
          <comment>EP0 bytes received</comment>
        </bits>
      </reg>
      <reg name="otg_cfg" protect="rw">
        <comment>OTG core configuration register</comment>
        <bits access="r" name="mprxe" pos="31" rst="0x1">
          <comment>Bulk Pkt Amalgation.When set, the automatic amalgamation of bulk packets is selected</comment>
        </bits>
        <bits access="r" name="mptxe" pos="30" rst="0x1">
          <comment>Bulk Pkt Spliting.When set, the automatic splitting of bulk packets is selected</comment>
        </bits>
        <bits access="r" name="be" pos="29" rst="0x0">
          <comment>Big Endian.When set, it indicates Big Endian ordering is selected.</comment>
        </bits>
        <bits access="r" name="hbrxe" pos="28" rst="0x1">
          <comment>High-bandwidth ISO Support.When set to 1 indicates High-bandwidth RX ISO Endpoint Support selected.</comment>
        </bits>
        <bits access="r" name="hbtxe" pos="27" rst="0x1">
          <comment>High-bandwidth ISO Support.When set to 1 indicates High-bandwidth TX ISO Endpoint Support selected.</comment>
        </bits>
        <bits access="r" name="dynf" pos="26" rst="0x1">
          <comment>Dynamic FIFO Sizing.When set to 1 indicates Dynamic FIFO Sizing option selected.</comment>
        </bits>
        <bits access="r" name="sc" pos="25" rst="0x1">
          <comment>Soft Connect.When set to 1 indicates Soft Connect/Disconnect option selected.</comment>
        </bits>
        <bits access="r" name="udi" pos="24" rst="0x0">
          <comment>UTMI datawidth
0: 8 bits;
1: 16 bits.</comment>
        </bits>
      </reg>
      <hole size="512"/>
      <reg name="otg_devctl" protect="rw">
        <comment>OTG device control/MISC/TX FIFO size/RX FIFO size register</comment>
        <bits access="rw" name="rxdpb" pos="28" rst="0x0">
          <comment>Double Packet Buffering. Defines whether the double-packet buffering is set for a selected endpoint. When set, the double-packet buffering is turned on.</comment>
        </bits>
        <bits access="rw" name="rxsize" pos="27:24" rst="0x0">
          <comment>Endpoint RX FIFO Size. This field defines the RX FIFO size for a selected endpoint (and therefore a maximum packet size that is allowed before any splitting within the FIFO of Bulk/High- Bandwidth packets prior to transmission).RX FIFO Size (Bytes):</comment>
        </bits>
        <bits access="rw" name="txdpb" pos="20" rst="0x0">
          <comment>Double Packet Buffering. Defines whether the double-packet buffering is set for a selected endpoint. When set, the double-packet buffering is turned on.</comment>
        </bits>
        <bits access="rw" name="txsize" pos="19:16" rst="0x0">
          <comment>Endpoint TX FIFO Size. This field defines the TX FIFO size for a selected endpoint (and therefore a maximum packet size that is allowed before any splitting within the FIFO of Bulk/High- Bandwidth packets prior to transmission).TX FIFO Size (Bytes): If DPB = 1, the size of the TX FIFO will be twice the size defined in this field.</comment>
        </bits>
        <bits access="r" name="ctrlinter" pos="9" rst="0x0">
          <comment>current interrupt is none DMA related.</comment>
        </bits>
        <bits access="r" name="dmainter" pos="8" rst="0x0">
          <comment>current interrupt is  DMA related.</comment>
        </bits>
        <bits access="r" name="bdev" pos="7" rst="0x1">
          <comment>B-Device.This bit indicates whether the core is operating as the A-Device or the B-Device. Only valid while a session is in progress.
0: A-Device
1: B-Device
Note: If the core is in Force_Host mode (i.e. a session has been started with OTG_TM.Testmode.FRH = 1), this bit will indicate the state of the HOSTDISCON input signal from the transceiver.</comment>
        </bits>
        <bits access="r" name="fsdev" pos="6" rst="0x0">
          <comment>Full Speed.Full Speed. This bit is set when a full-speed or high-speed device has been detected being connected to the port. (High-speed devices are distinguished from full-speed by checking for high-speed chirps when the device is reset.) Only valid in Host mode.</comment>
        </bits>
        <bits access="r" name="lsdev" pos="5" rst="0x0">
          <comment>Low Speed.Low Speed. This bit is set when a low-speed device has been detected being connected to the port. Only valid in Host mode.</comment>
        </bits>
        <bits access="r" name="vbus" pos="4:3" rst="0x0">
          <comment>VBUS.These bits encode the current VBUS level as follows: 00: Below SessionEnd</comment>
        </bits>
        <bits access="r" name="host" pos="2" rst="0x0">
          <comment>Host Mode.This Read-only bit is set when the core is acting as a Host.</comment>
        </bits>
        <bits access="rw" name="hreq" pos="1" rst="0x0">
          <comment>Host Request.Host Request. When set, the core will initiate the Host Negotiation when Suspend mode is entered. It is cleared when Host Negotiation is completed.</comment>
        </bits>
        <bits access="rw" name="sess" pos="0" rst="0x0">
          <comment>Session.When operating as an A-Device, this bit is set or cleared by the software to start or end a session.When operating as a B-Device, this bit is set/cleared by the core when a session starts/ends. It may also be set by the software to initiate the SRP. When the core is in Suspend mode, the bit may be cleared by the software to perform a software disconnect.</comment>
        </bits>
      </reg>
      <reg name="otg_fa" protect="rw">
        <comment>OTG TX/RX FIFO address register</comment>
        <bits access="rw" name="rxad" pos="28:16" rst="0x0">
          <comment>FIFO Start Address. This field defines the start address of the endpoint FIFO in units of 8 bytes as follows.
13h000 0000
13h001 0008
13h002 0010
 
13h1FFF FFF8</comment>
        </bits>
        <bits access="rw" name="txad" pos="12:0" rst="0x0">
          <comment>FIFO Start Address. This field defines the start address of the endpoint FIFO in units of 8 bytes as follows.
13h000 0000
13h001 0008
13h002 0010
 
13h1FFF FFF8</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="otg_hwver" protect="rw">
        <comment>OTG hardware version number register</comment>
        <bits access="r" name="vmaj" pos="14:10" rst="0x4">
          <comment>Major Version number.Returns 6d02</comment>
        </bits>
        <bits access="r" name="vmin" pos="9:0" rst="0x0">
          <comment>Minor Version number. Returns 10d000</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="otg_info" protect="rw">
        <comment>OTG EP/RAM/link/VPLEN INFO register</comment>
        <bits access="rw" name="vplen" pos="31:24" rst="0x3c">
          <comment>VBUS Pulse Length.
Sets the duration of the VBus pulsing charge in units of 546.1 us (the default setting corresponds to 32.77ms).
Note: When working in FS Interface mode, the timer values will be different: units of 682.62 us and the default value of 40.96 ms</comment>
        </bits>
        <bits access="rw" name="wtcon" pos="23:20" rst="0x5">
          <comment>Connect/Disconnect Delay. Sets the wait to be applied to allow for the user s connect/disconnect filter in units of 533.3ns (the default setting corresponds to 2.667us). Note: When working in FS Interface mode, the timer values will be different: units of 666.63 ns and the default value of 3.33 us</comment>
        </bits>
        <bits access="rw" name="wtid" pos="19:16" rst="0xc">
          <comment>ID Pullup Delay. Sets the delay to be applied from IDPULLUP being asserted to IDDIG being considered valid in units of 4.369ms (the default setting corresponds to 52.43ms). Note: When working in FS Interface mode, the timer values will be different: units of 5.46 ms and the default value of 65.54 ms</comment>
        </bits>
        <bits access="r" name="dma_ch" pos="15:12" rst="0x0">
          <comment>number of DMA channel</comment>
        </bits>
        <bits access="r" name="ram_bits" pos="11:8" rst="0xc">
          <comment>width of RAM DATA bus</comment>
        </bits>
        <bits access="r" name="rx_ep" pos="7:4" rst="0xf">
          <comment>number of RX_EP</comment>
        </bits>
        <bits access="r" name="tx_ep" pos="3:0" rst="0xf">
          <comment>number of TX_EP</comment>
        </bits>
      </reg>
      <reg name="otg_eof" protect="rw">
        <comment>OTG HS/FS/LS time buffer register</comment>
        <bits access="rw" name="rstx" pos="25" rst="0x0">
          <comment>Reset All FFs in the XCLK clock domain. When a 1b1 is written to this bit, the XCLK clock domain reset will be asserted within a minimum delay of 7 cycles of the AHB clock. The output NRSTXO will be asynchronously asserted and synchronously de-asserted with respect to XCLK. This register is self clearing and always reads zero.</comment>
        </bits>
        <bits access="rw" name="rst" pos="24" rst="0x0">
          <comment>Reset All FFs in the AHB clock domain. When a 1b1 is written to this bit, the AHB clock domain reset will be asserted within a minimum delay of 7 cycles of the AHB clock. The output NRSTO will be asynchronously asserted and synchronously de-asserted with respect to AHB clock. This register is self clearing and always reads zero.</comment>
        </bits>
        <bits access="rw" name="ls_eof1" pos="23:16" rst="0x72">
          <comment>LS Time Buffer. Sets for Low-speed transactions the time before EOF to stop beginning new transactions, in units of 1.067 us (the default setting corresponds to 121.6 us).</comment>
        </bits>
        <bits access="rw" name="fs_eof1" pos="15:8" rst="0x77">
          <comment>FS Time Buffer. Sets for Full-speed transactions the time before EOF to stop beginning new transactions, in units of 533.3 ns (the default setting corresponds to 63.46 us).</comment>
        </bits>
        <bits access="rw" name="hs_eof1" pos="7:0" rst="0x7c">
          <comment>HS Time Buffer. Sets for High-speed transactions the time before EOF to stop beginning new transactions, in units of 133.3 ns (the default setting corresponds to 17.07 us)</comment>
        </bits>
      </reg>
      <reg name="otg_ep0_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep0_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep1_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep1_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep2_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep2_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep3_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep3_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep4_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep4_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep5_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep5_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep6_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep6_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep7_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep7_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep8_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep8_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep9_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep9_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep10_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep10_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep11_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep11_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep12_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep12_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep13_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep13_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep14_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep14_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep15_txfad_had_hp" protect="rw">
        <comment>OTG TX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="txhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="txhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="txfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <reg name="otg_ep15_rxfad_had_hp" protect="rw">
        <comment>OTG RX FUNCTION Address/HUB Address/HUB port register</comment>
        <bits access="rw" name="rxhp" pos="30:24" rst="0x0">
          <comment>HUB port number</comment>
        </bits>
        <bits access="rw" name="multiple" pos="23" rst="0x0">
          <comment>1= multiple transaction translator
0= single transaction translato</comment>
        </bits>
        <bits access="rw" name="rxhad" pos="22:16" rst="0x0">
          <comment>The address of hub</comment>
        </bits>
        <bits access="rw" name="rxfad" pos="6:0" rst="0x0">
          <comment>address of the target function</comment>
        </bits>
      </reg>
      <hole size="128"/>
      <reg name="reg_ep1_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep1_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep1_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep1_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep2_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep2_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep2_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep2_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep3_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep3_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep3_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep3_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep4_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep4_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep4_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep4_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep5_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep5_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep5_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep5_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep6_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep6_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep6_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep6_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep7_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep7_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep7_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep7_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep8_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep8_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep8_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep8_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep9_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep9_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep9_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep9_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep10_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep10_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep10_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep10_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep11_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep11_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep11_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep11_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep12_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep12_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep12_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep12_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep13_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep13_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep13_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep13_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep14_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep14_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep14_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep14_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <reg name="reg_ep15_txmaxp_csr" protect="rw">
        <comment>OTG TX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aset" pos="31" rst="0x0">
          <comment>Auto Reset.If the CPU sets this bit, TRDY will be automatically set when data of the maximum packet size (value in OTG_TXMAXP) is loaded into the TX FIFO. If a packet of less than the maximum packet size is loaded, then TRDY will have to be set manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="iso" pos="30" rst="0x0">
          <comment>Host: Reserved
Device: Isochronous Transfers. The CPU sets this bit to enable the TX endpoint for Isochronous transfers, and clears it to enable the TX endpoint for Bulk or Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="md" pos="29" rst="0x0">
          <comment>Mode.The CPU sets this bit to enable the endpoint direction as TX, and clears the bit to enable it as RX. This bit has any effect only where the same endpoint FIFO is used for both TX and RX transactions.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="28" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the TX endpoint.</comment>
        </bits>
        <bits access="rw" name="fdt" pos="27" rst="0x0">
          <comment>Force Data Toggle.The CPU sets this bit to force the endpoint data toggle to switch and the data packet to be cleared from the FIFO, regardless of whether an ACK was received. This can be used by Interrupt TX endpoints that are used to communicate rate feedback for Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="drm" pos="26" rst="0x0">
          <comment>Dma Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="25" rst="0x0">
          <comment>Host:Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the TX Endpoint data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.
Device:While D6(ISO)=1,  The TX endpoint is enabled to do ISO transfer, this bit is meaningless.
While D6(ISO)=0,
 1: CPU sets this bit to enable the TX endpoint to do INT transfer
 0: CPU sets this bit to enable the TX endpoint to do BULK transfer</comment>
        </bits>
        <bits access="rw" name="dt" pos="24" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the TX Endpoint data toggle. If DRM is high, this bit may be written with the required setting of the data toggle. If DRM is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="nak" pos="23" rst="0x0">
          <comment>Host: NAK Timeout.This bit will be set when the TX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the OTG_TXINTV register. The CPU should clear this bit to allow the endpoint to continue.
Note: Valid only for Bulk endpoints.
Device:Incomplete. When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received to send all the parts.
Note: In anything other than a high-bandwidth transfer, this bit will always return zero.</comment>
        </bits>
        <bits access="rw" name="clr" pos="22" rst="0x0">
          <comment>Clear Data Toggle. The CPU writes a 1 to this bit to reset the endpoint data toggle to 0.</comment>
        </bits>
        <bits access="rw" name="rxs" pos="21" rst="0x0">
          <comment>Host: RX Stall. This bit is set when a STALL handshake is received. The FIFO is flushed and the TRDY bit is cleared (see below). The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the TxPktRdy bit is cleared (see below). The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="stp" pos="20" rst="0x0">
          <comment>Host: Setup Packet. The CPU sets this bit, at the same time as the TRDY bit is set, to send a SETUP token instead of an OUT token for the transaction.
Note: Setting this bit also clears the Data Toggle.
Device: Send Stall. The CPU sets this bit to issue a STALL handshake to an IN token. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="19" rst="0x0">
          <comment>Flush FIFO. The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint TX FIFO. The FIFO pointer is reset and the TRDY bit (below) is cleared.</comment>
        </bits>
        <bits access="rw" name="err" pos="18" rst="0x0">
          <comment>Host: Error. The core sets this bit when 3 attempts have been made to send a packet and no handshake packet has been received. The CPU should clear this bit.
Note: An interrupt is generated when the bit is set.Valid only when the endpoint is operating in Bulk or Interrupt mode.
Device:Underrun. The core sets this bit if an IN token is received when TxPktRdy is not set. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="fne" pos="17" rst="0x0">
          <comment>FIFO Not Empty.The core sets this bit when there is at least 1 packet in the Tx FIFO.</comment>
        </bits>
        <bits access="rw" name="trdy" pos="16" rst="0x0">
          <comment>TX Packet Ready. The software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier.See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep15_rxmaxp_csr" protect="rw">
        <comment>OTG RX MAXPKTSIZE/CONTROL STATUS register</comment>
        <bits access="rw" name="aclr" pos="31" rst="0x0">
          <comment>Host: Auto clear.If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the RX FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.
Device: Auto Set. If the CPU sets this bit then the RRDY bit will be automatically cleared when a packet of (OTG_RXMAXP) bytes has been unloaded from the Rx FIFO. When packets of less than the maximum packet size are unloaded, RRDY will have to be cleared manually.
Note: This bit should not be set for high-bandwidth Isochronous endpoints.</comment>
        </bits>
        <bits access="rw" name="arq" pos="30" rst="0x0">
          <comment>Host:Auto Request.If the CPU sets this bit, the RPK bit will be automatically set when the RRDY bit is cleared.
Device:ISO. The CPU sets this bit to enable the RX endpoint for Isochronous transfers, and clears it to enable the RX endpoint for Bulk/Interrupt transfers.</comment>
        </bits>
        <bits access="rw" name="dmr" pos="29" rst="0x0">
          <comment>DMA Request Enable.The CPU sets this bit to enable the DMA request for the RX endpoint.</comment>
        </bits>
        <bits access="rw" name="dny" pos="28" rst="0x0">
          <comment>Disable NYET.The CPU sets this bit to disable the sending of NYET handshakes. When set, all successfully received RX packets are ACKd including at the point at which the FIFO becomes full.
Note: This bit only has any effect in high-speed mode, in which mode it should be set for all Interrupt endpoints.</comment>
        </bits>
        <bits access="rw" name="dmd" pos="27" rst="0x0">
          <comment>DMA Request Mode.The CPU sets this bit to select DMA Request Mode 1 and clears it to select DMA Request Mode 0.</comment>
        </bits>
        <bits access="rw" name="dwe" pos="26" rst="0x0">
          <comment>Data Toggle Write Enable.The CPU writes a 1 to this bit to enable the current state of the Endpoint 0 data toggle to be written (see DT bit, below). This bit is automatically cleared once the new value is written.</comment>
        </bits>
        <bits access="rw" name="dt" pos="25" rst="0x0">
          <comment>Data Toggle.When read, this bit indicates the current state of the Endpoint 0 data toggle. If DWE is high, this bit may be written with the required setting of the data toggle. If DWE is low, any value written to DT is ignored.</comment>
        </bits>
        <bits access="rw" name="irx" pos="24" rst="0x0">
          <comment>Incomp RX.This bit will be set in a high-bandwidth Isochronous transfer if the packet received is incomplete. It will be cleared when RRDY is cleared. In anything other than a high-bandwidth Isochronous transfer, this bit always returns 0.
Note: If USB protocols are followed correctly, this bit should never be set. The bit becoming set indicates a failure of the associated Peripheral device to behave correctly.</comment>
        </bits>
        <bits access="rw" name="clr" pos="23" rst="0x0">
          <comment>Clear Data Toggle.When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rs" pos="22" rst="0x0">
          <comment>Host:RX Stall.RX Stall. When a STALL handshake is received, this bit is set and an interrupt is generated. The CPU should clear this bit.
Device:Sent Stall. This bit is set when a STALL handshake is transmitted. The CPU should clear this bit.</comment>
        </bits>
        <bits access="rw" name="rpk" pos="21" rst="0x0">
          <comment>Host: Request Packet.Request Packet. The CPU writes a 1 to this bit to request an IN transaction. It is cleared when RRDY is set.
Device:Send Stall. The CPU writes a 1b to this bit to issue a STALL handshake. The CPU clears this bit to terminate the stall condition.
Note: This bit has no effect where the endpoint is being used for Isochronous transfers.</comment>
        </bits>
        <bits access="rw" name="ff" pos="20" rst="0x0">
          <comment>Flush FIFO.The software writes a 1b to this bit to flush the next packet to be transmitted from the endpoint RX FIFO. The FIFO pointer is reset and the RRDY bit is cleared.
Note: FF bit has no effect unless RRDY is set. Also note that, if the FIFO is double-buffered, FF may need to be set twice to completely clear the FIFO.</comment>
        </bits>
        <bits access="rw" name="der" pos="19" rst="0x0">
          <comment>Host:Data Error/NAK Timeout.When operating in ISO mode, this bit is set when RRDY is set if the data packet has a CRC or bit-stuff error and cleared when RRDY is cleared. In Bulk mode, this bit will be set when the RX endpoint is halted following the receipt of NAK responses for longer than the time set as the NAK Limit by the RxInterval register. The CPU should clear this bit to allow the endpoint to continue.
Device:Data Error. This bit is set when RRDY is set if the data packet has a CRC or bit-stuff error. It is cleared when RRDY is cleared.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="er" pos="18" rst="0x0">
          <comment>Host: Error.The USB sets this bit when 3 attempts have been made to receive a packet and no data packet has been received. The CPU should clear this bit. An interrupt is generated when the bit is set.
Note: This bit is only valid when the Tx endpoint is operating in Bulk or Interrupt mode. In ISO mode, it always returns zero.
Device:Overrun. This bit is set if an OUT packet cannot be loaded into the Rx FIFO. The CPU should clear this bit.
Note: This bit is only valid when the endpoint is operating in ISO mode. In Bulk mode, it always returns zero.</comment>
        </bits>
        <bits access="rw" name="fful" pos="17" rst="0x0">
          <comment>FIFO Full.This bit is set when no more packets can be loaded into the RX FIFO.</comment>
        </bits>
        <bits access="rw" name="rrdy" pos="16" rst="0x0">
          <comment>RX Packet Ready.RX Packet Ready. This bit is set when a data packet has been received. The CPU should clear this bit when the packet has been unloaded from the RX FIFO. An interrupt is generated when the bit is set.</comment>
        </bits>
        <bits access="rw" name="mult" pos="15:11" rst="0x0">
          <comment>Multiplier. See spec.</comment>
        </bits>
        <bits access="rw" name="maxp" pos="10:0" rst="0x0">
          <comment>Maximum Payload Transmitted. This fields defines (in bytes) the maximum payload transmitted in a single transaction. The value set can be up to 1024 bytes but is subject to the constraints placed by the USB Specification on packet sizes for Bulk, Interrupt and Isochronous transfers in full-speed and high-speed operations.</comment>
        </bits>
      </reg>
      <reg name="reg_ep15_rxcnt_txtype" protect="rw">
        <comment>OTG RX bytes received counter/transaction control/TX polling interval register</comment>
        <bits access="rw" name="txpi" pos="31:24" rst="0x0">
          <comment>TX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected TX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="23:22" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device:
 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="21:20" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint:
 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="19:16" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
        <bits access="r" name="rxcnt" pos="12:0" rst="0x0">
          <comment>Endpoint RX Count. The number of bytes received in RX FIFO.RXCNT is a 7-bit field in case of Endpoint 0.</comment>
        </bits>
      </reg>
      <reg name="reg_ep15_rxtype_intv" protect="rw">
        <comment>OTG RX transaction control/polling interval register</comment>
        <bits access="rw" name="rxpi" pos="15:8" rst="0x0">
          <comment>RX Polling Interval/NAK Limit. For Interrupt and Isochronous transfers, this field defines the polling interval for the currently-selected RX endpoint.For Bulk mode, this field sets the number of frames/microframes after which the endpoint should timeout on receiving a stream of NAK responses.</comment>
        </bits>
        <bits access="rw" name="speed" pos="7:6" rst="0x0">
          <comment>Operating Speed. Operating speed of the target device: 00: Unused
01: High
10: Full
11: Low</comment>
        </bits>
        <bits access="rw" name="prot" pos="5:4" rst="0x0">
          <comment>Protocol. This bit selects the required protocol for the TX endpoint: 00: Control
01: Isochronous
10: Bulk
11: Interrupt</comment>
        </bits>
        <bits access="rw" name="ep" pos="3:0" rst="0x0">
          <comment>Target Endpoint Number. The CPU should set this value to the endpoint number contained in the TX endpoint descriptor returned to the OTG Controller during device enumeration.</comment>
        </bits>
      </reg>
      <hole size="2048"/>
      <reg name="otg_ep0_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep1_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep2_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep3_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep4_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep5_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep6_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep7_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep8_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep9_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep10_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep11_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep12_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep13_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep14_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_ep15_rxpktcnt" protect="rw">
        <comment>OTG RX packet count register</comment>
        <bits access="rw" name="rxpkt_mode_en" pos="31" rst="0x0">
          <comment>enable the pre-define-RX-data-length</comment>
        </bits>
        <bits access="rw" name="rxpktcnt" pos="30:0" rst="0x0">
          <comment>RXPKTCNT Control.Sets the number of packets of size MaxPacketSize that are to be transferred in a block transfer. Only used in Host mode when AutoReq is set. Has no effect in Device mode or when AutoReq is not set.</comment>
        </bits>
      </reg>
      <reg name="otg_rxdbdis_txdbdis" protect="rw">
        <comment>OTG RX/TX double packet buffer disable register</comment>
        <bits access="r" name="txdb" pos="31:17" rst="0x0">
          <comment>EPx Receive Double Buffer Disable</comment>
        </bits>
        <bits access="r" name="rxdb" pos="15:1" rst="0x0">
          <comment>EPx Receive Double Buffer Disable</comment>
        </bits>
      </reg>
      <reg name="otg_uch_hsrtn" protect="rw">
        <comment>OTG chirp timeout control/high-speed resume register</comment>
        <bits access="rw" name="c_t_hsrtn" pos="31:16" rst="0x32">
          <comment>The delay from the end of High Speed resume signaling to enabling UTM normal operating mode. The default value corresponds to a delay of 3us</comment>
        </bits>
        <bits access="rw" name="c_t_uch" pos="15:0" rst="0x4074">
          <comment>Configurable Chirp Timeout timer, the default value corresponds to a delay of 1.1ms.</comment>
        </bits>
      </reg>
      <reg name="otg_hsbt_fifo" protect="rw">
        <comment>OTG HS BUS TURN around/FIFO timeout check/FIFO timeout count/external control registers</comment>
        <bits access="rw" name="tx_compl_mode" pos="30" rst="0x0">
          <comment>1= wait for tx data sent on usb bus</comment>
        </bits>
        <bits access="rw" name="clear_rxbuff_en" pos="29" rst="0x0">
          <comment>1= set flushFIFO, all rx FIFO pointers, status for MCU&amp;USB
Of each buff will be clear
0 = set  flushFIFO,rx pointers, status forr current buff of MCU side will be clear.</comment>
        </bits>
        <bits access="rw" name="clear_txbuff_en" pos="28" rst="0x0">
          <comment>1= set flushFIFO, all tx FIFO pointers, status for MCU&amp;USB
Of each buff will be clear
0 = set  flushFIFO, tx pointers, status forr current buff of MCU side will be clear.</comment>
        </bits>
        <bits access="rw" name="srp_en" pos="26" rst="0x0">
          <comment>1= enable OTG SRP protocol
0= disable OTG SRP protocol</comment>
        </bits>
        <bits access="rw" name="host_mode_force" pos="25" rst="0x0">
          <comment>While HOST_force_en =1
1= DEVICE mode
0 = HOST mode
(no function if HOST_force_en =0)</comment>
        </bits>
        <bits access="rw" name="host_force_en" pos="24" rst="0x0">
          <comment>Setting the mode force host or device,1=SW force enable/0= SW force disable</comment>
        </bits>
        <bits access="rw" name="fifotimeout" pos="23:16" rst="0x80">
          <comment>Setting the check number of data in FIFO</comment>
        </bits>
        <bits access="rw" name="fifocheckreg" pos="15:9" rst="0x40">
          <comment>Setting the period of check data in FIFO</comment>
        </bits>
        <bits access="rw" name="fifocheckmode_en" pos="8" rst="0x0">
          <comment>Setting the mode of fifochecck</comment>
        </bits>
        <bits access="rw" name="hsbt" pos="3:0" rst="0x0">
          <comment>adjust the setting of HS bus turn around timing out setting</comment>
        </bits>
      </reg>
      <reg name="otg_listend_int_sts" protect="rw">
        <comment>OTG TX LISTEND interrupt status/enable register</comment>
        <bits access="r" name="tx_listend_enable15" pos="31" rst="0x0">
          <comment>When 1, the TX_listend_int15  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable14" pos="30" rst="0x0">
          <comment>When 1, the TX_listend_int14  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable13" pos="29" rst="0x0">
          <comment>When 1, the TX_listend_int13  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable12" pos="28" rst="0x0">
          <comment>When 1, the TX_listend_int12  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable11" pos="27" rst="0x0">
          <comment>When 1, the TX_listend_int11  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable10" pos="26" rst="0x0">
          <comment>When 1, the TX_listend_int10  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable9" pos="25" rst="0x0">
          <comment>When 1, the TX_listend_int9  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable8" pos="24" rst="0x0">
          <comment>When 1, the TX_listend_int8  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable7" pos="23" rst="0x0">
          <comment>When 1, the TX_listend_int7  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable6" pos="22" rst="0x0">
          <comment>When 1, the TX_listend_int6  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable5" pos="21" rst="0x0">
          <comment>When 1, the TX_listend_int5  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable4" pos="20" rst="0x0">
          <comment>When 1, the TX_listend_int4  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable3" pos="19" rst="0x0">
          <comment>When 1, the TX_listend_int3  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable2" pos="18" rst="0x0">
          <comment>When 1, the TX_listend_int2  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_enable1" pos="17" rst="0x0">
          <comment>When 1, the TX_listend_int1  will function</comment>
        </bits>
        <bits access="r" name="tx_listend_int15" pos="15" rst="0x0">
          <comment>When TX EP15 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int14" pos="14" rst="0x0">
          <comment>When TX EP14 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int13" pos="13" rst="0x0">
          <comment>When TX EP13 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int12" pos="12" rst="0x0">
          <comment>When TX EP12 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int11" pos="11" rst="0x0">
          <comment>When TX EP11 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int10" pos="10" rst="0x0">
          <comment>When TX EP10 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int9" pos="9" rst="0x0">
          <comment>When TX EP9 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int8" pos="8" rst="0x0">
          <comment>When TX EP8 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int7" pos="7" rst="0x0">
          <comment>When TX EP7 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int6" pos="6" rst="0x0">
          <comment>When TX EP6 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int5" pos="5" rst="0x0">
          <comment>When TX EP5 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int4" pos="4" rst="0x0">
          <comment>When TX EP4 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int3" pos="3" rst="0x0">
          <comment>When TX EP3 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int2" pos="2" rst="0x0">
          <comment>When TX EP2 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
        <bits access="r" name="tx_listend_int1" pos="1" rst="0x0">
          <comment>When TX EP1 send the data in the list end NOD (transferred by DMA), a TX interrupt will launch, and this bit will be set to 1.</comment>
        </bits>
      </reg>
      <reg name="otg_listend_int_clr" protect="rw">
        <comment>OTG TX LISTEND interrupt clear register</comment>
        <bits access="rw" name="tx_listend_clear15" pos="15" rst="0x0">
          <comment>When 1, the TX_listend_int15  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear14" pos="14" rst="0x0">
          <comment>When 1, the TX_listend_int14  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear13" pos="13" rst="0x0">
          <comment>When 1, the TX_listend_int13  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear12" pos="12" rst="0x0">
          <comment>When 1, the TX_listend_int12  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear11" pos="11" rst="0x0">
          <comment>When 1, the TX_listend_int11  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear10" pos="10" rst="0x0">
          <comment>When 1, the TX_listend_int10  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear9" pos="9" rst="0x0">
          <comment>When 1, the TX_listend_int9  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear8" pos="8" rst="0x0">
          <comment>When 1, the TX_listend_int8  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear7" pos="7" rst="0x0">
          <comment>When 1, the TX_listend_int7  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear6" pos="6" rst="0x0">
          <comment>When 1, the TX_listend_int6  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear5" pos="5" rst="0x0">
          <comment>When 1, the TX_listend_int5  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear4" pos="4" rst="0x0">
          <comment>When 1, the TX_listend_int4  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear3" pos="3" rst="0x0">
          <comment>When 1, the TX_listend_int3  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear2" pos="2" rst="0x0">
          <comment>When 1, the TX_listend_int2  will be cleared</comment>
        </bits>
        <bits access="rw" name="tx_listend_clear1" pos="1" rst="0x0">
          <comment>When 1, the TX_listend_int1  will be cleared</comment>
        </bits>
      </reg>
      <reg name="otg_endpoint_en" protect="rw">
        <comment>OTG endpoint enable register</comment>
        <bits access="r" name="endpoint_enable15" pos="15" rst="0x1">
          <comment>When 1, the Endpoint15  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable14" pos="14" rst="0x1">
          <comment>When 1, the Endpoint14  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable13" pos="13" rst="0x1">
          <comment>When 1, the Endpoint13  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable12" pos="12" rst="0x1">
          <comment>When 1, the Endpoint12  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable11" pos="11" rst="0x1">
          <comment>When 1, the Endpoint11  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable10" pos="10" rst="0x1">
          <comment>When 1, the Endpoint10  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable9" pos="9" rst="0x1">
          <comment>When 1, the Endpoint9  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable8" pos="8" rst="0x1">
          <comment>When 1, the Endpoint8  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable7" pos="7" rst="0x1">
          <comment>When 1, the Endpoint7  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable6" pos="6" rst="0x1">
          <comment>When 1, the Endpoint6  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable5" pos="5" rst="0x1">
          <comment>When 1, the Endpoint5  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable4" pos="4" rst="0x1">
          <comment>When 1, the Endpoint4  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable3" pos="3" rst="0x1">
          <comment>When 1, the Endpoint3  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable2" pos="2" rst="0x1">
          <comment>When 1, the Endpoint2  (both TX/RX) will function</comment>
        </bits>
        <bits access="r" name="endpoint_enable1" pos="1" rst="0x1">
          <comment>When 1, the Endpoint1  (both TX/RX) will function</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x02100000" name="USBC" type="USBC"/>
  </archive>
  <archive relative="dbgio.xml">
    <module category="System" name="DBGIO">
      <reg name="dbgio_en" protect="rw">
        <comment>global enable global enable control register</comment>
        <bits access="rw" name="ch_en" pos="15:8" rst="0x0">
          <comment>This value requires one-hot or all zero.
[1:0] user channel; [2] train 1 ; [3] : train 2</comment>
        </bits>
        <bits access="rw" name="funnel_en" pos="4" rst="0x0"/>
        <bits access="rw" name="func_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="funnel_sta" protect="rw">
        <comment>Funnel overflow flag Funnel overflow flag register</comment>
        <bits access="r" name="funnel_afifo_empty" pos="5" rst="0x1">
          <comment>funnel async fifo empty status</comment>
        </bits>
        <bits access="rw" name="funnel_overflow_clear" pos="4" rst="0x0">
          <comment>funnel overflow flag clear.</comment>
        </bits>
        <bits access="r" name="funnel_afifo_full" pos="0" rst="0x0">
          <comment>funnel async fifo full flag</comment>
        </bits>
      </reg>
      <reg name="dbgio_int_en" protect="rw">
        <comment>interrupte enable</comment>
        <bits access="rw" name="funnel_ovf_int_en" pos="0" rst="0x0">
          <comment>fifo_overflow interrupt</comment>
        </bits>
      </reg>
      <reg name="dbgio_int_sta" protect="rw">
        <comment>interrupte status</comment>
        <bits access="r" name="funnel_overflow" pos="0" rst="0x0"/>
      </reg>
      <reg name="dbgio_ctrl" protect="rw">
        <comment>dbgio control</comment>
        <bits access="rw" name="sw_rst" pos="8" rst="0x0">
          <comment>Software reset.
0: work
1: reset</comment>
        </bits>
        <bits access="rw" name="clk_src_sel" pos="4" rst="0x0">
          <comment>Dbgio source clock select
1h0: 200MHz
1b1: 140MHz</comment>
        </bits>
        <bits access="rw" name="ddr_mode_en" pos="0" rst="0x0">
          <comment>Dbgio ddr mode enable</comment>
        </bits>
      </reg>
      <reg name="fsm_cut_off_len" protect="rw">
        <comment>The max length of data package control register</comment>
        <bits access="rw" name="fsm_cut_off_len" pos="15:0" rst="0x20">
          <comment>&quot;fsm_cut_off_len +1&quot; is the max length of data package between any SYNC &amp; CRC package, keep the value equals to (33N+32) where N is integer or zero.</comment>
        </bits>
      </reg>
      <reg name="fsm_data_wait_len" protect="rw">
        <comment>The max length of data wait cycle register</comment>
        <bits access="rw" name="fsm_data_wait_len" pos="15:0" rst="0x20">
          <comment>&quot;fsm_data_wait_len +1&quot; is the max length of data wait cycle time when gearbox fifo is almost empty</comment>
        </bits>
      </reg>
      <reg name="dll_cfg" protect="rw">
        <comment>DBGIO PHY DLL CFG DBGIO PHY DLL CFG registers</comment>
        <bits access="rw" name="dll_wait_cnt" pos="31:28" rst="0x4">
          <comment>Cycles to wait DLL locked signals.</comment>
        </bits>
        <bits access="rw" name="dll_datwr_cpst_en" pos="24" rst="0x0">
          <comment>write delay cell  select
0:use user defined value from CLKDATWR_DLY_VAL
1:use dll generated value which referenced form CLKDATWR_DLY_VAL</comment>
        </bits>
        <bits access="rw" name="dll_clk_sel" pos="22" rst="0x0">
          <comment>DLL Clock source selection
0: Select 1x clock
1: Select 2x clock</comment>
        </bits>
        <bits access="rw" name="dll_en" pos="21" rst="0x0">
          <comment>DLL enable signal
0:DLL disable
1:DLL enable</comment>
        </bits>
        <bits access="rw" name="dll_clr" pos="20" rst="0x0">
          <comment>DLL clear signal
1:clear DLL</comment>
        </bits>
        <bits access="rw" name="dll_auto_clr_en" pos="19" rst="0x0">
          <comment>Dont  support in this version</comment>
        </bits>
        <bits access="rw" name="dll_cpst_en" pos="18" rst="0x0">
          <comment>DLL output delay value enable</comment>
        </bits>
        <bits access="rw" name="dll_cpst_start" pos="17" rst="0x0">
          <comment>DLL start enable signal, this bit should be write to 1b0 when it is enabled to 1b1</comment>
        </bits>
        <bits access="rw" name="dll_half_mode" pos="16" rst="0x0">
          <comment>DLL lock mode:
0: full cycle lock mode
1: half cycle lock mode</comment>
        </bits>
        <bits access="rw" name="dll_init" pos="14:8" rst="0x1">
          <comment>DLL count initial value, DLL use it as the initial value to count the delay value.</comment>
        </bits>
        <bits access="rw" name="dll_cpst_threshold" pos="7:4" rst="0x0">
          <comment>DLL  change  threshold value, DLL update rd/wr/cmd delay line value if the DLL count delta bigger then DLL_CPST_THRESHOLD</comment>
        </bits>
        <bits access="rw" name="dll_phase_interval" pos="2:1" rst="0x0">
          <comment>DLL phase interval , DLL use it as the interval of phase 1 and phase2</comment>
        </bits>
        <bits access="rw" name="clk_phase_sel" pos="0" rst="0x0">
          <comment>OUPUT clock phase select</comment>
        </bits>
      </reg>
      <reg name="dll_dly" protect="rw">
        <comment>DBGIO PHY DLL DLY  DBGIO PHY DLL DLY registers</comment>
        <bits access="rw" name="dll_clkdatwr_dly_val" pos="7:0" rst="0x0">
          <comment>Clock Data Write Line Delay Value
Based Phase is invert of PHY Clock
When DLL_DATWR_CPST_EN is enable,</comment>
        </bits>
      </reg>
      <reg name="dll_dly_offset" protect="rw">
        <comment>DBGIO PHY DLL Offset Read  DBGIO PHY DLL Offset Read registers</comment>
        <bits access="rw" name="dll_clkdatwr_dly_inv" pos="5" rst="0x0">
          <comment>Clock Data Write Line Delay Invert</comment>
        </bits>
        <bits access="rw" name="dll_clkdatwr_dly_offset" pos="4:0" rst="0x0">
          <comment>Data Write Delay offset. The highest bit indicates if it is add or sub.
OFFSET [4]=0:  CLKDATWR_DLY_VAL + OFFSET [3:0]
OFFSET [4]=1:  CLKDATWR_DLY_VAL  OFFSET [3:0].
If DLL_DATWR _CPST_EN==1, the offset is added after the proportion.
E.g. If
Clock cycle (CYC)== 5ns
CLKDATWR _DLY_ VAL (VAL) ==h40, CLKDATWR_DLY_OFFSET (OFSET) == h6,
DLL_CNT(CNT) == h20
 it means delay:
(VAL/h100)*CYC + (CYC * OFSET) / CN =
 (h40/h100)*5ns + (5ns * h6) / h20 2.2ns</comment>
        </bits>
      </reg>
      <reg name="dll_sts0" protect="rw">
        <comment>DBGIO PHY DLL STS0 registers DBGIO PHY DLL STS0 registers</comment>
        <bits access="r" name="dll_phase1" pos="20" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_phase2" pos="19" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_locked" pos="18" rst="0x0">
          <comment>If use DLL, software should wait this value to 1b1</comment>
        </bits>
        <bits access="r" name="dll_error" pos="17" rst="0x0">
          <comment>If use DLL, soft ware should wait DLL_LOCKED to 1b1 and  at that time ,this bit is 1b0</comment>
        </bits>
        <bits access="r" name="dll_cpst_st" pos="16" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_st" pos="10:8" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
        <bits access="r" name="dll_cnt" pos="6:0" rst="0x0">
          <comment>DLL delay cell counts of 1 cycle</comment>
        </bits>
      </reg>
      <reg name="dll_sts1" protect="rw">
        <comment>DBGIO PHY DLL STS1  DBGIO PHY DLL STS1 registers</comment>
        <bits access="r" name="clkdatwr_dly_cnt" pos="7:0" rst="0x0">
          <comment>Reserved  for  vender asic only</comment>
        </bits>
      </reg>
      <reg name="dll_backup" protect="rw">
        <comment>DBGIO PHY DLL BACKUP DBGIO PHY DLL BACKUP registers</comment>
        <bits access="rw" name="oe_ext_optional" pos="4" rst="0x0">
          <comment>Oe_ext_optional( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_slice_en_value" pos="3" rst="0x0">
          <comment>Force slice en value( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_slice_en_force" pos="2" rst="0x0">
          <comment>Force slice enable( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_backup_value" pos="1" rst="0x1">
          <comment>Force dll use backup mode value( Reserved  for  vender asic only)</comment>
        </bits>
        <bits access="rw" name="rf_dll_backup" pos="0" rst="0x0">
          <comment>Force dll use backup mode( Reserved  for  vender asic only)</comment>
        </bits>
      </reg>
      <reg name="use_port" protect="rw">
        <comment>Which channel be used Which channel be used</comment>
        <bits access="r" name="use_port" pos="7:0" rst="0xff">
          <comment>If one channel is used, corresponding bit will be 1, otherwise is 0.</comment>
        </bits>
      </reg>
      <reg name="use_source_sync" protect="rw">
        <comment>Which channel use source sync mode</comment>
        <bits access="r" name="use_source_sync" pos="7:0" rst="0xf8">
          <comment>If one channel uses source sync mode, corresponding bit will be 1, otherwise is 0.</comment>
        </bits>
      </reg>
      <reg name="use_ready" protect="rw">
        <comment>Which channel use handshake mode</comment>
        <bits access="r" name="use_ready" pos="7:0" rst="0x3">
          <comment>If one channel uses handshake mode, corresponding bit will be 1, otherwise is 0.</comment>
        </bits>
      </reg>
      <reg name="use_logic_analizer" protect="rw">
        <comment>Which channel use LA mode</comment>
        <bits access="r" name="use_logic_analizer" pos="7:0" rst="0x4">
          <comment>If one channel uses LA mode, corresponding bit will be 1, otherwise is 0.</comment>
        </bits>
      </reg>
      <reg name="la_sample_rate" protect="rw">
        <comment>LA channel sample rate control register</comment>
        <bits access="rw" name="la_sample_rate" pos="3:0" rst="0x7">
          <comment>Sample rate of the LA channel is &quot;(sample_rate + 1) / 16&quot;
This setting can't exceed 0xa, due to the ideal bandwidth limitation.</comment>
        </bits>
      </reg>
      <reg name="version" protect="rw">
        <comment>IP version IP version</comment>
        <bits access="r" name="version" pos="15:0" rst="0x1">
          <comment>R0p1</comment>
        </bits>
      </reg>
      <hole size="1440"/>
      <reg name="dbgio_en_set" protect="rw"/>
      <reg name="funnel_sta_set" protect="rw"/>
      <reg name="dbgio_int_en_set" protect="rw"/>
      <hole size="32"/>
      <reg name="dbgio_ctrl_set" protect="rw"/>
      <hole size="1888"/>
      <reg name="dbgio_en_clr" protect="rw"/>
      <reg name="funnel_sta_clr" protect="rw"/>
      <reg name="dbgio_int_en_clr" protect="rw"/>
      <hole size="32"/>
      <reg name="dbgio_ctrl_clr" protect="rw"/>
    </module>
    <var name="REG_DBGIO_SET_OFFSET" value="0x100"/>
    <var name="REG_DBGIO_CLR_OFFSET" value="0x200"/>
    <instance address="0x18c01000" name="DBGIO" type="DBGIO"/>
  </archive>
  <archive relative="busmon.xml">
    <module category="System" name="BUSMON">
      <reg name="mon_ctrl" protect="rw">
        <comment></comment>
        <bits access="rw" name="busmon_ctrl" pos="0" rst="0x0">
          <comment>Monitor
0
1
:BUS Monitor</comment>
        </bits>
      </reg>
      <reg name="mon_conf" protect="rw">
        <comment></comment>
        <bits access="rw" name="mon_ext_addr_en" pos="9" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="busy_en" pos="8" rst="0x0">
          <comment>BUSY
1
0</comment>
        </bits>
        <bits access="rw" name="rbusy_en" pos="7" rst="0x0">
          <comment>RBUSY
1
0</comment>
        </bits>
        <bits access="rw" name="wbusy_en" pos="6" rst="0x0">
          <comment>WBUSY
1
0</comment>
        </bits>
        <bits access="rw" name="mon_in_addr_en" pos="5" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="mon_num_en" pos="4" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="mon_cont_en" pos="3" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="mon_time_en" pos="2" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="mon_lock_en" pos="1" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="gint_en" pos="0" rst="0x0">
          <comment>
0
1

MON_M0_ADDR_WIDIDDDR0x0-0x1fff_ffffDDR
</comment>
        </bits>
      </reg>
      <reg name="mon_time" protect="rw">
        <comment></comment>
      </reg>
      <reg name="mon_cont" protect="rw">
        <comment></comment>
      </reg>
      <reg name="mon_int_en" protect="rw">
        <comment></comment>
        <bits access="rw" name="addr_int_en" pos="3" rst="0x0">
          <comment>MASTER0
0
1</comment>
        </bits>
        <bits access="rw" name="num_int_en" pos="2" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="timer_int_en" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="lock_int_en" pos="0" rst="0x0">
          <comment>LOCK
0
1</comment>
        </bits>
      </reg>
      <reg name="mon_int_flag" protect="rw">
        <comment></comment>
        <bits access="rc" name="timer_int" pos="17" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rc" name="addr_int" pos="16" rst="0x0">
          <comment>MASTER0
0
1</comment>
        </bits>
        <bits access="rc" name="m4_rnum_int" pos="15" rst="0x0">
          <comment>MASTER4
0
1</comment>
        </bits>
        <bits access="rc" name="m4_wnum_int" pos="14" rst="0x0">
          <comment>MASTER4
0
1</comment>
        </bits>
        <bits access="rc" name="m3_rnum_int" pos="13" rst="0x0">
          <comment>MASTER3
0
1</comment>
        </bits>
        <bits access="rc" name="m3_wnum_int" pos="12" rst="0x0">
          <comment>MASTER3
0
1</comment>
        </bits>
        <bits access="rc" name="m2_rnum_int" pos="11" rst="0x0">
          <comment>MASTER2
0
1</comment>
        </bits>
        <bits access="rc" name="m2_wnum_int" pos="10" rst="0x0">
          <comment>MASTER2
0
1</comment>
        </bits>
        <bits access="rc" name="m1_rnum_int" pos="9" rst="0x0">
          <comment>MASTER1
0
1</comment>
        </bits>
        <bits access="rc" name="m1_wnum_int" pos="8" rst="0x0">
          <comment>MASTER1
0
1</comment>
        </bits>
        <bits access="rc" name="m0_rnum_int" pos="7" rst="0x0">
          <comment>MASTER0
0
1</comment>
        </bits>
        <bits access="rc" name="m0_wnum_int" pos="6" rst="0x0">
          <comment>MASTER0
0
1</comment>
        </bits>
        <bits access="rc" name="timer_cint" pos="5" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rc" name="m4_lcok_int" pos="4" rst="0x0">
          <comment>MASTER4
0
1</comment>
        </bits>
        <bits access="rc" name="m3_lcok_int" pos="3" rst="0x0">
          <comment>MASTER3
0
1</comment>
        </bits>
        <bits access="rc" name="m2_lcok_int" pos="2" rst="0x0">
          <comment>MASTER2
0
1</comment>
        </bits>
        <bits access="rc" name="m1_lcok_int" pos="1" rst="0x0">
          <comment>MASTER1
0
1</comment>
        </bits>
        <bits access="rc" name="m0_lcok_int" pos="0" rst="0x0">
          <comment>MASTER0
0
1</comment>
        </bits>
      </reg>
      <reg name="mon_m0_start_addr0" protect="rw">
        <comment>MASTER0</comment>
      </reg>
      <reg name="mon_m0_end_addr0" protect="rw">
        <comment>MASTER0ID</comment>
      </reg>
      <reg name="mon_m0_addr_wid" protect="rw">
        <comment>MASTER0</comment>
        <bits access="r" name="wa_id" pos="7:0" rst="0x0">
          <comment>ID
: MON_START_ADDR, MON_END_ADDRMASTER0;MASTER0,ADDR_INT,</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="mon_lock_time" protect="rw">
        <comment></comment>
        <bits access="rw" name="lock_value" pos="15:0" rst="0xffff">
          <comment>
</comment>
        </bits>
      </reg>
      <reg name="mon_rcommand0" protect="rw">
        <comment>0</comment>
      </reg>
      <reg name="mon_rdata0" protect="rw">
        <comment>0</comment>
      </reg>
      <reg name="mon_wcommand0" protect="rw">
        <comment>0</comment>
      </reg>
      <reg name="mon_wdata0" protect="rw">
        <comment>0</comment>
      </reg>
      <reg name="mon_rcommand1" protect="rw">
        <comment>1</comment>
      </reg>
      <reg name="mon_rdata1" protect="rw">
        <comment>1</comment>
      </reg>
      <reg name="mon_wcommand1" protect="rw">
        <comment>1</comment>
      </reg>
      <reg name="mon_wdata1" protect="rw">
        <comment>1</comment>
      </reg>
      <reg name="mon_rcommand2" protect="rw">
        <comment>2</comment>
      </reg>
      <reg name="mon_rdata2" protect="rw">
        <comment>2</comment>
      </reg>
      <reg name="mon_wcommand2" protect="rw">
        <comment>2</comment>
      </reg>
      <reg name="mon_wdata2" protect="rw">
        <comment>2</comment>
      </reg>
      <reg name="mon_rcommand3" protect="rw">
        <comment>3</comment>
      </reg>
      <reg name="mon_rdata3" protect="rw">
        <comment>3</comment>
      </reg>
      <reg name="mon_wcommand3" protect="rw">
        <comment>3</comment>
      </reg>
      <reg name="mon_wdata3" protect="rw">
        <comment>3</comment>
      </reg>
      <reg name="mon_rcommand4" protect="rw">
        <comment>4</comment>
      </reg>
      <reg name="mon_rdata4" protect="rw">
        <comment>4</comment>
      </reg>
      <reg name="mon_wcommand4" protect="rw">
        <comment>4</comment>
      </reg>
      <reg name="mon_wdata4" protect="rw">
        <comment>4</comment>
      </reg>
      <reg name="mon_m0_start_addr1" protect="rw">
        <comment>MASTER0</comment>
      </reg>
      <reg name="mon_m0_end_addr1" protect="rw">
        <comment>MASTER0</comment>
      </reg>
      <reg name="mon_m0_start_addr2" protect="rw">
        <comment>MASTER0</comment>
      </reg>
      <reg name="mon_m0_end_addr2" protect="rw">
        <comment>MASTER0</comment>
      </reg>
      <reg name="mon_m0_start_addr3" protect="rw">
        <comment>MASTER0</comment>
      </reg>
      <reg name="mon_m0_end_addr3" protect="rw">
        <comment>MASTER0</comment>
      </reg>
      <reg name="mon_m0_addr" protect="rw">
        <comment>MASTER0</comment>
      </reg>
    </module>
    <instance address="0x04802000" name="AP_BUSMON" type="BUSMON"/>
    <instance address="0x14004000" name="CP_BUSMON" type="BUSMON"/>
  </archive>
  <archive relative="psram_phy.xml">
    <module category="System" name="PSRAM_PHY">
      <reg name="psram_rf_cfg_phy" protect="rw">
        <bits access="rw" name="rf_phy_init_complete" pos="1" rst="0x0">
          <comment>phy initial complete configuration</comment>
        </bits>
        <bits access="rw" name="rf_phy_en" pos="0" rst="0x0">
          <comment>phy enable</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_clock_gate" protect="rw">
        <bits access="rw" name="rf_clk_gate_ag_rd_en" pos="4" rst="0x0">
          <comment>clk_ag_rd enable</comment>
        </bits>
        <bits access="rw" name="rf_clk_gate_ag_wr_en" pos="3" rst="0x0">
          <comment>clk_ag_wr enable</comment>
        </bits>
        <bits access="rw" name="rf_clk_gate_ag_en" pos="2" rst="0x0">
          <comment>clk_ag enable</comment>
        </bits>
        <bits access="rw" name="rf_clk_gate_fg_en" pos="1" rst="0x0">
          <comment>clk_fg enable</comment>
        </bits>
        <bits access="rw" name="rf_clk_gate_en" pos="0" rst="0x0">
          <comment>all clk enable</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_lpi" protect="rw">
        <bits access="rw" name="rf_cwakeup_s0" pos="2" rst="0x0">
          <comment>software configure axi channel slave port cwakeup</comment>
        </bits>
        <bits access="rw" name="rf_cwakeup_m0" pos="1" rst="0x0">
          <comment>software configure axi channel master port cwakeup</comment>
        </bits>
        <bits access="rw" name="rf_lpi_sel_m0" pos="0" rst="0x0">
          <comment>low power interface m0 ch or all ch  select</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_psram_type" protect="rw">
        <bits access="rw" name="rf_length_limit" pos="8" rst="0x0">
          <comment>burst  length 256byte limit for freq of 26m,52m and 109m</comment>
        </bits>
        <bits access="rw" name="rf_wrapper_limit" pos="7" rst="0x0">
          <comment>wb955 128byte wrapper limit</comment>
        </bits>
        <bits access="rw" name="rf_rwds_smpl_time" pos="6:4" rst="0x4">
          <comment>winbond memory sample rwds time</comment>
        </bits>
        <bits access="rw" name="rf_wb64_256_sel" pos="3" rst="0x0">
          <comment>psram is winbond memory 64Mb or 256Mb</comment>
        </bits>
        <bits access="rw" name="rf_datax16_sel" pos="2" rst="0x0">
          <comment>psram dq width  x8 or x16 select</comment>
        </bits>
        <bits access="rw" name="rf_ap256_sel" pos="1" rst="0x0">
          <comment>psram is ap memory 256Mb or not select</comment>
        </bits>
        <bits access="rw" name="rf_wb_sel" pos="0" rst="0x0">
          <comment>psram is winbond hyperbus or not select</comment>
        </bits>
      </reg>
      <reg name="psram_rf_wb_mrw_data" protect="rw">
        <bits access="rw" name="rf_wb_mrw_data" pos="15:0" rst="0x0">
          <comment>winbond memory mr write data</comment>
        </bits>
      </reg>
      <hole size="1888"/>
      <reg name="psram_rfdll_cfg_dll" protect="rw">
        <bits access="w" name="rfdll_reset" pos="0" rst="0x0">
          <comment>not use</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_cpst_idle" protect="rw">
        <bits access="r" name="rfdl_cpst_st_idle_ads1" pos="1" rst="0x1">
          <comment>This bit indicates ad slice 1 cpst is in IDLE status.</comment>
        </bits>
        <bits access="r" name="rfdl_cpst_st_idle_ads0" pos="0" rst="0x1">
          <comment>This bit indicates ad slice 0 cpst is in IDLE status.</comment>
        </bits>
      </reg>
      <reg name="psram_rf_status_phy_data_in" protect="rw">
        <bits access="rw" name="rf_phy_data_in" pos="15:0" rst="0x0">
          <comment>phy input data</comment>
        </bits>
      </reg>
      <hole size="1952"/>
      <reg name="psram_rf_cfg_dll_ads0" protect="rw">
        <bits access="rw" name="rf_dll_lock_wait_ads0" pos="31:28" rst="0x0">
          <comment>This field indicates the cycles to wait the DLL lock internal signals</comment>
        </bits>
        <bits access="rw" name="rf_dll_auto_err_clr_en_ads0" pos="27" rst="0x0">
          <comment>This bit use to clear dll error automaticly</comment>
        </bits>
        <bits access="rw" name="rf_dll_pd_cnt_ads0" pos="26:24" rst="0x0">
          <comment>This field is the sum of the delay cells from phase1 to phase2.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_thr_ads0" pos="23:16" rst="0x0">
          <comment>This field is the threshold to start one compensation</comment>
        </bits>
        <bits access="rw" name="rf_dll_en_ads0" pos="15" rst="0x0">
          <comment>This bit enables the DLL.</comment>
        </bits>
        <bits access="rw" name="rf_dll_clk_sel_ads0" pos="14" rst="0x0">
          <comment>select input clock of dll for ad slice</comment>
        </bits>
        <bits access="w" name="rf_dll_err_clr_ads0" pos="13" rst="0x0">
          <comment>This bit write 1 to clear ad slice</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_auto_ref_en_ads0" pos="12" rst="0x0">
          <comment>This bit is used to enable automatic compensation when all bank auto refresh.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_start_ads0" pos="11" rst="0x0">
          <comment>This bit is used to start compensation one time.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_en_ads0" pos="10" rst="0x0">
          <comment>This bit enables the DLL compensation.</comment>
        </bits>
        <bits access="rw" name="rf_dll_auto_clr_en_ads0" pos="9" rst="0x0">
          <comment>This bit enables DLL automatically clear when in low power state</comment>
        </bits>
        <bits access="rw" name="rf_dll_clr_ads0" pos="8" rst="0x0">
          <comment>This field is to reset DLL</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_dll_ads0" protect="rw">
        <bits access="r" name="rfdll_error_ads0" pos="29" rst="0x0">
          <comment>This field is set if DLL error happens</comment>
        </bits>
        <bits access="r" name="rfdll_locked_ads0" pos="28" rst="0x0">
          <comment>This field indicates DLL is locked or not</comment>
        </bits>
        <bits access="r" name="rfdll_st_ads0" pos="27:25" rst="0x0">
          <comment>This fields show the state of DLL FSM</comment>
        </bits>
        <bits access="r" name="rfdl_cpst_st_ads0" pos="24" rst="0x0">
          <comment>This bit indicates ad slice 0 cpst is in IDLE status.</comment>
        </bits>
        <bits access="r" name="rfdll_cnt_ads0" pos="7:0" rst="0x0">
          <comment>This field indicate the count of delay cells for one clk_dmc cycle</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_0_wr_ads0" protect="rw">
        <bits access="rw" name="rf_clkwr_dl_cpst_en_ads0" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_dl_cpst_minus_ads0" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_qtr_dl_cpst_offset_ads0" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_clkwr_qtr_cnt_ads0" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_qtr_dl_sel_ads0" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_raw_dl_cpst_offset_ads0" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_clkwr_raw_cnt_ads0" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_raw_dl_sel_ads0" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_1_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dqs_in_pos_dl_cpst_en_ads0" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_dl_cpst_minus_ads0" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_qtr_dl_cpst_offset_ads0" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_pos_qtr_cnt_ads0" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_qtr_dl_sel_ads0" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_raw_dl_cpst_offset_ads0" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_pos_raw_cnt_ads0" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_raw_dl_sel_ads0" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_2_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dqs_in_neg_dl_cpst_en_ads0" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_dl_cpst_minus_ads0" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_qtr_dl_cpst_offset_ads0" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_neg_qtr_cnt_ads0" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_qtr_dl_sel_ads0" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_raw_dl_cpst_offset_ads0" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_neg_raw_cnt_ads0" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_raw_dl_sel_ads0" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_3_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dqs_gate_dl_cpst_en_ads0" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_dl_cpst_minus_ads0" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_qtr_dl_cpst_offset_ads0" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_gate_qtr_cnt_ads0" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_qtr_dl_sel_ads0" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_raw_dl_cpst_offset_ads0" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_gate_raw_cnt_ads0" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_raw_dl_sel_ads0" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_4_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_out_cen_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of CEN output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_clk_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of CLK output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_5_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_out_d3_dl_sel_ads0" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D3 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d2_dl_sel_ads0" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D2 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d1_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D1 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d0_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D0 output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_6_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_out_d7_dl_sel_ads0" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D7 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d6_dl_sel_ads0" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D6 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d5_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D5 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d4_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D4 output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_7_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_in_d3_dl_sel_ads0" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D3 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d2_dl_sel_ads0" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D2 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d1_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D1 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d0_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D0 input delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_8_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_in_d7_dl_sel_ads0" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D7 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d6_dl_sel_ads0" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D6 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d5_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D5 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d4_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D4 input delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_9_wr_ads0" protect="rw">
        <bits access="rw" name="rf_dly_in_dqs_dl_sel_ads0" pos="20:16" rst="0x0">
          <comment>This field controls delay value of DQS input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_dqm_dl_sel_ads0" pos="12:8" rst="0x0">
          <comment>This field controls delay value of DQM input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_dqs_dl_sel_ads0" pos="4:0" rst="0x0">
          <comment>This field controls delay value of DQS output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_max_cnt_ads0" protect="rw">
        <bits access="r" name="rfdll_max_cnt_f3_ads0" pos="31:24" rst="0x0">
          <comment>dll max count for frequency set 3</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f2_ads0" pos="23:16" rst="0x0">
          <comment>dll max count for frequency set 2</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f1_ads0" pos="15:8" rst="0x0">
          <comment>dll max count for frequency set 1</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f0_ads0" pos="7:0" rst="0x0">
          <comment>dll max count for frequency set 0</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_min_cnt_ads0" protect="rw">
        <bits access="r" name="rfdll_min_cnt_f3_ads0" pos="31:24" rst="0xff">
          <comment>dll min count for frequency set 3</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f2_ads0" pos="23:16" rst="0xff">
          <comment>dll min count for frequency set 2</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f1_ads0" pos="15:8" rst="0xff">
          <comment>dll min count for frequency set 1</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f0_ads0" pos="7:0" rst="0xff">
          <comment>dll min count for frequency set 0</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_sel_wr_ads0" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_sel_ads0" pos="20" rst="0x0">
          <comment>This field controls IO source of CS
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_sel_ads0" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_sel_ads0" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_sel_ads0" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_sel_ads0" pos="7" rst="0x0">
          <comment>This field controls IO source of D7
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_sel_ads0" pos="6" rst="0x0">
          <comment>This field controls IO source of D6
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_sel_ads0" pos="5" rst="0x0">
          <comment>This field controls IO source of D5
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_sel_ads0" pos="4" rst="0x0">
          <comment>This field controls IO source of D4
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_sel_ads0" pos="3" rst="0x0">
          <comment>This field controls IO source of D3
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_sel_ads0" pos="2" rst="0x0">
          <comment>This field controls IO source of D2
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_sel_ads0" pos="1" rst="0x0">
          <comment>This field controls IO source of D1
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_sel_ads0" pos="0" rst="0x0">
          <comment>This field controls IO source of D0
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_ie_wr_ads0" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_ie_ads0" pos="20" rst="0x0">
          <comment>This field controls IO source of CS ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_ie_ads0" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_ie_ads0" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_ie_ads0" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_ie_ads0" pos="7" rst="0x0">
          <comment>This field controls IO source of D7 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_ie_ads0" pos="6" rst="0x0">
          <comment>This field controls IO source of D6 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_ie_ads0" pos="5" rst="0x0">
          <comment>This field controls IO source of D5 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_ie_ads0" pos="4" rst="0x0">
          <comment>This field controls IO source of D4 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_ie_ads0" pos="3" rst="0x0">
          <comment>This field controls IO source of D3 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_ie_ads0" pos="2" rst="0x0">
          <comment>This field controls IO source of D2 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_ie_ads0" pos="1" rst="0x0">
          <comment>This field controls IO source of D1 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_ie_ads0" pos="0" rst="0x0">
          <comment>This field controls IO source of D0 ie
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_oe_wr_ads0" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_oe_ads0" pos="20" rst="0x0">
          <comment>This field controls IO source of CS oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_oe_ads0" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_oe_ads0" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_oe_ads0" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_oe_ads0" pos="7" rst="0x0">
          <comment>This field controls IO source of D7 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_oe_ads0" pos="6" rst="0x0">
          <comment>This field controls IO source of D6 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_oe_ads0" pos="5" rst="0x0">
          <comment>This field controls IO source of D5 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_oe_ads0" pos="4" rst="0x0">
          <comment>This field controls IO source of D4 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_oe_ads0" pos="3" rst="0x0">
          <comment>This field controls IO source of D3 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_oe_ads0" pos="2" rst="0x0">
          <comment>This field controls IO source of D2 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_oe_ads0" pos="1" rst="0x0">
          <comment>This field controls IO source of D1 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_oe_ads0" pos="0" rst="0x0">
          <comment>This field controls IO source of D0 oe
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_out_wr_ads0" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_out_ads0" pos="20" rst="0x0">
          <comment>This field set value of CEN IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_out_ads0" pos="16" rst="0x0">
          <comment>This field set value of CLK IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_out_ads0" pos="9" rst="0x0">
          <comment>This field set value of DQS IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_out_ads0" pos="8" rst="0x0">
          <comment>This field set value of DQM IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_out_ads0" pos="7" rst="0x0">
          <comment>This field set value of D7 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_out_ads0" pos="6" rst="0x0">
          <comment>This field set value of D6 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_out_ads0" pos="5" rst="0x0">
          <comment>This field set value of D5 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_out_ads0" pos="4" rst="0x0">
          <comment>This field set value of D4 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_out_ads0" pos="3" rst="0x0">
          <comment>This field set value of D3 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_out_ads0" pos="2" rst="0x0">
          <comment>This field set value of D2 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_out_ads0" pos="1" rst="0x0">
          <comment>This field set value of D1 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_out_ads0" pos="0" rst="0x0">
          <comment>This field set value of D0 IO output</comment>
        </bits>
      </reg>
      <hole size="1472"/>
      <reg name="psram_rf_cfg_dll_ads1" protect="rw">
        <comment>not use</comment>
        <bits access="rw" name="rf_dll_lock_wait_ads1" pos="31:28" rst="0x0">
          <comment>This field indicates the cycles to wait the DLL lock internal signals</comment>
        </bits>
        <bits access="rw" name="rf_dll_auto_err_clr_en_ads1" pos="27" rst="0x0">
          <comment>This bit use to clear dll error automaticly</comment>
        </bits>
        <bits access="rw" name="rf_dll_pd_cnt_ads1" pos="26:24" rst="0x0">
          <comment>This field is the sum of the delay cells from phase1 to phase2.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_thr_ads1" pos="23:16" rst="0x0">
          <comment>This field is the threshold to start one compensation</comment>
        </bits>
        <bits access="rw" name="rf_dll_en_ads1" pos="15" rst="0x0">
          <comment>This bit enables the DLL.</comment>
        </bits>
        <bits access="rw" name="rf_dll_clk_sel_ads1" pos="14" rst="0x0">
          <comment>select input clock of dll for ad slice</comment>
        </bits>
        <bits access="w" name="rf_dll_err_clr_ads1" pos="13" rst="0x0">
          <comment>This bit write 1 to clear ad slice</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_auto_ref_en_ads1" pos="12" rst="0x0">
          <comment>This bit is used to enable automatic compensation when all bank auto refresh.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_start_ads1" pos="11" rst="0x0">
          <comment>This bit is used to start compensation one time.</comment>
        </bits>
        <bits access="rw" name="rf_dl_cpst_en_ads1" pos="10" rst="0x0">
          <comment>This bit enables the DLL compensation.</comment>
        </bits>
        <bits access="rw" name="rf_dll_auto_clr_en_ads1" pos="9" rst="0x0">
          <comment>This bit enables DLL automatically clear when in low power state</comment>
        </bits>
        <bits access="rw" name="rf_dll_clr_ads1" pos="8" rst="0x0">
          <comment>This field is to reset DLL</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_dll_ads1" protect="rw">
        <comment>not use</comment>
        <bits access="r" name="rfdll_error_ads1" pos="29" rst="0x0">
          <comment>This field is set if DLL error happens</comment>
        </bits>
        <bits access="r" name="rfdll_locked_ads1" pos="28" rst="0x0">
          <comment>This field indicates DLL is locked or not</comment>
        </bits>
        <bits access="r" name="rfdll_st_ads1" pos="27:25" rst="0x0">
          <comment>This fields show the state of DLL FSM</comment>
        </bits>
        <bits access="r" name="rfdl_cpst_st_ads1" pos="24" rst="0x0">
          <comment>This bit indicates ad slice 0 cpst is in IDLE status.</comment>
        </bits>
        <bits access="r" name="rfdll_cnt_ads1" pos="7:0" rst="0x0">
          <comment>This field indicate the count of delay cells for one clk_dmc cycle</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_0_wr_ads1" protect="rw">
        <bits access="rw" name="rf_clkwr_dl_cpst_en_ads1" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_dl_cpst_minus_ads1" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_qtr_dl_cpst_offset_ads1" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_clkwr_qtr_cnt_ads1" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_qtr_dl_sel_ads1" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_raw_dl_cpst_offset_ads1" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_clkwr_raw_cnt_ads1" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_clkwr_raw_dl_sel_ads1" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_1_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dqs_in_pos_dl_cpst_en_ads1" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_dl_cpst_minus_ads1" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_qtr_dl_cpst_offset_ads1" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_pos_qtr_cnt_ads1" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_qtr_dl_sel_ads1" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_raw_dl_cpst_offset_ads1" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_pos_raw_cnt_ads1" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_pos_raw_dl_sel_ads1" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_2_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dqs_in_neg_dl_cpst_en_ads1" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_dl_cpst_minus_ads1" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_qtr_dl_cpst_offset_ads1" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_neg_qtr_cnt_ads1" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_qtr_dl_sel_ads1" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_raw_dl_cpst_offset_ads1" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_in_neg_raw_cnt_ads1" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_in_neg_raw_dl_sel_ads1" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_3_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dqs_gate_dl_cpst_en_ads1" pos="31" rst="0x0">
          <comment>This field enables the delay line to be compensated automatically by DLL</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_dl_cpst_minus_ads1" pos="30" rst="0x0">
          <comment>This field enables to plus or to minus the offset value when DLL CPST,
0: Plus offset
1: Minus offset</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_qtr_dl_cpst_offset_ads1" pos="29:28" rst="0x0">
          <comment>This fields are used to set the offset quarter delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_gate_qtr_cnt_ads1" pos="27:26" rst="0x0">
          <comment>This field indicate the quarter count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_qtr_dl_sel_ads1" pos="25:24" rst="0x0">
          <comment>This field controls quarter delay value of delay line</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_raw_dl_cpst_offset_ads1" pos="23:16" rst="0x0">
          <comment>This fields are used to set the offset delay value of DLL CPST</comment>
        </bits>
        <bits access="r" name="rfdl_dqs_gate_raw_cnt_ads1" pos="15:8" rst="0x0">
          <comment>This field indicate the raw count of delay</comment>
        </bits>
        <bits access="rw" name="rf_dqs_gate_raw_dl_sel_ads1" pos="7:0" rst="0x0">
          <comment>This field controls delay value of delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_4_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_out_cen_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of CEN output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_clk_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of CLK output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_5_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_out_d3_dl_sel_ads1" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D3 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d2_dl_sel_ads1" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D2 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d1_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D1 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d0_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D0 output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_6_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_out_d7_dl_sel_ads1" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D7 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d6_dl_sel_ads1" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D6 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d5_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D5 output delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_d4_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D4 output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_7_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_in_d3_dl_sel_ads1" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D3 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d2_dl_sel_ads1" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D2 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d1_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D1 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d0_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D0 input delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_8_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_in_d7_dl_sel_ads1" pos="28:24" rst="0x0">
          <comment>This field controls delay value of D7 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d6_dl_sel_ads1" pos="20:16" rst="0x0">
          <comment>This field controls delay value of D6 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d5_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of D5 input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_in_d4_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of D4 input delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_dll_dl_9_wr_ads1" protect="rw">
        <bits access="rw" name="rf_dly_in_dqs_dl_sel_ads1" pos="20:16" rst="0x0">
          <comment>This field controls delay value of DQS input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_dqm_dl_sel_ads1" pos="12:8" rst="0x0">
          <comment>This field controls delay value of DQM input delay line</comment>
        </bits>
        <bits access="rw" name="rf_dly_out_dqs_dl_sel_ads1" pos="4:0" rst="0x0">
          <comment>This field controls delay value of DQS output delay line</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_max_cnt_ads1" protect="rw">
        <comment>not use</comment>
        <bits access="r" name="rfdll_max_cnt_f3_ads1" pos="31:24" rst="0x0">
          <comment>dll max count for frequency set 3</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f2_ads1" pos="23:16" rst="0x0">
          <comment>dll max count for frequency set 2</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f1_ads1" pos="15:8" rst="0x0">
          <comment>dll max count for frequency set 1</comment>
        </bits>
        <bits access="r" name="rfdll_max_cnt_f0_ads1" pos="7:0" rst="0x0">
          <comment>dll max count for frequency set 0</comment>
        </bits>
      </reg>
      <reg name="psram_rfdll_status_min_cnt_ads1" protect="rw">
        <bits access="r" name="rfdll_min_cnt_f3_ads1" pos="31:24" rst="0xff">
          <comment>dll min count for frequency set 3</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f2_ads1" pos="23:16" rst="0xff">
          <comment>dll min count for frequency set 2</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f1_ads1" pos="15:8" rst="0xff">
          <comment>dll min count for frequency set 1</comment>
        </bits>
        <bits access="r" name="rfdll_min_cnt_f0_ads1" pos="7:0" rst="0xff">
          <comment>dll min count for frequency set 0</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_sel_wr_ads1" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_sel_ads1" pos="20" rst="0x0">
          <comment>This field controls IO source of CS
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_sel_ads1" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_sel_ads1" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_sel_ads1" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_sel_ads1" pos="7" rst="0x0">
          <comment>This field controls IO source of D7
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_sel_ads1" pos="6" rst="0x0">
          <comment>This field controls IO source of D6
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_sel_ads1" pos="5" rst="0x0">
          <comment>This field controls IO source of D5
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_sel_ads1" pos="4" rst="0x0">
          <comment>This field controls IO source of D4
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_sel_ads1" pos="3" rst="0x0">
          <comment>This field controls IO source of D3
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_sel_ads1" pos="2" rst="0x0">
          <comment>This field controls IO source of D2
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_sel_ads1" pos="1" rst="0x0">
          <comment>This field controls IO source of D1
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_sel_ads1" pos="0" rst="0x0">
          <comment>This field controls IO source of D0
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_ie_wr_ads1" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_ie_ads1" pos="20" rst="0x0">
          <comment>This field controls IO source of CS ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_ie_ads1" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_ie_ads1" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_ie_ads1" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_ie_ads1" pos="7" rst="0x0">
          <comment>This field controls IO source of D7 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_ie_ads1" pos="6" rst="0x0">
          <comment>This field controls IO source of D6 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_ie_ads1" pos="5" rst="0x0">
          <comment>This field controls IO source of D5 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_ie_ads1" pos="4" rst="0x0">
          <comment>This field controls IO source of D4 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_ie_ads1" pos="3" rst="0x0">
          <comment>This field controls IO source of D3 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_ie_ads1" pos="2" rst="0x0">
          <comment>This field controls IO source of D2 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_ie_ads1" pos="1" rst="0x0">
          <comment>This field controls IO source of D1 ie
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_ie_ads1" pos="0" rst="0x0">
          <comment>This field controls IO source of D0 ie
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_oe_wr_ads1" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_oe_ads1" pos="20" rst="0x0">
          <comment>This field controls IO source of CS oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_oe_ads1" pos="16" rst="0x0">
          <comment>This field controls IO source of CLK oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_oe_ads1" pos="9" rst="0x0">
          <comment>This field controls IO source of DQS oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_oe_ads1" pos="8" rst="0x0">
          <comment>This field controls IO source of DQM oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_oe_ads1" pos="7" rst="0x0">
          <comment>This field controls IO source of D7 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_oe_ads1" pos="6" rst="0x0">
          <comment>This field controls IO source of D6 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_oe_ads1" pos="5" rst="0x0">
          <comment>This field controls IO source of D5 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_oe_ads1" pos="4" rst="0x0">
          <comment>This field controls IO source of D4 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_oe_ads1" pos="3" rst="0x0">
          <comment>This field controls IO source of D3 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_oe_ads1" pos="2" rst="0x0">
          <comment>This field controls IO source of D2 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_oe_ads1" pos="1" rst="0x0">
          <comment>This field controls IO source of D1 oe
0:from psram internal logic
1:from register</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_oe_ads1" pos="0" rst="0x0">
          <comment>This field controls IO source of D0 oe
0:from psram internal logic
1:from register</comment>
        </bits>
      </reg>
      <reg name="psram_rf_cfg_phy_iomux_out_wr_ads1" protect="rw">
        <bits access="rw" name="rf_phy_io_csn_out_ads1" pos="20" rst="0x0">
          <comment>This field set value of CEN IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_clk_out_ads1" pos="16" rst="0x0">
          <comment>This field set value of CLK IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqs_out_ads1" pos="9" rst="0x0">
          <comment>This field set value of DQS IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_dqm_out_ads1" pos="8" rst="0x0">
          <comment>This field set value of DQM IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d7_out_ads1" pos="7" rst="0x0">
          <comment>This field set value of D7 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d6_out_ads1" pos="6" rst="0x0">
          <comment>This field set value of D6 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d5_out_ads1" pos="5" rst="0x0">
          <comment>This field set value of D5 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d4_out_ads1" pos="4" rst="0x0">
          <comment>This field set value of D4 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d3_out_ads1" pos="3" rst="0x0">
          <comment>This field set value of D3 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d2_out_ads1" pos="2" rst="0x0">
          <comment>This field set value of D2 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d1_out_ads1" pos="1" rst="0x0">
          <comment>This field set value of D1 IO output</comment>
        </bits>
        <bits access="rw" name="rf_phy_io_d0_out_ads1" pos="0" rst="0x0">
          <comment>This field set value of D0 IO output</comment>
        </bits>
      </reg>
      <hole size="1472"/>
      <reg name="psram_drf_cfg" protect="rw">
        <bits access="rw" name="drf_clkdmem_out_sel" pos="0" rst="0x0">
          <comment>This field use to  select clkdmem_out
0:clkdmem_out invert
1:clkdmem_out</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_reg_sel" protect="rw">
        <bits access="rw" name="drf_reg_sel" pos="1:0" rst="0x0">
          <comment>This field use to  select f0/f1/f2/f3 register</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_ie_sel_f0" protect="rw">
        <bits access="rw" name="drf_dqs_ie_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_oe_sel_f0" protect="rw">
        <bits access="rw" name="drf_dqs_oe_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_out_sel_f0" protect="rw">
        <bits access="rw" name="drf_dqs_out_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs out delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_gate_sel_f0" protect="rw">
        <bits access="rw" name="drf_dqs_gate_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs gate delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_ie_sel_f0" protect="rw">
        <bits access="rw" name="drf_data_ie_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select data ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_oe_sel_f0" protect="rw">
        <bits access="rw" name="drf_data_oe_sel_f0" pos="15:0" rst="0x0">
          <comment>This field use to  select data oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_ie_sel_f1" protect="rw">
        <bits access="rw" name="drf_dqs_ie_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_oe_sel_f1" protect="rw">
        <bits access="rw" name="drf_dqs_oe_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_out_sel_f1" protect="rw">
        <bits access="rw" name="drf_dqs_out_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs out delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_gate_sel_f1" protect="rw">
        <bits access="rw" name="drf_dqs_gate_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs gate delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_ie_sel_f1" protect="rw">
        <bits access="rw" name="drf_data_ie_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select data ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_oe_sel_f1" protect="rw">
        <bits access="rw" name="drf_data_oe_sel_f1" pos="15:0" rst="0x0">
          <comment>This field use to  select data oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_ie_sel_f2" protect="rw">
        <bits access="rw" name="drf_dqs_ie_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_oe_sel_f2" protect="rw">
        <bits access="rw" name="drf_dqs_oe_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_out_sel_f2" protect="rw">
        <bits access="rw" name="drf_dqs_out_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs out delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_gate_sel_f2" protect="rw">
        <bits access="rw" name="drf_dqs_gate_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs gate delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_ie_sel_f2" protect="rw">
        <bits access="rw" name="drf_data_ie_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select data ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_oe_sel_f2" protect="rw">
        <bits access="rw" name="drf_data_oe_sel_f2" pos="15:0" rst="0x0">
          <comment>This field use to  select data oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_ie_sel_f3" protect="rw">
        <bits access="rw" name="drf_dqs_ie_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_oe_sel_f3" protect="rw">
        <bits access="rw" name="drf_dqs_oe_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_out_sel_f3" protect="rw">
        <bits access="rw" name="drf_dqs_out_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs out delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dqs_gate_sel_f3" protect="rw">
        <bits access="rw" name="drf_dqs_gate_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select dqs gate delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_ie_sel_f3" protect="rw">
        <bits access="rw" name="drf_data_ie_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select data ie delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_data_oe_sel_f3" protect="rw">
        <bits access="rw" name="drf_data_oe_sel_f3" pos="15:0" rst="0x0">
          <comment>This field use to  select data oe delay  cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_mode_f0" protect="rw">
        <bits access="rw" name="drf_dll_satu_mode_f0" pos="2" rst="0x0">
          <comment>This field use to  select dll in saturate mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_half_mode_f0" pos="1" rst="0x0">
          <comment>This field use to  select dll in half mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_clk_mode_f0" pos="0" rst="0x0">
          <comment>This field use to  select dll in x1 or x2 clk mode</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_cnt_f0" protect="rw">
        <bits access="rw" name="drf_dll_auto_cnt_f0" pos="29:20" rst="0x0">
          <comment>dll counts setting  for fast lock</comment>
        </bits>
        <bits access="rw" name="drf_dll_satu_cnt_f0" pos="19:10" rst="0x0">
          <comment>indicate the count of dll state</comment>
        </bits>
        <bits access="rw" name="drf_dll_init_cnt_f0" pos="9:0" rst="0x0">
          <comment>This field is used to configure DLL searching start value</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_mode_f1" protect="rw">
        <bits access="rw" name="drf_dll_satu_mode_f1" pos="2" rst="0x0">
          <comment>This field use to  select dll in saturate mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_half_mode_f1" pos="1" rst="0x0">
          <comment>This field use to  select dll in half mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_clk_mode_f1" pos="0" rst="0x0">
          <comment>This field use to  select dll in x1 or x2 clk mode</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_cnt_f1" protect="rw">
        <bits access="rw" name="drf_dll_auto_cnt_f1" pos="29:20" rst="0x0">
          <comment>dll counts setting  for fast lock</comment>
        </bits>
        <bits access="rw" name="drf_dll_satu_cnt_f1" pos="19:10" rst="0x0">
          <comment>indicate the count of dll state</comment>
        </bits>
        <bits access="rw" name="drf_dll_init_cnt_f1" pos="9:0" rst="0x0">
          <comment>This field is used to configure DLL searching start value</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_mode_f2" protect="rw">
        <bits access="rw" name="drf_dll_satu_mode_f2" pos="2" rst="0x0">
          <comment>This field use to  select dll in saturate mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_half_mode_f2" pos="1" rst="0x0">
          <comment>This field use to  select dll in half mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_clk_mode_f2" pos="0" rst="0x0">
          <comment>This field use to  select dll in x1 or x2 clk mode</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_cnt_f2" protect="rw">
        <bits access="rw" name="drf_dll_auto_cnt_f2" pos="29:20" rst="0x0">
          <comment>dll counts setting  for fast lock</comment>
        </bits>
        <bits access="rw" name="drf_dll_satu_cnt_f2" pos="19:10" rst="0x0">
          <comment>indicate the count of dll state</comment>
        </bits>
        <bits access="rw" name="drf_dll_init_cnt_f2" pos="9:0" rst="0x0">
          <comment>This field is used to configure DLL searching start value</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_mode_f3" protect="rw">
        <bits access="rw" name="drf_dll_satu_mode_f3" pos="2" rst="0x0">
          <comment>This field use to  select dll in saturate mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_half_mode_f3" pos="1" rst="0x0">
          <comment>This field use to  select dll in half mode</comment>
        </bits>
        <bits access="rw" name="drf_dll_clk_mode_f3" pos="0" rst="0x0">
          <comment>This field use to  select dll in x1 or x2 clk mode</comment>
        </bits>
      </reg>
      <reg name="psram_drf_cfg_dll_cnt_f3" protect="rw">
        <bits access="rw" name="drf_dll_auto_cnt_f3" pos="29:20" rst="0x0">
          <comment>dll counts setting  for fast lock</comment>
        </bits>
        <bits access="rw" name="drf_dll_satu_cnt_f3" pos="19:10" rst="0x0">
          <comment>indicate the count of dll state</comment>
        </bits>
        <bits access="rw" name="drf_dll_init_cnt_f3" pos="9:0" rst="0x0">
          <comment>This field is used to configure DLL searching start value</comment>
        </bits>
      </reg>
      <hole size="960"/>
      <reg name="psram_drf_format_control" protect="rw">
        <bits access="rw" name="drf_memory_burst" pos="1:0" rst="0x0">
          <comment>This field use to set psram memory burst</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_rcd" protect="rw">
        <bits access="rw" name="drf_t_rcd" pos="3:0" rst="0x0">
          <comment>This field use to set rcd timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_rddata_en" protect="rw">
        <bits access="rw" name="drf_t_rddata_en" pos="3:0" rst="0x0">
          <comment>This field use to set rddata_en timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_phywrlat" protect="rw">
        <bits access="rw" name="drf_t_phywrlat" pos="3:0" rst="0x0">
          <comment>This field use to set phywrlat timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_cph_wr" protect="rw">
        <bits access="rw" name="drf_t_cph_wr" pos="3:0" rst="0x0">
          <comment>This field use to set cph_wr timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_cph_rd" protect="rw">
        <bits access="rw" name="drf_t_cph_rd_optm" pos="4" rst="0x0">
          <comment>This field use to set cph_rd_optm timing</comment>
        </bits>
        <bits access="rw" name="drf_t_cph_rd" pos="2:0" rst="0x0">
          <comment>This field use to set cph_rd timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_data_oe_ext" protect="rw">
        <bits access="rw" name="drf_t_data_oe_cmd_ext" pos="7:4" rst="0x0">
          <comment>This field use to set cmd data oe extend cycle</comment>
        </bits>
        <bits access="rw" name="drf_t_data_oe_wdata_ext" pos="3:0" rst="0x0">
          <comment>This field use to set wdata oe extend cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_dqs_oe_ext" protect="rw">
        <bits access="rw" name="drf_t_dqs_oe_ext" pos="3:0" rst="0x0">
          <comment>This field use to set dqs oe extend cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_xphs" protect="rw">
        <bits access="rw" name="drf_t_xphs" pos="4:0" rst="0x0">
          <comment>This field use to set xphs timing</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_rddata_vld_sync" protect="rw">
        <bits access="rw" name="drf_t_rddata_vld_sync" pos="2:0" rst="0x0">
          <comment>This field use to set rddata valid sync cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_rddata_late" protect="rw">
        <bits access="rw" name="drf_t_rddata_late" pos="4:0" rst="0x0">
          <comment>This field use to set rddata late cycle</comment>
        </bits>
      </reg>
      <reg name="psram_drf_t_rddata_valid_early" protect="rw">
        <bits access="rw" name="drf_t_rddata_valid_early" pos="1:0" rst="0x0">
          <comment>This field use to set rddata early cycle</comment>
        </bits>
      </reg>
      <reg name="drf_t_wb_rst" protect="rw">
        <bits access="rw" name="drf_t_wb_rp_rst" pos="13:8" rst="0x0">
          <comment>This field use to set winbond reset rp cycle</comment>
        </bits>
        <bits access="rw" name="drf_t_wb_rh_rst" pos="5:0" rst="0x0">
          <comment>This field use to set winbond reset rh cycle</comment>
        </bits>
      </reg>
      <hole size="1632"/>
      <reg name="psram_drf_train_cfg" protect="rw">
        <comment>not use</comment>
        <bits access="rw" name="drf_dmc_rdlvl_gate_en" pos="21" rst="0x0">
          <comment>This field use to enable dmc read gate training</comment>
        </bits>
        <bits access="rw" name="drf_phy_rdlvl_gate_en" pos="20" rst="0x0">
          <comment>This field use to enable phy read gate training</comment>
        </bits>
        <bits access="rw" name="drf_dmc_rdlvl_en" pos="17" rst="0x0">
          <comment>This field use to enable dmc read data eye training</comment>
        </bits>
        <bits access="rw" name="drf_phy_rdlvl_en" pos="16" rst="0x0">
          <comment>This field use to enable phy read data eye training</comment>
        </bits>
        <bits access="rw" name="drf_dmc_wrlvl_en" pos="13" rst="0x0">
          <comment>This field use to enable dmc write training</comment>
        </bits>
        <bits access="rw" name="drf_phy_wrlvl_en" pos="12" rst="0x0">
          <comment>This field use to enable phy write training</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_type_3" pos="11:10" rst="0x0">
          <comment>This field use to define type3 max number of cycles of idle time on DFI control</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_type_2" pos="9:8" rst="0x0">
          <comment>This field use to define type2 max number of cycles of idle time on DFI control</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_type_1" pos="7:6" rst="0x0">
          <comment>This field use to define type1 max number of cycles of idle time on DFI control</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_type_0" pos="5:4" rst="0x0">
          <comment>This field use to define type0 max number of cycles of idle time on DFI control</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_type_sel" pos="2:1" rst="0x0">
          <comment>This field use to select phyupd type</comment>
        </bits>
        <bits access="rw" name="drf_phyupd_en" pos="0" rst="0x0">
          <comment>This field use to enable phy-initiated update</comment>
        </bits>
      </reg>
      <reg name="psram_drf_mr_data_en" protect="rw">
        <bits access="rw" name="drf_mr_data_en" pos="0" rst="0x0">
          <comment>record read memory register data enable</comment>
        </bits>
      </reg>
      <reg name="psram_drf_mr_data_0" protect="rw">
        <comment>read memory register data0</comment>
      </reg>
      <reg name="psram_drf_mr_data_1" protect="rw">
        <comment>read memory register data1</comment>
      </reg>
      <hole size="1920"/>
      <reg name="psram_rf_irq_ctrl" protect="rw">
        <bits access="rw" name="rf_irq_en_disc_rd_ads1" pos="20" rst="0x0">
          <comment>ads1 read command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_wr_ads1" pos="19" rst="0x0">
          <comment>ads1 write command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_mrr_ads1" pos="18" rst="0x0">
          <comment>ads1 mr read command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_mrw_ads1" pos="17" rst="0x0">
          <comment>ads1 mr write command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_rst_ads1" pos="16" rst="0x0">
          <comment>ads1 reset command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_rd_ads0" pos="12" rst="0x0">
          <comment>ads0 read command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_wr_ads0" pos="11" rst="0x0">
          <comment>ads0 write command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_mrr_ads0" pos="10" rst="0x0">
          <comment>ads0 mr read command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_mrw_ads0" pos="9" rst="0x0">
          <comment>ads0 mr write command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_disc_rst_ads0" pos="8" rst="0x0">
          <comment>ads0 reset command send int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_rddata_timeout_ads1" pos="5" rst="0x0">
          <comment>ads1 rddata timeout int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_rddata_timeout_ads0" pos="4" rst="0x0">
          <comment>ads0 rddata timeout int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_dll_unlock_ads1" pos="1" rst="0x0">
          <comment>ads1 dll unlock int enable</comment>
        </bits>
        <bits access="rw" name="rf_irq_en_dll_unlock_ads0" pos="0" rst="0x0">
          <comment>ads0 dll unlock int enable</comment>
        </bits>
      </reg>
      <reg name="psram_rf_irq_status_clr" protect="rw">
        <bits access="rw" name="rf_irq_st_clr_disc_rd_ads1" pos="20" rst="0x0">
          <comment>ads1 read command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_wr_ads1" pos="19" rst="0x0">
          <comment>ads1 write command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_mrr_ads1" pos="18" rst="0x0">
          <comment>ads1 mr read command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_mrw_ads1" pos="17" rst="0x0">
          <comment>ads1 mr write command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_rst_ads1" pos="16" rst="0x0">
          <comment>ads1 reset command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_rd_ads0" pos="12" rst="0x0">
          <comment>ads0 read command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_wr_ads0" pos="11" rst="0x0">
          <comment>ads0 write command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_mrr_ads0" pos="10" rst="0x0">
          <comment>ads0 mr read command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_mrw_ads0" pos="9" rst="0x0">
          <comment>ads0 mr write command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_disc_rst_ads0" pos="8" rst="0x0">
          <comment>ads0 reset command send int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_rddata_timeout_ads1" pos="5" rst="0x0">
          <comment>ads1 rddata timeout int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_rddata_timeout_ads0" pos="4" rst="0x0">
          <comment>ads0 rddata timeout int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_dll_unlock_ads1" pos="1" rst="0x0">
          <comment>ads1 dll unlock int clear</comment>
        </bits>
        <bits access="rw" name="rf_irq_st_clr_dll_unlock_ads0" pos="0" rst="0x0">
          <comment>ads0 dll unlock int clear</comment>
        </bits>
      </reg>
      <reg name="psram_rf_irq_status" protect="rw">
        <bits access="r" name="rf_irq_st_disc_rd_ads1" pos="20" rst="0x0">
          <comment>ads1 read command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_wr_ads1" pos="19" rst="0x0">
          <comment>ads1 write command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_mrr_ads1" pos="18" rst="0x0">
          <comment>ads1 mr read command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_mrw_ads1" pos="17" rst="0x0">
          <comment>ads1 mr write command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_rst_ads1" pos="16" rst="0x0">
          <comment>ads1 reset command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_rd_ads0" pos="12" rst="0x0">
          <comment>ads0 read command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_wr_ads0" pos="11" rst="0x0">
          <comment>ads0 write command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_mrr_ads0" pos="10" rst="0x0">
          <comment>ads0 mr read command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_mrw_ads0" pos="9" rst="0x0">
          <comment>ads0 mr write command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_disc_rst_ads0" pos="8" rst="0x0">
          <comment>ads0 reset command send int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_rddata_timeout_ads1" pos="5" rst="0x0">
          <comment>ads1 rddata timeout int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_rddata_timeout_ads0" pos="4" rst="0x0">
          <comment>ads0 rddata timeout int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_dll_unlock_ads1" pos="1" rst="0x0">
          <comment>ads1 dll unlock int status</comment>
        </bits>
        <bits access="r" name="rf_irq_st_dll_unlock_ads0" pos="0" rst="0x0">
          <comment>ads0 dll unlock int status</comment>
        </bits>
      </reg>
      <reg name="psram_rf_irq_cnt_clr" protect="rw">
        <bits access="w" name="rf_irq_cnt_clr_dll_unlock_ads1" pos="1" rst="0x0">
          <comment>ads1 dll unlock cnt clear</comment>
        </bits>
        <bits access="w" name="rf_irq_cnt_clr_dll_unlock_ads0" pos="0" rst="0x0">
          <comment>ads0 dll unlock cnt clear</comment>
        </bits>
      </reg>
      <reg name="psram_rf_irq_cnt_dll_unlock_ads0" protect="rw">
        <bits access="r" name="rf_irq_cnt_overflow_dll_unlock_ads0" pos="31" rst="0x0">
          <comment>ads0 dll unlock cnt overflow status</comment>
        </bits>
        <bits access="r" name="rf_irq_cnt_dll_unlock_ads0" pos="30:0" rst="0x0">
          <comment>ads0 dll unlock cnt value</comment>
        </bits>
      </reg>
      <reg name="psram_rf_irq_cnt_dll_unlock_ads1" protect="rw">
        <bits access="r" name="rf_irq_cnt_overflow_dll_unlock_ads1" pos="31" rst="0x0">
          <comment>ads1 dll unlock cnt overflow status</comment>
        </bits>
        <bits access="r" name="rf_irq_cnt_dll_unlock_ads1" pos="30:0" rst="0x0">
          <comment>ads1 dll unlock cnt value</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="io_rf_psram_drv_cfg" protect="rw">
        <bits access="rw" name="psram_drvn" pos="12:8" rst="0x10"/>
        <bits access="rw" name="psram_drvp" pos="7:3" rst="0x10"/>
        <bits access="rw" name="psram_slewrate" pos="2:1" rst="0x0"/>
        <bits access="rw" name="psram_fix_read0" pos="0" rst="0x1"/>
      </reg>
      <reg name="io_rf_psram_pad_en_cfg" protect="rw">
        <bits access="rw" name="psram_pad_clkn_en" pos="0" rst="0x1"/>
      </reg>
      <reg name="io_rf_psram_pull_cfg" protect="rw">
        <bits access="rw" name="psram_cen_pull1_bit" pos="11:10" rst="0x1"/>
        <bits access="rw" name="psram_clk_pull0_bit" pos="9:8" rst="0x1"/>
        <bits access="rw" name="psram_clkn_pull1_bit" pos="7:6" rst="0x1"/>
        <bits access="rw" name="psram_dm_pull1_bit" pos="5:4" rst="0x1"/>
        <bits access="rw" name="psram_dq_pull0_bit" pos="3:2" rst="0x0"/>
        <bits access="rw" name="psram_dqs_pull0_bit" pos="1:0" rst="0x1"/>
      </reg>
      <reg name="io_rf_psram_reserved" protect="rw">
        </reg>
    </module>
    <instance address="0x51601000" name="PSRAM_PHY" type="PSRAM_PHY"/>
  </archive>
  <archive relative="cp_irqh.xml">
    <module category="System" name="CP_IRQH">
      <reg name="inth_itr0" protect="rw">
        <comment>Interrupt flag Register0</comment>
      </reg>
      <reg name="inth_itr1" protect="rw">
        <comment>Interrupt flag Register0</comment>
      </reg>
      <reg name="inth_mir0" protect="rw">
        <comment>Interrupt mask Register0</comment>
      </reg>
      <reg name="inth_mir1" protect="rw">
        <comment>Interrupt mask Register1</comment>
      </reg>
      <reg name="inth_mirs0" protect="rw">
        <comment>10</comment>
      </reg>
      <reg name="inth_mirs1" protect="rw">
        <comment>11</comment>
      </reg>
      <reg name="inth_mirc0" protect="rw">
        <comment>00</comment>
      </reg>
      <reg name="inth_mirc1" protect="rw">
        <comment>01</comment>
      </reg>
      <reg name="inth_gmir" protect="rw">
        <comment></comment>
        <bits access="rw" name="gim" pos="0" rst="0x1">
          <comment>Global interrupt enable BIT
0Interrupt is decided by corresponding mask bit
1Maks all Interrupt</comment>
        </bits>
      </reg>
      <reg name="inth_sel0" protect="rw">
        <comment>0</comment>
      </reg>
      <reg name="inth_sel1" protect="rw">
        <comment>1</comment>
      </reg>
      <hole size="32"/>
      <reg name="irq_sta0" protect="rw">
        <comment>IRQ</comment>
      </reg>
      <reg name="irq_sta1" protect="rw">
        <comment>IRQ</comment>
      </reg>
      <reg name="irq_sir" protect="rw">
        <comment>IRQ</comment>
        <bits access="r" name="is" pos="6:0" rst="0x7f">
          <comment>IRQ interrupt source code
0000000IRQ0
0000001IRQ1
0000010IRQ2

0111111IRQ63</comment>
        </bits>
      </reg>
      <reg name="irq_ctrl" protect="rw">
        <comment>IRQ</comment>
        <bits access="w" name="clr" pos="0" rst="0x0">
          <comment>Clear interrupt status bit
0no operation
1clear corresponding bit of IRQ_STA and ITR,at the same time change irq from high to low</comment>
        </bits>
      </reg>
      <reg name="fiq_sta0" protect="rw">
        <comment>FIQ</comment>
      </reg>
      <reg name="fiq_sta1" protect="rw">
        <comment>FIQ</comment>
      </reg>
      <reg name="fiq_sir" protect="rw">
        <comment>FIQ</comment>
        <bits access="r" name="fs" pos="6:0" rst="0x7f">
          <comment>fiq interrupt source code
0000000FIQ0
0000001FIQ1
0000010FIQ2

0111111FIQ63</comment>
        </bits>
      </reg>
      <reg name="fiq_ctrl" protect="rw">
        <comment>FIQ</comment>
        <bits access="w" name="clr" pos="0" rst="0x0">
          <comment>Clear interrupt status bit
0no operation
1clear corresponding bit of IRQ_STA and ITR,at the same time change irq from high to low</comment>
        </bits>
      </reg>
      <reg name="vicprio0" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio1" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio2" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio3" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio4" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio5" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio6" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio7" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio8" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio9" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio10" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio11" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio12" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio13" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio14" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio15" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio16" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio17" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio18" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio19" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio20" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio21" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio22" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio23" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio24" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio25" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio26" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio27" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio28" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio29" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio30" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio31" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio32" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio33" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio34" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio35" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio36" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio37" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio38" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio39" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio40" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio41" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio42" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio43" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio44" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio45" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio46" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio47" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio48" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio49" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio50" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio51" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio52" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio53" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio54" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio55" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio56" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio57" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio58" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio59" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio60" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio61" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio62" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
      <reg name="vicprio63" protect="rw">
        <comment></comment>
        <bits access="rw" name="vic_pri" pos="2:0" rst="0x7">
          <comment>Interrupt prio
0Interrupt prio 0
1Interrupt prio 1

7Interrupt prio 7
Prio 0 is corrosponed to the highist prio</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x14009000" name="CP_IRQH" type="CP_IRQH"/>
    <instance address="0x1400a000" name="CP_IRQH1" type="CP_IRQH"/>
  </archive>
  <archive relative="cp_axidma.xml">
    <module category="System" name="CP_AXIDMA">
      <reg name="axidma_conf" protect="rw">
        <bits access="rw" name="gen_reg_secuirty_en" pos="6" rst="0x1">
          <comment>general used register security visit enable
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="resp_err_stop_en" pos="5" rst="0x0">
          <comment>response error stop function enable
0enable
1disable</comment>
        </bits>
        <bits access="rw" name="outstand" pos="4:3" rst="0x2">
          <comment>the number of outstanding that can be send out
0: 2
1: 3
2: 4</comment>
        </bits>
        <bits access="rw" name="priority" pos="2" rst="0x0">
          <comment>multe-channel transport priority mode control
0: there is no priority in the channels, using polling to DMA data
1: smaller channel number has high-priority.high-priority move data before low-priority channels</comment>
        </bits>
        <bits access="rw" name="stop_ie" pos="1" rst="0x0">
          <comment>interrupt control bit
0: no interruption occurs when all logical channels finish
1: interruption occurs when all logical channels finish</comment>
        </bits>
        <bits access="rw" name="stop" pos="0" rst="0x0">
          <comment>the control bit of logical channel transport finish
0: don't stop all the channel,or automatically clear after setting
1: stop all channel.the current transmission is stopped.the start bits of all channels are cleared</comment>
        </bits>
      </reg>
      <reg name="axidma_delay" protect="rw">
        <bits access="rw" name="delay" pos="15:0" rst="0x0">
          <comment>in the non-priority mode, the time interval between two COUNTP transmission. Take the system clock as the criterion to avoid AXIDMA long-term use of the bus.</comment>
        </bits>
      </reg>
      <reg name="axidma_status" protect="rw">
        <bits access="r" name="stop_status" pos="4" rst="0x0">
          <comment>stop status
0: not finish
1: finish</comment>
        </bits>
        <bits access="r" name="ch_num" pos="3:0" rst="0xf">
          <comment>the channel number of the final transmission
0000: channel 0 just finished the transmission
0001: channel 1 just finished the transmission
0010: channel 2 just finished the transmission

1011: channel 11 just finished the transmission
others: nonentity</comment>
        </bits>
      </reg>
      <reg name="axidma_irq_stat" protect="rw">
        <bits access="r" name="rst_fin_irq" pos="12" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="r" name="ch11_irq" pos="11" rst="0x0">
          <comment>channel 11 interrupts state
0: the channel 11 has not been interrupted, or the interrupt bit has been cleared
1: channel 11 is interrupted</comment>
        </bits>
        <bits access="r" name="ch10_irq" pos="10" rst="0x0">
          <comment>channel 10 interrupts state
0: the channel 10 has not been interrupted, or the interrupt bit has been cleared
1: channel 10 is interrupted</comment>
        </bits>
        <bits access="r" name="ch9_irq" pos="9" rst="0x0">
          <comment>channel 9 interrupts state
0: the channel 9 has not been interrupted, or the interrupt bit has been cleared
1: channel 9 is interrupted</comment>
        </bits>
        <bits access="r" name="ch8_irq" pos="8" rst="0x0">
          <comment>channel 8 interrupts state
0: the channel 8 has not been interrupted, or the interrupt bit has been cleared
1: channel 8 is interrupted</comment>
        </bits>
        <bits access="r" name="ch7_irq" pos="7" rst="0x0">
          <comment>channel 7 interrupts state
0: the channel 7 has not been interrupted, or the interrupt bit has been cleared
1: channel 7 is interrupted</comment>
        </bits>
        <bits access="r" name="ch6_irq" pos="6" rst="0x0">
          <comment>channel 6 interrupts state
0: the channel 6 has not been interrupted, or the interrupt bit has been cleared
1: channel 6 is interrupted</comment>
        </bits>
        <bits access="r" name="ch5_irq" pos="5" rst="0x0">
          <comment>channel 5 interrupts state
0: the channel 5 has not been interrupted, or the interrupt bit has been cleared
1: channel 5 is interrupted</comment>
        </bits>
        <bits access="r" name="ch4_irq" pos="4" rst="0x0">
          <comment>channel 4 interrupts state
0: the channel 4 has not been interrupted, or the interrupt bit has been cleared
1: channel 4 is interrupted</comment>
        </bits>
        <bits access="r" name="ch3_irq" pos="3" rst="0x0">
          <comment>channel 3 interrupts state
0: the channel 3 has not been interrupted, or the interrupt bit has been cleared
1: channel 3 is interrupted</comment>
        </bits>
        <bits access="r" name="ch2_irq" pos="2" rst="0x0">
          <comment>channel 2 interrupts state
0: the channel 2 has not been interrupted, or the interrupt bit has been cleared
1: channel 2 is interrupted</comment>
        </bits>
        <bits access="r" name="ch1_irq" pos="1" rst="0x0">
          <comment>channel 1 interrupts state
0: the channel 1 has not been interrupted, or the interrupt bit has been cleared
1: channel 1 is interrupted</comment>
        </bits>
        <bits access="r" name="ch0_irq" pos="0" rst="0x0">
          <comment>channel 0 interrupts state
0: the channel 0 has not been interrupted, or the interrupt bit has been cleared
1: channel 0 is interrupted</comment>
        </bits>
      </reg>
      <reg name="axidma_arm_req_stat" protect="rw">
        <bits access="r" name="irq23" pos="23" rst="0x0">
          <comment>state of IRQ 23 generate requests of moving data
0: IRQ 23 does not generate requests of moving data
1: IRQ 23 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq22" pos="22" rst="0x0">
          <comment>state of IRQ 22 generate requests of moving data
0: IRQ 22 does not generate requests of moving data
1: IRQ 22 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq21" pos="21" rst="0x0">
          <comment>state of IRQ 21 generate requests of moving data
0: IRQ 21 does not generate requests of moving data
1: IRQ 21 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq20" pos="20" rst="0x0">
          <comment>state of IRQ 20 generate requests of moving data
0: IRQ 20 does not generate requests of moving data
1: IRQ 20 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq19" pos="19" rst="0x0">
          <comment>state of IRQ 19 generate requests of moving data
0: IRQ 19 does not generate requests of moving data
1: IRQ 19 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq18" pos="18" rst="0x0">
          <comment>state of IRQ 18 generate requests of moving data
0: IRQ 18 does not generate requests of moving data
1: IRQ 18 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq17" pos="17" rst="0x0">
          <comment>state of IRQ 17 generate requests of moving data
0: IRQ 17 does not generate requests of moving data
1: IRQ 17 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq16" pos="16" rst="0x0">
          <comment>state of IRQ 16 generate requests of moving data
0: IRQ 16 does not generate requests of moving data
1: IRQ 16 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq15" pos="15" rst="0x0">
          <comment>state of IRQ 15 generate requests of moving data
0: IRQ 15 does not generate requests of moving data
1: IRQ 15 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq14" pos="14" rst="0x0">
          <comment>state of IRQ 14 generate requests of moving data
0: IRQ 14 does not generate requests of moving data
1: IRQ 14 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq13" pos="13" rst="0x0">
          <comment>state of IRQ 13 generate requests of moving data
0: IRQ 13 does not generate requests of moving data
1: IRQ 13 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq12" pos="12" rst="0x0">
          <comment>state of IRQ 12 generate requests of moving data
0: IRQ 12 does not generate requests of moving data
1: IRQ 12 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq11" pos="11" rst="0x0">
          <comment>state of IRQ 11 generate requests of moving data
0: IRQ 11 does not generate requests of moving data
1: IRQ 11 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq10" pos="10" rst="0x0">
          <comment>state of IRQ 10 generate requests of moving data
0: IRQ 10 does not generate requests of moving data
1: IRQ 10 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq9" pos="9" rst="0x0">
          <comment>state of IRQ 9 generate requests of moving data
0: IRQ 9 does not generate requests of moving data
1: IRQ 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq8" pos="8" rst="0x0">
          <comment>state of IRQ 8 generate requests of moving data
0: IRQ 8 does not generate requests of moving data
1: IRQ 8 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq7" pos="7" rst="0x0">
          <comment>state of IRQ 7 generate requests of moving data
0: IRQ 7 does not generate requests of moving data
1: IRQ 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq6" pos="6" rst="0x0">
          <comment>state of IRQ 6 generate requests of moving data
0: IRQ 6 does not generate requests of moving data
1: IRQ 6 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq5" pos="5" rst="0x0">
          <comment>state of IRQ 5 generate requests of moving data
0: IRQ 5 does not generate requests of moving data
1: IRQ 5 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq4" pos="4" rst="0x0">
          <comment>state of IRQ 4 generate requests of moving data
0: IRQ 4 does not generate requests of moving data
1: IRQ 4 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq3" pos="3" rst="0x0">
          <comment>state of IRQ 3 generate requests of moving data
0: IRQ 3 does not generate requests of moving data
1: IRQ 3 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq2" pos="2" rst="0x0">
          <comment>state of IRQ 2 generate requests of moving data
0: IRQ 2 does not generate requests of moving data
1: IRQ 2 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq1" pos="1" rst="0x0">
          <comment>state of IRQ 1 generate requests of moving data
0: IRQ 1 does not generate requests of moving data
1: IRQ 1 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq0" pos="0" rst="0x0">
          <comment>state of IRQ 0 generate requests of moving data
0: IRQ 0 does not generate requests of moving data
1: IRQ 0 generate requests of moving data</comment>
        </bits>
      </reg>
      <reg name="axidma_arm_ack_stat" protect="rw">
        <bits access="r" name="ack23" pos="23" rst="0x0">
          <comment>state of ACK 23 generate requests of moving data
0: ACK 23 does not generate requests of moving data
1: ACK 23 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack22" pos="22" rst="0x0">
          <comment>state of ACK 22 generate requests of moving data
0: ACK 22 does not generate requests of moving data
1: ACK 22 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack21" pos="21" rst="0x0">
          <comment>state of ACK 21 generate requests of moving data
0: ACK 21 does not generate requests of moving data
1: ACK 21 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack20" pos="20" rst="0x0">
          <comment>state of ACK 20 generate requests of moving data
0: ACK 20 does not generate requests of moving data
1: ACK 20 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack19" pos="19" rst="0x0">
          <comment>state of ACK 19 generate requests of moving data
0: ACK 19 does not generate requests of moving data
1: ACK 19 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack18" pos="18" rst="0x0">
          <comment>state of ACK 18 generate requests of moving data
0: ACK 18 does not generate requests of moving data
1: ACK 18 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack17" pos="17" rst="0x0">
          <comment>state of ACK 17 generate requests of moving data
0: ACK 17 does not generate requests of moving data
1: ACK 17 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack16" pos="16" rst="0x0">
          <comment>state of ACK 16 generate requests of moving data
0: ACK 16 does not generate requests of moving data
1: ACK 16 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack15" pos="15" rst="0x0">
          <comment>state of ACK 15 generate requests of moving data
0: ACK 15 does not generate requests of moving data
1: ACK 15 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack14" pos="14" rst="0x0">
          <comment>state of ACK 14 generate requests of moving data
0: ACK 14 does not generate requests of moving data
1: ACK 14 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack13" pos="13" rst="0x0">
          <comment>state of ACK 13 generate requests of moving data
0: ACK 13 does not generate requests of moving data
1: ACK 13 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack12" pos="12" rst="0x0">
          <comment>state of ACK 12 generate requests of moving data
0: ACK 12 does not generate requests of moving data
1: ACK 12 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack11" pos="11" rst="0x0">
          <comment>state of ACK 11 generate requests of moving data
0: ACK 11 does not generate requests of moving data
1: ACK 11 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack10" pos="10" rst="0x0">
          <comment>state of ACK 10 generate requests of moving data
0: ACK 10 does not generate requests of moving data
1: ACK 10 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack9" pos="9" rst="0x0">
          <comment>state of ACK 9 generate requests of moving data
0: ACK 9 does not generate requests of moving data
1: ACK 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack8" pos="8" rst="0x0">
          <comment>state of ACK 8 generate requests of moving data
0: ACK 8 does not generate requests of moving data
1: ACK 8 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack7" pos="7" rst="0x0">
          <comment>state of ACK 7 generate requests of moving data
0: ACK 7 does not generate requests of moving data
1: ACK 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack6" pos="6" rst="0x0">
          <comment>state of ACK 6 generate requests of moving data
0: ACK 6 does not generate requests of moving data
1: ACK 6 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack5" pos="5" rst="0x0">
          <comment>state of ACK 5 generate requests of moving data
0: ACK 5 does not generate requests of moving data
1: ACK 5 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack4" pos="4" rst="0x0">
          <comment>state of ACK 4 generate requests of moving data
0: ACK 4 does not generate requests of moving data
1: ACK 4 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack3" pos="3" rst="0x0">
          <comment>state of ACK 3 generate requests of moving data
0: ACK 3 does not generate requests of moving data
1: ACK 3 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack2" pos="2" rst="0x0">
          <comment>state of ACK 2 generate requests of moving data
0: ACK 2 does not generate requests of moving data
1: ACK 2 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack1" pos="1" rst="0x0">
          <comment>state of ACK 1 generate requests of moving data
0: ACK 1 does not generate requests of moving data
1: ACK 1 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack0" pos="0" rst="0x0">
          <comment>state of ACK 0 generate requests of moving data
0: ACK 0 does not generate requests of moving data
1: ACK 0 generate requests of moving data</comment>
        </bits>
      </reg>
      <reg name="axidma_zsp_req_stat0" protect="rw">
        <bits access="rw" name="req7" pos="30:28" rst="0x0">
          <comment>REQ 7
000REQ 7
001REQ 71

111REQ 77</comment>
        </bits>
        <bits access="rw" name="req6" pos="26:24" rst="0x0">
          <comment>REQ 6
000REQ 6
001REQ 61

111REQ 67</comment>
        </bits>
        <bits access="rw" name="req5" pos="22:20" rst="0x0">
          <comment>REQ 5
000REQ 5
001REQ 51

111REQ 57</comment>
        </bits>
        <bits access="rw" name="req4" pos="18:16" rst="0x0">
          <comment>REQ 4
000REQ 4
001REQ 41

111REQ 47</comment>
        </bits>
        <bits access="rw" name="req3" pos="14:12" rst="0x0">
          <comment>REQ 3
000REQ 3
001REQ 31

111REQ 37</comment>
        </bits>
        <bits access="rw" name="req2" pos="10:8" rst="0x0">
          <comment>REQ 2
000REQ 2
001REQ 21

111REQ 27</comment>
        </bits>
        <bits access="rw" name="req1" pos="6:4" rst="0x0">
          <comment>REQ 1
000REQ 1
001REQ 11

111REQ 17</comment>
        </bits>
        <bits access="rw" name="req0" pos="2:0" rst="0x0">
          <comment>REQ 0
000REQ 0
001REQ 01

111REQ 07</comment>
        </bits>
      </reg>
      <reg name="axidma_zsp_req_stat1" protect="rw">
        <bits access="rw" name="req11" pos="14:12" rst="0x0">
          <comment>REQ 11
000REQ 11
001REQ 111

111REQ 117</comment>
        </bits>
        <bits access="rw" name="req10" pos="10:8" rst="0x0">
          <comment>REQ 10
000REQ 10
001REQ 101

111REQ 107</comment>
        </bits>
        <bits access="rw" name="req9" pos="6:4" rst="0x0">
          <comment>REQ 9
000REQ 9
001REQ 91

111REQ 97</comment>
        </bits>
        <bits access="rw" name="req8" pos="2:0" rst="0x0">
          <comment>REQ 0
000REQ 8
001REQ 81

111REQ 87</comment>
        </bits>
      </reg>
      <reg name="axidma_ch_irq_distr" protect="rw">
        <bits access="rw" name="ch11_irq_en0" pos="11" rst="0x0">
          <comment>channel 11 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch10_irq_en0" pos="10" rst="0x0">
          <comment>channel 10 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch9_irq_en0" pos="9" rst="0x0">
          <comment>channel 9 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch8_irq_en0" pos="8" rst="0x0">
          <comment>channel 8 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch7_irq_en0" pos="7" rst="0x0">
          <comment>channel 7 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch6_irq_en0" pos="6" rst="0x0">
          <comment>channel 6 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch5_irq_en0" pos="5" rst="0x0">
          <comment>channel 5 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch4_irq_en0" pos="4" rst="0x0">
          <comment>channel 4 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch3_irq_en0" pos="3" rst="0x0">
          <comment>channel 3 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch2_irq_en0" pos="2" rst="0x0">
          <comment>channel 2 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch1_irq_en0" pos="1" rst="0x0">
          <comment>channel 1 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch0_irq_en0" pos="0" rst="0x0">
          <comment>channel 0 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
      </reg>
      <hole size="224"/>
      <reg name="axidma_c0_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x0">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x0">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c0_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c0_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c0_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c1_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x1">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x1">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c1_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c1_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c1_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c2_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x2">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x2">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c2_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c2_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c2_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c3_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x3">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x3">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c3_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c3_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c3_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c4_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x4">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x4">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c4_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c4_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c4_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c5_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x5">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x5">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c5_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c5_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c5_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c6_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x6">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x6">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c6_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c6_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c6_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c7_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x7">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x7">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c7_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c7_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c7_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c8_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x8">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x8">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c8_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c8_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c8_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c9_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0x9">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0x9">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c9_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c9_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c9_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c10_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0xa">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0xa">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c10_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c10_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c10_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c11_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0x0">
          <comment>response error interrupt enable
0disable
1enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="0x1">
          <comment>security visit
0security
1unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0x0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0x0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0x0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0x0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0x0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0x0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0x0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="0x1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0x0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0x0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0xb">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2

10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0xb">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission

01111: IRQ15 trigger transmission

10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c11_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c11_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0x0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0x0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0x0">
          <comment>response error interrupt flag
0unset
1set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0x0">
          <comment>response error status
0unset
1set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0x0">
          <comment>data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0x0">
          <comment>the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0x0">
          <comment>COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0x0">
          <comment>scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0x0">
          <comment>the number of scatter-gather transfers completed
0x0000: 0

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0x0">
          <comment>scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0x0">
          <comment>COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0x0">
          <comment>the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0x0">
          <comment>the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c11_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0x0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit

0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0x0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0x0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0x0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0x0">
          <comment>scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_set" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_set" pos="0" rst="0x0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_clr" protect="rw">
        <comment>AXIDMA </comment>
        <bits access="rw" name="run_clr" pos="0" rst="0x0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x12040000" name="CP_AXIDMA" type="CP_AXIDMA"/>
  </archive>
  <archive relative="f8.xml">
    <module category="System" name="F8">
      <reg name="f8_up_conf" protect="rw">
        <comment>F8 </comment>
        <bits access="rw" name="f8_ar_sel" pos="4:2" rst="0x0">
          <comment>F8
000
001AES
010snow3G
011zuc
100Kasumi
101-111Reversed</comment>
        </bits>
        <bits access="rw" name="f8_irq_en" pos="1" rst="0x0">
          <comment>F8
0F8 /group
1F8 /group</comment>
        </bits>
        <bits access="rw" name="f8_start" pos="0" rst="0x0">
          <comment>F8
0F8 
1F8</comment>
        </bits>
      </reg>
      <reg name="f8_up_group_addr" protect="rw">
        <comment>F8group</comment>
      </reg>
      <reg name="f8_up_group_cnt" protect="rw">
        <comment>F8group</comment>
      </reg>
      <reg name="f8_up_status" protect="rw">
        <comment>F8</comment>
        <bits access="rc" name="f8_up_stat" pos="0" rst="0x0">
          <comment>0F8/
1F8/</comment>
        </bits>
      </reg>
      <reg name="f8_dp_conf" protect="rw">
        <comment>F8 </comment>
        <bits access="rw" name="f8_ar_sel" pos="4:2" rst="0x0">
          <comment>F8
000
001AES
010snow3G
011zuc
100Kasumi
101-111Reversed</comment>
        </bits>
        <bits access="rw" name="f8_irq_en" pos="1" rst="0x0">
          <comment>F8
0F8 /group
1F8 /group</comment>
        </bits>
        <bits access="rw" name="f8_start" pos="0" rst="0x0">
          <comment>F8
0F8 
1F8</comment>
        </bits>
      </reg>
      <reg name="f8_dp_group_addr" protect="rw">
        <comment>F8group</comment>
      </reg>
      <reg name="f8_dp_group_cnt" protect="rw">
        <comment>F8group</comment>
      </reg>
      <reg name="f8_dp_status" protect="rw">
        <comment>F8</comment>
        <bits access="rc" name="f8_dp_stat" pos="0" rst="0x0">
          <comment>0F8/
1F8/</comment>
        </bits>
      </reg>
      <reg name="f9_conf" protect="rw">
        <comment>F9</comment>
        <bits access="rw" name="w_cmd_cnt" pos="7:6" rst="0x1">
          <comment>AXIoutstanding,2b11</comment>
        </bits>
        <bits access="rw" name="r_cmd_cnt" pos="5:4" rst="0x1">
          <comment>AXIoutstanding,2b11</comment>
        </bits>
        <bits access="rw" name="f9_ar_sel" pos="3:2" rst="0x0">
          <comment>F9
00AES
01AES
10snow3G
11zuc</comment>
        </bits>
        <bits access="rw" name="f9_irq_en" pos="1" rst="0x0">
          <comment>F9
0F9 /group
1F9 /group</comment>
        </bits>
        <bits access="rw" name="f9_start" pos="0" rst="0x0">
          <comment>F9
0F9 
1F9</comment>
        </bits>
      </reg>
      <reg name="f9_group_addr" protect="rw">
        <comment>F9 group</comment>
      </reg>
      <reg name="f9_status" protect="rw">
        <comment>F9</comment>
        <bits access="rc" name="f9_stat" pos="0" rst="0x0">
          <comment>0F9
1F9</comment>
        </bits>
      </reg>
      <reg name="f9_result" protect="rw">
        <comment>F9 </comment>
      </reg>
      <reg name="f8_cmd_conf" protect="rw">
        <comment>F8 </comment>
        <bits access="rw" name="f8_ar_sel" pos="4:2" rst="0x0">
          <comment>F8
000
001AES
010snow3G
011zuc
100Kasumi
101-111Reversed</comment>
        </bits>
        <bits access="rw" name="f8_irq_en" pos="1" rst="0x0">
          <comment>F8
0F8 group
1F8 group</comment>
        </bits>
        <bits access="rw" name="f8_start" pos="0" rst="0x0">
          <comment>F8
0F8 
1F8</comment>
        </bits>
      </reg>
      <reg name="f8_cmd_addr" protect="rw">
        <comment>F8group</comment>
      </reg>
      <reg name="f8_cmd_status" protect="rw">
        <comment>F8</comment>
        <bits access="rc" name="f8_cmd_stat" pos="0" rst="0x0">
          <comment>0F8
1F8</comment>
        </bits>
      </reg>
      <reg name="status_sr" protect="rw">
        <comment></comment>
        <bits access="rc" name="f9_status" pos="3" rst="0x0">
          <comment>0F9
1F9</comment>
        </bits>
        <bits access="rc" name="f8_cmd_status" pos="2" rst="0x0">
          <comment>0F8
1F8</comment>
        </bits>
        <bits access="rc" name="f8_up_status" pos="1" rst="0x0">
          <comment>0F8
1F8</comment>
        </bits>
        <bits access="rc" name="f8_dp_status" pos="0" rst="0x0">
          <comment>0F8
1F8</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x12000000" name="F8" type="F8"/>
  </archive>
  <archive relative="idle_timer.xml">
    <module category="System" name="IDLE_TIMER">
      <reg name="idl_ctrl_sys1" protect="rw">
        <comment>CP sleep enable register(Enable CP sleep when writing 0x49444c45 to this register, accessed by software only.)</comment>
        <bits access="rw" name="idct_ctrl_sys1" pos="0" rst="0x0">
          <comment>Enable CP sleep
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_ctrl_sys2" protect="rw">
        <comment>AP sleep enable register(Auto cleared by hardware after the system awakup)</comment>
        <bits access="rw" name="idct_ctrl_sys2" pos="0" rst="0x0">
          <comment>Enable AP sleep(Auto cleared to be 0 when the system is awaked)
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_en" protect="rw">
        <comment>System sleep enable register</comment>
        <bits access="rw" name="idl_ap_en" pos="1" rst="0x0">
          <comment>Enable AP sleep
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="idl_cp_en" pos="0" rst="0x0">
          <comment>Enable CP sleep
0:  disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_m_timer" protect="rw">
        <comment>Slssp counter wrap value.</comment>
      </reg>
      <reg name="idl_wcn_en" protect="rw">
        <comment>WCN lp enable register</comment>
        <bits access="rw" name="wcn_res_val" pos="4" rst="0x1">
          <comment>Default value when the enable bit was disabled.</comment>
        </bits>
        <bits access="rw" name="wcn_idle_cg" pos="3" rst="0x1">
          <comment>Enable bit of wcn idle_cg
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="wcn_pd_pll" pos="2" rst="0x1">
          <comment>Enable bit of wcn pd_pll
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="wcn_pd_xtal" pos="1" rst="0x1">
          <comment>Enable bit of wcn pd_xtal
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="wcn_chip_pd" pos="0" rst="0x1">
          <comment>Enable bit of wcn chip_pd
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_ctrl_timer" protect="rw">
        <comment>Timer sleep enable (writing 0x49444c45 to this register to enable timer sleep.)</comment>
        <bits access="rw" name="idct_ctrl_timer" pos="0" rst="0x0">
          <comment>Enable Timer sleep(Auto clear to be 0 when timer is awaked)
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_m2_sys" protect="rw">
        <comment>Sleep threshold register</comment>
        <bits access="rw" name="m1_sys" pos="31:16" rst="0x6">
          <comment>Threshold register M1:
when the signal pow_on_ack is low, both gsm and lte timer are sleeped, and the difference between current ref_32k counter
and sleep wrap value is larger than this register, system sleep state machine can shift to SLP state.</comment>
        </bits>
        <bits access="rw" name="m2_sys" pos="15:0" rst="0x8">
          <comment>Threshold register M2:
when idct_sys1 and idct_sys2 are set to be1, the difference between current ref_32k counter and sleep wrap value is larger than this register, system sleep state machine can shift to SLP_PRE state.</comment>
        </bits>
      </reg>
      <reg name="idl_tc_start" protect="rw">
        <comment>Take over TCU enable register</comment>
        <bits access="rw" name="tc_start_mod" pos="1:0" rst="0x0">
          <comment>Enable mode(TCU suspend and this bits are clear to be 0 when take over is started)
00: disbale or already release TCU.
01:  take over TCU immediately
10: take over at gsm frame interrupt.
11:  no effect.</comment>
        </bits>
      </reg>
      <reg name="idl_tc_end" protect="rw">
        <comment>Restart TCU register</comment>
        <bits access="rw" name="tc_end_framc" pos="20:4" rst="0x1">
          <comment>restart TCU when gsm counter reach this register</comment>
        </bits>
        <bits access="rw" name="tc_end_mod" pos="1:0" rst="0x0">
          <comment>restart mode(this bits clear to be 0 when TCU restarts)
00: disable
01: restart TCU immediately
10: restart TCU when gsm frame interrupt occurred.
11:  restart TCU when gsm framc equal to TC_END_FRAMC.</comment>
        </bits>
      </reg>
      <reg name="idl_awk_timer" protect="rw">
        <comment>TIMER wakeup register</comment>
        <bits access="rw" name="wake_timer" pos="0" rst="0x0">
          <comment>Timer wakeup enable(software accessed only)
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="gsm_lp_pu_done" protect="rw">
        <comment>Lp_pu_done register</comment>
        <bits access="rw" name="lp_pu_done" pos="0" rst="0x0">
          <comment>TCU restart enable(software accessed only)
Output to the port gsm_lp_pu_done directly, wakeup TCU in low power mode when writing 1 to this bit.</comment>
        </bits>
      </reg>
      <reg name="gsm_frame_inten" protect="rw">
        <comment>gsm frame interrupt enable set register</comment>
        <bits access="rw" name="gsm_frame_irq_en" pos="0" rst="0x0">
          <comment>gsm_frame_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="gsm_frame_int_sta" protect="rw">
        <comment>gsm frame interrupt state register</comment>
        <bits access="rw" name="gsm_frame_int_sta" pos="0" rst="0x0">
          <comment>cleared by writing 1 to correspond bit</comment>
        </bits>
      </reg>
      <reg name="ltem1_frame_inten" protect="rw">
        <comment>LTEM1 frame interrupt enable register</comment>
        <bits access="rw" name="ltem1_frame3_irq_en" pos="2" rst="0x0">
          <comment>ltem1_frame3_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem1_frame2_irq_en" pos="1" rst="0x0">
          <comment>ltem1_frame2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem1_frame1_irq_en" pos="0" rst="0x0">
          <comment>ltem1_frame1_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="ltem1_frame_int_sta" protect="rw">
        <comment>LTEM1 interrupt state register</comment>
        <bits access="rc" name="ltem1_frame_int_sta" pos="2:0" rst="0x0">
          <comment>cleared by writing 1 to correspond bit</comment>
        </bits>
      </reg>
      <reg name="ltem2_frame_inten" protect="rw">
        <comment>LTEM2 frame interrupt enable register</comment>
        <bits access="rw" name="ltem2_frame3_irq_en" pos="2" rst="0x0">
          <comment>ltem2_frame3_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem2_frame2_irq_en" pos="1" rst="0x0">
          <comment>ltem2_frame2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem2_frame1_irq_en" pos="0" rst="0x0">
          <comment>ltem2_frame1_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="ltem2_frame_int_sta" protect="rw">
        <comment>LTEM2 interrupt state register</comment>
        <bits access="rc" name="ltem2_frame_int_sta" pos="2:0" rst="0x0">
          <comment>cleared by writing 1 to correspond bit</comment>
        </bits>
      </reg>
      <reg name="idl_sta" protect="rw">
        <comment>IDLE state register</comment>
        <bits access="r" name="idle_ltem3_timer_stat" pos="6" rst="0x0">
          <comment>ltem3 timer state
0: running at 122.88M
1:  running at 32K</comment>
        </bits>
        <bits access="r" name="idle_nb_timer_stat" pos="5" rst="0x0">
          <comment>NB timer state
0: running at 61.44M
1:  running at 32K</comment>
        </bits>
        <bits access="r" name="h_stat" pos="4" rst="0x0">
          <comment>H circuit state
0:  not work
1:  at wok</comment>
        </bits>
        <bits access="r" name="idle_ltem2_timer_stat" pos="3" rst="0x0">
          <comment>ltem2 timer state
0: running at 122.88M
1:  running at 32K</comment>
        </bits>
        <bits access="r" name="idle_ltem1_timer_stat" pos="2" rst="0x0">
          <comment>ltem1 timer state
0: running at 122.88M
1:  running at 32K</comment>
        </bits>
        <bits access="r" name="idle_gsm_timer_stat" pos="1" rst="0x0">
          <comment>GSM timer state
0: running at 26M
1:  running at 32K</comment>
        </bits>
        <bits access="r" name="idle_sys_stat" pos="0" rst="0x0">
          <comment>SYS state
0:  normal working
1:  low power mode</comment>
        </bits>
      </reg>
      <reg name="idl_h_ctrl" protect="rw">
        <comment>H circuit control register</comment>
        <bits access="rw" name="h_run_time" pos="6:3" rst="0xf">
          <comment>Runtime of H circuit, the length is 2^h_run_time(number of 32k clocks)</comment>
        </bits>
        <bits access="rw" name="h_auto_en" pos="2" rst="0x0">
          <comment>Automatic computing mode enable(loop computing until disabled)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="h_ctrl_en" pos="1" rst="0x0">
          <comment>Invocation pattern(compute only one time, automatic clear to be 0 when finished.)
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="idl_h_val" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x0">
          <comment>The length of sys clock in  2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_h_gsm" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x1f40000">
          <comment>The cycles number of 26M in 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_h_ltem" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x7800142">
          <comment>The cycles number of 122.88M in of 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_awk_en" protect="rw">
        <comment>wakeup enable register</comment>
        <bits access="rw" name="nb_lp_pu_reach_en" pos="20" rst="0x0">
          <comment>signal nb_lp_pu_reach wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="gsm_lp_pu_reach_en" pos="19" rst="0x0">
          <comment>signal gsm_lp_pu_reach wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk_self_en" pos="18" rst="0x0">
          <comment>sofware wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk_osw2_en" pos="17" rst="0x0">
          <comment>OSW2 wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk_osw1_en" pos="16" rst="0x0">
          <comment>OSW1 wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk15_en" pos="15" rst="0x0">
          <comment>pad_gpio1 wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk14_en" pos="14" rst="0x0">
          <comment>uart3_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk13_en" pos="13" rst="0x0">
          <comment>pad_uart3_rxd wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk12_en" pos="12" rst="0x0">
          <comment>gpt2_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk11_en" pos="11" rst="0x0">
          <comment>mailbox_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk10_en" pos="10" rst="0x0">
          <comment>gpio2_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk9_en" pos="9" rst="0x0">
          <comment>uart2_irq wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="awk8_en" pos="8" rst="0x0">
          <comment>pad_uart2_rxd wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk7_en" pos="7" rst="0x0">
          <comment>pmic_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk6_en" pos="6" rst="0x0">
          <comment>usb_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk5_en" pos="5" rst="0x0">
          <comment>pad_uart1_rxd wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk4_en" pos="4" rst="0x0">
          <comment>Uart1_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk3_en" pos="3" rst="0x0">
          <comment>Gpio1_irq wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk2_en" pos="2" rst="0x0">
          <comment>Keyboard wakeup enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="awk1_en" pos="1" rst="0x0">
          <comment>gpt1_irq wakeup enable
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="awk0_en" pos="0" rst="0x0">
          <comment>Pad_gpio6 wakeup enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="idl_awk_st" protect="rw">
        <comment>wakeup state(can be cleared by writing 1 to correspond bits)</comment>
        <bits access="r" name="pow_dfe_sta" pos="25" rst="0x1">
          <comment>pow_dfe_ack state
0: pow_dfe_ack is 0 when system exit IDLE
1:  pow_dfe_ack is 1 when system exit IDLE</comment>
        </bits>
        <bits access="rc" name="thr_sta" pos="24" rst="0x0">
          <comment>Threshold M1 state
1: pow_ack not meet threshold M1 or pow_ack not feedback in sleep period
0: meet threshold M1</comment>
        </bits>
        <bits access="rc" name="pow_sta" pos="23" rst="0x0">
          <comment>pow_ack state
0: pow_ack is 0 when system exit IDLE
1:  pow_ack is 1 when system exit IDLE</comment>
        </bits>
        <bits access="rc" name="idle_stat" pos="22" rst="0x0">
          <comment>system exit idle state
0: sys not enter idle
1: sys enter idle state</comment>
        </bits>
        <bits access="rc" name="awk_up_stat" pos="21" rst="0x0">
          <comment>IDLE sleep wakeup state
0: awaked before the sleep warp time
1: awaked at the sleep warp time</comment>
        </bits>
        <bits access="rc" name="nb_lp_pu_reach_stat" pos="20" rst="0x0">
          <comment>Signal nb_lp_pu_reach wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="gsm_lp_pu_reach_stat" pos="19" rst="0x0">
          <comment>Signal gsm_lp_pu_reach wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk_self_stat" pos="18" rst="0x0">
          <comment>software wakeup state
0: software wakeupup signal not generated
1: software wakeupup system.</comment>
        </bits>
        <bits access="rc" name="awk_osw2_stat" pos="17" rst="0x0">
          <comment>OSW2 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk_osw1_stat" pos="16" rst="0x0">
          <comment>OSW1 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk15_awk_stat" pos="15" rst="0x0">
          <comment>AWK15 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk14_awk_stat" pos="14" rst="0x0">
          <comment>AWK14 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk13_awk_stat" pos="13" rst="0x0">
          <comment>AWK13 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk12_awk_stat" pos="12" rst="0x0">
          <comment>AWK12 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk11_awk_stat" pos="11" rst="0x0">
          <comment>AWk11 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk10_awk_stat" pos="10" rst="0x0">
          <comment>AWk10 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk9_awk_stat" pos="9" rst="0x0">
          <comment>AWK9 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk8_awk_stat" pos="8" rst="0x0">
          <comment>AWK8 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk7_awk_stat" pos="7" rst="0x0">
          <comment>AWK7 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk6_awk_stat" pos="6" rst="0x0">
          <comment>AWK6 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk5_awk_stat" pos="5" rst="0x0">
          <comment>AWK5 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk4_awk_stat" pos="4" rst="0x0">
          <comment>AWK4 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk3_awk_stat" pos="3" rst="0x0">
          <comment>AWk3 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk2_awk_stat" pos="2" rst="0x0">
          <comment>AWk2 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk1_awk_stat" pos="1" rst="0x0">
          <comment>AWK1 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
        <bits access="rc" name="awk0_awk_stat" pos="0" rst="0x0">
          <comment>AWK0 wakeup state
0: this signal not generated
1: this signal generated</comment>
        </bits>
      </reg>
      <reg name="idl_awk_self" protect="rw">
        <comment>software wakeup signal</comment>
        <bits access="rw" name="wake_self" pos="0" rst="0x0">
          <comment>0: not effect
1:  wakeup system
(accessed by software only, this bit shold clear bu software when system is awaked.)</comment>
        </bits>
      </reg>
      <reg name="idl_osw1_en" protect="rw">
        <comment>OSW1 TIMER enable</comment>
        <bits access="rw" name="osw1_en" pos="31" rst="0x0">
          <comment>1:  enable
0: disable</comment>
        </bits>
        <bits access="rw" name="osw1_time" pos="30:0" rst="0x7fffffff">
          <comment>osw1 wrap value</comment>
        </bits>
      </reg>
      <reg name="idl_osw1_cont" protect="rw">
        <comment>OSW1 Timer current value</comment>
      </reg>
      <reg name="idl_fn_gsm" protect="rw">
        <comment>IDLE GSM frame register</comment>
      </reg>
      <reg name="idl_fn_ltem1" protect="rw">
        <comment>IDLE LTEM1frame register</comment>
        <bits access="r" name="idfn_rad_ltem" pos="31:4" rst="0x0">
          <comment>Number of frames ltem1 sleeped.</comment>
        </bits>
        <bits access="r" name="idfn_sub_ltem" pos="3:0" rst="0x0">
          <comment>Number of sub-frames ltem1 sleeped.</comment>
        </bits>
      </reg>
      <reg name="idl_fn_ltem2" protect="rw">
        <comment>IDLE LTEM2 frame register</comment>
        <bits access="r" name="idfn_rad_ltem" pos="31:4" rst="0x0">
          <comment>Number of frames ltem2 sleeped</comment>
        </bits>
        <bits access="r" name="idfn_sub_ltem" pos="3:0" rst="0x0">
          <comment>Number of sub-frames ltem2 sleeped.</comment>
        </bits>
      </reg>
      <reg name="idl_ltem_rfl" protect="rw">
        <comment>IDLE LTE frame length register</comment>
        <bits access="rw" name="ltem_idle_radioframe_parameter" pos="20:0" rst="0x12c000">
          <comment>LTE sleep frame length, suggest keep the default value.</comment>
        </bits>
      </reg>
      <reg name="idl_ltem_sfl" protect="rw">
        <comment>IDLE LTE sub-frame length register</comment>
        <bits access="rw" name="ltem_idle_frame_parameter" pos="16:0" rst="0x1e000">
          <comment>LTE sleep sub-frame length, suggest keep
the default value.</comment>
        </bits>
      </reg>
      <reg name="idl_sig_en" protect="rw">
        <comment>signal of low power related enable register</comment>
        <bits access="rw" name="idle_cg_en" pos="3" rst="0x1">
          <comment>Idle_cg_en enable
1: enable.
0: disable.</comment>
        </bits>
        <bits access="rw" name="pd_pll_en" pos="2" rst="0x1">
          <comment>Pd_pll_en enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="pd_xtal_en" pos="1" rst="0x1">
          <comment>pd_xtal_en enable
1: enable.
0: disable.</comment>
        </bits>
        <bits access="rw" name="chip_pd_en" pos="0" rst="0x1">
          <comment>chip_pd_en enable
1:  enable.
0: disable.</comment>
        </bits>
      </reg>
      <reg name="idl_sig_timer" protect="rw">
        <comment>low power related time control register</comment>
        <bits access="rw" name="t4" pos="31:24" rst="0x1">
          <comment>The time from enable clock to obtain clock</comment>
        </bits>
        <bits access="rw" name="t3" pos="23:16" rst="0xa">
          <comment>The time of PLL from power saving state to output normal clock.</comment>
        </bits>
        <bits access="rw" name="t2" pos="15:8" rst="0xa0">
          <comment>The time of OSC circuit from power saving
state to normal state.</comment>
        </bits>
        <bits access="rw" name="t1" pos="7:0" rst="0x1">
          <comment>The time of PMIC boost stabilization.</comment>
        </bits>
      </reg>
      <reg name="idl_32k_ref" protect="rw">
        <comment>32K reference counter</comment>
      </reg>
      <reg name="idl_cp_inten" protect="rw">
        <comment>cp interrupt enable register</comment>
        <bits access="rw" name="cp_em_latch_irq" pos="18" rst="0x0">
          <comment>em_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_cpu_latch_irq" pos="17" rst="0x0">
          <comment>cpu_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_rtc_latch_irq" pos="16" rst="0x0">
          <comment>rtc_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_load_end_irq" pos="15" rst="0x0">
          <comment>load_end_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_timer_idle_irq" pos="14" rst="0x0">
          <comment>timer_idle_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_target_irq" pos="13" rst="0x0">
          <comment>target_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_nb_pu_reach_irq" pos="12" rst="0x0">
          <comment>nb_pu_reach_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="nb_tc_end_irq" pos="11" rst="0x0">
          <comment>nb_tc_end_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="nb_tc_start_irq" pos="10" rst="0x0">
          <comment>nb_tc_start_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="sys_wak_irq" pos="9" rst="0x0">
          <comment>sys_awk _irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_timer_awk_irq" pos="8" rst="0x0">
          <comment>Timer_awk_irq_enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="cp_gsm_pu_reach_irq" pos="7" rst="0x0">
          <comment>gsm_pu_reach_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="gsm_tc_end_irq" pos="6" rst="0x0">
          <comment>gsm_tc_end_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="gsm_tc_start_irq" pos="5" rst="0x0">
          <comment>gsm_tc_start_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="osw1_irq" pos="4" rst="0x0">
          <comment>osw1_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="idl_tstamp_irq" pos="3" rst="0x0">
          <comment>tstamp_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="idle_frame_irq" pos="2" rst="0x0">
          <comment>idle_frame_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="idle_h_irq" pos="1" rst="0x1">
          <comment>idle_h_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="layout_irq" pos="0" rst="0x0">
          <comment>layout_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="idl_cp_inten_set" protect="rw">
        <comment>cp interrupt enable set register</comment>
        <bits access="rs" name="idl_cp_int_en_set" pos="18:0" rst="0x0">
          <comment>set  cp interrupt enable register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_cp_inten_clr" protect="rw">
        <comment>cp interrupt enable clear register</comment>
        <bits access="rc" name="idl_cp_int_en_clr" pos="18:0" rst="0x0">
          <comment>clear  cp interrupt enable register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_cp_int_sta" protect="rw">
        <comment>cp interrupt state</comment>
        <bits access="rc" name="idl_cp_int_sta" pos="18:0" rst="0x0">
          <comment>clear interrupt state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_ap_inten" protect="rw">
        <comment>ap interrupt enable register</comment>
        <bits access="rw" name="ap_em_latch_irq" pos="10" rst="0x0">
          <comment>em_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_cpu_latch_irq" pos="9" rst="0x0">
          <comment>cpu_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_rtc_latch_irq" pos="8" rst="0x0">
          <comment>rtc_latch_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_load_end_irq" pos="7" rst="0x0">
          <comment>load_end_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_timer_idle_irq" pos="6" rst="0x0">
          <comment>timer_idle_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_target_irq" pos="5" rst="0x0">
          <comment>target_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_nb_pu_reach_irq" pos="4" rst="0x0">
          <comment>nb_pu_reach_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="sys_wak_irq" pos="3" rst="0x0">
          <comment>sys_awk _irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_timer_awk_irq" pos="2" rst="0x0">
          <comment>Timer_awk_irq_enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ap_gsm_pu_reach_irq" pos="1" rst="0x0">
          <comment>gsm_pu_reach_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="osw2_irq" pos="0" rst="0x0">
          <comment>osw2_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="idl_ap_inten_set" protect="rw">
        <comment>ap interrupt enable set register</comment>
        <bits access="rs" name="idl_ap_int_en_set" pos="10:0" rst="0x0">
          <comment>set  ap interrupt enable register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_ap_inten_clr" protect="rw">
        <comment>ap interrupt enable clear register</comment>
        <bits access="rc" name="idl_ap_int_en_clr" pos="10:0" rst="0x0">
          <comment>clear  ap interrupt enable register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_ap_int_sta" protect="rw">
        <comment>ap interrupt state</comment>
        <bits access="rc" name="idl_ap_int_sta" pos="10:0" rst="0x0">
          <comment>clear ap interrupt state register when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_hfn" protect="rw">
        <comment>LTEM1 high-level frame number register</comment>
        <bits access="rw" name="ltem1_cfsr_hfn" pos="21:0" rst="0x0">
          <comment>Ltem1 high-level frame number value</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_fn" protect="rw">
        <bits access="rw" name="ltem1_cfsr_rad" pos="13:4" rst="0x0">
          <comment>LTE-M1 frame number</comment>
        </bits>
        <bits access="rw" name="ltem1_cfsr_sub" pos="3:0" rst="0x0">
          <comment>LTE-M1 sub-frame number</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsrs" protect="rw">
        <comment>LTE-M1 frame offset register</comment>
        <bits access="rw" name="active_time1_cfsr" pos="25" rst="0x0">
          <comment>frame adjust time
0: adjust at next frame interrupt
1: adjust frame immetiately</comment>
        </bits>
        <bits access="rw" name="adjust_direct1_cfsr" pos="24" rst="0x0">
          <comment>frame adjust direction
0: postive
1: negative</comment>
        </bits>
        <bits access="rw" name="ltem1_cfsrs" pos="23:0" rst="0x0">
          <comment>LTE-M1 frame offest value
(Adjust frame offset B, there are two case: if adjust direction is 0, write b+1 to this register then current frame plus this value when frame interrupt occurred. otherwise write b-1 into this register then current frame minus this value when frame interrupt occurred.)</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_rdh" protect="rw">
        <comment>LTE-M1 high-level frame read register</comment>
        <bits access="r" name="ltem1_cfsr_rdh" pos="21:0" rst="0x0">
          <comment>LTE-M1 high-level frame value</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_rdl" protect="rw">
        <comment>LTE-M1 frame read register</comment>
        <bits access="r" name="ltem1_cfsr_rdl_rad" pos="13:4" rst="0x0">
          <comment>LTE-M1 radio frame value</comment>
        </bits>
        <bits access="r" name="ltem1_cfsr_rdl_sub" pos="3:0" rst="0x0">
          <comment>LTE-M1 sub-frame value</comment>
        </bits>
      </reg>
      <reg name="ltem1_framc" protect="rw">
        <comment>LTE-M1 counter</comment>
        <bits access="r" name="ltem1_framc" pos="15:0" rst="0x1">
          <comment>LTE-M1 counter value</comment>
        </bits>
      </reg>
      <reg name="ltem1_framl" protect="rw">
        <comment>LTE-M1 frame length register</comment>
        <bits access="rw" name="ltem1_framl" pos="15:0" rst="0x7800">
          <comment>LTE-M1 frame length</comment>
        </bits>
      </reg>
      <reg name="ltem1_framls" protect="rw">
        <comment>LTE-M1 frame length adjust register</comment>
        <bits access="rw" name="active_time1_framls" pos="16" rst="0x0">
          <comment>adjust time
0: adjust immetiately
1:  adjust at next ltem frame interrupt</comment>
        </bits>
        <bits access="rw" name="ltem1_framls" pos="15:0" rst="0x0">
          <comment>LTE-M1 adjuste frame length.
current Ltem frame length load the register when write happens,then return the LFRAML at the time of lte frame interrupt arrivals.</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_tph" protect="rw">
        <comment>LTE-M1 radio frame value time stamp register</comment>
        <bits access="rw" name="ltem1_cfsr_tph" pos="21:0" rst="0x0">
          <comment>LTE-M1 high-level frame value time stamp register</comment>
        </bits>
      </reg>
      <reg name="ltem1_cfsr_tpl" protect="rw">
        <comment>LTE-M1 sub-frame time stamp register</comment>
        <bits access="rw" name="ltem1_cfsr_tpl" pos="13:0" rst="0x0">
          <comment>LTE-M1 frame stamp value</comment>
        </bits>
      </reg>
      <reg name="ltem1_framc_tp" protect="rw">
        <comment>LTE-M1 counter time stamp register</comment>
        <bits access="rw" name="ltem1_framc_tp" pos="15:0" rst="0x1">
          <comment>LTE-M1 stamp counter</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_hfn" protect="rw">
        <comment>LTE-M2 high-level frame register</comment>
        <bits access="rw" name="ltem2_cfsr_hfn" pos="21:0" rst="0x0">
          <comment>LTE-M2 high-level frame value</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_fn" protect="rw">
        <bits access="rw" name="ltem2_cfsr_rad" pos="13:4" rst="0x0">
          <comment>LTE-M2 radio frame value</comment>
        </bits>
        <bits access="rw" name="ltem2_cfsr_sub" pos="3:0" rst="0x0">
          <comment>LTE-M2 sub-frame value</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsrs" protect="rw">
        <comment>LTE-M2 frame offset adjust register</comment>
        <bits access="rw" name="active_time2_cfsr" pos="25" rst="0x0">
          <comment>adjust time.
0: adjust at next frame interrupt
1: adjust frame immetiately</comment>
        </bits>
        <bits access="rw" name="adjust_direct2_cfsr" pos="24" rst="0x0">
          <comment>adjust direction
0: postive
1: negative</comment>
        </bits>
        <bits access="rw" name="ltem2_cfsrs" pos="23:0" rst="0x0">
          <comment>Frame offest value(Adjust frame offset B, there are two case: if adjust direction is 0, write b+1 to this register then current frame plus this value at the time of frame interrupt genereted. otherwise write b-1 into this register then current frame minus this value at the time of frame interrupt generated.)</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_rdh" protect="rw">
        <comment>LTE-M2 high-level frame read register</comment>
        <bits access="r" name="ltem2_cfsr_rdh" pos="21:0" rst="0x0">
          <comment>LTE-M2 super read frame value</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_rdl" protect="rw">
        <comment>LTE-M2 frame read register</comment>
        <bits access="r" name="ltem2_cfsr_rdl_rad" pos="13:4" rst="0x0">
          <comment>LTE-M2 radio frame read value</comment>
        </bits>
        <bits access="r" name="ltem2_cfsr_rdl_sub" pos="3:0" rst="0x0">
          <comment>LTE-M2 sub-frame read value</comment>
        </bits>
      </reg>
      <reg name="ltem2_framc" protect="rw">
        <comment>LTE-M counter</comment>
        <bits access="r" name="ltem2_lframc" pos="15:0" rst="0x1">
          <comment>LTE-M counter</comment>
        </bits>
      </reg>
      <reg name="ltem2_framl" protect="rw">
        <comment>LTE-M2 frame length</comment>
        <bits access="rw" name="ltem2_lframl" pos="15:0" rst="0x7800">
          <comment>LTE-M2 frame length value</comment>
        </bits>
      </reg>
      <reg name="ltem2_framls" protect="rw">
        <comment>LTE-M2 frame length adjust register</comment>
        <bits access="rw" name="active_time2_framls" pos="16" rst="0x0">
          <comment>adjust time
0: adjust immetiately
1:  adjust at next ltem frame interrupt</comment>
        </bits>
        <bits access="rw" name="ltem2_framls" pos="15:0" rst="0x0">
          <comment>LTE-M2 adjuste frame length.
current Ltem frame length load the register when write happens,then backed the LFRAML at the time of lte frame interrupt occurred.</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_tph" protect="rw">
        <comment>LTE-M2 radio frame time stamp register</comment>
        <bits access="rw" name="ltem2_cfsr_tph" pos="21:0" rst="0x0">
          <comment>LTE-M2 high-level frame time stamp register</comment>
        </bits>
      </reg>
      <reg name="ltem2_cfsr_tpl" protect="rw">
        <comment>LTE-M2 sub-frame time stamp register</comment>
        <bits access="rw" name="ltem2_cfsr_tpl" pos="13:0" rst="0x0">
          <comment>LTE-M2 frame stamp value</comment>
        </bits>
      </reg>
      <reg name="ltem2_framc_tp" protect="rw">
        <comment>LTE-M2 counter time stamp register</comment>
        <bits access="rw" name="ltem2_framc_tp" pos="15:0" rst="0x1">
          <comment>LTE-M2 stamp counter</comment>
        </bits>
      </reg>
      <reg name="gsm_cfsr" protect="rw">
        <comment>GSM frame register</comment>
        <bits access="rw" name="gsm_cfsr" pos="23:0" rst="0x0">
          <comment>GSM frame value</comment>
        </bits>
      </reg>
      <reg name="gsm_cfsrs" protect="rw">
        <comment>GSM frame offset adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="24" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="gsm_cfsrs" pos="23:0" rst="0x0">
          <comment>frame offest value
(Adjust frame offset B. there are two case: if adjust direction is 0, write b+1 into this register then current frame plus this value when frame interrupt occurred. otherwise write b-1 into this register then current frame minus this value when frame interrupt occurred.)</comment>
        </bits>
      </reg>
      <reg name="gsm_cfsro" protect="rw">
        <comment>GSM frame overflow register</comment>
        <bits access="rw" name="gsm_cfsr_overflow" pos="23:0" rst="0x297000">
          <comment>GSM frame overflow value</comment>
        </bits>
      </reg>
      <reg name="ltem1_fhl" protect="rw">
        <comment>LTE-M high-level frame locked register</comment>
        <bits access="r" name="ltem_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="ltem1_fll" protect="rw">
        <comment>LTE-M frame locked register</comment>
        <bits access="r" name="ltem_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="ltem1_fcl" protect="rw">
        <comment>LTE-M counter locked register</comment>
        <bits access="r" name="ltem_fcl" pos="15:0" rst="0x1">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="ltem2_fhl" protect="rw">
        <comment>LTE-M high-level frame lock register</comment>
        <bits access="r" name="ltem_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="ltem2_fll" protect="rw">
        <comment>LTE-M frame locked register</comment>
        <bits access="r" name="ltem_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="ltem2_fcl" protect="rw">
        <comment>LTE-M counter locked register</comment>
        <bits access="r" name="ltem_fcl" pos="15:0" rst="0x1">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gsm_fl" protect="rw">
        <comment>GSM frame lock register</comment>
        <bits access="r" name="fl" pos="23:0" rst="0x0">
          <comment>GSM frame locked value</comment>
        </bits>
      </reg>
      <reg name="gsm_fcl" protect="rw">
        <comment>GSM counter lock register</comment>
        <bits access="r" name="gsm_fcl" pos="16:0" rst="0x1">
          <comment>GSM counter locked value</comment>
        </bits>
      </reg>
      <reg name="idl_tpctrl" protect="rw">
        <comment>time stamp register</comment>
        <bits access="rw" name="idle_mod_sel" pos="10:8" rst="0x0">
          <comment>lock signal
000: ltem1 frame interrupt.
001: ltem2 frame interrupt.
010: gsm frame interrupt.
011: negative of 32k clock.
100: nb frame interrput.
others: gsm frame interrupt.</comment>
        </bits>
        <bits access="rw" name="idle_inner_confg" pos="5:4" rst="0x0">
          <comment>lock way
00: disable lock
01: bit 0 control the time stamp, bit 0 auto clear to be 0 after time stamp finsihed.
10: time stamp when lock signal comes after that bit 5 and 4 clear to be 0.
11: time stamp loop</comment>
        </bits>
        <bits access="rw" name="idle_inner_ctrl" pos="0" rst="0x0">
          <comment>1: time stamp immediately.
0: not effect</comment>
        </bits>
      </reg>
      <reg name="layoutt" protect="rw">
        <comment>current task planning time register</comment>
      </reg>
      <reg name="layoutctrl" protect="rw">
        <comment>task planning time register</comment>
        <bits access="rw" name="chip_count" pos="22:8" rst="0x0">
          <comment>Layoutt register descending unit.
15h0000: 1
15h0001:  2
15h0002: 3

15h7fff: 32768</comment>
        </bits>
        <bits access="rw" name="timer_select" pos="1" rst="0x0">
          <comment>Layout count time selection
0: ltem1 timer
1: ltem2 timer</comment>
        </bits>
        <bits access="rw" name="enable" pos="0" rst="0x0">
          <comment>task planning
1:  start task planing
0: end timing
(The control bit is clear automatically after the timer is finished, and the software can be clear to bestop counting.)</comment>
        </bits>
      </reg>
      <reg name="ltem1_fint_dly1" protect="rw">
        <comment>LTEM1 frame interrupt delay register 1</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M1 frame interrupt delay, take ltem1_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem1_fint_dly2" protect="rw">
        <comment>LTEM1 frame interrupt delay register 2</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M1 frame interrupt delay, take ltem1_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem2_fint_dly1" protect="rw">
        <comment>LTEM2 frame interrupt delay register 1</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M2 frame interrupt delay, take ltem2_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem2_fint_dly2" protect="rw">
        <comment>LTEM2 frame interrupt delay register 2</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M2 frame interrupt delay, take ltem2_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem1_fint_en" protect="rw">
        <comment>sub-frame interrupt enable register</comment>
        <bits access="rw" name="lte_m1_fint_enable" pos="9:0" rst="0x3ff">
          <comment>Each bit corresponds to 10 sub-frame, sub-frame interrupt will be sent to CPU when correspond bit is enabled.</comment>
        </bits>
      </reg>
      <reg name="timer_en" protect="rw">
        <comment>TIMER enable register</comment>
        <bits access="rw" name="gnss_ltem_timer_enable" pos="5" rst="0x0">
          <comment>GNSS_LTE-M timer enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="nb_timer_enable" pos="4" rst="0x0">
          <comment>NB timer enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ltem_timer_enable" pos="3" rst="0x0">
          <comment>LTE-M timer enable
0: disable
1: enable
(note: this timer is the reference lte timer.)</comment>
        </bits>
        <bits access="rw" name="gsm_timer_enable" pos="2" rst="0x0">
          <comment>GSM timer enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="lte_m2_timer_enable" pos="1" rst="0x0">
          <comment>LTE-M2 timer enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="lte_m1_timer_enable" pos="0" rst="0x1">
          <comment>LTE-M1 timer enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="idle_frame_sta" protect="rw">
        <comment>IDLE frame interrupt state register(can be clear by writing 1 to correspond bit)</comment>
        <bits access="rc" name="gnss_lte_m_frame_state" pos="5" rst="0x0">
          <comment>GNSS_LTE-M frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
        <bits access="rc" name="nb_frame_state" pos="4" rst="0x0">
          <comment>NB frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
        <bits access="rc" name="lte_m_frame_state" pos="3" rst="0x0">
          <comment>reference lte frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
        <bits access="rc" name="gsm_frame_state" pos="2" rst="0x0">
          <comment>GSM frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
        <bits access="rc" name="lte_m2_frame_state" pos="1" rst="0x0">
          <comment>LTE-M2 frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
        <bits access="rc" name="lte_m1_frame_state" pos="0" rst="0x0">
          <comment>LTE-M1 frame interrupt state
0: No interrupt occurred
1: interrupt occurred</comment>
        </bits>
      </reg>
      <reg name="idle_frame_ltem1" protect="rw">
        <comment>IDLE LTE-M1 frame configuration register</comment>
        <bits access="rw" name="frame_conf" pos="24" rst="0x0">
          <comment>enable(this bit cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="frame_cfsr" pos="21:0" rst="0x0">
          <comment>interrupt frame number
interrupt occurred when current frame reach this register.</comment>
        </bits>
      </reg>
      <reg name="idle_frame_ltem2" protect="rw">
        <comment>IDLE LTE-M2 frame configuration register</comment>
        <bits access="rw" name="frame_conf" pos="24" rst="0x0">
          <comment>enable(this bit is cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="frame_cfsr" pos="21:0" rst="0x0">
          <comment>interrupt occurred when current frame reach this register.</comment>
        </bits>
      </reg>
      <reg name="idle_frame_gsm" protect="rw">
        <comment>IDLE GSM frame configuration register</comment>
        <bits access="rw" name="frame_conf" pos="24" rst="0x0">
          <comment>enable(this bit cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="frame_cfsr" pos="23:0" rst="0x0">
          <comment>interrupt occurred when current frame reach this register and counter equal to IDLE_FRAMC_GSM</comment>
        </bits>
      </reg>
      <reg name="idle_frame_lte" protect="rw">
        <comment>IDLE REF_LTE frame configuration register</comment>
      </reg>
      <reg name="idle_frame_lte_conf" protect="rw">
        <comment>IDLE REF LTE frame enable register</comment>
        <bits access="r" name="resrved" pos="31:1" rst="0x0"/>
        <bits access="rw" name="frame_ref_lte_conf" pos="0" rst="0x0">
          <comment>enable(this bit cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
      </reg>
      <reg name="ltem_ref_fn" protect="rw">
        <comment>REF_LTE frame register</comment>
      </reg>
      <reg name="ltem_ref_fnl" protect="rw">
        <comment>REF_LTE frame locked register</comment>
      </reg>
      <reg name="ltem_ref_fcl" protect="rw">
        <comment>REF_LTE counter locked register</comment>
        <bits access="r" name="ref_ltem_fcl" pos="14:0" rst="0x1">
          <comment>reference lte counter locked value</comment>
        </bits>
      </reg>
      <reg name="ref_32k_fnl" protect="rw">
        <comment>REF_32K CONT clocked register</comment>
      </reg>
      <reg name="ltem_ref_fc" protect="rw">
        <comment>REF_LTE counter register</comment>
        <bits access="r" name="ltem_ref_fc" pos="14:0" rst="0x1">
          <comment>reference lte counter</comment>
        </bits>
      </reg>
      <reg name="gsm_framl" protect="rw">
        <comment>GSM frame length</comment>
        <bits access="rw" name="gsm_framl" pos="16:0" rst="0x1d4c0">
          <comment>GSM frame length value</comment>
        </bits>
      </reg>
      <reg name="idl_osw2_en" protect="rw">
        <comment>OSW2 configuration register</comment>
        <bits access="rw" name="osw2_en" pos="31" rst="0x0">
          <comment>1: enable OSW2 timer
0: disable</comment>
        </bits>
        <bits access="rw" name="osw2_time" pos="30:0" rst="0x7fffffff">
          <comment>OSW2 Timing start value</comment>
        </bits>
      </reg>
      <reg name="idl_osw2_cont" protect="rw">
        <comment>OSW2 counter register</comment>
      </reg>
      <reg name="idle_framc_gsm" protect="rw">
        <comment>IDLE GSM frame interrupt counter setting register</comment>
        <bits access="rw" name="framc_cfsr" pos="16:0" rst="0x1">
          <comment>IDLE GSM frame interrupt generated when GSM frame counter reach GSM_FRAME_GSM and GSM counter equal to this register.</comment>
        </bits>
      </reg>
      <reg name="ltem1_fint_dly3" protect="rw">
        <comment>LTEM1 interrupt delay setting register 3</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M1 frame interrupt delay,
take ltem1_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem2_fint_dly3" protect="rw">
        <comment>LTEM2 interrupt delay setting register 3</comment>
        <bits access="rw" name="delay_time" pos="15:0" rst="0x1">
          <comment>LTE-M2 frame interrupt delay, take ltem2_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="idle_time_sel" protect="rw">
        <comment>idle time select register</comment>
        <bits access="rw" name="time_sel" pos="0" rst="0x0">
          <comment>1: select pd_xtal, 0: select chip_pd</comment>
        </bits>
      </reg>
      <reg name="idle_time" protect="rw">
        <comment>IDLE time register</comment>
      </reg>
      <reg name="idl_h_gsm_lp" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x1f40000">
          <comment>The cycles number of 26M in 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_h_ltem_lp" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x7800142">
          <comment>The cycles number of 122.88M in of 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_tc_start_nb" protect="rw">
        <comment>Take over NB TCU enable register</comment>
        <bits access="rw" name="tc_start_mod" pos="1:0" rst="0x0">
          <comment>Enable mode(NB TCU suspend and this bits are cleared by hardware when take over started)
00: disbale or already release TCU.
01:  take over TCU immediately
10: take over at gsm frame interrupt.
11:  no effect.</comment>
        </bits>
      </reg>
      <reg name="idl_tc_end_nb" protect="rw">
        <comment>Restart NB TCU register</comment>
        <bits access="rw" name="tc_end_framc" pos="20:4" rst="0x1">
          <comment>restart TCU when gsm counter reach this register</comment>
        </bits>
        <bits access="rw" name="tc_end_mod" pos="1:0" rst="0x0">
          <comment>restart mode(this bits cleared when TCU restarts)
00: disable
01: restart TCU immediately
10: restart TCU when gsm frame interrupt occurred.
11:  restart TCU when gsm framc equal to TC_END_FRAMC.</comment>
        </bits>
      </reg>
      <reg name="nb_lp_pu_done" protect="rw">
        <comment>Nb_lp_pu_done register</comment>
        <bits access="rw" name="lp_pu_done" pos="0" rst="0x0">
          <comment>TCU restart enable(accessed by software only.)
Output to the port nb_lp_pu_done directly, wakeup TCU in low power mode when writing 1 to this bit.</comment>
        </bits>
      </reg>
      <reg name="idl_h_nb" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x3c000a1">
          <comment>The cycles number of 61.44M in the length of 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_h_nb_lp" protect="rw">
        <comment>H value register</comment>
        <bits access="rw" name="h_value" pos="26:0" rst="0x3c000a1">
          <comment>The cycles number of 61.44M in the length of 2^h_run_time 32k cycles</comment>
        </bits>
      </reg>
      <reg name="idl_fn_nb" protect="rw">
        <comment>IDLE NB frame register</comment>
      </reg>
      <reg name="nb_frame_inten" protect="rw">
        <comment>NB frame interrupt enable register</comment>
        <bits access="rw" name="nb_frame_irq_en" pos="0" rst="0x0">
          <comment>nb_frame_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="nb_frame_int_sta" protect="rw">
        <comment>NB frame interrupt state register</comment>
        <bits access="rw" name="gsm_frame_int_sta" pos="0" rst="0x0">
          <comment>cleared by writing 1 to correspond bit</comment>
        </bits>
      </reg>
      <reg name="nb_cfsr" protect="rw">
        <comment>NB frame register</comment>
        <bits access="rw" name="gsm_cfsr" pos="23:0" rst="0x0">
          <comment>NB frame value</comment>
        </bits>
      </reg>
      <reg name="nb_framl" protect="rw">
        <comment>NB frame length</comment>
        <bits access="rw" name="nb_framl" pos="16:0" rst="0xf000">
          <comment>NB frame length value</comment>
        </bits>
      </reg>
      <reg name="nb_cfsrs" protect="rw">
        <comment>NB frame offset adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="24" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="nb_cfsrs" pos="23:0" rst="0x0">
          <comment>frame offest value
(Adjust frame offset B. there are two case: if adjust direction is 0, write b+1 to this register then current frame plus this value when frame interrupt occurred. otherwise write b- 1 to this register then current frame minus this value when frame interrupt occurred.)</comment>
        </bits>
      </reg>
      <reg name="nb_cfsro" protect="rw">
        <comment>NB frame overflow register</comment>
        <bits access="rw" name="nb_cfsr_overflow" pos="23:0" rst="0xffffff">
          <comment>NB frame overflow value</comment>
        </bits>
      </reg>
      <reg name="nb_fl" protect="rw">
        <comment>NB frame lock register</comment>
        <bits access="r" name="fl" pos="23:0" rst="0x0">
          <comment>NB frame locked value</comment>
        </bits>
      </reg>
      <reg name="nb_fcl" protect="rw">
        <comment>NB counter lock register</comment>
        <bits access="r" name="nb_fcl" pos="16:0" rst="0x1">
          <comment>NB counter locked value</comment>
        </bits>
      </reg>
      <reg name="idle_frame_nb" protect="rw">
        <comment>IDLE NB frame configuration register</comment>
        <bits access="rw" name="frame_conf" pos="24" rst="0x0">
          <comment>enable(this bit cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="frame_cfsr" pos="23:0" rst="0x0">
          <comment>interrupt occurred when current frame reach this register and counter equal to IDLE_FRAMC_NB</comment>
        </bits>
      </reg>
      <reg name="idle_framc_nb" protect="rw">
        <comment>IDLE NB frame interrupt counter setting register</comment>
        <bits access="rw" name="framc_cfsr" pos="16:0" rst="0x1">
          <comment>IDLE NB frame interrupt generated when NB frame counter reach IDLE_FRAME_NB and NB counter equal to this register.</comment>
        </bits>
      </reg>
      <reg name="idl_awk_en_set" protect="rw">
        <comment>wakeup enable set register</comment>
        <bits access="rs" name="awk_en_set" pos="20:0" rst="0x0">
          <comment>set wakeup enable register  by writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="idl_awk_en_clr" protect="rw">
        <comment>wakeup enable clear register</comment>
        <bits access="rc" name="awk_en_clear" pos="20:0" rst="0x0">
          <comment>clear wakeup enable register  by writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="gsm_framc" protect="rw">
        <comment>GSM framc read  register</comment>
        <bits access="rw" name="rd_enable" pos="20" rst="0x0">
          <comment>Read enable register.
This bit should be set first when read the value of GSM counter, then rd_enable bit cleared by hardware after locked the GSM counter.</comment>
        </bits>
        <bits access="r" name="framc" pos="16:0" rst="0x1">
          <comment>GSM framc</comment>
        </bits>
      </reg>
      <reg name="nb_framc" protect="rw">
        <comment>NB framc read  register</comment>
        <bits access="rw" name="rd_enable" pos="20" rst="0x0">
          <comment>Read enable register.
This bit should be set first when read the value of NB counter, then rd_enable bit cleared by hardware after locked the NB counter.</comment>
        </bits>
        <bits access="r" name="framc" pos="16:0" rst="0x1">
          <comment>NB framc</comment>
        </bits>
      </reg>
      <reg name="eliminat_jitter" protect="rw">
        <comment>Eliminate jitter configuration register</comment>
        <bits access="rw" name="eliminat_time" pos="23:16" rst="0x1">
          <comment>Eliminate jitter delay register</comment>
        </bits>
        <bits access="rw" name="elimiate_en" pos="15:0" rst="0x0">
          <comment>Emilinate the jitter from awake signal when writing 1 to correspond bits.</comment>
        </bits>
      </reg>
      <reg name="gsm_en_sel" protect="rw">
        <bits access="rw" name="select" pos="0" rst="0x0">
          <comment>GGE low power Scheme selection signal
0: use RDA8909 LP  Scheme
1: use IDLE module of LP Scheme</comment>
        </bits>
      </reg>
      <reg name="nb_en_sel" protect="rw">
        <bits access="rw" name="select" pos="0" rst="0x0">
          <comment>NB low power Scheme selection signal
0: use RDA8909 LP  Scheme
1: use IDLE module of LP Scheme</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sw" protect="rw">
        <bits access="rw" name="dsipll" pos="6" rst="0x0">
          <comment>1:disbale PLL
0:enable PLL</comment>
        </bits>
        <bits access="rw" name="mempll" pos="5" rst="0x0">
          <comment>1:disable PLL
0:enbale PLL</comment>
        </bits>
        <bits access="rw" name="usbpll" pos="4" rst="0x0">
          <comment>1:disable PLL
0:enable PLL</comment>
        </bits>
        <bits access="rw" name="audiopll" pos="3" rst="0x0">
          <comment>1:disable PLL
0:enable PLL</comment>
        </bits>
        <bits access="rw" name="apll" pos="2" rst="0x0">
          <comment>1:disable PLL
0:enable PLL</comment>
        </bits>
        <bits access="rw" name="bbpll2" pos="1" rst="0x0">
          <comment>1:disable PLL
0:enable PLL</comment>
        </bits>
        <bits access="rw" name="bbpll1" pos="0" rst="0x0">
          <comment>1:disable PLL
0:enable PLL</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sw_set" protect="rw">
        <bits access="rs" name="pdpllswset" pos="6:0" rst="0x0">
          <comment>set corresponding bits of  PD_PLL_SW
0:Invariance of corresponding bits
1:set 1 of corresponding bits</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sw_clr" protect="rw">
        <bits access="rc" name="pdpllswclr" pos="6:0" rst="0x0">
          <comment>clean corresponding bits of PD_PLL_SW
0:Invariance of corresponding bits
1:clean corresponding bits</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sel" protect="rw">
        <bits access="rw" name="dsipll" pos="6" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit6 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="mempll" pos="5" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit5 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="usbpll" pos="4" rst="0x0">
          <comment>select hardware signal or software register to control the PLL switch
1:software register(bit4 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="audiopll" pos="3" rst="0x0">
          <comment>select hardware signal or software register to control the PLL switch
1:software register(bit3 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="apll" pos="2" rst="0x0">
          <comment>select hardware signal or software register to control the PLL switch
1:software register(bit2 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="bbpll2" pos="1" rst="0x0">
          <comment>select hardware signal or software register to control the PLL switch
1:software register(bit1 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
        <bits access="rw" name="bbpll1" pos="0" rst="0x0">
          <comment>select hardware signal or software register to control the PLL switch
1:software register(bit0 of PD_PLL_SW)
0:hardware signal(IDLE module of pd_pll signal invert)</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sel_set" protect="rw">
        <bits access="rs" name="pdpllselset" pos="6:0" rst="0x0">
          <comment>set corresponding bits of PD_PLL_SEL
0:Invariance of corresponding bits
1:set 1 of corresponding bits</comment>
        </bits>
      </reg>
      <reg name="pd_pll_sel_clr" protect="rw">
        <bits access="rc" name="pdpllselclr" pos="6:0" rst="0x0">
          <comment>clean corresponding bits of PD_PLL_SEL
0:Invariance of corresponding bits
1:clean corresponding bits</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sw" protect="rw">
        <bits access="rw" name="dsipll" pos="6" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="mempll" pos="5" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="usbpll" pos="4" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="audiopll" pos="3" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="apll" pos="2" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="bbpll2" pos="1" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
        <bits access="rw" name="bbpll1" pos="0" rst="0x0">
          <comment>1:disable PLL output clk
0:enable PLL output clk</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sw_set" protect="rw">
        <bits access="rs" name="idlecgswset" pos="6:0" rst="0x0">
          <comment>set corresponding bits of IDLE_CG_SW
0:Invariance of corresponding bits
1:set 1 of corresponding bits</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sw_clr" protect="rw">
        <bits access="rc" name="idlecgswclr" pos="6:0" rst="0x0">
          <comment>clean corresponding bits of IDLE_CG_SW
0:Invariance of corresponding bits
1:clean corresponding bits</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sel" protect="rw">
        <bits access="rw" name="dsipll" pos="6" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit6 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="mempll" pos="5" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit5 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="usbpll" pos="4" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit4 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="audiopll" pos="3" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit3 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="apll" pos="2" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit2 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="bbpll2" pos="1" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit1 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
        <bits access="rw" name="bbpll1" pos="0" rst="0x0">
          <comment>select hardware signal or software register to control the PLL output clk switch
1:software register(bit0 of IDLE_CG_SW)
0:hardware signal(IDLE module of idle_cg signal invert)</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sel_set" protect="rw">
        <bits access="rs" name="idlecgselset" pos="6:0" rst="0x0">
          <comment>set corresponding bits of IDLE_CG_SEL
0:Invariance of corresponding bits
1:set 1 of corresponding bits</comment>
        </bits>
      </reg>
      <reg name="idle_cg_sel_clr" protect="rw">
        <bits access="rc" name="idlecgselclr" pos="6:0" rst="0x0">
          <comment>clean corresponding bits of IDLE_CG_SEL
0:Invariance of corresponding bits
1:clean corresponding bits</comment>
        </bits>
      </reg>
      <reg name="rf_idle_enable_sw" protect="rw">
        <bits access="rw" name="rfidleenablesw" pos="0" rst="0x0">
          <comment>1:control the RF_DIG enter in IDLE
0:control the RF_DIG exit to the IDLE</comment>
        </bits>
      </reg>
      <reg name="rf_idle_enable_sel" protect="rw">
        <bits access="rw" name="rfidleenablesel" pos="0" rst="0x1">
          <comment>select the hardware signal or software register to control the RF_DIG enter in or extit to IDLE model.
1:software register(RF_IDLE_ENABLE_SW)
0:hardware signal( pow_on signal invert of IDLE module)</comment>
        </bits>
      </reg>
      <reg name="idle_res0" protect="rw">
        <comment>IDLE moduel reserved register 0</comment>
      </reg>
      <reg name="idle_res1" protect="rw">
        <comment>IDLE moduel reserved register 1</comment>
      </reg>
      <reg name="idle_res2" protect="rw">
        <comment>IDLE moduel reserved register 2</comment>
      </reg>
      <reg name="idle_res3" protect="rw">
        <comment>IDLE moduel reserved register 3</comment>
      </reg>
      <reg name="idle_res4" protect="rw">
        <comment>IDLE moduel reserved register 4</comment>
      </reg>
      <reg name="idle_res5" protect="rw">
        <comment>IDLE moduel reserved register 5</comment>
      </reg>
      <reg name="idle_res6" protect="rw">
        <comment>IDLE moduel reserved register 6</comment>
      </reg>
      <reg name="idle_res7" protect="rw">
        <comment>IDLE moduel reserved register 7</comment>
      </reg>
      <reg name="mem_ema_cfg" protect="rw">
        <bits access="rw" name="rftpd_rmb" pos="9:6" rst="0x2">
          <comment>RFTPD type EMA signal</comment>
        </bits>
        <bits access="rw" name="rftpd_rmeb" pos="5" rst="0x0">
          <comment>RFTPD type EMA signal</comment>
        </bits>
        <bits access="rw" name="rftpd_rma" pos="4:1" rst="0x2">
          <comment>RFTPD type EMA signal</comment>
        </bits>
        <bits access="rw" name="rftpd_rmea" pos="0" rst="0x0">
          <comment>RFTPD type EMA signal</comment>
        </bits>
      </reg>
      <reg name="uart_ctrl" protect="rw">
        <bits access="rw" name="rst_ctrl_uart" pos="1" rst="0x1">
          <comment>UART module reset control:
0: reset
1: reset release</comment>
        </bits>
        <bits access="rw" name="enable_clk_uart" pos="0" rst="0x1">
          <comment>UART module clock control:
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="ddr_latch" protect="rw">
        <bits access="rw" name="psram_latch" pos="1" rst="0x0">
          <comment>PSRAM IO LATCH:
0: release PSRAM PAD
1: no release PSRAM PAD.This bit will be set &quot;1&quot; by hardware when AP power domain was shut-down.Software should write this bit to &quot;0&quot; after PSRAM initialization when AP wake-up from deep sleep.</comment>
        </bits>
        <bits access="rw" name="lpddr_latch" pos="0" rst="0x0">
          <comment>LPDDR IO LATCH:
0: release LPDDR PAD
1: no release LPDDR PAD.This bit will be set &quot;1&quot; by hardware when AP power domain was shut-down.Software should write this bit to &quot;0&quot; after LPDDR initialization when AP wake-up from deep sleep.</comment>
        </bits>
      </reg>
      <reg name="pad_ctrl" protect="rw">
        <bits access="rw" name="pad_misc_idle_wpdi" pos="27" rst="0x0"/>
        <bits access="rw" name="pad_osc_32k_drv" pos="26:25" rst="0x2"/>
        <bits access="rw" name="pad_osc_32k_se" pos="24" rst="0x0"/>
        <bits access="rw" name="pad_osc_32k_wpus" pos="23" rst="0x0"/>
        <bits access="rw" name="pad_gpio_6_pull_frc" pos="22" rst="0x0"/>
        <bits access="rw" name="pad_gpio_6_drv" pos="21:20" rst="0x2"/>
        <bits access="rw" name="pad_gpio_6_pull_dowe" pos="19" rst="0x0"/>
        <bits access="rw" name="pad_gpio_6_pull_up" pos="18" rst="0x0"/>
        <bits access="rw" name="pad_gpio_6_se" pos="17" rst="0x0"/>
        <bits access="rw" name="pad_gpio_6_wpus" pos="16" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_out" pos="15" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_out_frc" pos="14" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_pull_frc" pos="13" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_drv" pos="12:11" rst="0x2"/>
        <bits access="rw" name="pad_chip_pd_pull_dowe" pos="10" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_pull_up" pos="9" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_se" pos="8" rst="0x0"/>
        <bits access="rw" name="pad_chip_pd_wpus" pos="7" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_rxd_pull_frc" pos="6" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_rxd_drv" pos="5:4" rst="0x2"/>
        <bits access="rw" name="pad_uart_1_rxd_pull_dowe" pos="3" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_rxd_pull_up" pos="2" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_rxd_se" pos="1" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_rxd_wpus" pos="0" rst="0x0"/>
      </reg>
      <reg name="idle_res8" protect="rw">
        <comment>IDLE moduel reserved register 8</comment>
      </reg>
      <reg name="idle_res9" protect="rw">
        <comment>IDLE moduel reserved register 9</comment>
      </reg>
      <reg name="idle_res10" protect="rw">
        <comment>IDLE moduel reserved register 10</comment>
      </reg>
      <reg name="idle_res11" protect="rw">
        <comment>IDLE moduel reserved register 11</comment>
      </reg>
      <reg name="pad_ctrl_uart_txd" protect="rw">
        <bits access="rw" name="pad_uart_1_txd_out" pos="8" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_out_frc" pos="7" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_pull_frc" pos="6" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_drv" pos="5:4" rst="0x2"/>
        <bits access="rw" name="pad_uart_1_txd_pull_dowe" pos="3" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_pull_up" pos="2" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_se" pos="1" rst="0x0"/>
        <bits access="rw" name="pad_uart_1_txd_wpus" pos="0" rst="0x0"/>
      </reg>
      <reg name="mon_sel" protect="rw">
        <bits access="rw" name="mon15_sel" pos="31:30" rst="0x0">
          <comment>mon15_sel:
00: select nb_en.
01: select awk_sys_valid.
10: select awake[7].
11: select target_timer_stat[1].</comment>
        </bits>
        <bits access="rw" name="mon14_sel" pos="29:28" rst="0x0">
          <comment>mon14_sel:
00: select gsm_en.
01: select wcn_chip_pd.
10: select awake[6].
11: select target_timer_stat[0].</comment>
        </bits>
        <bits access="rw" name="mon13_sel" pos="27:26" rst="0x0">
          <comment>mon13_sel:
00: select wake_timer.
01: select wcn_pd_xtal.
10: select awake[5].
11: select target_timer_enable.</comment>
        </bits>
        <bits access="rw" name="mon12_sel" pos="25:24" rst="0x0">
          <comment>mon12_sel:
00: select timer_en_nb.
01: select wcn_pd_pll.
10: select awake[4].
11: select nb_frame_int.</comment>
        </bits>
        <bits access="rw" name="mon11_sel" pos="23:22" rst="0x0">
          <comment>mon11_sel:
00: select timer_en_gsm.
01: select wcn_idle_cg.
10: select awake[3].
11: nb_lp_pu_done.</comment>
        </bits>
        <bits access="rw" name="mon10_sel" pos="21:20" rst="0x0">
          <comment>mon10_sel:
00: select timer_en_ltem2.
01: select nb_en_sel.
10: select awake[2].
11: select nb_lp_sf_slowrunning.</comment>
        </bits>
        <bits access="rw" name="mon9_sel" pos="19:18" rst="0x0">
          <comment>mon9_sel:
00: select timer_en_ltem1.
01: select gsm_en_sel.
10: select awake[1].
11: select nb_fint.</comment>
        </bits>
        <bits access="rw" name="mon8_sel" pos="17:16" rst="0x0">
          <comment>mon8_sel:
00: select idst_nb_timer.
01: select idle_chip_pd.
10: select awake[0].
11: select gsm_frame_int.</comment>
        </bits>
        <bits access="rw" name="mon7_sel" pos="15:14" rst="0x0">
          <comment>mon7_sel:
00: select idst_gsm_timer
01: select idle_pd_xtal.
10: select awk_self.
11: gsm_lp_pu_done.</comment>
        </bits>
        <bits access="rw" name="mon6_sel" pos="13:12" rst="0x0">
          <comment>mon6_sel:
00: select idst_ltem2_timer.
01: select idle_pd_pll.
10: select idst_gsm_ltem_timer.
11: select gsm_lp_sf_slowrunning.</comment>
        </bits>
        <bits access="rw" name="mon5_sel" pos="11:10" rst="0x0">
          <comment>mon5_sel:
00: select idst_ltem1_timer.
01: select idle_idle_cg.
10: select awk_gsm_ltem_timner.
11: select gsm_fint.</comment>
        </bits>
        <bits access="rw" name="mon4_sel" pos="9:8" rst="0x0">
          <comment>mon4_sel:
00: select idct_nb_timer.
01: select pow_on.
10: select idst_sys.
11: select rstctrl_uart.</comment>
        </bits>
        <bits access="rw" name="mon3_sel" pos="7:6" rst="0x0">
          <comment>mon3_sel:
00: select idct_gsm_timer.
01: select idct_sys_valid.
10: select nb_lp_pu_reach.
11: select clken_uart.</comment>
        </bits>
        <bits access="rw" name="mon2_sel" pos="5:4" rst="0x0">
          <comment>mon2_sel:
00: select idct_ltem2_timer.
01: select idct_ap.
10: select gsm_lp_pu_reach.
11: select psram_latch_reg.</comment>
        </bits>
        <bits access="rw" name="mon1_sel" pos="3:2" rst="0x0">
          <comment>mon1_sel:
00: select idct_ltem1_timer
01: select idct_cp.
10: select osw2_awk
11: select lpddr_latch_reg</comment>
        </bits>
        <bits access="rw" name="mon0_sel" pos="1:0" rst="0x1">
          <comment>mon0_sel:
00: select idct_timer.
01: select ltem1_fint.
10: select osw1_awk.
11: select ltem2_fint</comment>
        </bits>
      </reg>
      <reg name="mon_sel_set" protect="rw">
        <comment>set corresponding bits of MON_SEL
0:Invariance of corresponding bits
1:set corresponding bits</comment>
      </reg>
      <reg name="mon_sel_clr" protect="rw">
        <comment>clear corresponding bits of MON_SEL
0:Invariance of corresponding bits
1:clear corresponding bits</comment>
      </reg>
      <reg name="target_timer" protect="rw">
        <comment>Interrupt generated when the reference 32K counter reach to this register value.</comment>
      </reg>
      <reg name="target_timer_en" protect="rw">
        <bits access="rw" name="disable_target_timer" pos="0" rst="0x0">
          <comment>1: disable target timer.
0: enable</comment>
        </bits>
      </reg>
      <reg name="target_value_lock" protect="rw">
        <comment>The locked value of reference 32K when interrupt generated.</comment>
      </reg>
      <reg name="target_timer_stat" protect="rw">
        <bits access="r" name="timer_stat_32k" pos="1" rst="0x0">
          <comment>Indicat the state of target timer in 32K clock domain</comment>
        </bits>
        <bits access="r" name="timer_stat_122m" pos="0" rst="0x0">
          <comment>Indicate the state of target timer in 122.88M clock domain</comment>
        </bits>
      </reg>
      <reg name="slow_sys_clk_sel_hwen" protect="rw">
        <bits access="rw" name="slow_sys_clk_sel_hwen" pos="0" rst="0x0">
          <comment>0:SLOW_CLK and system clk selected by software bit conrtol
1:SLOW_CLK and system clk select by hareware signal control</comment>
        </bits>
      </reg>
      <reg name="slow_clk_sel_hwen" protect="rw">
        <bits access="rw" name="slow_clk_sel_hwen" pos="0" rst="0x0">
          <comment>0:SLOW_CLK selected(between 26M and 32k) by software bit control
1:SLOW_CLK selected(between 26M and 32k) by hareware signal control</comment>
        </bits>
      </reg>
      <reg name="sleep_prot_time" protect="rw">
        <bits access="rw" name="prot_time" pos="7:0" rst="0x9">
          <comment>The minimum threshold of deep sleep, to ensure PMIC have complete deep sleep in and deep sleep out.</comment>
        </bits>
      </reg>
      <reg name="h_val_sel" protect="rw">
        <bits access="rw" name="h_val_sel" pos="0" rst="0x0">
          <comment>change H_VAL's time
1:pd_xtal
0:chip_pd</comment>
        </bits>
      </reg>
      <reg name="tp_sta" protect="rw">
        <bits access="r" name="tp_sta2" pos="2" rst="0x0">
          <comment>1:tstamp_i[1]
0:tstamp_i[0]</comment>
        </bits>
        <bits access="r" name="tp_sta1" pos="1" rst="0x0">
          <comment>1:perip tstamp
0:inner tstamp</comment>
        </bits>
        <bits access="rc" name="tp_sta0" pos="0" rst="0x0">
          <comment>1:tstamp saved
0:nothing</comment>
        </bits>
      </reg>
      <reg name="ltem1_framls_rel" protect="rw">
        <comment>LTE-M framl ref adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="ltem1_framls_ref" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="ltem1_framls_abs" protect="rw">
        <comment>LTE-M framl abs adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="ltem1_framls_abs" pos="15:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="ltem2_framls_rel" protect="rw">
        <comment>LTE-M framl ref adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="ltem2_framls_ref" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="ltem2_framls_abs" protect="rw">
        <comment>LTE-M framl abs adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0:postive
1:negative</comment>
        </bits>
        <bits access="rw" name="ltem2_framls_abs" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="ltem1_load_en" protect="rw">
        <comment>LTE-M1 LOAD change register</comment>
        <bits access="rw" name="ltem1_load_en" pos="0" rst="0x0">
          <comment>0:load_timer from lps
1:TP load</comment>
        </bits>
      </reg>
      <reg name="ltem2_load_en" protect="rw">
        <comment>LTE-M2 LOAD change register</comment>
        <bits access="rw" name="ltem2_load_en" pos="0" rst="0x0">
          <comment>0:load_timer from lps
1:TP load</comment>
        </bits>
      </reg>
      <reg name="ltem2_fint_en" protect="rw">
        <comment>sub-frame interrupt enable register</comment>
        <bits access="rw" name="lte_m2_fint_enable" pos="9:0" rst="0x3ff">
          <comment>Each bit corresponds to 10 sub-frame, sub-frame interrupt will be sent to CPU when correspond bit is enabled.</comment>
        </bits>
      </reg>
      <reg name="gnss_tstamp_en" protect="rw">
        <comment>sub-frame interrupt enable register</comment>
        <bits access="rw" name="em_latch_en" pos="2" rst="0x0">
          <comment>1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="cpu_latch_en" pos="1" rst="0x0">
          <comment>1:enable
0:disable</comment>
        </bits>
        <bits access="rw" name="rtc_latch_en" pos="0" rst="0x0">
          <comment>1:enable
0:disable</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem1_fhl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 high-level frame locked register</comment>
        <bits access="r" name="gnss_rtc_ltem1_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem1_fll" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 frame locked register</comment>
        <bits access="r" name="gnss_rtc_ltem1_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem1_fcl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 counter locked register</comment>
        <bits access="r" name="gnss_rtc_ltem1_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem2_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_rtc_ltem2_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem2_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_rtc_ltem2_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem2_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_rtc_ltem2_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem3_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_rtc_ltem3_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem3_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_rtc_ltem3_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_rtc_ltem3_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_rtc_ltem3_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem1_fhl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 high-level frame locked register</comment>
        <bits access="r" name="gnss_cpu_ltem1_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem1_fll" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 frame locked register</comment>
        <bits access="r" name="gnss_cpu_ltem1_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem1_fcl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 counter locked register</comment>
        <bits access="r" name="gnss_cpu_ltem1_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem2_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_cpu_ltem2_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem2_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_cpu_ltem2_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem2_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_cpu_ltem2_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem3_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_cpu_ltem3_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem3_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_cpu_ltem3_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_ltem3_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_cpu_ltem3_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem1_fhl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 high-level frame locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem1_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem1_fll" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 frame locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem1_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem1_fcl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 counter locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem1_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem2_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem2_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem2_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem2_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem2_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem2_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem3_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem3_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem3_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem3_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_cpu_rtc_ltem3_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_cpu_rtc_ltem3_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem1_fhl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 high-level frame locked register</comment>
        <bits access="r" name="gnss_em_ltem1_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem1_fll" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 frame locked register</comment>
        <bits access="r" name="gnss_em_ltem1_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem1_fcl" protect="rw">
        <comment>GNSS_CAPTURE_LTE-M1 counter locked register</comment>
        <bits access="r" name="gnss_em_ltem1_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem2_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_em_ltem2_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem2_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_em_ltem2_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem2_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_em_ltem2_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem3_fhl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 high-level frame lock register</comment>
        <bits access="r" name="gnss_em_ltem3_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem3_fll" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 frame locked register</comment>
        <bits access="r" name="gnss_em_ltem3_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="gnss_em_ltem3_fcl" protect="rw">
        <comment>GNSS CAPTURE LTE-M2 counter locked register</comment>
        <bits access="r" name="gnss_em_ltem3_fcl" pos="17:0" rst="0x4">
          <comment>LTE-M counter locked value</comment>
        </bits>
      </reg>
      <reg name="ltem3_load_en" protect="rw">
        <comment>LTE-M3 LOAD change register</comment>
        <bits access="rw" name="ltem3_load_en" pos="0" rst="0x0"/>
      </reg>
      <reg name="idl_fn_ltem3" protect="rw">
        <comment>IDLE LTEM3 frame register</comment>
        <bits access="r" name="idfn_rad_ltem3" pos="31:4" rst="0x0">
          <comment>Number of frames ltem3 sleeped</comment>
        </bits>
        <bits access="r" name="idfn_sub_ltem3" pos="3:0" rst="0x0">
          <comment>Number of sub-frames ltem3 sleeped.</comment>
        </bits>
      </reg>
      <reg name="ltem3_frame_inten" protect="rw">
        <comment>LTEM3 frame interrupt enable register</comment>
        <bits access="rw" name="ltem3_frame3_irq_en" pos="2" rst="0x0">
          <comment>ltem3_frame3_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem3_frame2_irq_en" pos="1" rst="0x0">
          <comment>ltem3_frame2_irq enable
1: enable
0: disable</comment>
        </bits>
        <bits access="rw" name="ltem3_frame1_irq_en" pos="0" rst="0x0">
          <comment>ltem3_frame1_irq enable
1: enable
0: disable</comment>
        </bits>
      </reg>
      <reg name="ltem3_frame_int_sta" protect="rw">
        <comment>LTEM3 interrupt state register</comment>
        <bits access="rc" name="ltem3_frame_int_sta" pos="2:0" rst="0x0">
          <comment>cleared by writing 1 to correspond bit</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_hfn" protect="rw">
        <comment>LTEM3 high-level frame number register</comment>
        <bits access="rw" name="ltem3_cfsr_hfn" pos="21:0" rst="0x0">
          <comment>LTEM3 high-level frame number value</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_fn" protect="rw">
        <bits access="rw" name="ltem3_cfsr_rad" pos="13:4" rst="0x0">
          <comment>LTE-M3 frame number</comment>
        </bits>
        <bits access="rw" name="ltem3_cfsr_sub" pos="3:0" rst="0x0">
          <comment>LTE-M3 sub-frame number</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsrs" protect="rw">
        <comment>LTE-M3 frame offset register</comment>
        <bits access="rw" name="active_time3_cfsr" pos="25" rst="0x0">
          <comment>frame adjust time
0: adjust at next frame interrupt
1: adjust frame immetiately</comment>
        </bits>
        <bits access="rw" name="adjust_direct3_cfsr" pos="24" rst="0x0">
          <comment>frame adjust direction
0: postive
1: negative</comment>
        </bits>
        <bits access="rw" name="ltem3_cfsrs" pos="23:0" rst="0x0">
          <comment>LTE-M3 frame offest value
(Adjust frame offset B, there are two case: if adjust direction is 0, write b+1 to this register then current frame plus this value when frame interrupt occurred. otherwise write b-1 into this register then current frame minus this value when frame interrupt occurred.)</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_rdh" protect="rw">
        <comment>LTE-M3 high-level frame read register</comment>
        <bits access="r" name="ltem3_cfsr_rdh" pos="21:0" rst="0x0">
          <comment>LTE-M3 high-level frame value</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_rdl" protect="rw">
        <comment>LTE-M3 frame read register</comment>
        <bits access="r" name="ltem3_cfsr_rdl_rad" pos="13:4" rst="0x0">
          <comment>LTE-M3 radio frame value</comment>
        </bits>
        <bits access="r" name="ltem3_cfsr_rdl_sub" pos="3:0" rst="0x0">
          <comment>LTE-M3 sub-frame value</comment>
        </bits>
      </reg>
      <reg name="ltem3_framc" protect="rw">
        <comment>LTE-M3 counter</comment>
        <bits access="r" name="lframc3" pos="15:0" rst="0x1">
          <comment>LTE-M3 counter value</comment>
        </bits>
      </reg>
      <reg name="ltem3_framl" protect="rw">
        <comment>LTE-M3 frame length register</comment>
        <bits access="rw" name="lframl3" pos="15:0" rst="0x7800">
          <comment>LTE-M3 frame length</comment>
        </bits>
      </reg>
      <reg name="ltem3_framls" protect="rw">
        <comment>LTE-M3 frame length adjust register</comment>
        <bits access="rw" name="active_time3_framls" pos="16" rst="0x0">
          <comment>adjust time
0: adjust immetiately
1:  adjust at next ltem frame interrupt</comment>
        </bits>
        <bits access="rw" name="lframls3" pos="15:0" rst="0x0">
          <comment>LTE-M3 adjuste frame length.
current Ltem frame length load the register when write happens,then return the LFRAML at the time of lte frame interrupt arrivals.</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_tph" protect="rw">
        <comment>LTE-M3 radio frame value time stamp register</comment>
        <bits access="rw" name="ltem3_cfsr_tph" pos="21:0" rst="0x0">
          <comment>LTE-M3 high-level frame value time stamp register</comment>
        </bits>
      </reg>
      <reg name="ltem3_cfsr_tpl" protect="rw">
        <comment>LTE-M3 sub-frame time stamp register</comment>
        <bits access="rw" name="ltem3_cfsr_tpl" pos="13:0" rst="0x0">
          <comment>LTE-M3 frame stamp value</comment>
        </bits>
      </reg>
      <reg name="ltem3_framc_tp" protect="rw">
        <comment>LTE-M3 counter time stamp register</comment>
        <bits access="rw" name="ltem3_framc_tp" pos="15:0" rst="0x1">
          <comment>LTE-M3 stamp counter</comment>
        </bits>
      </reg>
      <reg name="ltem3_framls_rel" protect="rw">
        <comment>LTE-M framl ref adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="ltem3_framls_ref" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="ltem3_framls_abs" protect="rw">
        <comment>LTE-M framl abs adjust register</comment>
        <bits access="rw" name="adjust_direct" pos="16" rst="0x0">
          <comment>adjust direction
0: postive
1:  negative</comment>
        </bits>
        <bits access="rw" name="ltem3_framls_abs" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="lte3_fint_dly1" protect="rw">
        <comment>LTEM3 frame interrupt delay register 1</comment>
        <bits access="rw" name="delay3_time1" pos="15:0" rst="0x1">
          <comment>LTE-M3 frame interrupt delay, take ltem2_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem3_fint_dly2" protect="rw">
        <comment>LTEM3 frame interrupt delay register 2</comment>
        <bits access="rw" name="delay3_time2" pos="15:0" rst="0x1">
          <comment>LTE-M3 frame interrupt delay, take ltem3_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem3_fint_dly3" protect="rw">
        <comment>LTEM1 interrupt delay setting register 3</comment>
        <bits access="rw" name="delay3_time3" pos="15:0" rst="0x1">
          <comment>LTE-M3 frame interrupt delay,
take ltem3_framc as a reference.</comment>
        </bits>
      </reg>
      <reg name="ltem3_fint_en" protect="rw">
        <comment>sub-frame interrupt enable register</comment>
        <bits access="rw" name="lte_m3_fint_enable" pos="9:0" rst="0x3ff">
          <comment>Each bit corresponds to 10 sub-frame, sub-frame interrupt will be sent to CPU when correspond bit is enabled.</comment>
        </bits>
      </reg>
      <reg name="ltem3_fhl" protect="rw">
        <comment>LTE-M high-level frame locked register</comment>
        <bits access="r" name="ltem3_fhl" pos="21:0" rst="0x0">
          <comment>LTE-M high-level frame locked value,
lock the register LTEM_CFSR_HFN.</comment>
        </bits>
      </reg>
      <reg name="ltem3_fll" protect="rw">
        <comment>LTE-M frame locked register</comment>
        <bits access="r" name="ltem3_fll" pos="13:0" rst="0x0">
          <comment>LTE-M frame locked value, lock the register
LTEM_CFSR_FN</comment>
        </bits>
      </reg>
      <reg name="ltem3_fcl" protect="rw">
        <comment>LTE-M counter locked register</comment>
        <bits access="r" name="ltem3_fcl" pos="15:0" rst="0x1">
          <comment>LTE-M couner locked value</comment>
        </bits>
      </reg>
      <reg name="idle_frame_ltem3" protect="rw">
        <comment>IDLE LTE-M3 frame configuration register</comment>
        <bits access="rw" name="frame3_conf" pos="24" rst="0x0">
          <comment>enable(this bit cleared automatically after the frame interrupt generated)
0: disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="frame3_cfsr" pos="21:0" rst="0x0">
          <comment>interrupt frame number
interrupt occurred when current frame reach this register.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51507000" name="IDLE_TIMER" type="IDLE_TIMER"/>
  </archive>
  <archive relative="monitor.xml">
    <module category="System" name="MONITOR">
      <reg name="mon_sel0" protect="rw">
        <bits access="rw" name="mon_sel0" pos="10:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="mon_sel1" protect="rw">
        <bits access="rw" name="mon_sel1" pos="10:0" rst="0x1">
          <comment>1</comment>
        </bits>
      </reg>
      <reg name="mon_sel2" protect="rw">
        <bits access="rw" name="mon_sel2" pos="10:0" rst="0x2">
          <comment>2</comment>
        </bits>
      </reg>
      <reg name="mon_sel3" protect="rw">
        <bits access="rw" name="mon_sel3" pos="10:0" rst="0x3">
          <comment>3</comment>
        </bits>
      </reg>
      <reg name="mon_sel4" protect="rw">
        <bits access="rw" name="mon_sel4" pos="10:0" rst="0x4">
          <comment>4</comment>
        </bits>
      </reg>
      <reg name="mon_sel5" protect="rw">
        <bits access="rw" name="mon_sel5" pos="10:0" rst="0x5">
          <comment>5</comment>
        </bits>
      </reg>
      <reg name="mon_sel6" protect="rw">
        <bits access="rw" name="mon_sel6" pos="10:0" rst="0x6">
          <comment>6</comment>
        </bits>
      </reg>
      <reg name="mon_sel7" protect="rw">
        <bits access="rw" name="mon_sel7" pos="10:0" rst="0x7">
          <comment>7</comment>
        </bits>
      </reg>
      <reg name="mon_con0" protect="rw">
        <bits access="rw" name="mon_con0" pos="2:0" rst="0x0">
          <comment>monitor_o[0]
3'h0: 0
3'h1: 1
3'h2: 2
3'h3: 3
3'h4: 4
3'h5: 5
3'h6: 6
3'h7: 7</comment>
        </bits>
      </reg>
      <reg name="mon_con1" protect="rw">
        <bits access="rw" name="mon_con1" pos="2:0" rst="0x0">
          <comment>monitor_o[1]
3'h0: 0
3'h1: 1
3'h2: 2
3'h3: 3
3'h4: 4
3'h5: 5
3'h6: 6
3'h7: 7</comment>
        </bits>
      </reg>
      <reg name="mon_con2" protect="rw">
        <bits access="rw" name="mon_con2" pos="2:0" rst="0x0">
          <comment>monitor_o[2]
3'h0: 0
3'h1: 1
3'h2: 2
3'h3: 3
3'h4: 4
3'h5: 5
3'h6: 6
3'h7: 7</comment>
        </bits>
      </reg>
      <reg name="mon_con3" protect="rw">
        <bits access="rw" name="mon_con3" pos="2:0" rst="0x0">
          <comment>monitor_o[3]
3'h0: 0
3'h1: 1
3'h2: 2
3'h3: 3
3'h4: 4
3'h5: 5
3'h6: 6
3'h7: 7</comment>
        </bits>
      </reg>
      <reg name="mon_con4" protect="rw">
        <bits access="rw" name="mon_con4" pos="2:0" rst="0x0">
          <comment>monitor_o[4]
3'h0: 0
3'h1: 1
3'h2: 2
3'h3: 3
3'h4: 4
3'h5: 5
3'h6: 6
3'h7: 7</comment>
        </bits>
      </reg>
      <reg name="mon_con5" protect="rw">
        <bits access="rw" name="mon_con5" pos="2:0" rst="0x0">
          <comment>monitor_o[5]
3'h0: 0
3'h1: 1
3'h2: 2
3'h3: 3
3'h4: 4
3'h5: 5
3'h6: 6
3'h7: 7</comment>
        </bits>
      </reg>
      <reg name="mon_con6" protect="rw">
        <bits access="rw" name="mon_con6" pos="2:0" rst="0x0">
          <comment>monitor_o[6]
3'h0: 0
3'h1: 1
3'h2: 2
3'h3: 3
3'h4: 4
3'h5: 5
3'h6: 6
3'h7: 7</comment>
        </bits>
      </reg>
      <reg name="mon_con7" protect="rw">
        <bits access="rw" name="mon_con7" pos="2:0" rst="0x0">
          <comment>monitor_o[7]
3'h0: 0
3'h1: 1
3'h2: 2
3'h3: 3
3'h4: 4
3'h5: 5
3'h6: 6
3'h7: 7</comment>
        </bits>
      </reg>
      <reg name="mon_enable" protect="rw">
        <bits access="rw" name="mon_enable" pos="0" rst="0x0">
          <comment>
1
0</comment>
        </bits>
      </reg>
      <reg name="monitor_o" protect="rw">
        <bits access="r" name="monitor_signal" pos="7:0" rst="0x0">
          <comment>monitor output signal value.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51502000" name="MONITOR" type="MONITOR"/>
  </archive>
  <archive relative="sysmail.xml">
    <module category="System" name="CP_MAILBOX">
      <reg name="intgr0" protect="rw">
        <comment>power domain shutdown/on controled by hardware signal or sofeware register.</comment>
      </reg>
      <reg name="intstr0" protect="rw">
        <comment>sysmail0 interrupt bit set register</comment>
      </reg>
      <reg name="intcr0" protect="rw">
        <comment>sysmail0 interrupt clean register</comment>
      </reg>
      <reg name="intmr0" protect="rw">
        <comment>sysmail0 interrupt mask register</comment>
      </reg>
      <reg name="intsr0" protect="rw">
        <comment>sysmail0 interrupt status register</comment>
      </reg>
      <reg name="intmsr0" protect="rw">
        <comment>sysmail0 interrupt mask status register</comment>
      </reg>
      <hole size="64"/>
      <reg name="intgr1" protect="rw">
        <comment>sysmail1 Interrupt generate register</comment>
      </reg>
      <reg name="intstr1" protect="rw">
        <comment>sysmail1 interrupt bit set register</comment>
      </reg>
      <reg name="intcr1" protect="rw">
        <comment>sysmail1 interrupt clean register</comment>
      </reg>
      <reg name="intmr1" protect="rw">
        <comment>sysmail1 interrupt mask register</comment>
      </reg>
      <reg name="intsr1" protect="rw">
        <comment>sysmail1 interrupt status register</comment>
      </reg>
      <reg name="intmsr1" protect="rw">
        <comment>sysmail1 interrupt mask  status register</comment>
      </reg>
      <hole size="64"/>
      <reg name="intgr2" protect="rw">
        <comment>sysmail2 Interrupt generate register</comment>
      </reg>
      <reg name="intstr2" protect="rw">
        <comment>sysmail2 interrupt bit set register</comment>
      </reg>
      <reg name="intcr2" protect="rw">
        <comment>sysmail2 interrupt clean register</comment>
      </reg>
      <reg name="intmr2" protect="rw">
        <comment>sysmail2 interrupt mask register</comment>
      </reg>
      <reg name="intsr2" protect="rw">
        <comment>sysmail2 interrupt status register</comment>
      </reg>
      <reg name="intmsr2" protect="rw">
        <comment>sysmail2 interrupt mask  status register</comment>
      </reg>
      <hole size="64"/>
      <reg name="intgr3" protect="rw">
        <comment>sysmail3 Interrupt generate register</comment>
      </reg>
      <reg name="intstr3" protect="rw">
        <comment>sysmail3 interrupt bit set register</comment>
      </reg>
      <reg name="intcr3" protect="rw">
        <comment>sysmail3 interrupt clean register</comment>
      </reg>
      <reg name="intmr3" protect="rw">
        <comment>sysmail3 interrupt mask register</comment>
      </reg>
      <reg name="intsr3" protect="rw">
        <comment>sysmail3 interrupt status register</comment>
      </reg>
      <reg name="intmsr3" protect="rw">
        <comment>sysmail3 interrupt mask  status register</comment>
      </reg>
      <hole size="64"/>
      <reg name="intgr4" protect="rw">
        <comment>sysmail4 Interrupt generate register</comment>
      </reg>
      <reg name="intstr4" protect="rw">
        <comment>sysmail4 interrupt bit set register</comment>
      </reg>
      <reg name="intcr4" protect="rw">
        <comment>sysmail4 interrupt clean register</comment>
      </reg>
      <reg name="intmr4" protect="rw">
        <comment>sysmail4 interrupt mask register</comment>
      </reg>
      <reg name="intsr4" protect="rw">
        <comment>sysmail4 interrupt status register</comment>
      </reg>
      <reg name="intmsr4" protect="rw">
        <comment>sysmail4 interrupt mask  status register</comment>
      </reg>
      <hole size="64"/>
      <reg name="intgr5" protect="rw">
        <comment>sysmail5 Interrupt generate register</comment>
      </reg>
      <reg name="intstr5" protect="rw">
        <comment>sysmail5 interrupt bit set register</comment>
      </reg>
      <reg name="intcr5" protect="rw">
        <comment>sysmail5 interrupt clean register</comment>
      </reg>
      <reg name="intmr5" protect="rw">
        <comment>sysmail5 interrupt mask register</comment>
      </reg>
      <reg name="intsr5" protect="rw">
        <comment>sysmail5 interrupt status register</comment>
      </reg>
      <reg name="intmsr5" protect="rw">
        <comment>sysmail5 interrupt mask  status register</comment>
      </reg>
      <hole size="576"/>
      <reg name="sysmail0" protect="rw">
        </reg>
      <reg name="sysmail1" protect="rw">
        </reg>
      <reg name="sysmail2" protect="rw">
        </reg>
      <reg name="sysmail3" protect="rw">
        </reg>
      <reg name="sysmail4" protect="rw">
        </reg>
      <reg name="sysmail5" protect="rw">
        </reg>
      <reg name="sysmail6" protect="rw">
        </reg>
      <reg name="sysmail7" protect="rw">
        </reg>
      <reg name="sysmail8" protect="rw">
        </reg>
      <reg name="sysmail9" protect="rw">
        </reg>
      <reg name="sysmail10" protect="rw">
        </reg>
      <reg name="sysmail11" protect="rw">
        </reg>
      <reg name="sysmail12" protect="rw">
        </reg>
      <reg name="sysmail13" protect="rw">
        </reg>
      <reg name="sysmail14" protect="rw">
        </reg>
      <reg name="sysmail15" protect="rw">
        </reg>
      <reg name="sysmail16" protect="rw">
        </reg>
      <reg name="sysmail17" protect="rw">
        </reg>
      <reg name="sysmail18" protect="rw">
        </reg>
      <reg name="sysmail19" protect="rw">
        </reg>
      <reg name="sysmail20" protect="rw">
        </reg>
      <reg name="sysmail21" protect="rw">
        </reg>
      <reg name="sysmail22" protect="rw">
        </reg>
      <reg name="sysmail23" protect="rw">
        </reg>
      <reg name="sysmail24" protect="rw">
        </reg>
      <reg name="sysmail25" protect="rw">
        </reg>
      <reg name="sysmail26" protect="rw">
        </reg>
      <reg name="sysmail27" protect="rw">
        </reg>
      <reg name="sysmail28" protect="rw">
        </reg>
      <reg name="sysmail29" protect="rw">
        </reg>
      <reg name="sysmail30" protect="rw">
        </reg>
      <reg name="sysmail31" protect="rw">
        </reg>
      <hole size="1024"/>
      <reg name="sysmail32" protect="rw">
        </reg>
      <reg name="sysmail33" protect="rw">
        </reg>
      <reg name="sysmail34" protect="rw">
        </reg>
      <reg name="sysmail35" protect="rw">
        </reg>
      <reg name="sysmail36" protect="rw">
        </reg>
      <reg name="sysmail37" protect="rw">
        </reg>
      <reg name="sysmail38" protect="rw">
        </reg>
      <reg name="sysmail39" protect="rw">
        </reg>
      <reg name="sysmail40" protect="rw">
        </reg>
      <reg name="sysmail41" protect="rw">
        </reg>
      <reg name="sysmail42" protect="rw">
        </reg>
      <reg name="sysmail43" protect="rw">
        </reg>
      <reg name="sysmail44" protect="rw">
        </reg>
      <reg name="sysmail45" protect="rw">
        </reg>
      <reg name="sysmail46" protect="rw">
        </reg>
      <reg name="sysmail47" protect="rw">
        </reg>
      <reg name="sysmail48" protect="rw">
        </reg>
      <reg name="sysmail49" protect="rw">
        </reg>
      <reg name="sysmail50" protect="rw">
        </reg>
      <reg name="sysmail51" protect="rw">
        </reg>
      <reg name="sysmail52" protect="rw">
        </reg>
      <reg name="sysmail53" protect="rw">
        </reg>
      <reg name="sysmail54" protect="rw">
        </reg>
      <reg name="sysmail55" protect="rw">
        </reg>
      <reg name="sysmail56" protect="rw">
        </reg>
      <reg name="sysmail57" protect="rw">
        </reg>
      <reg name="sysmail58" protect="rw">
        </reg>
      <reg name="sysmail59" protect="rw">
        </reg>
      <reg name="sysmail60" protect="rw">
        </reg>
      <reg name="sysmail61" protect="rw">
        </reg>
      <reg name="sysmail62" protect="rw">
        </reg>
      <reg name="sysmail63" protect="rw">
        </reg>
      <hole size="1024"/>
      <reg name="sysmail64" protect="rw">
        </reg>
      <reg name="sysmail65" protect="rw">
        </reg>
      <reg name="sysmail66" protect="rw">
        </reg>
      <reg name="sysmail67" protect="rw">
        </reg>
      <reg name="sysmail68" protect="rw">
        </reg>
      <reg name="sysmail69" protect="rw">
        </reg>
      <reg name="sysmail70" protect="rw">
        </reg>
      <reg name="sysmail71" protect="rw">
        </reg>
      <reg name="sysmail72" protect="rw">
        </reg>
      <reg name="sysmail73" protect="rw">
        </reg>
      <reg name="sysmail74" protect="rw">
        </reg>
      <reg name="sysmail75" protect="rw">
        </reg>
      <reg name="sysmail76" protect="rw">
        </reg>
      <reg name="sysmail77" protect="rw">
        </reg>
      <reg name="sysmail78" protect="rw">
        </reg>
      <reg name="sysmail79" protect="rw">
        </reg>
      <reg name="sysmail80" protect="rw">
        </reg>
      <reg name="sysmail81" protect="rw">
        </reg>
      <reg name="sysmail82" protect="rw">
        </reg>
      <reg name="sysmail83" protect="rw">
        </reg>
      <reg name="sysmail84" protect="rw">
        </reg>
      <reg name="sysmail85" protect="rw">
        </reg>
      <reg name="sysmail86" protect="rw">
        </reg>
      <reg name="sysmail87" protect="rw">
        </reg>
      <reg name="sysmail88" protect="rw">
        </reg>
      <reg name="sysmail89" protect="rw">
        </reg>
      <reg name="sysmail90" protect="rw">
        </reg>
      <reg name="sysmail91" protect="rw">
        </reg>
      <reg name="sysmail92" protect="rw">
        </reg>
      <reg name="sysmail93" protect="rw">
        </reg>
      <reg name="sysmail94" protect="rw">
        </reg>
      <reg name="sysmail95" protect="rw">
        </reg>
    </module>
    <instance address="0x51506000" name="MAILBOX" type="CP_MAILBOX"/>
  </archive>
  <archive relative="pusch.xml">
    <module category="System" name="PUSCH">
      <reg name="ack_offset" protect="rw">
        <comment>ACK</comment>
        <bits access="rw" name="ack_offset" pos="3:0" rst="0x0">
          <comment>ACK</comment>
        </bits>
      </reg>
      <reg name="ri_offset" protect="rw">
        <comment>RIMCS</comment>
        <bits access="rw" name="ri_offset" pos="3:0" rst="0x0">
          <comment>RIMCS</comment>
        </bits>
      </reg>
      <reg name="cqi_offset" protect="rw">
        <comment>CQIMCS</comment>
        <bits access="rw" name="cqi_offset" pos="3:0" rst="0x0">
          <comment>CQIMCS</comment>
        </bits>
      </reg>
      <reg name="tbsize_init" protect="rw">
        <comment></comment>
        <bits access="rw" name="tbsize_init" pos="13:0" rst="0x0">
          <comment>PUSCHPUSCHCRCbit</comment>
        </bits>
      </reg>
      <reg name="tbsize" protect="rw">
        <comment></comment>
        <bits access="rw" name="tbsize" pos="13:0" rst="0x0">
          <comment>PUSCHPUSCHCRCbit</comment>
        </bits>
      </reg>
      <reg name="modulate" protect="rw">
        <comment></comment>
        <bits access="rw" name="modulate" pos="1:0" rst="0x0">
          <comment>00BPSK
01QPSK
1016QAM
1164QAM</comment>
        </bits>
      </reg>
      <reg name="redun_ver" protect="rw">
        <comment></comment>
        <bits access="rw" name="redun_ver" pos="1:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="lcrb" protect="rw">
        <comment>PUSCHPUSCH</comment>
        <bits access="rw" name="ini_sub_num" pos="26:16" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
        <bits access="rw" name="sub_num" pos="10:0" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
      </reg>
      <reg name="symbol_num" protect="rw">
        <comment>PUSCHPUSCH</comment>
        <bits access="rw" name="ru_num" pos="11:8" rst="0x0">
          <comment>RU</comment>
        </bits>
        <bits access="rw" name="ini_sym_num" pos="7:4" rst="0x0">
          <comment>PUSCHCAT1/CATM
1PUSCH DATA
CAT-NB1RU</comment>
        </bits>
        <bits access="rw" name="sym_num" pos="3:0" rst="0x0">
          <comment>PUSCHCAT1/CATM1
PUSCH DATACAT-NB
1RU</comment>
        </bits>
      </reg>
      <reg name="cqi_bit1" protect="rw">
        <comment>CQI</comment>
      </reg>
      <reg name="cqi_bit2" protect="rw">
        <comment>CQI</comment>
      </reg>
      <reg name="cqi_bit8_bitlen" protect="rw">
        <comment>CQI</comment>
        <bits access="rw" name="o_cqi_bitlen_min" pos="22:16" rst="0x0">
          <comment>CQI</comment>
        </bits>
        <bits access="rw" name="o_cqi_bitlen" pos="14:8" rst="0x0">
          <comment>CQI65</comment>
        </bits>
        <bits access="rw" name="cqi_bit8" pos="0" rst="0x0">
          <comment>CQI64</comment>
        </bits>
      </reg>
      <reg name="ri_bit_bitlen" protect="rw">
        <comment>RI</comment>
        <bits access="rw" name="o_ri_bitlen" pos="16" rst="0x0">
          <comment>RI</comment>
        </bits>
        <bits access="rw" name="ri_bit" pos="0" rst="0x0">
          <comment>RI</comment>
        </bits>
      </reg>
      <reg name="ack_bit_bitlen" protect="rw">
        <comment>ACK</comment>
        <bits access="rw" name="o_ack_bitlen" pos="26:24" rst="0x0">
          <comment>ACK4</comment>
        </bits>
        <bits access="rw" name="ack_bit" pos="3:0" rst="0x0">
          <comment>ACK</comment>
        </bits>
      </reg>
      <reg name="ack_mux_bundling" protect="rw">
        <comment>ACK</comment>
        <bits access="rw" name="bundling_flag" pos="2" rst="0x0">
          <comment>0FDDTDDHARQ-ACK
1TDDHARQ-ACK</comment>
        </bits>
        <bits access="rw" name="bundling_idx" pos="1:0" rst="0x0">
          <comment>TDD HARQ-ACK</comment>
        </bits>
      </reg>
      <reg name="pucch_format" protect="rw">
        <comment>PUCCH</comment>
        <bits access="rw" name="format" pos="2:0" rst="0x0">
          <comment>PUCCH
000~010RESERVED
0112
1002a
1012b
110~111RESERVED</comment>
        </bits>
      </reg>
      <reg name="prach_u" protect="rw">
        <comment>UU</comment>
        <bits access="rw" name="u_inv_value" pos="25:16" rst="0x0">
          <comment>U</comment>
        </bits>
        <bits access="rw" name="u_value" pos="9:0" rst="0x0">
          <comment>U</comment>
        </bits>
      </reg>
      <reg name="prach_cv" protect="rw">
        <comment>CV</comment>
        <bits access="rw" name="cv_value" pos="9:0" rst="0x0">
          <comment>CV</comment>
        </bits>
      </reg>
      <reg name="gold_init" protect="rw">
        <comment>GOLD</comment>
        <bits access="rw" name="gold_init" pos="30:0" rst="0x0">
          <comment>GOLD</comment>
        </bits>
      </reg>
      <reg name="pusch_ctrl" protect="rw">
        <comment></comment>
        <bits access="rw" name="pusch2dft_trig_en" pos="17" rst="0x0">
          <comment>1PUSCHULDFT
0PUSCHULDFT</comment>
        </bits>
        <bits access="rw" name="func_sel" pos="16:15" rst="0x0">
          <comment>00PUSCH
01PUCCH UCI
10PRACH
11NPUSCH1NPUSCH2PUSCH IP</comment>
        </bits>
        <bits access="rw" name="uci_en" pos="14" rst="0x0">
          <comment>FUNC_SELPUSCH UCIPUCCH UCIFUNC_SEL00PUSCH UCIFUNC_SEL01PUCCH UCI
0UCI
1UCI</comment>
        </bits>
        <bits access="rw" name="buf_index" pos="13:12" rst="0x0">
          <comment>PUSCH_BUFFERMEM
00PUSCH_BUF1
01PUSCH_BUF2
10PUSCH_BUF3
11PRACH_BUF</comment>
        </bits>
        <bits access="rw" name="pusch_buf_en" pos="11" rst="0x0">
          <comment>0PUSCH_BUFFER
1PUSCH_BUFFER</comment>
        </bits>
        <bits access="rw" name="zc_index" pos="9" rst="0x0">
          <comment>PRACHZC
0ZC139
1ZC839</comment>
        </bits>
        <bits access="rw" name="inver_en" pos="7" rst="0x0">
          <comment>0PUSCHCRCByte
1PUSCHCRCByte</comment>
        </bits>
        <bits access="rw" name="pusch_irqen" pos="5" rst="0x0">
          <comment>0LTE
1LTE</comment>
        </bits>
        <bits access="rw" name="scr_en" pos="4" rst="0x0">
          <comment>0PUSCH
1PUSCH</comment>
        </bits>
        <bits access="rw" name="int_en" pos="3" rst="0x0">
          <comment>0PUSCH
1PUSCH</comment>
        </bits>
        <bits access="rw" name="tb_rm_en" pos="2" rst="0x0">
          <comment>0PUSCHTurbo
1PUSCHTurbo</comment>
        </bits>
        <bits access="rw" name="crc_en" pos="1" rst="0x0">
          <comment>0PUSCHCRC
1PUSCHCRC</comment>
        </bits>
        <bits access="rw" name="fun_en" pos="0" rst="0x0">
          <comment>0LTE
1LTE</comment>
        </bits>
      </reg>
      <reg name="pusch_irq_flag" protect="rw">
        <comment></comment>
        <bits access="rc" name="irq_flag" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="pucch_res" protect="rw">
        <comment>PUCCH format2/2a/2b UCI</comment>
        <bits access="r" name="res_uci" pos="21:0" rst="0x0">
          <comment>PUCCH format2/2a/2b UCI</comment>
        </bits>
      </reg>
      <hole size="523584"/>
      <reg name="mem1" protect="rw">
        </reg>
      <hole size="131040"/>
      <reg name="mem2" protect="rw">
        </reg>
      <hole size="131040"/>
      <reg name="mem3" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="pusch_buf1" protect="rw">
        </reg>
      <hole size="131040"/>
      <reg name="pusch_buf2" protect="rw">
        </reg>
      <hole size="131040"/>
      <reg name="pusch_buf3" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="prach_buf" protect="rw">
        </reg>
    </module>
    <instance address="0x18800000" name="PUSCH" type="PUSCH"/>
  </archive>
  <archive relative="ldtc1.xml">
    <module category="System" name="LDTC1">
      <reg name="csys_para_nxt" protect="rw">
        <comment>CTRL</comment>
        <bits access="rw" name="schd_sib1" pos="30:26" rst="0x0">
          <comment>Schedule SIB1 BR R13PBML</comment>
        </bits>
        <bits access="rw" name="phi_res" pos="25:24" rst="0x0">
          <comment>PHICH resourcePBML</comment>
        </bits>
        <bits access="rw" name="phi_dur" pos="23" rst="0x0">
          <comment>PHICH durationPBML</comment>
        </bits>
        <bits access="rw" name="bw_ind_ul" pos="22:20" rst="0x0">
          <comment>
01.4Mhz
13Mhz
25Mhz
310Mhz
415Mhz
520Mhz
6~75</comment>
        </bits>
        <bits access="rw" name="ng_ind" pos="19:18" rst="0x0">
          <comment>Ng
01/6
11/2
21
32</comment>
        </bits>
        <bits access="rw" name="tm_mode" pos="17:14" rst="0x0">
          <comment>
1~:9tm1,tm2,,tm9</comment>
        </bits>
        <bits access="rw" name="ss_conf" pos="13:10" rst="0x0">
          <comment>TDD0~9
9</comment>
        </bits>
        <bits access="rw" name="uldl_conf" pos="9:7" rst="0x0">
          <comment>0~66</comment>
        </bits>
        <bits access="rw" name="bw_ind" pos="6:4" rst="0x0">
          <comment>
01.4Mhz
13Mhz
25Mhz
310Mhz
415Mhz
520Mhz
6~75</comment>
        </bits>
        <bits access="rw" name="ant_tx" pos="3:2" rst="0x0">
          <comment>
01
12
24
32</comment>
        </bits>
        <bits access="rw" name="cp_ind" pos="1" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="rw" name="fdd_tdd" pos="0" rst="0x0">
          <comment>FDDTDD
0TDD
1FDD</comment>
        </bits>
      </reg>
      <reg name="cnid_cell_nxt" protect="rw">
        <comment>CTRLID</comment>
        <bits access="rw" name="nid_cell" pos="8:0" rst="0x0">
          <comment>ID0~503</comment>
        </bits>
      </reg>
      <reg name="dsys_para_nxt" protect="rw">
        <comment>CTRL</comment>
        <bits access="rw" name="bw_ind_ul" pos="22:20" rst="0x0">
          <comment>
01.4Mhz
13Mhz
25Mhz
310Mhz
415Mhz
520Mhz
6~75</comment>
        </bits>
        <bits access="rw" name="ng_ind" pos="19:18" rst="0x0">
          <comment>Ng
01/6
11/2
21
32</comment>
        </bits>
        <bits access="rw" name="tm_mode" pos="17:14" rst="0x0">
          <comment>
1~:9tm1,tm2,,tm9</comment>
        </bits>
        <bits access="rw" name="ss_conf" pos="13:10" rst="0x0">
          <comment>TDD0~99</comment>
        </bits>
        <bits access="rw" name="uldl_conf" pos="9:7" rst="0x0">
          <comment>0~66</comment>
        </bits>
        <bits access="rw" name="bw_ind" pos="6:4" rst="0x0">
          <comment>
01.4Mhz
13Mhz
25Mhz
310Mhz
415Mhz
520Mhz
6~75</comment>
        </bits>
        <bits access="rw" name="ant_tx" pos="3:2" rst="0x0">
          <comment>
01
12
24
32</comment>
        </bits>
        <bits access="rw" name="cp_ind" pos="1" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="rw" name="fdd_tdd" pos="0" rst="0x0">
          <comment>FDDTDD
0TDD
1FDD</comment>
        </bits>
      </reg>
      <reg name="dnid_cell_nxt" protect="rw">
        <comment>CTRLID</comment>
        <bits access="rw" name="nid_cell" pos="8:0" rst="0x0">
          <comment>MBSFN ID0~255
ID0~503</comment>
        </bits>
      </reg>
      <reg name="ra_t_rnti" protect="rw">
        <comment>RA-RNTI/TEMP-C-RNTI</comment>
        <bits access="rw" name="t_rnti" pos="31:16" rst="0x0">
          <comment>Temp-C-RNTI</comment>
        </bits>
        <bits access="rw" name="ra_rnti" pos="15:0" rst="0x0">
          <comment>RA_RNTI</comment>
        </bits>
      </reg>
      <reg name="c_sps_rnti" protect="rw">
        <comment>C-RNTI/SPS-C-RNTI</comment>
        <bits access="rw" name="sps_rnti" pos="31:16" rst="0x0">
          <comment>SPS_RNTI</comment>
        </bits>
        <bits access="rw" name="c_rnti" pos="15:0" rst="0x0">
          <comment>C_RNTI</comment>
        </bits>
      </reg>
      <reg name="tpc_rnti" protect="rw">
        <comment>TPC-PUCCH-RNTI/TPC-PUSCH-RNTI</comment>
        <bits access="rw" name="tpcs_rnti" pos="31:16" rst="0x0">
          <comment>TPC-PUCSH-RNTI</comment>
        </bits>
        <bits access="rw" name="tpcc_rnti" pos="15:0" rst="0x0">
          <comment>TPC-PUCCH-RNTI</comment>
        </bits>
      </reg>
      <reg name="g_rnti" protect="rw">
        <comment>G_RNTI</comment>
        <bits access="rw" name="g_rnti" pos="15:0" rst="0x0">
          <comment>G_RNTI</comment>
        </bits>
      </reg>
      <reg name="csi_rsmap0_nxt" protect="rw">
        <comment>CSIRS0</comment>
        <bits access="rw" name="csirs_group2" pos="23:12" rst="0x0">
          <comment>2PRBCSI-RS
CSIRS_GROUP1</comment>
        </bits>
        <bits access="rw" name="csirs_group1" pos="11:0" rst="0x0">
          <comment>1PRBCSI-RS
011PRBRE#0
RE#1101RE#0
CSI-RS</comment>
        </bits>
      </reg>
      <reg name="csi_rsmap1_nxt" protect="rw">
        <comment>CSIRS1</comment>
        <bits access="rw" name="csirs_jump" pos="30:24" rst="0x0">
          <comment>CSI-RSOFDM1PDSCHNorm-CP2430OFDM#5689101213Ext-CP2429OFDM#45781011Norm-CP241OFDM#510OFDM#51CSI-RS</comment>
        </bits>
        <bits access="rw" name="csirs_group4" pos="23:12" rst="0x0">
          <comment>4PRBCSI-RSCSIRS_GROUP1</comment>
        </bits>
        <bits access="rw" name="csirs_group3" pos="11:0" rst="0x0">
          <comment>3PRBCSI-RSCSIRS_GROUP1</comment>
        </bits>
      </reg>
      <reg name="pmi_cfg" protect="rw">
        <comment>PMI</comment>
        <bits access="rw" name="pmi_cbsr" pos="15:0" rst="0x0">
          <comment>PMI (codebookSubsetRestriction)
0PMIbit
1PMIbit</comment>
        </bits>
      </reg>
      <reg name="pcfi_cfg_nxt" protect="rw">
        <comment>PDCCH</comment>
        <bits access="rw" name="cfi_val" pos="3:0" rst="0x7">
          <comment>BIT
Bit0:1OFDMCFI
Bit1:2OFDMCFI
Bit2:3OFDMCFI
Bit3:4OFDMCFI
0
1</comment>
        </bits>
      </reg>
      <reg name="phi_cfg_nxt" protect="rw">
        <comment>PHICH</comment>
        <bits access="rw" name="hi_cond" pos="23:22" rst="0x0">
          <comment>HIOFDM0~3</comment>
        </bits>
        <bits access="rw" name="phi1_en" pos="21" rst="0x0">
          <comment>PHICH1
0
1</comment>
        </bits>
        <bits access="rw" name="phi1_seqnum" pos="20:18" rst="0x0">
          <comment>PHICH10~7</comment>
        </bits>
        <bits access="rw" name="phi1_grpnum" pos="17:11" rst="0x0">
          <comment>PHICH10~99</comment>
        </bits>
        <bits access="rw" name="phi0_en" pos="10" rst="0x0">
          <comment>PHICH0
0
1</comment>
        </bits>
        <bits access="rw" name="phi0_seqnum" pos="9:7" rst="0x0">
          <comment>PHICH00~7</comment>
        </bits>
        <bits access="rw" name="phi0_grpnum" pos="6:0" rst="0x0">
          <comment>PHICH00~99</comment>
        </bits>
      </reg>
      <reg name="pdcch_cfg_nxt" protect="rw">
        <comment>PDCCH</comment>
        <bits access="rw" name="dcilen_ue1" pos="31:26" rst="0x0">
          <comment>UEDCImax57</comment>
        </bits>
        <bits access="rw" name="dcilen_ue0" pos="25:20" rst="0x0">
          <comment>UEDCImax57</comment>
        </bits>
        <bits access="rw" name="dcilen_comm1" pos="19:14" rst="0x0">
          <comment>COMMDCImax57</comment>
        </bits>
        <bits access="rw" name="dcilen_comm0" pos="13:8" rst="0x0">
          <comment>COMMDCImax57</comment>
        </bits>
        <bits access="rw" name="dcilen_sel" pos="7" rst="0x0">
          <comment>DCILEN
0
1</comment>
        </bits>
        <bits access="rw" name="pus_enh" pos="6" rst="0x0">
          <comment>PUSCH
0DCI0
1DCI0C</comment>
        </bits>
        <bits access="rw" name="csi_sel" pos="5" rst="0x0">
          <comment>CSI
01
12</comment>
        </bits>
        <bits access="rw" name="antsel_en" pos="4" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="srs_act" pos="3" rst="0x0">
          <comment>SRS
0DCISRS_REQ
1DCISRS_REQ</comment>
        </bits>
        <bits access="rw" name="pdcch_det_num" pos="2:0" rst="0x4">
          <comment>PDCCH
0:1
1:2
2:3
3:4

78</comment>
        </bits>
      </reg>
      <reg name="pdsch0_cfg_nxt" protect="rw">
        <comment>PDSCH C/RA/T</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>PMIDCIPMI
0DCIPMI
1PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>tx2:0~3tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>
0
1
2
3PORT7
4PORT8
5PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid(UE)0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="modu" pos="15:14" rst="0x0">
          <comment>
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tbsize" pos="13:0" rst="0x0">
          <comment>max12216</comment>
        </bits>
      </reg>
      <reg name="pdsch1_cfg_nxt" protect="rw">
        <comment>PDSCH -SI</comment>
        <bits access="rw" name="ra_type" pos="16" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="15:14" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="tbsize" pos="13:0" rst="0x0">
          <comment>max2216</comment>
        </bits>
      </reg>
      <reg name="pdsch2_cfg_nxt" protect="rw">
        <comment>PDSCH -PAGING</comment>
        <bits access="rw" name="ra_type" pos="16" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="15:14" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="tbsize" pos="13:0" rst="0x0">
          <comment>max2216</comment>
        </bits>
      </reg>
      <reg name="frame_ccnt_nxt" protect="rw">
        <comment>CTRL</comment>
        <bits access="rw" name="ssfn_cnt" pos="31:16" rst="0x0">
          <comment>0~65535</comment>
        </bits>
        <bits access="rw" name="rf_cnt" pos="13:4" rst="0x0">
          <comment>:0~1023</comment>
        </bits>
        <bits access="rw" name="sf_cnt" pos="3:0" rst="0x0">
          <comment>:0~9</comment>
        </bits>
      </reg>
      <reg name="frame_dcnt_nxt" protect="rw">
        <comment>DATA</comment>
        <bits access="rw" name="ssfn_cnt" pos="31:16" rst="0x0">
          <comment>0~65535</comment>
        </bits>
        <bits access="rw" name="rf_cnt" pos="13:4" rst="0x0">
          <comment>:0~1023</comment>
        </bits>
        <bits access="rw" name="sf_cnt" pos="3:0" rst="0x0">
          <comment>:0~9</comment>
        </bits>
      </reg>
      <reg name="ldtc1_cserv_nxt" protect="rw">
        <comment>LDTC CTRL</comment>
        <bits access="rw" name="sc_n_rnti_en" pos="10" rst="0x0">
          <comment>SC-N-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="sc_rnti_en" pos="9" rst="0x0">
          <comment>SC-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="g_rnti_en" pos="8" rst="0x0">
          <comment>G-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="tpcc_rnti_en" pos="7" rst="0x0">
          <comment>TPC-PUCCH-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="tpcs_rnti_en" pos="6" rst="0x0">
          <comment>TPC-PUSCH-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="t_rnti_en" pos="5" rst="0x0">
          <comment>Temp-C-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="sps_rnti_en" pos="4" rst="0x0">
          <comment>SPS-C-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="c_rnti_en" pos="3" rst="0x0">
          <comment>C-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="ra_rnti_en" pos="2" rst="0x0">
          <comment>RA-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="p_rnti_en" pos="1" rst="0x0">
          <comment>P-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="si_rnti_en" pos="0" rst="0x0">
          <comment>SI-RNTI
0
1</comment>
        </bits>
      </reg>
      <reg name="ldtc1_dserv_nxt" protect="rw">
        <comment>LDTC DATA</comment>
        <bits access="rw" name="sc_rnti_en" pos="7" rst="0x0">
          <comment>SC-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="g_rnti_en" pos="6" rst="0x0">
          <comment>G-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="t_rnti_en" pos="5" rst="0x0">
          <comment>Temp-C-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="sps_rnti_en" pos="4" rst="0x0">
          <comment>SPS-C-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="c_rnti_en" pos="3" rst="0x0">
          <comment>C-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="ra_rnti_en" pos="2" rst="0x0">
          <comment>RA-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="p_rnti_en" pos="1" rst="0x0">
          <comment>P-RNTI
0
1</comment>
        </bits>
        <bits access="rw" name="si_rnti_en" pos="0" rst="0x0">
          <comment>SI-RNTI
0
1</comment>
        </bits>
      </reg>
      <reg name="ldtc1_cctrl_nxt" protect="rw">
        <comment>LDTC CTRL</comment>
        <bits access="rw" name="dma_s_en" pos="14" rst="0x0">
          <comment>SINR DMA
0
1</comment>
        </bits>
        <bits access="rw" name="dma_m_en" pos="13" rst="0x0">
          <comment>PMI DMA
0
1</comment>
        </bits>
        <bits access="rw" name="int_s_en" pos="12" rst="0x0">
          <comment>SINR
0
1</comment>
        </bits>
        <bits access="rw" name="int_m_en" pos="11" rst="0x0">
          <comment>PMI
0
1</comment>
        </bits>
        <bits access="rw" name="int_c_en" pos="10" rst="0x0">
          <comment>PDCCH
0
1</comment>
        </bits>
        <bits access="rw" name="int_b_en" pos="9" rst="0x0">
          <comment>PBCH
0
1</comment>
        </bits>
        <bits access="rw" name="mbms_sf" pos="8" rst="0x0">
          <comment>MBMS
0MBMS
1MBMS</comment>
        </bits>
        <bits access="rw" name="cqfqt_ppsel" pos="7:6" rst="0x0">
          <comment>CTRL QFQT
01
12
23</comment>
        </bits>
        <bits access="rw" name="pbch_first" pos="5" rst="0x0">
          <comment>PBCH
0
1</comment>
        </bits>
        <bits access="rw" name="sinr_en" pos="4" rst="0x0">
          <comment>SINR
0
1</comment>
        </bits>
        <bits access="rw" name="pmi_en" pos="3" rst="0x0">
          <comment>PMI
0
1</comment>
        </bits>
        <bits access="rw" name="hi_en" pos="2" rst="0x0">
          <comment>HI
0
1</comment>
        </bits>
        <bits access="rw" name="pdcch_en" pos="1" rst="0x0">
          <comment>PDCCH
0
1</comment>
        </bits>
        <bits access="rw" name="pbch_en" pos="0" rst="0x0">
          <comment>PBCH
0
1</comment>
        </bits>
      </reg>
      <reg name="ldtc1_dctrl_nxt" protect="rw">
        <comment>LDTC DATA</comment>
        <bits access="rw" name="dma_d_en" pos="8" rst="0x0">
          <comment>PDSCH DMA
0
1</comment>
        </bits>
        <bits access="rw" name="int_d_en" pos="7" rst="0x0">
          <comment>PDSCH
0
1</comment>
        </bits>
        <bits access="rw" name="dqfqt_ppsel" pos="6:5" rst="0x0">
          <comment>DATA QFQT
01
12
23</comment>
        </bits>
        <bits access="rw" name="csirs_en" pos="4" rst="0x0">
          <comment>CSIRS
0
1</comment>
        </bits>
        <bits access="rw" name="sihqbuf_sel" pos="3" rst="0x0">
          <comment>SIHQBUF
0HQBUF0
1HQBUF1</comment>
        </bits>
        <bits access="rw" name="si_first" pos="2" rst="0x0">
          <comment>PDSCH
0
1</comment>
        </bits>
        <bits access="rw" name="pds_first" pos="1" rst="0x0">
          <comment>PDS
0
1</comment>
        </bits>
        <bits access="rw" name="pdsch_en" pos="0" rst="0x0">
          <comment>PDSCH
0
1</comment>
        </bits>
      </reg>
      <reg name="ldtc1_cstart" protect="rw">
        <comment>LDTC CTRL</comment>
        <bits access="rw" name="ldtc_cstart" pos="0" rst="0x0">
          <comment>LDTC
0
1</comment>
        </bits>
      </reg>
      <reg name="ldtc1_dstart" protect="rw">
        <comment>LDTC DATA</comment>
        <bits access="rw" name="ldtc_dstart" pos="0" rst="0x0">
          <comment>LDTC
0
1</comment>
        </bits>
      </reg>
      <reg name="ctrl_flag" protect="rw">
        <comment>CTRL</comment>
        <bits access="rc" name="dci_valid" pos="15:8" rst="0x0">
          <comment>DCI
0DCI
1DCI</comment>
        </bits>
        <bits access="rc" name="mib_valid" pos="7:4" rst="0x0">
          <comment>MIB
0MIB
1MIB</comment>
        </bits>
        <bits access="rc" name="int_sflag" pos="3" rst="0x0">
          <comment>SINR
0
1</comment>
        </bits>
        <bits access="rc" name="int_mflag" pos="2" rst="0x0">
          <comment>PMI
0
1</comment>
        </bits>
        <bits access="rc" name="int_cflag" pos="1" rst="0x0">
          <comment>PDCCH
0
1</comment>
        </bits>
        <bits access="rc" name="int_bflag" pos="0" rst="0x0">
          <comment>PBCH
0
1</comment>
        </bits>
      </reg>
      <reg name="data_flag" protect="rw">
        <comment>DATA</comment>
        <bits access="rc" name="paging_zero_flag" pos="6" rst="0x0">
          <comment>PAGINGCRC
0
1</comment>
        </bits>
        <bits access="rc" name="paging_crc_flag" pos="5" rst="0x1">
          <comment>PAGINGCRC
0CRC
1CRC</comment>
        </bits>
        <bits access="rc" name="si_zero_flag" pos="4" rst="0x0">
          <comment>SICRC
0
1</comment>
        </bits>
        <bits access="rc" name="si_crc_flag" pos="3" rst="0x1">
          <comment>SICRC
0CRC
1CRC</comment>
        </bits>
        <bits access="rc" name="pdsch_zero_flag" pos="2" rst="0x0">
          <comment>PDSCH CRC
0
1</comment>
        </bits>
        <bits access="rc" name="pdsch_crc_flag" pos="1" rst="0x1">
          <comment>PDSCH CRC
0CRC
1CRC</comment>
        </bits>
        <bits access="rc" name="int_dflag" pos="0" rst="0x0">
          <comment>PDSCH
0
1</comment>
        </bits>
      </reg>
      <reg name="buf_flag" protect="rw">
        <comment>BUF</comment>
        <bits access="r" name="dfh_ind" pos="3" rst="0x0">
          <comment>FHdata
0FH0
1FH1</comment>
        </bits>
        <bits access="r" name="cfh_ind" pos="2" rst="0x0">
          <comment>FHctrl
0FH0
1FH1</comment>
        </bits>
        <bits access="r" name="dschout_ind" pos="1" rst="0x0">
          <comment>DSCHOUT
0DSCHOUT0
1DSCHOUT1</comment>
        </bits>
        <bits access="r" name="fftbuf_ind" pos="0" rst="0x0">
          <comment>FFTBUF
0FFTBUF0
1FFTBUF1</comment>
        </bits>
      </reg>
      <reg name="alg_comm_para" protect="rw">
        <comment>ALG_COMM_PARA</comment>
        <bits access="rw" name="pdc_th" pos="16:11" rst="0x0">
          <comment>PDCCH</comment>
        </bits>
        <bits access="rw" name="g_scale" pos="10:8" rst="0x4">
          <comment>GQ
0Q15
1Q16

7Q22</comment>
        </bits>
        <bits access="rw" name="cc_ir" pos="7" rst="0x0">
          <comment>HQ 
0CC
1IR</comment>
        </bits>
        <bits access="rw" name="hqbit_sel" pos="6" rst="0x0">
          <comment>HQ BUF
04bit
16bit</comment>
        </bits>
        <bits access="rw" name="sdgn_sel" pos="5" rst="0x0">
          <comment>SDGnoise
0noise
1GM</comment>
        </bits>
        <bits access="rw" name="subbw_sel" pos="4" rst="0x0">
          <comment>PMI/PWR
0
1
</comment>
        </bits>
        <bits access="rw" name="ctcg_sel" pos="3" rst="0x0">
          <comment>CTCG
0OFDM4(OFDM4)CRS
1OFDM8(OFDM8)CRS</comment>
        </bits>
        <bits access="rw" name="crs_g_len" pos="2" rst="0x0">
          <comment>CRS G
01PRB
12PRB</comment>
        </bits>
        <bits access="rw" name="crs_fh_len" pos="1" rst="0x0">
          <comment>CRS36 PRB
03PRB
16PRB</comment>
        </bits>
        <bits access="rw" name="ue_bund" pos="0" rst="0x0">
          <comment>UE RSPRB1,3
0
1</comment>
        </bits>
      </reg>
      <reg name="che_fh_para" protect="rw">
        <comment>CHE</comment>
        <bits access="rw" name="fh10_bitsel_type" pos="7" rst="0x1">
          <comment>16bit10bit
0
1</comment>
        </bits>
        <bits access="rw" name="fh10_bitsel" pos="6:4" rst="0x0">
          <comment>16bit10bit
0x015~6
0x114~5
0x213~4
0x312~3
0x411~2
0x510~1
0x69~0
reserved</comment>
        </bits>
        <bits access="rw" name="fh16_bitsel" pos="3:0" rst="0x6">
          <comment>16bit
0x028~13
0x127~12
0x226~11
0x325~10
0x424~9
0x523~8
0x622~7
0x721~6
0x820~5
0x919~4
0xa18~3
0xb17~2
0xc16~1
0xd15~0
Reserved</comment>
        </bits>
      </reg>
      <reg name="che_th_para" protect="rw">
        <comment>CHE</comment>
        <bits access="rw" name="th16_bitsel" pos="3:0" rst="0x5">
          <comment>
0x025~10
0x124~9
0x223~8
0x322~7
0x421~6
0x520~5
0x619~4
0x718~3
0x817~2
0x916~1
0xa15~0</comment>
        </bits>
      </reg>
      <reg name="rbbm_pds00_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pds01_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pds02_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pds03_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="rbbm_nxt_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbit[99:96]prbbit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="rbbm_pds10_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pds11_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pds12_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pds13_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="rbbm_nxt_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbit[99:96]prbbit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="rbbm_si00_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_si01_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_si02_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_si03_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="rbbm_nxt_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprbbit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="rbbm_si10_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_si11_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_si12_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_si13_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="rbbm_nxt_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbit[99:96]prbbit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="rbbm_pag00_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pag01_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pag02_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pag03_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="rbbm_nxt_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbit[99:96]prbbit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="rbbm_pag10_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pag11_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pag12_nxt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rbbm_pag13_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="rbbm_nxt_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbit[99:96]prbbit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="pmi_pds0_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="pmi_8" pos="31:28" rst="0x0">
          <comment>8</comment>
        </bits>
        <bits access="rw" name="pmi_7" pos="27:24" rst="0x0">
          <comment>7</comment>
        </bits>
        <bits access="rw" name="pmi_6" pos="23:20" rst="0x0">
          <comment>6</comment>
        </bits>
        <bits access="rw" name="pmi_5" pos="19:16" rst="0x0">
          <comment>5</comment>
        </bits>
        <bits access="rw" name="pmi_4" pos="15:12" rst="0x0">
          <comment>4</comment>
        </bits>
        <bits access="rw" name="pmi_3" pos="11:8" rst="0x0">
          <comment>3</comment>
        </bits>
        <bits access="rw" name="pmi_2" pos="7:4" rst="0x0">
          <comment>2</comment>
        </bits>
        <bits access="rw" name="pmi_1" pos="3:0" rst="0x0">
          <comment>1</comment>
        </bits>
      </reg>
      <reg name="pmi_pds1_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="pmi_16" pos="31:28" rst="0x0">
          <comment>16</comment>
        </bits>
        <bits access="rw" name="pmi_15" pos="27:24" rst="0x0">
          <comment>15</comment>
        </bits>
        <bits access="rw" name="pmi_14" pos="23:20" rst="0x0">
          <comment>14</comment>
        </bits>
        <bits access="rw" name="pmi_13" pos="19:16" rst="0x0">
          <comment>13</comment>
        </bits>
        <bits access="rw" name="pmi_12" pos="15:12" rst="0x0">
          <comment>12</comment>
        </bits>
        <bits access="rw" name="pmi_11" pos="11:8" rst="0x0">
          <comment>11</comment>
        </bits>
        <bits access="rw" name="pmi_10" pos="7:4" rst="0x0">
          <comment>10</comment>
        </bits>
        <bits access="rw" name="pmi_9" pos="3:0" rst="0x0">
          <comment>9</comment>
        </bits>
      </reg>
      <reg name="pmi_pds2_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="pmi_24" pos="31:28" rst="0x0">
          <comment>24</comment>
        </bits>
        <bits access="rw" name="pmi_23" pos="27:24" rst="0x0">
          <comment>23</comment>
        </bits>
        <bits access="rw" name="pmi_22" pos="23:20" rst="0x0">
          <comment>22</comment>
        </bits>
        <bits access="rw" name="pmi_21" pos="19:16" rst="0x0">
          <comment>21</comment>
        </bits>
        <bits access="rw" name="pmi_20" pos="15:12" rst="0x0">
          <comment>20</comment>
        </bits>
        <bits access="rw" name="pmi_19" pos="11:8" rst="0x0">
          <comment>19</comment>
        </bits>
        <bits access="rw" name="pmi_18" pos="7:4" rst="0x0">
          <comment>18</comment>
        </bits>
        <bits access="rw" name="pmi_17" pos="3:0" rst="0x0">
          <comment>17</comment>
        </bits>
      </reg>
      <reg name="pmi_pds3_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="pmi_25" pos="3:0" rst="0x0">
          <comment>25</comment>
        </bits>
      </reg>
      <reg name="spwr_wb" protect="rw">
        <comment>CRS</comment>
      </reg>
      <reg name="npwr_wb" protect="rw">
        <comment>CRS</comment>
      </reg>
      <reg name="spwr_wb_agc" protect="rw">
        <comment>CRSAGC</comment>
        <bits access="r" name="spwr_wb_agc" pos="9:0" rst="0x0">
          <comment>1CRSAGC</comment>
        </bits>
      </reg>
      <reg name="npwr_wb_agc" protect="rw">
        <comment>CRSAGC</comment>
        <bits access="r" name="npwr_wb_agc" pos="9:0" rst="0x0">
          <comment>1CRSAGC</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_factor0" protect="rw">
        <comment>DATA0</comment>
        <bits access="rw" name="pdcch_scale_sel" pos="19" rst="0x0">
          <comment>PDCCH
0
1</comment>
        </bits>
        <bits access="rw" name="pbch_scale_sel" pos="18" rst="0x0">
          <comment>PBCH
0
1</comment>
        </bits>
        <bits access="rw" name="pbch_scale1" pos="17:9" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="pbch_scale0" pos="8:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_factor1" protect="rw">
        <comment>DATA2</comment>
        <bits access="rw" name="pdsch_scale_sel" pos="12" rst="0x0">
          <comment>PDSCH
0
1</comment>
        </bits>
        <bits access="rw" name="pdsch_scale0" pos="11:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_factor2" protect="rw">
        <comment>DATA3</comment>
        <bits access="rw" name="pdsch_scale2" pos="23:12" rst="0x0">
          <comment>2</comment>
        </bits>
        <bits access="rw" name="pdsch_scale1" pos="11:0" rst="0x0">
          <comment>1</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_factor3" protect="rw">
        <comment>DATA4</comment>
        <bits access="rw" name="pdsch_scale4" pos="23:12" rst="0x0">
          <comment>4</comment>
        </bits>
        <bits access="rw" name="pdsch_scale3" pos="11:0" rst="0x0">
          <comment>3</comment>
        </bits>
      </reg>
      <reg name="sd_data_factor0" protect="rw">
        <comment>DATA(CRS)0</comment>
        <bits access="rw" name="cr_data_factor" pos="31:16" rst="0x2000">
          <comment>OFDMCELL RSdata</comment>
        </bits>
        <bits access="rw" name="ucr_data_factor" pos="15:0" rst="0x2000">
          <comment>OFDMCELL RSdata</comment>
        </bits>
      </reg>
      <reg name="sd_data_factor1" protect="rw">
        <comment>DATA(URS)1</comment>
        <bits access="rw" name="cr_data_factor" pos="31:16" rst="0x2000">
          <comment>OFDMCELL RSdata</comment>
        </bits>
        <bits access="rw" name="ucr_data_factor" pos="15:0" rst="0x2000">
          <comment>OFDMCELL RSdata</comment>
        </bits>
      </reg>
      <reg name="sd_data_factor2" protect="rw">
        <comment>DATA(URS)2</comment>
        <bits access="rw" name="cr_data_factor" pos="31:16" rst="0x2000">
          <comment>OFDMCELL RSdata</comment>
        </bits>
        <bits access="rw" name="ucr_data_factor" pos="15:0" rst="0x2000">
          <comment>OFDMCELL RSdata</comment>
        </bits>
      </reg>
      <reg name="cnoise_nxt" protect="rw">
        <comment>CTRL</comment>
      </reg>
      <reg name="cnoise_agc_nxt" protect="rw">
        <comment>CTRLAGC</comment>
        <bits access="rw" name="noise_agc" pos="9:0" rst="0x0">
          <comment>AGC</comment>
        </bits>
      </reg>
      <reg name=" cnoise_th" protect="rw">
        <comment>CTRL</comment>
        <bits access="rw" name="noise_th" pos="15:0" rst="0x0">
          <comment>PDCCHPBCH</comment>
        </bits>
      </reg>
      <reg name="dnoise_nxt" protect="rw">
        <comment>DATA</comment>
      </reg>
      <reg name="dnoise_agc_nxt" protect="rw">
        <comment>DATAAGC</comment>
        <bits access="rw" name="noise_agc" pos="9:0" rst="0x0">
          <comment>AGC</comment>
        </bits>
      </reg>
      <reg name="dnoise_th" protect="rw">
        <comment>DATA</comment>
        <bits access="rw" name="noise_th2" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="noise_th1" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="sd_scaling_bcout0" protect="rw">
        <comment>SDOUTPBCH0</comment>
        <bits access="r" name="cscale_out" pos="11:8" rst="0x0">
          <comment>PDCCHINDX</comment>
        </bits>
        <bits access="r" name="bscale_out3" pos="7:6" rst="0x0">
          <comment>PBCHINDX3</comment>
        </bits>
        <bits access="r" name="bscale_out2" pos="5:4" rst="0x0">
          <comment>PBCHINDX2</comment>
        </bits>
        <bits access="r" name="bscale_out1" pos="3:2" rst="0x0">
          <comment>PBCHINDX1</comment>
        </bits>
        <bits access="r" name="bscale_out0" pos="1:0" rst="0x0">
          <comment>PBCHINDX0</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_dout0" protect="rw">
        <comment>SDOUTPDSCH0</comment>
        <bits access="r" name="dscale_out7" pos="23:21" rst="0x0">
          <comment>INDX7</comment>
        </bits>
        <bits access="r" name="dscale_out6" pos="20:18" rst="0x0">
          <comment>INDX6</comment>
        </bits>
        <bits access="r" name="dscale_out5" pos="17:15" rst="0x0">
          <comment>INDX5</comment>
        </bits>
        <bits access="r" name="dscale_out4" pos="14:12" rst="0x0">
          <comment>INDX4</comment>
        </bits>
        <bits access="r" name="dscale_out3" pos="11:9" rst="0x0">
          <comment>INDX3</comment>
        </bits>
        <bits access="r" name="dscale_out2" pos="8:6" rst="0x0">
          <comment>INDX2</comment>
        </bits>
        <bits access="r" name="dscale_out1" pos="5:3" rst="0x0">
          <comment>INDX1</comment>
        </bits>
        <bits access="r" name="dscale_out0" pos="2:0" rst="0x0">
          <comment>INDX0</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_dout1" protect="rw">
        <comment>SDOUTPDSCH1</comment>
        <bits access="r" name="dscale_out15" pos="23:21" rst="0x0">
          <comment>INDX15</comment>
        </bits>
        <bits access="r" name="dscale_out14" pos="20:18" rst="0x0">
          <comment>INDX14</comment>
        </bits>
        <bits access="r" name="dscale_out13" pos="17:15" rst="0x0">
          <comment>INDX13</comment>
        </bits>
        <bits access="r" name="dscale_out12" pos="14:12" rst="0x0">
          <comment>INDX12</comment>
        </bits>
        <bits access="r" name="dscale_out11" pos="11:9" rst="0x0">
          <comment>INDX11</comment>
        </bits>
        <bits access="r" name="dscale_out10" pos="8:6" rst="0x0">
          <comment>INDX10</comment>
        </bits>
        <bits access="r" name="dscale_out9" pos="5:3" rst="0x0">
          <comment>INDX9</comment>
        </bits>
        <bits access="r" name="dscale_out8" pos="2:0" rst="0x0">
          <comment>INDX8</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_dout2" protect="rw">
        <comment>SDOUTPDSCH2</comment>
        <bits access="r" name="dscale_out23" pos="23:21" rst="0x0">
          <comment>INDX23</comment>
        </bits>
        <bits access="r" name="dscale_out22" pos="20:18" rst="0x0">
          <comment>INDX22</comment>
        </bits>
        <bits access="r" name="dscale_out21" pos="17:15" rst="0x0">
          <comment>INDX21</comment>
        </bits>
        <bits access="r" name="dscale_out20" pos="14:12" rst="0x0">
          <comment>INDX20</comment>
        </bits>
        <bits access="r" name="dscale_out19" pos="11:9" rst="0x0">
          <comment>INDX19</comment>
        </bits>
        <bits access="r" name="dscale_out18" pos="8:6" rst="0x0">
          <comment>INDX18</comment>
        </bits>
        <bits access="r" name="dscale_out17" pos="5:3" rst="0x0">
          <comment>INDX17</comment>
        </bits>
        <bits access="r" name="dscale_out16" pos="2:0" rst="0x0">
          <comment>INDX16</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_dout3" protect="rw">
        <comment>SDOUTPDSCH3</comment>
        <bits access="r" name="dscale_out31" pos="23:21" rst="0x0">
          <comment>INDX31</comment>
        </bits>
        <bits access="r" name="dscale_out30" pos="20:18" rst="0x0">
          <comment>INDX30</comment>
        </bits>
        <bits access="r" name="dscale_out29" pos="17:15" rst="0x0">
          <comment>INDX29</comment>
        </bits>
        <bits access="r" name="dscale_out28" pos="14:12" rst="0x0">
          <comment>INDX28</comment>
        </bits>
        <bits access="r" name="dscale_out27" pos="11:9" rst="0x0">
          <comment>INDX27</comment>
        </bits>
        <bits access="r" name="dscale_out26" pos="8:6" rst="0x0">
          <comment>INDX26</comment>
        </bits>
        <bits access="r" name="dscale_out25" pos="5:3" rst="0x0">
          <comment>INDX25</comment>
        </bits>
        <bits access="r" name="dscale_out24" pos="2:0" rst="0x0">
          <comment>INDX24</comment>
        </bits>
      </reg>
      <reg name="sd_scaling_dout4" protect="rw">
        <comment>SDOUTPDSCH4</comment>
        <bits access="r" name="dscale_out34" pos="8:6" rst="0x0">
          <comment>INDX34</comment>
        </bits>
        <bits access="r" name="dscale_out33" pos="5:3" rst="0x0">
          <comment>INDX33</comment>
        </bits>
        <bits access="r" name="dscale_out32" pos="2:0" rst="0x0">
          <comment>INDX32</comment>
        </bits>
      </reg>
      <reg name="hq_hb_sta" protect="rw">
        <comment>HARQBUF</comment>
        <bits access="rc" name="hb15_sta" pos="15" rst="0x0">
          <comment>15HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb14_sta" pos="14" rst="0x0">
          <comment>14HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb13_sta" pos="13" rst="0x0">
          <comment>13HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb12_sta" pos="12" rst="0x0">
          <comment>12HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb11_sta" pos="11" rst="0x0">
          <comment>11HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb10_sta" pos="10" rst="0x0">
          <comment>10HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb9_sta" pos="9" rst="0x0">
          <comment>9HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb8_sta" pos="8" rst="0x0">
          <comment>8HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb7_sta" pos="7" rst="0x0">
          <comment>7HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb6_sta" pos="6" rst="0x0">
          <comment>6HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb5_sta" pos="5" rst="0x0">
          <comment>5HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb4_sta" pos="4" rst="0x0">
          <comment>4HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb3_sta" pos="3" rst="0x0">
          <comment>3HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb2_sta" pos="2" rst="0x0">
          <comment>2HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb1_sta" pos="1" rst="0x0">
          <comment>1HARQBUFFER
0:
1:</comment>
        </bits>
        <bits access="rc" name="hb0_sta" pos="0" rst="0x0">
          <comment>0HARQBUFFER
0:
1:</comment>
        </bits>
      </reg>
      <reg name="hq_hb_proc0" protect="rw">
        <comment>HARQBUF0</comment>
        <bits access="r" name="hb7_proc" pos="31:28" rst="0x0">
          <comment>7HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb6_proc" pos="27:24" rst="0x0">
          <comment>6HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb5_proc" pos="23:20" rst="0x0">
          <comment>5HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb4_proc" pos="19:16" rst="0x0">
          <comment>4HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb3_proc" pos="15:12" rst="0x0">
          <comment>3HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb2_proc" pos="11:8" rst="0x0">
          <comment>2HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb1_proc" pos="7:4" rst="0x0">
          <comment>1HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb0_proc" pos="3:0" rst="0x0">
          <comment>0HARQBUFFER:0~15</comment>
        </bits>
      </reg>
      <reg name="hq_hb_proc1" protect="rw">
        <comment>HARQBUF1</comment>
        <bits access="r" name="hb15_proc" pos="31:28" rst="0x0">
          <comment>15HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb14_proc" pos="27:24" rst="0x0">
          <comment>14HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb13_proc" pos="23:20" rst="0x0">
          <comment>13HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb12_proc" pos="19:16" rst="0x0">
          <comment>12HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb11_proc" pos="15:12" rst="0x0">
          <comment>11HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb10_proc" pos="11:8" rst="0x0">
          <comment>10HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb9_proc" pos="7:4" rst="0x0">
          <comment>9HARQBUFFER:0~15</comment>
        </bits>
        <bits access="r" name="hb8_proc" pos="3:0" rst="0x0">
          <comment>8HARQBUFFER:0~15</comment>
        </bits>
      </reg>
      <reg name="turbo_para" protect="rw">
        <comment>TURBO</comment>
        <bits access="rw" name="norm_en2" pos="17" rst="0x0">
          <comment>64QAM
02
1</comment>
        </bits>
        <bits access="rw" name="norm_en1" pos="16" rst="0x0">
          <comment>16QAM
02
1</comment>
        </bits>
        <bits access="rw" name="norm_en0" pos="15" rst="0x0">
          <comment>QPSK
02
1</comment>
        </bits>
        <bits access="rw" name="shift_en2" pos="14" rst="0x0">
          <comment>64QAM
0
1</comment>
        </bits>
        <bits access="rw" name="shift_en1" pos="13" rst="0x1">
          <comment>16QAM
0
1</comment>
        </bits>
        <bits access="rw" name="shift_en0" pos="12" rst="0x1">
          <comment>QPSK
0
1</comment>
        </bits>
        <bits access="rw" name="shift_iternum2" pos="11:8" rst="0x5">
          <comment>2</comment>
        </bits>
        <bits access="rw" name="shift_iternum1" pos="7:4" rst="0x2">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="iter_num_max" pos="3:0" rst="0x8">
          <comment>1
90~8</comment>
        </bits>
      </reg>
      <reg name="turbo_iter" protect="rw">
        <comment>TURBO</comment>
        <bits access="r" name="real_iter3" pos="15:12" rst="0x0">
          <comment>PAG-1</comment>
        </bits>
        <bits access="r" name="real_iter2" pos="11:8" rst="0x0">
          <comment>SI-1</comment>
        </bits>
        <bits access="r" name="real_iter1" pos="7:4" rst="0x0">
          <comment>PDS-1</comment>
        </bits>
        <bits access="r" name="real_iter0" pos="3:0" rst="0x0">
          <comment>PDS-1</comment>
        </bits>
      </reg>
      <reg name="vit_par" protect="rw">
        <comment>VIT</comment>
        <bits access="rw" name="mask_en" pos="5" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="crc_type" pos="4" rst="0x0">
          <comment>CRC
0CRC16
1CRC24A</comment>
        </bits>
        <bits access="rw" name="dmav_en" pos="3" rst="0x0">
          <comment>DMA
0
1</comment>
        </bits>
        <bits access="rw" name="intv_en" pos="2" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="vit_itnum" pos="1:0" rst="0x1">
          <comment>VIT
0:1
1:2
2:3
3:4</comment>
        </bits>
      </reg>
      <reg name="vit_faconf" protect="rw">
        <comment>VIT FA</comment>
        <bits access="rw" name="crc_mask" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="fa_en" pos="8" rst="0x0">
          <comment>PDCCHfalse alarm</comment>
        </bits>
        <bits access="rw" name="fa_th" pos="7:0" rst="0x80">
          <comment>PDCCHfalse alarm(U8Q7)</comment>
        </bits>
      </reg>
      <reg name="vit_len" protect="rw">
        <comment>VIT</comment>
        <bits access="rw" name="vit_len" pos="9:0" rst="0x0">
          <comment>VIT</comment>
        </bits>
      </reg>
      <reg name="vit_start" protect="rw">
        <comment>VIT</comment>
        <bits access="rw" name="vit_start" pos="0" rst="0x0">
          <comment>VIT
0
1</comment>
        </bits>
      </reg>
      <reg name="vit_flag" protect="rw">
        <comment>VIT</comment>
        <bits access="rc" name="pdsch_zero_flag" pos="2" rst="0x0">
          <comment>VIT CRCCRC
0
1</comment>
        </bits>
        <bits access="rc" name="vit_crc_flag" pos="1" rst="0x1">
          <comment>VIT CRC
0
1</comment>
        </bits>
        <bits access="rc" name="int_vflag" pos="0" rst="0x0">
          <comment>PBCH
0
1</comment>
        </bits>
      </reg>
      <reg name="vit_faout" protect="rw">
        <comment>VIT FA</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm0</comment>
        </bits>
        <bits access="r" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm</comment>
        </bits>
      </reg>
      <reg name="cfi_out" protect="rw">
        <comment>CFICH</comment>
        <bits access="r" name="cfi_out" pos="2:0" rst="0x0">
          <comment>CFI
1~41.4M1</comment>
        </bits>
      </reg>
      <reg name="hi_out" protect="rw">
        <comment>PHICH</comment>
        <bits access="r" name="hi1_out" pos="1" rst="0x0">
          <comment>HI1</comment>
        </bits>
        <bits access="r" name="hi0_out" pos="0" rst="0x0">
          <comment>HI0</comment>
        </bits>
      </reg>
      <reg name="sw_cin_nxt" protect="rw">
        <comment>CTRL</comment>
      </reg>
      <reg name="sw_din_nxt" protect="rw">
        <comment>DATA</comment>
      </reg>
      <reg name="sw_cout" protect="rw">
        <comment>CTRL</comment>
      </reg>
      <reg name="sw_dout" protect="rw">
        <comment>DATA</comment>
      </reg>
      <reg name="pds_rep_num" protect="rw">
        <comment>PDSCH</comment>
        <bits access="r" name="pds15_rep_num" pos="31:30" rst="0x0">
          <comment>PDSCH 15</comment>
        </bits>
        <bits access="r" name="pds14_rep_num" pos="29:28" rst="0x0">
          <comment>PDSCH 14</comment>
        </bits>
        <bits access="r" name="pds13_rep_num" pos="27:26" rst="0x0">
          <comment>PDSCH 13</comment>
        </bits>
        <bits access="r" name="pds12_rep_num" pos="25:24" rst="0x0">
          <comment>PDSCH 12</comment>
        </bits>
        <bits access="r" name="pds11_rep_num" pos="23:22" rst="0x0">
          <comment>PDSCH 11</comment>
        </bits>
        <bits access="r" name="pds10_rep_num" pos="21:20" rst="0x0">
          <comment>PDSCH 10</comment>
        </bits>
        <bits access="r" name="pds9_rep_num" pos="19:18" rst="0x0">
          <comment>PDSCH 9</comment>
        </bits>
        <bits access="r" name="pds8_rep_num" pos="17:16" rst="0x0">
          <comment>PDSCH 8</comment>
        </bits>
        <bits access="r" name="pds7_rep_num" pos="15:14" rst="0x0">
          <comment>PDSCH 7</comment>
        </bits>
        <bits access="r" name="pds6_rep_num" pos="13:12" rst="0x0">
          <comment>PDSCH 6</comment>
        </bits>
        <bits access="r" name="pds5_rep_num" pos="11:10" rst="0x0">
          <comment>PDSCH 5</comment>
        </bits>
        <bits access="r" name="pds4_rep_num" pos="9:8" rst="0x0">
          <comment>PDSCH 4</comment>
        </bits>
        <bits access="r" name="pds3_rep_num" pos="7:6" rst="0x0">
          <comment>PDSCH 3</comment>
        </bits>
        <bits access="r" name="pds2_rep_num" pos="5:4" rst="0x0">
          <comment>PDSCH 2</comment>
        </bits>
        <bits access="r" name="pds1_rep_num" pos="3:2" rst="0x0">
          <comment>PDSCH 1</comment>
        </bits>
        <bits access="r" name="pds0_rep_num" pos="1:0" rst="0x0">
          <comment>PDSCH 0</comment>
        </bits>
      </reg>
      <reg name="si_rep_num" protect="rw">
        <comment>SI</comment>
        <bits access="r" name="si1_rep_num" pos="3:2" rst="0x0">
          <comment>SI1</comment>
        </bits>
        <bits access="r" name="si0_rep_num" pos="1:0" rst="0x0">
          <comment>SI0</comment>
        </bits>
      </reg>
      <reg name="pbch_rep_num" protect="rw">
        <comment>PBCH</comment>
        <bits access="r" name="pbch_rep_num" pos="1:0" rst="0x0">
          <comment>PBCH</comment>
        </bits>
      </reg>
      <reg name="rtctrl_cfg" protect="rw">
        <comment></comment>
        <bits access="rw" name="rtctrl_cfg" pos="17:0" rst="0xc350">
          <comment></comment>
        </bits>
      </reg>
      <reg name="cabis_enbl_nxt" protect="rw">
        <comment>ABIS</comment>
        <bits access="rw" name="abis_portsel2" pos="11:10" rst="0x0">
          <comment>2
02port0port14port0port1port2port3
12port04port0port2port3
22port14port1port2port3</comment>
        </bits>
        <bits access="rw" name="abis_portsel1" pos="9:8" rst="0x0">
          <comment>1
02port0port14port0port1port2port3
12port04port0port2port3
22port14port1port2port3</comment>
        </bits>
        <bits access="rw" name="abis_portsel0" pos="7:6" rst="0x0">
          <comment>
02port0port14port0port1port2port3
12port04port0port2port3
22port14port1port2port3</comment>
        </bits>
        <bits access="rw" name="cmc_en" pos="5" rst="0x0">
          <comment>MultiCell
0SingalCell
1MultiCell</comment>
        </bits>
        <bits access="rw" name="cabis_sel" pos="4" rst="0x0">
          <comment>ABIS
0
1DLFFT</comment>
        </bits>
        <bits access="rw" name="cabis_en" pos="3" rst="0x0">
          <comment>ABIS
0
1</comment>
        </bits>
        <bits access="rw" name="cabis_sdden" pos="2" rst="0x0">
          <comment>ABISSD PDSCH
0
1</comment>
        </bits>
        <bits access="rw" name="cabis_sdcen" pos="1" rst="0x0">
          <comment>ABISSD MPDCCH
0
1</comment>
        </bits>
        <bits access="rw" name="cabis_sdben" pos="0" rst="0x0">
          <comment>ABISSD PBCH
0
1</comment>
        </bits>
      </reg>
      <reg name="cabis_cfg_nxt" protect="rw">
        <comment>ABIS</comment>
        <bits access="rw" name="cabis_num" pos="29:28" rst="0x0">
          <comment>
000
011
102
0</comment>
        </bits>
        <bits access="rw" name="cabis_txnum_next2" pos="27:26" rst="0x0">
          <comment>2
001port
012port
104port
1port</comment>
        </bits>
        <bits access="rw" name="cabis_txnum_next1" pos="25:24" rst="0x0">
          <comment>1
001port
012port
104port
1port</comment>
        </bits>
        <bits access="rw" name="cabis_nrb_next2" pos="23:21" rst="0x0">
          <comment>2 
0006prb
00115prb
01025prb
01150prb
10075prb
101100prb
6prb</comment>
        </bits>
        <bits access="rw" name="cabis_nrb_next1" pos="20:18" rst="0x0">
          <comment>1 
0006prb
00115prb
01025prb
01150prb
10075prb
101100prb
6prb</comment>
        </bits>
        <bits access="rw" name="cabis_cellid_next2" pos="17:9" rst="0x0">
          <comment>2 CELL ID</comment>
        </bits>
        <bits access="rw" name="cabis_cellid_next1" pos="8:0" rst="0x0">
          <comment>1 CELL ID</comment>
        </bits>
      </reg>
      <reg name="cabis_dly1_nxt" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="cabis_dly_next1" pos="18:0" rst="0x0">
          <comment>1TS</comment>
        </bits>
      </reg>
      <reg name="cabis_dly2_nxt" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="cabis_dly_next2" pos="18:0" rst="0x0">
          <comment>2TS</comment>
        </bits>
      </reg>
      <reg name="cabis_shft_nxt" protect="rw">
        <comment>ABIS</comment>
        <bits access="r" name="cabis_shft_next3" pos="11:8" rst="0x0">
          <comment>ABIS31+2</comment>
        </bits>
        <bits access="r" name="cabis_shft_next2" pos="7:4" rst="0x0">
          <comment>ABIS22</comment>
        </bits>
        <bits access="r" name="cabis_shft_next1" pos="3:0" rst="0x0">
          <comment>ABIS11</comment>
        </bits>
      </reg>
      <reg name="dabis_enbl_nxt" protect="rw">
        <comment>ABIS</comment>
        <bits access="rw" name="abis_portsel2" pos="10:9" rst="0x0">
          <comment>2
02port0port14port0port1port2port3
12port04port0port2port3
22port14port1port2port3</comment>
        </bits>
        <bits access="rw" name="abis_portsel1" pos="8:7" rst="0x0">
          <comment>1
02port0port14port0port1port2port3
12port04port0port2port3
22port14port1port2port3</comment>
        </bits>
        <bits access="rw" name="abis_portsel0" pos="6:5" rst="0x0">
          <comment>
02port0port14port0port1port2port3
12port04port0port2port3
22port14port1port2port3</comment>
        </bits>
        <bits access="rw" name="dabis_sel" pos="4" rst="0x0">
          <comment>ABIS
0
1DLFFT</comment>
        </bits>
        <bits access="rw" name="dabis_en" pos="3" rst="0x0">
          <comment>ABIS
0
1</comment>
        </bits>
        <bits access="rw" name="dabis_sdden" pos="2" rst="0x0">
          <comment>ABISSD PDSCH
0
1</comment>
        </bits>
        <bits access="rw" name="dabis_sdcen" pos="1" rst="0x0">
          <comment>ABISSD MPDCCH
0
1</comment>
        </bits>
        <bits access="rw" name="dabis_sdben" pos="0" rst="0x0">
          <comment>ABISSD PBCH
0
1</comment>
        </bits>
      </reg>
      <reg name="dabis_cfg_nxt" protect="rw">
        <comment>ABIS</comment>
        <bits access="rw" name="dabis_num" pos="29:28" rst="0x0">
          <comment>
000
011
102
0</comment>
        </bits>
        <bits access="rw" name="dabis_txnum_next2" pos="27:26" rst="0x0">
          <comment>2
001port
012port
104port
1port</comment>
        </bits>
        <bits access="rw" name="dabis_txnum_next1" pos="25:24" rst="0x0">
          <comment>2
001port
012port
104port
1port</comment>
        </bits>
        <bits access="rw" name="dabis_nrb_next2" pos="23:21" rst="0x0">
          <comment>2 
0006prb
00115prb
01025prb
01150prb
10075prb
101100prb
6prb</comment>
        </bits>
        <bits access="rw" name="dabis_nrb_next1" pos="20:18" rst="0x0">
          <comment>1 
0006prb
00115prb
01025prb
01150prb
10075prb
101100prb
6prb</comment>
        </bits>
        <bits access="rw" name="dabis_cellid_next2" pos="17:9" rst="0x0">
          <comment>2 CELL ID</comment>
        </bits>
        <bits access="rw" name="dabis_cellid_next1" pos="8:0" rst="0x0">
          <comment>1 CELL ID</comment>
        </bits>
      </reg>
      <reg name="dabis_dly1_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="dabis_dly_next1" pos="18:0" rst="0x0">
          <comment>1TS</comment>
        </bits>
      </reg>
      <reg name="dabis_dly2_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="dabis_dly_next2" pos="18:0" rst="0x0">
          <comment>2TS</comment>
        </bits>
      </reg>
      <reg name="dabis_shft_nxt" protect="rw">
        <comment>ABIS</comment>
        <bits access="r" name="dabis_shft_next3" pos="11:8" rst="0x0">
          <comment>ABIS31+2</comment>
        </bits>
        <bits access="r" name="dabis_shft_next2" pos="7:4" rst="0x0">
          <comment>ABIS22</comment>
        </bits>
        <bits access="r" name="dabis_shft_next1" pos="3:0" rst="0x0">
          <comment>ABIS11</comment>
        </bits>
      </reg>
      <reg name="reis_conf" protect="rw">
        <comment>REIS</comment>
        <bits access="rw" name="reis_en" pos="4" rst="0x0">
          <comment>REIS
0
1</comment>
        </bits>
        <bits access="rw" name="reis_num" pos="3:0" rst="0x0">
          <comment>REISNUM</comment>
        </bits>
      </reg>
      <reg name="reis_pos0" protect="rw">
        <comment>REIS0</comment>
        <bits access="rw" name="reis_shift1" pos="31:28" rst="0x0">
          <comment>REIS1</comment>
        </bits>
        <bits access="rw" name="reis_re1" pos="26:16" rst="0x0">
          <comment>REIS1RE20M1200RE</comment>
        </bits>
        <bits access="rw" name="reis_shift0" pos="15:12" rst="0x0">
          <comment>REIS0</comment>
        </bits>
        <bits access="rw" name="reis_re0" pos="10:0" rst="0x0">
          <comment>REIS0RE20M1200RE</comment>
        </bits>
      </reg>
      <reg name="reis_pos1" protect="rw">
        <comment>REIS1</comment>
        <bits access="rw" name="reis_shift3" pos="31:28" rst="0x0">
          <comment>REIS3</comment>
        </bits>
        <bits access="rw" name="reis_re3" pos="26:16" rst="0x0">
          <comment>REIS3RE20M1200RE</comment>
        </bits>
        <bits access="rw" name="reis_shift2" pos="15:12" rst="0x0">
          <comment>REIS2</comment>
        </bits>
        <bits access="rw" name="reis_re2" pos="10:0" rst="0x0">
          <comment>REIS2RE20M1200RE</comment>
        </bits>
      </reg>
      <reg name="reis_pos2" protect="rw">
        <comment>REIS2</comment>
        <bits access="rw" name="reis_shift5" pos="31:28" rst="0x0">
          <comment>REIS5</comment>
        </bits>
        <bits access="rw" name="reis_re5" pos="26:16" rst="0x0">
          <comment>REIS5RE20M1200RE</comment>
        </bits>
        <bits access="rw" name="reis_shift4" pos="15:12" rst="0x0">
          <comment>REIS4</comment>
        </bits>
        <bits access="rw" name="reis_re4" pos="10:0" rst="0x0">
          <comment>REIS4RE20M1200RE</comment>
        </bits>
      </reg>
      <reg name="reis_pos3" protect="rw">
        <comment>REIS3</comment>
        <bits access="rw" name="reis_shift7" pos="31:28" rst="0x0">
          <comment>REIS7</comment>
        </bits>
        <bits access="rw" name="reis_re7" pos="26:16" rst="0x0">
          <comment>REIS7RE20M1200RE</comment>
        </bits>
        <bits access="rw" name="reis_shift6" pos="15:12" rst="0x0">
          <comment>REIS6</comment>
        </bits>
        <bits access="rw" name="reis_re6" pos="10:0" rst="0x0">
          <comment>REIS6RE20M1200RE</comment>
        </bits>
      </reg>
      <reg name="rbis_par" protect="rw">
        <comment>RBIS</comment>
        <bits access="rw" name="rbis_portsel" pos="31" rst="0x0">
          <comment>2ABISPORT
0port0
1port1</comment>
        </bits>
        <bits access="rw" name="rbis_en" pos="30" rst="0x0">
          <comment>RBIS
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_sdden" pos="29" rst="0x0">
          <comment>RBISSD PDSCH
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_sdcen" pos="28" rst="0x0">
          <comment>RBISSD MPDCCH
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_sdben" pos="27" rst="0x0">
          <comment>RBISSD PBCH
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_posen" pos="26" rst="0x0">
          <comment>RBIS
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_num" pos="25:23" rst="0x0">
          <comment>RBIS
01
12
23
34
45</comment>
        </bits>
        <bits access="rw" name="rbis_dipos" pos="22:16" rst="0x0">
          <comment>RBIS</comment>
        </bits>
        <bits access="rw" name="rbis_factor" pos="15:0" rst="0x0">
          <comment>RBIS</comment>
        </bits>
      </reg>
      <reg name="rbis_posout0" protect="rw">
        <comment>RBIS0</comment>
        <bits access="r" name="rbis_posout3" pos="27:21" rst="0x0">
          <comment>RBIS0~99</comment>
        </bits>
        <bits access="r" name="rbis_posout2" pos="20:14" rst="0x0">
          <comment>RBIS0~99</comment>
        </bits>
        <bits access="r" name="rbis_posout1" pos="13:7" rst="0x0">
          <comment>RBIS0~99</comment>
        </bits>
        <bits access="r" name="rbis_posout0" pos="6:0" rst="0x0">
          <comment>RBIS0~99</comment>
        </bits>
      </reg>
      <reg name="rbis_posout1" protect="rw">
        <comment>RBIS1</comment>
        <bits access="r" name="rbis_posout4" pos="6:0" rst="0x0">
          <comment>RBIS0~99</comment>
        </bits>
      </reg>
      <reg name="rbis_ave" protect="rw">
        <comment>RBIS</comment>
      </reg>
      <reg name="rbis_max" protect="rw">
        <comment>RBIS</comment>
        <bits access="r" name="rbis_max" pos="24:0" rst="0x0">
          <comment>RBIS</comment>
        </bits>
      </reg>
      <reg name="pbml_cfg_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="pbml_en" pos="20" rst="0x0">
          <comment>PBML
0
1</comment>
        </bits>
        <bits access="rw" name="llr_cal_len" pos="19:14" rst="0x0">
          <comment>LLR</comment>
        </bits>
        <bits access="rw" name="llr_pos_sta" pos="13:8" rst="0x0">
          <comment>LLR</comment>
        </bits>
        <bits access="rw" name="llr_alpha" pos="7:0" rst="0x0">
          <comment>LLR
0~255</comment>
        </bits>
      </reg>
      <reg name="ctrl_state" protect="rw">
        <comment></comment>
        <bits access="r" name="ctrl_state" pos="25:0" rst="0x1">
          <comment></comment>
        </bits>
      </reg>
      <reg name="data_state" protect="rw">
        <comment></comment>
        <bits access="r" name="data_state" pos="25:0" rst="0x1">
          <comment></comment>
        </bits>
      </reg>
      <reg name="frame_ccnt_out" protect="rw">
        <comment>CTRL</comment>
        <bits access="r" name="ssfn_cnt" pos="31:16" rst="0x0">
          <comment>0~65535</comment>
        </bits>
        <bits access="r" name="rf_cnt" pos="13:4" rst="0x0">
          <comment>0~1023</comment>
        </bits>
        <bits access="r" name="sf_cnt" pos="3:0" rst="0x0">
          <comment>0~9</comment>
        </bits>
      </reg>
      <reg name="frame_dcnt_out" protect="rw">
        <comment>DATA</comment>
        <bits access="r" name="ssfn_cnt" pos="31:16" rst="0x0">
          <comment>0~65535</comment>
        </bits>
        <bits access="r" name="rf_cnt" pos="13:4" rst="0x0">
          <comment>0~1023</comment>
        </bits>
        <bits access="r" name="sf_cnt" pos="3:0" rst="0x0">
          <comment>0~9</comment>
        </bits>
      </reg>
      <reg name="pds0_harqin0_info" protect="rw">
        <comment>PDSCH HARQIN</comment>
        <bits access="r" name="pds_len0" pos="25:16" rst="0x0">
          <comment>CB0HARQIN MEM0</comment>
        </bits>
        <bits access="r" name="pds_ini0" pos="9:0" rst="0x0">
          <comment>CB0HARQIN MEM0</comment>
        </bits>
      </reg>
      <reg name="pds0_harqin1_info" protect="rw">
        <comment>PDSCH HARQIN</comment>
        <bits access="r" name="pds_e0" pos="31:16" rst="0x0">
          <comment>CB0</comment>
        </bits>
        <bits access="r" name="pds_ini1" pos="12:0" rst="0x0">
          <comment>CB0HARQIN MEM1</comment>
        </bits>
      </reg>
      <reg name="pds1_harqin0_info" protect="rw">
        <comment>PDSCH HARQIN</comment>
        <bits access="r" name="pds_len0" pos="25:16" rst="0x0">
          <comment>CB1HARQIN MEM0</comment>
        </bits>
        <bits access="r" name="pds_ini0" pos="9:0" rst="0x0">
          <comment>CB1HARQIN MEM0</comment>
        </bits>
      </reg>
      <reg name="pds1_harqin1_info" protect="rw">
        <comment>PDSCH HARQIN</comment>
        <bits access="r" name="pds_e0" pos="31:16" rst="0x0">
          <comment>CB1</comment>
        </bits>
        <bits access="r" name="pds_ini1" pos="12:0" rst="0x0">
          <comment>CB1HARQIN MEM1</comment>
        </bits>
      </reg>
      <reg name="si_harqin0_info" protect="rw">
        <comment>SI HARQIN</comment>
        <bits access="r" name="si_len0" pos="25:16" rst="0x0">
          <comment>SICB1HARQIN MEM0</comment>
        </bits>
        <bits access="r" name="si_ini0" pos="9:0" rst="0x0">
          <comment>SICB1HARQIN MEM0</comment>
        </bits>
      </reg>
      <reg name="si_harqin1_info" protect="rw">
        <comment>SI HARQIN</comment>
        <bits access="r" name="si_e0" pos="31:16" rst="0x0">
          <comment>SICB1</comment>
        </bits>
        <bits access="r" name="si_ini1" pos="12:0" rst="0x0">
          <comment>SICB1HARQIN MEM1</comment>
        </bits>
      </reg>
      <reg name="pag_harqin0_info" protect="rw">
        <comment>PAGING HARQIN</comment>
        <bits access="r" name="pag_len0" pos="25:16" rst="0x0">
          <comment>PAGINGCB1HARQIN MEM0</comment>
        </bits>
        <bits access="r" name="pag_ini0" pos="9:0" rst="0x0">
          <comment>PAGINGCB1HARQIN MEM0</comment>
        </bits>
      </reg>
      <reg name="pag_harqin1_info" protect="rw">
        <comment>PAGING HARQIN</comment>
        <bits access="r" name="pag_e0" pos="31:16" rst="0x0">
          <comment>PAGINGCB1</comment>
        </bits>
        <bits access="r" name="pag_ini1" pos="12:0" rst="0x0">
          <comment>PAGINGCB1HARQIN MEM1</comment>
        </bits>
      </reg>
      <reg name="cabis_shft_out" protect="rw">
        <comment>ABIS</comment>
        <bits access="r" name="cabis_shft3" pos="11:8" rst="0x0">
          <comment>ABIS31+2</comment>
        </bits>
        <bits access="r" name="cabis_shft2" pos="7:4" rst="0x0">
          <comment>ABIS22</comment>
        </bits>
        <bits access="r" name="cabis_shft1" pos="3:0" rst="0x0">
          <comment>ABIS11</comment>
        </bits>
      </reg>
      <reg name="dabis_shft_out" protect="rw">
        <comment>ABIS</comment>
        <bits access="r" name="dabis_shft3" pos="11:8" rst="0x0">
          <comment>ABIS31+2</comment>
        </bits>
        <bits access="r" name="dabis_shft2" pos="7:4" rst="0x0">
          <comment>ABIS22</comment>
        </bits>
        <bits access="r" name="dabis_shft1" pos="3:0" rst="0x0">
          <comment>ABIS11</comment>
        </bits>
      </reg>
      <reg name="mc_dly1_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="mc_dly1" pos="18:0" rst="0x0">
          <comment>1TS</comment>
        </bits>
      </reg>
      <reg name="mc_dly2_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="mc_dly2" pos="18:0" rst="0x0">
          <comment>2TS</comment>
        </bits>
      </reg>
      <reg name="mc_dlyth_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="mc_dlyth" pos="9:0" rst="0x0">
          <comment>TS</comment>
        </bits>
      </reg>
      <hole size="8384096"/>
      <reg name="cfhmem1" protect="rw">
        <bits access="rw" name="cfhmem1" pos="29:0" rst="0x0"/>
      </reg>
      <hole size="524256"/>
      <reg name="cfhmem2" protect="rw">
        <bits access="rw" name="cfhmem2" pos="29:0" rst="0x0"/>
      </reg>
      <hole size="524256"/>
      <reg name="crsmem1" protect="rw">
        <bits access="rw" name="crsmem1_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="crsmem1_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="crsmem2" protect="rw">
        <bits access="rw" name="crsmem2_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="crsmem2_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="clsmem" protect="rw">
        <bits access="rw" name="clsmem_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="clsmem_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="458720"/>
      <reg name="ursmem" protect="rw">
        <bits access="rw" name="ursmem_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="ursmem_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="ulsmem" protect="rw">
        <bits access="rw" name="ulsmem_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="ulsmem_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="pwr_mem1" protect="rw">
        </reg>
      <hole size="3552"/>
      <reg name="pwr_mem1_sb_sinr" protect="rw">
        </reg>
      <hole size="768"/>
      <reg name="pwr_mem1_wb_sinr" protect="rw">
        </reg>
      <hole size="61120"/>
      <reg name="cell_qfmem1" protect="rw">
        <bits access="rw" name="cell_qfmem1_re" pos="31:19" rst="0x0"/>
        <bits access="rw" name="cell_qfmem1_im" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="98272"/>
      <reg name="cell_qfmem2" protect="rw">
        <bits access="rw" name="cell_qfmem2_re" pos="31:19" rst="0x0"/>
        <bits access="rw" name="cell_qfmem2_im" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="163808"/>
      <reg name="ct_qtmem1" protect="rw">
        <bits access="rw" name="ct_qtmem1_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem1_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem1_p01_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem1_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem1_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem1_p01_tap3" protect="rw">
        <bits access="rw" name="ct_qtmem1_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem1_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="1184"/>
      <reg name="ct_qtmem1_p23_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem1_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem1_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="14240"/>
      <reg name="ct_qtmem2" protect="rw">
        <bits access="rw" name="ct_qtmem2_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem2_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem2_p01_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem2_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem2_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem2_p01_tap3" protect="rw">
        <bits access="rw" name="ct_qtmem2_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem2_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="1184"/>
      <reg name="ct_qtmem2_p23_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem2_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem2_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="47008"/>
      <reg name="dt_qtmem1" protect="rw">
        <bits access="rw" name="dt_qtmem1_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="dt_qtmem1_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="dt_qtmem2" protect="rw">
        <bits access="rw" name="dt_qtmem2_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="dt_qtmem2_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="98272"/>
      <reg name="agc_cls_mem" protect="rw">
        <bits access="rw" name="agc_cls_mem_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_cls_mem_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="agc_uls_mem" protect="rw">
        <bits access="rw" name="agc_uls_mem_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_uls_mem_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="agc_cfh_mem1" protect="rw">
        <bits access="rw" name="agc_cfh_mem1_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_cfh_mem1_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="agc_cfh_mem2" protect="rw">
        <bits access="rw" name="agc_cfh_mem2_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_cfh_mem2_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="agc_ufh_mem1" protect="rw">
        <bits access="rw" name="agc_ufh_mem1_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_ufh_mem1_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="agc_ufh_mem2" protect="rw">
        <bits access="rw" name="agc_ufh_mem2_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="agc_ufh_mem2_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="2016"/>
      <reg name="gold_ mem1" protect="rw">
        </reg>
      <hole size="2016"/>
      <reg name="gold_ mem2" protect="rw">
        </reg>
      <hole size="18400"/>
      <reg name="ufhmem" protect="rw">
        <bits access="rw" name="ufhmem" pos="29:0" rst="0x0"/>
      </reg>
      <hole size="294880"/>
      <reg name="csi_in_mem" protect="rw">
        <bits access="rw" name="csimem_re" pos="31:20" rst="0x0"/>
        <bits access="rw" name="csimem_im" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="pmi_mem" protect="rw">
        </reg>
      <hole size="352"/>
      <reg name="pmi_mem_sb" protect="rw">
        <bits access="rw" name="pmi_sb4" pos="31:28" rst="0x0"/>
        <bits access="rw" name="pmi_sb3" pos="27:24" rst="0x0"/>
        <bits access="rw" name="pmi_sb2" pos="23:20" rst="0x0"/>
        <bits access="rw" name="pmi_sb1" pos="19:16" rst="0x0"/>
        <bits access="rw" name="pmi_prb99" pos="15:12" rst="0x0"/>
        <bits access="rw" name="pmi_prb98" pos="11:8" rst="0x0"/>
        <bits access="rw" name="pmi_prb97" pos="7:4" rst="0x0"/>
        <bits access="rw" name="pmi_prb96" pos="3:0" rst="0x0"/>
      </reg>
      <hole size="228960"/>
      <reg name="cell_qfmem3" protect="rw">
        <bits access="rw" name="cell_qfmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="cell_qfmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="ct_qtmem3" protect="rw">
        <bits access="rw" name="ct_qtmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem3_p01_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="416"/>
      <reg name="ct_qtmem3_p01_tap3" protect="rw">
        <bits access="rw" name="ct_qtmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="1184"/>
      <reg name="ct_qtmem3_p23_tap2" protect="rw">
        <bits access="rw" name="ct_qtmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="ct_qtmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="63392"/>
      <reg name="dt_qtmem3" protect="rw">
        <bits access="rw" name="dt_qtmem3_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="dt_qtmem3_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="4849632"/>
      <reg name="sdmemch0" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="sdmemch1" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="sdmemcg0" protect="rw">
        <bits access="rw" name="sdmemcg0" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="sdmemcg1" protect="rw">
        <bits access="rw" name="sdmemcg1" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="sdmemdh0" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="sdmemdh1" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="sdmemdg0" protect="rw">
        <bits access="rw" name="sdmemdg0" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="sdmemdg1" protect="rw">
        <bits access="rw" name="sdmemdg1" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="sdmemdg2" protect="rw">
        <bits access="r" name="sdmemdg2" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="sdmemdg3" protect="rw">
        <bits access="r" name="sdmemdg3" pos="31:11" rst="0x0"/>
      </reg>
      <hole size="6717408"/>
      <reg name="pdcch_memin" protect="rw">
        <bits access="rw" name="pdcch_memin_2" pos="31:21" rst="0x0"/>
        <bits access="rw" name="pdcch_memin_1" pos="15:5" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="pdcch_memgold" protect="rw">
        </reg>
      <hole size="16352"/>
      <reg name="pdcch_mempbch0" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="pdcch_mempbch1" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="pdcch_mempbch2" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="dci0_out1" protect="rw">
        <comment>DCI01</comment>
      </reg>
      <reg name="dci0_out2" protect="rw">
        <comment>DCI02</comment>
      </reg>
      <reg name="dci0_pwr" protect="rw">
        <comment>DCI0</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI</comment>
        </bits>
      </reg>
      <reg name="dci0_fa" protect="rw">
        <comment>DCI0  LLR</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm0</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm</comment>
        </bits>
      </reg>
      <reg name="dci0_info1" protect="rw">
        <comment>DCI0 1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>
00
11</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI1A
0ORDER
1ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI
0
1
2
3</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI
0:DCI0
1:DCI1
2:DCI1A
3:DCI1B
4:DCI1C
5:DCI1D
6:DCI2
7:DCI2A
8:DCI2B
9:DCI2C
10:DCI3/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>DCI RNTI
0RNTI0SI-RNTI
1RNTI1P-RNTI
2RNTI2RA-RNTI
3RNTI3C-RNTI
4RNTI4SPS-RNTI
5RNTI5T-RNTI
6RNTI6TPCS-RNTI
7RNTI7TPCC-RNTI
8RNTI8G-RNTI
9RNTI9SC-RNTI
10RNTI10SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>DCICOMMUE
0
1UE</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>DCI(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>DCIL
000L=1;
001L=2;
010L=4;
011L=8;
100L=12;
101L=16;
110L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>DCI (max38)</comment>
        </bits>
      </reg>
      <reg name="dci0_info2" protect="rw">
        <comment>DCI0 2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>PMIDCIPMI
0DCIPMI
1PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>tx2:0~3tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>
0
1
2
3PORT7
4PORT8
5PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid(UE)0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>max12216</comment>
        </bits>
      </reg>
      <reg name="dci0_info3" protect="rw">
        <comment>DCI0 3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI0C</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI2/DCI2A/DCI2B/DCI2C2
01
12</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI0</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI0CQI</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI2/DCI2ATBCW
0
1</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS
SRQDCI0DCI1ADCI2B TDDDCI2C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI1D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="dci0_info4" protect="rw">
        <comment>DCI0 4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>
0TYPE0
1TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1RBA</comment>
        </bits>
      </reg>
      <reg name="dci0_info5" protect="rw">
        <comment>DCI0 5</comment>
      </reg>
      <reg name="dci0_info6" protect="rw">
        <comment>DCI0 6</comment>
      </reg>
      <reg name="dci0_info7" protect="rw">
        <comment>DCI0 7</comment>
      </reg>
      <reg name="dci0_info8" protect="rw">
        <comment>DCI0 8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci0_info9" protect="rw">
        <comment>DCI0 9</comment>
      </reg>
      <reg name="dci0_info10" protect="rw">
        <comment>DCI0 10</comment>
      </reg>
      <reg name="dci0_info11" protect="rw">
        <comment>DCI0 11</comment>
      </reg>
      <reg name="dci0_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci1_out1" protect="rw">
        <comment>DCI11</comment>
      </reg>
      <reg name="dci1_out2" protect="rw">
        <comment>DCI12</comment>
      </reg>
      <reg name="dci1_pwr" protect="rw">
        <comment>DCI1</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI</comment>
        </bits>
      </reg>
      <reg name="dci1_fa" protect="rw">
        <comment>DCI1  LLR</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm0</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm</comment>
        </bits>
      </reg>
      <reg name="dci1_info1" protect="rw">
        <comment>DCI1 1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>
00
11</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI1A
0ORDER
1ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI
0
1
2
3</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI
0:DCI1
1:DCI1
2:DCI1A
3:DCI1B
4:DCI1C
5:DCI1D
6:DCI2
7:DCI2A
8:DCI2B
9:DCI2C
10:DCI3/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>DCI RNTI
0RNTI0SI-RNTI
1RNTI1P-RNTI
2RNTI2RA-RNTI
3RNTI3C-RNTI
4RNTI4SPS-RNTI
5RNTI5T-RNTI
6RNTI6TPCS-RNTI
7RNTI7TPCC-RNTI
8RNTI8G-RNTI
9RNTI9SC-RNTI
10RNTI10SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>DCICOMMUE
0
1UE</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>DCI(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>DCIL
000L=1;
001L=2;
010L=4;
011L=8;
100L=12;
101L=16;
110L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>DCI (max38)</comment>
        </bits>
      </reg>
      <reg name="dci1_info2" protect="rw">
        <comment>DCI1 2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>PMIDCIPMI
0DCIPMI
1PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>tx2:0~3tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>
0
1
2
3PORT7
4PORT8
5PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid(UE)0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>max12216</comment>
        </bits>
      </reg>
      <reg name="dci1_info3" protect="rw">
        <comment>DCI1 3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI1C</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI2/DCI2A/DCI2B/DCI2C2
01
12</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI1</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI1CQI</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI2/DCI2ATBCW
0
1</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS
SRQDCI1DCI1ADCI2B TDDDCI2C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI1D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="dci1_info4" protect="rw">
        <comment>DCI1 4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>
0TYPE0
1TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1RBA</comment>
        </bits>
      </reg>
      <reg name="dci1_info5" protect="rw">
        <comment>DCI1 5</comment>
      </reg>
      <reg name="dci1_info6" protect="rw">
        <comment>DCI1 6</comment>
      </reg>
      <reg name="dci1_info7" protect="rw">
        <comment>DCI1 7</comment>
      </reg>
      <reg name="dci1_info8" protect="rw">
        <comment>DCI1 8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci1_info9" protect="rw">
        <comment>DCI1 9</comment>
      </reg>
      <reg name="dci1_info10" protect="rw">
        <comment>DCI1 10</comment>
      </reg>
      <reg name="dci1_info11" protect="rw">
        <comment>DCI1 11</comment>
      </reg>
      <reg name="dci1_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci2_out1" protect="rw">
        <comment>DCI21</comment>
      </reg>
      <reg name="dci2_out2" protect="rw">
        <comment>DCI22</comment>
      </reg>
      <reg name="dci2_pwr" protect="rw">
        <comment>DCI2</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI</comment>
        </bits>
      </reg>
      <reg name="dci2_fa" protect="rw">
        <comment>DCI2  LLR</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm0</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm</comment>
        </bits>
      </reg>
      <reg name="dci2_info1" protect="rw">
        <comment>DCI2 1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>
00
11</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI2A
0ORDER
1ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI
0
1
2
3</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI
0:DCI2
1:DCI2
2:DCI2A
3:DCI2B
4:DCI2C
5:DCI2D
6:DCI2
7:DCI2A
8:DCI2B
9:DCI2C
10:DCI3/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>DCI RNTI
0RNTI0SI-RNTI
1RNTI1P-RNTI
2RNTI2RA-RNTI
3RNTI3C-RNTI
4RNTI4SPS-RNTI
5RNTI5T-RNTI
6RNTI6TPCS-RNTI
7RNTI7TPCC-RNTI
8RNTI8G-RNTI
9RNTI9SC-RNTI
10RNTI10SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>DCICOMMUE
0
1UE</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>DCI(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>DCIL
000L=1;
001L=2;
010L=4;
011L=8;
100L=12;
101L=16;
110L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>DCI (max38)</comment>
        </bits>
      </reg>
      <reg name="dci2_info2" protect="rw">
        <comment>DCI2 2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>PMIDCIPMI
0DCIPMI
1PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>tx2:0~3tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>
0
1
2
3PORT7
4PORT8
5PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid(UE)0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>max12216</comment>
        </bits>
      </reg>
      <reg name="dci2_info3" protect="rw">
        <comment>DCI2 3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI2C</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI2/DCI2A/DCI2B/DCI2C2
01
12</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI2</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI2CQI</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI2/DCI2ATBCW
0
1</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS
SRQDCI2DCI2ADCI2B TDDDCI2C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI2D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="dci2_info4" protect="rw">
        <comment>DCI2 4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>
0TYPE0
1TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1RBA</comment>
        </bits>
      </reg>
      <reg name="dci2_info5" protect="rw">
        <comment>DCI2 5</comment>
      </reg>
      <reg name="dci2_info6" protect="rw">
        <comment>DCI2 6</comment>
      </reg>
      <reg name="dci2_info7" protect="rw">
        <comment>DCI2 7</comment>
      </reg>
      <reg name="dci2_info8" protect="rw">
        <comment>DCI2 8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci2_info9" protect="rw">
        <comment>DCI2 9</comment>
      </reg>
      <reg name="dci2_info10" protect="rw">
        <comment>DCI2 10</comment>
      </reg>
      <reg name="dci2_info11" protect="rw">
        <comment>DCI2 11</comment>
      </reg>
      <reg name="dci2_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci3_out1" protect="rw">
        <comment>DCI31</comment>
      </reg>
      <reg name="dci3_out2" protect="rw">
        <comment>DCI32</comment>
      </reg>
      <reg name="dci3_pwr" protect="rw">
        <comment>DCI3</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI</comment>
        </bits>
      </reg>
      <reg name="dci3_fa" protect="rw">
        <comment>DCI3  LLR</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm0</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm</comment>
        </bits>
      </reg>
      <reg name="dci3_info1" protect="rw">
        <comment>DCI3 1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>
00
11</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI3A
0ORDER
1ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI
0
1
2
3</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI
0:DCI3
1:DCI3
2:DCI3A
3:DCI3B
4:DCI3C
5:DCI3D
6:DCI3
7:DCI3A
8:DCI3B
9:DCI3C
10:DCI3/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>DCI RNTI
0RNTI0SI-RNTI
1RNTI1P-RNTI
2RNTI2RA-RNTI
3RNTI3C-RNTI
4RNTI4SPS-RNTI
5RNTI5T-RNTI
6RNTI6TPCS-RNTI
7RNTI7TPCC-RNTI
8RNTI8G-RNTI
9RNTI9SC-RNTI
10RNTI10SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>DCICOMMUE
0
1UE</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>DCI(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>DCIL
000L=1;
001L=2;
010L=4;
011L=8;
100L=12;
101L=16;
110L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>DCI (max38)</comment>
        </bits>
      </reg>
      <reg name="dci3_info2" protect="rw">
        <comment>DCI3 2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>PMIDCIPMI
0DCIPMI
1PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>tx2:0~3tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>
0
1
2
3PORT7
4PORT8
5PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid(UE)0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>max12216</comment>
        </bits>
      </reg>
      <reg name="dci3_info3" protect="rw">
        <comment>DCI3 3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI3C</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI3/DCI3A/DCI3B/DCI3C2
01
12</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI3</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI3CQI</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI3/DCI3ATBCW
0
1</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS
SRQDCI3DCI3ADCI3B TDDDCI3C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI3D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="dci3_info4" protect="rw">
        <comment>DCI3 4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>
0TYPE0
1TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1RBA</comment>
        </bits>
      </reg>
      <reg name="dci3_info5" protect="rw">
        <comment>DCI3 5</comment>
      </reg>
      <reg name="dci3_info6" protect="rw">
        <comment>DCI3 6</comment>
      </reg>
      <reg name="dci3_info7" protect="rw">
        <comment>DCI3 7</comment>
      </reg>
      <reg name="dci3_info8" protect="rw">
        <comment>DCI3 8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci3_info9" protect="rw">
        <comment>DCI3 9</comment>
      </reg>
      <reg name="dci3_info10" protect="rw">
        <comment>DCI3 10</comment>
      </reg>
      <reg name="dci3_info11" protect="rw">
        <comment>DCI3 11</comment>
      </reg>
      <reg name="dci3_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci4_out1" protect="rw">
        <comment>DCI41</comment>
      </reg>
      <reg name="dci4_out2" protect="rw">
        <comment>DCI42</comment>
      </reg>
      <reg name="dci4_pwr" protect="rw">
        <comment>DCI4</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI</comment>
        </bits>
      </reg>
      <reg name="dci4_fa" protect="rw">
        <comment>DCI4  LLR</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm0</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm</comment>
        </bits>
      </reg>
      <reg name="dci4_info1" protect="rw">
        <comment>DCI4 1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>
00
11</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI4A
0ORDER
1ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI
0
1
2
3</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI
0:DCI4
1:DCI4
2:DCI4A
3:DCI4B
4:DCI4C
5:DCI4D
6:DCI4
7:DCI4A
8:DCI4B
9:DCI4C
10:DCI4/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>DCI RNTI
0RNTI0SI-RNTI
1RNTI1P-RNTI
2RNTI2RA-RNTI
3RNTI3C-RNTI
4RNTI4SPS-RNTI
5RNTI5T-RNTI
6RNTI6TPCS-RNTI
7RNTI7TPCC-RNTI
8RNTI8G-RNTI
9RNTI9SC-RNTI
10RNTI10SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>DCICOMMUE
0
1UE</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>DCI(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>DCIL
000L=1;
001L=2;
010L=4;
011L=8;
100L=12;
101L=16;
110L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>DCI (max38)</comment>
        </bits>
      </reg>
      <reg name="dci4_info2" protect="rw">
        <comment>DCI4 2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>PMIDCIPMI
0DCIPMI
1PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>tx2:0~3tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>
0
1
2
3PORT7
4PORT8
5PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid(UE)0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>max12216</comment>
        </bits>
      </reg>
      <reg name="dci4_info3" protect="rw">
        <comment>DCI4 3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI4C</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI4/DCI4A/DCI4B/DCI4C2
01
12</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI4</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI4CQI</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI4/DCI4ATBCW
0
1</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS
SRQDCI4DCI4ADCI4B TDDDCI4C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI4D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="dci4_info4" protect="rw">
        <comment>DCI4 4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>
0TYPE0
1TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1RBA</comment>
        </bits>
      </reg>
      <reg name="dci4_info5" protect="rw">
        <comment>DCI4 5</comment>
      </reg>
      <reg name="dci4_info6" protect="rw">
        <comment>DCI4 6</comment>
      </reg>
      <reg name="dci4_info7" protect="rw">
        <comment>DCI4 7</comment>
      </reg>
      <reg name="dci4_info8" protect="rw">
        <comment>DCI4 8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci4_info9" protect="rw">
        <comment>DCI4 9</comment>
      </reg>
      <reg name="dci4_info10" protect="rw">
        <comment>DCI4 10</comment>
      </reg>
      <reg name="dci4_info11" protect="rw">
        <comment>DCI4 11</comment>
      </reg>
      <reg name="dci4_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci5_out1" protect="rw">
        <comment>DCI51</comment>
      </reg>
      <reg name="dci5_out2" protect="rw">
        <comment>DCI52</comment>
      </reg>
      <reg name="dci5_pwr" protect="rw">
        <comment>DCI5</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI</comment>
        </bits>
      </reg>
      <reg name="dci5_fa" protect="rw">
        <comment>DCI5  LLR</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm0</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm</comment>
        </bits>
      </reg>
      <reg name="dci5_info1" protect="rw">
        <comment>DCI5 1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>
00
11</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI5A
0ORDER
1ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI
0
1
2
3</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI
0:DCI5
1:DCI5
2:DCI5A
3:DCI5B
4:DCI5C
5:DCI5D
6:DCI5
7:DCI5A
8:DCI5B
9:DCI5C
10:DCI5/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>DCI RNTI
0RNTI0SI-RNTI
1RNTI1P-RNTI
2RNTI2RA-RNTI
3RNTI3C-RNTI
4RNTI4SPS-RNTI
5RNTI5T-RNTI
6RNTI6TPCS-RNTI
7RNTI7TPCC-RNTI
8RNTI8G-RNTI
9RNTI9SC-RNTI
10RNTI10SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>DCICOMMUE
0
1UE</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>DCI(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>DCIL
000L=1;
001L=2;
010L=4;
011L=8;
100L=12;
101L=16;
110L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>DCI (max38)</comment>
        </bits>
      </reg>
      <reg name="dci5_info2" protect="rw">
        <comment>DCI5 2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>PMIDCIPMI
0DCIPMI
1PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>tx2:0~3tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>
0
1
2
3PORT7
4PORT8
5PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid(UE)0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>max12216</comment>
        </bits>
      </reg>
      <reg name="dci5_info3" protect="rw">
        <comment>DCI5 3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI5C</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI5/DCI5A/DCI5B/DCI5C2
01
12</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI5</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI5CQI</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI5/DCI5ATBCW
0
1</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS
SRQDCI5DCI5ADCI5B TDDDCI5C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI5D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="dci5_info4" protect="rw">
        <comment>DCI5 4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>
0TYPE0
1TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1RBA</comment>
        </bits>
      </reg>
      <reg name="dci5_info5" protect="rw">
        <comment>DCI5 5</comment>
      </reg>
      <reg name="dci5_info6" protect="rw">
        <comment>DCI5 6</comment>
      </reg>
      <reg name="dci5_info7" protect="rw">
        <comment>DCI5 7</comment>
      </reg>
      <reg name="dci5_info8" protect="rw">
        <comment>DCI5 8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci5_info9" protect="rw">
        <comment>DCI5 9</comment>
      </reg>
      <reg name="dci5_info10" protect="rw">
        <comment>DCI5 10</comment>
      </reg>
      <reg name="dci5_info11" protect="rw">
        <comment>DCI5 11</comment>
      </reg>
      <reg name="dci5_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci6_out1" protect="rw">
        <comment>DCI61</comment>
      </reg>
      <reg name="dci6_out2" protect="rw">
        <comment>DCI62</comment>
      </reg>
      <reg name="dci6_pwr" protect="rw">
        <comment>DCI6</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI</comment>
        </bits>
      </reg>
      <reg name="dci6_fa" protect="rw">
        <comment>DCI6  LLR</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm0</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm</comment>
        </bits>
      </reg>
      <reg name="dci6_info1" protect="rw">
        <comment>DCI6 1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>
00
11</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI6A
0ORDER
1ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI
0
1
2
3</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI
0:DCI6
1:DCI6
2:DCI6A
3:DCI6B
4:DCI6C
5:DCI6D
6:DCI6
7:DCI6A
8:DCI6B
9:DCI6C
10:DCI6/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>DCI RNTI
0RNTI0SI-RNTI
1RNTI1P-RNTI
2RNTI2RA-RNTI
3RNTI3C-RNTI
4RNTI4SPS-RNTI
5RNTI5T-RNTI
6RNTI6TPCS-RNTI
7RNTI7TPCC-RNTI
8RNTI8G-RNTI
9RNTI9SC-RNTI
10RNTI10SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>DCICOMMUE
0
1UE</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>DCI(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>DCIL
000L=1;
001L=2;
010L=4;
011L=8;
100L=12;
101L=16;
110L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>DCI (max38)</comment>
        </bits>
      </reg>
      <reg name="dci6_info2" protect="rw">
        <comment>DCI6 2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>PMIDCIPMI
0DCIPMI
1PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>tx2:0~3tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>
0
1
2
3PORT7
4PORT8
5PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid(UE)0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>max12216</comment>
        </bits>
      </reg>
      <reg name="dci6_info3" protect="rw">
        <comment>DCI6 3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI6C</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI6/DCI6A/DCI6B/DCI6C2
01
12</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI6</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI6CQI</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI6/DCI6ATBCW
0
1</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS
SRQDCI6DCI6ADCI6B TDDDCI6C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI6D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="dci6_info4" protect="rw">
        <comment>DCI6 4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>
0TYPE0
1TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1RBA</comment>
        </bits>
      </reg>
      <reg name="dci6_info5" protect="rw">
        <comment>DCI6 5</comment>
      </reg>
      <reg name="dci6_info6" protect="rw">
        <comment>DCI6 6</comment>
      </reg>
      <reg name="dci6_info7" protect="rw">
        <comment>DCI6 7</comment>
      </reg>
      <reg name="dci6_info8" protect="rw">
        <comment>DCI6 8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci6_info9" protect="rw">
        <comment>DCI6 9</comment>
      </reg>
      <reg name="dci6_info10" protect="rw">
        <comment>DCI6 10</comment>
      </reg>
      <reg name="dci6_info11" protect="rw">
        <comment>DCI6 11</comment>
      </reg>
      <reg name="dci6_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci7_out1" protect="rw">
        <comment>DCI71</comment>
      </reg>
      <reg name="dci7_out2" protect="rw">
        <comment>DCI72</comment>
      </reg>
      <reg name="dci7_pwr" protect="rw">
        <comment>DCI7</comment>
        <bits access="rw" name="dci_pwr" pos="25:0" rst="0x0">
          <comment>DCI</comment>
        </bits>
      </reg>
      <reg name="dci7_fa" protect="rw">
        <comment>DCI7  LLR</comment>
        <bits access="rw" name="dci_fa_zero" pos="15:8" rst="0x0">
          <comment>DCI false alarm0</comment>
        </bits>
        <bits access="rw" name="dci_fa" pos="7:0" rst="0x0">
          <comment>DCI false alarm</comment>
        </bits>
      </reg>
      <reg name="dci7_info1" protect="rw">
        <comment>DCI7 1</comment>
        <bits access="rw" name="ant_sel" pos="28" rst="0x0">
          <comment>
00
11</comment>
        </bits>
        <bits access="rw" name="order_flag" pos="27" rst="0x0">
          <comment>DCI7A
0ORDER
1ORDER</comment>
        </bits>
        <bits access="rw" name="sps_ind" pos="26:25" rst="0x0">
          <comment>SPS-C-RNTI
0
1
2
3</comment>
        </bits>
        <bits access="rw" name="dci_type" pos="24:21" rst="0x0">
          <comment>DCI
0:DCI7
1:DCI7
2:DCI7A
3:DCI7B
4:DCI7C
5:DCI7D
6:DCI7
7:DCI7A
8:DCI7B
9:DCI7C
10:DCI7/3A</comment>
        </bits>
        <bits access="rw" name="rnti_ind" pos="20:17" rst="0x0">
          <comment>DCI RNTI
0RNTI0SI-RNTI
1RNTI1P-RNTI
2RNTI2RA-RNTI
3RNTI3C-RNTI
4RNTI4SPS-RNTI
5RNTI5T-RNTI
6RNTI6TPCS-RNTI
7RNTI7TPCC-RNTI
8RNTI8G-RNTI
9RNTI9SC-RNTI
10RNTI10SC-N-RNTI</comment>
        </bits>
        <bits access="rw" name="comm_ue" pos="16" rst="0x0">
          <comment>DCICOMMUE
0
1UE</comment>
        </bits>
        <bits access="rw" name="dci_stapos" pos="15:9" rst="0x0">
          <comment>DCI(index:0~23)</comment>
        </bits>
        <bits access="rw" name="dci_llevel" pos="8:6" rst="0x0">
          <comment>DCIL
000L=1;
001L=2;
010L=4;
011L=8;
100L=12;
101L=16;
110L=24;</comment>
        </bits>
        <bits access="rw" name="dci_len" pos="5:0" rst="0x0">
          <comment>DCI (max38)</comment>
        </bits>
      </reg>
      <reg name="dci7_info2" protect="rw">
        <comment>DCI7 2</comment>
        <bits access="rw" name="pmi_confm" pos="31" rst="0x0">
          <comment>PMIDCIPMI
0DCIPMI
1PMI</comment>
        </bits>
        <bits access="rw" name="hq_proc" pos="30:27" rst="0x0">
          <comment>HARQ:0~15</comment>
        </bits>
        <bits access="rw" name="pmi_indx" pos="26:23" rst="0x0">
          <comment>tx2:0~3tx4:0~15</comment>
        </bits>
        <bits access="rw" name="trans_scheme" pos="22:20" rst="0x0">
          <comment>
0
1
2
3PORT7
4PORT8
5PORT5</comment>
        </bits>
        <bits access="rw" name="ra_type" pos="19" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="n_scid" pos="18" rst="0x0">
          <comment>Nscid(UE)0~1</comment>
        </bits>
        <bits access="rw" name="rv_sel" pos="17:16" rst="0x0">
          <comment>0~3</comment>
        </bits>
        <bits access="rw" name="modu_type" pos="15:14" rst="0x0">
          <comment>
0:QPSK
1:16QAM
2:64QAM</comment>
        </bits>
        <bits access="rw" name="tb_size" pos="13:0" rst="0x0">
          <comment>max12216</comment>
        </bits>
      </reg>
      <reg name="dci7_info3" protect="rw">
        <comment>DCI7 3</comment>
        <bits access="rw" name="rep" pos="21:19" rst="0x0">
          <comment>DCI7C</comment>
        </bits>
        <bits access="rw" name="mcs" pos="18:14" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="cw2_flag" pos="13" rst="0x0">
          <comment>DCI7/DCI7A/DCI7B/DCI7C2
01
12</comment>
        </bits>
        <bits access="rw" name="cs_dmrs" pos="12:10" rst="0x0">
          <comment>DCI7</comment>
        </bits>
        <bits access="rw" name="cqi_indx" pos="9:8" rst="0x0">
          <comment>DCI7CQI</comment>
        </bits>
        <bits access="rw" name="tb_cw" pos="7" rst="0x0">
          <comment>DCI7/DCI7ATBCW
0
1</comment>
        </bits>
        <bits access="rw" name="srs_req" pos="6" rst="0x0">
          <comment>SRS
SRQDCI7DCI7ADCI7B TDDDCI7C TDD</comment>
        </bits>
        <bits access="rw" name="ndi_ind" pos="5" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="pwr_ofst" pos="4" rst="0x0">
          <comment>DCI7D POWER OFFSET</comment>
        </bits>
        <bits access="rw" name="dai" pos="3:2" rst="0x0">
          <comment>DAI</comment>
        </bits>
        <bits access="rw" name="tpc_step" pos="1:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="dci7_info4" protect="rw">
        <comment>DCI7 4</comment>
        <bits access="rw" name="nul_fd" pos="31:15" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="ra_type" pos="14" rst="0x0">
          <comment>
0TYPE0
1TYPE1</comment>
        </bits>
        <bits access="rw" name="rb_hop_flag" pos="13" rst="0x0">
          <comment>Type0</comment>
        </bits>
        <bits access="rw" name="rba" pos="12:0" rst="0x0">
          <comment>Type0/Type1RBA</comment>
        </bits>
      </reg>
      <reg name="dci7_info5" protect="rw">
        <comment>DCI7 5</comment>
      </reg>
      <reg name="dci7_info6" protect="rw">
        <comment>DCI7 6</comment>
      </reg>
      <reg name="dci7_info7" protect="rw">
        <comment>DCI7 7</comment>
      </reg>
      <reg name="dci7_info8" protect="rw">
        <comment>DCI7 8</comment>
        <bits access="rw" name="rb_bm_03" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <reg name="dci7_info9" protect="rw">
        <comment>DCI7 9</comment>
      </reg>
      <reg name="dci7_info10" protect="rw">
        <comment>DCI7 10</comment>
      </reg>
      <reg name="dci7_info11" protect="rw">
        <comment>DCI7 11</comment>
      </reg>
      <reg name="dci7_info12" protect="rw">
        <bits access="rw" name="rb_bm_13" pos="3:0" rst="0x0">
          <comment>0.5msbitmapbitprb[99:96]bit
0prb
1prb</comment>
        </bits>
      </reg>
      <hole size="86016"/>
      <reg name="pdcch_memdem" protect="rw">
        <bits access="rw" name="pdcch_memdem_2" pos="31:21" rst="0x0"/>
        <bits access="rw" name="pdcch_memdem_1" pos="15:5" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="pdcch_memreg" protect="rw">
        </reg>
      <hole size="65504"/>
      <reg name="pdcch_mempbchin" protect="rw">
        <bits access="rw" name="pbch_memin_2" pos="31:22" rst="0x0"/>
        <bits access="rw" name="pbch_memin_1" pos="15:6" rst="0x0"/>
      </reg>
      <hole size="8160"/>
      <reg name="mib0_out" protect="rw">
        <comment>MIB01</comment>
        <bits access="r" name="mib0_out" pos="23:0" rst="0x0">
          <comment>MIB0</comment>
        </bits>
      </reg>
      <reg name="mib0_info" protect="rw">
        <comment>MIB0INFO</comment>
        <bits access="r" name="mib0_info" pos="1:0" rst="0x0">
          <comment>MIB </comment>
        </bits>
      </reg>
      <reg name="mib1_out" protect="rw">
        <comment>MIB11</comment>
        <bits access="r" name="mib1_out" pos="23:0" rst="0x0">
          <comment>MIB1</comment>
        </bits>
      </reg>
      <reg name="mib1_info" protect="rw">
        <comment>MIB1INFO</comment>
        <bits access="r" name="mib1_info" pos="1:0" rst="0x0">
          <comment>MIB </comment>
        </bits>
      </reg>
      <reg name="mib2_out" protect="rw">
        <comment>MIB21</comment>
        <bits access="r" name="mib2_out" pos="23:0" rst="0x0">
          <comment>MIB2</comment>
        </bits>
      </reg>
      <reg name="mib2_info" protect="rw">
        <comment>MIB2INFO</comment>
        <bits access="r" name="mib2_info" pos="1:0" rst="0x0">
          <comment>MIB </comment>
        </bits>
      </reg>
      <reg name="mib3_out" protect="rw">
        <comment>MIB31</comment>
        <bits access="r" name="mib3_out" pos="23:0" rst="0x0">
          <comment>MIB3</comment>
        </bits>
      </reg>
      <reg name="mib3_info" protect="rw">
        <comment>MIB3INFO</comment>
        <bits access="r" name="mib3_info" pos="1:0" rst="0x0">
          <comment>MIB </comment>
        </bits>
      </reg>
      <hole size="7921408"/>
      <reg name="hqmem11" protect="rw">
        <bits access="rw" name="hqmem11_2" pos="31:19" rst="0x0"/>
        <bits access="rw" name="hqmem11_1" pos="15:3" rst="0x0"/>
      </reg>
      <hole size="98272"/>
      <reg name="hqmem12" protect="rw">
        </reg>
      <hole size="950240"/>
      <reg name="hqmem21" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="hqmem22" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="hqmem23" protect="rw">
        </reg>
      <hole size="262112"/>
      <reg name="hqmem24" protect="rw">
        </reg>
      <hole size="6553568"/>
      <reg name="tbmemin0" protect="rw">
        <bits access="rw" name="tbmemin0" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="229344"/>
      <reg name="tbmemout0" protect="rw">
        </reg>
      <hole size="294880"/>
      <reg name="tbmemin1" protect="rw">
        <bits access="rw" name="tbmemin1" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="229344"/>
      <reg name="tbmemout1" protect="rw">
        </reg>
      <hole size="294880"/>
      <reg name="pdsmemout0" protect="rw">
        </reg>
      <hole size="12256"/>
      <reg name="pdsmemout0_si" protect="rw">
        </reg>
      <hole size="2208"/>
      <reg name="pdsmemout0_pch" protect="rw">
        </reg>
      <hole size="18208"/>
      <reg name="pdsmemout1" protect="rw">
        </reg>
      <hole size="12256"/>
      <reg name="pdsmemout1_si" protect="rw">
        </reg>
      <hole size="2208"/>
      <reg name="pdsmemout1_pch" protect="rw">
        </reg>
      <hole size="7292704"/>
      <reg name="fftbuf0" protect="rw">
        </reg>
      <hole size="524256"/>
      <reg name="fftbuf1" protect="rw">
        </reg>
      <hole size="7864288"/>
      <reg name="hqbuf" protect="rw">
        </reg>
    </module>
    <instance address="0x19000000" name="LDTC1" type="LDTC1"/>
  </archive>
  <archive relative="dlfft.xml">
    <module category="System" name="DLFFT">
      <reg name="dlfft_frame_config_next" protect="rw">
        <comment></comment>
        <bits access="rw" name="crs_pow_ofdm0_next" pos="19" rst="0x1">
          <comment>CATMCELL RSOFDM0
0OFDM0
1OFDM0</comment>
        </bits>
        <bits access="rw" name="fft_norm_sel_next" pos="18" rst="0x0">
          <comment>FFT
0
1</comment>
        </bits>
        <bits access="rw" name="fft_norm_en_next" pos="17" rst="0x0">
          <comment>0FFTFFT
1FFTFFT</comment>
        </bits>
        <bits access="rw" name="dlfft_only_en_next" pos="16" rst="0x0">
          <comment>0DLFFTLDTC1LDTC
1DLFFTLDTC1LDTC</comment>
        </bits>
        <bits access="rw" name="fft_dma_inten_next" pos="15" rst="0x1">
          <comment>1DLFFTTXRXOFDM
0DLFFT</comment>
        </bits>
        <bits access="rw" name="master_card_next" pos="14" rst="0x0">
          <comment>0:
1:</comment>
        </bits>
        <bits access="rw" name="sys_frame_num_next" pos="13:4" rst="0x0">
          <comment>0~1023</comment>
        </bits>
        <bits access="rw" name="sub_frame_num_next" pos="3:0" rst="0x0">
          <comment>0~9</comment>
        </bits>
      </reg>
      <reg name="cat1_rs_ctrl_next" protect="rw">
        <comment>CAT1RS</comment>
        <bits access="rw" name="crs_pow_index_next" pos="21:19" rst="0x0">
          <comment>CELL RS&amp;AGC
000
001
010
011
100
</comment>
        </bits>
        <bits access="rw" name="cat1_crs_pow_ofdm0_next" pos="18" rst="0x1">
          <comment>CAT1CELL RSOFDM0
0OFDM0
1OFDM0</comment>
        </bits>
        <bits access="rw" name="mbms_mode_sel_next" pos="17:16" rst="0x0">
          <comment>MBMS
2b00MBMSCELLRS
2b01MBMS1CELLRS
2b10MBMS2CELLRS
2b1100</comment>
        </bits>
        <bits access="rw" name="mbms_en_next" pos="15" rst="0x0">
          <comment>0MBMS
1MBMS</comment>
        </bits>
        <bits access="rw" name="cellid_next" pos="14:6" rst="0x0">
          <comment>CELLID</comment>
        </bits>
        <bits access="rw" name="cp_sel_next" pos="5" rst="0x0">
          <comment>CP
0NORM CP
1EX CP</comment>
        </bits>
        <bits access="rw" name="cellport_sel_next" pos="4:3" rst="0x0">
          <comment>CELLRS PORT
2b00port0
2b01port0/1
2b10port0/1/2/3
2b11CELLPORT_SEL2b112b00prot0</comment>
        </bits>
        <bits access="rw" name="ueport_sel_next" pos="2" rst="0x0">
          <comment>UERS PORT
0port5
1port7/8</comment>
        </bits>
        <bits access="rw" name="cellrs_en_next" pos="1" rst="0x0">
          <comment>0CELLRS
1CELLRS</comment>
        </bits>
        <bits access="rw" name="uers_en_next" pos="0" rst="0x0">
          <comment>0UERS
1UERS</comment>
        </bits>
      </reg>
      <reg name="cat1_csi_para_next" protect="rw">
        <comment>CAT1CSIRS</comment>
        <bits access="rw" name="csirs_bitmap_next" pos="19:8" rst="0x0">
          <comment>RSCSIRSCSIRS BITMAP</comment>
        </bits>
        <bits access="rw" name="csirs_ofdm1_next" pos="7:4" rst="0x0">
          <comment>CSIRSCSIRSOFDM</comment>
        </bits>
        <bits access="rw" name="csirs_ofdm0_next" pos="3:0" rst="0x0">
          <comment>CSIRSCSIRSOFDM</comment>
        </bits>
      </reg>
      <reg name="cat1_agc_next" protect="rw">
        <comment>CAT1AGC</comment>
        <bits access="rw" name="agc1_next" pos="19:10" rst="0x0">
          <comment>MBMSCELLRSOFDMAGC</comment>
        </bits>
        <bits access="rw" name="agc0_next" pos="9:0" rst="0x0">
          <comment>MBMSAGCMBMSCELLRSOFDMAGC</comment>
        </bits>
      </reg>
      <reg name="cat1_dlfft_ctrl_next" protect="rw">
        <comment>DLFFT</comment>
        <bits access="rw" name="pbch_en_next" pos="1" rst="0x0">
          <comment>0PBCH
1PBCH</comment>
        </bits>
        <bits access="rw" name="csirs_en_next" pos="0" rst="0x0">
          <comment>0CSIRS
1CSIRS</comment>
        </bits>
      </reg>
      <reg name="cat1_sys_config_next" protect="rw">
        <comment>CAT1</comment>
        <bits access="rw" name="prb_index_next" pos="10:8" rst="0x0">
          <comment>PRB
0006prb
00115prb
01025prb
01150prb
10075prb
101100prb
1116prb</comment>
        </bits>
        <bits access="rw" name="up_down_config" pos="7:5" rst="0x0">
          <comment>0~6</comment>
        </bits>
        <bits access="rw" name="mode_sel_next" pos="4" rst="0x0">
          <comment>0TDD MODE
1FDD MODE</comment>
        </bits>
        <bits access="rw" name="s_frame_config" pos="3:0" rst="0x0">
          <comment>  0~9</comment>
        </bits>
      </reg>
      <reg name="cat1_fft_gate_next" protect="rw">
        <comment>CAT1FFT</comment>
        <bits access="rw" name="fft_gate_next" pos="12:0" rst="0x0">
          <comment>FFT0~4096</comment>
        </bits>
      </reg>
      <reg name="catm_nb_sys_config_next" protect="rw">
        <comment>CATM/NB</comment>
        <bits access="rw" name="prb_index_next" pos="11:9" rst="0x0">
          <comment>NBIOTNBPRB0~5</comment>
        </bits>
        <bits access="rw" name="cp_sel_next" pos="8" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="rw" name="up_down_config_next" pos="7:5" rst="0x0">
          <comment>0~6</comment>
        </bits>
        <bits access="rw" name="mode_sel_next" pos="4" rst="0x0">
          <comment>0TDD MODE
1FDD MODE</comment>
        </bits>
        <bits access="rw" name="s_frame_config_next" pos="3:0" rst="0x0">
          <comment>  0~9</comment>
        </bits>
      </reg>
      <reg name="catm_nb_rs_config_next" protect="rw">
        <comment>CATM/NBRS</comment>
        <bits access="rw" name="crs_pow_index_next" pos="15:13" rst="0x0">
          <comment>CELL RS&amp;AGC
000
001
010
011
100
</comment>
        </bits>
        <bits access="rw" name="crs_nrs_sel_next" pos="12" rst="0x0">
          <comment>0NBNRS
1NBCRS</comment>
        </bits>
        <bits access="rw" name="id_value_next" pos="11:3" rst="0x0">
          <comment>CELLRSNRSID</comment>
        </bits>
        <bits access="rw" name="rsport_sel_next" pos="2:1" rst="0x0">
          <comment>CELLRSNRS PORT
2b00port0
2b01port0/1
2b10port0/1/2/3
2b112b10</comment>
        </bits>
      </reg>
      <reg name="catm_nb_nbw_next" protect="rw">
        <comment>CATM/NB</comment>
        <bits access="rw" name="nbw_cover_zero_sel_next" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="catm_agc_next" protect="rw">
        <comment>CATMAGC</comment>
        <bits access="rw" name="catm_agc_next" pos="9:0" rst="0x0">
          <comment>CATMAGC</comment>
        </bits>
      </reg>
      <reg name="abis_config_next" protect="rw">
        <comment>ABIS</comment>
        <bits access="rw" name="frame_intra_sel_next" pos="31" rst="0x0">
          <comment>0LDTC1LLR0
1LDTC1LLR</comment>
        </bits>
        <bits access="rw" name="ctcg_sel_next" pos="30" rst="0x0">
          <comment>CTCG
0OFDM4(OFDM4)CRS
1OFDM8(OFDM8)CRS</comment>
        </bits>
        <bits access="rw" name="num_neibour_next" pos="29:28" rst="0x0">
          <comment>
000
011
102
0</comment>
        </bits>
        <bits access="rw" name="txnum_neibour_next2" pos="27:26" rst="0x0">
          <comment>2
001port
012port
104port
1port</comment>
        </bits>
        <bits access="rw" name="txnum_neibour_next1" pos="25:24" rst="0x0">
          <comment>1
001port
012port
104port
1port</comment>
        </bits>
        <bits access="rw" name="nrb_neibour_next2" pos="23:21" rst="0x0">
          <comment>2 
0006prb
00115prb
01025prb
01150prb
10075prb
101100prb
6prb</comment>
        </bits>
        <bits access="rw" name="nrb_neibour_next1" pos="20:18" rst="0x0">
          <comment>1 
0006prb
00115prb
01025prb
01150prb
10075prb
101100prb
6prb</comment>
        </bits>
        <bits access="rw" name="cellid_neibour_next2" pos="17:9" rst="0x0">
          <comment>2 CELL ID</comment>
        </bits>
        <bits access="rw" name="cellid_neibour_next1" pos="8:0" rst="0x0">
          <comment>1 CELL ID</comment>
        </bits>
      </reg>
      <reg name="delay_next1" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="delay_next1" pos="18:0" rst="0x0">
          <comment>1TS</comment>
        </bits>
      </reg>
      <reg name="delay_next2" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="delay_next2" pos="18:0" rst="0x0">
          <comment>2TS</comment>
        </bits>
      </reg>
      <reg name="pb_next" protect="rw">
        <comment>CRSCRS</comment>
        <bits access="rw" name="abis_llr_shift_modify_next" pos="12:8" rst="0x0"/>
        <bits access="rw" name="abis_start_ofdm_next" pos="7:4" rst="0x0">
          <comment>ABISOFDM0~13</comment>
        </bits>
        <bits access="rw" name="pb_next" pos="1:0" rst="0x0">
          <comment>CRSCRS</comment>
        </bits>
      </reg>
      <reg name="noise_delta_next" protect="rw">
        <comment></comment>
      </reg>
      <reg name="noise_agc_next" protect="rw">
        <comment>AGC</comment>
        <bits access="rw" name="noise_agc_next" pos="9:0" rst="0x0">
          <comment>AGC</comment>
        </bits>
      </reg>
      <reg name="dlfft_mode_next" protect="rw">
        <comment></comment>
        <bits access="rw" name="dlfft_info_sel_next" pos="14" rst="0x0">
          <comment>0DLFFT_INFO_OUT1
1DLFFT_INFO_OUT2</comment>
        </bits>
        <bits access="rw" name="dlfft_info_next" pos="13:4" rst="0x0">
          <comment>DLFFT INFO</comment>
        </bits>
        <bits access="rw" name="crs_pow_clr_next" pos="3" rst="0x0">
          <comment>0CRS_POW_MAXPOWAGC
1CRS_POW_MAXPOWAGC</comment>
        </bits>
        <bits access="rw" name="soft_irt_en_next" pos="2" rst="0x0">
          <comment>0SOFT_IRT
1SOFT_IRT</comment>
        </bits>
        <bits access="rw" name="dlfft_mode_sel_next" pos="1:0" rst="0x0">
          <comment>00CAT1
01CATM
10NB-IOT
11CAT1</comment>
        </bits>
      </reg>
      <reg name="fft_lnum_next" protect="rw">
        <comment>FFT</comment>
        <bits access="rw" name="fft_lnum11_next" pos="21:20" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_next" pos="19:18" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_next" pos="17:16" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~18bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_next" pos="15:14" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~19bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_next" pos="13:12" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~20bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_next" pos="11:10" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~21bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_next" pos="9:8" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~22bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_next" pos="7:6" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~23bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_next" pos="5:4" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~24bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_next" pos="3:2" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~25bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_next" pos="1:0" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~26bit</comment>
        </bits>
      </reg>
      <reg name="dlfft_frame_config_curr" protect="rw">
        <comment></comment>
        <bits access="r" name="crs_pow_ofdm0_curr" pos="19" rst="0x1">
          <comment>ATMCELL RSOFDM0
0OFDM0
1OFDM0</comment>
        </bits>
        <bits access="r" name="fft_norm_sel_curr" pos="18" rst="0x0">
          <comment>FFT
0
1</comment>
        </bits>
        <bits access="r" name="fft_norm_en_curr" pos="17" rst="0x0">
          <comment>0FFTFFT
1FFTFFT</comment>
        </bits>
        <bits access="r" name="dlfft_only_en_curr" pos="16" rst="0x0">
          <comment>0DLFFTLDTC1LDTC
1DLFFTLDTC1LDTC</comment>
        </bits>
        <bits access="r" name="fft_dma_inten_curr" pos="15" rst="0x1">
          <comment>1DLFFTTXRXOFDM
0DLFFT</comment>
        </bits>
        <bits access="r" name="master_card_curr" pos="14" rst="0x0">
          <comment>0:
1:</comment>
        </bits>
        <bits access="r" name="sys_frame_num_curr" pos="13:4" rst="0x0">
          <comment>0~1023</comment>
        </bits>
        <bits access="r" name="sub_frame_num_curr" pos="3:0" rst="0x0">
          <comment>0~9</comment>
        </bits>
      </reg>
      <reg name="cat1_rs_ctrl_curr" protect="rw">
        <comment>CAT1RS</comment>
        <bits access="r" name="crs_pow_index_curr" pos="21:19" rst="0x0">
          <comment>CELL RS&amp;AGC
000
001
010
011
100
</comment>
        </bits>
        <bits access="r" name="crs_pow_ofdm0_curr" pos="18" rst="0x1">
          <comment>CELL RSOFDM0
0OFDM0
1OFDM0</comment>
        </bits>
        <bits access="r" name="mbms_mode_sel_curr" pos="17:16" rst="0x0">
          <comment>MBMS
2b00MBMSCELLRS
2b01MBMS1CELLRS
2b10MBMS2CELLRS
2b1100</comment>
        </bits>
        <bits access="r" name="mbms_en_curr" pos="15" rst="0x0">
          <comment>0MBMS
1MBMS</comment>
        </bits>
        <bits access="r" name="cellid_curr" pos="14:6" rst="0x0">
          <comment>CELLID</comment>
        </bits>
        <bits access="r" name="cp_sel_curr" pos="5" rst="0x0">
          <comment>CP
0NORM CP
1EX CP</comment>
        </bits>
        <bits access="r" name="cellport_sel_curr" pos="4:3" rst="0x0">
          <comment>CELLRS PORT
2b00port0
2b01port0/1
2b10port0/1/2/3
2b11CELLPORT_SEL2b112b00prot0</comment>
        </bits>
        <bits access="r" name="ueport_sel_curr" pos="2" rst="0x0">
          <comment>UERS PORT
0port5
1port7/8</comment>
        </bits>
        <bits access="r" name="cellrs_en_curr" pos="1" rst="0x0">
          <comment>0CELLRS
1CELLRS</comment>
        </bits>
        <bits access="r" name="uers_en_curr" pos="0" rst="0x0">
          <comment>0UERS
1UERS</comment>
        </bits>
      </reg>
      <reg name="cat1_csi_para_curr" protect="rw">
        <comment>CAT1CSIRS</comment>
        <bits access="r" name="csirs_bitmap_curr" pos="19:8" rst="0x0">
          <comment>RSCSIRSCSIRS BITMAP</comment>
        </bits>
        <bits access="r" name="csirs_ofdm1_curr" pos="7:4" rst="0x0">
          <comment>CSIRSCSIRSOFDM</comment>
        </bits>
        <bits access="r" name="csirs_ofdm0_curr" pos="3:0" rst="0x0">
          <comment>CSIRSCSIRSOFDM</comment>
        </bits>
      </reg>
      <reg name="cat1_agc_curr" protect="rw">
        <comment>CAT1AGC</comment>
        <bits access="r" name="agc1_curr" pos="19:10" rst="0x0">
          <comment>MBMSCELLRSOFDMAGC</comment>
        </bits>
        <bits access="r" name="agc0_curr" pos="9:0" rst="0x0">
          <comment>MBMSAGCMBMSCELLRSOFDMAGC</comment>
        </bits>
      </reg>
      <reg name="cat1_dlfft_ctrl_curr" protect="rw">
        <comment>DLFFT</comment>
        <bits access="r" name="pbch_en_curr" pos="1" rst="0x0">
          <comment>0PBCH
1PBCH</comment>
        </bits>
        <bits access="r" name="csirs_en_curr" pos="0" rst="0x0">
          <comment>0CSIRS
1CSIRS</comment>
        </bits>
      </reg>
      <reg name="cat1_sys_config_curr" protect="rw">
        <comment>CAT1</comment>
        <bits access="r" name="prb_index_curr" pos="10:8" rst="0x0">
          <comment>PRB
0006prb
00115prb
01025prb
01150prb
10075prb
101100prb
1116prb</comment>
        </bits>
        <bits access="r" name="up_down_config" pos="7:5" rst="0x0">
          <comment>0~6</comment>
        </bits>
        <bits access="r" name="mode_sel_curr" pos="4" rst="0x0">
          <comment>0TDD MODE
1FDD MODE</comment>
        </bits>
        <bits access="r" name="s_frame_config" pos="3:0" rst="0x0">
          <comment>  0~9</comment>
        </bits>
      </reg>
      <reg name="cat1_fft_gate_curr" protect="rw">
        <comment>CAT1FFT</comment>
        <bits access="r" name="fft_gate_curr" pos="12:0" rst="0x0">
          <comment>FFT0~4096</comment>
        </bits>
      </reg>
      <reg name="catm_nb_sys_config_curr" protect="rw">
        <comment>CATM/NB</comment>
        <bits access="r" name="prb_index_curr" pos="11:9" rst="0x0">
          <comment>NBIOTNBPRB0~5</comment>
        </bits>
        <bits access="r" name="cp_sel_curr" pos="8" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="r" name="up_down_config_curr" pos="7:5" rst="0x0">
          <comment>0~6</comment>
        </bits>
        <bits access="r" name="mode_sel_curr" pos="4" rst="0x0">
          <comment>0TDD MODE
1FDD MODE</comment>
        </bits>
        <bits access="r" name="s_frame_config_curr" pos="3:0" rst="0x0">
          <comment>  0~9</comment>
        </bits>
      </reg>
      <reg name="catm_nb_rs_config_curr" protect="rw">
        <comment>CATM/NBRS</comment>
        <bits access="r" name="crs_pow_index_curr" pos="15:13" rst="0x0">
          <comment>CELL RS&amp;AGC
000
001
010
011
100
</comment>
        </bits>
        <bits access="r" name="crs_nrs_sel_curr" pos="12" rst="0x0">
          <comment>0NBNRS
1NBCRS</comment>
        </bits>
        <bits access="r" name="id_value_curr" pos="11:3" rst="0x0">
          <comment>CELLRSNRSID</comment>
        </bits>
        <bits access="r" name="rsport_sel_curr" pos="2:1" rst="0x0">
          <comment>CELLRSNRS PORT
2b00port0
2b01port0/1
2b10port0/1/2/3
2b112b10</comment>
        </bits>
      </reg>
      <reg name="catm_nb_nbw_curr" protect="rw">
        <comment>CATM/NB</comment>
        <bits access="r" name="nbw_cover_zero_sel_curr" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="catm_agc_curr" protect="rw">
        <comment>CATMAGC</comment>
        <bits access="r" name="catm_agc_curr" pos="9:0" rst="0x0">
          <comment>CATMAGC</comment>
        </bits>
      </reg>
      <reg name="abis_config_curr" protect="rw">
        <comment>ABIS</comment>
        <bits access="r" name="frame_intra_sel_curr" pos="31" rst="0x0">
          <comment>0LDTC1LLR0
1LDTC1LLR</comment>
        </bits>
        <bits access="r" name="ctcg_sel_curr" pos="30" rst="0x0">
          <comment>CTCG
0OFDM4(OFDM4)CRS
1OFDM8(OFDM8)CRS</comment>
        </bits>
        <bits access="r" name="num_neibour_curr" pos="29:28" rst="0x0">
          <comment>
000
011
102
0</comment>
        </bits>
        <bits access="r" name="txnum_neibour_curr2" pos="27:26" rst="0x0">
          <comment>2
001port
012port
104port
1port</comment>
        </bits>
        <bits access="r" name="txnum_neibour_curr1" pos="25:24" rst="0x0">
          <comment>1
001port
012port
104port
1port</comment>
        </bits>
        <bits access="r" name="nrb_neibour_curr2" pos="23:21" rst="0x0">
          <comment>2 
0006prb
00115prb
01025prb
01150prb
10075prb
101100prb
6prb</comment>
        </bits>
        <bits access="r" name="nrb_neibour_curr1" pos="20:18" rst="0x0">
          <comment>1 
0006prb
00115prb
01025prb
01150prb
10075prb
101100prb
6prb</comment>
        </bits>
        <bits access="r" name="cellid_neibour_curr2" pos="17:9" rst="0x0">
          <comment>2 CELL ID</comment>
        </bits>
        <bits access="r" name="cellid_neibour_curr1" pos="8:0" rst="0x0">
          <comment>1 CELL ID</comment>
        </bits>
      </reg>
      <reg name="delay_curr1" protect="rw">
        <comment>1</comment>
        <bits access="r" name="delay_curr1" pos="18:0" rst="0x0">
          <comment>1TS</comment>
        </bits>
      </reg>
      <reg name="delay_curr2" protect="rw">
        <comment>2</comment>
        <bits access="r" name="delay_curr2" pos="18:0" rst="0x0">
          <comment>2TS</comment>
        </bits>
      </reg>
      <reg name="pb_curr" protect="rw">
        <comment>CRSCRS</comment>
        <bits access="r" name="abis_llr_shift_modify_curr" pos="12:8" rst="0x0">
          <comment>ABIS LLR-8~8</comment>
        </bits>
        <bits access="r" name="abis_start_ofdm_curr" pos="7:4" rst="0x0">
          <comment>ABISOFDM0~13</comment>
        </bits>
        <bits access="r" name="pb_curr" pos="1:0" rst="0x0">
          <comment>CRSCRS</comment>
        </bits>
      </reg>
      <reg name="noise_delta_curr" protect="rw">
        <comment></comment>
      </reg>
      <reg name="noise_agc_curr" protect="rw">
        <comment>AGC</comment>
        <bits access="r" name="noise_agc_curr" pos="9:0" rst="0x0">
          <comment>AGC</comment>
        </bits>
      </reg>
      <reg name="dlfft_mode_curr" protect="rw">
        <comment></comment>
        <bits access="r" name="dlfft_info_sel_curr" pos="14" rst="0x0">
          <comment>0DLFFT_INFO_OUT1
1DLFFT_INFO_OUT2</comment>
        </bits>
        <bits access="r" name="dlfft_info_curr" pos="13:4" rst="0x0">
          <comment>DLFFT INFO</comment>
        </bits>
        <bits access="r" name="crs_pow_clr_curr" pos="3" rst="0x0">
          <comment>0CRS_POW_MAXPOWAGC
1CRS_POW_MAXPOWAGC</comment>
        </bits>
        <bits access="r" name="soft_irt_en_curr" pos="2" rst="0x0">
          <comment>0SOFT_IRT
1SOFT_IRT</comment>
        </bits>
        <bits access="r" name="dlfft_mode_sel_curr" pos="1:0" rst="0x0">
          <comment>00CAT1
01CATM
10NB-IOT
11CAT1</comment>
        </bits>
      </reg>
      <reg name="fft_lnum_curr" protect="rw">
        <comment>FFT</comment>
        <bits access="r" name="fft_lnum11_curr" pos="21:20" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="r" name="fft_lnum10_curr" pos="19:18" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="r" name="fft_lnum9_curr" pos="17:16" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~18bit</comment>
        </bits>
        <bits access="r" name="fft_lnum8_curr" pos="15:14" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~19bit</comment>
        </bits>
        <bits access="r" name="fft_lnum7_curr" pos="13:12" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~20bit</comment>
        </bits>
        <bits access="r" name="fft_lnum6_curr" pos="11:10" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~21bit</comment>
        </bits>
        <bits access="r" name="fft_lnum5_curr" pos="9:8" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~22bit</comment>
        </bits>
        <bits access="r" name="fft_lnum4_curr" pos="7:6" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~23bit</comment>
        </bits>
        <bits access="r" name="fft_lnum3_curr" pos="5:4" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~24bit</comment>
        </bits>
        <bits access="r" name="fft_lnum2_curr" pos="3:2" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~25bit</comment>
        </bits>
        <bits access="r" name="fft_lnum1_curr" pos="1:0" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~26bit</comment>
        </bits>
      </reg>
      <reg name="dlfft_inten" protect="rw">
        <comment>DLFFT</comment>
        <bits access="rw" name="spare3_err_inten" pos="12" rst="0x0">
          <comment>13
03</comment>
        </bits>
        <bits access="rw" name="spare2_err_inten" pos="11" rst="0x0">
          <comment>12
02</comment>
        </bits>
        <bits access="rw" name="iddet_err_inten" pos="10" rst="0x0">
          <comment>1IDDET Online&amp;Offline
0IDDET Online&amp;Offline</comment>
        </bits>
        <bits access="rw" name="rxcapt_err_inten" pos="9" rst="0x0">
          <comment>1RXCAPT
0RXCAPT</comment>
        </bits>
        <bits access="rw" name="rf_nodata_inten" pos="8" rst="0x0">
          <comment>1RF
0RF</comment>
        </bits>
        <bits access="rw" name="rf_abnormal_up_inten" pos="7" rst="0x0">
          <comment>1RF
0RF</comment>
        </bits>
        <bits access="rw" name="rf_abnormal_down_inten" pos="6" rst="0x0">
          <comment>1RF
0RF</comment>
        </bits>
        <bits access="rw" name="rf_short_inten" pos="5" rst="0x0">
          <comment>1RF
0RF</comment>
        </bits>
        <bits access="rw" name="rf_over_inten" pos="4" rst="0x0">
          <comment>1RF
0RF</comment>
        </bits>
        <bits access="rw" name="axi_dma_inten" pos="3" rst="0x0">
          <comment>1AXIDMA
AXIDMADLFFT
OFDM
0AXIDMA</comment>
        </bits>
        <bits access="rw" name="fft_err_inten" pos="2" rst="0x0">
          <comment>1DLFFTTXRX or LDTC or LDTC1ERROR
0DLFFTTXRX or LDTCor LDTC1ERROR</comment>
        </bits>
        <bits access="rw" name="fft_core_inten" pos="1" rst="0x0">
          <comment>1DLFFTOFDM
0DLFFT</comment>
        </bits>
        <bits access="rw" name="fft_dma_inten" pos="0" rst="0x0">
          <comment>1DLFFTTXRXOFDM
0DLFFT</comment>
        </bits>
      </reg>
      <reg name="catm_nb_fft_gate" protect="rw">
        <comment>CATM/NBFFT</comment>
        <bits access="rw" name="fft_gate" pos="12:0" rst="0x0">
          <comment>FFT0~4096</comment>
        </bits>
      </reg>
      <reg name="dlfft_start" protect="rw">
        <comment></comment>
        <bits access="rw" name="catm_nb_dlfft_start" pos="1" rst="0x0">
          <comment>0: CATM/NB
1: CATM/NB</comment>
        </bits>
        <bits access="rw" name="cat1_dlfft_start" pos="0" rst="0x0">
          <comment>0: CAT1
1: CAT1</comment>
        </bits>
      </reg>
      <reg name="dlfft_intf" protect="rw">
        <comment></comment>
        <bits access="rc" name="spare3_errf" pos="19" rst="0x0">
          <comment>13
03</comment>
        </bits>
        <bits access="rc" name="spare2_errf" pos="18" rst="0x0">
          <comment>12
02</comment>
        </bits>
        <bits access="rc" name="iddet_errf" pos="17" rst="0x0">
          <comment>1IDDET Online&amp;Offline
0IDDET Online&amp;Offline</comment>
        </bits>
        <bits access="rc" name="rxcapt_errf" pos="16" rst="0x0">
          <comment>1RXCAPT
0RXCAPT</comment>
        </bits>
        <bits access="rc" name="measpwr_debug_errf" pos="15" rst="0x0">
          <comment>1MEASPWR
0 MEASPWR</comment>
        </bits>
        <bits access="rc" name="rf_nodata_errf" pos="14" rst="0x0">
          <comment>1RF
0RF</comment>
        </bits>
        <bits access="rc" name="sd_rd_errf" pos="13" rst="0x0">
          <comment>1SDDLFFT
0SDDLFFT</comment>
        </bits>
        <bits access="rc" name="coeff2ldtc_errf" pos="12" rst="0x0">
          <comment>1COEFFLDTC
0COEFFLDTC</comment>
        </bits>
        <bits access="rc" name="coeff2ldtc1_errf" pos="11" rst="0x0">
          <comment>1COEFFLDTC1
0COEFFLDTC1</comment>
        </bits>
        <bits access="rc" name="rf_abnormal_up_errf" pos="10" rst="0x0">
          <comment>1RF
0RF</comment>
        </bits>
        <bits access="rc" name="rf_abnormal_down_errf" pos="9" rst="0x0">
          <comment>1RF
0RF</comment>
        </bits>
        <bits access="rc" name="rf_short_errf" pos="8" rst="0x0">
          <comment>1RF
0RF</comment>
        </bits>
        <bits access="rc" name="rf_over_errf" pos="7" rst="0x0">
          <comment>1RF
0RF</comment>
        </bits>
        <bits access="rc" name="axi_dma_intf" pos="6" rst="0x0">
          <comment>1AXIDMAAXIDMADLFFTOFDM
0AXIDMA</comment>
        </bits>
        <bits access="rc" name="csi_wr_errf" pos="5" rst="0x0">
          <comment>1CSI
0CSI</comment>
        </bits>
        <bits access="rc" name="mmse_wr_errf" pos="4" rst="0x0">
          <comment>1MMSE
0MMSE</comment>
        </bits>
        <bits access="rc" name="ldtc_wr_errf" pos="3" rst="0x0">
          <comment>1LDTC
0LDTC</comment>
        </bits>
        <bits access="rc" name="txrx_rd_errf" pos="2" rst="0x0">
          <comment>1TXRX
0TXRX</comment>
        </bits>
        <bits access="rc" name="fft_core_intf" pos="1" rst="0x0">
          <comment>1DLFFTOFDM
0DLFFT</comment>
        </bits>
        <bits access="rc" name="fft_dma_intf" pos="0" rst="0x0">
          <comment>1DLFFTTXRXOFDM   
0DLFFT</comment>
        </bits>
      </reg>
      <reg name="ofdm_count" protect="rw">
        <comment>OFDM</comment>
        <bits access="r" name="ofdm_count" pos="3:0" rst="0x0">
          <comment>OFDM0~13</comment>
        </bits>
      </reg>
      <reg name="master_card" protect="rw">
        <comment></comment>
        <bits access="r" name="dlfft_info_out2" pos="20:11" rst="0x0">
          <comment>DLFFT INFO 2</comment>
        </bits>
        <bits access="r" name="dlfft_info_out1" pos="10:1" rst="0x0">
          <comment>DLFFT INFO 1</comment>
        </bits>
        <bits access="r" name="master_card_out" pos="0" rst="0x0">
          <comment>0
1</comment>
        </bits>
      </reg>
      <reg name="llr_out1" protect="rw">
        <comment>ABIS1</comment>
        <bits access="r" name="llr_out1" pos="3:0" rst="0xf">
          <comment>ABIS11</comment>
        </bits>
      </reg>
      <reg name="llr_out2" protect="rw">
        <comment>ABIS2</comment>
        <bits access="r" name="llr_out2" pos="3:0" rst="0xf">
          <comment>ABIS22</comment>
        </bits>
      </reg>
      <reg name="llr_out3" protect="rw">
        <comment>ABIS3</comment>
        <bits access="r" name="llr_out3" pos="3:0" rst="0xf">
          <comment>ABIS31+2</comment>
        </bits>
      </reg>
      <reg name="crs_pow_max1" protect="rw">
        <comment>CELLRS</comment>
      </reg>
      <reg name="crs_pow_agc1" protect="rw">
        <comment>CELLRSAGC</comment>
        <bits access="r" name="crs_pow_agc1" pos="9:0" rst="0x0">
          <comment>CELLRSAGC</comment>
        </bits>
      </reg>
      <reg name="crs_pow_max2" protect="rw">
        <comment>CELLRS</comment>
      </reg>
      <reg name="crs_pow_agc2" protect="rw">
        <comment>CELLRSAGC</comment>
        <bits access="r" name="crs_pow_agc2" pos="9:0" rst="0x0">
          <comment>CELLRSAGC</comment>
        </bits>
      </reg>
      <reg name="crs_pow_max3" protect="rw">
        <comment>CELLRS</comment>
      </reg>
      <reg name="crs_pow_agc3" protect="rw">
        <comment>CELLRSAGC</comment>
        <bits access="r" name="crs_pow_agc3" pos="9:0" rst="0x0">
          <comment>CELLRSAGC</comment>
        </bits>
      </reg>
      <reg name="crs_pow_max4" protect="rw">
        <comment>CELLRS</comment>
      </reg>
      <reg name="crs_pow_agc4" protect="rw">
        <comment>CELLRSAGC</comment>
        <bits access="r" name="crs_pow_agc4" pos="9:0" rst="0x0">
          <comment>CELLRSAGC</comment>
        </bits>
      </reg>
      <reg name="crs_pow_max5" protect="rw">
        <comment>CELLRS</comment>
      </reg>
      <reg name="crs_pow_agc5" protect="rw">
        <comment>CELLRSAGC</comment>
        <bits access="r" name="crs_pow_agc5" pos="9:0" rst="0x0">
          <comment>CELLRSAGC</comment>
        </bits>
      </reg>
      <reg name="fsm_state" protect="rw">
        <comment></comment>
      </reg>
      <reg name="txrx_norm_gene1" protect="rw">
        <comment>TXRX1</comment>
        <bits access="r" name="ofdm7_norm_gene" pos="31:28" rst="0x0">
          <comment>OFDM 7TXRX</comment>
        </bits>
        <bits access="r" name="ofdm6_norm_gene" pos="27:24" rst="0x0">
          <comment>OFDM 6TXRX</comment>
        </bits>
        <bits access="r" name="ofdm5_norm_gene" pos="23:20" rst="0x0">
          <comment>OFDM 5TXRX</comment>
        </bits>
        <bits access="r" name="ofdm4_norm_gene" pos="19:16" rst="0x0">
          <comment>OFDM 4TXRX</comment>
        </bits>
        <bits access="r" name="ofdm3_norm_gene" pos="15:12" rst="0x0">
          <comment>OFDM 3TXRX</comment>
        </bits>
        <bits access="r" name="ofdm2_norm_gene" pos="11:8" rst="0x0">
          <comment>OFDM 2TXRX</comment>
        </bits>
        <bits access="r" name="ofdm1_norm_gene" pos="7:4" rst="0x0">
          <comment>OFDM 1TXRX</comment>
        </bits>
        <bits access="r" name="ofdm0_norm_gene" pos="3:0" rst="0x0">
          <comment>OFDM 0TXRX</comment>
        </bits>
      </reg>
      <reg name="txrx_norm_gene2" protect="rw">
        <comment>TXRX1</comment>
        <bits access="r" name="ofdm13_norm_gene" pos="23:20" rst="0x0">
          <comment>OFDM 13TXRX</comment>
        </bits>
        <bits access="r" name="ofdm12_norm_gene" pos="19:16" rst="0x0">
          <comment>OFDM 12TXRX</comment>
        </bits>
        <bits access="r" name="ofdm11_norm_gene" pos="15:12" rst="0x0">
          <comment>OFDM 11TXRX</comment>
        </bits>
        <bits access="r" name="ofdm10_norm_gene" pos="11:8" rst="0x0">
          <comment>OFDM 10TXRX</comment>
        </bits>
        <bits access="r" name="ofdm9_norm_gene" pos="7:4" rst="0x0">
          <comment>OFDM 9TXRX</comment>
        </bits>
        <bits access="r" name="ofdm8_norm_gene" pos="3:0" rst="0x0">
          <comment>OFDM 8TXRX</comment>
        </bits>
      </reg>
      <reg name="txrx_soft_offset" protect="rw">
        <comment>TXRXSOFT IRT</comment>
        <bits access="r" name="txrx_soft_offset1" pos="9:5" rst="0x0">
          <comment>TXRXSOFT IRT1</comment>
        </bits>
        <bits access="r" name="txrx_soft_offset0" pos="4:0" rst="0x0">
          <comment>TXRXSOFT IRT0</comment>
        </bits>
      </reg>
      <reg name="ofdm_assert" protect="rw">
        <comment>OFDM</comment>
        <bits access="r" name="txrx_enable_assert" pos="4" rst="0x0">
          <comment>ASSERTTXRX_ENABLE</comment>
        </bits>
        <bits access="r" name="ofdm_assert" pos="3:0" rst="0x0">
          <comment>ASSERTOFDM0~13</comment>
        </bits>
      </reg>
      <reg name="fsm_state_assert" protect="rw">
        <comment></comment>
      </reg>
      <reg name=" abis_real_time_flag" protect="rw">
        <comment>ABIS</comment>
        <bits access="r" name="abis_real_time_flag3" pos="2" rst="0x0">
          <comment>0ABISLLR_OUT3
1ABISLLR_OUT3</comment>
        </bits>
        <bits access="r" name="abis_real_time_flag2" pos="1" rst="0x0">
          <comment>0ABISLLR_OUT2
1ABISLLR_OUT2</comment>
        </bits>
        <bits access="r" name="abis_real_time_flag1" pos="0" rst="0x0">
          <comment>0ABISLLR_OUT1
1ABISLLR_OUT1</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x18a00000" name="DLFFT" type="DLFFT"/>
  </archive>
  <archive relative="coeff.xml">
    <module category="System" name="COEFF">
      <reg name="qfqt_start" protect="rw">
        <comment></comment>
        <bits access="rw" name="meas_en" pos="10" rst="0x0">
          <comment>Coeffmeas
1
0</comment>
        </bits>
        <bits access="rw" name="ldtc_en" pos="9" rst="0x0">
          <comment>Coeffldtc\ldtc1
1
0</comment>
        </bits>
        <bits access="rw" name="buf_sel" pos="8:7" rst="0x0">
          <comment>Coeffldtc\ldtc1 buf
00ldtc buf1
01ldtc buf2
10ldtc buf3
11</comment>
        </bits>
        <bits access="rw" name="cat_sel" pos="6" rst="0x0">
          <comment>CAT1CATM
0CATM
1CAT1</comment>
        </bits>
        <bits access="rw" name="fast_mod" pos="5" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="port_sel" pos="4" rst="0x0">
          <comment>Port
0Port78
1Port5</comment>
        </bits>
        <bits access="rw" name="qfqt_inten" pos="2" rst="0x0">
          <comment>
0QFQT
1QFQT</comment>
        </bits>
        <bits access="rw" name="cp_type" pos="1" rst="0x0">
          <comment>
0: NCP
1: ECP</comment>
        </bits>
        <bits access="rw" name="qfqt_en" pos="0" rst="0x0">
          <comment>
0: QFQT
1: QFQT</comment>
        </bits>
      </reg>
      <reg name="qfqt_state" protect="rw">
        <comment></comment>
        <bits access="rc" name="which_err" pos="3:2" rst="0x0">
          <comment>buf
00ldtc buf1
01ldtc buf2
10ldtc buf3
11meas buf</comment>
        </bits>
        <bits access="rc" name="err_state" pos="1" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rc" name="qfqt_intf" pos="0" rst="0x0">
          <comment>
0: 
1: </comment>
        </bits>
      </reg>
      <reg name="qf_conf" protect="rw">
        <comment>QF(QT_CONF)</comment>
        <bits access="rw" name="sys_band_sel" pos="17:15" rst="0x0">
          <comment>
000: 6PRB
001: 15PRB
010: 25PRB
011: 50PRB
100: 75PRB
101: 100PRB
Others: RESERVED 6PRB</comment>
        </bits>
        <bits access="rw" name="coeff_qf_snr" pos="14:4" rst="0x1">
          <comment></comment>
        </bits>
        <bits access="rw" name="cha_mod" pos="1:0" rst="0x0">
          <comment>
00: EPA
01: EVA
10: ETU
11: RESERVED EPA</comment>
        </bits>
      </reg>
      <reg name="qt_conf" protect="rw">
        <comment>QT(QF_CONF)</comment>
        <bits access="rw" name="doppler" pos="17:16" rst="0x0">
          <comment>
005
0170
10300
11:   850</comment>
        </bits>
        <bits access="rw" name="tdd_fdd" pos="15" rst="0x0">
          <comment>TDDFDD
0TDD
1FDD</comment>
        </bits>
        <bits access="rw" name="coeff_qt_snr" pos="14:4" rst="0x1">
          <comment></comment>
        </bits>
        <bits access="rw" name="ss_sel" pos="3:0" rst="0x0">
          <comment>
0000SS0
0001SS1
0010SS2
0011SS3
0100SS4
0101SS5
0110SS6
0111SS7
1000SS8
1001SS9</comment>
        </bits>
      </reg>
      <reg name="sw_in" protect="rw">
        <comment></comment>
        <bits access="rw" name="sw_in" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="sw_out" protect="rw">
        <comment></comment>
        <bits access="r" name="sw_out" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
    </module>
    <instance address="0x18200000" name="COEFF" type="COEFF"/>
  </archive>
  <archive relative="rfad.xml">
    <module category="System" name="RFAD">
      <reg name="mod_en" protect="rw">
        <comment></comment>
        <bits access="rw" name="mod_up_en" pos="1" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="mod_dn_en" pos="0" rst="0x0">
          <comment>
1
0</comment>
        </bits>
      </reg>
      <reg name="ram_addr_map_cfg" protect="rw">
        <comment>RAM</comment>
        <bits access="rw" name="ram3_start_addr_up" pos="31:24" rst="0x0">
          <comment>RAM3RAM
RAM3256+</comment>
        </bits>
        <bits access="rw" name="ram2_start_addr_up" pos="23:16" rst="0x0">
          <comment>RAM2SPI RAM</comment>
        </bits>
        <bits access="rw" name="ram3_start_addr_dn" pos="15:8" rst="0x0">
          <comment>RAM3RAM
RAM3256+</comment>
        </bits>
        <bits access="rw" name="ram2_start_addr_dn" pos="7:0" rst="0x0">
          <comment>RAM2SPI RAM</comment>
        </bits>
      </reg>
      <reg name="gpo_immdata" protect="rw">
        <comment>GPO</comment>
        <bits access="rw" name="up_sel" pos="16" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="spi_sel" pos="15" rst="0x0">
          <comment>SPI
1SPI
0GPO</comment>
        </bits>
        <bits access="rw" name="spi_rw" pos="14" rst="0x0">
          <comment>SPI
1SPI
0SPI</comment>
        </bits>
        <bits access="rw" name="gpo" pos="13:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="spi_immdata" protect="rw">
        <comment>RFSPI</comment>
      </reg>
      <reg name="spi_cfg" protect="rw">
        <comment>SPI </comment>
        <bits access="rw" name="distance" pos="29:26" rst="0x3">
          <comment>SPISENSCLK</comment>
        </bits>
        <bits access="rw" name="frq_div_rd" pos="25:23" rst="0x1">
          <comment>SPI
0004
0016default
0108
01110
10012
10114
11016
11118</comment>
        </bits>
        <bits access="rw" name="frq_div_wr" pos="22:20" rst="0x1">
          <comment>SPI
0004
0016default
0108
01110
10012
10114
11016
11118</comment>
        </bits>
        <bits access="rw" name="cs_inv" pos="19" rst="0x0">
          <comment>4-W3-W
0
1</comment>
        </bits>
        <bits access="rw" name="dux" pos="18" rst="0x0">
          <comment> 17bit4
0
1</comment>
        </bits>
        <bits access="rw" name="ms" pos="17" rst="0x0">
          <comment>SPI
03
14</comment>
        </bits>
        <bits access="rw" name="rd_inter" pos="16:15" rst="0x2">
          <comment>SPISPI
00:0
01:1
10:2
11:3</comment>
        </bits>
        <bits access="rw" name="rd_edge" pos="14" rst="0x0">
          <comment>
00
1</comment>
        </bits>
        <bits access="rw" name="sec" pos="13" rst="0x0">
          <comment>
0Normal SPI
1DigRF SPI</comment>
        </bits>
        <bits access="rw" name="cpha" pos="12" rst="0x1">
          <comment>SPI
0: 
1;
1: 
;</comment>
        </bits>
        <bits access="rw" name="cpol" pos="11" rst="0x0">
          <comment>SPI
0: SPIIDLE
1: SPIIDLE</comment>
        </bits>
        <bits access="rw" name="spol" pos="10" rst="0x0">
          <comment>SPI
0: SPI
1: SPI</comment>
        </bits>
        <bits access="rw" name="rx_data_len" pos="9:5" rst="0xf">
          <comment>SPI
00000: 1-bits
00001: 2-bits
...........
11111: 32-bits</comment>
        </bits>
        <bits access="rw" name="tx_data_len" pos="4:0" rst="0x1f">
          <comment>SPI
00000: 1-bits
00001: 2-bits
...........
11111: 32-bits</comment>
        </bits>
      </reg>
      <reg name="spi_rxdata" protect="rw">
        <comment>SPI </comment>
      </reg>
      <reg name="debug_data" protect="rw">
        <comment>DEBUG</comment>
        <bits access="r" name="framc_err_up_flag" pos="31" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="r" name="insert_err_up_flag" pos="30" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="r" name="addr_err_up" pos="29" rst="0x0">
          <comment>0RAM
1RAM</comment>
        </bits>
        <bits access="r" name="time_err_up" pos="28" rst="0x0">
          <comment>0
1
0xf0xA</comment>
        </bits>
        <bits access="r" name="ram_rd_addr_up" pos="24:16" rst="0x0">
          <comment>RAM</comment>
        </bits>
        <bits access="r" name="framc_err_dn_flag" pos="15" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="r" name="insert_err_dn_flag" pos="14" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="r" name="addr_err_dn" pos="13" rst="0x0">
          <comment>0RAM
1RAM</comment>
        </bits>
        <bits access="r" name="time_err_dn" pos="12" rst="0x0">
          <comment>0
1
0xf0xA</comment>
        </bits>
        <bits access="r" name="ram_rd_addr_dn" pos="8:0" rst="0x0">
          <comment>RAM</comment>
        </bits>
      </reg>
      <reg name="rf_gpo_ctrl" protect="rw">
        <comment>RF GPO control register</comment>
      </reg>
      <reg name="framl_rfad" protect="rw">
        <comment>RFAD</comment>
        <bits access="rw" name="dont_insert_en" pos="18" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="up_en" pos="17" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="dn_en" pos="16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="framc_rfad" pos="15:0" rst="0x7800">
          <comment>RFAD</comment>
        </bits>
      </reg>
      <reg name="framc_err_up" protect="rw">
        <comment>FRAMC</comment>
        <bits access="r" name="framc_err_up_flag" pos="24" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="r" name="framc_err_up" pos="23:0" rst="0x0">
          <comment>FRAMC</comment>
        </bits>
      </reg>
      <reg name="data_time_err_up" protect="rw">
        <comment></comment>
        <bits access="r" name="ram_rd_addr_up" pos="31:24" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="data_time_err_up" pos="23:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="framc_err_dn" protect="rw">
        <comment>FRAMC</comment>
        <bits access="r" name="framc_err_dn_flag" pos="24" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="r" name="framc_err_dn" pos="23:0" rst="0x0">
          <comment>FRAMC</comment>
        </bits>
      </reg>
      <reg name="data_time_err_dn" protect="rw">
        <comment></comment>
        <bits access="r" name="ram_rd_addr_dn" pos="31:24" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="data_time_err_dn" pos="23:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="framl_err" protect="rw">
        <comment>FRAML</comment>
        <bits access="r" name="framl_err_up" pos="31:16" rst="0x0">
          <comment>FRAML</comment>
        </bits>
        <bits access="r" name="framl_err_dn" pos="15:0" rst="0x0">
          <comment>FRAML</comment>
        </bits>
      </reg>
      <reg name="dont_insert _err_up" protect="rw">
        <comment></comment>
        <bits access="r" name="ram_rd_addr_up" pos="31:24" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="framc_err_up" pos="23:0" rst="0x0">
          <comment>FRAMC</comment>
        </bits>
      </reg>
      <reg name="dont_insert _err_dn" protect="rw">
        <comment></comment>
        <bits access="r" name="ram_rd_addr_dn" pos="31:24" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="framc_err_dn" pos="23:0" rst="0x0">
          <comment>FRAMC</comment>
        </bits>
      </reg>
      <hole size="32256"/>
      <reg name="down_mem" protect="rw">
        <comment></comment>
      </reg>
      <hole size="32736"/>
      <reg name="up_mem" protect="rw">
        <comment></comment>
      </reg>
    </module>
    <instance address="0x18100000" name="RFAD" type="RFAD"/>
  </archive>
  <archive relative="ul_dft.xml">
    <module category="System" name="UL_DFT">
      <reg name="dft_ctrl_next" protect="rw">
        <comment>DFT/IDFT</comment>
        <bits access="rw" name="anti_drop_en_next" pos="12" rst="0x0">
          <comment>0ANTI_DROP
1ANTI_DROP</comment>
        </bits>
        <bits access="rw" name="anti_drop_lnum_next" pos="11" rst="0x0">
          <comment>ANTI_DROP:
08bit
17bit</comment>
        </bits>
        <bits access="rw" name="dft_npts_next" pos="10:5" rst="0x0">
          <comment>DFT/IDFTindex0~4344index </comment>
        </bits>
        <bits access="rw" name="pus_modu_sel_next" pos="4:3" rst="0x0">
          <comment>00: BPSK
01: QPSK
10: 16QAM
11: 64QAM</comment>
        </bits>
        <bits access="rw" name="dft_en_next" pos="2" rst="0x0">
          <comment>0DFT/IDFT
1DFT/IDFT</comment>
        </bits>
        <bits access="rw" name="pus_mod_en_next" pos="1" rst="0x0">
          <comment>0PUSCH
1PUSCH</comment>
        </bits>
        <bits access="rw" name="dft_idft_sel_next" pos="0" rst="0x0">
          <comment>0: DFT
1: IDFT</comment>
        </bits>
      </reg>
      <reg name="puc_mod_data_next" protect="rw">
        <comment>PUCCH</comment>
        <bits access="rw" name="puc_mod_data_next" pos="21:0" rst="0x0">
          <comment>PUCCHd(n)</comment>
        </bits>
      </reg>
      <reg name="srs_map_cfg_next" protect="rw">
        <comment>SRS</comment>
        <bits access="rw" name="k_tc_num_next" pos="26" rst="0x0">
          <comment>SRS
021
143</comment>
        </bits>
        <bits access="rw" name="k_tc_next" pos="25:24" rst="0x0">
          <comment>
000
011
102
113</comment>
        </bits>
        <bits access="rw" name="srs_map_len_next" pos="22:16" rst="0x0">
          <comment>SRS</comment>
        </bits>
        <bits access="rw" name="srs_map_start2_next" pos="14:8" rst="0x0">
          <comment>SRS</comment>
        </bits>
        <bits access="rw" name="srs_map_start1_next" pos="6:0" rst="0x0">
          <comment>SRS</comment>
        </bits>
      </reg>
      <reg name="srs_zc_len_next" protect="rw">
        <comment>SRSZC</comment>
        <bits access="rw" name="srs_num_next" pos="24" rst="0x0">
          <comment>0SRS1
1SRS2</comment>
        </bits>
        <bits access="rw" name="srs_map_ofdm2_next" pos="23:20" rst="0x0">
          <comment>SRSOFDM</comment>
        </bits>
        <bits access="rw" name="sra_map_ofdm1_next" pos="19:16" rst="0x0">
          <comment>SRSOFDM</comment>
        </bits>
        <bits access="rw" name="special_frame_start_next" pos="15:12" rst="0x0">
          <comment>SRSOFDM</comment>
        </bits>
        <bits access="rw" name="srs_zc_len_next" pos="10:0" rst="0x0">
          <comment>SRSZC</comment>
        </bits>
      </reg>
      <reg name="puc_map_cfg_next" protect="rw">
        <comment>PUCCH</comment>
        <bits access="rw" name="tx_fir_en_next" pos="31" rst="0x0">
          <comment>0TX
1TX</comment>
        </bits>
        <bits access="rw" name="tx_nb_start2_next" pos="30:24" rst="0x0">
          <comment>2</comment>
        </bits>
        <bits access="rw" name="tx_nb_start1_next" pos="22:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="puc_map_start2_next" pos="14:8" rst="0x0">
          <comment>PUCCH</comment>
        </bits>
        <bits access="rw" name="puc_map_start1_next" pos="6:0" rst="0x0">
          <comment>PUCCH</comment>
        </bits>
      </reg>
      <reg name="pus_map_cfg_next" protect="rw">
        <comment>PUSCH</comment>
        <bits access="rw" name="pus_map_sel_next" pos="31" rst="0x0">
          <comment>PUSCH
00.5ms
11ms</comment>
        </bits>
        <bits access="rw" name="pus_map_len2_next" pos="30:24" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
        <bits access="rw" name="pus_map_len1_next" pos="22:16" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
        <bits access="rw" name="pus_map_start2_next" pos="14:8" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
        <bits access="rw" name="pus_map_start1_next" pos="6:0" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
      </reg>
      <reg name="hard_para_next1" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="pus_dmrs_w_flag" pos="15" rst="0x0">
          <comment>PUSCH DMRS
1
0</comment>
        </bits>
        <bits access="rw" name="pucpus_shortened_mode_next" pos="14:11" rst="0x0">
          <comment>PUSCH/PUCCH
0000normal
0001type0_shortend
0010type1_shortend
0011type2_shortend
0100type3_shortend
0101type4_shortend
0110type5_shortend
0111:  type6_shortend
1000:  type7_shortend
1001:  other</comment>
        </bits>
        <bits access="rw" name="group_hop_flag_next" pos="10" rst="0x0">
          <comment>1u
0u</comment>
        </bits>
        <bits access="rw" name="seq_hop_flag_next" pos="9" rst="0x0">
          <comment>1v
0v</comment>
        </bits>
        <bits access="rw" name="ta_overlap_next" pos="8:3" rst="0x0">
          <comment>TA0~32</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_field_next" pos="2:0" rst="0x0">
          <comment>dmrsValue0~7</comment>
        </bits>
      </reg>
      <reg name="hard_para _next2" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="delta_apc_srs_next" pos="31:16" rst="0x0">
          <comment>SRSAPC </comment>
        </bits>
        <bits access="rw" name="delta_apc_scr_next" pos="15:0" rst="0x0">
          <comment>PUSCH/PUCCH/PRACHAPC </comment>
        </bits>
      </reg>
      <reg name="hard_para _next3" protect="rw">
        <comment>3</comment>
        <bits access="rw" name="n1_pucch_next" pos="31:20" rst="0x0">
          <comment>PUCCH1/1a/1b0~4095</comment>
        </bits>
        <bits access="rw" name="srs_cycle_shift_next" pos="19:16" rst="0x0">
          <comment>SRS</comment>
        </bits>
        <bits access="rw" name="subframe_slot_cnt_next" pos="14:10" rst="0x0">
          <comment>CAT1/CATM/CAT-NB15kHz1ms2CAT-NB3.75kHz2ms1</comment>
        </bits>
        <bits access="rw" name="nf_next" pos="9:0" rst="0x0">
          <comment>0~1023</comment>
        </bits>
      </reg>
      <reg name="ofdm_offset_next" protect="rw">
        <comment>OFDM OFFSET</comment>
        <bits access="rw" name="ofdm_offset_last_next" pos="31:16" rst="0x0">
          <comment>OFDMoffset</comment>
        </bits>
        <bits access="rw" name="ofdm_offset_first_next" pos="15:0" rst="0x0">
          <comment>OFDMoffset</comment>
        </bits>
      </reg>
      <reg name="dft_fft_inten_next" protect="rw">
        <comment></comment>
        <bits access="rw" name="err_inten_next" pos="15" rst="0x0">
          <comment>0ULDFTTXRXPUSCHERROR
1ULDFTTXRXPUSCHERROR</comment>
        </bits>
        <bits access="rw" name="dma_inten_next" pos="14" rst="0x0">
          <comment>1AXIDMA
0AXIDMA</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten13_next" pos="13" rst="0x0">
          <comment>1OFDM13
0OFDM13</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten12_next" pos="12" rst="0x0">
          <comment>1OFDM12
0OFDM12</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten11_next" pos="11" rst="0x0">
          <comment>1OFDM11
0OFDM11</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten10_next" pos="10" rst="0x0">
          <comment>1OFDM10
0OFDM10</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten9_next" pos="9" rst="0x0">
          <comment>1OFDM9
0OFDM9</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten8_next" pos="8" rst="0x0">
          <comment>1OFDM8
0OFDM8</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten7_next" pos="7" rst="0x0">
          <comment>1OFDM7
0OFDM7</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten6_next" pos="6" rst="0x0">
          <comment>1OFDM6
0OFDM6</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten5_next" pos="5" rst="0x0">
          <comment>1OFDM5
0OFDM5</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten4_next" pos="4" rst="0x0">
          <comment>1OFDM4
0OFDM4</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten3_next" pos="3" rst="0x0">
          <comment>1OFDM3
0OFDM3</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten2_next" pos="2" rst="0x0">
          <comment>1OFDM2
0OFDM2</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten1_next" pos="1" rst="0x0">
          <comment>1OFDM1
0OFDM1</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten0_next" pos="0" rst="0x0">
          <comment>1OFDM0
0OFDM0</comment>
        </bits>
      </reg>
      <reg name="dft_fft_intf_next" protect="rw">
        <comment></comment>
        <bits access="rc" name="dft_fft_intf13_next" pos="15" rst="0x0">
          <comment>1OFDM13
0OFDM13</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf12_next" pos="14" rst="0x0">
          <comment>1OFDM12
0OFDM12</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf11_next" pos="13" rst="0x0">
          <comment>1OFDM11
0OFDM11</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf10_next" pos="12" rst="0x0">
          <comment>1OFDM10
0OFDM10</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf9_next" pos="11" rst="0x0">
          <comment>1OFDM9
0OFDM9</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf8_next" pos="10" rst="0x0">
          <comment>1OFDM8
0OFDM8</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf7_next" pos="9" rst="0x0">
          <comment>1OFDM7
0OFDM7</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf6_next" pos="8" rst="0x0">
          <comment>1OFDM6
0OFDM6</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf5_next" pos="7" rst="0x0">
          <comment>1OFDM5
0OFDM5</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf4_next" pos="6" rst="0x0">
          <comment>1OFDM4
0OFDM4</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf3_next" pos="5" rst="0x0">
          <comment>1OFDM3
0OFDM3</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf2_next" pos="4" rst="0x0">
          <comment>1OFDM2
0OFDM2</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf1_next" pos="3" rst="0x0">
          <comment>1OFDM1
0OFDM1</comment>
        </bits>
        <bits access="rc" name="dft_fft_intf0_next" pos="2" rst="0x0">
          <comment>1OFDM0
0OFDM0</comment>
        </bits>
        <bits access="rc" name="pus_rd_errf" pos="1" rst="0x0">
          <comment>1pusch
0pusch</comment>
        </bits>
        <bits access="rc" name="txrx_wr_errf" pos="0" rst="0x0">
          <comment>1txrx
0txrx</comment>
        </bits>
      </reg>
      <reg name="ofdm_zero_next" protect="rw">
        <comment>OFDM</comment>
        <bits access="rw" name="ofdm_zero_next" pos="13:0" rst="0x0">
          <comment>OFDM
14b0
14b10
14b1101
14b111012
</comment>
        </bits>
      </reg>
      <reg name="dft_fft_ctrl_next" protect="rw">
        <comment>DFT/IDFT&amp;FFT/IFFT</comment>
        <bits access="rw" name="dftfft_soft_start" pos="30" rst="0x0">
          <comment>0ULDFT
1ULDFT</comment>
        </bits>
        <bits access="rw" name="dft_trig_mode" pos="29" rst="0x0">
          <comment>0ULDFT
1ULDFTPUSCH</comment>
        </bits>
        <bits access="rw" name="launch_en_next" pos="28" rst="0x0">
          <comment>0
1</comment>
        </bits>
        <bits access="rw" name="srs_en_next" pos="27" rst="0x0">
          <comment>0SRS
1SRS</comment>
        </bits>
        <bits access="rw" name="clear_en_next" pos="26" rst="0x0">
          <comment>0FFTMEM
1FFTMEM</comment>
        </bits>
        <bits access="rw" name="fft_ifft_sel_next" pos="25" rst="0x0">
          <comment>1IFFT
0FFT</comment>
        </bits>
        <bits access="rw" name="fft_cal_next" pos="24" rst="0x0">
          <comment>1FFT/IFFT
0FFT/IFFT</comment>
        </bits>
        <bits access="rw" name="pwradj_en_next" pos="23" rst="0x0">
          <comment>0
1</comment>
        </bits>
        <bits access="rw" name="prach_format_sel_next" pos="22:20" rst="0x0">
          <comment>PRACH
000PRACH0
001PRACH1
010PRACH2
011PRACH3
100PRACH4
</comment>
        </bits>
        <bits access="rw" name="pucch_format_sel_next" pos="19:17" rst="0x0">
          <comment>PUCCH
000PUCCH1
001PUCCH1a
010PUCCH1b
011PUCCH2
100PUCCH2a
101PUCCH2b
</comment>
        </bits>
        <bits access="rw" name="npusch_formatsel_next" pos="16" rst="0x0">
          <comment>0NPUSCH format 1
1NPUSCH format2</comment>
        </bits>
        <bits access="rw" name="ofdm_num_next" pos="15:12" rst="0x0">
          <comment>OFDM</comment>
        </bits>
        <bits access="rw" name="datadrive_en_next" pos="10" rst="0x0">
          <comment>0DATADRIVE
1DATADRIVE</comment>
        </bits>
        <bits access="rw" name="pus_buf_sel_next" pos="9:8" rst="0x0">
          <comment>UL_DFTPUSCH BUFFER
00PUSCH BUFFER1
01PUSCH BUFFER2
10PUSCH BUFFER3
11PUSCH PRA_BUF</comment>
        </bits>
        <bits access="rw" name="chan_mode_next" pos="6:4" rst="0x0">
          <comment>
000PUSCH
001PUCCH
010PRACH
011SRS
100NPUSCH
101NPRACH
</comment>
        </bits>
        <bits access="rw" name="fft_npts" pos="3:1" rst="0x0">
          <comment>FFT/IFFT
111
110
101
1002048
0111024
010512
001256
000128</comment>
        </bits>
        <bits access="rw" name="dftfft_irqen_next" pos="0" rst="0x0">
          <comment>0: 
1: </comment>
        </bits>
      </reg>
      <reg name=" fft_lnum_srs_next" protect="rw">
        <comment>SRSFFT</comment>
        <bits access="rw" name="fft_lnum11_srs_next" pos="21:20" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_srs_next" pos="19:18" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_srs_next" pos="17:16" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_srs_next" pos="15:14" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_srs_next" pos="13:12" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_srs_next" pos="11:10" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_srs_next" pos="9:8" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_srs_next" pos="7:6" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_srs_next" pos="5:4" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_srs_next" pos="3:2" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_srs_next" pos="1:0" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
      </reg>
      <reg name="fft_lnum_scr_next" protect="rw">
        <comment>PUSCH/PUCCH/PRACHFFT</comment>
        <bits access="rw" name="fft_lnum11_scr_next" pos="21:20" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_scr_next" pos="19:18" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_scr_next" pos="17:16" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_scr_next" pos="15:14" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_scr_next" pos="13:12" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_scr_next" pos="11:10" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_scr_next" pos="9:8" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_scr_next" pos="7:6" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_scr_next" pos="5:4" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_scr_next" pos="3:2" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_scr_next" pos="1:0" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
      </reg>
      <reg name="npus_map_cfg_next" protect="rw">
        <comment>NPUSCH</comment>
        <bits access="rw" name="npus_rep_cnt_next" pos="23:17" rst="0x0">
          <comment>NPUSCH0~127</comment>
        </bits>
        <bits access="rw" name="n_ru_sc_next" pos="16:15" rst="0x0">
          <comment>
001
013
106
1112</comment>
        </bits>
        <bits access="rw" name="isc_start_index_next" pos="14:9" rst="0x0">
          <comment>NPUSCH 0~47</comment>
        </bits>
        <bits access="rw" name="n_slot_cnt_next" pos="8:1" rst="0x0">
          <comment>Nslots1~160</comment>
        </bits>
        <bits access="rw" name="npus_sub_space_next" pos="0" rst="0x0">
          <comment>0: 3.75KHz
1: 15KHz</comment>
        </bits>
      </reg>
      <reg name="npus_dmrs_cfg_next" protect="rw">
        <comment>NPUSCH DMRS</comment>
        <bits access="rw" name="first_ru_slot_next" pos="26:22" rst="0x0">
          <comment>RU0~19</comment>
        </bits>
        <bits access="rw" name="slot_n_next" pos="21:7" rst="0x0">
          <comment>1DMRS0~20480</comment>
        </bits>
        <bits access="rw" name="base_seq_next" pos="6:2" rst="0x0">
          <comment>BASE_SEQ_NEXT0~30</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_next" pos="1:0" rst="0x0">
          <comment>CYCLIC_SHIFT0~3</comment>
        </bits>
      </reg>
      <reg name="npra _cfg_next" protect="rw">
        <comment>NPRACH</comment>
        <bits access="rw" name="sym_group_rep_cnt_next" pos="16:9" rst="0x0">
          <comment>t0~128</comment>
        </bits>
        <bits access="rw" name="nprach_sc_offset_next" pos="8:6" rst="0x0">
          <comment>frequency location of the first sub-carrier allocated to NPRACH
000frequency location0
001frequency location2
010frequency location12
011frequency location18
100frequency location24
101frequency location34
110frequency location36
1110</comment>
        </bits>
        <bits access="rw" name="init_sc_next" pos="5:0" rst="0x0">
          <comment>being the subcarrier selected by the MAC layer from  0-47</comment>
        </bits>
      </reg>
      <reg name="inout_para" protect="rw">
        <comment>FFT/IFFT</comment>
        <bits access="rw" name="fir_bit_sel" pos="28:25" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="delta_ss" pos="24:20" rst="0x0">
          <comment>0~29</comment>
        </bits>
        <bits access="rw" name="n2_pucch" pos="19:9" rst="0x0">
          <comment>PUCCH2/2a/2b0~1184</comment>
        </bits>
        <bits access="rw" name="cyclic_shift" pos="8:6" rst="0x0">
          <comment>0~7</comment>
        </bits>
        <bits access="rw" name="cp_mode" pos="2" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="rw" name="tdd_fdd_mode_sel" pos="1" rst="0x0">
          <comment>0TDD  mode
1FDD  mode</comment>
        </bits>
        <bits access="rw" name="inout_ctrl" pos="0" rst="0x0">
          <comment>1: 
0: </comment>
        </bits>
      </reg>
      <reg name="id_para" protect="rw">
        <comment>ID</comment>
        <bits access="rw" name="ncs_u_gold_mode" pos="29" rst="0x0">
          <comment>NCSUGOLDC_INI
1if no value for   or   is configured by higher layers or the PUSCH transmission corresponds to a Random Access Response Grant or a retransmission of the same transport block as part of the contention based random access procedure
0otherwise</comment>
        </bits>
        <bits access="rw" name="csh_dmrs_id" pos="28:19" rst="0x0">
          <comment>NCS_U_GOLD_MODE1 + 0~532NCS_U_GOLD_MODE0 0~509</comment>
        </bits>
        <bits access="rw" name="rs_id" pos="18:9" rst="0x0">
          <comment>NCS_U_GOLD_MODE1 + 0~532NCS_U_GOLD_MODE0 0~509</comment>
        </bits>
        <bits access="rw" name="cell_id" pos="8:0" rst="0x0">
          <comment>ID0~503</comment>
        </bits>
      </reg>
      <reg name="pucch_dummy_id" protect="rw">
        <comment>PUCCHID</comment>
        <bits access="rw" name="puc_dummy_id" pos="8:0" rst="0x0">
          <comment>RSID</comment>
        </bits>
      </reg>
      <reg name="puc_rbmap_config" protect="rw">
        <comment>PUCCH</comment>
        <bits access="rw" name="ncs1_puc" pos="14:12" rst="0x0">
          <comment>nCsAn1/1a/1b0~7</comment>
        </bits>
        <bits access="rw" name="ce_mode_flag" pos="10" rst="0x0">
          <comment>CE_mode
0CE_modeA
1CE_modeB</comment>
        </bits>
        <bits access="rw" name="delta_shift_puc" pos="9:8" rst="0x0">
          <comment>
00 1
01 2
10 3
1100 1</comment>
        </bits>
        <bits access="rw" name="nrb2" pos="6:0" rst="0x0">
          <comment>cqiNrb PUCCH2/2a/2b0~98</comment>
        </bits>
      </reg>
      <reg name="sysband_config" protect="rw">
        <comment></comment>
        <bits access="rw" name="sys_band" pos="2:0" rst="0x0">
          <comment>CAT1 
0006PRB
00115PRB
01025PRB
01150PRB
10075PRB
101100PRB
6PRB</comment>
        </bits>
      </reg>
      <reg name="dftfft_launch" protect="rw">
        <comment></comment>
        <bits access="rw" name="dma_start_en" pos="1" rst="0x0">
          <comment>0DMA
1DMA</comment>
        </bits>
        <bits access="rw" name="dftfft_launch" pos="0" rst="0x0">
          <comment>0: 
1: </comment>
        </bits>
      </reg>
      <reg name="dft_fft_sw_stop" protect="rw">
        <comment></comment>
        <bits access="rw" name="sw_pause_ofdm" pos="17:4" rst="0x0">
          <comment>SW_PAUSE_EN=1OFDM
14`b0
14`b1OFDM0
14`b11OFDM01
14`b111OFDM012
</comment>
        </bits>
        <bits access="rw" name="sw_pause_way" pos="3" rst="0x0">
          <comment>SW_PAUSE_EN=1
0SW_PAUSE_OFDMOFDM
1SW_PAUSE_OFDMOFDM</comment>
        </bits>
        <bits access="rw" name="sw_pause_en" pos="2" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="sw_tmp_en" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="sw_stop_en" pos="0" rst="0x0">
          <comment>
0
1OFDM</comment>
        </bits>
      </reg>
      <reg name="dft_fft_sw_stop_flag" protect="rw">
        <comment></comment>
        <bits access="rc" name="sw_pause_flag" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rc" name="sw_stop_flag" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="dft_ctrl_curr1" protect="rw">
        <comment>DFT/IDFT</comment>
        <bits access="rw" name="anti_drop_en_curr" pos="12" rst="0x0">
          <comment>0ANTI_DROP
1ANTI_DROP</comment>
        </bits>
        <bits access="rw" name="anti_drop_lnum_curr" pos="11" rst="0x0">
          <comment>ANTI_DROP:
08bit
17bit</comment>
        </bits>
        <bits access="rw" name="dft_npts_curr" pos="10:5" rst="0x0">
          <comment>DFT/IDFTindex0~4344index </comment>
        </bits>
        <bits access="rw" name="pus_modu_sel_curr" pos="4:3" rst="0x0">
          <comment>00: BPSK
01: QPSK
10: 16QAM
11: 64QAM</comment>
        </bits>
        <bits access="rw" name="dft_en_curr" pos="2" rst="0x0">
          <comment>0DFT/IDFT
1DFT/IDFT</comment>
        </bits>
        <bits access="rw" name="pus_mod_en_curr" pos="1" rst="0x0">
          <comment>0PUSCH
1PUSCH</comment>
        </bits>
        <bits access="rw" name="dft_idft_sel_curr" pos="0" rst="0x0">
          <comment>0: DFT
1: IDFT</comment>
        </bits>
      </reg>
      <reg name="puc_mod_data_curr1" protect="rw">
        <comment>PUCCH</comment>
        <bits access="rw" name="puc_mod_data_curr" pos="21:0" rst="0x0">
          <comment>PUCCHd(n)</comment>
        </bits>
      </reg>
      <reg name="srs_map_cfg_curr1" protect="rw">
        <comment>SRS</comment>
        <bits access="rw" name="k_tc_num_curr" pos="26" rst="0x0">
          <comment>SRS
021
143</comment>
        </bits>
        <bits access="rw" name="k_tc_curr" pos="25:24" rst="0x0">
          <comment>
000
011
102
113</comment>
        </bits>
        <bits access="rw" name="srs_map_len_curr" pos="22:16" rst="0x0">
          <comment>SRS</comment>
        </bits>
        <bits access="rw" name="srs_map_start2_curr" pos="14:8" rst="0x0">
          <comment>SRS</comment>
        </bits>
        <bits access="rw" name="srs_map_start1_curr" pos="6:0" rst="0x0">
          <comment>SRS</comment>
        </bits>
      </reg>
      <reg name="srs_zc_len_curr1" protect="rw">
        <comment>SRSZC</comment>
        <bits access="rw" name="srs_num_curr" pos="24" rst="0x0">
          <comment>0SRS1
1SRS2</comment>
        </bits>
        <bits access="rw" name="srs_map_ofdm2_curr" pos="23:20" rst="0x0">
          <comment>SRSOFDM</comment>
        </bits>
        <bits access="rw" name="sra_map_ofdm1_curr" pos="19:16" rst="0x0">
          <comment>SRSOFDM</comment>
        </bits>
        <bits access="rw" name="special_frame_start_curr" pos="15:12" rst="0x0">
          <comment>SRSOFDM</comment>
        </bits>
        <bits access="rw" name="srs_zc_len_curr" pos="10:0" rst="0x0">
          <comment>SRSZC</comment>
        </bits>
      </reg>
      <reg name="puc_map_cfg_curr1" protect="rw">
        <comment>PUCCH</comment>
        <bits access="rw" name="tx_fir_en_curr" pos="31" rst="0x0">
          <comment>0TX
1TX</comment>
        </bits>
        <bits access="rw" name="tx_nb_start2_curr" pos="30:24" rst="0x0">
          <comment>2</comment>
        </bits>
        <bits access="rw" name="tx_nb_start1_curr" pos="22:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="puc_map_start2_curr" pos="14:8" rst="0x0">
          <comment>PUCCH</comment>
        </bits>
        <bits access="rw" name="puc_map_start1_curr" pos="6:0" rst="0x0">
          <comment>PUCCH</comment>
        </bits>
      </reg>
      <reg name="pus_map_cfg_curr1" protect="rw">
        <comment>PUSCH</comment>
        <bits access="rw" name="pus_map_sel_curr" pos="31" rst="0x0">
          <comment>PUSCH
00.5ms
11ms</comment>
        </bits>
        <bits access="rw" name="pus_map_len2_curr" pos="30:24" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
        <bits access="rw" name="pus_map_len1_curr" pos="22:16" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
        <bits access="rw" name="pus_map_start2_curr" pos="14:8" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
        <bits access="rw" name="pus_map_start1_curr" pos="6:0" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
      </reg>
      <reg name="hard_para_curr11" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="pucpus_shortened_mode_curr" pos="14:11" rst="0x0">
          <comment>PUSCH/PUCCH
0000normal
0001type0_shortend
0010type1_shortend
0011type2_shortend
0100type3_shortend
0101type4_shortend
0110type5_shortend
0111:  type6_shortend
1000:  type7_shortend
1001:  other</comment>
        </bits>
        <bits access="rw" name="group_hop_flag_curr" pos="10" rst="0x0">
          <comment>1u
0u</comment>
        </bits>
        <bits access="rw" name="seq_hop_flag_curr" pos="9" rst="0x0">
          <comment>1v
0v</comment>
        </bits>
        <bits access="rw" name="ta_overlap_curr" pos="8:3" rst="0x0">
          <comment>TA0~32</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_field_curr" pos="2:0" rst="0x0">
          <comment>dmrsValue0~7</comment>
        </bits>
      </reg>
      <reg name="hard_para _curr21" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="delta_apc_srs_curr" pos="31:16" rst="0x0">
          <comment>SRSAPC </comment>
        </bits>
        <bits access="rw" name="delta_apc_scr_curr" pos="15:0" rst="0x0">
          <comment>PUSCH/PUCCH/PRACHAPC </comment>
        </bits>
      </reg>
      <reg name="hard_para _curr31" protect="rw">
        <comment>3</comment>
        <bits access="rw" name="n1_pucch_curr" pos="31:20" rst="0x0">
          <comment>PUCCH1/1a/1b0~4095</comment>
        </bits>
        <bits access="rw" name="srs_cycle_shift_curr" pos="19:16" rst="0x0">
          <comment>SRS</comment>
        </bits>
        <bits access="rw" name="subframe_slot_cnt_curr" pos="14:10" rst="0x0">
          <comment>CAT1/CATM/CAT-NB15kHz1ms2CAT-NB3.75kHz2ms1</comment>
        </bits>
        <bits access="rw" name="nf_curr" pos="9:0" rst="0x0">
          <comment>0~1023</comment>
        </bits>
      </reg>
      <reg name="ofdm_offset_curr1" protect="rw">
        <comment>OFDM OFFSET</comment>
        <bits access="rw" name="ofdm_offset_last_curr" pos="31:16" rst="0x0">
          <comment>OFDMoffset</comment>
        </bits>
        <bits access="rw" name="ofdm_offset_first_curr" pos="15:0" rst="0x0">
          <comment>OFDMoffset</comment>
        </bits>
      </reg>
      <reg name="dft_fft_inten_curr1" protect="rw">
        <comment></comment>
        <bits access="rw" name="err_inten_curr" pos="15" rst="0x0">
          <comment>0ULDFTTXRXPUSCHERROR
1ULDFTTXRXPUSCHERROR</comment>
        </bits>
        <bits access="rw" name="dma_inten_curr" pos="14" rst="0x0">
          <comment>1AXIDMA
0AXIDMA</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten13_curr" pos="13" rst="0x0">
          <comment>1OFDM13
0OFDM13</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten12_curr" pos="12" rst="0x0">
          <comment>1OFDM12
0OFDM12</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten11_curr" pos="11" rst="0x0">
          <comment>1OFDM11
0OFDM11</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten10_curr" pos="10" rst="0x0">
          <comment>1OFDM10
0OFDM10</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten9_curr" pos="9" rst="0x0">
          <comment>1OFDM9
0OFDM9</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten8_curr" pos="8" rst="0x0">
          <comment>1OFDM8
0OFDM8</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten7_curr" pos="7" rst="0x0">
          <comment>1OFDM7
0OFDM7</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten6_curr" pos="6" rst="0x0">
          <comment>1OFDM6
0OFDM6</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten5_curr" pos="5" rst="0x0">
          <comment>1OFDM5
0OFDM5</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten4_curr" pos="4" rst="0x0">
          <comment>1OFDM4
0OFDM4</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten3_curr" pos="3" rst="0x0">
          <comment>1OFDM3
0OFDM3</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten2_curr" pos="2" rst="0x0">
          <comment>1OFDM2
0OFDM2</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten1_curr" pos="1" rst="0x0">
          <comment>1OFDM1
0OFDM1</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten0_curr" pos="0" rst="0x0">
          <comment>1OFDM0
0OFDM0</comment>
        </bits>
      </reg>
      <reg name="ofdm_zero_curr1" protect="rw">
        <comment>OFDM</comment>
        <bits access="rw" name="ofdm_zero_curr" pos="13:0" rst="0x0">
          <comment>OFDM
14b0
14b10
14b1101
14b111012
</comment>
        </bits>
      </reg>
      <reg name="dft_fft_ctrl_curr1" protect="rw">
        <comment>DFT/IDFT&amp;FFT/IFFT</comment>
        <bits access="rw" name="dftfft_soft_start" pos="30" rst="0x0">
          <comment>0ULDFT
1ULDFT</comment>
        </bits>
        <bits access="rw" name="dft_trig_mode" pos="29" rst="0x0">
          <comment>0ULDFT
1ULDFTPUSCH</comment>
        </bits>
        <bits access="rw" name="launch_en_curr" pos="28" rst="0x0">
          <comment>0
1</comment>
        </bits>
        <bits access="rw" name="srs_en_curr" pos="27" rst="0x0">
          <comment>0SRS
1SRS</comment>
        </bits>
        <bits access="rw" name="clear_en_curr" pos="26" rst="0x0">
          <comment>0FFTMEM
1FFTMEM</comment>
        </bits>
        <bits access="rw" name="fft_ifft_sel_curr" pos="25" rst="0x0">
          <comment>1IFFT
0FFT</comment>
        </bits>
        <bits access="rw" name="fft_cal_curr" pos="24" rst="0x0">
          <comment>1FFT/IFFT
0FFT/IFFT</comment>
        </bits>
        <bits access="rw" name="pwradj_en_curr" pos="23" rst="0x0">
          <comment>0
1</comment>
        </bits>
        <bits access="rw" name="prach_format_sel_curr" pos="22:20" rst="0x0">
          <comment>PRACH
000PRACH0
001PRACH1
010PRACH2
011PRACH3
100PRACH4
</comment>
        </bits>
        <bits access="rw" name="pucch_format_sel_curr" pos="19:17" rst="0x0">
          <comment>PUCCH
000PUCCH1
001PUCCH1a
010PUCCH1b
011PUCCH2
100PUCCH2a
101PUCCH2b
</comment>
        </bits>
        <bits access="rw" name="npusch_formatsel_curr" pos="16" rst="0x0">
          <comment>0NPUSCH format 1
1NPUSCH format2</comment>
        </bits>
        <bits access="rw" name="ofdm_num_curr" pos="15:12" rst="0x0">
          <comment>OFDM</comment>
        </bits>
        <bits access="rw" name="datadrive_en_curr" pos="10" rst="0x0">
          <comment>0DATADRIVE
1DATADRIVE</comment>
        </bits>
        <bits access="rw" name="pus_buf_sel_curr" pos="9:8" rst="0x0">
          <comment>UL_DFTPUSCH BUFFER
00PUSCH BUFFER1
01PUSCH BUFFER2
10PUSCH BUFFER3
11PUSCH PRA_BUF</comment>
        </bits>
        <bits access="rw" name="chan_mode_curr" pos="6:4" rst="0x0">
          <comment>
000PUSCH
001PUCCH
010PRACH
011SRS
100NPUSCH
101NPRACH
</comment>
        </bits>
        <bits access="rw" name="fft_npts" pos="3:1" rst="0x0">
          <comment>FFT/IFFT
111
110
101
1002048
0111024
010512
001256
000128</comment>
        </bits>
        <bits access="rw" name="dftfft_irqen_curr" pos="0" rst="0x0">
          <comment>0: 
1: </comment>
        </bits>
      </reg>
      <reg name=" fft_lnum_srs_curr1" protect="rw">
        <comment>SRSFFT</comment>
        <bits access="rw" name="fft_lnum11_srs_curr" pos="21:20" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_srs_curr" pos="19:18" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_srs_curr" pos="17:16" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_srs_curr" pos="15:14" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_srs_curr" pos="13:12" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_srs_curr" pos="11:10" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_srs_curr" pos="9:8" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_srs_curr" pos="7:6" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_srs_curr" pos="5:4" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_srs_curr" pos="3:2" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_srs_curr" pos="1:0" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
      </reg>
      <reg name="fft_lnum_scr_curr1" protect="rw">
        <comment>PUSCH/PUCCH/PRACHFFT</comment>
        <bits access="rw" name="fft_lnum11_scr_curr" pos="21:20" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_scr_curr" pos="19:18" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_scr_curr" pos="17:16" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_scr_curr" pos="15:14" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_scr_curr" pos="13:12" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_scr_curr" pos="11:10" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_scr_curr" pos="9:8" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_scr_curr" pos="7:6" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_scr_curr" pos="5:4" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_scr_curr" pos="3:2" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_scr_curr" pos="1:0" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
      </reg>
      <reg name="npus_map_cfg_curr1" protect="rw">
        <comment>NPUSCH</comment>
        <bits access="rw" name="npus_rep_cnt_curr" pos="23:17" rst="0x0">
          <comment>NPUSCH0~127</comment>
        </bits>
        <bits access="rw" name="n_ru_sc_curr" pos="16:15" rst="0x0">
          <comment>
001
013
106
1112</comment>
        </bits>
        <bits access="rw" name="isc_start_index_curr" pos="14:9" rst="0x0">
          <comment>NPUSCH 0~47</comment>
        </bits>
        <bits access="rw" name="n_slot_cnt_curr" pos="8:1" rst="0x0">
          <comment>Nslots1~160</comment>
        </bits>
        <bits access="rw" name="npus_sub_space_curr" pos="0" rst="0x0">
          <comment>0: 3.75KHz
1: 15KHz</comment>
        </bits>
      </reg>
      <reg name="npus_dmrs_cfg_curr1" protect="rw">
        <comment>NPUSCH DMRS</comment>
        <bits access="rw" name="first_ru_slot_curr" pos="26:22" rst="0x0">
          <comment>RU0~19</comment>
        </bits>
        <bits access="rw" name="slot_n_curr" pos="21:7" rst="0x0">
          <comment>1DMRS0~20480</comment>
        </bits>
        <bits access="rw" name="base_seq_curr" pos="6:2" rst="0x0">
          <comment>BASE_SEQ_CURR0~30</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_curr" pos="1:0" rst="0x0">
          <comment>CYCLIC_SHIFT0~3</comment>
        </bits>
      </reg>
      <reg name="npra _cfg_curr1" protect="rw">
        <comment>NPRACH</comment>
        <bits access="rw" name="sym_group_rep_cnt_curr" pos="16:9" rst="0x0">
          <comment>t0~128</comment>
        </bits>
        <bits access="rw" name="nprach_sc_offset_curr" pos="8:6" rst="0x0">
          <comment>frequency location of the first sub-carrier allocated to NPRACH
000frequency location0
001frequency location2
010frequency location12
011frequency location18
100frequency location24
101frequency location34
110frequency location36
1110</comment>
        </bits>
        <bits access="rw" name="init_sc_curr" pos="5:0" rst="0x0">
          <comment>being the subcarrier selected by the MAC layer from  0-47</comment>
        </bits>
      </reg>
      <reg name="dft_ctrl_curr2" protect="rw">
        <comment>DFT/IDFT</comment>
        <bits access="rw" name="anti_drop_en_curr" pos="12" rst="0x0">
          <comment>0ANTI_DROP
1ANTI_DROP</comment>
        </bits>
        <bits access="rw" name="anti_drop_lnum_curr" pos="11" rst="0x0">
          <comment>ANTI_DROP:
08bit
17bit</comment>
        </bits>
        <bits access="rw" name="dft_npts_curr" pos="10:5" rst="0x0">
          <comment>DFT/IDFTindex0~4344index </comment>
        </bits>
        <bits access="rw" name="pus_modu_sel_curr" pos="4:3" rst="0x0">
          <comment>00: BPSK
01: QPSK
10: 16QAM
11: 64QAM</comment>
        </bits>
        <bits access="rw" name="dft_en_curr" pos="2" rst="0x0">
          <comment>0DFT/IDFT
1DFT/IDFT</comment>
        </bits>
        <bits access="rw" name="pus_mod_en_curr" pos="1" rst="0x0">
          <comment>0PUSCH
1PUSCH</comment>
        </bits>
        <bits access="rw" name="dft_idft_sel_curr" pos="0" rst="0x0">
          <comment>0: DFT
1: IDFT</comment>
        </bits>
      </reg>
      <reg name="puc_mod_data_curr2" protect="rw">
        <comment>PUCCH</comment>
        <bits access="rw" name="puc_mod_data_curr" pos="21:0" rst="0x0">
          <comment>PUCCHd(n)</comment>
        </bits>
      </reg>
      <reg name="srs_map_cfg_curr2" protect="rw">
        <comment>SRS</comment>
        <bits access="rw" name="k_tc_num_curr" pos="26" rst="0x0">
          <comment>SRS
021
143</comment>
        </bits>
        <bits access="rw" name="k_tc_curr" pos="25:24" rst="0x0">
          <comment>
000
011
102
113</comment>
        </bits>
        <bits access="rw" name="srs_map_len_curr" pos="22:16" rst="0x0">
          <comment>SRS</comment>
        </bits>
        <bits access="rw" name="srs_map_start2_curr" pos="14:8" rst="0x0">
          <comment>SRS</comment>
        </bits>
        <bits access="rw" name="srs_map_start1_curr" pos="6:0" rst="0x0">
          <comment>SRS</comment>
        </bits>
      </reg>
      <reg name="srs_zc_len_curr2" protect="rw">
        <comment>SRSZC</comment>
        <bits access="rw" name="srs_num_curr" pos="24" rst="0x0">
          <comment>0SRS1
1SRS2</comment>
        </bits>
        <bits access="rw" name="srs_map_ofdm2_curr" pos="23:20" rst="0x0">
          <comment>SRSOFDM</comment>
        </bits>
        <bits access="rw" name="sra_map_ofdm1_curr" pos="19:16" rst="0x0">
          <comment>SRSOFDM</comment>
        </bits>
        <bits access="rw" name="special_frame_start_curr" pos="15:12" rst="0x0">
          <comment>SRSOFDM</comment>
        </bits>
        <bits access="rw" name="srs_zc_len_curr" pos="10:0" rst="0x0">
          <comment>SRSZC</comment>
        </bits>
      </reg>
      <reg name="puc_map_cfg_curr2" protect="rw">
        <comment>PUCCH</comment>
        <bits access="rw" name="tx_fir_en_curr" pos="31" rst="0x0">
          <comment>0TX
1TX</comment>
        </bits>
        <bits access="rw" name="tx_nb_start2_curr" pos="30:24" rst="0x0">
          <comment>2</comment>
        </bits>
        <bits access="rw" name="tx_nb_start1_curr" pos="22:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="puc_map_start2_curr" pos="14:8" rst="0x0">
          <comment>PUCCH</comment>
        </bits>
        <bits access="rw" name="puc_map_start1_curr" pos="6:0" rst="0x0">
          <comment>PUCCH</comment>
        </bits>
      </reg>
      <reg name="pus_map_cfg_curr2" protect="rw">
        <comment>PUSCH</comment>
        <bits access="rw" name="pus_map_sel_curr" pos="31" rst="0x0">
          <comment>PUSCH
00.5ms
11ms</comment>
        </bits>
        <bits access="rw" name="pus_map_len2_curr" pos="30:24" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
        <bits access="rw" name="pus_map_len1_curr" pos="22:16" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
        <bits access="rw" name="pus_map_start2_curr" pos="14:8" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
        <bits access="rw" name="pus_map_start1_curr" pos="6:0" rst="0x0">
          <comment>PUSCH</comment>
        </bits>
      </reg>
      <reg name="hard_para_curr12" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="pucpus_shortened_mode_curr" pos="14:11" rst="0x0">
          <comment>PUSCH/PUCCH
0000normal
0001type0_shortend
0010type1_shortend
0011type2_shortend
0100type3_shortend
0101type4_shortend
0110type5_shortend
0111:  type6_shortend
1000:  type7_shortend
1001:  other</comment>
        </bits>
        <bits access="rw" name="group_hop_flag_curr" pos="10" rst="0x0">
          <comment>1u
0u</comment>
        </bits>
        <bits access="rw" name="seq_hop_flag_curr" pos="9" rst="0x0">
          <comment>1v
0v</comment>
        </bits>
        <bits access="rw" name="ta_overlap_curr" pos="8:3" rst="0x0">
          <comment>TA0~32</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_field_curr" pos="2:0" rst="0x0">
          <comment>dmrsValue0~7</comment>
        </bits>
      </reg>
      <reg name="hard_para _curr22" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="delta_apc_srs_curr" pos="31:16" rst="0x0">
          <comment>SRSAPC </comment>
        </bits>
        <bits access="rw" name="delta_apc_scr_curr" pos="15:0" rst="0x0">
          <comment>PUSCH/PUCCH/PRACHAPC </comment>
        </bits>
      </reg>
      <reg name="hard_para _curr32" protect="rw">
        <comment>3</comment>
        <bits access="rw" name="n1_pucch_curr" pos="31:20" rst="0x0">
          <comment>PUCCH1/1a/1b0~4095</comment>
        </bits>
        <bits access="rw" name="srs_cycle_shift_curr" pos="19:16" rst="0x0">
          <comment>SRS</comment>
        </bits>
        <bits access="rw" name="subframe_slot_cnt_curr" pos="14:10" rst="0x0">
          <comment>CAT1/CATM/CAT-NB15kHz1ms2CAT-NB3.75kHz2ms1</comment>
        </bits>
        <bits access="rw" name="nf_curr" pos="9:0" rst="0x0">
          <comment>0~1023</comment>
        </bits>
      </reg>
      <reg name="ofdm_offset_curr2" protect="rw">
        <comment>OFDM OFFSET</comment>
        <bits access="rw" name="ofdm_offset_last_curr" pos="31:16" rst="0x0">
          <comment>OFDMoffset</comment>
        </bits>
        <bits access="rw" name="ofdm_offset_first_curr" pos="15:0" rst="0x0">
          <comment>OFDMoffset</comment>
        </bits>
      </reg>
      <reg name="dft_fft_inten_curr2" protect="rw">
        <comment></comment>
        <bits access="rw" name="err_inten_curr" pos="15" rst="0x0">
          <comment>0ULDFTTXRXPUSCHERROR
1ULDFTTXRXPUSCHERROR</comment>
        </bits>
        <bits access="rw" name="dma_inten_curr" pos="14" rst="0x0">
          <comment>1AXIDMA
0AXIDMA</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten13_curr" pos="13" rst="0x0">
          <comment>1OFDM13
0OFDM13</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten12_curr" pos="12" rst="0x0">
          <comment>1OFDM12
0OFDM12</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten11_curr" pos="11" rst="0x0">
          <comment>1OFDM11
0OFDM11</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten10_curr" pos="10" rst="0x0">
          <comment>1OFDM10
0OFDM10</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten9_curr" pos="9" rst="0x0">
          <comment>1OFDM9
0OFDM9</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten8_curr" pos="8" rst="0x0">
          <comment>1OFDM8
0OFDM8</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten7_curr" pos="7" rst="0x0">
          <comment>1OFDM7
0OFDM7</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten6_curr" pos="6" rst="0x0">
          <comment>1OFDM6
0OFDM6</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten5_curr" pos="5" rst="0x0">
          <comment>1OFDM5
0OFDM5</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten4_curr" pos="4" rst="0x0">
          <comment>1OFDM4
0OFDM4</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten3_curr" pos="3" rst="0x0">
          <comment>1OFDM3
0OFDM3</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten2_curr" pos="2" rst="0x0">
          <comment>1OFDM2
0OFDM2</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten1_curr" pos="1" rst="0x0">
          <comment>1OFDM1
0OFDM1</comment>
        </bits>
        <bits access="rw" name="dft_fft_inten0_curr" pos="0" rst="0x0">
          <comment>1OFDM0
0OFDM0</comment>
        </bits>
      </reg>
      <reg name="ofdm_zero_curr2" protect="rw">
        <comment>OFDM</comment>
        <bits access="rw" name="ofdm_zero_curr" pos="13:0" rst="0x0">
          <comment>OFDM
14b0
14b10
14b1101
14b111012
</comment>
        </bits>
      </reg>
      <reg name="dft_fft_ctrl_curr2" protect="rw">
        <comment>DFT/IDFT&amp;FFT/IFFT</comment>
        <bits access="rw" name="dftfft_soft_start" pos="30" rst="0x0">
          <comment>0ULDFT
1ULDFT</comment>
        </bits>
        <bits access="rw" name="dft_trig_mode" pos="29" rst="0x0">
          <comment>0ULDFT
1ULDFTPUSCH</comment>
        </bits>
        <bits access="rw" name="launch_en_curr" pos="28" rst="0x0">
          <comment>0
1</comment>
        </bits>
        <bits access="rw" name="srs_en_curr" pos="27" rst="0x0">
          <comment>0SRS
1SRS</comment>
        </bits>
        <bits access="rw" name="clear_en_curr" pos="26" rst="0x0">
          <comment>0FFTMEM
1FFTMEM</comment>
        </bits>
        <bits access="rw" name="fft_ifft_sel_curr" pos="25" rst="0x0">
          <comment>1IFFT
0FFT</comment>
        </bits>
        <bits access="rw" name="fft_cal_curr" pos="24" rst="0x0">
          <comment>1FFT/IFFT
0FFT/IFFT</comment>
        </bits>
        <bits access="rw" name="pwradj_en_curr" pos="23" rst="0x0">
          <comment>0
1</comment>
        </bits>
        <bits access="rw" name="prach_format_sel_curr" pos="22:20" rst="0x0">
          <comment>PRACH
000PRACH0
001PRACH1
010PRACH2
011PRACH3
100PRACH4
</comment>
        </bits>
        <bits access="rw" name="pucch_format_sel_curr" pos="19:17" rst="0x0">
          <comment>PUCCH
000PUCCH1
001PUCCH1a
010PUCCH1b
011PUCCH2
100PUCCH2a
101PUCCH2b
</comment>
        </bits>
        <bits access="rw" name="npusch_formatsel_curr" pos="16" rst="0x0">
          <comment>0NPUSCH format 1
1NPUSCH format2</comment>
        </bits>
        <bits access="rw" name="ofdm_num_curr" pos="15:12" rst="0x0">
          <comment>OFDM</comment>
        </bits>
        <bits access="rw" name="datadrive_en_curr" pos="10" rst="0x0">
          <comment>0DATADRIVE
1DATADRIVE</comment>
        </bits>
        <bits access="rw" name="pus_buf_sel_curr" pos="9:8" rst="0x0">
          <comment>UL_DFTPUSCH BUFFER
00PUSCH BUFFER1
01PUSCH BUFFER2
10PUSCH BUFFER3
11PUSCH PRA_BUF</comment>
        </bits>
        <bits access="rw" name="chan_mode_curr" pos="6:4" rst="0x0">
          <comment>
000PUSCH
001PUCCH
010PRACH
011SRS
100NPUSCH
101NPRACH
</comment>
        </bits>
        <bits access="rw" name="fft_npts" pos="3:1" rst="0x0">
          <comment>FFT/IFFT
111
110
101
1002048
0111024
010512
001256
000128</comment>
        </bits>
        <bits access="rw" name="dftfft_irqen_curr" pos="0" rst="0x0">
          <comment>0: 
1: </comment>
        </bits>
      </reg>
      <reg name=" fft_lnum_srs_curr2" protect="rw">
        <comment>SRSFFT</comment>
        <bits access="rw" name="fft_lnum11_srs_curr" pos="21:20" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_srs_curr" pos="19:18" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_srs_curr" pos="17:16" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_srs_curr" pos="15:14" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_srs_curr" pos="13:12" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_srs_curr" pos="11:10" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_srs_curr" pos="9:8" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_srs_curr" pos="7:6" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_srs_curr" pos="5:4" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_srs_curr" pos="3:2" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_srs_curr" pos="1:0" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
      </reg>
      <reg name="fft_lnum_scr_curr2" protect="rw">
        <comment>PUSCH/PUCCH/PRACHFFT</comment>
        <bits access="rw" name="fft_lnum11_scr_curr" pos="21:20" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum10_scr_curr" pos="19:18" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum9_scr_curr" pos="17:16" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum8_scr_curr" pos="15:14" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum7_scr_curr" pos="13:12" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum6_scr_curr" pos="11:10" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum5_scr_curr" pos="9:8" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum4_scr_curr" pos="7:6" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum3_scr_curr" pos="5:4" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum2_scr_curr" pos="3:2" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
        <bits access="rw" name="fft_lnum1_scr_curr" pos="1:0" rst="0x0">
          <comment>FFT
2b0025~14bit
2b0126~15bit
2b1027~16bit
2b1128~17bit</comment>
        </bits>
      </reg>
      <reg name="npus_map_cfg_curr2" protect="rw">
        <comment>NPUSCH</comment>
        <bits access="rw" name="npus_rep_cnt_curr" pos="23:17" rst="0x0">
          <comment>NPUSCH0~127</comment>
        </bits>
        <bits access="rw" name="n_ru_sc_curr" pos="16:15" rst="0x0">
          <comment>
001
013
106
1112</comment>
        </bits>
        <bits access="rw" name="isc_start_index_curr" pos="14:9" rst="0x0">
          <comment>NPUSCH 0~47</comment>
        </bits>
        <bits access="rw" name="n_slot_cnt_curr" pos="8:1" rst="0x0">
          <comment>Nslots1~160</comment>
        </bits>
        <bits access="rw" name="npus_sub_space_curr" pos="0" rst="0x0">
          <comment>0: 3.75KHz
1: 15KHz</comment>
        </bits>
      </reg>
      <reg name="npus_dmrs_cfg_curr2" protect="rw">
        <comment>NPUSCH DMRS</comment>
        <bits access="rw" name="first_ru_slot_curr" pos="26:22" rst="0x0">
          <comment>RU0~19</comment>
        </bits>
        <bits access="rw" name="slot_n_curr" pos="21:7" rst="0x0">
          <comment>1DMRS0~20480</comment>
        </bits>
        <bits access="rw" name="base_seq_curr" pos="6:2" rst="0x0">
          <comment>BASE_SEQ_CURR0~30</comment>
        </bits>
        <bits access="rw" name="cyclic_shift_curr" pos="1:0" rst="0x0">
          <comment>CYCLIC_SHIFT0~3</comment>
        </bits>
      </reg>
      <reg name="npra _cfg_curr2" protect="rw">
        <comment>NPRACH</comment>
        <bits access="rw" name="sym_group_rep_cnt_curr" pos="16:9" rst="0x0">
          <comment>t0~128</comment>
        </bits>
        <bits access="rw" name="nprach_sc_offset_curr" pos="8:6" rst="0x0">
          <comment>frequency location of the first sub-carrier allocated to NPRACH
000frequency location0
001frequency location2
010frequency location12
011frequency location18
100frequency location24
101frequency location34
110frequency location36
1110</comment>
        </bits>
        <bits access="rw" name="init_sc_curr" pos="5:0" rst="0x0">
          <comment>being the subcarrier selected by the MAC layer from  0-47</comment>
        </bits>
      </reg>
      <reg name="fsm_state" protect="rw">
        <comment></comment>
        <bits access="r" name="ocp_pi" pos="31" rst="0x0">
          <comment>TXRX PING
1
0</comment>
        </bits>
        <bits access="r" name="ocp_pa" pos="30" rst="0x0">
          <comment>TXRX PANG
1
0</comment>
        </bits>
        <bits access="r" name="frame_state" pos="29:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="ofdm_state" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="ofdm_count" protect="rw">
        <comment>OFDM</comment>
        <bits access="r" name="ofdm_count" pos="3:0" rst="0x0">
          <comment>OFDM0~13</comment>
        </bits>
      </reg>
      <reg name="fsm_state_assert" protect="rw">
        <comment>ASSERT</comment>
        <bits access="r" name="ocp_pi_assert" pos="31" rst="0x0">
          <comment>ASSERT TXRX PING
1
0</comment>
        </bits>
        <bits access="r" name="ocp_pa_assert" pos="30" rst="0x0">
          <comment>ASSERT TXRX PANG
1
0</comment>
        </bits>
        <bits access="r" name="frame_state_assert" pos="29:16" rst="0x0">
          <comment>ASSERT</comment>
        </bits>
        <bits access="r" name="ofdm_state_assert" pos="15:0" rst="0x0">
          <comment>ASSERT</comment>
        </bits>
      </reg>
      <reg name="ofdm_assert" protect="rw">
        <comment>OFDM</comment>
        <bits access="r" name="ofdm_assert" pos="3:0" rst="0x0">
          <comment>ASSERT OFDM0~13</comment>
        </bits>
      </reg>
      <hole size="30624"/>
      <reg name="uldft_mem1" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem2" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem3" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem4" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem5" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem6" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem7" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem8" protect="rw">
        </reg>
      <hole size="8160"/>
      <reg name="uldft_mem9" protect="rw">
        </reg>
      <hole size="16352"/>
      <reg name="uldft_mem10" protect="rw">
        </reg>
    </module>
    <instance address="0x18700000" name="UL_DFT" type="UL_DFT"/>
  </archive>
  <archive relative="txrx.xml">
    <module category="System" name="TXRX">
      <reg name="int_flag" protect="rw">
        <comment></comment>
        <bits access="rc" name="tx_trace_fin" pos="5" rst="0x0">
          <comment>TRACE
0
1</comment>
        </bits>
        <bits access="rc" name="rx_trace_fin" pos="4" rst="0x0">
          <comment>TRACE
0
1</comment>
        </bits>
        <bits access="rc" name="tx_fin" pos="3" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rc" name="tx_ofdm" pos="2" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rc" name="rx_fin" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rc" name="rx_ofdm" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="int_mask" protect="rw">
        <comment></comment>
        <bits access="rw" name="tx_trace_fin" pos="5" rst="0x0">
          <comment>TRACE
0
1</comment>
        </bits>
        <bits access="rw" name="rx_trace_fin" pos="4" rst="0x0">
          <comment>TRACE
0
1</comment>
        </bits>
        <bits access="rw" name="tx_finish_mask" pos="3" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="tx_ofdm_mask" pos="2" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="rx_finish_mask" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="rx_ofdm_mask" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="int_flag_ofdm_rx" protect="rw">
        <comment>OFDM</comment>
        <bits access="rc" name="rx_ofdm_int_14" pos="14" rst="0x0">
          <comment>0OFDM14
1OFDM14</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_13" pos="13" rst="0x0">
          <comment>0OFDM13
1OFDM13</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_12" pos="12" rst="0x0">
          <comment>0OFDM12
1OFDM12</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_11" pos="11" rst="0x0">
          <comment>0OFDM11
1OFDM11</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_10" pos="10" rst="0x0">
          <comment>0OFDM10
1OFDM10</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_9" pos="9" rst="0x0">
          <comment>0OFDM9
1OFDM9</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_8" pos="8" rst="0x0">
          <comment>0OFDM8
1OFDM8</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_7" pos="7" rst="0x0">
          <comment>0OFDM7
1OFDM7</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_6" pos="6" rst="0x0">
          <comment>0OFDM6
1OFDM6</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_5" pos="5" rst="0x0">
          <comment>0OFDM5
1OFDM5</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_4" pos="4" rst="0x0">
          <comment>0OFDM4
1OFDM4</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_3" pos="3" rst="0x0">
          <comment>0OFDM3
1OFDM3</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_2" pos="2" rst="0x0">
          <comment>0OFDM2
1OFDM2</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_1" pos="1" rst="0x0">
          <comment>0OFDM1
1OFDM1</comment>
        </bits>
        <bits access="rc" name="rx_ofdm_int_0" pos="0" rst="0x0">
          <comment>0OFDM0
1OFDM0</comment>
        </bits>
      </reg>
      <reg name="int_mask_ofdm_rx" protect="rw">
        <comment></comment>
        <bits access="rw" name="rx_inten" pos="16" rst="0x0">
          <comment>1
0
1</comment>
        </bits>
        <bits access="rw" name="rx_last_int_en" pos="15" rst="0x0">
          <comment>0OFDM
1OFDM</comment>
        </bits>
        <bits access="rw" name="rx_int_en14" pos="14" rst="0x0">
          <comment>0OFDM14
1OFDM14</comment>
        </bits>
        <bits access="rw" name="rx_int_en13" pos="13" rst="0x0">
          <comment>0OFDM13
1OFDM13</comment>
        </bits>
        <bits access="rw" name="rx_int_en12" pos="12" rst="0x0">
          <comment>0OFDM12
1OFDM12</comment>
        </bits>
        <bits access="rw" name="rx_int_en11" pos="11" rst="0x0">
          <comment>0OFDM11
1OFDM11</comment>
        </bits>
        <bits access="rw" name="rx_int_en10" pos="10" rst="0x0">
          <comment>0OFDM10
1OFDM10</comment>
        </bits>
        <bits access="rw" name="rx_int_en9" pos="9" rst="0x0">
          <comment>0OFDM9
1OFDM9</comment>
        </bits>
        <bits access="rw" name="rx_int_en8" pos="8" rst="0x0">
          <comment>0OFDM8
1OFDM8</comment>
        </bits>
        <bits access="rw" name="rx_int_en7" pos="7" rst="0x0">
          <comment>0OFDM7
1OFDM7</comment>
        </bits>
        <bits access="rw" name="rx_int_en6" pos="6" rst="0x0">
          <comment>0OFDM6
1OFDM6</comment>
        </bits>
        <bits access="rw" name="rx_int_en5" pos="5" rst="0x0">
          <comment>0OFDM5
1OFDM5</comment>
        </bits>
        <bits access="rw" name="rx_int_en4" pos="4" rst="0x0">
          <comment>0OFDM4
1OFDM4</comment>
        </bits>
        <bits access="rw" name="rx_int_en3" pos="3" rst="0x0">
          <comment>0OFDM3
1OFDM3</comment>
        </bits>
        <bits access="rw" name="rx_int_en2" pos="2" rst="0x0">
          <comment>0OFDM2
1OFDM2</comment>
        </bits>
        <bits access="rw" name="rx_int_en1" pos="1" rst="0x0">
          <comment>0OFDM1
1OFDM1</comment>
        </bits>
        <bits access="rw" name="rx_int_en0" pos="0" rst="0x0">
          <comment>0OFDM0
1OFDM0</comment>
        </bits>
      </reg>
      <reg name="sys_cfg" protect="rw">
        <comment></comment>
        <bits access="rw" name="rx_dcoc_sel" pos="5" rst="0x0">
          <comment>DCOC
1
0</comment>
        </bits>
        <bits access="rw" name="rx_ovt" pos="4" rst="0x0">
          <comment>0
1</comment>
        </bits>
        <bits access="rw" name="tx_ovt" pos="3" rst="0x0">
          <comment>0
1</comment>
        </bits>
        <bits access="rw" name="tx_dfe_en" pos="2" rst="0x0">
          <comment>DFE
0DFE
1DFE</comment>
        </bits>
        <bits access="rw" name="tx_nb_en" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="cat1_en" pos="0" rst="0x0">
          <comment>CAT1
0CAT1
1CAT1</comment>
        </bits>
      </reg>
      <reg name="stop_cfg" protect="rw">
        <comment></comment>
        <bits access="rw" name="tx_stop_en" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="rx_stop_en" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="rx_cfg" protect="rw">
        <comment></comment>
        <bits access="rw" name="rx_soft_afc_en" pos="31" rst="0x0">
          <comment>SOFT AFC 
0
1</comment>
        </bits>
        <bits access="rw" name="rx_rssi_cfg" pos="30" rst="0x0">
          <comment>RSSI
1data
0data</comment>
        </bits>
        <bits access="rw" name="rssi_save_sel" pos="27:25" rst="0x0">
          <comment>RSSI 
0: RSSI_MAX1
1: RSSI_MAX2
2: RSSI_MAX3
3: RSSI_MAX4
4: RSSI_MAX5
Other:</comment>
        </bits>
        <bits access="rw" name="rx_hf_fir_en" pos="23" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="rx_otdoa_en" pos="22" rst="0x0">
          <comment>OTDOA
1
0</comment>
        </bits>
        <bits access="rw" name="offset_ctrl_flag" pos="21" rst="0x0">
          <comment>offset
1RXoffsetcp
0offset</comment>
        </bits>
        <bits access="rw" name="rx_iddet_en" pos="19" rst="0x0">
          <comment>1IDDET
0IDDET</comment>
        </bits>
        <bits access="rw" name="rx_dlfft_en" pos="18" rst="0x0">
          <comment>DLFFT DATA_DRIVE
0
1</comment>
        </bits>
        <bits access="rw" name="rx_cp_type" pos="17:16" rst="0x0">
          <comment>00CP
01CP
10CPIDDET</comment>
        </bits>
        <bits access="rw" name="hf_fir_bitsel" pos="11:8" rst="0x0">
          <comment>FIR
4h033-22
4h132-21
4h231-20
4h330-19
4h429-18
4h528-17
4h627-16
4h726-15
4h825-14
4h924-13
4ha23-12
4hb22-11
4hc21-10
4hd20-9
4he19-8
4hf18-7</comment>
        </bits>
        <bits access="rw" name="rx_trace_en" pos="7" rst="0x0">
          <comment>TRACE
1
0</comment>
        </bits>
        <bits access="rw" name="offset_zero_flag" pos="6" rst="0x0">
          <comment>0measpwr/dlfft offset
10
0offsetoffset_ctrl_flag</comment>
        </bits>
        <bits access="rw" name="rx_meas_en" pos="5" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="rx_norm_en" pos="4" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="rx_ave_en" pos="3" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="rx_sat_en" pos="2" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="rx_rssi_en" pos="1" rst="0x0">
          <comment>RSSI
1
0</comment>
        </bits>
        <bits access="rw" name="glb_rxen" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="rx_1st_ofdm_len_offset" protect="rw">
        <comment>OFDM</comment>
        <bits access="rw" name="rx_ist_ofdm_len_offset" pos="9:0" rst="0x0">
          <comment>OFDM</comment>
        </bits>
      </reg>
      <reg name="rx_afc_factor" protect="rw">
        <comment>SOFT AFC</comment>
        <bits access="rw" name="rx_afc_update" pos="16" rst="0x0">
          <comment>AFC
1
0</comment>
        </bits>
        <bits access="rw" name="rx_afc_factor" pos="15:0" rst="0x0">
          <comment>AFC
10hz</comment>
        </bits>
      </reg>
      <reg name="rx_rssi_max_cfg" protect="rw">
        <comment>RSSI MAX</comment>
        <bits access="rw" name="next_en" pos="5" rst="0x0">
          <comment>
1
0
AD_ON0</comment>
        </bits>
        <bits access="rw" name="rssi_max_clear" pos="4" rst="0x0">
          <comment>RSSI0
1
0</comment>
        </bits>
        <bits access="rw" name="rssi_max_start" pos="3:0" rst="0x0">
          <comment>RSSI</comment>
        </bits>
      </reg>
      <reg name="rx_norm_cfg" protect="rw">
        <comment></comment>
        <bits access="rw" name="rx_norm_cfg" pos="2:0" rst="0x1">
          <comment>
1~5</comment>
        </bits>
      </reg>
      <reg name="rx_sat_val" protect="rw">
        <comment></comment>
        <bits access="rw" name="sat_val_max" pos="27:16" rst="0x0">
          <comment>
</comment>
        </bits>
        <bits access="rw" name="sat_val_min" pos="11:0" rst="0x0">
          <comment>
</comment>
        </bits>
      </reg>
      <reg name="rx_pre_cfg" protect="rw">
        <comment>PRE</comment>
        <bits access="rw" name="rx_freq_factor" pos="22:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="rx_bw_sel" pos="10:8" rst="0x0">
          <comment>
3h5: 20M       (1/16)
3h4: 15M       (1/16)
3h3: 10M       (1/8)
3h2: 5M        (1/4)
3h1: 3M        (1/2)
3h0: 1.4M
Other:</comment>
        </bits>
        <bits access="rw" name="freq_en" pos="7" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="fir_en" pos="6" rst="0x0">
          <comment>FIR
1
0</comment>
        </bits>
        <bits access="rw" name="rx_bitsel" pos="4:0" rst="0x8">
          <comment>FIR
5b0000034-23
5b0000133-22
5b0001032-21
5b0001131-20
5b0010030-19
5b0010129-18
5b0011028-17
5b0011127-16
5b0100026-15
5b0100125-14
5b0101024-13
5b0101123-12
5b0110022-11
5b0110121-10
5b0111020-9
5b0111119-8
5b1000018-7
5b1000117-6
5b1001016-5
Other</comment>
        </bits>
      </reg>
      <reg name="rx_aux_cfg" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rx_phy_factor" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rx_dc_cfg" protect="rw">
        <comment></comment>
        <bits access="rw" name="rx_dc_update" pos="31" rst="0x0">
          <comment>DCOC
0
1</comment>
        </bits>
        <bits access="rw" name="rx_dc_i" pos="27:16" rst="0x0">
          <comment>I</comment>
        </bits>
        <bits access="rw" name="rx_dc_q" pos="11:0" rst="0x0">
          <comment>Q</comment>
        </bits>
      </reg>
      <reg name="rx_gain1_cfg" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="rx_gain1_en" pos="16" rst="0x0">
          <comment>GAIN1
0
1</comment>
        </bits>
        <bits access="rw" name="rx_gain1" pos="9:0" rst="0x0">
          <comment>GAIN1</comment>
        </bits>
      </reg>
      <reg name="rx_gain2_cfg" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="rx_gain2_en" pos="16" rst="0x0">
          <comment>GAIN2
0
1</comment>
        </bits>
        <bits access="rw" name="rx_gain2" pos="9:0" rst="0x0">
          <comment>GAIN2</comment>
        </bits>
      </reg>
      <reg name="rx_out_cfg" protect="rw">
        <comment></comment>
        <bits access="rw" name="iddet_dat_start" pos="21:20" rst="0x3">
          <comment>IDDET
2h0:bit7
2'h1:bit8
2h2:bit9
2'h3:bit10</comment>
        </bits>
        <bits access="rw" name="iddet_dat_fin" pos="18:16" rst="0x0">
          <comment>IDDET
3h0:bit0
3'h1:bit1
3h2:bit2
3'h3:bit3
3h4:bit4
other:reserved</comment>
        </bits>
        <bits access="rw" name="otdoa_dat_start" pos="13:12" rst="0x3">
          <comment>OTDOA
2h0:bit7
2'h1:bit8
2h2:bit9
2'h3:bit10</comment>
        </bits>
        <bits access="rw" name="otdoa_dat_fin" pos="10:8" rst="0x0">
          <comment>OTDOA
3h0:bit0
3'h1:bit1
3h2:bit2
3'h3:bit3
3h4:bit4
other:reserved</comment>
        </bits>
        <bits access="rw" name="meas_dat_start" pos="5:4" rst="0x3">
          <comment>MEASPWR
2h0:bit7
2'h1:bit8
2h2:bit9
2'h3:bit10</comment>
        </bits>
        <bits access="rw" name="meas_dat_fin" pos="2:0" rst="0x0">
          <comment>MEASPWR
3h0:bit0
3'h1:bit1
3h2:bit2
3'h3:bit3
3h4:bit4
other:reserved</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="tx_cfg" protect="rw">
        <comment></comment>
        <bits access="rw" name="tx_loop" pos="4" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="tx_data_drive" pos="3" rst="0x0">
          <comment>DATA_DRIVE
0
1</comment>
        </bits>
        <bits access="rw" name="tx_cp_type" pos="2" rst="0x0">
          <comment>1CP
0CP</comment>
        </bits>
        <bits access="rw" name="glb_txen" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="tx_1st_ofdm_len_offset" protect="rw">
        <comment>OFDM</comment>
        <bits access="rw" name="tx_1st_ofdm_len_offset" pos="6:0" rst="0x0">
          <comment>OFDM(-32~31)</comment>
        </bits>
      </reg>
      <reg name="tx_ofdm0_len" protect="rw">
        <comment>PINGCP</comment>
        <bits access="rw" name="tx_ofdm0_len" pos="11:0" rst="0x89">
          <comment>PINGCP0</comment>
        </bits>
      </reg>
      <reg name="tx_ofdm1_len" protect="rw">
        <comment>PANGCP</comment>
        <bits access="rw" name="tx_ofdm1_len" pos="11:0" rst="0x88">
          <comment>PANGCP0</comment>
        </bits>
      </reg>
      <reg name="tx_post_cfg" protect="rw">
        <comment>POST</comment>
        <bits access="r" name="prach_en" pos="23" rst="0x0">
          <comment>PRACH
1
0
DFT</comment>
        </bits>
        <bits access="r" name="prach_format" pos="22:20" rst="0x0">
          <comment>PRACH 
3hxxx0~4
DFT</comment>
        </bits>
        <bits access="r" name="tx_nb_start" pos="18:12" rst="0x0">
          <comment>NB
DFT</comment>
        </bits>
        <bits access="r" name="tx_fir_en" pos="11" rst="0x0">
          <comment>
1
0
DFT</comment>
        </bits>
        <bits access="rw" name="tx_bw_sel" pos="10:8" rst="0x0">
          <comment>
3h5: 20M       (16)
3h4: 15M       (16)
3h3: 10M       (8)
3h2: 5M        (4)
3h1: 3M        (2)
3h0: 1.4M
Other:</comment>
        </bits>
        <bits access="rw" name="tx_freq_en" pos="7" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="tx_bitsel" pos="4:0" rst="0x8">
          <comment>FIR
5b0000034-23
5b0000133-22
5b0001032-21
5b0001131-20
5b0010030-19
5b0010129-18
5b0011028-17
5b0011127-16
5b0100026-15
5b0100125-14
5b0101024-13
5b0101123-12
5b0110022-11
5b0110121-10
5b0111020-9
5b0111119-8
5b1000018-7
5b1000117-6
5b1001016-5
Other</comment>
        </bits>
      </reg>
      <reg name="tx_fill0_num" protect="rw">
        <comment></comment>
        <bits access="rw" name="tx_fill0_num" pos="7:0" rst="0x0">
          <comment>0
8hff : 255
8hfe: 254

8h01: 1
8h00: 0</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="rx_phy_factor_cur" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rx_sat_cnt" protect="rw">
        <comment></comment>
      </reg>
      <reg name="rx_norm_data" protect="rw">
        <comment></comment>
        <bits access="r" name="rx_norm_data" pos="3:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="rssi_max1" protect="rw">
        <comment>RSSI 1</comment>
      </reg>
      <reg name="rssi_max2" protect="rw">
        <comment>RSSI 2</comment>
      </reg>
      <reg name="rssi_max3" protect="rw">
        <comment>RSSI 3</comment>
      </reg>
      <reg name="rssi_max4" protect="rw">
        <comment>RSSI 4</comment>
      </reg>
      <reg name="rssi_max5" protect="rw">
        <comment>RSSI 5</comment>
      </reg>
      <reg name="rx_dc_cal_value" protect="rw">
        <comment></comment>
        <bits access="r" name="rx_dc_cal_value_i" pos="31:16" rst="0x0">
          <comment>I</comment>
        </bits>
        <bits access="r" name="rx_dc_cal_value_q" pos="15:0" rst="0x0">
          <comment>Q</comment>
        </bits>
      </reg>
      <hole size="224"/>
      <reg name="rx_ofdm_stat" protect="rw">
        <comment>OFDM</comment>
        <bits access="r" name="rx_mem_addr" pos="27:16" rst="0x0">
          <comment>RX_MEM</comment>
        </bits>
        <bits access="r" name="ad_on" pos="13" rst="0x0">
          <comment>AD_ON</comment>
        </bits>
        <bits access="r" name="rx_running" pos="12" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="r" name="rx_dlfft_en" pos="11" rst="0x0">
          <comment>DLFFT</comment>
        </bits>
        <bits access="r" name="rx_otdoa_en" pos="10" rst="0x0">
          <comment>OTDOA</comment>
        </bits>
        <bits access="r" name="rx_iddet_en" pos="9" rst="0x0">
          <comment>IDDET</comment>
        </bits>
        <bits access="r" name="rx_meas_en" pos="8" rst="0x0">
          <comment>MEAS</comment>
        </bits>
        <bits access="r" name="cp_err" pos="7" rst="0x0">
          <comment>CP
0
1</comment>
        </bits>
        <bits access="r" name="rx_no_data_err" pos="6" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="r" name="ping_pang_stat" pos="4" rst="0x0">
          <comment>PING_PANG</comment>
        </bits>
        <bits access="r" name="rx_ofdm_stat" pos="3:0" rst="0x0">
          <comment>OFDM</comment>
        </bits>
      </reg>
      <reg name="tx_fifo_stat" protect="rw">
        <comment>FIFO</comment>
        <bits access="r" name="tx_mem_addr" pos="27:16" rst="0x0">
          <comment>TX_MEM</comment>
        </bits>
        <bits access="r" name="da_on" pos="13" rst="0x0">
          <comment>DA_ON</comment>
        </bits>
        <bits access="r" name="tx_running" pos="12" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="r" name="tx_fifo_stat" pos="4" rst="0x0">
          <comment>FIFO
0ping
1pang</comment>
        </bits>
        <bits access="r" name="tx_ofdm_stat" pos="3:0" rst="0x0">
          <comment>OFDM</comment>
        </bits>
      </reg>
      <reg name="rx_err_stat" protect="rw">
        <comment></comment>
        <bits access="r" name="frame_num" pos="31:28" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="ts_cnt" pos="27:12" rst="0x0">
          <comment>TS</comment>
        </bits>
        <bits access="r" name="ofdm_num_rx" pos="11:8" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="ad_on" pos="5" rst="0x0">
          <comment>AD_ON</comment>
        </bits>
        <bits access="r" name="rx_running" pos="4" rst="0x0">
          <comment>01</comment>
        </bits>
        <bits access="r" name="dlfft_mem_sel" pos="3" rst="0x0">
          <comment>mem</comment>
        </bits>
        <bits access="r" name="pingpang_flag" pos="2" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="cp_type_rx" pos="1:0" rst="0x0">
          <comment>CP </comment>
        </bits>
      </reg>
      <reg name="tx_err_stat" protect="rw">
        <comment></comment>
        <bits access="r" name="frame_num" pos="31:28" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="ts_cnt" pos="27:12" rst="0x0">
          <comment>TS</comment>
        </bits>
        <bits access="r" name="ofdm_num_tx" pos="11:8" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="da_on" pos="6" rst="0x0">
          <comment>DA_ON</comment>
        </bits>
        <bits access="r" name="tx_running" pos="5" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="r" name="ram_pi_sel" pos="4" rst="0x0">
          <comment>PING RAM</comment>
        </bits>
        <bits access="r" name="dft_wr_pi_err" pos="3" rst="0x0">
          <comment>DFTPING</comment>
        </bits>
        <bits access="r" name="dft_wr_pa_err" pos="2" rst="0x0">
          <comment>DFTPANG</comment>
        </bits>
        <bits access="r" name="pi_empty_err" pos="1" rst="0x0">
          <comment>PING</comment>
        </bits>
        <bits access="r" name="pa_empty_err" pos="0" rst="0x0">
          <comment>PANG</comment>
        </bits>
      </reg>
      <reg name="st_cnt_framc" protect="rw">
        <comment>RFFRAMC</comment>
        <bits access="r" name="adon_pos_framc" pos="31:16" rst="0x0">
          <comment>ADONFRAMC</comment>
        </bits>
        <bits access="r" name="rf_1st_int_framc" pos="15:0" rst="0x0">
          <comment>FRAMC</comment>
        </bits>
      </reg>
      <reg name="st_cnt_ add" protect="rw">
        <comment>RFFRAMC</comment>
        <bits access="r" name="rf_int_num" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="rf_int_sub_add" pos="15:0" rst="0x0">
          <comment>FRAMC</comment>
        </bits>
      </reg>
      <reg name="ad_on_time" protect="rw">
        <comment>AD_ON</comment>
        <bits access="r" name="ad_on_neg_time1" pos="31:24" rst="0x0">
          <comment>AD_ON</comment>
        </bits>
        <bits access="r" name="ad_on_pos_time1" pos="23:16" rst="0x0">
          <comment>AD_ON</comment>
        </bits>
        <bits access="r" name="ad_on_neg_time0" pos="15:8" rst="0x0">
          <comment>AD_ON</comment>
        </bits>
        <bits access="r" name="ad_on_pos_time0" pos="7:0" rst="0x0">
          <comment>AD_ON</comment>
        </bits>
      </reg>
      <reg name="da_on_time" protect="rw">
        <comment>DA_ON</comment>
        <bits access="r" name="da_on_neg_time1" pos="31:24" rst="0x0">
          <comment>DA_ON</comment>
        </bits>
        <bits access="r" name="da_on_pos_time1" pos="23:16" rst="0x0">
          <comment>DA_ON</comment>
        </bits>
        <bits access="r" name="da_on_neg_time0" pos="15:8" rst="0x0">
          <comment>DA_ON</comment>
        </bits>
        <bits access="r" name="da_on_pos_time0" pos="7:0" rst="0x0">
          <comment>DA_ON</comment>
        </bits>
      </reg>
      <reg name="fftbuf1_time" protect="rw">
        <comment>FFTBUF1</comment>
        <bits access="r" name="fftbuf1_time4" pos="31:24" rst="0x0">
          <comment>4FFTBUF1</comment>
        </bits>
        <bits access="r" name="fftbuf1_time3" pos="23:16" rst="0x0">
          <comment>3FFTBUF1</comment>
        </bits>
        <bits access="r" name="fftbuf1_time2" pos="15:8" rst="0x0">
          <comment>2FFTBUF1</comment>
        </bits>
        <bits access="r" name="fftbuf1_time1" pos="7:0" rst="0x0">
          <comment>1FFTBUF1</comment>
        </bits>
      </reg>
      <reg name="fftbuf2_time" protect="rw">
        <comment>FFTBUF2</comment>
        <bits access="r" name="fftbuf2_time4" pos="31:24" rst="0x0">
          <comment>4FFTBUF2</comment>
        </bits>
        <bits access="r" name="fftbuf2_time3" pos="23:16" rst="0x0">
          <comment>3FFTBUF2</comment>
        </bits>
        <bits access="r" name="fftbuf2_time2" pos="15:8" rst="0x0">
          <comment>2FFTBUF2</comment>
        </bits>
        <bits access="r" name="fftbuf2_time1" pos="7:0" rst="0x0">
          <comment>1FFTBUF2</comment>
        </bits>
      </reg>
      <reg name="fft2ldtc_time" protect="rw">
        <comment>FFT2LDTC</comment>
        <bits access="r" name="fft2ldtc_time4" pos="31:24" rst="0x0">
          <comment>4FFT2LDTC</comment>
        </bits>
        <bits access="r" name="fft2ldtc_time3" pos="23:16" rst="0x0">
          <comment>3FFT2LDTC</comment>
        </bits>
        <bits access="r" name="fft2ldtc_time2" pos="15:8" rst="0x0">
          <comment>2FFT2LDTC</comment>
        </bits>
        <bits access="r" name="fft2ldtc_time1" pos="7:0" rst="0x0">
          <comment>1FFT2LDTC</comment>
        </bits>
      </reg>
      <reg name="tx_fir3_coe1_cfg" protect="rw">
        <comment>TX FIR3 </comment>
        <bits access="rw" name="tx_fir_coe_a21" pos="31:24" rst="0x0">
          <comment>A28bit</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a1" pos="23:12" rst="0x0">
          <comment>A1</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a0" pos="11:0" rst="0x0">
          <comment>A0</comment>
        </bits>
      </reg>
      <reg name="tx_fir3_coe2_cfg" protect="rw">
        <comment>TX FIR3 </comment>
        <bits access="rw" name="tx_fir_coe_a51" pos="31:28" rst="0x0">
          <comment>A54bit</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a4" pos="27:16" rst="0x0">
          <comment>A4</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a3" pos="15:4" rst="0x0">
          <comment>A3</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a22" pos="3:0" rst="0x0">
          <comment>A24bit</comment>
        </bits>
      </reg>
      <reg name="tx_fir3_coe3_cfg" protect="rw">
        <comment>TX FIR3 </comment>
        <bits access="rw" name="tx_fir_coe_a7" pos="31:20" rst="0x0">
          <comment>A7</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a6" pos="19:8" rst="0x0">
          <comment>A6</comment>
        </bits>
        <bits access="rw" name="tx_fir_coe_a52" pos="7:0" rst="0x0">
          <comment>A58bit</comment>
        </bits>
      </reg>
      <reg name="tx_fir3_cfg" protect="rw">
        <comment>TX FIR3 </comment>
        <bits access="rw" name="reg_samp_rate" pos="12:7" rst="0x0">
          <comment>FIR3</comment>
        </bits>
        <bits access="rw" name="reg_grp_delay" pos="6:2" rst="0x0">
          <comment>FIR3</comment>
        </bits>
        <bits access="rw" name="autock_en" pos="1" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="fir3_en" pos="0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="tx_vld_cnt_cfg" protect="rw">
        <comment>TX FIR3 </comment>
        <bits access="rw" name="tx_vld_cnt" pos="2:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <hole size="751616"/>
      <reg name="mem5" protect="rw">
        </reg>
      <hole size="32768"/>
      <reg name="mem3" protect="rw">
        <bits access="rw" name="mem3_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem3_2" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="mem4" protect="rw">
        <bits access="rw" name="mem4_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem4_2" pos="15:4" rst="0x0"/>
      </reg>
    </module>
    <instance address="0x18000000" name="TXRX" type="TXRX"/>
  </archive>
  <archive relative="measpwr.xml">
    <module category="System" name="MEASPWR">
      <reg name="measpwr_rxdata_ctrl1" protect="rw">
        <comment>MEASPWR1</comment>
        <bits access="rw" name="fdd_tdd" pos="31" rst="0x1">
          <comment>FDD_TDD
0FDD
1TDD</comment>
        </bits>
        <bits access="rw" name="rx_offset1" pos="18:0" rst="0x0">
          <comment>TXRXAD_ON
0~30720*10-110ms(AD ON)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_ctrl2" protect="rw">
        <comment>MEASPWR2</comment>
        <bits access="rw" name="rx_len" pos="15:0" rst="0x0">
          <comment>MEASPWR1~30720*6(6ms)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_val_ctrl" protect="rw">
        <comment>MEASPWR</comment>
        <bits access="w" name="invalid_flag" pos="20" rst="0x0">
          <comment>Offset2
0offset2
1offset2</comment>
        </bits>
        <bits access="rw" name="rx_offset2" pos="17:0" rst="0x0">
          <comment>MEASPWR 0~30720*6-1</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id1" protect="rw">
        <comment>MEASPWRID1</comment>
        <bits access="rw" name="rx_offset3_id1" pos="19:0" rst="0x0">
          <comment>ID1 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id2" protect="rw">
        <comment>MEASPWRID2</comment>
        <bits access="rw" name="rx_offset3_id2" pos="19:0" rst="0x0">
          <comment>ID2 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id3" protect="rw">
        <comment>MEASPWRID3</comment>
        <bits access="rw" name="rx_offset3_id3" pos="19:0" rst="0x0">
          <comment>s</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id4" protect="rw">
        <comment>MEASPWRID4</comment>
        <bits access="rw" name="rx_offset3_id4" pos="19:0" rst="0x0">
          <comment>ID4 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id5" protect="rw">
        <comment>MEASPWRID5</comment>
        <bits access="rw" name="rx_offset3_id5" pos="19:0" rst="0x0">
          <comment>ID5 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id6" protect="rw">
        <comment>MEASPWRID6</comment>
        <bits access="rw" name="rx_offset3_id6" pos="19:0" rst="0x0">
          <comment>ID6 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id7" protect="rw">
        <comment>MEASPWRID7</comment>
        <bits access="rw" name="rx_offset3_id7" pos="19:0" rst="0x0">
          <comment>ID7 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_rxdata_offset3_id8" protect="rw">
        <comment>MEASPWRID8</comment>
        <bits access="rw" name="rx_offset3_id8" pos="19:0" rst="0x0">
          <comment>ID8 (0~30720*10-1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_nb_offset4" protect="rw">
        <comment>MEASPWR NB OFSET4</comment>
        <bits access="rw" name="nb_offet4" pos="14:0" rst="0x0">
          <comment>Nboffset4</comment>
        </bits>
      </reg>
      <reg name="measpwr_total_subf" protect="rw">
        <comment>MEASPWR</comment>
        <bits access="rw" name="total_subf_num_id3_8" pos="20:12" rst="0x0">
          <comment>ID3~ID8
01
12
23

511:512</comment>
        </bits>
        <bits access="rw" name="total_subf_num_id1_2" pos="8:0" rst="0x0">
          <comment>ID1ID2
01
12
23

511:512</comment>
        </bits>
      </reg>
      <reg name="measpwr_ifft_para" protect="rw">
        <comment>IFFT</comment>
        <bits access="rw" name="ifft_cut7" pos="13:12" rst="0x0">
          <comment>IFFT
</comment>
        </bits>
        <bits access="rw" name="ifft_cut6" pos="11:10" rst="0x0">
          <comment>IFFT
</comment>
        </bits>
        <bits access="rw" name="ifft_cut5" pos="9:8" rst="0x0">
          <comment>IFFT
</comment>
        </bits>
        <bits access="rw" name="ifft_cut4" pos="7:6" rst="0x0">
          <comment>IFFT
</comment>
        </bits>
        <bits access="rw" name="ifft_cut3" pos="5:4" rst="0x0">
          <comment>IFFT
</comment>
        </bits>
        <bits access="rw" name="ifft_cut2" pos="3:2" rst="0x0">
          <comment>IFFT
</comment>
        </bits>
        <bits access="rw" name="ifft_cut1" pos="1:0" rst="0x0">
          <comment>IFFT
2b00:bit[25:14]
2b01:bit[26:15]
2b10:bit[27:16]
2b11:bit[28:17]</comment>
        </bits>
      </reg>
      <reg name="measpwr_ifft_gate" protect="rw">
        <comment>MEASPWR IFFT</comment>
        <bits access="rw" name="ifft_gate" pos="6:0" rst="0x0">
          <comment>IFFT</comment>
        </bits>
      </reg>
      <reg name="measpwr_int_en" protect="rw">
        <comment>MEASPWR</comment>
        <bits access="rw" name="id8_interrupt_enable" pos="31:28" rst="0x0">
          <comment>ID8 10
bit[28]
bit[29]
bit[30]AFC
bit[31]:agc_compare</comment>
        </bits>
        <bits access="rw" name="id7_interrupt_enable" pos="27:24" rst="0x0">
          <comment>ID7 10
bit[24]
bit[25]
bit[26]AFC
bit[27]:agc_compare</comment>
        </bits>
        <bits access="rw" name="id6_interrupt_enable" pos="23:20" rst="0x0">
          <comment>ID6 10
bit[20]
bit[21]
bit[22]AFC
bit[23]:agc_compare</comment>
        </bits>
        <bits access="rw" name="id5_interrupt_enable" pos="19:16" rst="0x0">
          <comment>ID5 10
bit[16]
bit[17]
bit[18]AFC
bit[19]:agc_compare</comment>
        </bits>
        <bits access="rw" name="id4_interrupt_enable" pos="15:12" rst="0x0">
          <comment>ID4 10
bit[12]
bit[13]
bit[14]AFC
bit[15]:agc_compare</comment>
        </bits>
        <bits access="rw" name="id3_interrupt_enable" pos="11:8" rst="0x0">
          <comment>ID3 10
bit[8]
bit[9]
bit[10]AFC
bit[11]:agc_compare</comment>
        </bits>
        <bits access="rw" name="id2_interrupt_enable" pos="7:4" rst="0x0">
          <comment>ID2 10
bit[4]
bit[5]
bit[6]AFC
bit[7]:agc_compare</comment>
        </bits>
        <bits access="rw" name="id1_interrupt_enable" pos="3:0" rst="0x0">
          <comment>ID1 10
bit[0]
bit[1]
bit[2]AFC
bit[3]:agc_compare</comment>
        </bits>
      </reg>
      <reg name="measpwr_int_sta" protect="rw">
        <comment>MEASPWR</comment>
        <bits access="rc" name="id8_interrupt_state" pos="31:28" rst="0x0">
          <comment>ID8 10
bit[28]
bit[29]
bit[30]AFC
bit[31]:agc_compare</comment>
        </bits>
        <bits access="rc" name="id7_interrupt_state" pos="27:24" rst="0x0">
          <comment>ID7 10
bit[24]
bit[25]
bit[26]AFC
bit[27]:agc_compare</comment>
        </bits>
        <bits access="rc" name="id6_interrupt_state" pos="23:20" rst="0x0">
          <comment>ID6 10
bit[20]
bit[21]
bit[22]AFC
bit[23]:agc_compare</comment>
        </bits>
        <bits access="rc" name="id5_interrupt_state" pos="19:16" rst="0x0">
          <comment>ID5 10
bit[16]
bit[17]
bit[18]AFC
bit[19]:agc_compare</comment>
        </bits>
        <bits access="rc" name="id4_interrupt_state" pos="15:12" rst="0x0">
          <comment>ID4 10
bit[12]
bit[13]
bit[14]AFC
bit[15]:agc_compare</comment>
        </bits>
        <bits access="rc" name="id3_interrupt_state" pos="11:8" rst="0x0">
          <comment>ID3 10
bit[8]
bit[9]
bit[10]AFC
bit[11]:agc_compare</comment>
        </bits>
        <bits access="rc" name="id2_interrupt_state" pos="7:4" rst="0x0">
          <comment>ID2 10
bit[4]
bit[5]
bit[6]AFC
bit[7]:agc_compare</comment>
        </bits>
        <bits access="rc" name="id1_interrupt_state" pos="3:0" rst="0x0">
          <comment>ID1 10
bit[0]
bit[1]
bit[2]AFC
bit[3]:agc_compare</comment>
        </bits>
      </reg>
      <reg name="measpwr_id1_id2_func_ctrl" protect="rw">
        <comment>ID1ID2MEASPWR</comment>
        <bits access="rw" name="id1_id2_trmsf_en" pos="8" rst="0x0">
          <comment>TRMS</comment>
        </bits>
        <bits access="rw" name="id1_id2_sigma_en" pos="7" rst="0x0">
          <comment>SIGMA</comment>
        </bits>
        <bits access="rw" name="id1_id2_doppler_en" pos="6" rst="0x0">
          <comment>DOPPLER</comment>
        </bits>
        <bits access="rw" name="id1_id2_sinr_en" pos="5" rst="0x0">
          <comment>SINR</comment>
        </bits>
        <bits access="rw" name="id1_id2_afc_com_en" pos="4" rst="0x0">
          <comment>AFC</comment>
        </bits>
        <bits access="rw" name="id1_id2_afc_hst_en" pos="3" rst="0x0">
          <comment>AFC</comment>
        </bits>
        <bits access="rw" name="id1_id2_trms_en" pos="2" rst="0x0">
          <comment>TRMS</comment>
        </bits>
        <bits access="rw" name="id1_id2_rsrp_en" pos="1" rst="0x0">
          <comment>RSRP</comment>
        </bits>
        <bits access="rw" name="id1_id2_irt_en" pos="0" rst="0x0">
          <comment>IRT</comment>
        </bits>
      </reg>
      <reg name="measpwr_id3_id8_func_ctrl" protect="rw">
        <comment>ID3~ID8MEASPWR</comment>
        <bits access="rw" name="id3_id8_trmsf_en" pos="8" rst="0x0">
          <comment>TRMS</comment>
        </bits>
        <bits access="rw" name="id3_id8_sigma_en" pos="7" rst="0x0">
          <comment>SIGMA</comment>
        </bits>
        <bits access="rw" name="id3_id8_doppler_en" pos="6" rst="0x0">
          <comment>DOPPLER</comment>
        </bits>
        <bits access="rw" name="id3_id8_sinr_en" pos="5" rst="0x0">
          <comment>SINR</comment>
        </bits>
        <bits access="rw" name="id3_id8_afc_com_en" pos="4" rst="0x0">
          <comment>AFC</comment>
        </bits>
        <bits access="rw" name="id3_id8_afc_hst_en" pos="3" rst="0x0">
          <comment>AFC</comment>
        </bits>
        <bits access="rw" name="id3_id8_trms_en" pos="2" rst="0x0">
          <comment>TRMS</comment>
        </bits>
        <bits access="rw" name="id3_id8_rsrp_en" pos="1" rst="0x0">
          <comment>RSRP</comment>
        </bits>
        <bits access="rw" name="id3_id8_irt_en" pos="0" rst="0x0">
          <comment>IRT</comment>
        </bits>
      </reg>
      <reg name="measpwr_agc_compare" protect="rw">
        <comment>MEASPWR AGC</comment>
        <bits access="rw" name="agc_compare" pos="9:0" rst="0x1ff">
          <comment>agcagcagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_nb_para" protect="rw">
        <comment>MEASPWR </comment>
        <bits access="rw" name="id38_nb_ind" pos="11:8" rst="0x0">
          <comment>ID3-80-15CATM</comment>
        </bits>
        <bits access="rw" name="id2_nb_ind" pos="7:4" rst="0x0">
          <comment>ID20-15CATM</comment>
        </bits>
        <bits access="rw" name="id1_nb_ind" pos="3:0" rst="0x0">
          <comment>ID10-15CATM</comment>
        </bits>
      </reg>
      <reg name="measpwr_band_para" protect="rw">
        <comment>MEASPWR ID2</comment>
        <bits access="rw" name="meas_bw_id38" pos="14:12" rst="0x0">
          <comment>ID3-8
01.4m
13m
25m
310m
415m
520m</comment>
        </bits>
        <bits access="rw" name="sys_bw_id38" pos="10:8" rst="0x0">
          <comment>ID3-8
01.4m
13m
25m
310m
415m
520m</comment>
        </bits>
        <bits access="rw" name="meas_bw_id12" pos="6:4" rst="0x0">
          <comment>ID1-2
01.4m
13m
25m
310m
415m
520m</comment>
        </bits>
        <bits access="rw" name="sys_bw_id12" pos="2:0" rst="0x0">
          <comment>ID1-2
01.4m
13m
25m
310m
415m
520m</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="measpwr_afc_para" protect="rw">
        <comment>AFC</comment>
        <bits access="rw" name="afc_factor" pos="23:8" rst="0x0">
          <comment>Afc_factor</comment>
        </bits>
        <bits access="rw" name="afc_related_flag" pos="4" rst="0x0">
          <comment>AFC
0
1
4</comment>
        </bits>
        <bits access="rw" name="afc_renum" pos="2:0" rst="0x0">
          <comment>AFC
0001
0012
0103
0114
1006
10112
Other:1</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect1" protect="rw">
        <comment>AFC</comment>
        <bits access="rw" name="afc_soft_fa_ctor1" pos="15:0" rst="0x0">
          <comment>ID1 AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigpwr_para" protect="rw">
        <comment>Sigpwr</comment>
        <bits access="rw" name="sigpwr_alpha" pos="28:12" rst="0x0">
          <comment>SIGPWR alpha</comment>
        </bits>
        <bits access="rw" name="sigpwr_ofdmnum" pos="9:8" rst="0x0">
          <comment>SIGPWR
001
012
114
Other1</comment>
        </bits>
        <bits access="rw" name="sigpwr_renum" pos="7:0" rst="0x0">
          <comment>ID1-2 SIGPWR(</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma_para" protect="rw">
        <comment>SIGMA</comment>
        <bits access="rw" name="sigma_alpha" pos="24:8" rst="0x0">
          <comment>SIGMA alpha</comment>
        </bits>
        <bits access="rw" name="sigma_win" pos="6:0" rst="0x0">
          <comment>SIGMA1~80</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler_para" protect="rw">
        <comment>DOPPLER</comment>
        <bits access="rw" name="doppler_alpha1" pos="29:13" rst="0x0">
          <comment>Id1-2 Doppler alpha</comment>
        </bits>
        <bits access="rw" name="doppler_scale" pos="11:8" rst="0x0">
          <comment>Doppler_scaleQ12</comment>
        </bits>
        <bits access="rw" name="doppler_win" pos="6:0" rst="0x0">
          <comment>DOPPLER1~80</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms_para1" protect="rw">
        <comment>TRMS1</comment>
        <bits access="rw" name="t_th" pos="23:16" rst="0x0">
          <comment>Trms8q0</comment>
        </bits>
        <bits access="rw" name="noise_sel" pos="12" rst="0x0">
          <comment>
0TRMSDis_Limit
1RSRPDis_Limit</comment>
        </bits>
        <bits access="rw" name="d_flag2" pos="9" rst="0x0">
          <comment>ID3-8:
0:1L_U16ExtractStepTab_true1
11L_U16ExtractStepTab_true</comment>
        </bits>
        <bits access="rw" name="d_flag" pos="8" rst="0x0">
          <comment>ID1-2:
0:1L_U16ExtractStepTab_true1
11L_U16ExtractStepTab_true</comment>
        </bits>
        <bits access="rw" name="dis_limit" pos="7:0" rst="0x0">
          <comment>(N2N+1)</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms_para2" protect="rw">
        <comment>TRMS2</comment>
        <bits access="rw" name="s_th" pos="31:16" rst="0x0">
          <comment>ID1-216q15</comment>
        </bits>
        <bits access="rw" name="n_th" pos="15:0" rst="0x0">
          <comment>ID1-216q10</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp_para1" protect="rw">
        <comment>RSRP1</comment>
        <bits access="rw" name="d_flag2" pos="25" rst="0x1">
          <comment>ID3-8</comment>
        </bits>
        <bits access="rw" name="d_flag" pos="24" rst="0x1">
          <comment>ID1-2</comment>
        </bits>
        <bits access="rw" name="beta" pos="23:8" rst="0x0">
          <comment>ID1-2beta16Q10</comment>
        </bits>
        <bits access="rw" name="dis_limit" pos="7:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp_para2" protect="rw">
        <comment>RSRP2</comment>
        <bits access="rw" name="mode1_compensate2" pos="25:17" rst="0x0">
          <comment>ID3-8RSRP</comment>
        </bits>
        <bits access="rw" name="mode1_compensate" pos="16:8" rst="0x0">
          <comment>ID1-2RSRP</comment>
        </bits>
        <bits access="rw" name="rsrp_agcadjust" pos="7:0" rst="0x0">
          <comment>L_S32RsrpdB_Temp = L_S32RsrpdB  - AGC_Base*16 - RSRPAgcAdjust*16 + L_U16DownSamplingCompensate*16</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp_para3" protect="rw">
        <comment>RSRP3</comment>
        <bits access="rw" name="s_th" pos="23:8" rst="0x0">
          <comment>ID1-2</comment>
        </bits>
        <bits access="rw" name="rssi_q" pos="6:0" rst="0x0">
          <comment>RSSI Q()</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp_para4" protect="rw">
        <comment>RSRP4</comment>
        <bits access="rw" name="powq_value" pos="15:8" rst="0x0">
          <comment>FFTIFFTQ</comment>
        </bits>
        <bits access="rw" name="pow_pa" pos="7:0" rst="0x0">
          <comment>FFTIFFT</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt_para1" protect="rw">
        <comment>IRT1</comment>
        <bits access="rw" name="val_sel" pos="20" rst="0x0">
          <comment>IRT
08910
1</comment>
        </bits>
        <bits access="rw" name="pow_max_num" pos="19:16" rst="0x0">
          <comment>pow</comment>
        </bits>
        <bits access="rw" name="n_scale" pos="15:12" rst="0x0">
          <comment>Scale</comment>
        </bits>
        <bits access="rw" name="dis_limit" pos="11:4" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="irt_ofdm_num" pos="1:0" rst="0x0">
          <comment>IRT
001
012
114</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt_para2" protect="rw">
        <comment>IRT 2</comment>
        <bits access="rw" name="s_th" pos="31:16" rst="0x0">
          <comment>ID1-2</comment>
        </bits>
        <bits access="rw" name="n_th" pos="15:0" rst="0x0">
          <comment>ID1-216q10</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt_scale_th1" protect="rw">
        <comment>IRT ID1-2 Scale1</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th2" protect="rw">
        <comment>IRT  ID1-2 Scale2</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th4" protect="rw">
        <comment>IRT  ID1-2 Scale4</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th8" protect="rw">
        <comment>IRT  ID1-2 Scale8</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th16" protect="rw">
        <comment>IRT  ID1-2 Scale16</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th32" protect="rw">
        <comment>IRT  ID1-2 Scale32</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th64" protect="rw">
        <comment>IRT  ID1-2 Scale64</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th128" protect="rw">
        <comment>IRT  ID1-2 Scale128</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th256" protect="rw">
        <comment>IRT  ID1-2 Scale256</comment>
      </reg>
      <reg name="measpwr_ irt_scale_th512" protect="rw">
        <comment>IRT  ID1-2 Scale512</comment>
      </reg>
      <reg name="measpwr_rssi_para" protect="rw">
        <comment>RSSI</comment>
        <bits access="rw" name="rssi_compensate2" pos="19:12" rst="0x0">
          <comment>ID3-8 Rssi</comment>
        </bits>
        <bits access="rw" name="rssi_compensate" pos="11:4" rst="0x0">
          <comment>ID1-2 Rssi</comment>
        </bits>
        <bits access="rw" name="rssi_sel" pos="0" rst="0x1">
          <comment>IDRSSI
0MEASPWROFDMRSSI
1MEASPWR</comment>
        </bits>
      </reg>
      <reg name="measpwr_agc" protect="rw">
        <comment>MEASPWRAGC</comment>
        <bits access="rw" name="agc_rx" pos="9:0" rst="0x0">
          <comment>AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_id1_para1" protect="rw">
        <comment>MEASPWR ID11</comment>
        <bits access="rw" name="lnum_mod" pos="31:28" rst="0x0">
          <comment>FFT
4`b0000
4`b0001
4`b0010
.</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="27:24" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="afc_out_num" pos="23:16" rst="0x0">
          <comment>AFC</comment>
        </bits>
        <bits access="rw" name="crs_rssi_sel" pos="15:14" rst="0x0">
          <comment>Crs_rssi
00
01
10
11reserved</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="13" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="nid" pos="12:4" rst="0x0">
          <comment>NID 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="3" rst="0x0">
          <comment>2port
0port 0 and port 1
1only port 1</comment>
        </bits>
        <bits access="rw" name="afc_out_sel" pos="2" rst="0x0">
          <comment>AFC
0IRT
1bit[8:1]</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="1" rst="0x0">
          <comment>
01
12</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="0" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
      </reg>
      <reg name="measpwr_id1_para2" protect="rw">
        <comment>MEASPWR ID12</comment>
        <bits access="rw" name="qf_mem_sel" pos="31" rst="0x0">
          <comment>Hmmse QF mem
0QF mem
1QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="30" rst="0x0">
          <comment>IRT scale
0
1</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="29:28" rst="0x0">
          <comment>AFC\POW
00hls
01hmmse
10freqfirst
11hls</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="26" rst="0x0">
          <comment>Crs_rssi</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="25:16" rst="0x0">
          <comment>bit[25:16]9-0</comment>
        </bits>
        <bits access="rw" name="offline0_step" pos="15:7" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="sinr_map" pos="6:4" rst="0x0">
          <comment>SINR
000NASINR
0011
0102
0113
1004
OtherNA</comment>
        </bits>
        <bits access="rw" name="afc_related_en" pos="3" rst="0x0">
          <comment>AFC
0
1</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>
0
1
1</comment>
        </bits>
      </reg>
      <reg name="measpwr_id2_para1" protect="rw">
        <comment>MEASPWR ID21</comment>
        <bits access="rw" name="lnum_mod" pos="31:28" rst="0x0">
          <comment>FFT
4`b0000
4`b0001
4`b0010
.</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="27:24" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="afc_out_num" pos="23:16" rst="0x0">
          <comment>AFC</comment>
        </bits>
        <bits access="rw" name="crs_rssi_sel" pos="15:14" rst="0x0">
          <comment>Crs_rssi
00
01
10
11reserved</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="13" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="nid" pos="12:4" rst="0x0">
          <comment>NID 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="3" rst="0x0">
          <comment>2port
0port 0 and port 1
1only port 1</comment>
        </bits>
        <bits access="rw" name="afc_out_sel" pos="2" rst="0x0">
          <comment>AFC
0IRT
1bit[8:1]</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="1" rst="0x0">
          <comment>
01
12</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="0" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
      </reg>
      <reg name="measpwr_id2_para2" protect="rw">
        <comment>MEASPWR ID22</comment>
        <bits access="rw" name="qf_mem_sel" pos="31" rst="0x0">
          <comment>Hmmse QF mem
0QF mem
1QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="30" rst="0x0">
          <comment>IRT scale
0
1</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="29:28" rst="0x0">
          <comment>AFC\POW
00hls
01hmmse
10freqfirst
11hls</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="26" rst="0x0">
          <comment>Crs_rssi</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="25:16" rst="0x0">
          <comment>bit[25:16]9-0</comment>
        </bits>
        <bits access="rw" name="offline0_step" pos="15:7" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="r" name="reserve2" pos="6:4" rst="0x0"/>
        <bits access="rw" name="afc_related_en" pos="3" rst="0x0">
          <comment>AFC
0
1</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>
0
1
1</comment>
        </bits>
      </reg>
      <reg name="measpwr_id3_para1" protect="rw">
        <comment>MEASPWR ID31</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT
4`b0000
4`b0001
4`b0010
.</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>2port
0port 0 and port 1
1only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>
01
12</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>
0
1
1</comment>
        </bits>
      </reg>
      <reg name="measpwr_id4_para1" protect="rw">
        <comment>MEASPWR ID41</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT
4`b0000
4`b0001
4`b0010
.</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>2port
0port 0 and port 1
1only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>
01
12</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>
0
1
1</comment>
        </bits>
      </reg>
      <reg name="measpwr_id5_para1" protect="rw">
        <comment>MEASPWR ID51</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT
4`b0000
4`b0001
4`b0010
.</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>2port
0port 0 and port 1
1only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>
01
12</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>
0
1
1</comment>
        </bits>
      </reg>
      <reg name="measpwr_id6_para1" protect="rw">
        <comment>MEASPWR ID61</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT
4`b0000
4`b0001
4`b0010
.</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>2port
0port 0 and port 1
1only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>
01
12</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>
0
1
1</comment>
        </bits>
      </reg>
      <reg name="measpwr_id7_para1" protect="rw">
        <comment>MEASPWR ID71</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT
4`b0000
4`b0001
4`b0010
.</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>2port
0port 0 and port 1
1only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>
01
12</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>
0
1
1</comment>
        </bits>
      </reg>
      <reg name="measpwr_id8_para1" protect="rw">
        <comment>MEASPWR ID81</comment>
        <bits access="rw" name="lnum_mod" pos="27:24" rst="0x0">
          <comment>FFT
4`b0000
4`b0001
4`b0010
.</comment>
        </bits>
        <bits access="rw" name="offline0_time" pos="23:20" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="firstd_ofdm_flag" pos="17" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="nid" pos="16:8" rst="0x0">
          <comment>NID 0~503</comment>
        </bits>
        <bits access="rw" name="tx_flag" pos="6" rst="0x0">
          <comment>2port
0port 0 and port 1
1only port 1</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="5" rst="0x0">
          <comment>
01
12</comment>
        </bits>
        <bits access="rw" name="cp_index" pos="4" rst="0x0">
          <comment>CP
0CP
1CP</comment>
        </bits>
        <bits access="rw" name="crs_rssi_clr" pos="3" rst="0x0">
          <comment>Crs_rssi</comment>
        </bits>
        <bits access="rw" name="last_flag" pos="2" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="windows_clr" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rw" name="restart" pos="0" rst="0x0">
          <comment>
0
1
1</comment>
        </bits>
      </reg>
      <reg name="measpwr_id_para" protect="rw">
        <comment>MEASPWR ID</comment>
        <bits access="rw" name="offline_mod_sel" pos="28" rst="0x0">
          <comment>Offline
00
11</comment>
        </bits>
        <bits access="rw" name="offlin_data_sel" pos="24" rst="0x0">
          <comment>offline
0
1</comment>
        </bits>
        <bits access="rw" name="nid12_info" pos="19:4" rst="0x0">
          <comment>NID1-2</comment>
        </bits>
        <bits access="rw" name="irt_soft_en" pos="3" rst="0x0">
          <comment>IRT
0
1</comment>
        </bits>
        <bits access="rw" name="afc_soft_en" pos="2" rst="0x0">
          <comment>AFC
0
1</comment>
        </bits>
        <bits access="rw" name="mode_sel" pos="1:0" rst="0x0">
          <comment>
0CATM
1CAT1
2NB
NB_LTEFFT</comment>
        </bits>
      </reg>
      <reg name="measpwr_id_ctrl" protect="rw">
        <comment>MEASPWR ID</comment>
        <bits access="rs" name="invalid_flag" pos="29" rst="0x0">
          <comment>NID_MAP
0
1</comment>
        </bits>
        <bits access="rs" name="nid38_info" pos="28:19" rst="0x0">
          <comment>NID3-8</comment>
        </bits>
        <bits access="rs" name="offline_sel" pos="8" rst="0x0">
          <comment>Offlineonline
0online
1offline</comment>
        </bits>
        <bits access="rs" name="nid8" pos="7" rst="0x0">
          <comment>ID1
0</comment>
        </bits>
        <bits access="rs" name="nid7" pos="6" rst="0x0">
          <comment>ID1
0</comment>
        </bits>
        <bits access="rs" name="nid6" pos="5" rst="0x0">
          <comment>ID1
0</comment>
        </bits>
        <bits access="rs" name="nid5" pos="4" rst="0x0">
          <comment>ID1
0</comment>
        </bits>
        <bits access="rs" name="nid4" pos="3" rst="0x0">
          <comment>ID1
0</comment>
        </bits>
        <bits access="rs" name="nid3" pos="2" rst="0x0">
          <comment>ID1
0</comment>
        </bits>
        <bits access="rs" name="nid2" pos="1" rst="0x0">
          <comment>ID1
0</comment>
        </bits>
        <bits access="rs" name="nid1" pos="0" rst="0x0">
          <comment>ID1
0</comment>
        </bits>
      </reg>
      <reg name="measpwr_ctrl" protect="rw">
        <comment>MEASPWR</comment>
        <bits access="rs" name="nid8_en" pos="7" rst="0x0">
          <comment>NID8</comment>
        </bits>
        <bits access="rs" name="nid7_en" pos="6" rst="0x0">
          <comment>NID7</comment>
        </bits>
        <bits access="rs" name="nid6_en" pos="5" rst="0x0">
          <comment>NID6</comment>
        </bits>
        <bits access="rs" name="nid5_en" pos="4" rst="0x0">
          <comment>NID5</comment>
        </bits>
        <bits access="rs" name="nid4_en" pos="3" rst="0x0">
          <comment>NID4</comment>
        </bits>
        <bits access="rs" name="nid3_en" pos="2" rst="0x0">
          <comment>NID3</comment>
        </bits>
        <bits access="rs" name="nid2_en" pos="1" rst="0x0">
          <comment>NID2</comment>
        </bits>
        <bits access="rs" name="nid1_en" pos="0" rst="0x0">
          <comment>NID1</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc1_out" protect="rw">
        <comment>ID1 AFC</comment>
        <bits access="r" name="afc_out1" pos="15:0" rst="0x0">
          <comment>AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc2_out" protect="rw">
        <comment>ID2 AFC</comment>
        <bits access="r" name="afc_out2" pos="15:0" rst="0x0">
          <comment>AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc3_out" protect="rw">
        <comment>ID3 AFC</comment>
        <bits access="r" name="afc_out3" pos="15:0" rst="0x0">
          <comment>AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc4_out" protect="rw">
        <comment>ID4 AFC</comment>
        <bits access="r" name="afc_out4" pos="15:0" rst="0x0">
          <comment>AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc5_out" protect="rw">
        <comment>ID5 AFC</comment>
        <bits access="r" name="afc_out5" pos="15:0" rst="0x0">
          <comment>AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc1_rsrp" protect="rw">
        <comment>ID1AFCRSRP db</comment>
        <bits access="r" name="afc_rsrp1" pos="15:0" rst="0x0">
          <comment>AFCRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc2_rsrp" protect="rw">
        <comment>ID2AFCRSRP db</comment>
        <bits access="r" name="afc_rsrp2" pos="15:0" rst="0x0">
          <comment>AFCRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc3_rsrp" protect="rw">
        <comment>ID3AFCRSRP db</comment>
        <bits access="r" name="afc_rsrp3" pos="15:0" rst="0x0">
          <comment>AFCRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc4_rsrp" protect="rw">
        <comment>ID4AFCRSRP db</comment>
        <bits access="r" name="afc_rsrp4" pos="15:0" rst="0x0">
          <comment>AFCRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc5_rsrp" protect="rw">
        <comment>ID5AFCRSRP db</comment>
        <bits access="r" name="afc_rsrp5" pos="15:0" rst="0x0">
          <comment>AFCRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigpwr1_out1" protect="rw">
        <comment>1 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr1_out2" protect="rw">
        <comment>2 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr1_out3" protect="rw">
        <comment>3 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr1_out4" protect="rw">
        <comment>4 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr1_out5" protect="rw">
        <comment>5 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr1_out6" protect="rw">
        <comment>6 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr2_ out" protect="rw">
        <comment>ID2 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr3_ out" protect="rw">
        <comment>ID3 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr4_out4" protect="rw">
        <comment>ID4 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr5_out5" protect="rw">
        <comment>ID5 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigma1_out1" protect="rw">
        <comment>1 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out1" protect="rw">
        <comment>1AGC</comment>
        <bits access="r" name="sinr1_log_out1" pos="26:16" rst="0x0">
          <comment>1SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc1_out1" pos="9:0" rst="0x0">
          <comment>1SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma1_out2" protect="rw">
        <comment>2 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out2" protect="rw">
        <comment>2AGC</comment>
        <bits access="r" name="sinr1_log_out2" pos="26:16" rst="0x0">
          <comment>2SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc1_out2" pos="9:0" rst="0x0">
          <comment>2SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma1_out3" protect="rw">
        <comment>3 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out3" protect="rw">
        <comment>3AGC</comment>
        <bits access="r" name="sinr1_log_out3" pos="26:16" rst="0x0">
          <comment>3SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc1_out3" pos="9:0" rst="0x0">
          <comment>3SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma1_out4" protect="rw">
        <comment>4 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out4" protect="rw">
        <comment>4AGC</comment>
        <bits access="r" name="sinr1_log_out4" pos="26:16" rst="0x0">
          <comment>4SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc1_out4" pos="9:0" rst="0x0">
          <comment>4SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma1_out5" protect="rw">
        <comment>SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out5" protect="rw">
        <comment>AGC</comment>
        <bits access="r" name="sinr1_log_out5" pos="26:16" rst="0x0">
          <comment>5SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc1_out5" pos="9:0" rst="0x0">
          <comment>SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma1_out6" protect="rw">
        <comment>ID1 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma1_agc_out6" protect="rw">
        <comment>ID1AGC</comment>
        <bits access="r" name="sinr1_log_out6" pos="26:16" rst="0x0">
          <comment>6SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc1_out6" pos="9:0" rst="0x0">
          <comment>ID1SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma2_out" protect="rw">
        <comment>ID2 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma2_agc_out" protect="rw">
        <comment>ID2AGC</comment>
        <bits access="r" name="sinr2_log_out" pos="26:16" rst="0x0">
          <comment>ID2SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc2_out" pos="9:0" rst="0x0">
          <comment>ID2SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma3_out" protect="rw">
        <comment>ID3 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma3_agc_out" protect="rw">
        <comment>ID3AGC</comment>
        <bits access="r" name="sinr3_log_out" pos="26:16" rst="0x0">
          <comment>ID3SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc3_out" pos="9:0" rst="0x0">
          <comment>ID3SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma4_out" protect="rw">
        <comment>ID4 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma4_agc_out" protect="rw">
        <comment>ID4AGC</comment>
        <bits access="r" name="sinr4_log_out" pos="26:16" rst="0x0">
          <comment>ID4SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc4_out" pos="9:0" rst="0x0">
          <comment>ID4SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma5_out" protect="rw">
        <comment>ID5 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma5_agc_out" protect="rw">
        <comment>ID5AGC</comment>
        <bits access="r" name="sinr5_log_out" pos="26:16" rst="0x0">
          <comment>ID5SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc5_out" pos="9:0" rst="0x0">
          <comment>ID5SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sinr1_out1" protect="rw">
        <comment>1SINR</comment>
      </reg>
      <reg name="measpwr_sinr1_out2" protect="rw">
        <comment>2SINR</comment>
      </reg>
      <reg name="measpwr_sinr1_out3" protect="rw">
        <comment>3SINR</comment>
      </reg>
      <reg name="measpwr_sinr1_out4" protect="rw">
        <comment>4SINR</comment>
      </reg>
      <reg name="measpwr_sinr1_out5" protect="rw">
        <comment>SINR</comment>
      </reg>
      <reg name="measpwr_sinr1_out6" protect="rw">
        <comment>ID1SINR</comment>
      </reg>
      <reg name="measpwr_sinr2_out" protect="rw">
        <comment>ID2SINR</comment>
      </reg>
      <reg name="measpwr_sinr3_out" protect="rw">
        <comment>ID3SINR</comment>
      </reg>
      <reg name="measpwr_sinr4_out" protect="rw">
        <comment>ID4SINR</comment>
      </reg>
      <reg name="measpwr_sinr5_out" protect="rw">
        <comment>ID5SINR</comment>
      </reg>
      <reg name="measpwr_ doppler1_out" protect="rw">
        <comment>ID1 DOPPLER</comment>
        <bits access="r" name="hls_agc_base1" pos="25:16" rst="0x0">
          <comment>hls_agc_base</comment>
        </bits>
        <bits access="r" name="doppler1_out" pos="10:0" rst="0x0">
          <comment>DOPPLER</comment>
        </bits>
      </reg>
      <reg name="measpwr_ doppler2_out" protect="rw">
        <comment>ID1 DOPPLER</comment>
        <bits access="r" name="hls_agc_base2" pos="25:16" rst="0x0">
          <comment>hls_agc_base</comment>
        </bits>
        <bits access="r" name="doppler2_out" pos="10:0" rst="0x0">
          <comment>DOPPLER</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp1_out" protect="rw">
        <comment>RSRP</comment>
      </reg>
      <reg name="measpwr_rsrp1_db" protect="rw">
        <comment>RSRP</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRPdB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp1_scale" protect="rw">
        <comment>RSRP Scale</comment>
      </reg>
      <reg name="measpwr_rsrp1_scale_db" protect="rw">
        <comment>RSRP ScaledB</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>ScaledB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq1_db" protect="rw">
        <comment>RSRP RSRQdB</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi1_out" protect="rw">
        <comment>RSRP RSSI</comment>
      </reg>
      <reg name="measpwr_rssi1_db" protect="rw">
        <comment>RSRP RSSIdB</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSIdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp2_out" protect="rw">
        <comment>RSRP</comment>
      </reg>
      <reg name="measpwr_rsrp2_db" protect="rw">
        <comment>RSRP</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRPdB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp2_scale" protect="rw">
        <comment>RSRP Scale</comment>
      </reg>
      <reg name="measpwr_rsrp2_scale_db" protect="rw">
        <comment>RSRP ScaledB</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>ScaledB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq2_db" protect="rw">
        <comment>RSRP RSRQdB</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi2_out" protect="rw">
        <comment>RSRP RSSI</comment>
      </reg>
      <reg name="measpwr_rssi2_db" protect="rw">
        <comment>RSRP RSSIdB</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSIdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp3_out" protect="rw">
        <comment>RSRP</comment>
      </reg>
      <reg name="measpwr_rsrp3_db" protect="rw">
        <comment>RSRP</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRPdB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp3_scale" protect="rw">
        <comment>RSRP Scale</comment>
      </reg>
      <reg name="measpwr_rsrp3_scale_db" protect="rw">
        <comment>RSRP ScaledB</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>ScaledB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq3_db" protect="rw">
        <comment>RSRP RSRQdB</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi3_out" protect="rw">
        <comment>RSRP RSSI</comment>
      </reg>
      <reg name="measpwr_rssi3_db" protect="rw">
        <comment>RSRP RSSIdB</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSIdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp4_out" protect="rw">
        <comment>RSRP</comment>
      </reg>
      <reg name="measpwr_rsrp4_db" protect="rw">
        <comment>RSRP</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRPdB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp4_scale" protect="rw">
        <comment>RSRP Scale</comment>
      </reg>
      <reg name="measpwr_rsrp4_scale_db" protect="rw">
        <comment>RSRP ScaledB</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>ScaledB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq4_db" protect="rw">
        <comment>RSRP RSRQdB</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi4_out" protect="rw">
        <comment>RSRP RSSI</comment>
      </reg>
      <reg name="measpwr_rssi4_db" protect="rw">
        <comment>RSRP RSSIdB</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSIdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp5_out" protect="rw">
        <comment>RSRP</comment>
      </reg>
      <reg name="measpwr_rsrp5_db" protect="rw">
        <comment>RSRP</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRPdB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp5_scale" protect="rw">
        <comment>RSRP Scale</comment>
      </reg>
      <reg name="measpwr_rsrp5_scale_db" protect="rw">
        <comment>RSRP ScaledB</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>ScaledB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq5_db" protect="rw">
        <comment>RSRP RSRQdB</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi5_out" protect="rw">
        <comment>RSRP RSSI</comment>
      </reg>
      <reg name="measpwr_rssi5_db" protect="rw">
        <comment>RSRP RSSIdB</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSIdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp6_out" protect="rw">
        <comment>RSRP</comment>
      </reg>
      <reg name="measpwr_rsrp6_db" protect="rw">
        <comment>RSRP</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRPdB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp6_scale" protect="rw">
        <comment>RSRP Scale</comment>
      </reg>
      <reg name="measpwr_rsrp6_scale_db" protect="rw">
        <comment>RSRP ScaledB</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>ScaledB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq6_db" protect="rw">
        <comment>RSRP RSRQdB</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi6_out" protect="rw">
        <comment>RSRP RSSI</comment>
      </reg>
      <reg name="measpwr_rssi6_db" protect="rw">
        <comment>RSRP RSSIdB</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSIdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp7_out" protect="rw">
        <comment>RSRP</comment>
      </reg>
      <reg name="measpwr_rsrp7_db" protect="rw">
        <comment>RSRP</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRPdB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp7_scale" protect="rw">
        <comment>RSRP Scale</comment>
      </reg>
      <reg name="measpwr_rsrp7_scale_db" protect="rw">
        <comment>RSRP ScaledB</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>ScaledB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq7_db" protect="rw">
        <comment>RSRP RSRQdB</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi7_out" protect="rw">
        <comment>RSRP RSSI</comment>
      </reg>
      <reg name="measpwr_rssi7_db" protect="rw">
        <comment>RSRP RSSIdB</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSIdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp8_out" protect="rw">
        <comment>RSRP</comment>
      </reg>
      <reg name="measpwr_rsrp8_db" protect="rw">
        <comment>RSRP</comment>
        <bits access="r" name="rsrp_pwr_db" pos="15:0" rst="0x0">
          <comment>RSRPdB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp8_scale" protect="rw">
        <comment>RSRP Scale</comment>
      </reg>
      <reg name="measpwr_rsrp8_scale_db" protect="rw">
        <comment>RSRP ScaledB</comment>
        <bits access="rw" name="scale_rsrp_db" pos="15:0" rst="0x0">
          <comment>ScaledB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrq8_db" protect="rw">
        <comment>RSRP RSRQdB</comment>
        <bits access="r" name="rsrq_db" pos="15:0" rst="0x0">
          <comment>RSRQdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_rssi8_out" protect="rw">
        <comment>RSRP RSSI</comment>
      </reg>
      <reg name="measpwr_rssi8_db" protect="rw">
        <comment>RSRP RSSIdB</comment>
        <bits access="r" name="rssi_db" pos="15:0" rst="0x0">
          <comment>RSSIdBOFDM</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt1_delay" protect="rw">
        <comment>IRTdelay</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt1outflag" protect="rw">
        <comment>IRT scale</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale
1
0</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt1_scale" protect="rw">
        <comment>IRTScale</comment>
      </reg>
      <reg name="measpwr_irt2_delay" protect="rw">
        <comment>IRTdelay</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt2outflag" protect="rw">
        <comment>IRT scale</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale
1
0</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt2_scale" protect="rw">
        <comment>IRTScale</comment>
      </reg>
      <reg name="measpwr_irt3_delay" protect="rw">
        <comment>IRTdelay</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt3outflag" protect="rw">
        <comment>IRT scale</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale
1
0</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt3_scale" protect="rw">
        <comment>IRTScale</comment>
      </reg>
      <reg name="measpwr_irt4_delay" protect="rw">
        <comment>IRTdelay</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt4outflag" protect="rw">
        <comment>IRT scale</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale
1
0</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt4_scale" protect="rw">
        <comment>IRTScale</comment>
      </reg>
      <reg name="measpwr_irt5_delay" protect="rw">
        <comment>IRTdelay</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt5outflag" protect="rw">
        <comment>IRT scale</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale
1
0</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt5_scale" protect="rw">
        <comment>IRTScale</comment>
      </reg>
      <reg name="measpwr_irt6_delay" protect="rw">
        <comment>IRTdelay</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt6outflag" protect="rw">
        <comment>IRT scale</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale
1
0</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt6_scale" protect="rw">
        <comment>IRTScale</comment>
      </reg>
      <reg name="measpwr_irt7_delay" protect="rw">
        <comment>IRTdelay</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt7outflag" protect="rw">
        <comment>IRT scale</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale
1
0</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt7_scale" protect="rw">
        <comment>IRTScale</comment>
      </reg>
      <reg name="measpwr_irt8_delay" protect="rw">
        <comment>IRTdelay</comment>
        <bits access="r" name="irt_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt8outflag" protect="rw">
        <comment>IRT scale</comment>
        <bits access="r" name="irt_validflag" pos="12" rst="0x0">
          <comment>Irt_scale
1
0</comment>
        </bits>
        <bits access="r" name="subf_num" pos="8:0" rst="0x0">
          <comment>IRTscale</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt8_scale" protect="rw">
        <comment>IRTScale</comment>
      </reg>
      <reg name="measpwr_trms1_out" protect="rw">
        <comment>ID1 TRMSScale</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_trms2_out" protect="rw">
        <comment>ID1 TRMSScale</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_id_info" protect="rw">
        <comment>ID1</comment>
        <bits access="r" name="id2_info" pos="31:16" rst="0x0">
          <comment>ID2</comment>
        </bits>
        <bits access="r" name="id1_info" pos="15:0" rst="0x0">
          <comment>ID1</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_para" protect="rw">
        <comment>RBIS</comment>
        <bits access="rw" name="rbis_correct" pos="29" rst="0x0">
          <comment>ID1-2 RBIS CORRECT
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_judge" pos="28" rst="0x0">
          <comment>ID1-2 RBIS JUDGE
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_en" pos="27" rst="0x0">
          <comment>ID1-2 RBIS
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_posen" pos="26" rst="0x0">
          <comment>ID1-2 RBIS
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_num" pos="25:23" rst="0x0">
          <comment>ID1-2 RBIS
01
12
23
34
45</comment>
        </bits>
        <bits access="rw" name="rbis_dipos" pos="22:16" rst="0x0">
          <comment>ID1-2 RBIS</comment>
        </bits>
        <bits access="rw" name="rbis_factor" pos="15:0" rst="0x0">
          <comment>ID1-2 RBIS</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_out1" protect="rw">
        <comment>RBIS ID1 1</comment>
        <bits access="r" name="rbis_out3" pos="30:24" rst="0x0">
          <comment>ID14RBIPRB</comment>
        </bits>
        <bits access="r" name="rbis_out2" pos="22:16" rst="0x0">
          <comment>ID13RBIPRB</comment>
        </bits>
        <bits access="r" name="rbis_out1" pos="14:8" rst="0x0">
          <comment>ID12RBIPRB</comment>
        </bits>
        <bits access="r" name="rbis_out0" pos="6:0" rst="0x0">
          <comment>ID11RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_out2" protect="rw">
        <comment>RBIS ID12</comment>
        <bits access="r" name="rbis_num" pos="10:8" rst="0x0">
          <comment>ID1 RBIS JUDGE</comment>
        </bits>
        <bits access="r" name="rbis_out4" pos="6:0" rst="0x0">
          <comment>ID15RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_ave" protect="rw">
        <comment>RBIS ID1 AVE</comment>
      </reg>
      <reg name="measpwr_rbis_max" protect="rw">
        <comment>RBIS ID1 MAX</comment>
        <bits access="r" name="rbis_max" pos="24:0" rst="0x0">
          <comment>ID1 RBIS</comment>
        </bits>
      </reg>
      <reg name="measpwr_rx_irt" protect="rw">
        <comment>RX_IRT</comment>
        <bits access="r" name="id2_offset4" pos="30:21" rst="0x0">
          <comment>ID2 offset4</comment>
        </bits>
        <bits access="r" name="id2_rx_irt" pos="20:16" rst="0x0">
          <comment>ID2 RX IRT</comment>
        </bits>
        <bits access="r" name="id1_offset4" pos="14:5" rst="0x0">
          <comment>ID1 offset4</comment>
        </bits>
        <bits access="r" name="id1_rx_irt" pos="4:0" rst="0x0">
          <comment>ID1 RX IRT</comment>
        </bits>
      </reg>
      <reg name="measpwr_debug1" protect="rw">
        <comment>DEBUG 1</comment>
        <bits access="r" name="debug_rev_flag" pos="23" rst="0x0">
          <comment>debug_rev_flag</comment>
        </bits>
        <bits access="r" name="debug_update_flag" pos="22" rst="0x0">
          <comment>debug_update_flag</comment>
        </bits>
        <bits access="r" name="id_update" pos="21" rst="0x0">
          <comment>id_update</comment>
        </bits>
        <bits access="r" name="offset2_update" pos="20" rst="0x0">
          <comment>offset2_update</comment>
        </bits>
        <bits access="r" name="din_id_sel" pos="18:16" rst="0x0">
          <comment>din_id_sel</comment>
        </bits>
        <bits access="r" name="datagen_state" pos="14:4" rst="0x0">
          <comment>datagen_state</comment>
        </bits>
        <bits access="r" name="datain_state" pos="2:0" rst="0x0">
          <comment>datain_state</comment>
        </bits>
      </reg>
      <reg name="measpwr_debug2" protect="rw">
        <comment>DEBUG 2</comment>
        <bits access="r" name="inmem_in_act" pos="31" rst="0x0">
          <comment>inmem_in_act</comment>
        </bits>
        <bits access="r" name="invalid_data_cont" pos="30:16" rst="0x0">
          <comment>invalid_data_cont</comment>
        </bits>
        <bits access="r" name="inmem_cont" pos="15:0" rst="0x0">
          <comment>inmem_cont</comment>
        </bits>
      </reg>
      <reg name="measpwr_debug3" protect="rw">
        <comment>DEBUG 3</comment>
        <bits access="r" name="datain_state_cur" pos="26:24" rst="0x0">
          <comment>datain_state_cur</comment>
        </bits>
        <bits access="r" name="func_id_sel" pos="22:20" rst="0x0">
          <comment>func_id_sel</comment>
        </bits>
        <bits access="r" name="pow_state" pos="16:12" rst="0x0">
          <comment>pow_state</comment>
        </bits>
        <bits access="r" name="func_state" pos="8:0" rst="0x0">
          <comment>func_state</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigpwr6_out" protect="rw">
        <comment>ID6 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr7_out" protect="rw">
        <comment>ID7 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr8_out" protect="rw">
        <comment>ID8 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigma6_out" protect="rw">
        <comment>ID6 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma6_agc_out" protect="rw">
        <comment>ID6AGC</comment>
        <bits access="r" name="sinr6_log_out" pos="26:16" rst="0x0">
          <comment>ID6SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc6_out" pos="9:0" rst="0x0">
          <comment>ID6SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma7_out" protect="rw">
        <comment>ID7 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma7_agc_out" protect="rw">
        <comment>ID7AGC</comment>
        <bits access="r" name="sinr7_log_out" pos="26:16" rst="0x0">
          <comment>ID7SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc7_out" pos="9:0" rst="0x0">
          <comment>ID7SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigma8_out" protect="rw">
        <comment>ID8 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma8_agc_out" protect="rw">
        <comment>ID8AGC</comment>
        <bits access="r" name="sinr8_log_out" pos="26:16" rst="0x0">
          <comment>ID8SINR LOG</comment>
        </bits>
        <bits access="r" name="baseagc8_out" pos="9:0" rst="0x0">
          <comment>ID8SIGMAAGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_sinr6_out" protect="rw">
        <comment>ID6SINR</comment>
      </reg>
      <reg name="measpwr_sinr7_out" protect="rw">
        <comment>ID7SINR</comment>
      </reg>
      <reg name="measpwr_sinr8_out" protect="rw">
        <comment>ID8SINR</comment>
      </reg>
      <reg name="measpwr_afc_soft_reect2" protect="rw">
        <comment>AFC</comment>
        <bits access="rw" name="afc_soft_fa_ctor2" pos="15:0" rst="0x0">
          <comment>ID2 AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect3" protect="rw">
        <comment>AFC</comment>
        <bits access="rw" name="afc_soft_fa_ctor3" pos="15:0" rst="0x0">
          <comment>ID3 AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect4" protect="rw">
        <comment>AFC</comment>
        <bits access="rw" name="afc_soft_fa_ctor4" pos="15:0" rst="0x0">
          <comment>ID4 AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect5" protect="rw">
        <comment>AFC</comment>
        <bits access="rw" name="afc_soft_fa_ctor5" pos="15:0" rst="0x0">
          <comment>ID5 AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect6" protect="rw">
        <comment>AFC</comment>
        <bits access="rw" name="afc_soft_fa_ctor6" pos="15:0" rst="0x0">
          <comment>ID6 AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect7" protect="rw">
        <comment>AFC</comment>
        <bits access="rw" name="afc_soft_fa_ctor7" pos="15:0" rst="0x0">
          <comment>ID7 AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc_soft_reect8" protect="rw">
        <comment>AFC</comment>
        <bits access="rw" name="afc_soft_fa_ctor8" pos="15:0" rst="0x0">
          <comment>ID8 AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler_para2" protect="rw">
        <comment>DOPPLER</comment>
        <bits access="rw" name="doppler_alpha2" pos="16:0" rst="0x0">
          <comment>Id3-8 Doppler alpha</comment>
        </bits>
      </reg>
      <reg name="measpwr_trmsf_para" protect="rw">
        <comment>TRMS</comment>
        <bits access="rw" name="trmsf_scale" pos="27:24" rst="0x0">
          <comment>trmsf_scale(Q12</comment>
        </bits>
        <bits access="rw" name="trmsf_space" pos="21:20" rst="0x0">
          <comment>TRMS</comment>
        </bits>
        <bits access="rw" name="trmsf_alpha" pos="16:0" rst="0x0">
          <comment>TRMS alpha</comment>
        </bits>
      </reg>
      <reg name="measpwr_id3_para2" protect="rw">
        <comment>MEASPWR ID32</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem
0QF mem
1QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale
0
1</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW
00hls
01hmmse
10freqfirst
11hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>bit[9:0]9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_id4_para2" protect="rw">
        <comment>MEASPWR ID42</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem
0QF mem
1QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale
0
1</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW
00hls
01hmmse
10freqfirst
11hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>bit[9:0]9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_id5_para2" protect="rw">
        <comment>MEASPWR ID52</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem
0QF mem
1QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale
0
1</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW
00hls
01hmmse
10freqfirst
11hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>bit[9:0]9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_id6_para2" protect="rw">
        <comment>MEASPWR ID62</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem
0QF mem
1QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale
0
1</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW
00hls
01hmmse
10freqfirst
11hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>bit[9:0]9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_id7_para2" protect="rw">
        <comment>MEASPWR ID72</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem
0QF mem
1QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale
0
1</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW
00hls
01hmmse
10freqfirst
11hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>bit[9:0]9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_id8_para2" protect="rw">
        <comment>MEASPWR ID82</comment>
        <bits access="rw" name="offline0_step" pos="24:16" rst="0x0">
          <comment>OFFLINE0</comment>
        </bits>
        <bits access="rw" name="qf_mem_sel" pos="15" rst="0x0">
          <comment>Hmmse QF mem
0QF mem
1QF mem</comment>
        </bits>
        <bits access="rw" name="irt_scale_disable" pos="14" rst="0x0">
          <comment>IRT scale
0
1</comment>
        </bits>
        <bits access="rw" name="pow_data_sel" pos="13:12" rst="0x0">
          <comment>AFC\POW
00hls
01hmmse
10freqfirst
11hls</comment>
        </bits>
        <bits access="rw" name="frame_map" pos="9:0" rst="0x0">
          <comment>bit[9:0]9-0</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc1_hst" protect="rw">
        <comment>ID1 AFC HST</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc2_hst" protect="rw">
        <comment>ID2 AFC HST</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc3_hst" protect="rw">
        <comment>ID3 AFC HST</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc4_hst" protect="rw">
        <comment>ID4 AFC HST</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc5_hst" protect="rw">
        <comment>ID5 AFC HST</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc6_hst" protect="rw">
        <comment>ID6 AFC HST</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc7_hst" protect="rw">
        <comment>ID7 AFC HST</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc8_hst" protect="rw">
        <comment>ID8 AFC HST</comment>
        <bits access="r" name="afc_hst" pos="15:0" rst="0x0">
          <comment>AFC HST</comment>
        </bits>
      </reg>
      <reg name="measpwr_sigpwr1_bef" protect="rw">
        <comment>ID1 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr2_bef" protect="rw">
        <comment>ID2 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr3_bef" protect="rw">
        <comment>ID3 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr4_bef" protect="rw">
        <comment>ID4 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr5_bef" protect="rw">
        <comment>ID5 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr6_bef" protect="rw">
        <comment>ID6 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr7_bef" protect="rw">
        <comment>ID7 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigpwr8_bef" protect="rw">
        <comment>ID8 SIGPWR</comment>
      </reg>
      <reg name="measpwr_sigma1_bef" protect="rw">
        <comment>ID1 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma2_bef" protect="rw">
        <comment>ID2 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma3_bef" protect="rw">
        <comment>ID3 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma4_bef" protect="rw">
        <comment>ID4 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma5_bef" protect="rw">
        <comment>ID5 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma6_bef" protect="rw">
        <comment>ID6 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma7_bef" protect="rw">
        <comment>ID7 SIGMA</comment>
      </reg>
      <reg name="measpwr_sigma8_bef" protect="rw">
        <comment>ID8 SIGMA</comment>
      </reg>
      <reg name="measpwr_doppler3_out" protect="rw">
        <comment>ID3 DOPPLER</comment>
        <bits access="r" name="hls_agc_base3" pos="25:16" rst="0x0">
          <comment>hls_agc_base</comment>
        </bits>
        <bits access="r" name="doppler3_out" pos="10:0" rst="0x0">
          <comment>DOPPLER</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler4_out" protect="rw">
        <comment>ID4 DOPPLER</comment>
        <bits access="r" name="hls_agc_base4" pos="25:16" rst="0x0">
          <comment>hls_agc_base</comment>
        </bits>
        <bits access="r" name="doppler4_out" pos="10:0" rst="0x0">
          <comment>DOPPLER</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler5_out" protect="rw">
        <comment>ID5 DOPPLER</comment>
        <bits access="r" name="hls_agc_base5" pos="25:16" rst="0x0">
          <comment>hls_agc_base</comment>
        </bits>
        <bits access="r" name="doppler5_out" pos="10:0" rst="0x0">
          <comment>DOPPLER</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler6_out" protect="rw">
        <comment>ID6 DOPPLER</comment>
        <bits access="r" name="hls_agc_base6" pos="25:16" rst="0x0">
          <comment>hls_agc_base</comment>
        </bits>
        <bits access="r" name="doppler6_out" pos="10:0" rst="0x0">
          <comment>DOPPLER</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler7_out" protect="rw">
        <comment>ID7 DOPPLER</comment>
        <bits access="r" name="hls_agc_base7" pos="25:16" rst="0x0">
          <comment>hls_agc_base</comment>
        </bits>
        <bits access="r" name="doppler7_out" pos="10:0" rst="0x0">
          <comment>DOPPLER</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler8_out" protect="rw">
        <comment>ID8 DOPPLER</comment>
        <bits access="r" name="hls_agc_base8" pos="25:16" rst="0x0">
          <comment>hls_agc_base</comment>
        </bits>
        <bits access="r" name="doppler8_out" pos="10:0" rst="0x0">
          <comment>DOPPLER</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler1_bef1" protect="rw">
        <comment>ID1 DOPPLER1</comment>
      </reg>
      <reg name="measpwr_doppler1_bef2" protect="rw">
        <comment>ID1 DOPPLER2</comment>
      </reg>
      <reg name="measpwr_doppler2_bef1" protect="rw">
        <comment>ID2 DOPPLER1</comment>
      </reg>
      <reg name="measpwr_doppler2_bef2" protect="rw">
        <comment>ID2 DOPPLER2</comment>
      </reg>
      <reg name="measpwr_trmsf1_out" protect="rw">
        <comment>ID1 TRMS</comment>
      </reg>
      <reg name="measpwr_trmsf2_out" protect="rw">
        <comment>ID2 TRMS</comment>
      </reg>
      <reg name="measpwr_trmsf3_out" protect="rw">
        <comment>ID3 TRMS</comment>
      </reg>
      <reg name="measpwr_trmsf4_out" protect="rw">
        <comment>ID4 TRMS</comment>
      </reg>
      <reg name="measpwr_trmsf5_out" protect="rw">
        <comment>ID5 TRMS</comment>
      </reg>
      <reg name="measpwr_trmsf6_out" protect="rw">
        <comment>ID6 TRMS</comment>
      </reg>
      <reg name="measpwr_trmsf7_out" protect="rw">
        <comment>ID7 TRMS</comment>
      </reg>
      <reg name="measpwr_trmsf8_out" protect="rw">
        <comment>ID8 TRMS</comment>
      </reg>
      <hole size="32"/>
      <reg name="measpwr_trmsf1_bef1" protect="rw">
        <comment>ID1 TRMSPART1</comment>
      </reg>
      <reg name="measpwr_trmsf1_bef2" protect="rw">
        <comment>ID1 TRMSPART2</comment>
      </reg>
      <reg name="measpwr_trmsf2_bef1" protect="rw">
        <comment>ID2 TRMSPART1</comment>
      </reg>
      <reg name="measpwr_trmsf2_bef2" protect="rw">
        <comment>ID2 TRMSPART2</comment>
      </reg>
      <reg name="measpwr_trmsf3_bef1" protect="rw">
        <comment>ID3 TRMSPART1</comment>
      </reg>
      <reg name="measpwr_trmsf3_bef2" protect="rw">
        <comment>ID3 TRMSPART2</comment>
      </reg>
      <reg name="measpwr_trmsf4_bef1" protect="rw">
        <comment>ID4 TRMSPART1</comment>
      </reg>
      <reg name="measpwr_trmsf4_bef2" protect="rw">
        <comment>ID4 TRMSPART2</comment>
      </reg>
      <reg name="measpwr_trmsf5_bef1" protect="rw">
        <comment>ID5 TRMSPART1</comment>
      </reg>
      <reg name="measpwr_trmsf5_bef2" protect="rw">
        <comment>ID5 TRMSPART2</comment>
      </reg>
      <reg name="measpwr_trmsf6_bef1" protect="rw">
        <comment>ID6 TRMSPART1</comment>
      </reg>
      <reg name="measpwr_trmsf6_bef2" protect="rw">
        <comment>ID6 TRMSPART2</comment>
      </reg>
      <reg name="measpwr_trmsf7_bef1" protect="rw">
        <comment>ID7 TRMSPART1</comment>
      </reg>
      <reg name="measpwr_trmsf7_bef2" protect="rw">
        <comment>ID7 TRMSPART2</comment>
      </reg>
      <reg name="measpwr_trmsf8_bef1" protect="rw">
        <comment>ID8 TRMSPART1</comment>
      </reg>
      <reg name="measpwr_trmsf8_bef2" protect="rw">
        <comment>ID8 TRMSPART2</comment>
      </reg>
      <reg name="measpwr_pow1_max" protect="rw">
        <comment>ID1 POW</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POWbit[23:0]</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_pow2_max" protect="rw">
        <comment>ID2 POW</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POWbit[23:0]</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_pow3_max" protect="rw">
        <comment>ID3 POW</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POWbit[23:0]</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_pow4_max" protect="rw">
        <comment>ID4 POW</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POWbit[23:0]</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_pow5_max" protect="rw">
        <comment>ID5 POW</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POWbit[23:0]</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_pow6_max" protect="rw">
        <comment>ID6 POW</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POWbit[23:0]</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_pow7_max" protect="rw">
        <comment>ID7 POW</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POWbit[23:0]</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_pow8_max" protect="rw">
        <comment>ID8 POW</comment>
        <bits access="r" name="pow_max" pos="31:7" rst="0x0">
          <comment>POWbit[23:0]</comment>
        </bits>
        <bits access="r" name="pow_max_addr" pos="6:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_trms3_out" protect="rw">
        <comment>ID3 TRMSScale</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_trms4_out" protect="rw">
        <comment>ID4 TRMSScale</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_trms5_out" protect="rw">
        <comment>ID5 TRMSScale</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_trms6_out" protect="rw">
        <comment>ID6 TRMSScale</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_trms7_out" protect="rw">
        <comment>ID7 TRMSScale</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_trms8_out" protect="rw">
        <comment>ID8 TRMSScale</comment>
        <bits access="r" name="trms_delay" pos="15:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="measpwr_reis_conf" protect="rw">
        <comment>REIS</comment>
        <bits access="rw" name="reis_dc_en" pos="5" rst="0x0">
          <comment>REIS_DC</comment>
        </bits>
        <bits access="rw" name="reis_en" pos="4" rst="0x0">
          <comment>REIS
0
1</comment>
        </bits>
        <bits access="rw" name="reis_num" pos="3:0" rst="0x0">
          <comment>REISNUM</comment>
        </bits>
      </reg>
      <reg name="measpwr_reis_pos0" protect="rw">
        <comment>REIS0</comment>
        <bits access="rw" name="reis_re1" pos="26:16" rst="0x0">
          <comment>REIS1RE20M1200RE</comment>
        </bits>
        <bits access="rw" name="reis_re0" pos="10:0" rst="0x0">
          <comment>REIS0RE20M1200RE</comment>
        </bits>
      </reg>
      <reg name="measpwr_reis_pos1" protect="rw">
        <comment>REIS1</comment>
        <bits access="rw" name="reis_re3" pos="26:16" rst="0x0">
          <comment>REIS3RE20M1200RE</comment>
        </bits>
        <bits access="rw" name="reis_re2" pos="10:0" rst="0x0">
          <comment>REIS2RE20M1200RE</comment>
        </bits>
      </reg>
      <reg name="measpwr_reis_pos2" protect="rw">
        <comment>REIS0</comment>
        <bits access="rw" name="reis_re5" pos="26:16" rst="0x0">
          <comment>REIS5RE20M1200RE</comment>
        </bits>
        <bits access="rw" name="reis_re4" pos="10:0" rst="0x0">
          <comment>REIS4RE20M1200RE</comment>
        </bits>
      </reg>
      <reg name="measpwr_reis_pos3" protect="rw">
        <comment>REIS0</comment>
        <bits access="rw" name="reis_re7" pos="26:16" rst="0x0">
          <comment>REIS7RE20M1200RE</comment>
        </bits>
        <bits access="rw" name="reis_re6" pos="10:0" rst="0x0">
          <comment>REIS6RE20M1200RE</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_sel" protect="rw">
        <comment>OFFLINE0</comment>
        <bits access="rw" name="pos_delay_sel" pos="8" rst="0x0">
          <comment>Pos\delay
0pos
1:delay</comment>
        </bits>
        <bits access="rw" name="jump_flag" pos="5:4" rst="0x0">
          <comment>
00IRT_Scale
01RSRP_Scale
10SINR
11POWMAX_Scale</comment>
        </bits>
        <bits access="rw" name="decision_flag" pos="1:0" rst="0x0">
          <comment>
00IRT_Scale
01Sigpwr
10SINR
11IRT_Scale</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_th" protect="rw">
        <comment>OFFLINE0</comment>
      </reg>
      <reg name="measpwr_offline0_pos" protect="rw">
        <comment>OFFLINE0</comment>
        <bits access="r" name="id8_max_position" pos="31:28" rst="0x0">
          <comment>Id8TBin</comment>
        </bits>
        <bits access="r" name="id7_max_position" pos="27:24" rst="0x0">
          <comment>Id7TBin</comment>
        </bits>
        <bits access="r" name="id6_max_position" pos="23:20" rst="0x0">
          <comment>Id6TBin</comment>
        </bits>
        <bits access="r" name="id5_max_position" pos="19:16" rst="0x0">
          <comment>Id5TBin</comment>
        </bits>
        <bits access="r" name="id4_max_position" pos="15:12" rst="0x0">
          <comment>Id4TBin</comment>
        </bits>
        <bits access="r" name="id3_max_position" pos="11:8" rst="0x0">
          <comment>Id3TBin</comment>
        </bits>
        <bits access="r" name="id2_max_position" pos="7:4" rst="0x0">
          <comment>Id2TBin</comment>
        </bits>
        <bits access="r" name="id1_max_position" pos="3:0" rst="0x0">
          <comment>Id1TBin</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_id" protect="rw">
        <comment>OFFLINE0</comment>
        <bits access="r" name="tbin_position_valid_flag" pos="11:4" rst="0x0">
          <comment>TbinID1~ID8
0
1</comment>
        </bits>
        <bits access="r" name="offline_jump_id" pos="3:0" rst="0xf">
          <comment>Offline
0xF</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_para" protect="rw">
        <comment>OFFLINE1</comment>
        <bits access="rw" name="first_ofdm" pos="12" rst="0x0">
          <comment>
00
143</comment>
        </bits>
        <bits access="rw" name="offline1_mod_sel" pos="9:8" rst="0x0">
          <comment>Offline1
000
0105
1050
1190</comment>
        </bits>
        <bits access="rw" name="offline1_num" pos="5" rst="0x0">
          <comment>Offline1
01
12</comment>
        </bits>
        <bits access="rw" name="offline1_time" pos="4:0" rst="0x0">
          <comment>Offline1</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc1" protect="rw">
        <comment>OFFLINE1AGC1</comment>
        <bits access="rw" name="offline1_agc3" pos="29:20" rst="0x0">
          <comment>3 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc2" pos="19:10" rst="0x0">
          <comment>2 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc1" pos="9:0" rst="0x0">
          <comment>1 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc2" protect="rw">
        <comment>OFFLINE1AGC2</comment>
        <bits access="rw" name="offline1_agc6" pos="29:20" rst="0x0">
          <comment>6 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc5" pos="19:10" rst="0x0">
          <comment>5 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc4" pos="9:0" rst="0x0">
          <comment>4 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc3" protect="rw">
        <comment>OFFLINE1AGC3</comment>
        <bits access="rw" name="offline1_agc9" pos="29:20" rst="0x0">
          <comment>9 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc8" pos="19:10" rst="0x0">
          <comment>8 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc7" pos="9:0" rst="0x0">
          <comment>7 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc4" protect="rw">
        <comment>OFFLINE1AGC4</comment>
        <bits access="rw" name="offline1_agc12" pos="29:20" rst="0x0">
          <comment>12 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc11" pos="19:10" rst="0x0">
          <comment>11 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc10" pos="9:0" rst="0x0">
          <comment>10 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc5" protect="rw">
        <comment>OFFLINE1AGC5</comment>
        <bits access="rw" name="offline1_agc15" pos="29:20" rst="0x0">
          <comment>15 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc14" pos="19:10" rst="0x0">
          <comment>14 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc13" pos="9:0" rst="0x0">
          <comment>13 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline1_agc6" protect="rw">
        <comment>OFFLINE1AGC6</comment>
        <bits access="rw" name="offline1_agc18" pos="29:20" rst="0x0">
          <comment>18 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc17" pos="19:10" rst="0x0">
          <comment>17 AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc16" pos="9:0" rst="0x0">
          <comment>16 AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi1_out1" protect="rw">
        <comment>ID1 CRS_RSSI1</comment>
      </reg>
      <reg name="measpwr_crs_rssi1_out2" protect="rw">
        <comment>ID1 CRS_RSSI2</comment>
      </reg>
      <reg name="measpwr_crs_rssi1_out3" protect="rw">
        <comment>ID1 CRS_RSSI3</comment>
      </reg>
      <reg name="measpwr_crs_rssi2_out1" protect="rw">
        <comment>ID2 CRS_RSSI1</comment>
      </reg>
      <reg name="measpwr_crs_rssi2_out2" protect="rw">
        <comment>ID2 CRS_RSSI2</comment>
      </reg>
      <reg name="measpwr_crs_rssi2_out3" protect="rw">
        <comment>ID2 CRS_RSSI3</comment>
      </reg>
      <hole size="32"/>
      <reg name="measpwr_crs_rssi3_out" protect="rw">
        <comment>ID3 CRS_RSSI</comment>
      </reg>
      <reg name="measpwr_crs_rssi4_out" protect="rw">
        <comment>ID4 CRS_RSSI</comment>
      </reg>
      <reg name="measpwr_crs_rssi5_out" protect="rw">
        <comment>ID5 CRS_RSSI</comment>
      </reg>
      <reg name="measpwr_crs_rssi6_out" protect="rw">
        <comment>ID6 CRS_RSSI</comment>
      </reg>
      <reg name="measpwr_crs_rssi7_out" protect="rw">
        <comment>ID7 CRS_RSSI</comment>
      </reg>
      <reg name="measpwr_crs_rssi8_out" protect="rw">
        <comment>ID8 CRS_RSSI</comment>
      </reg>
      <reg name="measpwr_crs_rssi1_agc1" protect="rw">
        <comment>ID1 CRS_RSSI1AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi1_agc2" protect="rw">
        <comment>ID1 CRS_RSSI2AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi1_agc3" protect="rw">
        <comment>ID1 CRS_RSSI3AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi2_agc1" protect="rw">
        <comment>ID2 CRS_RSSI1AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi2_agc2" protect="rw">
        <comment>ID2 CRS_RSSI2AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi2_agc3" protect="rw">
        <comment>ID2 CRS_RSSI3AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi3_agc" protect="rw">
        <comment>ID3 CRS_RSSI AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi4_agc" protect="rw">
        <comment>ID4 CRS_RSSI AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi5_agc" protect="rw">
        <comment>ID5 CRS_RSSI AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi6_agc" protect="rw">
        <comment>ID6 CRS_RSSI AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi7_agc" protect="rw">
        <comment>ID7 CRS_RSSI AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_crs_rssi8_agc" protect="rw">
        <comment>ID8 CRS_RSSI AGC</comment>
        <bits access="r" name="crs_rssi_agc" pos="9:0" rst="0x0">
          <comment>Crs rssiagc</comment>
        </bits>
      </reg>
      <reg name="measpwr_hmmse_win" protect="rw">
        <comment>HMMSE</comment>
        <bits access="rw" name="fh_wl_ind" pos="0" rst="0x0">
          <comment>
03PRB
16PRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_hmmse_bitsel" protect="rw">
        <comment>HMMSE</comment>
        <bits access="rw" name="fh_bitsel" pos="3:0" rst="0x6">
          <comment>13bit
0x029~17
0x128~16
0x227~15
0x326~14
0x425~13
0x524~12
0x623~11
0x722~10
0x821~9
0x920~8
0xa19~7
0xb18~6
0xc17~5
0xd16~4
0xe15~3
0xf14~2</comment>
        </bits>
      </reg>
      <reg name="measpwr_hmmse_flag" protect="rw">
        <comment>HMMSE QF MEM</comment>
        <bits access="r" name="used_wl_ind" pos="4" rst="0x0">
          <comment>USED_WL_IND</comment>
        </bits>
        <bits access="r" name="qf_mem_mark" pos="1:0" rst="0x0">
          <comment>QF MEM
00mem
01mem
Othermem</comment>
        </bits>
      </reg>
      <reg name="measpwr_id_info2" protect="rw">
        <comment>ID2</comment>
        <bits access="r" name="id38_info" pos="9:0" rst="0x0">
          <comment>ID38</comment>
        </bits>
      </reg>
      <reg name="measpwr_inmem_mode" protect="rw">
        <comment>INMEM</comment>
        <bits access="rw" name="inmem_mode" pos="1:0" rst="0x0">
          <comment>INMEM
00 measpwr
01OTDOA
10
11</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc1_rsrp_hst" protect="rw">
        <comment>ID1AFC HSTRSRP db</comment>
        <bits access="r" name="afc_rsrp1_hst" pos="15:0" rst="0x0">
          <comment>AFC HSTRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc2_rsrp_hst" protect="rw">
        <comment>ID2AFC HSTRSRP db</comment>
        <bits access="r" name="afc_rsrp2_hst" pos="15:0" rst="0x0">
          <comment>AFC HSTRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc3_rsrp_hst" protect="rw">
        <comment>ID3AFC HSTRSRP db</comment>
        <bits access="r" name="afc_rsrp3_hst" pos="15:0" rst="0x0">
          <comment>AFC HSTRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc4_rsrp_hst" protect="rw">
        <comment>ID4AFC HSTRSRP db</comment>
        <bits access="r" name="afc_rsrp4_hst" pos="15:0" rst="0x0">
          <comment>AFC HSTRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc5_rsrp_hst" protect="rw">
        <comment>ID5AFC HSTRSRP db</comment>
        <bits access="r" name="afc_rsrp5_hst" pos="15:0" rst="0x0">
          <comment>AFC HSTRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc6_rsrp_hst" protect="rw">
        <comment>ID6AFC HSTRSRP db</comment>
        <bits access="r" name="afc_rsrp6_hst" pos="15:0" rst="0x0">
          <comment>AFC HSTRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc7_rsrp_hst" protect="rw">
        <comment>ID7AFC HSTRSRP db</comment>
        <bits access="r" name="afc_rsrp7_hst" pos="15:0" rst="0x0">
          <comment>AFC HSTRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc8_rsrp_hst" protect="rw">
        <comment>ID8AFC HSTRSRP db</comment>
        <bits access="r" name="afc_rsrp8_hst" pos="15:0" rst="0x0">
          <comment>AFC HSTRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_powmax1_scale" protect="rw">
        <comment>ID1 POWMAX SCALE</comment>
      </reg>
      <reg name="measpwr_powmax2_scale" protect="rw">
        <comment>ID2 POWMAX SCALE</comment>
      </reg>
      <reg name="measpwr_powmax3_scale" protect="rw">
        <comment>ID3 POWMAX SCALE</comment>
      </reg>
      <reg name="measpwr_powmax4_scale" protect="rw">
        <comment>ID4 POWMAX SCALE</comment>
      </reg>
      <reg name="measpwr_powmax5_scale" protect="rw">
        <comment>ID5 POWMAX SCALE</comment>
      </reg>
      <reg name="measpwr_powmax6_scale" protect="rw">
        <comment>ID6 POWMAX SCALE</comment>
      </reg>
      <reg name="measpwr_powmax7_scale" protect="rw">
        <comment>ID7 POWMAX SCALE</comment>
      </reg>
      <reg name="measpwr_powmax8_scale" protect="rw">
        <comment>ID8 POWMAX SCALE</comment>
      </reg>
      <reg name="measpwr_afc6_out" protect="rw">
        <comment>ID6 AFC</comment>
        <bits access="r" name="afc_out6" pos="15:0" rst="0x0">
          <comment>AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc7_out" protect="rw">
        <comment>ID7 AFC</comment>
        <bits access="r" name="afc_out7" pos="15:0" rst="0x0">
          <comment>AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc8_out" protect="rw">
        <comment>ID8 AFC</comment>
        <bits access="r" name="afc_out8" pos="15:0" rst="0x0">
          <comment>AFC</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc6_rsrp" protect="rw">
        <comment>ID6AFCRSRP db</comment>
        <bits access="r" name="afc_rsrp6" pos="15:0" rst="0x0">
          <comment>AFCRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc7_rsrp" protect="rw">
        <comment>ID7AFCRSRP db</comment>
        <bits access="r" name="afc_rsrp7" pos="15:0" rst="0x0">
          <comment>AFCRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_afc8_rsrp" protect="rw">
        <comment>ID8AFCRSRP db</comment>
        <bits access="r" name="afc_rsrp8" pos="15:0" rst="0x0">
          <comment>AFCRSRP db</comment>
        </bits>
      </reg>
      <reg name="measpwr_doppler3_bef1" protect="rw">
        <comment>ID3 DOPPLER1</comment>
      </reg>
      <reg name="measpwr_doppler3_bef2" protect="rw">
        <comment>ID3 DOPPLER2</comment>
      </reg>
      <reg name="measpwr_doppler4_bef1" protect="rw">
        <comment>ID4 DOPPLER1</comment>
      </reg>
      <reg name="measpwr_doppler4_bef2" protect="rw">
        <comment>ID4 DOPPLER2</comment>
      </reg>
      <reg name="measpwr_doppler5_bef1" protect="rw">
        <comment>ID5 DOPPLER1</comment>
      </reg>
      <reg name="measpwr_doppler5_bef2" protect="rw">
        <comment>ID5 DOPPLER2</comment>
      </reg>
      <reg name="measpwr_doppler6_bef1" protect="rw">
        <comment>ID6 DOPPLER1</comment>
      </reg>
      <reg name="measpwr_doppler6_bef2" protect="rw">
        <comment>ID6 DOPPLER2</comment>
      </reg>
      <reg name="measpwr_doppler7_bef1" protect="rw">
        <comment>ID7 DOPPLER1</comment>
      </reg>
      <reg name="measpwr_doppler7_bef2" protect="rw">
        <comment>ID7 DOPPLER2</comment>
      </reg>
      <reg name="measpwr_doppler8_bef1" protect="rw">
        <comment>ID8 DOPPLER1</comment>
      </reg>
      <reg name="measpwr_doppler8_bef2" protect="rw">
        <comment>ID8 DOPPLER2</comment>
      </reg>
      <reg name="measpwr_offline1_agc7" protect="rw">
        <comment>OFFLINE1AGC7</comment>
        <bits access="rw" name="offline1_agc20" pos="19:10" rst="0x0">
          <comment>20AGC</comment>
        </bits>
        <bits access="rw" name="offline1_agc19" pos="9:0" rst="0x0">
          <comment>19AGC</comment>
        </bits>
      </reg>
      <reg name="measpwr_int_join" protect="rw">
        <comment>MEASPWR</comment>
        <bits access="rw" name="interrupt_join_flag" pos="7:0" rst="0x0">
          <comment>bit[7:0]id8-id1
0:
1</comment>
        </bits>
      </reg>
      <reg name="measpwr_int_mark" protect="rw">
        <comment>MEASPWR</comment>
        <bits access="r" name="id8_interrupt_mark" pos="31:28" rst="0x0">
          <comment>ID1</comment>
        </bits>
        <bits access="r" name="id7_interrupt_mark" pos="27:24" rst="0x0">
          <comment>ID1</comment>
        </bits>
        <bits access="r" name="id6_interrupt_mark" pos="23:20" rst="0x0">
          <comment>ID1</comment>
        </bits>
        <bits access="r" name="id5_interrupt_mark" pos="19:16" rst="0x0">
          <comment>ID1</comment>
        </bits>
        <bits access="r" name="id4_interrupt_mark" pos="15:12" rst="0x0">
          <comment>ID1</comment>
        </bits>
        <bits access="r" name="id3_interrupt_mark" pos="11:8" rst="0x0">
          <comment>ID1</comment>
        </bits>
        <bits access="r" name="id2_interrupt_mark" pos="7:4" rst="0x0">
          <comment>ID1</comment>
        </bits>
        <bits access="r" name="id1_interrupt_mark" pos="3:0" rst="0x0">
          <comment>ID110
bit[0]\offine
bit[1]
bit[2]AFC
bit[3]Agc_compare</comment>
        </bits>
      </reg>
      <reg name="measpwr_int_flag" protect="rw">
        <comment>MEASPWR</comment>
        <bits access="r" name="interrupt_flag" pos="7:0" rst="0x0">
          <comment>bit[7:0]id8-id1
0
1</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos1" protect="rw">
        <comment>OFFLINE01</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID13</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID12</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID11</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos2" protect="rw">
        <comment>OFFLINE02</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID23</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID22</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID21</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos3" protect="rw">
        <comment>OFFLINE03</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID33</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID32</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID31</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos4" protect="rw">
        <comment>OFFLINE04</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID43</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID42</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID41</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos5" protect="rw">
        <comment>OFFLINE05</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID53</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID52</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID51</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos6" protect="rw">
        <comment>OFFLINE06</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID63</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID62</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID61</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos7" protect="rw">
        <comment>OFFLINE07</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID73</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID72</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID71</comment>
        </bits>
      </reg>
      <reg name="measpwr_offline0_decpos8" protect="rw">
        <comment>OFFLINE08</comment>
        <bits access="rw" name="decision_position3" pos="26:18" rst="0x0">
          <comment>ID83</comment>
        </bits>
        <bits access="rw" name="decision_position2" pos="17:9" rst="0x0">
          <comment>ID82</comment>
        </bits>
        <bits access="rw" name="decision_position1" pos="8:0" rst="0x0">
          <comment>ID81</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_para2" protect="rw">
        <comment>RBIS2</comment>
        <bits access="rw" name="rbis_correct" pos="29" rst="0x0">
          <comment>ID3-8 RBIS CORRECT
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_judge" pos="28" rst="0x0">
          <comment>ID3-8 RBIS JUDGE
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_en" pos="27" rst="0x0">
          <comment>ID3-8 RBIS
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_posen" pos="26" rst="0x0">
          <comment>ID3-8 RBIS
0
1</comment>
        </bits>
        <bits access="rw" name="rbis_num" pos="25:23" rst="0x0">
          <comment>ID3-8 RBIS
01
12
23
34
45</comment>
        </bits>
        <bits access="rw" name="rbis_dipos" pos="22:16" rst="0x0">
          <comment>ID3-8 RBIS</comment>
        </bits>
        <bits access="rw" name="rbis_factor" pos="15:0" rst="0x0">
          <comment>ID3-8 RBIS</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis2_out1" protect="rw">
        <comment>RBIS ID2 1</comment>
        <bits access="r" name="rbis_out3" pos="30:24" rst="0x0">
          <comment>ID24RBIPRB</comment>
        </bits>
        <bits access="r" name="rbis_out2" pos="22:16" rst="0x0">
          <comment>ID23RBIPRB</comment>
        </bits>
        <bits access="r" name="rbis_out1" pos="14:8" rst="0x0">
          <comment>ID22RBIPRB</comment>
        </bits>
        <bits access="r" name="rbis_out0" pos="6:0" rst="0x0">
          <comment>ID21RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis2_out2" protect="rw">
        <comment>RBIS ID22</comment>
        <bits access="r" name="rbis_num" pos="10:8" rst="0x0">
          <comment>ID2 RBIS JUDGE</comment>
        </bits>
        <bits access="r" name="rbis_out4" pos="6:0" rst="0x0">
          <comment>ID25RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis2_ave" protect="rw">
        <comment>RBIS ID2 AVE</comment>
      </reg>
      <reg name="measpwr_rbis2_max" protect="rw">
        <comment>RBIS ID2 MAX</comment>
        <bits access="r" name="rbis_max" pos="24:0" rst="0x0">
          <comment>ID2 RBIS</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis3_out1" protect="rw">
        <comment>RBIS ID3-8 1</comment>
        <bits access="r" name="rbis_out3" pos="30:24" rst="0x0">
          <comment>ID3-84RBIPRB</comment>
        </bits>
        <bits access="r" name="rbis_out2" pos="22:16" rst="0x0">
          <comment>ID3-83RBIPRB</comment>
        </bits>
        <bits access="r" name="rbis_out1" pos="14:8" rst="0x0">
          <comment>ID3-82RBIPRB</comment>
        </bits>
        <bits access="r" name="rbis_out0" pos="6:0" rst="0x0">
          <comment>ID3-81RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis3_out2" protect="rw">
        <comment>RBIS ID3-82</comment>
        <bits access="r" name="rbis_num" pos="10:8" rst="0x0">
          <comment>ID3-8 RBIS JUDGE</comment>
        </bits>
        <bits access="r" name="rbis_out4" pos="6:0" rst="0x0">
          <comment>ID3-85RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis3_ave" protect="rw">
        <comment>RBIS ID3-8 AVE</comment>
      </reg>
      <reg name="measpwr_rbis3_max" protect="rw">
        <comment>RBIS ID3-8 MAX</comment>
        <bits access="r" name="rbis_max" pos="24:0" rst="0x0">
          <comment>ID3-8 RBIS</comment>
        </bits>
      </reg>
      <reg name="measpwr_ irt_scale2_th1" protect="rw">
        <comment>IRT ID3-8 Scale1</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th2" protect="rw">
        <comment>IRT  ID3-8 Scale2</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th4" protect="rw">
        <comment>IRT  ID3-8 Scale4</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th8" protect="rw">
        <comment>IRT  ID3-8 Scale8</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th16" protect="rw">
        <comment>IRT  ID3-8 Scale16</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th32" protect="rw">
        <comment>IRT  ID3-8 Scale32</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th64" protect="rw">
        <comment>IRT  ID3-8 Scale64</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th128" protect="rw">
        <comment>IRT  ID3-8 Scale128</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th256" protect="rw">
        <comment>IRT  ID3-8 Scale256</comment>
      </reg>
      <reg name="measpwr_ irt_scale2_th512" protect="rw">
        <comment>IRT  ID3-8 Scale512</comment>
      </reg>
      <reg name="measpwr_sigpwr_para2" protect="rw">
        <comment>Sigpwr2</comment>
        <bits access="rw" name="sigpwr_renum" pos="7:0" rst="0x0">
          <comment>ID3-8 SIGPWR</comment>
        </bits>
      </reg>
      <reg name="measpwr_irt_para3" protect="rw">
        <comment>IRT2</comment>
        <bits access="rw" name="s_th" pos="31:16" rst="0x0">
          <comment>ID3-8</comment>
        </bits>
        <bits access="rw" name="n_th" pos="15:0" rst="0x0">
          <comment>id3-816q10</comment>
        </bits>
      </reg>
      <reg name="measpwr_trms_para3" protect="rw">
        <comment>TRMS3</comment>
        <bits access="rw" name="s_th" pos="31:16" rst="0x0">
          <comment>ID3-816q15</comment>
        </bits>
        <bits access="rw" name="n_th" pos="15:0" rst="0x0">
          <comment>ID3-816q10</comment>
        </bits>
      </reg>
      <reg name="measpwr_rsrp_para5" protect="rw">
        <comment>RSRP5</comment>
        <bits access="rw" name="beta" pos="31:16" rst="0x0">
          <comment>id3-8beta16Q10</comment>
        </bits>
        <bits access="rw" name="s_th" pos="15:0" rst="0x0">
          <comment>ID3-8</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_in1" protect="rw">
        <comment>RBIS ID1 1</comment>
        <bits access="rw" name="rbis_in3" pos="30:24" rst="0x0">
          <comment>ID14RBIPRB</comment>
        </bits>
        <bits access="rw" name="rbis_in2" pos="22:16" rst="0x0">
          <comment>ID13RBIPRB</comment>
        </bits>
        <bits access="r" name="reserced3" pos="15" rst="0x0"/>
        <bits access="rw" name="rbis_in1" pos="14:8" rst="0x0">
          <comment>ID12RBIPRB</comment>
        </bits>
        <bits access="rw" name="rbis_in0" pos="6:0" rst="0x0">
          <comment>ID11RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis_in2" protect="rw">
        <comment>RBIS ID1 2</comment>
        <bits access="rw" name="rbis_in_num" pos="10:8" rst="0x0">
          <comment>ID1 RBIS JUDGE</comment>
        </bits>
        <bits access="rw" name="rbis_in4" pos="6:0" rst="0x0">
          <comment>ID15RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis2_in1" protect="rw">
        <comment>RBIS ID21</comment>
        <bits access="rw" name="rbis_in3" pos="30:24" rst="0x0">
          <comment>ID24RBIPRB</comment>
        </bits>
        <bits access="rw" name="rbis_in2" pos="22:16" rst="0x0">
          <comment>ID23RBIPRB</comment>
        </bits>
        <bits access="r" name="reserced3" pos="15" rst="0x0"/>
        <bits access="rw" name="rbis_in1" pos="14:8" rst="0x0">
          <comment>ID22RBIPRB</comment>
        </bits>
        <bits access="rw" name="rbis_in0" pos="6:0" rst="0x0">
          <comment>ID21RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis2_in2" protect="rw">
        <comment>RBIS ID22</comment>
        <bits access="rw" name="rbis_in_num" pos="10:8" rst="0x0">
          <comment>ID2 RBIS JUDGE</comment>
        </bits>
        <bits access="rw" name="rbis_in4" pos="6:0" rst="0x0">
          <comment>ID25RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis3_in1" protect="rw">
        <comment>RBIS ID3-81</comment>
        <bits access="rw" name="rbis_in3" pos="30:24" rst="0x0">
          <comment>ID3-84RBIPRB</comment>
        </bits>
        <bits access="rw" name="rbis_in2" pos="22:16" rst="0x0">
          <comment>ID3-83RBIPRB</comment>
        </bits>
        <bits access="r" name="reserced3" pos="15" rst="0x0"/>
        <bits access="rw" name="rbis_in1" pos="14:8" rst="0x0">
          <comment>ID3-82RBIPRB</comment>
        </bits>
        <bits access="rw" name="rbis_in0" pos="6:0" rst="0x0">
          <comment>ID3-81RBIPRB</comment>
        </bits>
      </reg>
      <reg name="measpwr_rbis3_in2" protect="rw">
        <comment>RBIS ID3-82</comment>
        <bits access="rw" name="rbis_in_num" pos="10:8" rst="0x0">
          <comment>ID3-8 RBIS JUDGE</comment>
        </bits>
        <bits access="rw" name="rbis_in4" pos="6:0" rst="0x0">
          <comment>ID3-85RBIPRB</comment>
        </bits>
      </reg>
      <hole size="1034944"/>
      <reg name="mem_in_1" protect="rw">
        <bits access="rw" name="mem_in_1" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem_in_2" protect="rw">
        <bits access="rw" name="mem_in_2" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem_in_3" protect="rw">
        <bits access="rw" name="mem_in_3" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem_in_4" protect="rw">
        <bits access="rw" name="mem_in_4" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem_in_5" protect="rw">
        <bits access="rw" name="mem_in_5" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="mem_in_6" protect="rw">
        <bits access="rw" name="mem_in_6" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="mem_in_7" protect="rw">
        <bits access="rw" name="mem_in_7" pos="23:0" rst="0x0"/>
      </reg>
      <hole size="262112"/>
      <reg name="mem_in_8" protect="rw">
        <bits access="rw" name="mem_in_8" pos="23:0" rst="0x0"/>
      </reg>
    </module>
    <instance address="0x18500000" name="MEASPWR" type="MEASPWR"/>
  </archive>
  <archive relative="iddet.xml">
    <module category="System" name="IDDET">
      <reg name="iddet_start" protect="rw">
        <comment></comment>
        <bits access="rw" name="rd_pre_pwr" pos="27" rst="0x0">
          <comment>DMAIDDET
0:
1:</comment>
        </bits>
        <bits access="rw" name="save_last_pwr" pos="26" rst="0x0">
          <comment>DMAMEM
0:
1:</comment>
        </bits>
        <bits access="rw" name="sample_len" pos="25:12" rst="0x0">
          <comment>5ms+2OFDM
1~9856</comment>
        </bits>
        <bits access="rw" name="sample_num" pos="11:8" rst="0x0">
          <comment>
4b000: 5ms+2OFDM
4b0001: 1

4b1111: 15</comment>
        </bits>
        <bits access="rw" name="rec_continuity" pos="7" rst="0x1">
          <comment>0: 
1:</comment>
        </bits>
        <bits access="rw" name="flow_sel" pos="6:4" rst="0x0">
          <comment>3b001: PSS
3b010: PSS
3b011: SSS
3b100: 
3b101:
3b110:</comment>
        </bits>
        <bits access="rw" name="txrx_offset_en" pos="3" rst="0x0">
          <comment>TXRXOFFSET
1:OFFSET
0:OFFSET</comment>
        </bits>
        <bits access="rw" name="data_move_out" pos="2" rst="0x0">
          <comment>1: TXRXDMA;
0: TXRXDMA</comment>
        </bits>
        <bits access="rw" name="iddet_stop" pos="1" rst="0x0">
          <comment>1: IDDET
0: IDDET </comment>
        </bits>
        <bits access="rw" name="iddet_start" pos="0" rst="0x0">
          <comment>1: IDDET
0: IDDET </comment>
        </bits>
      </reg>
      <reg name="pss1_ctrl" protect="rw">
        <comment>PSS1_CTRL</comment>
        <bits access="rw" name="rssi_en" pos="16" rst="0x1">
          <comment>RSSI</comment>
        </bits>
        <bits access="rw" name="output_num" pos="15:12" rst="0x3">
          <comment>PSS.1~12512</comment>
        </bits>
        <bits access="rw" name="max_num" pos="10:8" rst="0x1">
          <comment>,1~5</comment>
        </bits>
        <bits access="rw" name="flow_mode_sel" pos="7" rst="0x0">
          <comment>0: ICS;1: IDDET</comment>
        </bits>
        <bits access="rw" name="ppm_en" pos="6" rst="0x1">
          <comment>0:  0: </comment>
        </bits>
        <bits access="rw" name="id_mode_sel" pos="5:4" rst="0x0">
          <comment>0: ID2  1: ID20  2: ID21  3: ID22</comment>
        </bits>
        <bits access="rw" name="localpss_freq_en" pos="3:2" rst="0x3">
          <comment>0:   1: 1
2: 3  3: 5</comment>
        </bits>
        <bits access="rw" name="dagc_en" pos="1" rst="0x1">
          <comment>0: AGC  1: AGC</comment>
        </bits>
        <bits access="rw" name="dc_en" pos="0" rst="0x1">
          <comment>0:    1: </comment>
        </bits>
      </reg>
      <reg name="pss2_ctrl" protect="rw">
        <comment>PSS2_CTRL</comment>
        <bits access="rw" name="rssi_en" pos="8" rst="0x1">
          <comment>RSSI</comment>
        </bits>
        <bits access="rw" name="pos_num" pos="7:4" rst="0x3">
          <comment> 1~12</comment>
        </bits>
        <bits access="rw" name="ppm_en" pos="3" rst="0x1">
          <comment>1:
0:</comment>
        </bits>
        <bits access="rw" name="localpss_freq_en" pos="2" rst="0x1">
          <comment>1: 
0: </comment>
        </bits>
        <bits access="rw" name="dagc_en" pos="1" rst="0x1">
          <comment>1: AGC
0: AGC</comment>
        </bits>
        <bits access="rw" name="dc_en" pos="0" rst="0x1">
          <comment>1: 
0: </comment>
        </bits>
      </reg>
      <reg name="sss_ctrl" protect="rw">
        <comment>SSS_CTRL</comment>
        <bits access="rw" name="rssi_en" pos="27" rst="0x1">
          <comment>RSSI</comment>
        </bits>
        <bits access="rw" name="pos_slide_num" pos="26:25" rst="0x0">
          <comment>
0:
1:1
2:2
3:4</comment>
        </bits>
        <bits access="rw" name="sort_sel" pos="24" rst="0x0">
          <comment>0:
1:</comment>
        </bits>
        <bits access="rw" name="normalsort_num" pos="23:20" rst="0x0">
          <comment>
1~10</comment>
        </bits>
        <bits access="rw" name="nid1" pos="19:12" rst="0x0">
          <comment>NID1ID  0~168</comment>
        </bits>
        <bits access="rw" name="pos_num" pos="11:8" rst="0x3">
          <comment>  ICSIDDET1~12</comment>
        </bits>
        <bits access="rw" name="ppm_en" pos="7" rst="0x1">
          <comment>1:
0:</comment>
        </bits>
        <bits access="rw" name="flow_mode_sel" pos="6" rst="0x0">
          <comment>0:ICS
1: ID DETECT</comment>
        </bits>
        <bits access="rw" name="id_mode_sel" pos="5" rst="0x0">
          <comment>1: ID   0: ID</comment>
        </bits>
        <bits access="rw" name="fdd_tdd_sel" pos="4" rst="0x0">
          <comment>1: FDD  0: TDD</comment>
        </bits>
        <bits access="rw" name="ic_en" pos="3" rst="0x1">
          <comment>1: 
0: </comment>
        </bits>
        <bits access="rw" name="freq_en" pos="2" rst="0x1">
          <comment>1: 
0: </comment>
        </bits>
        <bits access="rw" name="dagc_en" pos="1" rst="0x1">
          <comment>1: AGC
0: AGC</comment>
        </bits>
        <bits access="rw" name="dc_en" pos="0" rst="0x1">
          <comment>1: 
0: </comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_ctrl" protect="rw">
        <comment></comment>
        <bits access="rw" name="rssi_en" pos="18" rst="0x1">
          <comment>RSSI</comment>
        </bits>
        <bits access="rw" name="pos_slide_num" pos="17:16" rst="0x0">
          <comment>
0:
1:1
2:2
3:4</comment>
        </bits>
        <bits access="rw" name="pos_num" pos="15:12" rst="0x3">
          <comment> 1~12</comment>
        </bits>
        <bits access="rw" name="slide_num" pos="10:8" rst="0x4">
          <comment>PSSSSSM0~4</comment>
        </bits>
        <bits access="rw" name="fdd_tdd_sel" pos="5" rst="0x0">
          <comment>1: FDD
0: TDD</comment>
        </bits>
        <bits access="rw" name="freq_en" pos="4" rst="0x1">
          <comment>1: 
0: </comment>
        </bits>
        <bits access="rw" name="freqitm_en" pos="3" rst="0x1">
          <comment>1: 
0: </comment>
        </bits>
        <bits access="rw" name="ppm_en" pos="2" rst="0x1">
          <comment>1:
0:</comment>
        </bits>
        <bits access="rw" name="dagc_en" pos="1" rst="0x1">
          <comment>1: AGC
0: AGC</comment>
        </bits>
        <bits access="rw" name="dc_en" pos="0" rst="0x1">
          <comment>1: 
0: </comment>
        </bits>
      </reg>
      <reg name="resync_ctrl" protect="rw">
        <comment>RESYNC_CTRL</comment>
        <bits access="rw" name="rssi_en" pos="21" rst="0x1">
          <comment>RSSI</comment>
        </bits>
        <bits access="rw" name="data_len" pos="20:18" rst="0x1">
          <comment>
0:1ms
1:2ms
2:3ms
3:4ms
4:5ms</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="17:16" rst="0x0">
          <comment>00:  01: 0   10: 5</comment>
        </bits>
        <bits access="rw" name="max_num" pos="14:12" rst="0x1">
          <comment> 1~5</comment>
        </bits>
        <bits access="rw" name="id1" pos="11:4" rst="0x0">
          <comment>ID1  0~167</comment>
        </bits>
        <bits access="rw" name="id2" pos="3:2" rst="0x0">
          <comment>ID2  0~2</comment>
        </bits>
        <bits access="rw" name="dagc_en" pos="1" rst="0x1">
          <comment>0: AGC
1: AGC</comment>
        </bits>
        <bits access="rw" name="dc_en" pos="0" rst="0x1">
          <comment>0: 
1: </comment>
        </bits>
      </reg>
      <reg name="shift_ctrl0" protect="rw">
        <comment>0</comment>
        <bits access="rw" name="pwr_acc_s3" pos="31:28" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s3" pos="27:24" rst="0x0">
          <comment>RSSI -8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s2" pos="23:20" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s2" pos="19:16" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s1" pos="15:12" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s1" pos="11:8" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s0" pos="7:4" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s0" pos="3:0" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
      </reg>
      <reg name="shift_ctrl1" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="pwr_acc_s7" pos="31:28" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s7" pos="27:24" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s6" pos="23:20" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s6" pos="19:16" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s5" pos="15:12" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s5" pos="11:8" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s4" pos="7:4" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s4" pos="3:0" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
      </reg>
      <reg name="shift_ctrl2" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="pwr_acc_s9" pos="15:12" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s9" pos="11:8" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="pwr_acc_s8" pos="7:4" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
        <bits access="rw" name="rssi_s8" pos="3:0" rst="0x0">
          <comment>RSSI  -8~7</comment>
        </bits>
      </reg>
      <reg name="int_ctrl" protect="rw">
        <comment>INT_CTRL</comment>
        <bits access="rw" name="discon_section_fin_irq_en" pos="10" rst="0x1">
          <comment>1:
0:</comment>
        </bits>
        <bits access="rw" name="freq_search_irq_en" pos="9" rst="0x1">
          <comment>1: 1
0: 1</comment>
        </bits>
        <bits access="rw" name="rssi_en" pos="8" rst="0x1">
          <comment>1:RSSI
0: RSSI</comment>
        </bits>
        <bits access="rw" name="stop" pos="7" rst="0x1">
          <comment>1:
0: </comment>
        </bits>
        <bits access="rw" name="error_irq_en" pos="6" rst="0x1">
          <comment>1: AXIDMA
0: AXIDMA</comment>
        </bits>
        <bits access="rw" name="txrx_suspend_irq_en" pos="5" rst="0x1">
          <comment>1:TXRX
0: TXRX</comment>
        </bits>
        <bits access="rw" name="resync_fin_irq_en" pos="4" rst="0x1">
          <comment>1:
0:</comment>
        </bits>
        <bits access="rw" name="freq_idident_fin_irq_en" pos="3" rst="0x1">
          <comment>1:
0: </comment>
        </bits>
        <bits access="rw" name="sss_fin_irq_en" pos="2" rst="0x1">
          <comment>1:SSS
0: SSS</comment>
        </bits>
        <bits access="rw" name="pssitm_fin_irq_en" pos="1" rst="0x1">
          <comment>1:PSS
0: PSS</comment>
        </bits>
        <bits access="rw" name="pssgru_fin_irq_en" pos="0" rst="0x1">
          <comment>1:PSS
0: PSS</comment>
        </bits>
      </reg>
      <reg name="pos_offset" protect="rw">
        <comment>PSS/SSS</comment>
        <bits access="rw" name="pss1_rssi_th" pos="31:16" rst="0x0">
          <comment>RSSI</comment>
        </bits>
        <bits access="rw" name="pssitm_sss_offset_pos" pos="14:0" rst="0x0">
          <comment>PSSTXRX0PSSSSSTXRX
00~19200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl1" protect="rw">
        <comment>SAM_NUM_CTRL </comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>  0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl2" protect="rw">
        <comment>SAM_NUM_CTRL </comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>  0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl3" protect="rw">
        <comment>SAM_NUM_CTRL </comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>  0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl4" protect="rw">
        <comment>SAM_NUM_CTRL </comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>  0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl5" protect="rw">
        <comment>SAM_NUM_CTRL </comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>  0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl6" protect="rw">
        <comment>SAM_NUM_CTRL </comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>  0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl7" protect="rw">
        <comment>SAM_NUM_CTRL </comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>  0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl8" protect="rw">
        <comment>SAM_NUM_CTRL </comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>  0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl9" protect="rw">
        <comment>SAM_NUM_CTRL </comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>  0~200</comment>
        </bits>
      </reg>
      <reg name="sam_num_ctrl10" protect="rw">
        <comment>SAM_NUM_CTRL </comment>
        <bits access="rw" name="sam_num" pos="7:0" rst="0x0">
          <comment>  0~200</comment>
        </bits>
      </reg>
      <reg name="end_threshold1" protect="rw">
        <comment></comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="end_threshold2" protect="rw">
        <comment></comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="end_threshold3" protect="rw">
        <comment></comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="end_threshold4" protect="rw">
        <comment></comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="end_threshold5" protect="rw">
        <comment></comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="end_threshold6" protect="rw">
        <comment></comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="end_threshold7" protect="rw">
        <comment></comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="end_threshold8" protect="rw">
        <comment></comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="end_threshold9" protect="rw">
        <comment></comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="end_threshold10" protect="rw">
        <comment></comment>
        <bits access="rw" name="end_threshold1" pos="31:16" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="end_threshold0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para1" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para2" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para3" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para4" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para5" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para6" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para7" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para8" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para9" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para10" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para11" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="pssitm_id_para12" protect="rw">
        <comment>PSSID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>PSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para1" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para2" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para3" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para4" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para5" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para6" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para7" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para8" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para9" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para10" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para11" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="sss_id_para12" protect="rw">
        <comment>SSS ID</comment>
        <bits access="rw" name="pssgru_freqoff" pos="27:12" rst="0x0">
          <comment>PSSID-32768~32767</comment>
        </bits>
        <bits access="rw" name="pssgru_ppm" pos="9:4" rst="0x0">
          <comment>PSSID-32~31</comment>
        </bits>
        <bits access="rw" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)15  00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="1:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para1" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para2" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para3" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para4" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para5" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para6" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para7" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para8" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para9" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para10" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para11" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="freqitm_idident_para12" protect="rw">
        <comment>ID ID</comment>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>NID1  0-167</comment>
        </bits>
      </reg>
      <reg name="id_postion1" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion2" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion3" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion4" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion5" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion6" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion7" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion8" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion9" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion10" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion11" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="id_postion12" protect="rw">
        <comment>PSS/SSS/IDID</comment>
        <bits access="rw" name="id_pos" pos="13:0" rst="0x0">
          <comment>ID  0~9599</comment>
        </bits>
      </reg>
      <reg name="pss_sss_find" protect="rw">
        <comment>PSS_SSS_FIND</comment>
        <bits access="rw" name="find_win" pos="27:24" rst="0x0">
          <comment>SSSMAX 10</comment>
        </bits>
        <bits access="rw" name="nois_win" pos="21:20" rst="0x0">
          <comment> 0:31  1:61  2:127</comment>
        </bits>
        <bits access="rw" name="assist_win" pos="19:18" rst="0x0">
          <comment>IDDET PSSASSIST_WINMAX_NUMPOS_NUMPOS_NUM</comment>
        </bits>
        <bits access="rw" name="wipe_win" pos="17:16" rst="0x0">
          <comment>2b00:2  2b01:4  2b10:8 others:2</comment>
        </bits>
        <bits access="rw" name="p2p_win" pos="15:9" rst="0x0">
          <comment>0-127</comment>
        </bits>
        <bits access="rw" name="noisth_en" pos="8" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="nois_th" pos="7:0" rst="0x0">
          <comment>Q3</comment>
        </bits>
      </reg>
      <reg name="freq_pssgru1" protect="rw">
        <comment>PSS1</comment>
        <bits access="rw" name="freq_pssgru2" pos="29:20" rst="0x0">
          <comment>PSS2   -1024~1023</comment>
        </bits>
        <bits access="rw" name="freq_pssgru1" pos="19:10" rst="0x38">
          <comment>PSS1   -1024~1023</comment>
        </bits>
        <bits access="rw" name="freq_pssgru0" pos="9:0" rst="0x2f">
          <comment>PSS0   -1024~1023</comment>
        </bits>
      </reg>
      <reg name="freq_pssgru2" protect="rw">
        <comment>PSS2</comment>
        <bits access="rw" name="freq_pssgru4" pos="19:10" rst="0x11">
          <comment>PSS4   -1024~1023</comment>
        </bits>
        <bits access="rw" name="freq_pssgru3" pos="9:0" rst="0x8">
          <comment>PSS3   -1024~1023</comment>
        </bits>
      </reg>
      <reg name="freq_pssitm1" protect="rw">
        <comment>PSS1</comment>
        <bits access="rw" name="freq_pssitm" pos="12:0" rst="0x1448">
          <comment>PSS  -4096~4095</comment>
        </bits>
      </reg>
      <reg name="freq_pssitm2" protect="rw">
        <comment>PSS2</comment>
        <bits access="rw" name="freq_pssitm" pos="12:0" rst="0x1c18">
          <comment>PSS  -4096~4095</comment>
        </bits>
      </reg>
      <reg name="freq_pssitm3" protect="rw">
        <comment>PSS3</comment>
        <bits access="rw" name="freq_pssitm" pos="12:0" rst="0x3e8">
          <comment>PSS  -4096~4095</comment>
        </bits>
      </reg>
      <reg name="freq_pssitm4" protect="rw">
        <comment>PSS4</comment>
        <bits access="rw" name="freq_pssitm" pos="12:0" rst="0xbb8">
          <comment>PSS  -4096~4095</comment>
        </bits>
      </reg>
      <reg name="rssi_target" protect="rw">
        <comment>RSSI</comment>
      </reg>
      <reg name="ppm_gru_cfg1" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="ppm1" pos="13:8" rst="0x32">
          <comment>PSS  -32~31</comment>
        </bits>
        <bits access="rw" name="ppm0" pos="5:0" rst="0x2e">
          <comment>PSS  -32~31</comment>
        </bits>
      </reg>
      <reg name="ppm_gru_cfg2" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="ppm1" pos="13:8" rst="0x3a">
          <comment>PSS  -32~31</comment>
        </bits>
        <bits access="rw" name="ppm0" pos="5:0" rst="0x36">
          <comment>PSS  -32~31</comment>
        </bits>
      </reg>
      <reg name="ppm_gru_cfg3" protect="rw">
        <comment>3</comment>
        <bits access="rw" name="ppm1" pos="13:8" rst="0x2">
          <comment>PSS  -32~31</comment>
        </bits>
        <bits access="rw" name="ppm0" pos="5:0" rst="0x3e">
          <comment>PSS  -32~31</comment>
        </bits>
      </reg>
      <reg name="ppm_gru_cfg4" protect="rw">
        <comment>4</comment>
        <bits access="rw" name="ppm1" pos="13:8" rst="0xa">
          <comment>PSS  -32~31</comment>
        </bits>
        <bits access="rw" name="ppm0" pos="5:0" rst="0x6">
          <comment>PSS  -32~31</comment>
        </bits>
      </reg>
      <reg name="ppm_gru_cfg5" protect="rw">
        <comment>5</comment>
        <bits access="rw" name="ppm1" pos="13:8" rst="0x12">
          <comment>PSS  -32~31</comment>
        </bits>
        <bits access="rw" name="ppm0" pos="5:0" rst="0xe">
          <comment>PSS  -32~31</comment>
        </bits>
      </reg>
      <reg name="ppm_delt_cfg" protect="rw">
        <comment>PSSSSS</comment>
        <bits access="rw" name="delt_ppm3" pos="15:12" rst="0x3">
          <comment>  -8~7</comment>
        </bits>
        <bits access="rw" name="delt_ppm2" pos="11:8" rst="0x1">
          <comment>  -8~7</comment>
        </bits>
        <bits access="rw" name="delt_ppm1" pos="7:4" rst="0xf">
          <comment>  -8~7</comment>
        </bits>
        <bits access="rw" name="delt_ppm0" pos="3:0" rst="0xd">
          <comment>  -8~7</comment>
        </bits>
      </reg>
      <reg name="fft_cut" protect="rw">
        <comment>FFT</comment>
        <bits access="rw" name="lnum_mod2" pos="7:4" rst="0x0">
          <comment> FFT/IFFT ()
4`b0000
4`b0001
4`b0010
</comment>
        </bits>
        <bits access="rw" name="lnum_mod1" pos="3:0" rst="0x0">
          <comment> FFT/IFFT PSS/SSS
4`b0000
4`b0001
4`b0010
</comment>
        </bits>
      </reg>
      <reg name="ic_id_para" protect="rw">
        <comment>ID</comment>
        <bits access="rw" name="freq_off_en" pos="28" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="rw" name="freq_off" pos="27:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="cptype" pos="11" rst="0x0">
          <comment>IDCP
1EXTEND CP   0NORMAL CP</comment>
        </bits>
        <bits access="rw" name="sfnum" pos="10" rst="0x0">
          <comment>ID(SSS)
15   00</comment>
        </bits>
        <bits access="rw" name="nid2" pos="9:8" rst="0x0">
          <comment>SSS</comment>
        </bits>
        <bits access="rw" name="nid1" pos="7:0" rst="0x0">
          <comment>SSS</comment>
        </bits>
      </reg>
      <reg name="ic_cfg" protect="rw">
        <comment>IC_CFG</comment>
        <bits access="rw" name="ic_ppm" pos="23:18" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="sssic_pos" pos="17:4" rst="0x0">
          <comment>SSS 9600</comment>
        </bits>
        <bits access="rw" name="ic_shift" pos="3:0" rst="0x0">
          <comment>
0
11
22

-11
-22
</comment>
        </bits>
      </reg>
      <reg name="freqitm_out0" protect="rw">
        <comment>ID 0</comment>
        <bits access="r" name="freq_itm_out0" pos="15:0" rst="0x0">
          <comment>0</comment>
        </bits>
      </reg>
      <reg name="valid_node" protect="rw">
        <comment>PSSPSSSSS</comment>
        <bits access="r" name="valid_node1" pos="7:4" rst="0x0">
          <comment>SSS
00
11

1212</comment>
        </bits>
        <bits access="r" name="valid_node0" pos="3:0" rst="0x0">
          <comment>PSSPSSSSS
00
11

1212</comment>
        </bits>
      </reg>
      <reg name="sample_sum" protect="rw">
        <comment></comment>
        <bits access="rw" name="sample_sum" pos="7:0" rst="0x0">
          <comment>PSSPSSSSS
0~200</comment>
        </bits>
      </reg>
      <reg name="rssi" protect="rw">
        <comment>RSSI</comment>
        <bits access="r" name="rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSIPSSSSS
RSSI</comment>
        </bits>
      </reg>
      <reg name="id_power_noise1" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise2" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise3" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise4" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise5" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise6" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise7" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise8" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise9" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise10" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise11" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_power_noise12" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="id_position_freq1" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq2" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq3" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq4" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq5" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq6" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq7" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq8" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq9" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq10" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq11" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_position_freq12" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="id_info1" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info2" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info3" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info4" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info5" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info6" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info7" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info8" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info9" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info10" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info11" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="id_info12" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="pos_index" pos="25:22" rst="0x0">
          <comment>SSS IDDET
0~11</comment>
        </bits>
        <bits access="r" name="pos_slide" pos="21:18" rst="0x0">
          <comment>
0-8</comment>
        </bits>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="assist_id_power_noise1" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="assist_id_power_noise2" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="assist_id_power_noise3" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="assist_id_power_noise4" protect="rw">
        <comment></comment>
        <bits access="r" name="noise" pos="31:16" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
        <bits access="r" name="power" pos="15:0" rst="0x0">
          <comment>PSSPSSSSS</comment>
        </bits>
      </reg>
      <reg name="assist_id_position_freq1" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="assist_id_position_freq2" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="assist_id_position_freq3" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="assist_id_position_freq4" protect="rw">
        <comment></comment>
        <bits access="r" name="freq_offset" pos="31:16" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="postion" pos="13:0" rst="0x0">
          <comment>PSSPSSSSSID</comment>
        </bits>
      </reg>
      <reg name="assist_id_info1" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="assist_id_info2" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="assist_id_info3" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="assist_id_info4" protect="rw">
        <comment>ID</comment>
        <bits access="r" name="ppm" pos="17:12" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="r" name="nid1" pos="11:4" rst="0x0">
          <comment>NID1
0-167</comment>
        </bits>
        <bits access="r" name="cptype" pos="3" rst="0x0">
          <comment>IDCP
1EXTEND CP
0NORMAL CP</comment>
        </bits>
        <bits access="r" name="sfnum" pos="2" rst="0x0">
          <comment>ID(SSS)
15
00</comment>
        </bits>
        <bits access="r" name="nid2" pos="1:0" rst="0x0">
          <comment>NID2
0-2</comment>
        </bits>
      </reg>
      <reg name="int_flag" protect="rw">
        <comment>INT_FLAG</comment>
        <bits access="rc" name="discon_section_finish" pos="11" rst="0x0">
          <comment>1:
0:</comment>
        </bits>
        <bits access="rc" name="freq_search" pos="10" rst="0x0">
          <comment>1:
0:</comment>
        </bits>
        <bits access="rc" name="freq_search_sbi" pos="9" rst="0x0">
          <comment>1:1
0:</comment>
        </bits>
        <bits access="rc" name="rssi" pos="8" rst="0x0">
          <comment>1:RSSI
0: RSSI</comment>
        </bits>
        <bits access="rc" name="stop" pos="7" rst="0x0">
          <comment>1:
0: </comment>
        </bits>
        <bits access="rc" name="error_state" pos="6" rst="0x0">
          <comment>1:AXIDMA
0:</comment>
        </bits>
        <bits access="rc" name="txrx_suspend" pos="5" rst="0x0">
          <comment>1:TXRX
0:</comment>
        </bits>
        <bits access="rc" name="resync_finish" pos="4" rst="0x0">
          <comment>1:
0: </comment>
        </bits>
        <bits access="rc" name="freq_idident_finish" pos="3" rst="0x0">
          <comment>1:
0:</comment>
        </bits>
        <bits access="rc" name="sss_finish" pos="2" rst="0x0">
          <comment>1:SSS
0:</comment>
        </bits>
        <bits access="rc" name="pssitm_finish" pos="1" rst="0x0">
          <comment>1:PSS
0:</comment>
        </bits>
        <bits access="rc" name="pssgru_finish" pos="0" rst="0x0">
          <comment>1:PSS
0:</comment>
        </bits>
      </reg>
      <reg name="sta_flag" protect="rw">
        <comment>IDDET</comment>
        <bits access="r" name="freq_search_run" pos="5" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="r" name="resyn_run" pos="4" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="r" name="freqitm_idident_run" pos="3" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="r" name="sss_run" pos="2" rst="0x0">
          <comment>
1
0</comment>
        </bits>
        <bits access="r" name="pss_itm_run" pos="1" rst="0x0">
          <comment>PSS
1
0</comment>
        </bits>
        <bits access="r" name="pss_gru_run" pos="0" rst="0x0">
          <comment>PSS
1
0</comment>
        </bits>
      </reg>
      <reg name="soft_use" protect="rw">
        <comment></comment>
      </reg>
      <reg name="pre_sample_count" protect="rw">
        <comment></comment>
        <bits access="rw" name="pre_sample_count" pos="9:0" rst="0x0">
          <comment>  0~1023</comment>
        </bits>
      </reg>
      <reg name="freq_search_ctrl" protect="rw">
        <comment></comment>
        <bits access="rw" name="sort_mode" pos="26" rst="0x0">
          <comment>0:
1:</comment>
        </bits>
        <bits access="rw" name="fft_en" pos="25" rst="0x0">
          <comment>FFT
0: FFT
1: FFT(1024),FFT</comment>
        </bits>
        <bits access="rw" name="sort_en" pos="24" rst="0x0">
          <comment>:
0: 
1: ,</comment>
        </bits>
        <bits access="rw" name="sort_end_addr" pos="23:14" rst="0x0">
          <comment>1~999</comment>
        </bits>
        <bits access="rw" name="sort_start_addr" pos="13:4" rst="0x0">
          <comment>0~999</comment>
        </bits>
        <bits access="rw" name="freq_sel" pos="3:2" rst="0x0">
          <comment>
0: 5M
1: 10M
2: 20M
: 5M</comment>
        </bits>
        <bits access="rw" name="last_5ms" pos="1" rst="0x0">
          <comment>0: 5ms
1: 5ms</comment>
        </bits>
        <bits access="rw" name="first_5ms" pos="0" rst="0x0">
          <comment>0: 5ms
1: 5ms</comment>
        </bits>
      </reg>
      <reg name="freq_search_config1" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="pwrwin_32to20bitsel" pos="30:27" rst="0x9">
          <comment>;
0:[19:0],20bit
1:[20:1],20bit

12:[31:12],20bit
:12;</comment>
        </bits>
        <bits access="rw" name="pwr_32to16bitsel" pos="26:23" rst="0x0">
          <comment>,;I^2+Q^2=PWR(32bit)
0:[31:15],16bit
1:[31:14],16bit

15:[31:0],16bit</comment>
        </bits>
        <bits access="rw" name="cur_sbi_num" pos="22:17" rst="0x0">
          <comment>
0~49</comment>
        </bits>
        <bits access="rw" name="sbi_max" pos="16:11" rst="0x0">
          <comment>   0~50</comment>
        </bits>
        <bits access="rw" name="freq_20m_en" pos="10" rst="0x0">
          <comment>20MHz
0: 
1: </comment>
        </bits>
        <bits access="rw" name="freq_15m_en" pos="9" rst="0x0">
          <comment>15MHz
0: 
1: </comment>
        </bits>
        <bits access="rw" name="freq_10m_en" pos="8" rst="0x0">
          <comment>10MHz
0: 
1: </comment>
        </bits>
        <bits access="rw" name="freq_5m_en" pos="7" rst="0x0">
          <comment>5MHz
0: 
1: </comment>
        </bits>
        <bits access="rw" name="freq_3m_en" pos="6" rst="0x0">
          <comment>3MHz
0: 
1: </comment>
        </bits>
        <bits access="rw" name="freq_1_4m_en" pos="5" rst="0x0">
          <comment>1.4MHz
0: 
1: </comment>
        </bits>
        <bits access="rw" name="freq_200k_en" pos="4" rst="0x0">
          <comment>200KHz
0: 
1: </comment>
        </bits>
        <bits access="rw" name="m" pos="3:0" rst="0x5">
          <comment>,1~11</comment>
        </bits>
      </reg>
      <reg name="freq_search_config2" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="selectbinnum_right" pos="17:9" rst="0x0">
          <comment>Selectbinnum0~511</comment>
        </bits>
        <bits access="rw" name="selectbinnum_left" pos="8:0" rst="0x0">
          <comment>selectbinnum0~511</comment>
        </bits>
      </reg>
      <reg name="band_win_start_conf1" protect="rw">
        <comment>START1</comment>
        <bits access="rw" name="band_5mhz" pos="27:21" rst="0x18">
          <comment>0~99</comment>
        </bits>
        <bits access="rw" name="band_3mhz" pos="20:14" rst="0xf">
          <comment>0~99</comment>
        </bits>
        <bits access="rw" name="band_1_4mhz" pos="13:7" rst="0x7">
          <comment>0~99</comment>
        </bits>
        <bits access="rw" name="band_200khz" pos="6:0" rst="0x2">
          <comment>0~99</comment>
        </bits>
      </reg>
      <reg name="band_win_start_conf2" protect="rw">
        <comment>START2</comment>
        <bits access="rw" name="band_20mhz" pos="20:14" rst="0x5b">
          <comment>0~99</comment>
        </bits>
        <bits access="rw" name="band_15mhz" pos="13:7" rst="0x45">
          <comment>0~99</comment>
        </bits>
        <bits access="rw" name="band_10mhz" pos="6:0" rst="0x2e">
          <comment>0~99</comment>
        </bits>
      </reg>
      <reg name="band_win_end_conf1" protect="rw">
        <comment>END1</comment>
        <bits access="rw" name="band_20mhz" pos="27:24" rst="0x9">
          <comment>0~15</comment>
        </bits>
        <bits access="rw" name="band_15mhz" pos="23:20" rst="0x6">
          <comment>0~15</comment>
        </bits>
        <bits access="rw" name="band_10mhz" pos="19:16" rst="0x4">
          <comment>0~15</comment>
        </bits>
        <bits access="rw" name="band_5mhz" pos="15:12" rst="0x1">
          <comment>0~15</comment>
        </bits>
        <bits access="rw" name="band_3mhz" pos="11:8" rst="0x0">
          <comment>0~15</comment>
        </bits>
        <bits access="rw" name="band_1_4mhz" pos="7:4" rst="0x0">
          <comment>0~15</comment>
        </bits>
        <bits access="rw" name="band_200khz" pos="3:0" rst="0x0">
          <comment>0~15</comment>
        </bits>
      </reg>
      <reg name="band_win_end_conf2" protect="rw">
        <comment>END2</comment>
      </reg>
      <reg name="agc_conf" protect="rw">
        <comment>AGC</comment>
        <bits access="rw" name="agc" pos="6:0" rst="0x0">
          <comment>0~127</comment>
        </bits>
      </reg>
      <reg name="sbi_sum_ len" protect="rw">
        <comment></comment>
        <bits access="rw" name="sbi_sum_len" pos="9:0" rst="0x0">
          <comment></comment>
        </bits>
      </reg>
      <reg name="target_agc" protect="rw">
        <comment>AGC</comment>
        <bits access="rw" name="target_agc" pos="9:0" rst="0x0">
          <comment>AGC</comment>
        </bits>
      </reg>
      <reg name="freqitm_out1" protect="rw">
        <comment>ID 1</comment>
        <bits access="r" name="freq_itm_out2" pos="31:16" rst="0x0">
          <comment>2</comment>
        </bits>
        <bits access="r" name="freq_itm_out1" pos="15:0" rst="0x0">
          <comment>1</comment>
        </bits>
      </reg>
      <reg name="pss1_resyn_rssi_range" protect="rw">
        <comment>PSS1_RESYN_CTRLRSSI</comment>
        <bits access="rw" name="pss1_rssi_end" pos="29:16" rst="0x12bf">
          <comment>PSSRSSI0~47990~9599</comment>
        </bits>
        <bits access="rw" name="pss1_rssi_start" pos="13:0" rst="0x0">
          <comment>PSSRSSI0~47990~9599</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi0" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi1" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi2" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi3" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi4" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi5" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi6" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi7" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi8" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi9" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi10" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <reg name="pss1_max_rssi11" protect="rw">
        <comment></comment>
        <bits access="r" name="pss1_max_rssi" pos="15:0" rst="0x0">
          <comment>PSSRSSI</comment>
        </bits>
      </reg>
      <hole size="27136"/>
      <reg name="mem8_9_mem10_11" protect="rw">
        <comment>1 PSS
2 PSSRSSI</comment>
      </reg>
      <hole size="32736"/>
      <reg name="mem12" protect="rw">
        <comment>1 PSS
2 SSS</comment>
      </reg>
      <hole size="32736"/>
      <reg name="mem15" protect="rw">
        <comment></comment>
      </reg>
      <hole size="32736"/>
      <reg name="memqf" protect="rw">
        <comment>QF</comment>
      </reg>
      <hole size="131040"/>
      <reg name="mem1_8_mem1_11" protect="rw">
        <comment>MEM1-8
MEM1-11
RF</comment>
        <bits access="rw" name="mem1_8_mem1_11_1" pos="25:16" rst="0x0"/>
        <bits access="rw" name="mem1_8_mem1_11_2" pos="9:0" rst="0x0"/>
      </reg>
      <hole size="131040"/>
      <reg name="mem_freq_pwr_before_agc" protect="rw">
        <comment>AGC</comment>
        <bits access="rw" name="mem_freq_pwr_before_agc_1" pos="31:16" rst="0x0">
          <comment>1PWR1</comment>
        </bits>
        <bits access="rw" name="mem_freq_pwr_before_agc_0" pos="15:0" rst="0x0">
          <comment>1PWR0</comment>
        </bits>
      </reg>
      <hole size="32736"/>
      <reg name="mem_freq_len_agc" protect="rw">
        <comment>AGC</comment>
        <bits access="rw" name="mem_freq_len_agc_1" pos="18:10" rst="0x0">
          <comment>1</comment>
        </bits>
        <bits access="rw" name="mem_freq_len_agc_0" pos="9:0" rst="0x0">
          <comment>1AGC</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x18600000" name="IDDET" type="IDDET"/>
  </archive>
  <archive relative="csirs.xml">
    <module category="System" name="CSIRS">
      <reg name="csi_start" protect="rw">
        <comment>CSI</comment>
        <bits access="rw" name="data_drive_en" pos="2" rst="0x0">
          <comment>data_drive
0data_drive
1data_drive</comment>
        </bits>
        <bits access="rw" name="dma_start_en" pos="1" rst="0x0">
          <comment>DMACSI
0
1</comment>
        </bits>
        <bits access="rw" name="csi_en" pos="0" rst="0x0">
          <comment>CSI
0
1</comment>
        </bits>
      </reg>
      <reg name="csi_cfg_nxt" protect="rw">
        <comment>CSI</comment>
        <bits access="rw" name="cp" pos="25" rst="0x0">
          <comment>cp
0
1</comment>
        </bits>
        <bits access="rw" name="fh_bit_sel" pos="24:20" rst="0x0">
          <comment>FH
5d0fh[11:0]
5d1fh[12:1]
5d2fh[13:2]

5d16fh[27:16]
othersfh[28:17]</comment>
        </bits>
        <bits access="rw" name="csi_crs_ind" pos="19" rst="0x0">
          <comment>CSI-RSCRS
0CSI-RS
1CRS</comment>
        </bits>
        <bits access="rw" name="ls_en" pos="18" rst="0x0">
          <comment>LS/FH/
0LS/FH/
1</comment>
        </bits>
        <bits access="rw" name="sw_ri" pos="17" rst="0x0">
          <comment>RIri_sel=1PMI
0RI=1
1RI=2</comment>
        </bits>
        <bits access="rw" name="ri_sel" pos="16" rst="0x0">
          <comment>PMIRI
0RI
1RI</comment>
        </bits>
        <bits access="rw" name="pmi_en" pos="15" rst="0x0">
          <comment>PMI
0PMI
1PMI</comment>
        </bits>
        <bits access="rw" name="ri_en" pos="14" rst="0x0">
          <comment>RI
0RI
1RI</comment>
        </bits>
        <bits access="rw" name="old_ri_ind" pos="13" rst="0x0">
          <comment>RIRI
0RI=1
1RI</comment>
        </bits>
        <bits access="rw" name="total_nrb" pos="12:6" rst="0x0">
          <comment>6/15/25/50/75/100PRB</comment>
        </bits>
        <bits access="rw" name="sub_nrb" pos="5:2" rst="0x0">
          <comment>total_nrb=6/15/25/50/75/100sub_nrb=6/2/2/3/4/4 PRB</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="1:0" rst="0x0">
          <comment>CSI-RS1248CRS24
01RIPMI
12
24
38</comment>
        </bits>
      </reg>
      <reg name="csi_ri_threshold_nxt" protect="rw">
        <comment>RI</comment>
        <bits access="rw" name="th2_cfg" pos="30:16" rst="0x0">
          <comment>((1-th2)/(1+th2))^2RI01Q15th240</comment>
        </bits>
        <bits access="rw" name="th1_cfg" pos="14:0" rst="0x0">
          <comment>((1-th1)/(1+th1))^2RI01Q15th160</comment>
        </bits>
      </reg>
      <reg name="csi_code_index1_nxt" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="code_index1_mask2" pos="31:16" rst="0x0">
          <comment>RI=2248i1bitmapbit0~bit150~151</comment>
        </bits>
        <bits access="rw" name="code_index1_mask1" pos="15:0" rst="0x0">
          <comment>RI=1248i1bitmapbit0~bit150~151</comment>
        </bits>
      </reg>
      <reg name="csi_code_index2_nxt" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="code_index2_mask2" pos="31:16" rst="0x0">
          <comment>RI=28i2bitmapbit0~bit150~151</comment>
        </bits>
        <bits access="rw" name="code_index2_mask1" pos="15:0" rst="0x0">
          <comment>RI=18i2bitmapbit0~bit150~151</comment>
        </bits>
      </reg>
      <reg name="csi_inten_nxt" protect="rw">
        <comment></comment>
        <bits access="rw" name="phy_factor" pos="7:4" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rw" name="csi_inten" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="csi_cinit1_nxt" protect="rw">
        <comment>OFDM0C</comment>
        <bits access="rw" name="cinit0" pos="30:0" rst="0x0">
          <comment>OFDM0CCSI-RS</comment>
        </bits>
      </reg>
      <reg name="csi_cinit2_nxt" protect="rw">
        <comment>OFDM1C</comment>
        <bits access="rw" name="cinit1" pos="30:0" rst="0x0">
          <comment>OFDM1CCSI-RS</comment>
        </bits>
      </reg>
      <reg name="csi_intf" protect="rw">
        <comment></comment>
        <bits access="rc" name="phy_factor" pos="7:4" rst="0x0">
          <comment></comment>
        </bits>
        <bits access="rc" name="csi_intf" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="csi_sw_stop" protect="rw">
        <comment></comment>
        <bits access="rw" name="sw_pause_way" pos="2" rst="0x0">
          <comment>sw_pause_en=1
0
1</comment>
        </bits>
        <bits access="rw" name="sw_pause_en" pos="1" rst="0x0">
          <comment>
0
10</comment>
        </bits>
        <bits access="rw" name="sw_stop_en" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="csi_sw_stop_flag" protect="rw">
        <comment></comment>
        <bits access="rc" name="sw_pause_flag" pos="1" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="rc" name="sw_stop_flag" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="csi_ri_rpt" protect="rw">
        <comment>RI</comment>
        <bits access="r" name="ri_total_rpt" pos="0" rst="0x0">
          <comment>RIPRBRI
0RI=1
1RI=2</comment>
        </bits>
      </reg>
      <reg name="csi_pmi_rpt" protect="rw">
        <comment>PMI</comment>
        <bits access="r" name="pmi_total_rpt" pos="7:0" rst="0x0">
          <comment>PMIPRBPMI</comment>
        </bits>
      </reg>
      <reg name="csi_rx1_sig_rpt" protect="rw">
        <comment>1</comment>
        <bits access="r" name="rx1_sig_rpt" pos="27:0" rst="0x0">
          <comment>1</comment>
        </bits>
      </reg>
      <reg name="csi_rx2_sig_rpt" protect="rw">
        <comment>2</comment>
        <bits access="r" name="rx2_sig_rpt" pos="27:0" rst="0x0">
          <comment>2</comment>
        </bits>
      </reg>
      <reg name="csi_rx1_noise_rpt" protect="rw">
        <comment>1</comment>
        <bits access="r" name="rx1_noise_rpt" pos="29:0" rst="0x0">
          <comment>1</comment>
        </bits>
      </reg>
      <reg name="csi_rx2_noise_rpt" protect="rw">
        <comment>2</comment>
        <bits access="r" name="rx2_noise_rpt" pos="29:0" rst="0x0">
          <comment>2</comment>
        </bits>
      </reg>
      <reg name="csi_cfg_cur" protect="rw">
        <comment>CSI</comment>
        <bits access="rw" name="cp" pos="25" rst="0x0">
          <comment>cp
0
1</comment>
        </bits>
        <bits access="rw" name="fh_bit_sel" pos="24:20" rst="0x0">
          <comment>FH
5d0fh[11:0]
5d1fh[12:1]
5d2fh[13:2]

5d16fh[27:16]
othersfh[28:17]</comment>
        </bits>
        <bits access="rw" name="csi_crs_ind" pos="19" rst="0x0">
          <comment>CSI-RSCRS
0CSI-RS
1CRS</comment>
        </bits>
        <bits access="rw" name="ls_en" pos="18" rst="0x0">
          <comment>LS/FH/
0LS/FH/
1</comment>
        </bits>
        <bits access="rw" name="sw_ri" pos="17" rst="0x0">
          <comment>RIri_sel=1PMI
0RI=1
1RI=2</comment>
        </bits>
        <bits access="rw" name="ri_sel" pos="16" rst="0x0">
          <comment>PMIRI
0RI
1RI</comment>
        </bits>
        <bits access="rw" name="pmi_en" pos="15" rst="0x0">
          <comment>PMI
0PMI
1PMI</comment>
        </bits>
        <bits access="rw" name="ri_en" pos="14" rst="0x0">
          <comment>RI
0RI
1RI</comment>
        </bits>
        <bits access="rw" name="old_ri_ind" pos="13" rst="0x0">
          <comment>RIRI
0RI=1
1RI</comment>
        </bits>
        <bits access="rw" name="total_nrb" pos="12:6" rst="0x0">
          <comment>6/15/25/50/75/100PRB</comment>
        </bits>
        <bits access="rw" name="sub_nrb" pos="5:2" rst="0x0">
          <comment>total_nrb=6/15/25/50/75/100sub_nrb=6/2/2/3/4/4 PRB</comment>
        </bits>
        <bits access="rw" name="tx_num" pos="1:0" rst="0x0">
          <comment>CSI-RS1248CRS24
01RIPMI
12
24
38</comment>
        </bits>
      </reg>
      <reg name="csi_ri_threshold_cur" protect="rw">
        <comment>RI</comment>
        <bits access="rw" name="th2_cfg" pos="30:16" rst="0x0">
          <comment>((1-th2)/(1+th2))^2RI01Q15th240</comment>
        </bits>
        <bits access="rw" name="th1_cfg" pos="14:0" rst="0x0">
          <comment>((1-th1)/(1+th1))^2RI01Q15th160</comment>
        </bits>
      </reg>
      <reg name="csi_code_index1_cur" protect="rw">
        <comment>1</comment>
        <bits access="rw" name="code_index1_mask2" pos="31:16" rst="0x0">
          <comment>RI=2248i1bitmapbit0~bit150~151</comment>
        </bits>
        <bits access="rw" name="code_index1_mask1" pos="15:0" rst="0x0">
          <comment>RI=1248i1bitmapbit0~bit150~151</comment>
        </bits>
      </reg>
      <reg name="csi_code_index2_cur" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="code_index2_mask2" pos="31:16" rst="0x0">
          <comment>RI=28i2bitmapbit0~bit150~151</comment>
        </bits>
        <bits access="rw" name="code_index2_mask1" pos="15:0" rst="0x0">
          <comment>RI=18i2bitmapbit0~bit150~151</comment>
        </bits>
      </reg>
      <reg name="csi_inten_cur" protect="rw">
        <comment></comment>
        <bits access="rw" name="csi_inten" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="csi_cinit1_cur" protect="rw">
        <comment>OFDM0C</comment>
        <bits access="rw" name="cinit0" pos="30:0" rst="0x0">
          <comment>OFDM0CCSI-RS</comment>
        </bits>
      </reg>
      <reg name="csi_cinit2_cur" protect="rw">
        <comment>OFDM1C</comment>
        <bits access="rw" name="cinit1" pos="30:0" rst="0x0">
          <comment>OFDM1CCSI-RS</comment>
        </bits>
      </reg>
      <hole size="261376"/>
      <reg name="rs_fh_mem1" protect="rw">
        <bits access="rw" name="rs_fh_mem1_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="rs_fh_mem1_2" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="rs_fh_mem2" protect="rw">
        <bits access="rw" name="rs_fh_mem2_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="rs_fh_mem2_2" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="hls_mem1" protect="rw">
        <bits access="rw" name="hls_mem1_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="hls_mem1_2" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="out_mem" protect="rw">
        </reg>
    </module>
    <instance address="0x18b00000" name="CSIRS" type="CSIRS"/>
  </archive>
  <archive relative="corr.xml">
    <module category="System" name="CORR">
      <reg name="corr_para" protect="rw">
        <comment></comment>
        <bits access="rw" name="corr_loclen" pos="24:16" rst="0x0">
          <comment>max384</comment>
        </bits>
        <bits access="rw" name="corr_reclen" pos="15:4" rst="0x0">
          <comment>max2800</comment>
        </bits>
        <bits access="rw" name="corr_idnum" pos="3:0" rst="0x0">
          <comment>IDmax10</comment>
        </bits>
      </reg>
      <reg name="corr_start" protect="rw">
        <comment></comment>
        <bits access="rw" name="corr_start" pos="0" rst="0x0">
          <comment>
1
0</comment>
        </bits>
      </reg>
      <reg name="corr_out" protect="rw">
        <comment></comment>
        <bits access="r" name="corr_pp" pos="16" rst="0x0">
          <comment>
0
1</comment>
        </bits>
        <bits access="r" name="corr_pos" pos="15:4" rst="0x0">
          <comment>max2800</comment>
        </bits>
        <bits access="r" name="corr_id" pos="3:0" rst="0x0">
          <comment>IDmax10</comment>
        </bits>
      </reg>
      <reg name="corr_max" protect="rw">
        <comment>MAX</comment>
        <bits access="r" name="corr_max" pos="23:0" rst="0x0">
          <comment>CORR_MAX</comment>
        </bits>
      </reg>
      <reg name="corr_sum" protect="rw">
        <comment>SUM</comment>
      </reg>
      <reg name="corr_int_en" protect="rw">
        <comment></comment>
        <bits access="rw" name="corr_int_en" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="int_flag" protect="rw">
        <comment></comment>
        <bits access="rc" name="int_flag" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x19000800" name="CORR" type="CORR"/>
  </archive>
  <archive relative="rxcapt.xml">
    <module category="System" name="RXCAPT">
      <reg name="rxcapt_en" protect="rw">
        <comment></comment>
        <bits access="rw" name="rxcapt_en" pos="0" rst="0x0">
          <comment>
0
1</comment>
        </bits>
      </reg>
      <reg name="capt_cfg" protect="rw">
        <comment></comment>
        <bits access="rw" name="capt_dump" pos="4" rst="0x0">
          <comment>Dump
1
0</comment>
        </bits>
        <bits access="rw" name="capt_tx" pos="3" rst="0x0">
          <comment>Tx Trace
1
0</comment>
        </bits>
        <bits access="rw" name="capt_iddet_offline" pos="2" rst="0x0">
          <comment>IDDET offline
1
0</comment>
        </bits>
        <bits access="rw" name="capt_odtoa" pos="1" rst="0x0">
          <comment>ODTOA
1
0</comment>
        </bits>
        <bits access="rw" name="capt_rx" pos="0" rst="0x0">
          <comment>RX
1
0</comment>
        </bits>
      </reg>
      <reg name="fill_cfg1" protect="rw">
        <comment></comment>
        <bits access="rw" name="fill_len" pos="31:4" rst="0xfffffff">
          <comment></comment>
        </bits>
        <bits access="rw" name="fill_dl_offline" pos="3" rst="0x0">
          <comment>DL offline
1
0</comment>
        </bits>
        <bits access="rw" name="fill_div" pos="2:0" rst="0x0">
          <comment>
3h0:420M/15M
3h1:810M
3h2:165M
3h3:323M
3h4:641.4M
Others: 4</comment>
        </bits>
      </reg>
      <reg name="fill_cfg2" protect="rw">
        <comment>2</comment>
        <bits access="rw" name="fill_len" pos="31:4" rst="0xfffffff">
          <comment></comment>
        </bits>
        <bits access="rw" name="fill_iddet_offline" pos="3" rst="0x0">
          <comment>IDDET offline
1
0</comment>
        </bits>
        <bits access="rw" name="fill_div" pos="2:0" rst="0x0">
          <comment>
3h0:420M/15M
3h1:810M
3h2:165M
3h3:323M
3h4:641.4M
Others: 4</comment>
        </bits>
      </reg>
      <reg name="dma_req_en" protect="rw">
        <comment>DMA</comment>
        <bits access="rw" name="dma_req7_en" pos="7" rst="0x0">
          <comment>DMA_req7
1
0</comment>
        </bits>
        <bits access="rw" name="dma_req6_en" pos="6" rst="0x0">
          <comment>DMA_req6
1
0</comment>
        </bits>
        <bits access="rw" name="dma_req5_en" pos="5" rst="0x0">
          <comment>DMA_req5
1
0</comment>
        </bits>
        <bits access="rw" name="dma_req4_en" pos="4" rst="0x0">
          <comment>DMA_req4
1
0</comment>
        </bits>
        <bits access="rw" name="dma_req3_en" pos="3" rst="0x0">
          <comment>DMA_req3
1
0</comment>
        </bits>
        <bits access="rw" name="dma_req2_en" pos="2" rst="0x0">
          <comment>DMA_req2
1
0</comment>
        </bits>
        <bits access="rw" name="dma_req1_en" pos="1" rst="0x0">
          <comment>DMA_req1
1
0</comment>
        </bits>
        <bits access="rw" name="dma_req0_en" pos="0" rst="0x0">
          <comment>DMA_req0
1
0</comment>
        </bits>
      </reg>
      <reg name="irq_inten" protect="rw">
        <comment></comment>
        <bits access="rw" name="capt_err34" pos="13" rst="0x0">
          <comment>Capt_err34
1
0</comment>
        </bits>
        <bits access="rw" name="capt_err12" pos="12" rst="0x0">
          <comment>Capt_err12
1
0</comment>
        </bits>
        <bits access="rw" name="mem56_finish_irq" pos="10" rst="0x0">
          <comment>Mem56 finish
1
0</comment>
        </bits>
        <bits access="rw" name="mem56_pang_irq" pos="9" rst="0x0">
          <comment>Mem56 pang
1
0</comment>
        </bits>
        <bits access="rw" name="mem56_ping_irq" pos="8" rst="0x0">
          <comment>Mem56 ping
1
0</comment>
        </bits>
        <bits access="rw" name="mem34_finish_irq" pos="6" rst="0x0">
          <comment>Mem34 finish
1
0</comment>
        </bits>
        <bits access="rw" name="mem34_pang_irq" pos="5" rst="0x0">
          <comment>Mem34 pang
1
0</comment>
        </bits>
        <bits access="rw" name="mem34_ping_irq" pos="4" rst="0x0">
          <comment>Mem34 ping
1
0</comment>
        </bits>
        <bits access="rw" name="mem12_finish_irq" pos="2" rst="0x0">
          <comment>Mem12 finish
1
0</comment>
        </bits>
        <bits access="rw" name="mem12_pang_irq" pos="1" rst="0x0">
          <comment>Mem12 pang
1
0</comment>
        </bits>
        <bits access="rw" name="mem12_ping_irq" pos="0" rst="0x0">
          <comment>Mem12 ping
1
0</comment>
        </bits>
      </reg>
      <reg name="irq_inten_set" protect="rw">
        <comment></comment>
        <bits access="rs" name="capt_err34" pos="13" rst="0x0">
          <comment>Capt_err34
1
0</comment>
        </bits>
        <bits access="rs" name="capt_err12" pos="12" rst="0x0">
          <comment>Capt_err12
1
0</comment>
        </bits>
        <bits access="rs" name="mem56_finish_irq" pos="10" rst="0x0">
          <comment>Mem56 finish
1
0</comment>
        </bits>
        <bits access="rs" name="mem56_pang_irq" pos="9" rst="0x0">
          <comment>Mem56 pang
1
0</comment>
        </bits>
        <bits access="rs" name="mem56_ping_irq" pos="8" rst="0x0">
          <comment>Mem56 ping
1
0</comment>
        </bits>
        <bits access="rs" name="mem34_finish_irq" pos="6" rst="0x0">
          <comment>Mem34 finish
1
0</comment>
        </bits>
        <bits access="rs" name="mem34_pang_irq" pos="5" rst="0x0">
          <comment>Mem34 pang
1
0</comment>
        </bits>
        <bits access="rs" name="mem34_ping_irq" pos="4" rst="0x0">
          <comment>Mem34 ping
1
0</comment>
        </bits>
        <bits access="rs" name="mem12_finish_irq" pos="2" rst="0x0">
          <comment>Mem12 finish
1
0</comment>
        </bits>
        <bits access="rs" name="mem12_pang_irq" pos="1" rst="0x0">
          <comment>Mem12 pang
1
0</comment>
        </bits>
        <bits access="rs" name="mem12_ping_irq" pos="0" rst="0x0">
          <comment>Mem12 ping
1
0</comment>
        </bits>
      </reg>
      <reg name="irq_inten_clr" protect="rw">
        <comment></comment>
        <bits access="rc" name="capt_err34" pos="13" rst="0x0">
          <comment>Capt_err34
1
0</comment>
        </bits>
        <bits access="rc" name="capt_err12" pos="12" rst="0x0">
          <comment>Capt_err12
1
0</comment>
        </bits>
        <bits access="rc" name="mem56_finish_irq" pos="10" rst="0x0">
          <comment>Mem56 finish
1
0</comment>
        </bits>
        <bits access="rc" name="mem56_pang_irq" pos="9" rst="0x0">
          <comment>Mem56 pang
1
0</comment>
        </bits>
        <bits access="rc" name="mem56_ping_irq" pos="8" rst="0x0">
          <comment>Mem56 ping
1
0</comment>
        </bits>
        <bits access="rc" name="mem34_finish_irq" pos="6" rst="0x0">
          <comment>Mem34 finish
1
0</comment>
        </bits>
        <bits access="rc" name="mem34_pang_irq" pos="5" rst="0x0">
          <comment>Mem34 pang
1
0</comment>
        </bits>
        <bits access="rc" name="mem34_ping_irq" pos="4" rst="0x0">
          <comment>Mem34 ping
1
0</comment>
        </bits>
        <bits access="rc" name="mem12_finish_irq" pos="2" rst="0x0">
          <comment>Mem12 finish
1
0</comment>
        </bits>
        <bits access="rc" name="mem12_pang_irq" pos="1" rst="0x0">
          <comment>Mem12 pang
1
0</comment>
        </bits>
        <bits access="rc" name="mem12_ping_irq" pos="0" rst="0x0">
          <comment>Mem12 ping
1
0</comment>
        </bits>
      </reg>
      <reg name="irq_state" protect="rw">
        <comment></comment>
        <bits access="rc" name="capt_err34_irq" pos="13" rst="0x0">
          <comment>Capt_err34</comment>
        </bits>
        <bits access="rc" name="capt_err12_irq" pos="12" rst="0x0">
          <comment>Capt_err12</comment>
        </bits>
        <bits access="rc" name="mem56_finish_irq" pos="10" rst="0x0">
          <comment>Mem56 finish</comment>
        </bits>
        <bits access="rc" name="mem56_pang_irq" pos="9" rst="0x0">
          <comment>Mem56 pang</comment>
        </bits>
        <bits access="rc" name="mem56_ping_irq" pos="8" rst="0x0">
          <comment>Mem56 ping</comment>
        </bits>
        <bits access="rc" name="mem34_finish_irq" pos="6" rst="0x0">
          <comment>Mem34 finish</comment>
        </bits>
        <bits access="rc" name="mem34_pang_irq" pos="5" rst="0x0">
          <comment>Mem34 pang</comment>
        </bits>
        <bits access="rc" name="mem34_ping_irq" pos="4" rst="0x0">
          <comment>Mem34 ping</comment>
        </bits>
        <bits access="rc" name="mem12_finish_irq" pos="2" rst="0x0">
          <comment>Mem12 finish</comment>
        </bits>
        <bits access="rc" name="mem12_pang_irq" pos="1" rst="0x0">
          <comment>Mem12 pang</comment>
        </bits>
        <bits access="rc" name="mem12_ping_irq" pos="0" rst="0x0">
          <comment>Mem12 ping</comment>
        </bits>
      </reg>
      <reg name="capt_end_addr12" protect="rw">
        <comment>MEM12</comment>
        <bits access="rw" name="end_addr12" pos="10:0" rst="0x7cf">
          <comment>Mem12</comment>
        </bits>
      </reg>
      <reg name="capt_end_addr34" protect="rw">
        <comment>MEM34</comment>
        <bits access="rw" name="end_addr34" pos="8:0" rst="0x1f3">
          <comment>Mem34</comment>
        </bits>
      </reg>
      <reg name="fill_end_addr12" protect="rw">
        <comment>MEM12</comment>
        <bits access="rw" name="end_addr12" pos="10:0" rst="0x7ff">
          <comment>Mem12</comment>
        </bits>
      </reg>
      <reg name="fill_end_addr56" protect="rw">
        <comment>MEM56</comment>
        <bits access="rw" name="end_addr56" pos="9:0" rst="0x3ff">
          <comment>Mem56</comment>
        </bits>
      </reg>
      <reg name="norm_ctrl" protect="rw">
        <comment></comment>
      </reg>
      <reg name="state_mem12" protect="rw">
        <comment>MEM12</comment>
        <bits access="r" name="pang_sta" pos="30:28" rst="0x0">
          <comment>Mem12 pang
000IDLE
001MEM
010MEM
011DMA
100MEM
Others: IDLE</comment>
        </bits>
        <bits access="r" name="pang_addr" pos="26:16" rst="0x0">
          <comment>Mem12 pang</comment>
        </bits>
        <bits access="r" name="ping_sta" pos="14:12" rst="0x0">
          <comment>Mem12 ping
000IDLE
001MEM
010MEM
011DMA
100MEM
Others: IDLE</comment>
        </bits>
        <bits access="r" name="ping_addr" pos="10:0" rst="0x0">
          <comment>Mem12 ping</comment>
        </bits>
      </reg>
      <reg name="state_mem34" protect="rw">
        <comment>MEM34</comment>
        <bits access="r" name="pang_sta" pos="30:28" rst="0x0">
          <comment>Mem34 pang
000IDLE
001MEM
010MEM
011DMA
100MEM
Others: IDLE</comment>
        </bits>
        <bits access="r" name="pang_addr" pos="24:16" rst="0x0">
          <comment>Mem34 pang</comment>
        </bits>
        <bits access="r" name="ping_sta" pos="14:12" rst="0x0">
          <comment>Mem34 ping
000IDLE
001MEM
010MEM
011DMA
100MEM
Others: IDLE</comment>
        </bits>
        <bits access="r" name="ping_addr" pos="8:0" rst="0x0">
          <comment>Mem34 ping</comment>
        </bits>
      </reg>
      <reg name="state_mem56" protect="rw">
        <comment>MEM56</comment>
        <bits access="r" name="pang_sta" pos="30:28" rst="0x0">
          <comment>Mem56 pang
000IDLE
001MEM
010MEM
011DMA
100MEM
Others: IDLE</comment>
        </bits>
        <bits access="r" name="pang_addr" pos="25:16" rst="0x0">
          <comment>Mem56 pang</comment>
        </bits>
        <bits access="r" name="ping_sta" pos="14:12" rst="0x0">
          <comment>Mem56 ping
000IDLE
001MEM
010MEM
011DMA
100MEM
Others: IDLE</comment>
        </bits>
        <bits access="r" name="ping_addr" pos="9:0" rst="0x0">
          <comment>Mem56 ping</comment>
        </bits>
      </reg>
      <reg name="state_err12" protect="rw">
        <comment>EER12</comment>
        <bits access="r" name="which_mem" pos="24" rst="0x0">
          <comment>Err
0MEM12 Ping
1MEM12 Pang</comment>
        </bits>
        <bits access="r" name="err_fn" pos="23:0" rst="0x0">
          <comment>Error(ERR</comment>
        </bits>
      </reg>
      <reg name="state_err34" protect="rw">
        <comment>EER34</comment>
        <bits access="r" name="which_mem" pos="24" rst="0x0">
          <comment>Err
0MEM34 Ping
1MEM34 Pang</comment>
        </bits>
        <bits access="r" name="err_fn" pos="23:0" rst="0x0">
          <comment>Error(ERR</comment>
        </bits>
      </reg>
      <reg name="capt_sta" protect="rw">
        <comment></comment>
        <bits access="r" name="otdoa_sta" pos="17:16" rst="0x0">
          <comment>otdoa_sta
00
01OTDOA
10finish
11capt_cfg</comment>
        </bits>
        <bits access="r" name="iddet_sta" pos="13:12" rst="0x0">
          <comment>iddet_sta
00
01IDDET
10finish
11capt_cfg</comment>
        </bits>
        <bits access="r" name="tx_sta" pos="9:8" rst="0x0">
          <comment>tx_sta
00
01TX
10finish
11capt_cfg</comment>
        </bits>
        <bits access="r" name="dump_sta" pos="5:4" rst="0x0">
          <comment>dump_sta
00
01DUMP
10finish
11capt_cfg</comment>
        </bits>
        <bits access="r" name="rx_sta" pos="1:0" rst="0x0">
          <comment>rx_sta
00
01RX
10finish
11capt_cfg</comment>
        </bits>
      </reg>
      <reg name="fill1_sta1" protect="rw">
        <comment>DL offline1</comment>
        <bits access="r" name="fill_running_sta" pos="29:28" rst="0x0">
          <comment>fill_running_sta
00
01
10len
11fill_cfg</comment>
        </bits>
        <bits access="r" name="out_len" pos="27:0" rst="0x0">
          <comment>out_len
HWI/Q</comment>
        </bits>
      </reg>
      <reg name="fill1_sta2" protect="rw">
        <comment>DL offline2</comment>
        <bits access="r" name="in_len" pos="27:0" rst="0x0">
          <comment>in_len
DMAI/Q</comment>
        </bits>
      </reg>
      <reg name="fill2_sta1" protect="rw">
        <comment>IDDET offline1</comment>
        <bits access="r" name="fill_running_sta" pos="29:28" rst="0x0">
          <comment>fill_running_sta
00
01
10len
11fill_cfg</comment>
        </bits>
        <bits access="r" name="out_len" pos="27:0" rst="0x0">
          <comment>out_len
HWI/Q</comment>
        </bits>
      </reg>
      <reg name="fill2_sta2" protect="rw">
        <comment>IDDET offline2</comment>
        <bits access="r" name="in_len" pos="27:0" rst="0x0">
          <comment>in_len
DMAI/Q</comment>
        </bits>
      </reg>
      <reg name="dma_sta" protect="rw">
        <comment>DMA</comment>
        <bits access="r" name="ack_sta" pos="15:8" rst="0x0">
          <comment>DMA_ACK</comment>
        </bits>
        <bits access="r" name="req_sta" pos="7:0" rst="0x0">
          <comment>DMA_REQ</comment>
        </bits>
      </reg>
      <reg name="capt12_len" protect="rw">
        <bits access="r" name="current_len12" pos="23:0" rst="0x0"/>
      </reg>
      <reg name="capt34_len" protect="rw">
        <bits access="r" name="current_len34" pos="23:0" rst="0x0"/>
      </reg>
      <reg name="err_inten" protect="rw">
        <bits access="rw" name="err_inten_sr" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="err_inten_set" protect="rw">
        <bits access="rc" name="err_inten_set_sr" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="err_inten_clr" protect="rw">
        <bits access="rc" name="err_inten_clr_sr" pos="3:0" rst="0x0"/>
      </reg>
      <reg name="err_int_sta" protect="rw">
        <bits access="rc" name="err_int_sta" pos="3:0" rst="0x0"/>
      </reg>
      <hole size="523296"/>
      <reg name="mem12_ping" protect="rw">
        <bits access="rw" name="mem12_ping_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem12_ping_0" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem12_pang" protect="rw">
        <bits access="rw" name="mem12_pang_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem12_pang_0" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="65504"/>
      <reg name="mem34_ping" protect="rw">
        <bits access="rw" name="mem34_ping_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem34_ping_0" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="16352"/>
      <reg name="mem34_pang" protect="rw">
        <bits access="rw" name="mem34_pang_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem34_pang_0" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="16352"/>
      <reg name="mem56_ping" protect="rw">
        <bits access="rw" name="mem56_ping_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem56_ping_0" pos="15:4" rst="0x0"/>
      </reg>
      <hole size="32736"/>
      <reg name="mem56_pang" protect="rw">
        <bits access="rw" name="mem56_pang_1" pos="31:20" rst="0x0"/>
        <bits access="rw" name="mem56_pang_0" pos="15:4" rst="0x0"/>
      </reg>
    </module>
    <instance address="0x1a000000" name="RXCAPT" type="RXCAPT"/>
  </archive>
  <archive relative="pmic_adc.xml">
    <module category="System" name="PMIC_ADC">
      <reg name="auxadc_version" protect="rw">
        <comment>AUXADC IP version AUXADC IP version</comment>
        <bits access="r" name="auxadc_version" pos="15:0" rst="0x700">
          <comment>IP version r7p0</comment>
        </bits>
      </reg>
      <reg name="adc_cfg_ctrl" protect="rw">
        <comment>ADC ctrl information configure ADC ctrl information configure</comment>
        <bits access="rw" name="adc_offset_cal_en" pos="12" rst="0x0">
          <comment>Auxadc offset function enable
0: disable offset function
1: enable offset function</comment>
        </bits>
        <bits access="rw" name="rg_auxad_average" pos="10:8" rst="0x1">
          <comment>auxadc convert data out average control:
000: disable adc average, output 12bit data and valid after once conversion;
001: adc convert twice and output the average data;
010: adc convert 4 times and output the average data;
011: adc convert 8 times and output the average data;
100: adc convert 16 times and output the average data;
101: adc convert 32 times and output the average data;
110: adc convert 64 times and output the average data;
111: adc convert 128 times and output the average data;</comment>
        </bits>
        <bits access="rw" name="sw_ch_run_num" pos="7:4" rst="0x0">
          <comment>the number of SW channel accessing, N+1.</comment>
        </bits>
        <bits access="rw" name="adc_sign_code" pos="3" rst="0x0">
          <comment>AUXADC output code selection:
0:  adc_dout = (data-Doff)
1: if adc_offset_cal_en is 0
adc_dout = data
    if adc_offset_cal_en is 1
adc_dout = data-(Doff-2047)
more detail see Function Description</comment>
        </bits>
        <bits access="rw" name="adc_12b" pos="2" rst="0x1">
          <comment>ADC 12bits mode
0: ADC in 10bits mode;
1: ADC in 12bits mode.</comment>
        </bits>
        <bits access="rw" name="sw_ch_run" pos="1" rst="0x0">
          <comment>SW channel run,
Write '1' to run a SW channel accessing, it is cleared by HW.</comment>
        </bits>
        <bits access="rw" name="adc_en" pos="0" rst="0x0">
          <comment>ADC global enable,
0: ADC module disable;
1: ADC module enable.</comment>
        </bits>
      </reg>
      <reg name="adc_sw_ch_cfg" protect="rw">
        <comment>ADC SW channel configure  ADC SW channel configure</comment>
        <bits access="rw" name="adc_scale" pos="10:9" rst="0x0">
          <comment>ADC scale setting for current ADC channel</comment>
        </bits>
        <bits access="rw" name="adc_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="adc_cs" pos="4:0" rst="0x0">
          <comment>ADC software config channel ID.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch0_cfg" protect="rw">
        <comment>ADC fast HW channel0 configure  ADC fast HW channel0 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>ADC scale setting for current ADC channel</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch1_cfg" protect="rw">
        <comment>ADC fast HW channel1 configure  ADC fast HW channel1 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>ADC scale setting for current ADC channel</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch2_cfg" protect="rw">
        <comment>ADC fast HW channel2 configure  ADC fast HW channel2 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>ADC scale setting for current ADC channel</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch3_cfg" protect="rw">
        <comment>ADC fast HW channel3 configure  ADC fast HW channel3 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch4_cfg" protect="rw">
        <comment>ADC fast HW channel4 configure  ADC fast HW channel4 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch5_cfg" protect="rw">
        <comment>ADC fast HW channel5 configure  ADC fast HW channel5 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch6_cfg" protect="rw">
        <comment>ADC fast HW channel6 configure  ADC fast HW channel6 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch7_cfg" protect="rw">
        <comment>ADC fast HW channel7 configure  ADC fast HW channel7 configure</comment>
        <bits access="rw" name="frq_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="frq_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="frq_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="frq_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch0_cfg" protect="rw">
        <comment>ADC slow HW channel0 configure  ADC slow HW channel0 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch1_cfg" protect="rw">
        <comment>ADC slow HW channel1 configure  ADC slow HW channel1 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch2_cfg" protect="rw">
        <comment>ADC slow HW channel2 configure  ADC slow HW channel2 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch3_cfg" protect="rw">
        <comment>ADC slow HW channel3 configure  ADC slow HW channel3 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch4_cfg" protect="rw">
        <comment>ADC slow HW channel4 configure  ADC slow HW channel4 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch5_cfg" protect="rw">
        <comment>ADC slow HW channel5 configure  ADC slow HW channel5 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch6_cfg" protect="rw">
        <comment>ADC slow HW channel6 configure  ADC slow HW channel6 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_slow_hw_ch7_cfg" protect="rw">
        <comment>ADC slow HW channel7 configure  ADC slow HW channel7 configure</comment>
        <bits access="rw" name="req_scale" pos="10:9" rst="0x0">
          <comment>output the analog</comment>
        </bits>
        <bits access="rw" name="req_delay_en" pos="7" rst="0x0">
          <comment>current channel delay enable, 0-diable; 1-enable.</comment>
        </bits>
        <bits access="rw" name="req_slow" pos="6" rst="0x0">
          <comment>ADC conversion speed control:
0: quick mode, conversion initial includes 50 ADC clocks;
1: slow mode, conversion initial includes 70 ADC clocks.</comment>
        </bits>
        <bits access="rw" name="req_cs" pos="4:0" rst="0x0">
          <comment>ADC channel ID</comment>
        </bits>
      </reg>
      <reg name="adc_hw_ch_delay" protect="rw">
        <comment>ADC HW channel accessing dealy ADC HW channel accessing dealy</comment>
        <bits access="rw" name="hw_ch_delay" pos="7:0" rst="0x0">
          <comment>ADC HW channel accessing delay, its unit is ADC clock.
It can be use for signal without enough setup time.</comment>
        </bits>
      </reg>
      <reg name="adc_dat" protect="rw">
        <comment>ADC conversion result ADC conversion result</comment>
        <bits access="r" name="adc_dat_sw" pos="11:0" rst="0x0">
          <comment>ADC conversion result.</comment>
        </bits>
      </reg>
      <reg name="adc_cfg_int_en" protect="rw">
        <comment>ADC interrupt enable ADC interrupt enable</comment>
        <bits access="rw" name="adc_int_en" pos="0" rst="0x0">
          <comment>ADC interrupt enable, 0: disable; 1: enable.</comment>
        </bits>
      </reg>
      <reg name="adc_cfg_int_clr" protect="rw">
        <comment>ADC interrupt clear ADC interrupt clear</comment>
        <bits access="w" name="adc_int_clr" pos="0" rst="0x0">
          <comment>ADC interrupt clear. Write &quot;1&quot; to clear.</comment>
        </bits>
      </reg>
      <reg name="adc_cfg_int_sattus" protect="rw">
        <comment>ADC masked interrupt ADC masked interrupt</comment>
        <bits access="r" name="adc_int_status" pos="0" rst="0x0">
          <comment>ADC masked interrupt.</comment>
        </bits>
      </reg>
      <reg name="adc_cfg_int_raw" protect="rw">
        <comment>ADC raw interrupt ADC raw interrupt</comment>
        <bits access="r" name="adc_int_raw" pos="0" rst="0x0">
          <comment>ADC raw interrupt.</comment>
        </bits>
      </reg>
      <reg name="adc_debug" protect="rw">
        <comment>ADC debug information ADC debug information</comment>
        <bits access="r" name="adc_dbg_ch" pos="15:11" rst="0x0">
          <comment>0~7: fast HW channels;
8: SW channels;
9~16: slow HW channel;
31: no request.</comment>
        </bits>
        <bits access="r" name="adc_dbg_state" pos="10:8" rst="0x0">
          <comment>ADC accessing state:
0: idle;
1: fast HW request;
2: SW request;
3: slow HW request;
4: wait for fast HW request;
5: wait for slow HW request.</comment>
        </bits>
        <bits access="r" name="adc_dbg_cnt" pos="7:0" rst="0x0">
          <comment>ADC internal counter status, 0: idle; 1~n: work or wait counter.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_timer_en" protect="rw">
        <comment>ADC fast HW channel timer enable ADC fast HW channel timer enable</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch7_timer_en" pos="7" rst="0x0">
          <comment>ADC fast HW channel7 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch6_timer_en" pos="6" rst="0x0">
          <comment>ADC fast HW channel6 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch5_timer_en" pos="5" rst="0x0">
          <comment>ADC fast HW channel5 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch4_timer_en" pos="4" rst="0x0">
          <comment>ADC fast HW channel4 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch3_timer_en" pos="3" rst="0x0">
          <comment>ADC fast HW channel3 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch2_timer_en" pos="2" rst="0x0">
          <comment>ADC fast HW channel2 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch1_timer_en" pos="1" rst="0x0">
          <comment>ADC fast HW channel1 timer enable, 0:disable; 1: enable.</comment>
        </bits>
        <bits access="rw" name="rg_adc_fast_hw_ch0_timer_en" pos="0" rst="0x0">
          <comment>ADC fast HW channel0 timer enable, 0:disable; 1: enable.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_timer_div" protect="rw">
        <comment>ADC fast HW channel timer working clock divider ADC fast HW channel timer working clock divider</comment>
        <bits access="rw" name="rg_adc_fast_hw_timer_div" pos="15:0" rst="0x0">
          <comment>ADC fast HW channel timer working clock divider.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch0_timer_thresh" protect="rw">
        <comment>ADC fast HW channel0 timer threshold ADC fast HW channel0 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch0_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch0 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch1_timer_thresh" protect="rw">
        <comment>ADC fast HW channel1 timer threshold ADC fast HW channel1 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch1_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch1 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch2_timer_thresh" protect="rw">
        <comment>ADC fast HW channel2 timer threshold ADC fast HW channel2 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch2_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch2 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch3_timer_thresh" protect="rw">
        <comment>ADC fast HW channel3 timer threshold ADC fast HW channel3 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch3_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch3 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch4_timer_thresh" protect="rw">
        <comment>ADC fast HW channel4 timer threshold ADC fast HW channel4 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch4_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch4 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch5_timer_thresh" protect="rw">
        <comment>ADC fast HW channel5 timer threshold ADC fast HW channel5 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch5_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch5 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch6_timer_thresh" protect="rw">
        <comment>ADC fast HW channel6 timer threshold ADC fast HW channel6 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch6_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch6 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch7_timer_thresh" protect="rw">
        <comment>ADC fast HW channel7 timer threshold ADC fast HW channel7 timer threshold</comment>
        <bits access="rw" name="rg_adc_fast_hw_ch7_timer_thresh" pos="15:0" rst="0x0">
          <comment>ADC fast HW ch7 timer threshold.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch0_dat" protect="rw">
        <comment>ADC fast HW channel0 data ADC fast HW channel0 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch0 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch1_dat" protect="rw">
        <comment>ADC fast HW channel1 data ADC fast HW channel1 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch1 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch2_dat" protect="rw">
        <comment>ADC fast HW channel2 data ADC fast HW channel2 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch2 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch3_dat" protect="rw">
        <comment>ADC fast HW channel3 data ADC fast HW channel3 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch3 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch4_dat" protect="rw">
        <comment>ADC fast HW channel4 data ADC fast HW channel4 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch4 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch5_dat" protect="rw">
        <comment>ADC fast HW channel5 data ADC fast HW channel5 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch5 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch6_dat" protect="rw">
        <comment>ADC fast HW channel6 data ADC fast HW channel6 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch6 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_ch7_dat" protect="rw">
        <comment>ADC fast HW channel7 data ADC fast HW channel7 data</comment>
        <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0x0">
          <comment>ADC fast HW ch7 data, read twice, and capture the second value.</comment>
        </bits>
      </reg>
      <reg name="auxadc_ctrl0" protect="rw">
        <comment>ADC NTC ctrl information ADC NTC ctrl information</comment>
        <bits access="rw" name="rg_auxad_ref_sel" pos="5" rst="0x0">
          <comment>output to analog</comment>
        </bits>
        <bits access="rw" name="rg_auxad_thm_cal" pos="4" rst="0x0">
          <comment>output to analog
THM calibration enable signal,
0: disable THM calibration(default)
1: enable THM calibration, must set high 100us before AUXADC measure THM voltage and start the calibration</comment>
        </bits>
        <bits access="rw" name="rg_auxad_currentsen_en" pos="0" rst="0x0">
          <comment>output to analog
Aux ADC current sense enable signal, active high, default 0.</comment>
        </bits>
      </reg>
      <reg name="adc_fast_hw_dvalid" protect="rw">
        <comment>ADC fast HW channel data valid ADC fast HW channel data valid</comment>
        <bits access="r" name="rg_adc_fast_hw_ch7_dvld" pos="7" rst="0x0">
          <comment>ADC fast HW channel7 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch6_dvld" pos="6" rst="0x0">
          <comment>ADC fast HW channel6 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch5_dvld" pos="5" rst="0x0">
          <comment>ADC fast HW channel5 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch4_dvld" pos="4" rst="0x0">
          <comment>ADC fast HW channel4 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch3_dvld" pos="3" rst="0x0">
          <comment>ADC fast HW channel3 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch2_dvld" pos="2" rst="0x0">
          <comment>ADC fast HW channel2 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch1_dvld" pos="1" rst="0x0">
          <comment>ADC fast HW channel1 data valid.</comment>
        </bits>
        <bits access="r" name="rg_adc_fast_hw_ch0_dvld" pos="0" rst="0x0">
          <comment>ADC fast HW channel0 data valid.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108100" name="PMIC_ADC" type="PMIC_ADC"/>
  </archive>
  <archive relative="pmic_bltc.xml">
    <module category="System" name="PMIC_BLTC">
      <reg name="bltc_ctl" protect="rw">
        <comment>BLTC control 1. BLTC output select
2. BLTC output select(1: output by SW, 0: output by HW);
3. BLTC output type select (1: normal PWM, 0: breath light);
4, BLTC run enable signal</comment>
        <bits access="rw" name="wled_sw" pos="15" rst="0x0">
          <comment>BLTC WLED output value when by SW.</comment>
        </bits>
        <bits access="rw" name="wled_sel" pos="14" rst="0x0">
          <comment>BLTC WLED output selection</comment>
        </bits>
        <bits access="rw" name="wled_type" pos="13" rst="0x0">
          <comment>BLTC WLED output type</comment>
        </bits>
        <bits access="rw" name="wled_run" pos="12" rst="0x0">
          <comment>BLTC WLED run</comment>
        </bits>
        <bits access="rw" name="b_sw" pos="11" rst="0x0">
          <comment>BLTC B output value when by SW.</comment>
        </bits>
        <bits access="rw" name="b_sel" pos="10" rst="0x0">
          <comment>BLTC B output selection</comment>
        </bits>
        <bits access="rw" name="b_type" pos="9" rst="0x0">
          <comment>BLTC B output type</comment>
        </bits>
        <bits access="rw" name="b_run" pos="8" rst="0x0">
          <comment>BLTC B run</comment>
        </bits>
        <bits access="rw" name="g_sw" pos="7" rst="0x0">
          <comment>BLTC G output value when by SW.</comment>
        </bits>
        <bits access="rw" name="g_sel" pos="6" rst="0x0">
          <comment>BLTC G output selection</comment>
        </bits>
        <bits access="rw" name="g_type" pos="5" rst="0x0">
          <comment>BLTC G output type</comment>
        </bits>
        <bits access="rw" name="g_run" pos="4" rst="0x0">
          <comment>BLTC G run</comment>
        </bits>
        <bits access="rw" name="r_sw" pos="3" rst="0x0">
          <comment>BLTC R output value when by SW.</comment>
        </bits>
        <bits access="rw" name="r_sel" pos="2" rst="0x0">
          <comment>BLTC R output selection</comment>
        </bits>
        <bits access="rw" name="r_type" pos="1" rst="0x0">
          <comment>BLTC R output type</comment>
        </bits>
        <bits access="rw" name="r_run" pos="0" rst="0x0">
          <comment>BLTC R run</comment>
        </bits>
      </reg>
      <reg name="bltc_r_prescale" protect="rw">
        <comment>BLTC R prescale coefficient PWM prescale coefficient for work clock.</comment>
        <bits access="rw" name="prescl" pos="7:0" rst="0x0">
          <comment>BLTC prescale coefficient.</comment>
        </bits>
      </reg>
      <reg name="bltc_r_duty" protect="rw">
        <comment>BLTC R duty config PWM duty config.</comment>
        <bits access="rw" name="duty" pos="15:8" rst="0x0">
          <comment>PWM duty counter,duty cycle = duty /(mod+1)</comment>
        </bits>
        <bits access="rw" name="mode" pos="7:0" rst="0x0">
          <comment>PWM mod counter.</comment>
        </bits>
      </reg>
      <reg name="bltc_r_curve0" protect="rw">
        <comment>BLTC R rise/fall config BLTC R rise/fall config</comment>
        <bits access="rw" name="tfall" pos="13:8" rst="0x0">
          <comment>Output falling time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="trise" pos="5:0" rst="0x0">
          <comment>Output rising time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_r_curve1" protect="rw">
        <comment>BLTC R high/low config BLTC R high/low config</comment>
        <bits access="rw" name="tlow" pos="15:8" rst="0x0">
          <comment>Output low time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="thigh" pos="7:0" rst="0x0">
          <comment>Output  high time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_g_prescale" protect="rw">
        <comment>BLTC G prescale coefficient PWM prescale coefficient for work clock.</comment>
        <bits access="rw" name="prescl" pos="7:0" rst="0x0">
          <comment>BLTC prescale coefficient.</comment>
        </bits>
      </reg>
      <reg name="bltc_g_duty" protect="rw">
        <comment>BLTC G duty config PWM duty config.</comment>
        <bits access="rw" name="duty" pos="15:8" rst="0x0">
          <comment>PWM duty counter,duty cycle = duty /(mod+1)</comment>
        </bits>
        <bits access="rw" name="mode" pos="7:0" rst="0x0">
          <comment>PWM mod counter.</comment>
        </bits>
      </reg>
      <reg name="bltc_g_curve0" protect="rw">
        <comment>BLTC G rise/fall config BLTC G rise/fall config</comment>
        <bits access="rw" name="tfall" pos="13:8" rst="0x0">
          <comment>Output falling time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="trise" pos="5:0" rst="0x0">
          <comment>Output rising time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_g_curve1" protect="rw">
        <comment>BLTC G high/low config BLTC G high/low config</comment>
        <bits access="rw" name="tlow" pos="15:8" rst="0x0">
          <comment>Output low time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="thigh" pos="7:0" rst="0x0">
          <comment>Output  high time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_b_prescale" protect="rw">
        <comment>BLTC B prescale coefficient PWM prescale coefficient for work clock.</comment>
        <bits access="rw" name="prescl" pos="7:0" rst="0x0">
          <comment>BLTC prescale coefficient.</comment>
        </bits>
      </reg>
      <reg name="bltc_b_duty" protect="rw">
        <comment>BLTC B duty config PWM duty config.</comment>
        <bits access="rw" name="duty" pos="15:8" rst="0x0">
          <comment>PWM duty counter,duty cycle = duty /(mod+1)</comment>
        </bits>
        <bits access="rw" name="mode" pos="7:0" rst="0x0">
          <comment>PWM mod counter.</comment>
        </bits>
      </reg>
      <reg name="bltc_b_curve0" protect="rw">
        <comment>BLTC B rise/fall config BLTC B rise/fall config</comment>
        <bits access="rw" name="tfall" pos="13:8" rst="0x0">
          <comment>Output falling time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="trise" pos="5:0" rst="0x0">
          <comment>Output rising time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_b_curve1" protect="rw">
        <comment>BLTC B high/low config BLTC B high/low config</comment>
        <bits access="rw" name="tlow" pos="15:8" rst="0x0">
          <comment>Output low time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="thigh" pos="7:0" rst="0x0">
          <comment>Output  high time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_sts" protect="rw">
        <comment>BLTC status BLTC status</comment>
        <bits access="r" name="bltc_wled_busy" pos="3" rst="0x0">
          <comment>BLTC WLED busy, active high.</comment>
        </bits>
        <bits access="r" name="bltc_b_busy" pos="2" rst="0x0">
          <comment>BLTC B busy, active high.</comment>
        </bits>
        <bits access="r" name="bltc_g_busy" pos="1" rst="0x0">
          <comment>BLTC G busy, active high.</comment>
        </bits>
        <bits access="r" name="bltc_r_busy" pos="0" rst="0x0">
          <comment>BLTC R busy, active high.</comment>
        </bits>
      </reg>
      <reg name="bltc_r_isat" protect="rw">
        <comment>BLTC R current strength config. BLTC current strength config.</comment>
        <bits access="rw" name="isat" pos="5:0" rst="0x0">
          <comment>Current strength config.</comment>
        </bits>
      </reg>
      <reg name="bltc_g_isat" protect="rw">
        <comment>BLTC G current strength config. BLTC current strength config.</comment>
        <bits access="rw" name="isat" pos="5:0" rst="0x0">
          <comment>Current strength config.</comment>
        </bits>
      </reg>
      <reg name="bltc_b_isat" protect="rw">
        <comment>BLTC B current strength config. BLTC current strength config.</comment>
        <bits access="rw" name="isat" pos="5:0" rst="0x0">
          <comment>Current strength config.</comment>
        </bits>
      </reg>
      <reg name="bltc_wled_isat" protect="rw">
        <comment>BLTC WLED current strength config. BLTC current strength config.</comment>
        <bits access="rw" name="isat" pos="5:0" rst="0x0">
          <comment>Current strength config.</comment>
        </bits>
      </reg>
      <reg name="bltc_wled_prescale" protect="rw">
        <comment>BLTC WLED prescale coefficient PWM prescale coefficient for work clock.</comment>
        <bits access="rw" name="prescl" pos="7:0" rst="0x0">
          <comment>BLTC prescale coefficient.</comment>
        </bits>
      </reg>
      <reg name="bltc_wled_duty" protect="rw">
        <comment>BLTC WLED duty config PWM duty config.</comment>
        <bits access="rw" name="duty" pos="15:8" rst="0x0">
          <comment>PWM duty counter,duty cycle = duty /(mod+1)</comment>
        </bits>
        <bits access="rw" name="mode" pos="7:0" rst="0x0">
          <comment>PWM mod counter.</comment>
        </bits>
      </reg>
      <reg name="bltc_wled_curve0" protect="rw">
        <comment>BLTC WLED rise/fall config BLTC WLED rise/fall config</comment>
        <bits access="rw" name="tfall" pos="13:8" rst="0x0">
          <comment>Output falling time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="trise" pos="5:0" rst="0x0">
          <comment>Output rising time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_wled_curve1" protect="rw">
        <comment>BLTC WLED high/low config BLTC WLED high/low config</comment>
        <bits access="rw" name="tlow" pos="15:8" rst="0x0">
          <comment>Output low time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
        <bits access="rw" name="thigh" pos="7:0" rst="0x0">
          <comment>Output  high time, its unit is 0.125s, it should be &gt;0.</comment>
        </bits>
      </reg>
      <reg name="bltc_pd_ctrl" protect="rw">
        <comment>BLTC current strength config. BLTC current strength config.</comment>
        <bits access="rw" name="hw_pd" pos="1" rst="0x1">
          <comment>Power down signal</comment>
        </bits>
        <bits access="rw" name="sw_pd" pos="0" rst="0x1">
          <comment>Power down signal</comment>
        </bits>
      </reg>
      <reg name="bltc_version" protect="rw">
        <comment>BLTC version BLTC WLED high/low config</comment>
        <bits access="rw" name="bltc_version" pos="15:0" rst="0x0">
          <comment>bltc version information</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108080" name="PMIC_BLTC" type="PMIC_BLTC"/>
  </archive>
  <archive relative="pmic_efuse.xml">
    <module category="System" name="PMIC_EFUSE">
      <reg name="efuse_glb_ctrl" protect="rw">
        <comment>efuse global control register</comment>
        <bits access="rw" name="efuse_clk_gate" pos="3" rst="0x1">
          <comment>Control efs_clk gate
1: gate efs_clk</comment>
        </bits>
        <bits access="rw" name="efuse_type" pos="2:1">
          <comment>Efuse type select, 00:TSMC default</comment>
        </bits>
        <bits access="rw" name="efuse_pgm_en" pos="0">
          <comment>Efuse SW programme enable</comment>
        </bits>
      </reg>
      <reg name="efuse_data_rd" protect="rw">
        <comment>Data read from efuse memory</comment>
        <bits access="r" name="efuse_data_rd" pos="15:0">
          <comment>Efuse read data,
If SW  use efuse controller to send a read command to efuse memory, the return value will store here.</comment>
        </bits>
      </reg>
      <reg name="efuse_data_wr" protect="rw">
        <comment>Data to be write to efuse memory</comment>
        <bits access="rw" name="efuse_data_wr" pos="15:0">
          <comment>Efuse data to be write.
If SW want to program the efuse memory, the data to be programmed  will write to this register before SW issue a PGM command.</comment>
        </bits>
      </reg>
      <reg name="efuse_addr_index" protect="rw">
        <comment>block index for read, program</comment>
        <bits access="rw" name="read_write_index" pos="5:0">
          <comment>The efuse memory block index to be read or write.</comment>
        </bits>
      </reg>
      <reg name="efuse_mode_ctrl" protect="rw">
        <comment>Mode control of efuse memory</comment>
        <bits access="w" name="efuse_normal_rd_flag_clr" pos="2">
          <comment>Write 1 to this bit will clear normal read flag.This bit is self-clear, read this bit will always get 0</comment>
        </bits>
        <bits access="w" name="efuse_rd_start" pos="1">
          <comment>Write 1 to this bit start READ mode(read mode).This bit is self-clear, read this bit will always get 0</comment>
        </bits>
        <bits access="w" name="efuse_pg_start" pos="0">
          <comment>Write 1 to this bit start PGM mode(PGM mode). This bit is self-clear, read this bit will always get 0</comment>
        </bits>
      </reg>
      <reg name="efuse_status" protect="rw">
        <comment>Efuse controller internal status</comment>
        <bits access="r" name="efuse_normal_rd_done" pos="4">
          <comment>1 indicate EFUSE normal read has been done</comment>
        </bits>
        <bits access="r" name="efuse_global_prot" pos="3">
          <comment>If SW send a PGM command to memory and memory controller find the memory need to be protected (LSB of 64 bit is 1), this flag will be set to 1.</comment>
        </bits>
        <bits access="r" name="standby_busy" pos="2" rst="0x1">
          <comment>1 indicate efuse memory in standby mode</comment>
        </bits>
        <bits access="r" name="read_busy" pos="1">
          <comment>1 indicate efuse memory in read mode</comment>
        </bits>
        <bits access="r" name="pgm_busy" pos="0">
          <comment>1 indicate efuse memory in programming mode</comment>
        </bits>
      </reg>
      <reg name="efuse_magic_number" protect="rw">
        <comment>magic number to protect efuse from un-intentionally programming</comment>
        <bits access="rw" name="efuse_magic_number" pos="15:0">
          <comment>Magic number, only when this field is  0x7520, the Efuse programming command can be handle.
So if SW want to program efuse memory, except open clocks and power, 2 other  conditions must be met :
a) PGM_EN =1;
b) EFUSE_MAGIC_NUMBER = 0x7520</comment>
        </bits>
      </reg>
      <reg name="efuse_margin_magic_number" protect="rw">
        <comment>magic number to protect efuse from un-intentionally programming</comment>
        <bits access="rw" name="efuse_margin_magic_number" pos="15:0">
          <comment>Magic number, only when this field is  0x6688,  the margin read is usable.</comment>
        </bits>
      </reg>
      <reg name="efuse_wr_timing_ctrl" protect="rw">
        <comment>Write command timing control</comment>
        <bits access="rw" name="efuse_wr_timing_ctrl" pos="15:0" rst="0x5d91">
          <comment>Config this register to control the timing of writing operation related signals</comment>
        </bits>
      </reg>
      <reg name="efuse_rd_timing_ctrl" protect="rw">
        <comment>Read command timing control</comment>
        <bits access="rw" name="efuse_rd_timing_ctrl" pos="15:0" rst="0x3e">
          <comment>Config this register to control the timing of writing operation related signals</comment>
        </bits>
      </reg>
      <reg name="efuse_version" protect="rw">
        <comment>EFUSE control version registers</comment>
        <bits access="r" name="efuse_version" pos="15:0" rst="0x100">
          <comment>Efuse control version register</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="efuse_por_blk00" protect="rw">
        <comment>EFUSE POR READ BLK00</comment>
        <bits access="r" name="efuse_por_blk00" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk01" protect="rw">
        <comment>EFUSE POR READ BLK01</comment>
        <bits access="r" name="efuse_por_blk01" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk02" protect="rw">
        <comment>EFUSE POR READ BLK02</comment>
        <bits access="r" name="efuse_por_blk02" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk03" protect="rw">
        <comment>EFUSE POR READ BLK03</comment>
        <bits access="r" name="efuse_por_blk03" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk04" protect="rw">
        <comment>EFUSE POR READ BLK04</comment>
        <bits access="r" name="efuse_por_blk04" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk05" protect="rw">
        <comment>EFUSE POR READ BLK05</comment>
        <bits access="r" name="efuse_por_blk05" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk06" protect="rw">
        <comment>EFUSE POR READ BLK06</comment>
        <bits access="r" name="efuse_por_blk06" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk07" protect="rw">
        <comment>EFUSE POR READ BLK07</comment>
        <bits access="r" name="efuse_por_blk07" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk08" protect="rw">
        <comment>EFUSE POR READ BLK08</comment>
        <bits access="r" name="efuse_por_blk08" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk09" protect="rw">
        <comment>EFUSE POR READ BLK09</comment>
        <bits access="r" name="efuse_por_blk09" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk10" protect="rw">
        <comment>EFUSE POR READ BLK10</comment>
        <bits access="r" name="efuse_por_blk10" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk11" protect="rw">
        <comment>EFUSE POR READ BLK11</comment>
        <bits access="r" name="efuse_por_blk11" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk12" protect="rw">
        <comment>EFUSE POR READ BLK12</comment>
        <bits access="r" name="efuse_por_blk12" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk13" protect="rw">
        <comment>EFUSE POR READ BLK13</comment>
        <bits access="r" name="efuse_por_blk13" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk14" protect="rw">
        <comment>EFUSE POR READ BLK14</comment>
        <bits access="r" name="efuse_por_blk14" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk15" protect="rw">
        <comment>EFUSE POR READ BLK15</comment>
        <bits access="r" name="efuse_por_blk15" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk16" protect="rw">
        <comment>EFUSE POR READ BLK16</comment>
        <bits access="r" name="efuse_por_blk16" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk17" protect="rw">
        <comment>EFUSE POR READ BLK17</comment>
        <bits access="r" name="efuse_por_blk17" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk18" protect="rw">
        <comment>EFUSE POR READ BLK18</comment>
        <bits access="r" name="efuse_por_blk18" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk19" protect="rw">
        <comment>EFUSE POR READ BLK19</comment>
        <bits access="r" name="efuse_por_blk19" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk20" protect="rw">
        <comment>EFUSE POR READ BLK20</comment>
        <bits access="r" name="efuse_por_blk20" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk21" protect="rw">
        <comment>EFUSE POR READ BLK21</comment>
        <bits access="r" name="efuse_por_blk21" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk22" protect="rw">
        <comment>EFUSE POR READ BLK22</comment>
        <bits access="r" name="efuse_por_blk22" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk23" protect="rw">
        <comment>EFUSE POR READ BLK23</comment>
        <bits access="r" name="efuse_por_blk23" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk24" protect="rw">
        <comment>EFUSE POR READ BLK24</comment>
        <bits access="r" name="efuse_por_blk24" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk25" protect="rw">
        <comment>EFUSE POR READ BLK25</comment>
        <bits access="r" name="efuse_por_blk25" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk26" protect="rw">
        <comment>EFUSE POR READ BLK26</comment>
        <bits access="r" name="efuse_por_blk26" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk27" protect="rw">
        <comment>EFUSE POR READ BLK27</comment>
        <bits access="r" name="efuse_por_blk27" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk28" protect="rw">
        <comment>EFUSE POR READ BLK28</comment>
        <bits access="r" name="efuse_por_blk28" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk29" protect="rw">
        <comment>EFUSE POR READ BLK29</comment>
        <bits access="r" name="efuse_por_blk29" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk30" protect="rw">
        <comment>EFUSE POR READ BLK30</comment>
        <bits access="r" name="efuse_por_blk30" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk31" protect="rw">
        <comment>EFUSE POR READ BLK31</comment>
        <bits access="r" name="efuse_por_blk31" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk32" protect="rw">
        <comment>EFUSE POR READ BLK32</comment>
        <bits access="r" name="efuse_por_blk32" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk33" protect="rw">
        <comment>EFUSE POR READ BLK33</comment>
        <bits access="r" name="efuse_por_blk33" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk34" protect="rw">
        <comment>EFUSE POR READ BLK34</comment>
        <bits access="r" name="efuse_por_blk34" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk35" protect="rw">
        <comment>EFUSE POR READ BLK35</comment>
        <bits access="r" name="efuse_por_blk35" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk36" protect="rw">
        <comment>EFUSE POR READ BLK36</comment>
        <bits access="r" name="efuse_por_blk36" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk37" protect="rw">
        <comment>EFUSE POR READ BLK37</comment>
        <bits access="r" name="efuse_por_blk37" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk38" protect="rw">
        <comment>EFUSE POR READ BLK38</comment>
        <bits access="r" name="efuse_por_blk38" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk39" protect="rw">
        <comment>EFUSE POR READ BLK39</comment>
        <bits access="r" name="efuse_por_blk39" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk40" protect="rw">
        <comment>EFUSE POR READ BLK40</comment>
        <bits access="r" name="efuse_por_blk40" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk41" protect="rw">
        <comment>EFUSE POR READ BLK41</comment>
        <bits access="r" name="efuse_por_blk41" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk42" protect="rw">
        <comment>EFUSE POR READ BLK42</comment>
        <bits access="r" name="efuse_por_blk42" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk43" protect="rw">
        <comment>EFUSE POR READ BLK43</comment>
        <bits access="r" name="efuse_por_blk43" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk44" protect="rw">
        <comment>EFUSE POR READ BLK44</comment>
        <bits access="r" name="efuse_por_blk44" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk45" protect="rw">
        <comment>EFUSE POR READ BLK45</comment>
        <bits access="r" name="efuse_por_blk45" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk46" protect="rw">
        <comment>EFUSE POR READ BLK46</comment>
        <bits access="r" name="efuse_por_blk46" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk47" protect="rw">
        <comment>EFUSE POR READ BLK47</comment>
        <bits access="r" name="efuse_por_blk47" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk48" protect="rw">
        <comment>EFUSE POR READ BLK48</comment>
        <bits access="r" name="efuse_por_blk48" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk49" protect="rw">
        <comment>EFUSE POR READ BLK49</comment>
        <bits access="r" name="efuse_por_blk49" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk50" protect="rw">
        <comment>EFUSE POR READ BLK50</comment>
        <bits access="r" name="efuse_por_blk50" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk51" protect="rw">
        <comment>EFUSE POR READ BLK51</comment>
        <bits access="r" name="efuse_por_blk51" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk52" protect="rw">
        <comment>EFUSE POR READ BLK52</comment>
        <bits access="r" name="efuse_por_blk52" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk53" protect="rw">
        <comment>EFUSE POR READ BLK53</comment>
        <bits access="r" name="efuse_por_blk53" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk54" protect="rw">
        <comment>EFUSE POR READ BLK54</comment>
        <bits access="r" name="efuse_por_blk54" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk55" protect="rw">
        <comment>EFUSE POR READ BLK55</comment>
        <bits access="r" name="efuse_por_blk55" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk56" protect="rw">
        <comment>EFUSE POR READ BLK56</comment>
        <bits access="r" name="efuse_por_blk56" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk57" protect="rw">
        <comment>EFUSE POR READ BLK57</comment>
        <bits access="r" name="efuse_por_blk57" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk58" protect="rw">
        <comment>EFUSE POR READ BLK58</comment>
        <bits access="r" name="efuse_por_blk58" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk59" protect="rw">
        <comment>EFUSE POR READ BLK59</comment>
        <bits access="r" name="efuse_por_blk59" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk60" protect="rw">
        <comment>EFUSE POR READ BLK60</comment>
        <bits access="r" name="efuse_por_blk60" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk61" protect="rw">
        <comment>EFUSE POR READ BLK61</comment>
        <bits access="r" name="efuse_por_blk61" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk62" protect="rw">
        <comment>EFUSE POR READ BLK62</comment>
        <bits access="r" name="efuse_por_blk62" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
      <reg name="efuse_por_blk63" protect="rw">
        <comment>EFUSE POR READ BLK63</comment>
        <bits access="r" name="efuse_por_blk63" pos="15:0" rst="0x0">
          <comment>should be the efuse macro value</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108200" name="PMIC_EFUSE" type="PMIC_EFUSE"/>
  </archive>
  <archive relative="pmic_eic.xml">
    <module category="System" name="PMIC_EIC">
      <reg name="eic_dbnc_data" protect="rw">
        <comment>EIC_DBNC bits data register, read only</comment>
        <bits access="r" name="dbnc_data" pos="15:0" rst="0x0">
          <comment>EIC_DBNC bits data input</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_dmsk" protect="rw">
        <comment>EIC_DBNC bits data mask register</comment>
        <bits access="rw" name="dbnc_dmsk" pos="15:0" rst="0x0">
          <comment>EIC_DBNC_DATA register can be read if EIC_DBNC_DMSK set 1</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg name="eic_dbnc_iev" protect="rw">
        <comment>EIC_DBNC bits interrupt status register</comment>
        <bits access="rw" name="dbnc_iev" pos="15:0" rst="0xffff">
          <comment>EIC_DBNC bits interrupt status register:
1 high levels trigger interrupts,
0 low levels trigger interrupts.</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_ie" protect="rw">
        <comment>EIC_DBNC bits interrupt enable register</comment>
        <bits access="rw" name="dbnc_ie" pos="15:0" rst="0x0">
          <comment>EIC_DBNC bits interrupt enable register:
1 corresponding bit interrupt is enabled.
0 corresponding bit interrupt isn't enabled</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_ris" protect="rw">
        <comment>EIC_DBNC bits raw interrupt status register, and it reflects the status of interrupts trigger conditions detection on pins (prior to EIC_DBNC_MIS)</comment>
        <bits access="r" name="dbnc_ris" pos="15:0" rst="0x0">
          <comment>EIC bits raw interrupt status register:
1 interrupt condition met
0 condition not met</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_mis" protect="rw">
        <comment>EIC_DBNC bits masked interrupt status register</comment>
        <bits access="r" name="dbnc_mis" pos="15:0" rst="0x0">
          <comment>EIC_DBNC bits masked interrupt status register:
1 Interrupt active
0 interrupt not active</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_ic" protect="rw">
        <comment>EIC_DBNC_ bits interrupt clear register</comment>
        <bits access="rc" name="dbnc_ic" pos="15:0" rst="0x0">
          <comment>EIC_DBNC bits interrupt clear register:
1 clears detected interrupt.
0 has no effect.</comment>
        </bits>
      </reg>
      <reg name="eic_dbnc_trig" protect="rw">
        <comment>EIC_DBNC bits trig control register</comment>
        <bits access="w" name="dbnc_trig" pos="15:0" rst="0x0">
          <comment>EIC_DBNC bits trig control register:
1: generate the trig_start pulse
0: no effect
It must set EIC_DBNC_TRIG for using de-bounce function and getting active interrupt.</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="eic0_dbnc_ctrl" protect="rw">
        <comment>EIC0_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc0" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en0" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt0" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic1_dbnc_ctrl" protect="rw">
        <comment>EIC1_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc1" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en1" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt1" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic2_dbnc_ctrl" protect="rw">
        <comment>EIC2_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc2" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en2" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt2" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic3_dbnc_ctrl" protect="rw">
        <comment>EIC3_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc3" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en3" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt3" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic4_dbnc_ctrl" protect="rw">
        <comment>EIC4_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc4" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en4" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt4" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic5_dbnc_ctrl" protect="rw">
        <comment>EIC5_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc5" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en5" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt5" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic6_dbnc_ctrl" protect="rw">
        <comment>EIC6_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc6" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en6" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt6" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic7_dbnc_ctrl" protect="rw">
        <comment>EIC7_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc7" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en7" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt7" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic8_dbnc_ctrl" protect="rw">
        <comment>EIC8_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc8" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en8" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt8" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic9_dbnc_ctrl" protect="rw">
        <comment>EIC9_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc9" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en9" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt9" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic10_dbnc_ctrl" protect="rw">
        <comment>EIC10_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc10" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en10" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt10" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic11_dbnc_ctrl" protect="rw">
        <comment>EIC11_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc11" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en11" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt11" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic12_dbnc_ctrl" protect="rw">
        <comment>EIC12_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc12" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en12" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt12" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic13_dbnc_ctrl" protect="rw">
        <comment>EIC13_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc13" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en13" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt13" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic14_dbnc_ctrl" protect="rw">
        <comment>EIC14_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc14" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en14" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt14" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
      <reg name="eic15_dbnc_ctrl" protect="rw">
        <comment>EIC15_DBNC control register</comment>
        <bits access="rw" name="force_clk_dbnc15" pos="15" rst="0x0">
          <comment>1: clock of dbnc forced open;
0: no effect</comment>
        </bits>
        <bits access="rw" name="dbnc_en15" pos="14" rst="0x1">
          <comment>de-bounce mechanism enable or disable:
1 enable,0 disable(bypass)</comment>
        </bits>
        <bits access="rw" name="dbnc_cnt15" pos="11:0" rst="0x32">
          <comment>de-bounce counter period value setting,  the one unit is 0.977 1000/1024 millisecond</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108500" name="PMIC_EIC" type="PMIC_EIC"/>
  </archive>
  <archive relative="pmic_rtc.xml">
    <module category="System" name="PMIC_RTC">
      <reg name="rtc_sec_cnt_value" protect="rw">
        <comment>RTC second counter value</comment>
        <bits access="r" name="rtc_sec_cnt_value" pos="5:0" rst="0x0">
          <comment>RTC second counter value</comment>
        </bits>
      </reg>
      <reg name="rtc_min_cnt_value" protect="rw">
        <comment>RTC minute counter value</comment>
        <bits access="r" name="rtc_min_cnt_value" pos="5:0" rst="0x0">
          <comment>RTC minute counter value</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_cnt_value" protect="rw">
        <comment>RTC hour counter value</comment>
        <bits access="r" name="rtc_hrs_cnt_value" pos="5:0" rst="0x0">
          <comment>RTC hour counter value</comment>
        </bits>
      </reg>
      <reg name="rtc_day_cnt_value" protect="rw">
        <comment>RTC day counter value</comment>
        <bits access="r" name="rtc_day_cnt_value" pos="5:0" rst="0x0">
          <comment>RTC day counter value</comment>
        </bits>
      </reg>
      <reg name="rtc_sec_cnt_upd" protect="rw">
        <comment>RTC second counter update</comment>
        <bits access="rw" name="rtc_sec_cnt_upd" pos="5:0" rst="0x0">
          <comment>RTC second counter update
Write new counter value to this register to start a second counter updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_min_cnt_upd" protect="rw">
        <comment>RTC minute counter update</comment>
        <bits access="rw" name="rtc_min_cnt_upd" pos="5:0" rst="0x0">
          <comment>RTC minute counter update
Write new counter value to this register to start a minute counter updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_cnt_upd" protect="rw">
        <comment>RTC hour counter update</comment>
        <bits access="rw" name="rtc_hrs_cnt_upd" pos="4:0" rst="0x0">
          <comment>RTC hour counter update
Write new counter value to this register to start an hour counter updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_day_cnt_upd" protect="rw">
        <comment>RTC day counter update</comment>
        <bits access="rw" name="rtc_day_cnt_upd" pos="5:0" rst="0x0">
          <comment>RTC day counter update
Write new counter value to this register to start a day counter updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_sec_alm_upd" protect="rw">
        <comment>RTC second alarm update</comment>
        <bits access="rw" name="rtc_sec_alm_upd" pos="5:0" rst="0x0">
          <comment>RTC second alarm update
Write new counter value to this register to start a second alarm updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_min_alm_upd" protect="rw">
        <comment>RTC minute alarm update</comment>
        <bits access="rw" name="rtc_min_alm_upd" pos="5:0" rst="0x0">
          <comment>RTC minute alarm update
Write new counter value to this register to start a minute alarm updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_alm_upd" protect="rw">
        <comment>RTC hour alarm update</comment>
        <bits access="rw" name="rtc_hrs_alm_upd" pos="4:0" rst="0x0">
          <comment>RTC hour alarm update
Write new counter value to this register to start an hour alarm updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_day_alm_upd" protect="rw">
        <comment>RTC day alarm update</comment>
        <bits access="rw" name="rtc_day_alm_upd" pos="5:0" rst="0x0">
          <comment>RTC day alarm update
Write new counter value to this register to start a day alarm updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
      </reg>
      <reg name="rtc_int_en" protect="rw">
        <comment>RTC interrupt enable and
hour format control</comment>
        <bits access="rw" name="rtc_day_alm_upd_int_en" pos="15" rst="0x0">
          <comment>Day alarm updating complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="rtc_hrs_alm_upd_int_en" pos="14" rst="0x0">
          <comment>Hour alarm updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_min_alm_upd_int_en" pos="13" rst="0x0">
          <comment>Minute alarm updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_sec_alm_upd_int_en" pos="12" rst="0x0">
          <comment>Second alarm updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_day_cnt_upd_int_en" pos="11" rst="0x0">
          <comment>Day counter updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_hrs_cnt_upd_int_en" pos="10" rst="0x0">
          <comment>Hour counter updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_min_cnt_upd_int_en" pos="9" rst="0x0">
          <comment>Minute counter updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_sec_cnt_upd_int_en" pos="8" rst="0x0">
          <comment>Second counter updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_spg_upd_int_en" pos="7" rst="0x0">
          <comment>Spare register updating complete interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_auxalm_int_en" pos="6" rst="0x0">
          <comment>auxiliary alarm interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_hrs_format_sel" pos="5" rst="0x0">
          <comment>Hour format select
0: The read back hour count is formatted as 0 to 23.
1: The read back hour count is formatted as 0 to 11, and bit 4 represent AM or PM  AM is 0 and PM is 1.</comment>
        </bits>
        <bits access="rw" name="rtc_alm_int_en" pos="4" rst="0x0">
          <comment>alarm interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_day_int_en" pos="3" rst="0x0">
          <comment>day interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_hrs_int_en" pos="2" rst="0x0">
          <comment>hour interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_min_int_en" pos="1" rst="0x0">
          <comment>minute interrupt enable</comment>
        </bits>
        <bits access="rw" name="rtc_sec_int_en" pos="0" rst="0x0">
          <comment>Second interrupt enable</comment>
        </bits>
      </reg>
      <reg name="rtc_int_raw_sts" protect="rw">
        <comment>RTC interrupt raw status</comment>
        <bits access="r" name="rtc_day_alm_upd_int_raw_sts" pos="15" rst="0x0">
          <comment>Day alarm updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_alm_upd_int_raw_sts" pos="14" rst="0x0">
          <comment>Hour alarm updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_min_alm_upd_int_raw_sts" pos="13" rst="0x0">
          <comment>Minute alarm updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_sec_alm_upd_int_raw_sts" pos="12" rst="0x0">
          <comment>Second alarm updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_day_cnt_upd_int_raw_sts" pos="11" rst="0x0">
          <comment>Day counter updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_cnt_upd_int_raw_sts" pos="10" rst="0x0">
          <comment>Hour counter updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_min_cnt_upd_int_raw_sts" pos="9" rst="0x0">
          <comment>Minute counter updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_sec_cnt_upd_int_raw_sts" pos="8" rst="0x0">
          <comment>Second counter updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_spg_upd_int_raw_sts" pos="7" rst="0x0">
          <comment>Spare register updating complete interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_auxalm_int_raw_sts" pos="6" rst="0x0">
          <comment>auxiliary alarm interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_alm_int0_raw_sts" pos="5" rst="0x0">
          <comment>Reserved for debug</comment>
        </bits>
        <bits access="r" name="rtc_alm_int_raw_sts" pos="4" rst="0x0">
          <comment>alarm interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_day_int_raw_sts" pos="3" rst="0x0">
          <comment>day interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_int_raw_sts" pos="2" rst="0x0">
          <comment>hour interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_min_int_raw_sts" pos="1" rst="0x0">
          <comment>minute interrupt raw status</comment>
        </bits>
        <bits access="r" name="rtc_sec_int_raw_sts" pos="0" rst="0x0">
          <comment>Second interrupt raw status</comment>
        </bits>
      </reg>
      <reg name="rtc_int_clr" protect="rw">
        <comment>RTC interrupt clear</comment>
        <bits access="w" name="rtc_day_alm_upd_int_clr" pos="15" rst="0x0">
          <comment>Day alarm updating complete interrupt clear
Write 1 to this bit to clear corresponding interrupt</comment>
        </bits>
        <bits access="w" name="rtc_hrs_alm_upd_int_clr" pos="14" rst="0x0">
          <comment>Hour alarm updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_min_alm_upd_int_clr" pos="13" rst="0x0">
          <comment>Minute alarm updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_sec_alm_upd_int_clr" pos="12" rst="0x0">
          <comment>Second alarm updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_day_cnt_upd_int_clr" pos="11" rst="0x0">
          <comment>Day counter updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_hrs_cnt_upd_int_clr" pos="10" rst="0x0">
          <comment>Hour counter updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_min_cnt_upd_int_clr" pos="9" rst="0x0">
          <comment>Minute counter updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_sec_cnt_upd_int_clr" pos="8" rst="0x0">
          <comment>Second counter updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_spg_upd_int_clr" pos="7" rst="0x0">
          <comment>Spare register updating complete interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_auxalm_int_clr" pos="6" rst="0x0">
          <comment>Auxiliary alarm interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_alm_int_clr" pos="4" rst="0x0">
          <comment>alarm interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_day_int_clr" pos="3" rst="0x0">
          <comment>day interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_hrs_int_clr" pos="2" rst="0x0">
          <comment>hour interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_min_int_clr" pos="1" rst="0x0">
          <comment>minute interrupt clear</comment>
        </bits>
        <bits access="w" name="rtc_sec_int_clr" pos="0" rst="0x0">
          <comment>Second interrupt clear</comment>
        </bits>
      </reg>
      <reg name="rtc_int_mask_sts" protect="rw">
        <comment>RTC interrupt masked status</comment>
        <bits access="r" name="rtc_day_alm_upd_int_mask_sts" pos="15" rst="0x0">
          <comment>Day alarm updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_alm_upd_int_mask_sts" pos="14" rst="0x0">
          <comment>Hour alarm updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_min_alm_upd_int_mask_sts" pos="13" rst="0x0">
          <comment>Minute alarm updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_sec_alm_upd_int_mask_sts" pos="12" rst="0x0">
          <comment>Second alarm updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_day_cnt_upd_int_mask_sts" pos="11" rst="0x0">
          <comment>Day counter updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_cnt_upd_int_mask_sts" pos="10" rst="0x0">
          <comment>Hour counter updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_min_cnt_upd_int_mask_sts" pos="9" rst="0x0">
          <comment>Minute counter updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_sec_cnt_upd_int_mask_sts" pos="8" rst="0x0">
          <comment>Second counter updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_spg_upd_int_mask_sts" pos="7" rst="0x0">
          <comment>Spare register updating complete interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_auxalm_int_mask_sts" pos="6" rst="0x0">
          <comment>auxiliary alarm interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_alm_int_mask_sts" pos="4" rst="0x0">
          <comment>alarm interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_day_int_mask_sts" pos="3" rst="0x0">
          <comment>day interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_hrs_int_mask_sts" pos="2" rst="0x0">
          <comment>hour interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_min_int_mask_sts" pos="1" rst="0x0">
          <comment>minute interrupt masked status</comment>
        </bits>
        <bits access="r" name="rtc_sec_int_mask_sts" pos="0" rst="0x0">
          <comment>Second interrupt masked status</comment>
        </bits>
      </reg>
      <reg name="rtc_sec_alm_value" protect="rw">
        <comment>RTC second alarm value</comment>
        <bits access="r" name="rtc_sec_alm_value" pos="5:0" rst="0x0">
          <comment>RTC second alarm value</comment>
        </bits>
      </reg>
      <reg name="rtc_min_alm_value" protect="rw">
        <comment>RTC minute alarm value</comment>
        <bits access="r" name="rtc_min_alm_value" pos="5:0" rst="0x0">
          <comment>RTC minute alarm value</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_alm_value" protect="rw">
        <comment>RTC hour alarm value</comment>
        <bits access="r" name="rtc_hrs_alm_value" pos="5:0" rst="0x0">
          <comment>RTC hour alarm value</comment>
        </bits>
      </reg>
      <reg name="rtc_day_alm_value" protect="rw">
        <comment>RTC day alarm value</comment>
        <bits access="r" name="rtc_day_alm_value" pos="5:0" rst="0x0">
          <comment>RTC day alarm value</comment>
        </bits>
      </reg>
      <reg name="rtc_spg_value" protect="rw">
        <comment>RTC spare register value</comment>
        <bits access="r" name="rtc_spg_value" pos="15:8" rst="0x0">
          <comment>RTC spare register value</comment>
        </bits>
        <bits access="r" name="rtc_almlock_value" pos="7:0" rst="0x0">
          <comment>RTC alarm lock register value</comment>
        </bits>
      </reg>
      <reg name="rtc_spg_upd" protect="rw">
        <comment>RTC spare register update</comment>
        <bits access="rw" name="rtc_spg_upd" pos="15:8" rst="0x0">
          <comment>RTC spare register update
Write new counter value to this register to start a spare register updating operation in VDDRTC domain.
Reading this register can get recent updating value.</comment>
        </bits>
        <bits access="rw" name="rtc_almlock_upd" pos="7:0" rst="0x0">
          <comment>RTC alarm lock register update
Write new counter value to this register to start a register updating operation in VDDRTC domain.
Reading this register can get recent updating value.
Write 8hA5 to this register to unlock alarm function, and write other data to lock alarm function. That means, software must 8hA5 to this register to enable alarm function before using this function.</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_flag_ctrl" protect="rw">
        <comment>RTC power flag control register</comment>
        <bits access="rw" name="rtc_pwr_flag_set" pos="15:8" rst="0x0">
          <comment>RTC power flag register set</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_flag_clr" pos="7:0" rst="0x0">
          <comment>RTC power flag register clear</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_flag_sts" protect="rw">
        <comment>RTC power flag status</comment>
        <bits access="r" name="rtc_power_flag_status_register" pos="7:0" rst="0x96">
          <comment>RTC power flag status register</comment>
        </bits>
      </reg>
      <reg name="rtc_sec_auxalm_upd" protect="rw">
        <comment>RTC second auxiliary alarm
 update</comment>
        <bits access="rw" name="rtc_sec_auxalm_upd" pos="5:0" rst="0x0">
          <comment>RTC second auxiliary alarm register</comment>
        </bits>
      </reg>
      <reg name="rtc_min_auxalm_upd" protect="rw">
        <comment>RTC minute auxiliary alarm
 update</comment>
        <bits access="rw" name="rtc_min_auxalm_upd" pos="5:0" rst="0x0">
          <comment>RTC minute auxiliary alarm register</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_auxalm_upd" protect="rw">
        <comment>RTC hour auxiliary alarm
 update</comment>
        <bits access="rw" name="rtc_hrs_auxalm_upd" pos="4:0" rst="0x0">
          <comment>RTC hour auxiliary alarm register</comment>
        </bits>
      </reg>
      <reg name="rtc_day_auxalm_upd" protect="rw">
        <comment>RTC day auxiliary alarm
 update</comment>
        <bits access="rw" name="rtc_day_auxalm_upd" pos="5:0" rst="0x0">
          <comment>RTC day auxiliary alarm register</comment>
        </bits>
      </reg>
      <reg name="rtc_sec_cnt_raw" protect="rw">
        <comment>RTC second counter raw value</comment>
        <bits access="r" name="rtc_sec_cnt_raw" pos="5:0" rst="0x0">
          <comment>RTC second counter raw value
Only for debug</comment>
        </bits>
      </reg>
      <reg name="rtc_min_cnt_raw" protect="rw">
        <comment>RTC minute counter raw value</comment>
        <bits access="r" name="rtc_min_cnt_raw" pos="5:0" rst="0x0">
          <comment>RTC minute counter raw value
Only for debug</comment>
        </bits>
      </reg>
      <reg name="rtc_hrs_cnt_raw" protect="rw">
        <comment>RTC hour counter raw value</comment>
        <bits access="r" name="rtc_hrs_cnt_raw" pos="5:0" rst="0x0">
          <comment>RTC hour counter raw value
Only for debug</comment>
        </bits>
      </reg>
      <reg name="rtc_day_cnt_raw" protect="rw">
        <comment>RTC second counter raw value</comment>
        <bits access="r" name="rtc_day_cnt_raw" pos="5:0" rst="0x0">
          <comment>RTC day counter raw value
Only for debug</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108600" name="PMIC_RTC" type="PMIC_RTC"/>
  </archive>
  <archive relative="pmic_timer.xml">
    <module category="System" name="PMIC_TIMER">
      <reg name="timer_version" protect="rw">
        <comment>the IP version of this timer the IP version of this timer</comment>
        <bits access="r" name="ip_version" pos="15:4" rst="0x10">
          <comment>the IP version of this timer</comment>
        </bits>
        <bits access="r" name="ip_patch_version" pos="3:0" rst="0x1">
          <comment>the IP patch version of this timer</comment>
        </bits>
      </reg>
      <reg name="timer_load_lo" protect="rw">
        <comment>timer load value of lower 16 bit timer load value of lower 16 bit</comment>
        <bits access="rw" name="timer_load_lo" pos="15:0" rst="0x0">
          <comment>timer load value of lower 16 bit.
Write to this register will reload the timer with the new value.
In one-time mode, this value is the first counting start number.
In periodic mode, this value is each counting start number.</comment>
        </bits>
      </reg>
      <reg name="timer_load_hi" protect="rw">
        <comment>timer load value of higher 16 bit timer load value of higher 16 bit</comment>
        <bits access="rw" name="timer_load_hi" pos="15:0" rst="0x0">
          <comment>timer load value of higher 16 bit
Write to this register will reload the timer with the new value.
In one-time mode, this value is the first counting start number.
In periodic mode, this value is each counting start number.</comment>
        </bits>
      </reg>
      <reg name="timer_ctl" protect="rw">
        <comment>timer control register timer control register</comment>
        <bits access="rw" name="timer_run" pos="1" rst="0x0">
          <comment>timer open bit
0: timer stops
1: timer runs</comment>
        </bits>
        <bits access="rw" name="timer_mode" pos="0" rst="0x0">
          <comment>timer mode select
0: one-time mode
1: period mode</comment>
        </bits>
      </reg>
      <reg name="timer_int" protect="rw">
        <comment>timer interrupt timer interrupt</comment>
        <bits access="rc" name="timer_int_clr" pos="3" rst="0x0">
          <comment>timer Interrupt clear
Write 1 to this bit to clear interrupt</comment>
        </bits>
        <bits access="r" name="timer_int_mask_sts" pos="2" rst="0x0">
          <comment>timer interrupt masked status</comment>
        </bits>
        <bits access="r" name="timer_int_raw_sts" pos="1" rst="0x0">
          <comment>timer interrupt raw status</comment>
        </bits>
        <bits access="rw" name="timer_int_en" pos="0" rst="0x0">
          <comment>timer interrupt enable</comment>
        </bits>
      </reg>
      <reg name="timer_value_shdw_lo" protect="rw">
        <comment>timer counter shadow value of lower 16 bit for read timer counter shadow value of lower 16 bit for read</comment>
        <bits access="r" name="timer_value_shdw_lo" pos="15:0" rst="0x0">
          <comment>timer counter of lower 16bit shadow value for read.
This read-only register indicates current counter value.
The software can read the counter value immediately after load, without waiting for the load done. Also, software just needs to read once instead of double read.</comment>
        </bits>
      </reg>
      <reg name="timer_value_shdw_hi" protect="rw">
        <comment>timer counter shadow value of higher 16 bit for read timer counter shadow value of higher 16 bit for read</comment>
        <bits access="r" name="timer_value_shdw_hi" pos="15:0" rst="0x0">
          <comment>timer counter of higher 16bit shadow value for read.
This read-only register indicates current counter value.
The software can read the counter value immediately after load, without waiting for the load done. Also, software just needs to read once instead of double read.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108000" name="PMIC_TIMER" type="PMIC_TIMER"/>
  </archive>
  <archive relative="pmic_ana.xml">
    <module category="System" name="PMIC_ANA">
      <reg name="chip_id_low" protect="rw">
        <comment>CHIP_ID_LOW</comment>
        <bits access="r" name="chip_id_low" pos="15:0" rst="0xa000">
          <comment>CHIP ID low 16 bits,default:a000</comment>
        </bits>
      </reg>
      <reg name="chip_id_high" protect="rw">
        <comment>CHIP_ID_HIGH</comment>
        <bits access="r" name="chip_id_high" pos="15:0" rst="0x8850">
          <comment>CHIP ID high 16 bits,default:8850</comment>
        </bits>
      </reg>
      <reg name="module_en0" protect="rw">
        <comment>MODULE_EN0</comment>
        <bits access="rw" name="tmr_en" pos="12" rst="0x0">
          <comment>TMR module enable
0: Disable the PCLK  of timer
1: Enable  the PCLK  of timer</comment>
        </bits>
        <bits access="rw" name="bltc_en" pos="9" rst="0x0">
          <comment>BLTC module enable
0: Disable the PCLK  of BLTC
1: Enable  the PCLK  of BLTC</comment>
        </bits>
        <bits access="rw" name="efs_en" pos="6" rst="0x0">
          <comment>Efuse module enable
0: Disable the PCLK  of efuse ctrl
1: Enable  the PCLK  of efuse ctrl</comment>
        </bits>
        <bits access="rw" name="adc_en" pos="5" rst="0x0">
          <comment>AUXADC module enable
0: Disable the PCLK  of AUXADC
1: Enable  the PCLK  of AUXADC</comment>
        </bits>
        <bits access="rw" name="cal_en" pos="0" rst="0x0">
          <comment>CAL module enable
0: Disable the PCLK  of CAL
1: Enable  the PCLK  of CAL</comment>
        </bits>
      </reg>
      <reg name="dig_clk_en0" protect="rw">
        <comment>DIG_CLK_EN0</comment>
        <bits access="rw" name="clk_auxad_en" pos="6" rst="0x0">
          <comment>AUXAD clock enable, the clock is connected to AUXADC converter
0: disable AUXAD_CLK
1: enable AUXAD_CLK</comment>
        </bits>
        <bits access="rw" name="clk_auxadc_en" pos="5" rst="0x0">
          <comment>AUXADC module work clock enable
0: disable clk_adc
1: enable clk_adc</comment>
        </bits>
        <bits access="rw" name="clk_cal_src_sel" pos="4:3" rst="0x0">
          <comment>Calibration module clock source select                  2'b00:RC64K
2'b01:N/A
2'b10:N/A
2'b11:N/A</comment>
        </bits>
        <bits access="rw" name="clk_cal_en" pos="2" rst="0x0">
          <comment>CLK_CAL eanble
0: disable clk_cal
1: enable clk_cal</comment>
        </bits>
      </reg>
      <reg name="rtc_clk_en0" protect="rw">
        <comment>RTC_CLK_EN0</comment>
        <bits access="rw" name="rtc_tmr_en" pos="13" rst="0x0">
          <comment>TIMER RTC clock soft enable
0: Disable the RTC clock of timer
1: Enable RTC clock of timer</comment>
        </bits>
        <bits access="rw" name="rtc_bltc_en" pos="7" rst="0x0">
          <comment>BLTC RTC clock soft enable
0: Disable the RTC clock of BLTC
1: Enable RTC clock of BLTC</comment>
        </bits>
        <bits access="rw" name="rtc_arch_en" pos="0" rst="0x1">
          <comment>ARCH RTC clock soft enable
0: Disable the RTC clock of ARCH
1: Enable RTC clock of ARCH</comment>
        </bits>
      </reg>
      <reg name="soft_rst0" protect="rw">
        <comment>SOFT_RST0</comment>
        <bits access="rw" name="bltc_soft_rst" pos="9" rst="0x0">
          <comment>BLTC soft reset</comment>
        </bits>
        <bits access="rw" name="efs_soft_rst" pos="7" rst="0x0">
          <comment>Efuse soft reset</comment>
        </bits>
        <bits access="rw" name="adc_soft_rst" pos="6" rst="0x0">
          <comment>Auxadc soft reset</comment>
        </bits>
        <bits access="rw" name="tmr_soft_rst" pos="4" rst="0x0">
          <comment>TMR soft reset</comment>
        </bits>
        <bits access="rw" name="cal_soft_rst" pos="0" rst="0x0">
          <comment>CAL soft reset</comment>
        </bits>
      </reg>
      <reg name="xtl_wait" protect="rw">
        <comment>XTL_WAIT</comment>
        <bits access="rw" name="slp_rgb_pd_en" pos="15" rst="0x1">
          <comment>RGB driver power down enable in chip deep sleep mode</comment>
        </bits>
        <bits access="rw" name="xtl_wait" pos="7:0" rst="0x32">
          <comment>26MHz crystal oscillator  wait cycles</comment>
        </bits>
      </reg>
      <reg name="rg_dvdd_reserved1" protect="rw">
        <comment>RG_DVDD_RESERVED1</comment>
        <bits access="rw" name="rg_dvdd_reserved0" pos="15:8" rst="0xf0">
          <comment>RG_DVDD_RESERVED0</comment>
        </bits>
        <bits access="rw" name="rg_dvdd_reserved1" pos="7:0" rst="0xf0">
          <comment>RG_DVDD_RESERVED1</comment>
        </bits>
      </reg>
      <reg name="vbat_ctrl0" protect="rw">
        <comment>VBAT_CTRL0</comment>
        <bits access="rw" name="rg_ldo_vbat_auxcal_sel" pos="2:0" rst="0x0">
          <comment>LDOs output selection control. (To AUXADC internal calibration)</comment>
        </bits>
      </reg>
      <reg name="thm_otp_ctrl" protect="rw">
        <comment>THM_OTP_CTRL</comment>
        <bits access="rw" name="rg_otp_en" pos="3" rst="0x0">
          <comment>OTP function enable control bit</comment>
        </bits>
        <bits access="rw" name="rg_otp_op" pos="2:0" rst="0x3">
          <comment>OTP threshold
3'b011: 135C, default</comment>
        </bits>
      </reg>
      <reg name="led_ctrl" protect="rw">
        <comment>LED_CTRL</comment>
        <bits access="rw" name="ib_trim_em_sel" pos="12" rst="0x1">
          <comment>Internal resistor for sink current calibration bit selection
0: From Software Register
1: From Ememory</comment>
        </bits>
        <bits access="rw" name="rg_batdet_cur_en" pos="11" rst="0x0">
          <comment>current mode enable                                                                         &quot;0&quot; disable (default)                                                                      &quot;1&quot; enable (default)</comment>
        </bits>
        <bits access="rw" name="rg_batdet_cur_i" pos="10:8" rst="0x0">
          <comment>set current level in current mode
bit3~bit1  effective, bit0 not used,
1.25/2.5/5/10/20/40/80/160uA 7step</comment>
        </bits>
        <bits access="rw" name="rg_ib_rex_en" pos="7" rst="0x0">
          <comment>sink current adjustment for test  enable signale, high effective
Defautl 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ib_trim" pos="6:0" rst="0x40">
          <comment>sink current calibration bit.  1.25uA/step
default 0000000(1.25uA)</comment>
        </bits>
      </reg>
      <reg name="kpled_ctrl1" protect="rw">
        <comment>KPLED_CTRL1</comment>
        <bits access="rw" name="rg_ldo_kpled_cl_adj" pos="12" rst="0x1">
          <comment>KPLED LDO current limit threshold adjust:
default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_kpled_v" pos="11:8" rst="0x0">
          <comment>Current control bit. 16 steps
(default 4b0)
(0000:0.9mA
0001:1.8mA
 0010:2.7mA
 0011:3.6mA
 0100:4.5mA
 0101:5.4mA
 0110:6.3mA
 0111:7.2mA
 1000:16.2mA
 1001:22.5mA
 1010:29.7mA
 1011:37.8mA
 1100:46.8mA
 1101:56.7mA
 1110:67.5mA
 1111:79.2mA)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_shpt_adj" pos="7" rst="0x1">
          <comment>KPLED LDO foldback current threshold adjust:
default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_stb" pos="6:5" rst="0x2">
          <comment>KPLED LDO stability compensation:
default 2'b10</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_cap_sel" pos="4" rst="0x0">
          <comment>KPLED LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_v" pos="3:1" rst="0x5">
          <comment>KPLED LDO program bits:
100mV/step, 2.8V~3.5V; default 3.3V, 3'b101</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_shpt_pd" pos="0" rst="0x0">
          <comment>KPLED LDO short protection power down
default:0,on</comment>
        </bits>
      </reg>
      <reg name="ldo_vbat_ctrl1" protect="rw">
        <comment>LDO_VBAT_CTRL1</comment>
        <bits access="rw" name="rg_ldo_usb33_cl_adj" pos="7:5" rst="0x3">
          <comment>LDO_USB current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_usb33_shpt_en" pos="4" rst="0x1">
          <comment>LDO_USB short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_usb33_rz_adj" pos="3" rst="0x1">
          <comment>LDO_USB short current threshold adjust                                         default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_usb33_stb" pos="2:1" rst="0x0">
          <comment>LDO_USB compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_usb33_discharge_en" pos="0" rst="0x1">
          <comment>LDO_USB discharge en</comment>
        </bits>
      </reg>
      <reg name="ldo_vbat_ctrl2" protect="rw">
        <comment>LDO_VBAT_CTRL2</comment>
        <bits access="rw" name="rg_ldo_vio33_cl_adj" pos="15:13" rst="0x3">
          <comment>LDO_VIO33 current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_shpt_en" pos="12" rst="0x1">
          <comment>LDO_VIO33 short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_rz_adj" pos="11" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_stb" pos="10:9" rst="0x0">
          <comment>LDO_VIO33 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_discharge_en" pos="8" rst="0x1">
          <comment>LDO_VIO33 discharge en</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_cl_adj" pos="7:5" rst="0x3">
          <comment>LDO_CAMA current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_shpt_en" pos="4" rst="0x1">
          <comment>LDO_CAMA short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_rz_adj" pos="3" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_stb" pos="2:1" rst="0x0">
          <comment>LDO_CAMA compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_discharge_en" pos="0" rst="0x1">
          <comment>LDO_CAMA discharge en</comment>
        </bits>
      </reg>
      <reg name="ldo_vbat_ctrl3" protect="rw">
        <comment>LDO_VBAT_CTRL3</comment>
        <bits access="rw" name="rg_ldo_lcd_cl_adj" pos="15:13" rst="0x3">
          <comment>LDO_LCD current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lcd_shpt_en" pos="12" rst="0x1">
          <comment>LDO_LCD short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lcd_rz_adj" pos="11" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lcd_stb" pos="10:9" rst="0x0">
          <comment>LDO_LCD compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lcd_discharge_en" pos="8" rst="0x1">
          <comment>LDO_LCD discharge en</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mmc_cl_adj" pos="7:5" rst="0x3">
          <comment>LDO_MMC current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mmc_shpt_en" pos="4" rst="0x1">
          <comment>LDO_MMC short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mmc_rz_adj" pos="3" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mmc_stb" pos="2:1" rst="0x0">
          <comment>LDO_MMC compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mmc_discharge_en" pos="0" rst="0x1">
          <comment>LDO_MMC discharge en</comment>
        </bits>
      </reg>
      <reg name="ldo_ana_ctrl" protect="rw">
        <comment>LDO_ANA_CTRL</comment>
        <bits access="rw" name="rg_ldo_ana_cl_adj" pos="14" rst="0x0">
          <comment>LDO_ANA current limit threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_ANA short protect EN:
1 is disable
0 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_ANA short current threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_stb" pos="11:10" rst="0x0">
          <comment>LDO_ANA compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_bp" pos="9" rst="0x0">
          <comment>LDO_ANA bypass application:
default 1'b0, no bypass
             1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_cap_sel" pos="8" rst="0x0">
          <comment>ANA LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_ana_v" pos="5:0" rst="0x20">
          <comment>ANA LDO output voltage select                              000000~111111 1.4V~2.1875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_vio18_ctrl" protect="rw">
        <comment>LDO_VIO18_CTRL</comment>
        <bits access="rw" name="rg_ldo_vio18_cl_adj" pos="14" rst="0x0">
          <comment>LDO_VIO18 current limit threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_VIO18 short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_VIO18 short current threshold adjust                                         default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_stb" pos="11:10" rst="0x0">
          <comment>LDO_VIO18 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_bp" pos="9" rst="0x0">
          <comment>LDO_VIO18 bypass application:
default 1'b0, no bypass
            1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_cap_sel" pos="8" rst="0x0">
          <comment>VIO18 LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio18_v" pos="5:0" rst="0x20">
          <comment>VIO18 LDO output voltage select                              000000~111111 1.4V~2.1875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_vgen_ctrl1" protect="rw">
        <comment>LDO_VGEN_CTRL1</comment>
        <bits access="rw" name="rg_ldo_mem_cl_adj" pos="14" rst="0x0">
          <comment>LDO_MEM current limit threshold adjust                                         default 3'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_MEM short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_MEM short current threshold adjust                                         default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_stb" pos="11:10" rst="0x0">
          <comment>LDO_MEM compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_bp" pos="9" rst="0x0">
          <comment>LDO_MEM bypass application:
default 1'b0, no bypass
            1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_cap_sel" pos="8" rst="0x0">
          <comment>MEM LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_mem_v" pos="5:0" rst="0x20">
          <comment>MEM LDO output voltage select                              000000~111111 1.4V~2.1875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_spimem_ctrl" protect="rw">
        <comment>LDO_SPIMEM_CTRL</comment>
        <bits access="rw" name="rg_ldo_spimem_cl_adj" pos="14" rst="0x0">
          <comment>LDO_SPIMEM current limit threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_SPIMEM short protect EN:
1 is disable
0 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_SPIMEM short current threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_stb" pos="11:10" rst="0x0">
          <comment>LDO_SPIMEM compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_bp" pos="9" rst="0x0">
          <comment>LDO_SPIMEM bypass application:
default 1'b0, no bypass
             1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_cap_sel" pos="8" rst="0x0">
          <comment>SPIMEM LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_spimem_v" pos="5:0" rst="0x20">
          <comment>SPIMEM LDO output voltage select                              000000~111111 1.4V~2.1875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_camd_ctrl" protect="rw">
        <comment>LDO_CAMD_CTRL</comment>
        <bits access="rw" name="rg_ldo_camd_cl_adj" pos="14" rst="0x0">
          <comment>LDO_CAMD current limit threshold adjust                                         default 1'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_CAMD short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_CAMD short current threshold adjust                                         default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_stb" pos="11:10" rst="0x0">
          <comment>LDO_CAMD compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_bp" pos="9" rst="0x0">
          <comment>LDO_CAMD bypass application:
default 1'b0, no bypass
            1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_cap_sel" pos="8" rst="0x0">
          <comment>CAMD LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_camd_v" pos="5:0" rst="0x20">
          <comment>VIO18 LDO output voltage select                              000000~111111 1.4V~2.1875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_rf15_ctrl" protect="rw">
        <comment>LDO_RF15_CTRL</comment>
        <bits access="rw" name="rg_ldo_rf15_cl_adj" pos="14" rst="0x0">
          <comment>LDO_RF15 current limit threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_shpt_pd" pos="13" rst="0x0">
          <comment>LDO_RF15 short protect EN:
1 is disable
0 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_shpt_adj" pos="12" rst="0x0">
          <comment>LDO_RF15 short current threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_stb" pos="11:10" rst="0x0">
          <comment>LDO_RF15 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_bp" pos="9" rst="0x0">
          <comment>LDO_RF15 bypass application:
default 1'b0, no bypass
            1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_cap_sel" pos="8" rst="0x0">
          <comment>LDO RF15 remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf15_v" pos="5:0" rst="0x20">
          <comment>RF15 LDO output voltage select                              000000~111111 1.4V~1.8875V  12.5mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_vgen_ctrl3" protect="rw">
        <comment>LDO_VGEN_CTRL3</comment>
      </reg>
      <reg name="ldo_lp18_ctrl" protect="rw">
        <comment>LDO_LP18_CTRL</comment>
        <bits access="rw" name="rg_ldo_lp18_cl_adj" pos="15:13" rst="0x3">
          <comment>LDO_LP18 current limit threshold adjust                                         default 1'b011                                                                             111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_shpt_en" pos="12" rst="0x1">
          <comment>LDO_LP18 short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_rz_adj" pos="11" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_stb" pos="10:9" rst="0x0">
          <comment>LDO_LP18 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_discharge_en" pos="8" rst="0x1">
          <comment>LDO_LP18 discharge en</comment>
        </bits>
      </reg>
      <reg name="ldo_rf12_ctrl" protect="rw">
        <comment>LDO_LP18_RF12_CTRL</comment>
        <bits access="rw" name="rg_ldo_rf12_cl_adj" pos="12" rst="0x0">
          <comment>LDO_RF12 current limit threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_shpt_pd" pos="11" rst="0x0">
          <comment>LDO_RF12 short protect EN:
1 is disable
0 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_shpt_adj" pos="10" rst="0x0">
          <comment>LDO_RF12 short current threshold adjust                                         default 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_v" pos="9:4" rst="0x1f">
          <comment>RF12 LDO output voltage select                              000000~111111 0.8125~1.6V  12.5mV/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_stb" pos="3:2" rst="0x0">
          <comment>LDO_RF12 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_bp" pos="1" rst="0x0">
          <comment>LDO_RF12 bypass application:
default 1'b0, no bypass
            1'b1,  bypass</comment>
        </bits>
        <bits access="rw" name="rg_ldo_rf12_cap_sel" pos="0" rst="0x0">
          <comment>RF12 LDO remote cap application:
default 1'b0; when parasitic resistance is larger than 200m ohm, select 1'b1</comment>
        </bits>
      </reg>
      <reg name="dcdc_ctrl1" protect="rw">
        <comment>DCDC_CTRL1</comment>
        <bits access="rw" name="rg_dcdc_auxtrim_sel" pos="15:12" rst="0x0">
          <comment>DCDC to AUXADC trim channel selection
3'b001: select VCORE
3'b010: select VRF (VRF*18/37)
3'b011: select VPA (VPA*18/68)
RG_DCDC_AUXTRIM_SEL[2], internal test mode select:
0: default, internal test mode disable
1: internal test mode enable. Monitor internal signals by reuse CLK3M_OUT path
3'b100: enpwm_vrf
3'b101: zx_vrf
3'b110: enpwm_vcore
3'b111: zx_vcore</comment>
        </bits>
        <bits access="rw" name="rg_clk3m_out_en" pos="11" rst="0x0">
          <comment>test mode control.
1'b0: default, clock output off
1'b1:  clock output on</comment>
        </bits>
        <bits access="rw" name="rg_dcdc_clkout_uniphase" pos="4" rst="0x0">
          <comment>phase shift option
1'b0: default, w/i 1/5 phase shift at internal mode
1'b1: uni-phase mode, all ouputs = channel 0</comment>
        </bits>
        <bits access="rw" name="rg_dcdc_clkout_sel" pos="3:0" rst="0x0">
          <comment>clock selection for each channel
RG_CLKOUT_SEL[0]:  VCORE clk selection
RG_CLKOUT_SEL[1]:  VGEN clk selection
RG_CLKOUT_SEL[2]:  VRF clk selection
RG_CLKOUT_SEL[3]:  VPA clk selection
0: internal mode, default
1: external mode</comment>
        </bits>
      </reg>
      <reg name="vcore_ctrl2" protect="rw">
        <comment>VCORE_CTRL2</comment>
        <bits access="rw" name="rg_vcore_antiring_en" pos="6" rst="0x0">
          <comment>anti-ring enable
1'b0: default, anti-ring off
1'b1: anti-ring on</comment>
        </bits>
        <bits access="rw" name="rg_vcore_curlimit_r" pos="5:4" rst="0x0">
          <comment>current limit threshold tuning
2'b00: default
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
        <bits access="rw" name="rg_vcore_curavg" pos="3:2" rst="0x0">
          <comment>current sense average ratio
current sense multiplier tuning
2'b00: default, x1
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
        <bits access="rw" name="rg_vcore_curses_r" pos="1:0" rst="0x0">
          <comment>current sense R ratio tuning
current sense multiplier tuning
2'b00: default, x1
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
      </reg>
      <reg name="vcore_ctrl3" protect="rw">
        <comment>VCORE_CTRL3</comment>
        <bits access="rw" name="rg_vcore_force_pwm" pos="13" rst="0x0">
          <comment>force PWM mode
1'b0: default, PFM/PWM auto mode
1'b1: force PWM mode</comment>
        </bits>
        <bits access="rw" name="rg_vcore_zx_disable" pos="12" rst="0x0">
          <comment>force zero-cross off
1'b0: default, zero_cross detect on
1'b1: zero-cross detect off</comment>
        </bits>
        <bits access="rw" name="rg_vcore_zx_offset" pos="11:10" rst="0x0">
          <comment>zero-cross offset tuning
2'b00: default
2'b01: +5mV offset
2'b10: -5mV offset
2'b11: -10mV offset</comment>
        </bits>
        <bits access="rw" name="rg_vcore_pfm_vh" pos="9:8" rst="0x0">
          <comment>PFM mode threshold for upper limit
2'b00: default, 0.6V
2'b01: 0.55V
2'b10: 0.65V
2'b11: 0.7V</comment>
        </bits>
        <bits access="rw" name="rg_vcore_rcomp" pos="7:6" rst="0x0">
          <comment>compensation R select
2'b00: default, 360k
2'b01: 320k
2'b10: 400k
2'b11: 440k</comment>
        </bits>
        <bits access="rw" name="rg_vcore_slope" pos="5:4" rst="0x0">
          <comment>slope compensation tuning
2'b00: default
2'b01: 0.5x
2'b10: 1.5x
2'b11: 2x</comment>
        </bits>
        <bits access="rw" name="rg_vcore_sr_hs" pos="3:2" rst="0x0">
          <comment>high side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
        <bits access="rw" name="rg_vcore_sr_ls" pos="1:0" rst="0x0">
          <comment>low side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
      </reg>
      <reg name="vrf_ctrl0" protect="rw">
        <comment>VRF_CTRL0</comment>
        <bits access="rw" name="rg_vrf_antiring_en" pos="6" rst="0x0">
          <comment>anti-ring enable
1'b0: default, anti-ring off
1'b1: anti-ring on</comment>
        </bits>
        <bits access="rw" name="rg_vrf_curlimit_r" pos="5:4" rst="0x0">
          <comment>current limit threshold tuning
2'b00: default
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
        <bits access="rw" name="rg_vrf_curavg" pos="3:2" rst="0x0">
          <comment>current sense average ratio
current sense multiplier tuning
2'b00: default, x1
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
        <bits access="rw" name="rg_vrf_curses_r" pos="1:0" rst="0x0">
          <comment>current sense R ratio tuning
current sense multiplier tuning
2'b00: default, x1
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
      </reg>
      <reg name="vrf_ctrl1" protect="rw">
        <comment>VRF_CTRL1</comment>
        <bits access="rw" name="rg_vrf_force_pwm" pos="13" rst="0x0">
          <comment>force PWM mode
1'b0: default, PFM/PWM auto mode
1'b1: force PWM mode</comment>
        </bits>
        <bits access="rw" name="rg_vrf_zx_disable" pos="12" rst="0x0">
          <comment>force zero-cross off
1'b0: default, zero_cross detect on
1'b1: zero-cross detect off</comment>
        </bits>
        <bits access="rw" name="rg_vrf_zx_offset" pos="11:10" rst="0x0">
          <comment>zero-cross offset tuning
2'b00: default
2'b01: +5mV offset
2'b10: -5mV offset
2'b11: -10mV offset</comment>
        </bits>
        <bits access="rw" name="rg_vrf_pfm_vh" pos="9:8" rst="0x0">
          <comment>PFM mode threshold for upper limit
2'b00: default, 0.6V
2'b01: 0.55V
2'b10: 0.65V
2'b11: 0.7V</comment>
        </bits>
        <bits access="rw" name="rg_vrf_rcomp" pos="7:6" rst="0x0">
          <comment>compensation R select
2'b00: default, 360k
2'b01: 320k
2'b10: 400k
2'b11: 440k</comment>
        </bits>
        <bits access="rw" name="rg_vrf_slope" pos="5:4" rst="0x0">
          <comment>slope compensation tuning
2'b00: default
2'b01: 0.5x
2'b10: 1.5x
2'b11: 2x</comment>
        </bits>
        <bits access="rw" name="rg_vrf_sr_hs" pos="3:2" rst="0x0">
          <comment>high side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
        <bits access="rw" name="rg_vrf_sr_ls" pos="1:0" rst="0x0">
          <comment>low side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
      </reg>
      <reg name="vgen_ctrl2" protect="rw">
        <comment>VGEN_CTRL2</comment>
        <bits access="rw" name="dcdc_gen_clk_rst" pos="8" rst="0x0">
          <comment>soft reset of all dcdc generated clk</comment>
        </bits>
        <bits access="rw" name="rg_vgen_antiring_en" pos="7" rst="0x0">
          <comment>anti-ring enable
1'b0: default, anti-ring off
1'b1: anti-ring on</comment>
        </bits>
        <bits access="rw" name="rg_vgen_zx_disable" pos="6" rst="0x0">
          <comment>force zero-cross off
1'b0: default, zero_cross detect on
1'b1: zero-cross detect off</comment>
        </bits>
        <bits access="rw" name="rg_vgen_zx_offset" pos="5:4" rst="0x0">
          <comment>zero-cross offset tuning
2'b00: default
2'b01: +5mV offset
2'b10: -5mV offset
2'b11: -10mV offset</comment>
        </bits>
        <bits access="rw" name="rg_vgen_curlimit_r" pos="3:2" rst="0x0">
          <comment>current limit threshold tuning
2'b00: default
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
        <bits access="rw" name="rg_vgen_curses_r" pos="1:0" rst="0x0">
          <comment>current sense R ratio tuning
current sense multiplier tuning
2'b00: default, x1
2'b01: -20%
2'b10: +40%
2'b11: +20%</comment>
        </bits>
      </reg>
      <reg name="vgen_ctrl3" protect="rw">
        <comment>VGEN_CTRL3</comment>
        <bits access="rw" name="rg_vgen_force_pwm" pos="11" rst="0x0">
          <comment>force PWM mode
1'b0: default, PFM/PWM auto mode
1'b1: force PWM mode</comment>
        </bits>
        <bits access="rw" name="rg_vgen_maxduty_sel" pos="10" rst="0x0">
          <comment>reserved</comment>
        </bits>
        <bits access="rw" name="rg_vgen_pfm_vh" pos="9:8" rst="0x0">
          <comment>PFM mode threshold for upper limit
2'b00: default, 0.6V
2'b01: 0.55V
2'b10: 0.65V
2'b11: 0.7V</comment>
        </bits>
        <bits access="rw" name="rg_vgen_rcomp" pos="7:6" rst="0x0">
          <comment>compensation R select
2'b00: default, 360k
2'b01: 320k
2'b10: 400k
2'b11: 440k</comment>
        </bits>
        <bits access="rw" name="rg_vgen_slope" pos="5:4" rst="0x0">
          <comment>slope compensation tuning
2'b00: default
2'b01: 0.5x
2'b10: 1.5x
2'b11: 2x</comment>
        </bits>
        <bits access="rw" name="rg_vgen_sr_hs" pos="3:2" rst="0x0">
          <comment>high side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
        <bits access="rw" name="rg_vgen_sr_ls" pos="1:0" rst="0x0">
          <comment>low side slew rate control
2'b00: default
2'b01: 0.75x
2'b10: 0.5x
2'b11: 0.25x</comment>
        </bits>
      </reg>
      <reg name="chgr_ctrl1" protect="rw">
        <comment>CHGR_CTRL1</comment>
        <bits access="rw" name="chgr_cc_en" pos="10" rst="0x0">
          <comment>Select charger CC mode enable, high effective, Default 0</comment>
        </bits>
        <bits access="rw" name="chgr_end_v" pos="9:8" rst="0x0">
          <comment>Battery charging end voltage
        00: Vend=4.2V
        01: Vend=4.3V
        10: Vend=4.4V
        11: Vend=4.5V
(default 2b00)</comment>
        </bits>
        <bits access="rw" name="chgr_iterm" pos="7:6" rst="0x0">
          <comment>Termination charger current programmable bits
00:cc*0.9
01:cc*0.4
10:cc*0.2
11:cc*0.1</comment>
        </bits>
        <bits access="rw" name="vchg_ovp_v" pos="5:4" rst="0x1">
          <comment>control bits of over voltage protection for VCHG. When VCHG is above some level set by these 2 bits, charger power down and CHGR_OVI becomes high.
      00: 6.0V     01: 6.5V    10: 7.0V    11: 9.7V
Default 2b01</comment>
        </bits>
        <bits access="rw" name="chgr_cc_i" pos="3:0" rst="0x0">
          <comment>CC mode charging current
0000:300mA        0001 : 350
0010: 400mA       0011 : 450
0100: 500mA       0101 :550
0110: 600mA       0111: 650
1000: 700mA       1001: 750
1010: 800mA       1011: 900
1100: 1000mA       1101: 1100
1110: 1200mA     1111: 1300
Default4b0</comment>
        </bits>
      </reg>
      <reg name="auxadc_ctrl" protect="rw">
        <comment>AUXADC_CTRL</comment>
        <bits access="rw" name="rg_auxad_thm_cal" pos="5" rst="0x0">
          <comment>THM calibration enable signal,
0: disable THM calibration(default)
1: enable THM calibration, must set high 100us before AUXADC measure THM voltage and start the calibration</comment>
        </bits>
        <bits access="rw" name="rg_auxad_currentsen_en" pos="4" rst="0x0">
          <comment>Aux ADC current sense enable signal, active high, default 0.</comment>
        </bits>
        <bits access="rw" name="rg_auxad_test_en" pos="3" rst="0x0">
          <comment>AUX ADC channel ATE test scan mode control. 1 for ATE test channel scan, 0 for normal work. For ATE test channel scan, set this reg to 1, and using AUXAD_CS[4:0] to scan channel.</comment>
        </bits>
        <bits access="rw" name="rg_auxad_vss_sel" pos="2" rst="0x0">
          <comment>AUXADC signal VSS selection,
0: share signal VSS ball with all analog circuit
1: use specific ground ball as signal VSS</comment>
        </bits>
        <bits access="rw" name="rg_auxad_ref_sel" pos="1" rst="0x0">
          <comment>AUXADC reference source selection,
0: from bandgap current generate internal reference (default)
1: from bandgap voltage reference directly.</comment>
        </bits>
        <bits access="rw" name="rg_auxad_sgn_code" pos="0" rst="0x0">
          <comment>AUXADC output code selection
0: output ADC 12 bit code with 11bit resolution.(default)
1: output ADC 12 bit original raw measured code.</comment>
        </bits>
      </reg>
      <reg name="chgr_status" protect="rw">
        <comment>CHGR_STATUS</comment>
        <bits access="r" name="non_dcp_int" pos="12" rst="0x0">
          <comment>Charging port of NON-DCP status
1 Charging port is NON-DCP
0 Charging port is not NON-DCP</comment>
        </bits>
        <bits access="r" name="chg_det_done" pos="11" rst="0x0">
          <comment>Charging detect done after charger insert once</comment>
        </bits>
        <bits access="r" name="dp_low" pos="10" rst="0x0">
          <comment>The output of the comparator of DCD detection or SDP/NON-DCP detection
1 means DCD pass when doing DCD,
 or SDP if CHG_DET=0
0 means DCD fail when doing DCD,
or NON-DCP if CHG_DET=0</comment>
        </bits>
        <bits access="r" name="dcp_det" pos="9" rst="0x0">
          <comment>The output of the comparator of  DCP_DET loop
1  means DCP if CHG_DET is 1
0 means CDP if CHG_DET is 1</comment>
        </bits>
        <bits access="r" name="chg_det" pos="8" rst="0x0">
          <comment>The output of the comparator of CHG_DET loop
1 DCP or CDP
0 SDP or NON-DCP</comment>
        </bits>
        <bits access="r" name="sdp_int" pos="7" rst="0x0">
          <comment>Charging port  of SDP status
1 Charging port is SDP
0 Charging port is not SDP</comment>
        </bits>
        <bits access="r" name="dcp_int" pos="6" rst="0x0">
          <comment>Charging port of DCP status
1 Charging port is DCP
0 Charging port is not DCP</comment>
        </bits>
        <bits access="r" name="cdp_int" pos="5" rst="0x0">
          <comment>Charging  port of CDP status
1 Charging port is CDP
0 Charging port is not CDP</comment>
        </bits>
        <bits access="r" name="chgr_cv_status" pos="4" rst="0x0">
          <comment>Flag when charging current below some level(0.5*full current) in CV mode
High effective</comment>
        </bits>
        <bits access="r" name="chgr_on" pos="3" rst="0x0">
          <comment>Charger voltage ready indicator, high effective
When VCHG&lt;4.1V: 0
When VCHG&gt;4.3V: 1</comment>
        </bits>
        <bits access="r" name="chgr_int" pos="2" rst="0x0">
          <comment>Charger present indicator, high effective
When VCHG&lt;3.1V: 0
When VCHG&gt;3.3V: 1</comment>
        </bits>
        <bits access="r" name="vchg_ovi" pos="0" rst="0x0">
          <comment>VCHG over voltage(programmable) flag
When VCHG higher than some voltage set by VCHG_OVP_V&lt;5:0&gt; and lasts 2mS, CHGR_OVI=1
The hysteresis voltage is 600mV.</comment>
        </bits>
      </reg>
      <reg name="arch_en" protect="rw">
        <comment>ARCH_EN</comment>
        <bits access="rw" name="arch_en" pos="0" rst="0x1">
          <comment>PCLK_arch enable</comment>
        </bits>
      </reg>
      <reg name="mcu_wr_prot_value" protect="rw">
        <comment>MCU_WR_PROT_VALUE</comment>
        <bits access="r" name="mcu_wr_prot" pos="15" rst="0x0">
          <comment>Arch_en write protect bit status.
When mcu_wr_prot_value==16'h3c4d,
 the bit is &quot;1&quot;,else &quot;0&quot;</comment>
        </bits>
        <bits access="w" name="mcu_wr_prot_value" pos="14:0" rst="0x0">
          <comment>Arch_en write protect value</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="dcdc_core_reg1" protect="rw">
        <comment>DCDC_CORE_REG1</comment>
        <bits access="rw" name="div_clk_vcore_en" pos="12" rst="0x0">
          <comment>clock gating enable</comment>
        </bits>
        <bits access="rw" name="phase_sel_vcore" pos="11:6" rst="0x0">
          <comment>the phase difference, 26M per step</comment>
        </bits>
        <bits access="rw" name="div_base_vcore" pos="5:0" rst="0xf">
          <comment>the division factor from 26M for DCDCCORE, in default the clock is from RC in analog
6'h0: no divide
6'h1: divide by 2

6'h3F: divide by 64</comment>
        </bits>
      </reg>
      <reg name="dcdc_gen_reg1" protect="rw">
        <comment>DCDC_GEN_REG1</comment>
        <bits access="rw" name="div_clk_vgen_en" pos="12" rst="0x0">
          <comment>clock gating enable</comment>
        </bits>
        <bits access="rw" name="phase_sel_vgen" pos="11:6" rst="0x0">
          <comment>the phase difference, 26M per step</comment>
        </bits>
        <bits access="rw" name="div_base_vgen" pos="5:0" rst="0xf">
          <comment>the division factor from 26M for DCDCGEN, in default the clock is from RC in analog
6'h0: no divide
6'h1: divide by 2

6'h3F: divide by 64</comment>
        </bits>
      </reg>
      <reg name="dcdc_vrf_reg1" protect="rw">
        <comment>DCDC_VRF_REG1</comment>
        <bits access="rw" name="div_clk_vrf_en" pos="12" rst="0x0">
          <comment>clock gating enable</comment>
        </bits>
        <bits access="rw" name="phase_sel_vrf" pos="11:6" rst="0x0">
          <comment>the phase difference, 26M per step</comment>
        </bits>
        <bits access="rw" name="div_base_vrf" pos="5:0" rst="0xf">
          <comment>the division factor from 26M for DCDCVRF, in default the clock is from RC in analog
6'h0: no divide
6'h1: divide by 2

6'h3F: divide by 64</comment>
        </bits>
      </reg>
      <reg name="bg_ctrl0" protect="rw">
        <comment>BG_CTRL</comment>
        <bits access="rw" name="bg_chop_en" pos="12" rst="0x0">
          <comment>Band-gap chopping enable:
0:chopping disable (default)
1: chopping enable</comment>
        </bits>
        <bits access="rw" name="rg_bg_ts" pos="8" rst="0x0">
          <comment>Band-gap test enable:
0:test disable (default)
1: test enable</comment>
        </bits>
      </reg>
      <reg name="ldo_vosel1" protect="rw">
        <comment>LDO_VOSEL1</comment>
        <bits access="rw" name="rg_ldo_usb33_vosel" pos="15:10" rst="0x33">
          <comment>USB33 LDO output voltage select                              000000~111111 1.625V~3.225V  25mv/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_cama_vosel" pos="5:0" rst="0x2f">
          <comment>CAMA LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_vosel3" protect="rw">
        <comment>LDO_VOSEL3</comment>
        <bits access="rw" name="rg_ldo_mmc_vosel" pos="15:10" rst="0x2b">
          <comment>MMC LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_vosel" pos="5:0" rst="0x37">
          <comment>VIO33 LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_vosel4" protect="rw">
        <comment>LDO_VOSEL4</comment>
        <bits access="rw" name="rg_ldo_lcd_vosel" pos="15:10" rst="0x7">
          <comment>LCD LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_vosel" pos="5:0" rst="0x7">
          <comment>LP18 LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
      </reg>
      <reg name="ldo_lp18_vio33_ctrl1" protect="rw">
        <comment>LDO_LP18_CTRL1</comment>
        <bits access="rw" name="rg_ldo_lp18_ulp_ifb_en" pos="12" rst="0x0">
          <comment>LDO_LP18 increase feedback current 300nA in ULP mode</comment>
        </bits>
        <bits access="rw" name="rg_ldo_lp18_ulp_itrim" pos="9:8" rst="0x0">
          <comment>LDO_LP18 bias current trim in ulp mode;20nA/step</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_ulp_ifb_en" pos="4" rst="0x0">
          <comment>LDO_VIO33 increase feedback current 300nA in ULP mode</comment>
        </bits>
        <bits access="rw" name="rg_ldo_vio33_ulp_itrim" pos="1:0" rst="0x0">
          <comment>LDO_VIO33 bias current trim in ulp mode;20nA/step</comment>
        </bits>
      </reg>
      <reg name="reserved_reg_core" protect="rw">
        <comment>RESERVED_REG_CORE</comment>
        <bits access="rw" name="reserved_core" pos="15:0" rst="0x0">
          <comment>reserved for CORE:
RG_RESERVED_CORE[0] for ldo ANA cap sel, default 0;
RG_RESERVED_CORE[1] for ldo CAMIO cap sel, default 0;
RG_RESERVED_CORE[2] for ldo RF18A cap sel, default 0;
RG_RESERVED_CORE[3] for ldo RF18B cap sel, default 0;</comment>
        </bits>
      </reg>
      <reg name="reserved_reg1" protect="rw">
        <comment>RESERVED_REG1</comment>
      </reg>
      <reg name="reserved_reg2" protect="rw">
        <comment>RESERVED_REG2</comment>
      </reg>
      <reg name="ldo_sim_ctrl0" protect="rw">
        <comment>LDO_SIM_CTRL0</comment>
        <bits access="rw" name="rg_ldo_sim1_cl_adj" pos="15:13" rst="0x3">
          <comment>LDO_SIM1 current limit threshold adjust                                         default 1'b011                                                                             000 to 111 current limit increase</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim1_shpt_en" pos="12" rst="0x1">
          <comment>LDO_SIM1 short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim1_rz_adj" pos="11" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim1_stb" pos="10:9" rst="0x0">
          <comment>LDO_SIM1 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim1_discharge_en" pos="8" rst="0x1">
          <comment>LDO_SIM1 discharge en</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim0_cl_adj" pos="7:5" rst="0x3">
          <comment>LDO_SIM0 current limit threshold adjust                                         default 1'b011                                                                             000 to 111 current limit increase</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim0_shpt_en" pos="4" rst="0x1">
          <comment>LDO_SIM0 short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim0_rz_adj" pos="3" rst="0x1">
          <comment>compensation resistor  adjust                                   default 1'b1</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim0_stb" pos="2:1" rst="0x0">
          <comment>LDO_SIM0 compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim0_discharge_en" pos="0" rst="0x1">
          <comment>LDO_SIM0 discharge en</comment>
        </bits>
      </reg>
      <reg name="ldo_sim_vosel" protect="rw">
        <comment>LDO_SIM_VOSEL</comment>
        <bits access="rw" name="rg_ldo_sim0_vosel" pos="15:10" rst="0x7">
          <comment>SIM0 LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step       1.8V=000111                                                             3V=110111</comment>
        </bits>
        <bits access="rw" name="rg_ldo_sim1_vosel" pos="5:0" rst="0x7">
          <comment>SIM1 LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step       1.8V=000111                                                             3V=110111</comment>
        </bits>
      </reg>
      <reg name="sim_vpa_ctrl0" protect="rw">
        <comment>SIM_VPA_CTRL0</comment>
        <bits access="rw" name="da_ldo_sim0_pd" pos="13" rst="0x1">
          <comment>LDO_SIM0 power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_sim1_pd" pos="12" rst="0x1">
          <comment>LDO_SIM1 power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_sim0_lp_en" pos="9" rst="0x0">
          <comment>LDO_SIM0 lower power mode  EN:
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_sim1_lp_en" pos="8" rst="0x0">
          <comment>LDO_SIM1 lower power mode  EN:
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="rg_vpa_lp_en" pos="4" rst="0x0">
          <comment>VPA low power mode
1'b0: active mode
1'b1: low-power mode</comment>
        </bits>
        <bits access="rw" name="rg_vpa_pd" pos="0" rst="0x1">
          <comment>DCDC VPA power down
1'b0: DCDC on
1'b1: DCDC power down</comment>
        </bits>
      </reg>
      <reg name="ldo_sim_ctrl1" protect="rw">
        <comment>LDO_SIM_CTRL1</comment>
        <bits access="rw" name="slp_ldosim1_pd_en" pos="13" rst="0x0">
          <comment>LDOSIM2 power down enable in deep sleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ldosim0_pd_en" pos="12" rst="0x0">
          <comment>LDO SIM1 power down enable in deep sleep mode</comment>
        </bits>
        <bits access="rw" name="slp_ldosim1_lp_en" pos="9" rst="0x0">
          <comment>LDO SIM1 low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="slp_ldosim0_lp_en" pos="8" rst="0x0">
          <comment>LDO SIM0 low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
      </reg>
      <reg name="vpa_ctrl0" protect="rw">
        <comment>VPA_CTRL0</comment>
        <bits access="rw" name="ldo_vpa_votrim_sw_sel" pos="12" rst="0x0">
          <comment>DCDC VPA reference Bits selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="da_vpa_votrim" pos="4:0" rst="0x10">
          <comment>output voltage trim
5'10000: default 1.2V, 18.75mV/step
5'11111: +15 step
5'00000: -16 step</comment>
        </bits>
      </reg>
      <reg name="vpa_ctrl1" protect="rw">
        <comment>VPA_CTRL1</comment>
        <bits access="rw" name="rg_vpa_vosel" pos="6:0" rst="0x78">
          <comment>output voltage selection, 25mV/step.
7'h00=0.4V,
7'h7C=3.5V
default 7'h78=3.4V</comment>
        </bits>
      </reg>
      <reg name="vpa_ctrl2" protect="rw">
        <comment>VPA_CTRL2</comment>
        <bits access="rw" name="rg_vpa_zx_disable" pos="15" rst="0x0">
          <comment>force zero-cross off
1'b0: default, zero_cross detect on
1'b1: zero-cross detect off</comment>
        </bits>
        <bits access="rw" name="rg_vpa_zx_offset" pos="14:13" rst="0x0">
          <comment>zero-cross offset tuning
2'b00: default
2'b01: +4mV offset
2'b10: -2mV offset
2'b11: -4mV offset</comment>
        </bits>
        <bits access="rw" name="rg_vpa_antiring_en" pos="12" rst="0x0">
          <comment>anti-ring enable
1'b0: default, anti-ring off
1'b1: anti-ring on</comment>
        </bits>
        <bits access="rw" name="rg_vpa_apc_enable" pos="11" rst="0x0">
          <comment>APC mode enable
1'b0: default, RG control mode
1'b1: APC mode</comment>
        </bits>
        <bits access="rw" name="rg_vpa_apc_ramp_sel" pos="10" rst="0x0">
          <comment>APC ramp selection
1'b0: default, 2.0x ramp
1'b1: 2.5x ramp</comment>
        </bits>
        <bits access="rw" name="rg_vpa_bypass_disable" pos="9" rst="0x0">
          <comment>bypass mode disable
1'b0: default, auto bypass
1'b1: bypass off</comment>
        </bits>
        <bits access="rw" name="rg_vpa_bypass_forceon" pos="8" rst="0x0">
          <comment>bypass force on
1'b0: default, auto bypass
1'b1: force bypass mode on</comment>
        </bits>
        <bits access="rw" name="rg_vpa_bypass_threshold" pos="7:6" rst="0x0">
          <comment>bypass mode threshold
2'b00: default, ~200mV</comment>
        </bits>
        <bits access="rw" name="rg_vpa_ccomp3" pos="5:4" rst="0x0">
          <comment>compensation C3
2'b00: default 6.5pF
2'b01: -0.5pF
2'b10: +1pF
2'b11: +0.5pF</comment>
        </bits>
        <bits access="rw" name="rg_vpa_curlimit_r" pos="3:2" rst="0x0">
          <comment>current limit threshold tuning
2'b00: default 36k
2'b01: 52k
2'b10: 12k
2'b11: 28k</comment>
        </bits>
        <bits access="rw" name="rg_vpa_curses_m" pos="1:0" rst="0x0">
          <comment>current sense multiplier tuning
2'b00: default, x1
2'b01: x0.5
2'b10: x2
2'b11: x1.5</comment>
        </bits>
      </reg>
      <reg name="vpa_ctrl3" protect="rw">
        <comment>VPA_CTRL3</comment>
        <bits access="rw" name="rg_vpa_sawtoothcal_rst" pos="15" rst="0x0">
          <comment>sawtooth calibration
1'b0: default, auto calibration before power-on
1'b1: calibration manully</comment>
        </bits>
        <bits access="rw" name="rg_vpa_dvs_on" pos="14" rst="0x0">
          <comment>DVS control
1'b0: default, off
1'b0: on, for DCM down discharge</comment>
        </bits>
        <bits access="rw" name="rg_vpa_force_pwm" pos="13" rst="0x0">
          <comment>force PWM mode
1'b0: default, PFM/PWM auto mode
1'b1: force PWM mode</comment>
        </bits>
        <bits access="rw" name="rg_vpa_maxduty_sel" pos="12" rst="0x0">
          <comment>100% duty selection
1'b0: default, max duty=100%
1'b1: max duty ~95%</comment>
        </bits>
        <bits access="rw" name="rg_vpa_pfm_threshold" pos="11:10" rst="0x0">
          <comment>PFM mode threshold for upper limit
2'b00: default,960mV
2'b01: -40mV
2'b10: +40mV
2'b11: +80mV</comment>
        </bits>
        <bits access="rw" name="rg_vpa_rcomp2" pos="9:8" rst="0x0">
          <comment>compensation R2 select
2'b00: default, 960k
2'b01: 880k
2'b10: 1040k
2'b11: 1120k</comment>
        </bits>
        <bits access="rw" name="rg_vpa_rcomp3" pos="7:6" rst="0x0">
          <comment>compensation R3 select
2'b00: default, 9k
2'b01: 4.5k
2'b10: 18k
2'b11: 13.5k</comment>
        </bits>
        <bits access="rw" name="rg_vpa_sawtooth_slope" pos="5:4" rst="0x0">
          <comment>sawtooth tuning manully
2'b00: default 0.75x
2'b01: 0.875x
2'b10: 0.5x
2'b11: 0.625x</comment>
        </bits>
        <bits access="rw" name="rg_vpa_sr_hs" pos="3:2" rst="0x0">
          <comment>high side slew rate control
2'b00: default 2.5x
2'b01: 2x
2'b10: 1.5x
2'b11: 1x</comment>
        </bits>
        <bits access="rw" name="rg_vpa_sr_ls" pos="1:0" rst="0x0">
          <comment>low side slew rate control
2'b00: default 2x
2'b01: 1.5x
2'b10: 1.5x
2'b11: 1x</comment>
        </bits>
      </reg>
      <reg name="dcdc_vpa_reg1" protect="rw">
        <comment>DCDC_VPA_REG1</comment>
        <bits access="rw" name="div_clk_vpa_en" pos="12" rst="0x0">
          <comment>clock gating enable</comment>
        </bits>
        <bits access="rw" name="phase_sel_vpa" pos="11:6" rst="0x0">
          <comment>the phase difference, 26M per step</comment>
        </bits>
        <bits access="rw" name="div_base_vpa" pos="5:0" rst="0xf">
          <comment>the division factor from 26M for DCDCWPA, in default the clock is from RC in analog
6'h0: no divide
6'h1: divide by 2

6'h3F: divide by 64</comment>
        </bits>
      </reg>
      <hole size="1824"/>
      <reg name="sim_vpa_ctrl0_set" protect="rw"/>
      <reg name="ldo_sim_ctrl1_set" protect="rw"/>
      <hole size="1984"/>
      <reg name="sim_vpa_ctrl0_clr" protect="rw"/>
      <reg name="ldo_sim_ctrl1_clr" protect="rw"/>
    </module>
    <var name="REG_PMIC_ANA_SET_OFFSET" value="0x100"/>
    <var name="REG_PMIC_ANA_CLR_OFFSET" value="0x200"/>
    <instance address="0x51108c00" name="PMIC_ANA" type="PMIC_ANA"/>
  </archive>
  <archive relative="pmic_rtc_ana.xml">
    <module category="System" name="PMIC_RTC_ANA">
      <reg name="module_en0" protect="rw">
        <comment>MODULE_EN0</comment>
        <bits access="rw" name="iomux_en" pos="8" rst="0x1">
          <comment>PINREG module enable
0: Disable the PCLK  of pin registers
1: Enable  the PCLK  of pin registers</comment>
        </bits>
        <bits access="rw" name="rtc_topa_en" pos="7" rst="0x1">
          <comment>RTC_TOPA module enable
0: Disable the PCLK  of RTC_TOPA
1: Enable  the PCLK  of RTC_TOPA</comment>
        </bits>
        <bits access="rw" name="psm_topa_en" pos="4" rst="0x0">
          <comment>PSM  module enable
0: Disable the PCLK  of PSM
1: Enable  the PCLK  of PSM</comment>
        </bits>
        <bits access="rw" name="eic_en" pos="3" rst="0x0">
          <comment>EIC module enable
0: Disable the PCLK  of EIC
1: Enable  the PCLK  of EIC</comment>
        </bits>
        <bits access="rw" name="wdg_en" pos="2" rst="0x0">
          <comment>WDG module enable
0: Disable the PCLK  of watchdog
1: Enable  the PCLK  of watchdog</comment>
        </bits>
        <bits access="rw" name="rtc_en" pos="1" rst="0x1">
          <comment>RTC module enable
0: Disable the PCLK  of RTC
1: Enable  the PCLK  of RTC</comment>
        </bits>
      </reg>
      <reg name="dig_clk_en0" protect="rw">
        <comment>DIG_CLK_EN0</comment>
        <bits access="rw" name="clk_wdg_sel" pos="0" rst="0x0">
          <comment>WDG clk sel
0: clk_wdg_rtc
1: clk_32k_rtc</comment>
        </bits>
      </reg>
      <reg name="rtc_clk_en0" protect="rw">
        <comment>RTC_CLK_EN0</comment>
        <bits access="rw" name="rtc_efs_en" pos="11" rst="0x1">
          <comment>EFS RTC clock soft enable
0: Disable the RTC clock of EFS
1: Enable RTC clock of EFS</comment>
        </bits>
        <bits access="rw" name="rtc_eic_en" pos="3" rst="0x0">
          <comment>EIC RTC clock soft enable
0: Disable the RTC clock of EIC
1: Enable RTC clock of EIC</comment>
        </bits>
        <bits access="rw" name="rtc_wdg_en" pos="2" rst="0x1">
          <comment>Watchdog RTC clock soft enable
0: Disable the RTC clock of Watchdog
1: Enable RTC clock of Watchdo</comment>
        </bits>
        <bits access="rw" name="rtc_rtc_en" pos="1" rst="0x1">
          <comment>RTC RTC clock soft enable
0: Disable the RTC clock of RTC
1: Enable RTC clock of RTC</comment>
        </bits>
        <bits access="rw" name="rtc_arch_en" pos="0" rst="0x1">
          <comment>ARCH RTC clock soft enable
0: Disable the RTC clock of ARCH
1: Enable RTC clock of ARCH</comment>
        </bits>
      </reg>
      <reg name="soft_rst0" protect="rw">
        <comment>SOFT_RST0</comment>
        <bits access="rw" name="eic_soft_rst" pos="3" rst="0x0">
          <comment>EIC soft reset</comment>
        </bits>
        <bits access="rw" name="wdg_soft_rst" pos="2" rst="0x0">
          <comment>Watchdog soft reset</comment>
        </bits>
        <bits access="rw" name="rtc_soft_rst" pos="1" rst="0x0">
          <comment>RTC soft reset</comment>
        </bits>
      </reg>
      <reg name="vbat_ctrl1" protect="rw">
        <comment>VBAT_CTRL1</comment>
        <bits access="rw" name="da_ldo_vbat_reftrim_ulp" pos="12:8" rst="0x10">
          <comment>LDO_VBAT ULP reference voltage trim bit</comment>
        </bits>
        <bits access="rw" name="da_ldo_vbat_reftrim" pos="4:0" rst="0x10">
          <comment>LDO_VBAT reference voltage trim bit</comment>
        </bits>
      </reg>
      <reg name="ldo_vgen_ctrl3" protect="rw">
        <comment>LDO_VGEN_CTRL3</comment>
        <bits access="rw" name="da_ldo_vgen_reftrim" pos="4:0" rst="0x10">
          <comment>LDO_VGEN reference voltage trim bit</comment>
        </bits>
      </reg>
      <reg name="dcdc_ctrl1" protect="rw">
        <comment>DCDC_CTRL1</comment>
        <bits access="rw" name="da_dcdc_osc3m_en" pos="10" rst="0x0">
          <comment>internal oscillator enable
1'b0: oscillator off
1'b1: oscillator on</comment>
        </bits>
        <bits access="rw" name="da_dcdc_osc3m_freq" pos="9:5" rst="0x10">
          <comment>oscillator frequency tuning
5'b10000: default 3MHz
5'b01111: -1 step
5'b10001: +1 step
5'b00000: -16 step
5'b11111: +15 step</comment>
        </bits>
      </reg>
      <reg name="pm2_pd_en" protect="rw">
        <comment>PM2_PD_EN</comment>
        <bits access="rw" name="pm2_dcdc_core_ulp_en" pos="14" rst="0x0">
          <comment>PM2 VCORE ULP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldovio33_ulp_en" pos="13" rst="0x0">
          <comment>PM2 VIO33 ULP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldolp18_ulp_en" pos="12" rst="0x0">
          <comment>PM2 LP18 ULP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_dcdccore_lp_en" pos="11" rst="0x0">
          <comment>PM2 VCORE LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_dcdcgen_lp_en" pos="10" rst="0x0">
          <comment>PM2 VGEN LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldolp18_lp_en" pos="9" rst="0x0">
          <comment>PM2 VLP18 LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldodcxo_lp_en" pos="8" rst="0x0">
          <comment>PM2 VDCXO LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldovio33_lp_en" pos="7" rst="0x0">
          <comment>PM2 VIO33 LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldovio18_lp_en" pos="6" rst="0x0">
          <comment>PM2 VIO18 LP mode en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_dcdccore_pd_en" pos="5" rst="0x0">
          <comment>VCORE power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_dcdcgen_pd_en" pos="4" rst="0x0">
          <comment>VGEN power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldolp18_pd_en" pos="3" rst="0x0">
          <comment>VLP18 power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldodcxo_pd_en" pos="2" rst="0x0">
          <comment>VDCXO power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldovio33_pd_en" pos="1" rst="0x0">
          <comment>VIO33 power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldovio18_pd_en" pos="0" rst="0x0">
          <comment>VIO18 power down en
1'b0: disable
1'b1: enable</comment>
        </bits>
      </reg>
      <reg name="vgen_ctrl1" protect="rw">
        <comment>VGEN_CTRL1</comment>
        <bits access="rw" name="rg_vgen_vosel" pos="7:0" rst="0x2c">
          <comment>output voltage selection, 12.5mV/step.
8'h00= 1.3V
default 8'h2c=1.85V</comment>
        </bits>
      </reg>
      <reg name="ldo_vbat_ctrl1" protect="rw">
        <comment>LDO_VBAT_CTRL1</comment>
      </reg>
      <reg name="chgr_status" protect="rw">
        <comment>CHGR_STATUS</comment>
        <bits access="rw" name="chgr_int_en" pos="13" rst="0x0">
          <comment>Chgr_int enable after CHG_DET_DONE</comment>
        </bits>
        <bits access="rw" name="dcp_switch_en" pos="1" rst="0x1">
          <comment>0: switch DPDM to USB phy when DCP
1: keep to connect charger detector when DCP</comment>
        </bits>
      </reg>
      <reg name="power_pd_sw0" protect="rw">
        <comment>POWER_PD_SW0</comment>
        <bits access="rw" name="da_ldo_spimem_pd" pos="15" rst="0x0">
          <comment>LDO_SPIMEM power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_usb33_pd" pos="14" rst="0x0">
          <comment>LDO_USB power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_ana_pd" pos="13" rst="0x0">
          <comment>LDO_ANA power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_rf12_pd" pos="12" rst="0x0">
          <comment>LDO_RF12 power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_lp18_pd" pos="11" rst="0x0">
          <comment>LDO_LP18 power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_vio33_pd" pos="10" rst="0x0">
          <comment>LDO_VIO33 power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="ldo_emm_pd" pos="9" rst="0x0">
          <comment>EMM domain power down                                            1: power down                                                                0: power on</comment>
        </bits>
        <bits access="rw" name="ldo_cp_pd" pos="8" rst="0x0">
          <comment>LDO of charge pump power down
1: power down
0: power on</comment>
        </bits>
        <bits access="rw" name="da_ldo_dcxo_pd" pos="7" rst="0x0">
          <comment>LDO_DCXO power down                                           1: power down                                                                0: power on</comment>
        </bits>
        <bits access="rw" name="da_ldo_mem_pd" pos="6" rst="0x0">
          <comment>LDO_MEM power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_vio18_pd" pos="5" rst="0x0">
          <comment>LDO_VIO18 power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_vgen_pd" pos="4" rst="0x0">
          <comment>DCDC power down
1'b0: DCDC on
1'b1: DCDC power down</comment>
        </bits>
        <bits access="rw" name="da_vrf_pd" pos="3" rst="0x0">
          <comment>DCDC power down
1'b0: DCDC on
1'b1: DCDC power down</comment>
        </bits>
        <bits access="rw" name="da_vcore_pd" pos="2" rst="0x0">
          <comment>DCDC power down
1'b0: DCDC on
1'b1: DCDC power down</comment>
        </bits>
        <bits access="rw" name="da_ldo_mmc_pd" pos="1" rst="0x0">
          <comment>LDO_MMC power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="bg_pd" pos="0" rst="0x0">
          <comment>Band-gap power down:
1 is power down
0 is power up
At reset, should be &quot;1&quot;</comment>
        </bits>
      </reg>
      <reg name="power_pd_hw" protect="rw">
        <comment>POWER_PD_HW</comment>
        <bits access="rw" name="pwr_off_seq_en" pos="0" rst="0x0">
          <comment>Power off_sequence enable</comment>
        </bits>
      </reg>
      <reg name="soft_rst_hw" protect="rw">
        <comment>SOFT_RST_HW</comment>
        <bits access="rw" name="reg_soft_rst_sw" pos="0" rst="0x0">
          <comment>register soft resetwrite 1 can
1 reset total system
2 power down and up</comment>
        </bits>
      </reg>
      <reg name="xtal_rc_ctrl" protect="rw">
        <comment>XTAL_RC_CTRL</comment>
        <bits access="rw" name="rg_rc64k_pu" pos="7" rst="0x1">
          <comment>RC Oscillator 32kHz power up
1b0: power off
1'b1:  power on</comment>
        </bits>
        <bits access="rw" name="rg_xtal32k_pu" pos="6" rst="0x1">
          <comment>Crystal 64kHz power up
1b0: power off
1'b1:  power on</comment>
        </bits>
        <bits access="rw" name="rg_xtal32k_coarse" pos="5:3" rst="0x4">
          <comment>Crystal 32kHz capacitor coarse adjust</comment>
        </bits>
        <bits access="rw" name="rg_xtal32k_fine" pos="2:0" rst="0x5">
          <comment>Crystal 32kHz capacitor fine adjust</comment>
        </bits>
      </reg>
      <reg name="rtc_ctrl" protect="rw">
        <comment>RTC_CTRL</comment>
        <bits access="rw" name="rg_rtc_vosel" pos="10:8" rst="0x4">
          <comment>LDO RTC output program bits
3'b100: 1.8V (Default)</comment>
        </bits>
        <bits access="rw" name="rg_vbatbk_vosel" pos="7:5" rst="0x4">
          <comment>Backup battery output program bits
3'b100: 3.0V default</comment>
        </bits>
        <bits access="rw" name="da_rtcbg_trim" pos="4:0" rst="0x10">
          <comment>RTC bandgap calibretion bit
cover +/-10%
step 0.625% acc +/- 0.3125%</comment>
        </bits>
      </reg>
      <reg name="rg_rtc_reserved1" protect="rw">
        <comment>RG_RTC_RESERVED1</comment>
        <bits access="rw" name="rg_rtc_reserved0" pos="15:8" rst="0xf0">
          <comment>RG_RTC_RESERVED0</comment>
        </bits>
        <bits access="rw" name="rg_rtc_reserved1" pos="7:0" rst="0xf0">
          <comment>RG_RTC_RESERVED1</comment>
        </bits>
      </reg>
      <reg name="dvdd_ctrl" protect="rw">
        <comment>DVDD_CTRL</comment>
        <bits access="rw" name="da_psm_vref_pd" pos="2" rst="0x0">
          <comment>ULP global bias power down
1'b0:  default, power on
1'b1:  power down</comment>
        </bits>
        <bits access="rw" name="da_dvdd_iso" pos="1" rst="0x1">
          <comment>DVDD18 isolation signal used in force mode
1'b1:  default isolation</comment>
        </bits>
        <bits access="rw" name="da_dvdd_pd" pos="0" rst="0x0">
          <comment>DVDD18 power down control used in force mode
1'b0:  DVDD18 power switch on
1'b1:  DVDD18 power switch off</comment>
        </bits>
      </reg>
      <reg name="powon_ctrl" protect="rw">
        <comment>POWON_CTRL</comment>
        <bits access="rw" name="rg_baton_t" pos="15:14" rst="0x0">
          <comment>Control bit of de-glitch time for battery remove
&quot;00&quot; 32us    &quot;01&quot; 64us    &quot;10&quot; 128us    &quot;11&quot; no de-glitch         default&quot;00&quot;</comment>
        </bits>
        <bits access="rw" name="rg_ovlo_en" pos="13" rst="0x1">
          <comment>Over voltage locked-out enable (high effective)
Default 1</comment>
        </bits>
        <bits access="rw" name="rg_ovlo_t" pos="12:11" rst="0x0">
          <comment>Over voltage locked-out detecting time
00 : 1ms (default)
01 : 0.5ms
10 : 0.25ms
11 : 2ms</comment>
        </bits>
        <bits access="rw" name="rg_ovlo_v" pos="10:9" rst="0x0">
          <comment>Over voltage locked-out threshold
00 : 5.0V (default)
01 : 5.2V
10 : 4.8V
11 : 4.2V</comment>
        </bits>
        <bits access="rw" name="rg_uvlo_v" pos="8:7" rst="0x0">
          <comment>over voltage locked-out threshold
00 : 1.9V (default)
01 : 1.95V
10 : 1.85V
11 : 1.8V</comment>
        </bits>
        <bits access="rw" name="rg_vbat_crash_v" pos="6:5" rst="0x0">
          <comment>Battery crash voltage setting:
00: 1.7/2.1V (default)
01: 1.8/2.2V
10: 1.65/2.3V
11: 1.6/2.5V</comment>
        </bits>
        <bits access="rw" name="rg_buadet_en" pos="4" rst="0x0">
          <comment>BUA function enable
1'b0: default, off
1'b1: enable</comment>
        </bits>
        <bits access="rw" name="rg_pbint_pullh_enb" pos="3" rst="0x0">
          <comment>PBINT pull-high control
1'b0: with internal pull-high. Default
1'b1: without internal pull-high</comment>
        </bits>
        <bits access="rw" name="da_powerdet_en" pos="2" rst="0x0">
          <comment>Power detect enable
1'b0: default, off
1'b1: Power detect on (UVLO/OVLO/VBATLOW)</comment>
        </bits>
        <bits access="rw" name="rg_vbatlow_en" pos="1" rst="0x1">
          <comment>VBATLOW detect enable control at LP mode
1'b0: VBATLOW detect off
1'b1: VBATLOW detect on</comment>
        </bits>
        <bits access="rw" name="rg_uvlo_en" pos="0" rst="0x1">
          <comment>UVLO detect enable control at LP mode
1'b0: UVLO detect off
1'b1: UVLO detect on</comment>
        </bits>
      </reg>
      <reg name="kpled_ctrl0" protect="rw">
        <comment>KPLED_CTRL0</comment>
        <bits access="rw" name="rg_kpled_pd" pos="7" rst="0x1">
          <comment>Key PAD LED driver power down
1 power down (default)
0 enable</comment>
        </bits>
        <bits access="rw" name="rg_kpled_pulldown_en" pos="6" rst="0x0">
          <comment>Keypad LED pull down enable signale, high effective
Defautl 1'b0</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_pd" pos="5" rst="0x1">
          <comment>KPLED LDO power down signal, high effective
(Default 1, Off) iload=50mA</comment>
        </bits>
        <bits access="rw" name="rg_ldo_kpled_reftrim" pos="4:0" rst="0x10">
          <comment>LDO_KPLED trim bits:
6.25mV/step, 0.7V~0.89375V;   default 0.8V, 5'b10000</comment>
        </bits>
      </reg>
      <reg name="power_pd_sw1" protect="rw">
        <comment>POWER_PD_SW1</comment>
        <bits access="rw" name="da_ldo_cama_pd" pos="11" rst="0x1">
          <comment>LDO_CAMA power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_camd_pd" pos="10" rst="0x1">
          <comment>LDO_CAMD power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_lcd_pd" pos="8" rst="0x1">
          <comment>LDO_LCD power down:
1 is power down(default)
0 is power up</comment>
        </bits>
        <bits access="rw" name="da_ldo_rf15_pd" pos="3" rst="0x1">
          <comment>LDO_RF15 power down:
1 is power down(default)
0 is power up</comment>
        </bits>
      </reg>
      <reg name="power_lp_sw0" protect="rw">
        <comment>POWER_LP_SW0</comment>
        <bits access="rw" name="da_ldo_usb33_lp_en" pos="13" rst="0x0">
          <comment>LDO_USB lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_dcxo_lp_en" pos="12" rst="0x0">
          <comment>LDO_DCXO lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_cama_lp_en" pos="11" rst="0x0">
          <comment>LDO_CAMA lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_camd_lp_en" pos="10" rst="0x0">
          <comment>LDO_CAMD lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_mmc_lp_en" pos="9" rst="0x0">
          <comment>LDO_MMC lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_lcd_lp_en" pos="8" rst="0x0">
          <comment>LDO_LCD lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_vio18_lp_en" pos="7" rst="0x0">
          <comment>LDO_VIO18 lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_ana_lp_en" pos="6" rst="0x0">
          <comment>LDO_ANA lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_mem_lp_en" pos="5" rst="0x0">
          <comment>LDO_MEM lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_spimem_lp_en" pos="4" rst="0x0">
          <comment>LDO_SPIMEM lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_rf15_lp_en" pos="3" rst="0x0">
          <comment>LDO_RF15 lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_rf12_lp_en" pos="2" rst="0x0">
          <comment>LDO_RF12 lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_lp18_lp_en" pos="1" rst="0x0">
          <comment>LDO_LP18 lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_vio33_lp_en" pos="0" rst="0x0">
          <comment>LDO_VIO33 lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
      </reg>
      <reg name="ldo_vosel1" protect="rw">
        <comment>LDO_VOSEL1</comment>
        <bits access="rw" name="rg_ldo_dcxo_vosel" pos="5:0" rst="0x7">
          <comment>DCXO LDO output voltage select                              000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
      </reg>
      <reg name="slp_ldo_ulp_ctrl" protect="rw">
        <comment>SLP_LDO_ULP_CTRL</comment>
        <bits access="rw" name="pm1_dcdc_core_ulp_en" pos="2" rst="0x0">
          <comment>LDO_VCORE ultra lower power mode  EN:
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="pm1_ldo_vio33_ulp_en" pos="1" rst="0x0">
          <comment>LDO_VIO33 ultra lower power mode  EN:
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="pm1_ldo_lp18_ulp_en" pos="0" rst="0x0">
          <comment>LDO_LP18 ultra lower power mode  EN:
1 is enable
0 is disable(default)</comment>
        </bits>
      </reg>
      <reg name="ldo_vgen_ctrl" protect="rw">
        <comment>LDO_VGEN_CTRL</comment>
        <bits access="rw" name="rg_ldo_vgen_auxcal_sel" pos="2:0" rst="0x0">
          <comment>DCDC supplied LDO TRIM CONTROL BITS:
000:  cal disable (default)
001: LDO VDDCAMIOcal enable;
010: LDO ANA cal enable;
011: LDO VDDRF18A cal enable;
100: LDO VDDCAMD cal enable;
101: LDO VDDMEM cal enable;
110: LDO VDDCON cal enable;
111: LDO VDDRF18B cal enable;</comment>
        </bits>
      </reg>
      <reg name="ldo_lp18_vio33_ulp_en" protect="rw">
        <comment>LDO_LP18_VIO33_ULP_EN</comment>
        <bits access="rw" name="da_ldo_vio33_ulp_en" pos="1" rst="0x0">
          <comment>LDO_VIO33 ultra lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
        <bits access="rw" name="da_ldo_lp18_ulp_en" pos="0" rst="0x0">
          <comment>LDO_LP18 ultra lower power mode  EN(force mode):
1 is enable
0 is disable(default)</comment>
        </bits>
      </reg>
      <reg name="vcore_ctrl0" protect="rw">
        <comment>VCORE_CTRL0</comment>
        <bits access="rw" name="da_vcore_vosel" pos="8:0" rst="0x120">
          <comment>output voltage selection
9'b100100000, default 0.9V</comment>
        </bits>
      </reg>
      <reg name="vcore_ctrl1" protect="rw">
        <comment>VCORE_CTRL1</comment>
        <bits access="rw" name="rg_vcore_lp_en" pos="14" rst="0x0">
          <comment>low power mode(force mode)
1'b0: active mode
1'b1: low-power mode</comment>
        </bits>
        <bits access="rw" name="da_vcore_ulp_en" pos="13" rst="0x0">
          <comment>Ultra- low power mode(force mode)
1'b0: active mode
1'b1: low-power mode</comment>
        </bits>
        <bits access="rw" name="da_vcore_ulp_ret" pos="12" rst="0x0">
          <comment>Retention active at ULP mode(force mode)
1'b0: retention off
1'b1: retention active</comment>
        </bits>
        <bits access="rw" name="da_vcore_votrim" pos="9:5" rst="0x10">
          <comment>output voltage trimming</comment>
        </bits>
        <bits access="rw" name="da_vcore_votrim_lp" pos="4:0" rst="0x10">
          <comment>output voltage trimming at low power mode</comment>
        </bits>
      </reg>
      <reg name="vrf_ctrl2" protect="rw">
        <comment>VRF_CTRL2</comment>
        <bits access="rw" name="da_vrf_lp_en" pos="5" rst="0x0">
          <comment>VRF low power mode(force mode)
1'b0: active mode
1'b1: low-power mode</comment>
        </bits>
        <bits access="rw" name="da_vrf_votrim" pos="4:0" rst="0x10">
          <comment>output voltage selection, 12.5mV/step.
8'h00= 1.3V
default 8'h2c=1.85V</comment>
        </bits>
      </reg>
      <reg name="vrf_ctrl3" protect="rw">
        <comment>VRF_CTRL3</comment>
        <bits access="rw" name="rg_vrf_vosel" pos="8:0" rst="0xd0">
          <comment>output voltage selection, 6.25mV/step.
9'b011010000, default 1.3V</comment>
        </bits>
      </reg>
      <reg name="vgen_ctrl0" protect="rw">
        <comment>VGEN_CTRL0</comment>
        <bits access="rw" name="slp_ldo_mem_powersel_en" pos="9" rst="0x0">
          <comment>LP mode VMEM power switch enable:
1'b0:VMEM out
1'b1:VMEM short lp18,lp18 out</comment>
        </bits>
        <bits access="rw" name="pm2_ldo_mem_powersel" pos="8" rst="0x0">
          <comment>PM2 LDO VMEM power switch value:
1'b0:VMEM out
1'b1:VMEM short lp18,lp18 out</comment>
        </bits>
        <bits access="rw" name="da_vgen_lp_en" pos="5" rst="0x0">
          <comment>VGEN low power mode(force mode)
1'b0: active mode
1'b1: low-power mode</comment>
        </bits>
        <bits access="rw" name="da_vgen_votrim" pos="4:0" rst="0x10">
          <comment>VGEN output voltage trim
5'10000: default 1.2V, 18.75mV/step
5'11111: +15 step
5'00000: -16 step</comment>
        </bits>
      </reg>
      <reg name="chgr_ctrl0" protect="rw">
        <comment>CHGR_CTRL0</comment>
        <bits access="rw" name="chgr_pd" pos="10" rst="0x0">
          <comment>1  Internal charger power down
 0 Internal charger power up</comment>
        </bits>
        <bits access="rw" name="chgr_ptest" pos="9" rst="0x0">
          <comment>Charger production test signal,testmode flag
&quot;1&quot;ATE test mode, reduce delay time after VCHG insert
&quot;0&quot; normal mode</comment>
        </bits>
        <bits access="rw" name="chgr_expower_device" pos="8" rst="0x0">
          <comment>Choice of charger external power device
0:PNP+NMOS
1:PMOS+DIODE
Default value is 0</comment>
        </bits>
        <bits access="rw" name="chgr_dpm" pos="7:6" rst="0x3">
          <comment>VCHG tracking voltage level for automatic input control loop(AICL)
00: 3.8V
01: 3.95V
10: 4.3V
11: 4.5V
Default value is 11</comment>
        </bits>
        <bits access="rw" name="chgr_cv_v" pos="5:0" rst="0x10">
          <comment>Battery sense DAC (CC-CV trans-point control)
(default 6b010000)</comment>
        </bits>
      </reg>
      <reg name="chgr_det_ctrl0" protect="rw">
        <comment>CHGR_DET_CTRL0</comment>
        <bits access="rw" name="dp_dm_bc_enb" pos="5" rst="0x1">
          <comment>The DP DM path switch control
1 switch to USB phy, BC1P2 detect disable (default)
0 switch to BC1P2, BC1P2 detect enable</comment>
        </bits>
        <bits access="rw" name="rg_dp_dm_aux_en" pos="4" rst="0x0">
          <comment>DP, DM to auxADC select signal:
0: switch off, no DP/DM to auxADC
1: switch on, DP/DM to auxADC</comment>
        </bits>
        <bits access="rw" name="chg_int_delay" pos="2:0" rst="0x0">
          <comment>charger int delay time:
0000ms
00164ms
010264ms
..
111764ms</comment>
        </bits>
      </reg>
      <reg name="slp_ldo_pd_ctrl0" protect="rw">
        <comment>SLP_LDO_PD_CTRL0</comment>
        <bits access="rw" name="pm1_ldovio18_pd_en" pos="15" rst="0x0">
          <comment>LDO VIO18 power down enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldoana_pd_en" pos="14" rst="0x0">
          <comment>LDO ANA power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldorf12_pd_en" pos="13" rst="0x0">
          <comment>LDO RF12 power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldolp18_pd_en" pos="12" rst="0x0">
          <comment>LDO LP18 power down enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldodcxo_pd_en" pos="11" rst="0x0">
          <comment>LDO DCXO power down enable PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldovio33_pd_en" pos="10" rst="0x0">
          <comment>LDO VIO33 power down enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldorf15_pd_en" pos="9" rst="0x0">
          <comment>LDO RF15 power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldospimem_pd_en" pos="8" rst="0x0">
          <comment>LDO SPIMEM power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldousb_pd_en" pos="7" rst="0x0">
          <comment>LDO USB power down enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldokpled_pd_en" pos="6" rst="0x0">
          <comment>LDO KPLED power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldommc_pd_en" pos="5" rst="0x0">
          <comment>LDO MMC power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldolcd_pd_en" pos="4" rst="0x0">
          <comment>LDO LCD power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldocamd_pd_en" pos="3" rst="0x0">
          <comment>LDO CAMD power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldocama_pd_en" pos="2" rst="0x0">
          <comment>LDO CAMA power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="slp_ldo_pd_ctrl1" protect="rw">
        <comment>SLP_LDO_PD_CTRL1</comment>
        <bits access="rw" name="pm1_ldocp_pd_en" pos="4" rst="0x0">
          <comment>LDO CP power down enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldo_pd_en" pos="3" rst="0x0">
          <comment>ALL LDO and DCDC power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_io_en" pos="2" rst="0x0">
          <comment>IO PAD sleep enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="ldo_xtl_en" pos="1" rst="0x0">
          <comment>LDO and DCDC can be controlled by external device if this bit is set
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldomem_pd_en" pos="0" rst="0x0">
          <comment>LDO MEM power down enable in PM1
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="slp_dcdc_pd_ctrl" protect="rw">
        <comment>SLP_DCDC_PD_CTRL</comment>
        <bits access="rw" name="slp_dcdccore_pd_rstn_th" pos="15:12" rst="0x0">
          <comment>The number of 32K cycles set reset delay in DCDC CORE power down sleep mode</comment>
        </bits>
        <bits access="rw" name="slp_dcdccore_pu_rstn_th" pos="11:6" rst="0x0">
          <comment>The number of 32K cycles release reset delay in DCDC CORE power down sleep mode</comment>
        </bits>
        <bits access="rw" name="slp_dcdccore_drop_en" pos="3" rst="0x0">
          <comment>DCDC CORE power drop enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_dcdcvrf_pd_en" pos="1" rst="0x0">
          <comment>DCDC RF power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_dcdcgen_pd_en" pos="0" rst="0x0">
          <comment>DCDC GEN power down enable in PM1
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="dcdc_core_slp_ctrl0" protect="rw">
        <comment>DCDC_CORE_SLP_CTRL0</comment>
        <bits access="rw" name="pm1_dcdc_core_slp_step_delay" pos="13:12" rst="0x0">
          <comment>delay between two steps in PM1
00:1*32k clock
01:2*32k clock
10:3*32k clock
11:4*32k clock</comment>
        </bits>
        <bits access="rw" name="pm1_dcdc_core_slp_step_num" pos="11:8" rst="0x0">
          <comment>step number in PM1</comment>
        </bits>
        <bits access="rw" name="pm1_dcdc_core_slp_step_vol" pos="7:3" rst="0x0">
          <comment>voltage per step in PM1
00000:0mv
00001:1*3.125mv
00010:2*3.125mv
..
11111:31*3.125mv</comment>
        </bits>
        <bits access="rw" name="pm1_dcdccore_pd_en" pos="1" rst="0x0">
          <comment>DCDC CORE power down enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="dcdc_core_slp_step_en" pos="0" rst="0x0">
          <comment>DCDCCORE step tune enable in deep sleep
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="dcdc_core_slp_ctrl1" protect="rw">
        <comment>DCDC_CORE_SLP_CTRL1</comment>
        <bits access="rw" name="pm1_dcdc_core_vosel_ds_sw" pos="8:0" rst="0x4">
          <comment>DCDC CORE voltage control in PM1</comment>
        </bits>
      </reg>
      <reg name="slp_dcdc_lp_ctrl" protect="rw">
        <comment>SLP_DCDC_LP_CTRL</comment>
        <bits access="rw" name="pm1_dcdccore_lp_en" pos="4" rst="0x0">
          <comment>DCDC CORE low power mode enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_dcdcvrf_lp_en" pos="2" rst="0x0">
          <comment>DCDC VRF low power mode enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_dcdcgen_lp_en" pos="1" rst="0x0">
          <comment>DCDC GEN low power mode enable in PM1
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="slp_ldo_lp_ctrl0" protect="rw">
        <comment>SLP_LDO_LP_CTRL0</comment>
        <bits access="rw" name="slp_ldorf15_lp_en" pos="14" rst="0x0">
          <comment>LDO RF15 low power mode enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldorf12_lp_en" pos="13" rst="0x0">
          <comment>LDO RF12 low power mode enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldovio33_lp_en" pos="12" rst="0x0">
          <comment>LDO EMMCCORE low power mode enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldodcxo_lp_en" pos="11" rst="0x0">
          <comment>LDO DCXO low power mode enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldovio18_lp_en" pos="10" rst="0x0">
          <comment>LDO VIO18 low power mode enable in PM1
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldoana_lp_en" pos="9" rst="0x0">
          <comment>LDO ANA low power mode enable in deep sleep mode
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="slp_ldospimem_lp_en" pos="8" rst="0x0">
          <comment>LDO MEM low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="slp_ldommc_lp_en" pos="7" rst="0x0">
          <comment>LDO MMC low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldousb_lp_en" pos="6" rst="0x0">
          <comment>LDO USB low power mode enable in PM1
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="slp_ldolcd_lp_en" pos="4" rst="0x0">
          <comment>LDO LCD low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="slp_ldocamd_lp_en" pos="3" rst="0x0">
          <comment>LDO CAMD low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="slp_ldocama_lp_en" pos="2" rst="0x0">
          <comment>LDO CAMA low power mode enable in deep sleep mode
0: Disable
1: Enable</comment>
        </bits>
      </reg>
      <reg name="slp_ldo_lp_ctrl1" protect="rw">
        <comment>SLP_LDO_LP_CTRL1</comment>
        <bits access="rw" name="pm2_dcdc_core_vosel_ds_sw" pos="15:7" rst="0x0">
          <comment>DCDC CORE voltage control in PM2</comment>
        </bits>
        <bits access="rw" name="pm1_ldolp18_lp_en" pos="3" rst="0x0">
          <comment>LDO LP18 low power mode enable in PM1
0: Disable
1: Enable</comment>
        </bits>
        <bits access="rw" name="pm1_ldomem_lp_en" pos="0" rst="0x0">
          <comment>LDO MEM low power mode enable in PM1
0: Disable
1: Enable</comment>
        </bits>
      </reg>
      <reg name="reserved_reg_rtc" protect="rw">
        <comment>RESERVED_REG_RTC</comment>
        <bits access="rw" name="reserved_rtc" pos="15:0" rst="0x0">
          <comment>RG_RESERVED_RTC[4:0],   DCXO trim bit for 32k-less poweroff mode.  SW load from Efuse at first time power on.
RG_RESERVED_RTC[15:5], reserved</comment>
        </bits>
      </reg>
      <reg name="dcdc_vlg_sel" protect="rw">
        <comment>DCDC_VLG_SEL</comment>
        <bits access="rw" name="dcdc_gen_sw_sel" pos="3" rst="0x0">
          <comment>DCDC Voltage Program Bits selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="dcdc_core_votrim_sw_sel" pos="2" rst="0x0">
          <comment>DCDC Voltage Trim Bits selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="dcdc_core_slp_sw_sel" pos="1" rst="0x0">
          <comment>DCDC Voltage Program Bits selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="dcdc_core_nor_sw_sel" pos="0" rst="0x0">
          <comment>DCDC Voltage Program Bits selection
0: From efuse
1: From Software Register</comment>
        </bits>
      </reg>
      <reg name="ldo_vlg_sel0" protect="rw">
        <comment>LDO_VLG_SEL0</comment>
        <bits access="rw" name="vgen_reftrim_sw_sel" pos="9" rst="0x0">
          <comment>LDO_VGEN reference voltage trim bit selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="vbat_reftrim_ulp_sw_sel" pos="8" rst="0x0">
          <comment>LDO_VBAT reference ULP voltage trim bit selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="vbat_reftrim_sw_sel" pos="7" rst="0x0">
          <comment>LDO_VBAT reference voltage trim bit selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="dcdc_osc3m_freq_sw_sel" pos="6" rst="0x0">
          <comment>oscillator frequency tuning selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="rtcbg_trim_sw_sel" pos="5" rst="0x0">
          <comment>RTC bandgap calibretion bit selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="vrf_votrim_sw_sel" pos="4" rst="0x0">
          <comment>VRF output voltage selection,
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="vgen_votrim_sw_sel" pos="2" rst="0x0">
          <comment>output voltage trim selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="ldo_vcore_votrim_ulp_sw_sel" pos="1" rst="0x0">
          <comment>LDO Voltage trim selection
0: From efuse
1: From Software Register</comment>
        </bits>
        <bits access="rw" name="ldo_vcore_votrim_sw_sel" pos="0" rst="0x0">
          <comment>LDO Voltage trim selection
0: From efuse
1: From Software Register</comment>
        </bits>
      </reg>
      <reg name="clk32kless_ctrl0" protect="rw">
        <comment>CLK32KLESS_CTRL0</comment>
        <bits access="r" name="rc_mode_wr_ack_flag" pos="14" rst="0x0">
          <comment>RC_MODE write ack flag</comment>
        </bits>
        <bits access="rc" name="rc_mode_wr_ack_flag_clr" pos="10" rst="0x0">
          <comment>RC_MODE write ack flag clear, high effective</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_lp_en_rtcset" pos="7" rst="0x0">
          <comment>Low power LDO_DCXO power down set in RTC</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_lp_en_rtcclr" pos="6" rst="0x0">
          <comment>Low power LDO_DCXO power down clear in RTC</comment>
        </bits>
        <bits access="r" name="rtc_mode" pos="4" rst="0x0">
          <comment>0: 32k crystal
1: 32k-less</comment>
        </bits>
        <bits access="rw" name="rc_32k_sel" pos="1" rst="0x0">
          <comment>32K clock select in 32K crystal removal option
 0: From XO  1: From RC</comment>
        </bits>
        <bits access="rw" name="rc_32k_en" pos="0" rst="0x1">
          <comment>RC 32K oscillator enable</comment>
        </bits>
      </reg>
      <reg name="clk32kless_ctrl1" protect="rw">
        <comment>CLK32KLESS_CTRL1</comment>
        <bits access="rw" name="rc_mode" pos="15:0" rst="0x0">
          <comment>RC 32K mode in battery drop case:
16'h95A5: RC oscillator stop working.
Others: RC oscillator keep working.</comment>
        </bits>
      </reg>
      <reg name="xtl_wait_ctrl0" protect="rw">
        <comment>XTL_WAIT_CTRL0</comment>
      </reg>
      <reg name="por_rst_monitor" protect="rw">
        <comment>POR_RST_MONITOR</comment>
        <bits access="rw" name="por_rst_monitor" pos="15:0" rst="0x0">
          <comment>When POR reset active, this register is reset to 0</comment>
        </bits>
      </reg>
      <reg name="wdg_rst_monitor" protect="rw">
        <comment>WDG_RST_MONITOR</comment>
        <bits access="rw" name="wdg_rst_monitor" pos="15:0" rst="0x0">
          <comment>When WDG reset active, this register is reset to 0</comment>
        </bits>
      </reg>
      <reg name="por_pin_rst_monitor" protect="rw">
        <comment>POR_PIN_RST_MONITOR</comment>
        <bits access="rw" name="por_pin_rst_monitor" pos="15:0" rst="0x0">
          <comment>When POR_EXT_RST active, this register is reset to 0</comment>
        </bits>
      </reg>
      <reg name="por_src_flag" protect="rw">
        <comment>POR_SRC_FLAG</comment>
        <bits access="rw" name="por_sw_force_on" pos="15" rst="0x0">
          <comment>Setting this bit could disable the 1S debouncing time of power key after boot.</comment>
        </bits>
        <bits access="rc" name="reg_soft_rst_flag_clr" pos="14" rst="0x0">
          <comment>register reset flag clear</comment>
        </bits>
        <bits access="r" name="por_src_flag" pos="13:0" rst="0x0">
          <comment>Power on source flag:
[0]: Debounced PBINT signal, set when PBINT=0 &gt;50ms, clear when PBINT=1&gt;50ms.
[1]: PBINT initiating power-up hardware flag, set when PBINT=0&gt;1s, clear after power down.
[2]: reserved.
[3]: reserved.
[4]: Debounced CHGR_INT signal, set when VCHG=1 &gt;50ms, clear when VCHG=0&gt;50ms.
[5]: Charger plug-in initiating power-up hardware flag, set when VCHG=1&gt;1s, clear after power down.
[6]: RTC alarm initiating power-up hardware flag
[7]: Long pressing power key reboot hardware flag, set when PBINT=0&gt;PBINT_7S_THRESHOLD, clear after power down.
[8]: PBINT initiating power-up software flag, set when PBINT=0&gt;1s, clear by pbint_flag_clr.
[9]: reserved.
[10]: Charger plug-in initiating power-up software flag, set when VCHG=1&gt;1s, clear by chgr_int_flag_clr.
[11: External pin reset reboot software flag, set when EXTRSTN=0&gt;30ms, clear by ext_rstn_flag_clr.
[12]: Long pressing power key reboot software flag, set when PBINT=0&gt;PBINT_7S_THRESHOLD, clear by pbint_7s_flag_clr.
[13]: flag when register reset happened</comment>
        </bits>
      </reg>
      <reg name="por_7s_ctrl" protect="rw">
        <comment>POR_7S_CTRL</comment>
        <bits access="rw" name="pbint_7s_flag_clr" pos="15" rst="0x0">
          <comment>Write 1b1 to this bit will clear pbint_7s_flag.</comment>
        </bits>
        <bits access="rw" name="ext_rstn_flag_clr" pos="14" rst="0x0">
          <comment>Write 1b1 to this bit will clear ext_rstn_flag.</comment>
        </bits>
        <bits access="rw" name="chgr_int_flag_clr" pos="13" rst="0x0">
          <comment>Write 1b1 to this bit will clear chgr_int_flag.</comment>
        </bits>
        <bits access="rw" name="pbint_flag_clr" pos="11" rst="0x0">
          <comment>Write 1b1 to this bit will clear pbint_flag.</comment>
        </bits>
        <bits access="rw" name="key2_7s_rst_en" pos="9" rst="0x0">
          <comment>1: One-key Reset Mode;
0: Two-key Reset Mode;</comment>
        </bits>
        <bits access="rw" name="pbint_7s_rst_swmode" pos="8" rst="0x1">
          <comment>0: long reset;
1: short reset;</comment>
        </bits>
        <bits access="rw" name="pbint_7s_rst_threshold" pos="7:4" rst="0x6">
          <comment>The power key long pressing time threshold:
0~1: 2S
2: 3S
3: 4S
4: 5S
5: 6S
6: 7S
7: 8S
8: 9S
9: 10S
10:11S
11:12S
12: 13S
13:14S
14:15S
15:16S</comment>
        </bits>
        <bits access="rw" name="ext_rstn_mode" pos="3" rst="0x0">
          <comment>EXT_RSTN PIN function mode when 1key 7S reset
0: EXT_INT
1: RESET</comment>
        </bits>
        <bits access="rw" name="pbint_7s_auto_on_en" pos="2" rst="0x1">
          <comment>RTC register PBINT_7S_AUTO_ON_EN</comment>
        </bits>
        <bits access="rw" name="pbint_7s_rst_disable" pos="1" rst="0x0">
          <comment>0: enable 7s reset function;
1: disable 7s reset function;</comment>
        </bits>
        <bits access="rw" name="pbint_7s_rst_mode" pos="0" rst="0x1">
          <comment>0: software reset;
1: hardware reset;</comment>
        </bits>
      </reg>
      <reg name="hwrst_rtc" protect="rw">
        <comment>HWRST_RTC</comment>
        <bits access="r" name="hwrst_rtc_reg_sts" pos="15:8" rst="0x0">
          <comment>RTC status register, set by HWRST_RTC_SET.</comment>
        </bits>
        <bits access="rw" name="hwrst_rtc_reg_set" pos="7:0" rst="0x0">
          <comment>Software set this register to test VBAT and RTC power status.</comment>
        </bits>
      </reg>
      <reg name="smpl_ctrl0" protect="rw">
        <comment>SMPL_CTRL0</comment>
        <bits access="rw" name="smpl_mode" pos="15:0" rst="0x0">
          <comment>SMPL mode:
[15:13]: SMPL timer threshold
                0: 0.25s
                1: 0.5s
                2: 0.75s
                 ..
                 7: 2s
[12:0]: SMPL enable
               13'h1935: enable
                Others:     disable</comment>
        </bits>
      </reg>
      <reg name="rtc_rst0" protect="rw">
        <comment>RTC_RST0</comment>
        <bits access="rw" name="rtc_clk_flag_set" pos="15:0" rst="0x0">
          <comment>RTC register flag</comment>
        </bits>
      </reg>
      <reg name="rtc_rst1" protect="rw">
        <comment>RTC_RST1</comment>
        <bits access="rw" name="rtc_clk_flag_clr" pos="15:0" rst="0x0">
          <comment>RTC register flag</comment>
        </bits>
      </reg>
      <reg name="rtc_rst2" protect="rw">
        <comment>RTC_RST2</comment>
        <bits access="r" name="rtc_clk_flag_rtc" pos="15:0" rst="0xa596">
          <comment>RTC register flag, reset by RTC_RST, default is 16'hA596</comment>
        </bits>
      </reg>
      <reg name="rtc_clk_stop" protect="rw">
        <comment>RTC_CLK_STOP</comment>
        <bits access="r" name="rtc_clk_stop_flag" pos="7" rst="0x0">
          <comment>rtc time over thresthold value</comment>
        </bits>
        <bits access="rw" name="rtc_clk_stop_threshold" pos="6:0" rst="0x10">
          <comment>set reset rtc cnt time,default 16s</comment>
        </bits>
      </reg>
      <reg name="vbat_drop_cnt" protect="rw">
        <comment>VBAT_DROP_CNT</comment>
        <bits access="r" name="vbat_drop_cnt" pos="11:0" rst="0x0">
          <comment>VBAT Drop Time Count</comment>
        </bits>
      </reg>
      <reg name="mixed_ctrl" protect="rw">
        <comment>MIXED_CTRL</comment>
        <bits access="r" name="ad_buadet" pos="15" rst="0x0">
          <comment>Power detect enable
1'b0: default, off
1'b1: Power detect on (UVLO/OVLO/VBATLOW)</comment>
        </bits>
        <bits access="r" name="batdet_ok" pos="8" rst="0x1">
          <comment>Battery presence flag to SW and POCV, so need RTC domain
&quot;0&quot; no battery
&quot;1&quot; battery presence</comment>
        </bits>
        <bits access="r" name="vbat_ok" pos="5" rst="0x1">
          <comment>VBAT detect. Active 0 is reset, no need 32K osc (same as BATDET_OK).</comment>
        </bits>
        <bits access="rw" name="all_gpi_deb" pos="3" rst="0x0">
          <comment>ALL GPI source debug</comment>
        </bits>
        <bits access="rw" name="gpi_debug_en" pos="2" rst="0x0">
          <comment>GPI debug enable</comment>
        </bits>
        <bits access="rw" name="all_int_deb" pos="1" rst="0x0">
          <comment>ALL_INT debug, if 1, interrupt will be sent</comment>
        </bits>
        <bits access="rw" name="int_debug_en" pos="0" rst="0x0">
          <comment>Interupt debug enable</comment>
        </bits>
      </reg>
      <reg name="por_off_flag" protect="rw">
        <comment>POR_OFF_FLAG</comment>
        <bits access="r" name="por_chip_pd_flag" pos="13" rst="0x0">
          <comment>uvlo + ovlo chip power down flag</comment>
        </bits>
        <bits access="rc" name="por_chip_pd_flag_clr" pos="12" rst="0x0">
          <comment>uvlo  + ovlo chip power down flag clear</comment>
        </bits>
        <bits access="r" name="uvlo_chip_pd_flag" pos="11" rst="0x0">
          <comment>uvlo chip power down flag</comment>
        </bits>
        <bits access="rc" name="uvlo_chip_pd_flag_clr" pos="10" rst="0x0">
          <comment>uvlo chip power down flag clear</comment>
        </bits>
        <bits access="r" name="hard_7s_chip_pd_flag" pos="9" rst="0x0">
          <comment>7s hard chip power down flag</comment>
        </bits>
        <bits access="rc" name="hard_7s_chip_pd_flag_clr" pos="8" rst="0x0">
          <comment>7s hard chip power down flag clear</comment>
        </bits>
        <bits access="r" name="sw_chip_pd_flag" pos="7" rst="0x0">
          <comment>SW chip power down flag</comment>
        </bits>
        <bits access="rc" name="sw_chip_pd_flag_clr" pos="6" rst="0x0">
          <comment>SW chip power down flag clear</comment>
        </bits>
        <bits access="r" name="hw_chip_pd_flag" pos="5" rst="0x0">
          <comment>HW chip power down flag</comment>
        </bits>
        <bits access="rc" name="hw_chip_pd_flag_clr" pos="4" rst="0x0">
          <comment>HW chip power down flag clear</comment>
        </bits>
        <bits access="r" name="otp_chip_pd_flag" pos="3" rst="0x0">
          <comment>OTP chip power down flag</comment>
        </bits>
        <bits access="rc" name="otp_chip_pd_flag_clr" pos="2" rst="0x0">
          <comment>OTP chip power down flag clear</comment>
        </bits>
      </reg>
      <reg name="swrst_ctrl0" protect="rw">
        <comment>SWRST_CTRL0</comment>
        <bits access="rw" name="ext_rstn_pd_en" pos="10" rst="0x0">
          <comment>Software reset certain power enable when ext_rstn valid</comment>
        </bits>
        <bits access="rw" name="pb_7s_rst_pd_en" pos="9" rst="0x0">
          <comment>Software reset certain power enable when pb_7s_rst valid</comment>
        </bits>
        <bits access="rw" name="reg_rst_pd_en" pos="8" rst="0x0">
          <comment>Software reset certain power enable when reg_rst valid</comment>
        </bits>
        <bits access="rw" name="wdg_rst_pd_en" pos="7" rst="0x0">
          <comment>Software reset certain power enable when wdg_rst valid</comment>
        </bits>
        <bits access="rw" name="reg_rst_en" pos="4" rst="0x0">
          <comment>register reset enable:
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_pd_threshold" pos="3:0" rst="0x0">
          <comment>reset LDO to normal mode threshold time
8ms/step,default 8ms</comment>
        </bits>
      </reg>
      <reg name="swrst_ctrl1" protect="rw">
        <comment>SWRST_CTRL1</comment>
        <bits access="rw" name="sw_rst_spimem_pd_en" pos="15" rst="0x0">
          <comment>Software reset LDO_SPIMEM_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_vio18_pd_en" pos="14" rst="0x0">
          <comment>Software reset LDO_VIO18_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_dcdcgen_pd_en" pos="10" rst="0x0">
          <comment>Software reset DCDC_GEN_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_dcdccore_pd_en" pos="9" rst="0x0">
          <comment>Software reset DCDC_CORE_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_mem_pd_en" pos="8" rst="0x0">
          <comment>Software reset LDO_MEM_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_dcxo_pd_en" pos="7" rst="0x0">
          <comment>Software reset LDO_DCXO_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_rf12_pd_en" pos="6" rst="0x0">
          <comment>Software reset LDO_RF12_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_ana_pd_en" pos="5" rst="0x0">
          <comment>Software reset LDO_ANA_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_rf15_pd_en" pos="4" rst="0x0">
          <comment>Software reset LDO_RF15_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_usb_pd_en" pos="3" rst="0x0">
          <comment>Software reset LDO_USB_PD enable when global reset valid
0:  disable
1:  enable</comment>
        </bits>
        <bits access="rw" name="sw_rst_vio33_pd_en" pos="2" rst="0x0">
          <comment>Software reset LDO_EMMCCORE_PD enable when global reset valid</comment>
        </bits>
      </reg>
      <reg name="free_timer_low" protect="rw">
        <comment>FREE_TIMER_LOW</comment>
        <bits access="r" name="timer_low" pos="15:0" rst="0x0">
          <comment>low 16 bit value of  free timer</comment>
        </bits>
      </reg>
      <reg name="free_timer_high" protect="rw">
        <comment>FREE_TIMER_HIGH</comment>
        <bits access="r" name="timer_high" pos="15:0" rst="0x0">
          <comment>high 16 bit value of free timer</comment>
        </bits>
      </reg>
      <reg name="reserved_reg1" protect="rw">
        <comment>RESERVED_REG1</comment>
        <bits access="rw" name="pm2_dcdc_core_slp_step_vol" pos="12:8" rst="0x0">
          <comment>voltage per step in PM2
00000:0mv
00001:1*3.125mv
00010:2*3.125mv
..
11111:31*3.125mv</comment>
        </bits>
        <bits access="rw" name="pm1_ldo_mem_powersel" pos="6" rst="0x0">
          <comment>PM1 LDO VMEM power switch value:
1'b0:VMEM out
1'b1:VMEM short lp18,lp18 out</comment>
        </bits>
        <bits access="rw" name="ovlo_dbnc_en" pos="5" rst="0x0">
          <comment>OVLO dbnc enable:
0:  enable
1:  disable</comment>
        </bits>
        <bits access="rw" name="uvlo_dbnc_en" pos="4" rst="0x0">
          <comment>UVLO dbnc enable:
0:  enable
1:  disable</comment>
        </bits>
        <bits access="rw" name="pm1_power_det_en" pos="3" rst="0x0">
          <comment>PM1 power detect off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm1_bg_pd_en" pos="2" rst="0x0">
          <comment>PM1 bg_pd off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm1_osw_3m_en" pos="1" rst="0x0">
          <comment>PM1 OSW3M off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm1_dvdd_en" pos="0" rst="0x0">
          <comment>PM1 DVDD_PD off and DVDD_ISO hold enable:
0:disable
1:enable</comment>
        </bits>
      </reg>
      <reg name="reserved_reg2" protect="rw">
        <comment>RESERVED_REG2</comment>
        <bits access="rw" name="pm1_sleep_dly2" pos="15:12" rst="0x0">
          <comment>delay betwwen IO and VCORE when PM1 exits.(IO delay== {2'h0,pm1_sleep_dly2,2'h0})</comment>
        </bits>
        <bits access="rw" name="pm1_sleep_dly1" pos="11:8" rst="0x0">
          <comment>delay betwwen IO and VCORE when entering PM1.(VCORE delay== {2'h0,pm1_sleep_dly1,2'h0} + 1)</comment>
        </bits>
        <bits access="rw" name="ulp_cycle_sel1" pos="7:4" rst="0x0">
          <comment>if chip_sleep is low,ULP mode can use this value</comment>
        </bits>
        <bits access="rw" name="ulp_cycle_sel0" pos="3:0" rst="0x0">
          <comment>[3:0]:ULP cycle sel
4'h0:2;
4'h1:4;
4'h2:8;

4'hb:4096.</comment>
        </bits>
      </reg>
      <reg name="reserved_reg3" protect="rw">
        <comment>RESERVED_REG3</comment>
        <bits access="rw" name="ovlo_dbnc_time" pos="15:8" rst="0x0">
          <comment>UVLO dbnc time:
0:1ms
1:61us
2:91.5:us
3:122us

ff:7.8ms</comment>
        </bits>
        <bits access="rw" name="uvlo_dbnc_time" pos="7:0" rst="0x0">
          <comment>UVLO dbnc time:
0:2ms
1:61us
2:91.5:us
3:122us

ff:7.8ms</comment>
        </bits>
      </reg>
      <reg name="reserved_reg4" protect="rw">
        <comment>RESERVED_REG4</comment>
        <bits access="rw" name="pm2_sleep_dly2" pos="15:8" rst="0x0">
          <comment>delay betwwen IO and VCORE when PM1 exits.(IO delay== pm1_sleep_dly2)</comment>
        </bits>
        <bits access="rw" name="pm2_sleep_dly1" pos="7:0" rst="0x0">
          <comment>delay betwwen IO and VCORE when entering PM1.(VCORE delay== pm1_sleep_dly1 + 1)</comment>
        </bits>
      </reg>
      <reg name="reserved_reg5" protect="rw">
        <comment>RESERVED_REG5</comment>
        <bits access="rw" name="pm2_ldocp_pd_en" pos="14" rst="0x0">
          <comment>LDO CP power down enable in PM2
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_dcdc_core_slp_step_delay" pos="13:12" rst="0x0">
          <comment>delay between two steps in PM2
00:1*32k clock
01:2*32k clock
10:3*32k clock
11:4*32k clock</comment>
        </bits>
        <bits access="rw" name="pm2_dcdc_core_slp_step_num" pos="11:8" rst="0x0">
          <comment>step number in PM2</comment>
        </bits>
        <bits access="rw" name="pm2_power_det_en" pos="7" rst="0x0">
          <comment>PM2 power detect off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm2_slp_bg_pd_en" pos="6" rst="0x0">
          <comment>PM2 bg_pd off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm2_osw_3m_en" pos="5" rst="0x0">
          <comment>PM2 OSW3M off enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm2_dvdd_en" pos="4" rst="0x0">
          <comment>PM2 DVDD_PD off and DVDD_ISO hold enable:
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldousb_lp_en" pos="3" rst="0x0">
          <comment>LDO USB low power mode enable in PM2
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldomem_lp_en" pos="2" rst="0x0">
          <comment>LDO MEM low power mode enable in PM2
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldousb_pd_en" pos="1" rst="0x0">
          <comment>LDO USB power down enable in PM2
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="pm2_ldomem_pd_en" pos="0" rst="0x0">
          <comment>LDO MEM power down enable in PM2
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="reserved_reg6" protect="rw">
        <comment>RESERVED_REG6</comment>
        <bits access="rw" name="pm2_en" pos="0" rst="0x0">
          <comment>select the configuration used under PM2
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="pwr_wr_prot_value" protect="rw">
        <comment>PWR_WR_PROT_VALUE</comment>
        <bits access="r" name="pwr_wr_prot" pos="15" rst="0x0">
          <comment>All power which default on write protect bit status.
When mcu_wr_prot_value==16'h6e7f,
 the bit is &quot;1&quot;,else &quot;0&quot;</comment>
        </bits>
        <bits access="w" name="pwr_wr_prot_value" pos="14:0" rst="0x0">
          <comment>Arch_en write protect value</comment>
        </bits>
      </reg>
      <reg name="vol_tune_ctrl_core" protect="rw">
        <comment>VOL_TUNE_CTRL_CORE</comment>
        <bits access="rw" name="core_clk_sel" pos="14" rst="0x0">
          <comment>clock source for CORE DVFS
0: clock 26M
1: clock 32K</comment>
        </bits>
        <bits access="rw" name="core_step_delay" pos="13:12" rst="0x0">
          <comment>delay between two steps
00:1*32k clock or 2us in 26M
01:2*32k clock or 4us in 26M
10:3*32k clock or 8us in 26M
11:4*32k clock or 16us in 26M</comment>
        </bits>
        <bits access="rw" name="core_step_num" pos="11:8" rst="0x0">
          <comment>step number</comment>
        </bits>
        <bits access="rw" name="core_step_vol" pos="7:3" rst="0x0">
          <comment>DVFS voltage per step
00000:0mv
00001:1*3.125mv
00010:2*3.125mv
..
11111:31*3.125mv</comment>
        </bits>
        <bits access="rc" name="core_vol_tune_start" pos="2" rst="0x0">
          <comment>voltage tune start bit</comment>
        </bits>
        <bits access="r" name="core_vol_tune_flag" pos="1" rst="0x0">
          <comment>voltage tune flag
0:done
1:on going</comment>
        </bits>
        <bits access="rw" name="core_vol_tune_en" pos="0" rst="0x0">
          <comment>voltage tune enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="smpl_ctrl1" protect="rw">
        <comment>SMPL_CTRL1</comment>
        <bits access="r" name="smpl_pwr_on_flag" pos="15" rst="0x0">
          <comment>Set once SMPL timer not expired.</comment>
        </bits>
        <bits access="r" name="smpl_mode_wr_ack_flag" pos="14" rst="0x0">
          <comment>Set once SMPL mode write finish</comment>
        </bits>
        <bits access="rc" name="smpl_pwr_on_flag_clr" pos="13" rst="0x0">
          <comment>Clear SMPL_PWR_ON_FLAG</comment>
        </bits>
        <bits access="rc" name="smpl_mode_wr_ack_flag_clr" pos="12" rst="0x0">
          <comment>Clear SMPL_MODE_WR_ACK</comment>
        </bits>
        <bits access="r" name="smpl_pwr_on_set" pos="11" rst="0x0">
          <comment>Set once SMPL timer not expired,</comment>
        </bits>
        <bits access="r" name="smpl_en" pos="0" rst="0x0">
          <comment>SMPL enable indication</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="power_pd_sw0_set" protect="rw"/>
      <hole size="96"/>
      <reg name="power_pd_sw0_clr" protect="rw"/>
      <hole size="128"/>
      <reg name="power_pd_sw1_set" protect="rw"/>
      <hole size="96"/>
      <reg name="power_pd_sw1_clr" protect="rw"/>
    </module>
    <var name="REG_PMIC_RTC_ANA_SET_OFFSET" value="0x100"/>
    <var name="REG_PMIC_RTC_ANA_CLR_OFFSET" value="0x110"/>
    <instance address="0x51108800" name="PMIC_RTC_ANA" type="PMIC_RTC_ANA"/>
  </archive>
  <archive relative="pmic_wdt.xml">
    <module category="System" name="PMIC_WDT">
      <reg name="wdg_load_low" protect="rw">
        <comment>low 16 bits of watchdog value low 16 bits of watchdog value</comment>
        <bits access="rw" name="wdg_ld_value_low" pos="15:0" rst="0xffff">
          <comment>wdg_ld_value_low: low 16 bit of watchdog timer load value
wdg_ld_value_high: high 16 bit of watchdog timer load value
wdg_ld_value_higher: higher 16 bit of watchdog timer load value
wdg_ld_value_low, wdg_ld_value_high and wdg_ld_value_higher  are used together.Software should write wdg_ld_value_higher firstly, and then write wdg_ld_value_high, last write wdg_ld_value_low, because writing wdg_ld_value_low can trig loading both wdg_ld_value_low and wdg_ld_value_high to watchdog counter, and writing wdg_ld_value_high cannot trig this event. So software must guarantee wdg_ld_value_high is ready when writing wdg_ld_value_low.
In reset mode, software should load new value before timer decrease to 0. In interrupt mode, this value is counting start number. The default value is about 8 seconds.</comment>
        </bits>
      </reg>
      <reg name="wdg_load_high" protect="rw">
        <comment>high 16 bits of watchdog value high 16 bits of watchdog value</comment>
        <bits access="rw" name="wdg_ld_value_high" pos="15:0" rst="0x3">
          <comment>See wdg_ld_value_low description.</comment>
        </bits>
      </reg>
      <reg name="wdg_ctrl" protect="rw">
        <comment>watchdog control watchdog control</comment>
        <bits access="rw" name="wdg_rst_en" pos="3" rst="0x0">
          <comment>Watchdog reset enable bit
0: reset is disabled
1: reset is enabled
For reset mode: wdg_rst_en =1, wdg_irq_en=0.
For interrupt mode: wdg_rst_en =0, wdg_irq_en=1.
For combined mode: wdg_rst_en =1, wdg_irq_en=1.
Reset can't be triggered before wdg_rst_raw is cleared.</comment>
        </bits>
        <bits access="rw" name="wdg_new" pos="2" rst="0x0">
          <comment>Watchdog version
0: watchdog use old behavior, this is for backward compatibility
1: watchdog uses new behavior, such as multiple loads without checking busy bit, only need to read once to get timer counter value.</comment>
        </bits>
        <bits access="rw" name="wdg_open" pos="1" rst="0x0">
          <comment>Watchdog counter open:
0: counter stops.
1: counter runs.</comment>
        </bits>
        <bits access="rw" name="wdg_irq_en" pos="0" rst="0x0">
          <comment>Watchdog interrupt enable bit
0: interrupt is disabled
1: interrupt is enabled
For reset mode: wdg_rst_en =1, wdg_irq_en=0.
For interrupt mode: wdg_rst_en =0, wdg_irq_en=1.
For combined mode: wdg_rst_en =1, wdg_irq_en=1.</comment>
        </bits>
      </reg>
      <reg name="wdg_int_clr" protect="rw">
        <comment>watchdog interrupt clear watchdog interrupt clear</comment>
        <bits access="w" name="wdg_rst_clr" pos="3" rst="0x0">
          <comment>Watchdog reset clear
Write 1 to this bit to clear reset
Read this bit always get 0.</comment>
        </bits>
        <bits access="w" name="wdg_irq_clr" pos="0" rst="0x0">
          <comment>Watchdog interrupt clear
Write 1 to this bit to clear interrupt
Read this bit always get 0.</comment>
        </bits>
      </reg>
      <reg name="wdg_int_raw" protect="rw">
        <comment>watchdog interrupt raw status watchdog interrupt raw status</comment>
        <bits access="r" name="apb_wr_ld_busy" pos="4" rst="0x0">
          <comment>Watchdog load busy status
0: Watchdog is ready for new loading
1: Last loading is not completed
Software must not load new value when this bit is busy, that is, this bit should be checked before any new loading.
This bit is set after a new loading, and lasts two or three RTC clock cycles, about 60us - 92us.</comment>
        </bits>
        <bits access="r" name="wdg_rst_raw" pos="3" rst="0x0">
          <comment>Watchdog reset  raw status. Watchdog reset cannot clear this raw status, Also it can be used to judge if or not system rebooting comes from watchdog reset. Write wdg_rst_clr can clear this raw status.</comment>
        </bits>
        <bits access="r" name="wdg_irq_raw" pos="0" rst="0x0">
          <comment>Watchdog interrupt raw status. Watchdog reset cannot clear this raw status. Write wdg_irq_clr can clear this raw status.</comment>
        </bits>
      </reg>
      <reg name="wdg_irq_mask" protect="rw">
        <comment>watchdog interrupt mask status watchdog interrupt mask status</comment>
        <bits access="r" name="wdg_irq_mask" pos="0" rst="0x0">
          <comment>Watchdog interrupt masked status</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_low" protect="rw">
        <comment>low 16 bits of watchdog counter value low 16 bits of watchdog counter value</comment>
        <bits access="r" name="wdg_cnt_low" pos="15:0" rst="0xffff">
          <comment>wdg_cnt_low: Low 16 bit of watchdog timer counter value.
wdg_cnt_high: Mid 16 bit of watchdog timer counter value.
wdg_cnt_higher: High 16 bit of watchdog timer counter value.
wdg_cnt_low, wdg_cnt_mid and wdg_cnt_high  are used together.
This read-only register indicates current counter value.
Its not recommended to read this register in normal usage.
Because the counter is in different clock domain with APB, software needs use double-reading method to read this value, like system timer.</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_high" protect="rw">
        <comment>high 16 bits of watchdog counter value high 16 bits of watchdog counter value</comment>
        <bits access="r" name="wdg_cnt_high" pos="15:0" rst="0xffff">
          <comment>See wdg_cnt_low description.</comment>
        </bits>
      </reg>
      <reg name="wdg_lock" protect="rw">
        <comment>watchdog lock control watchdog lock control</comment>
        <bits access="rw" name="wdg_lock" pos="15:0" rst="0x0">
          <comment>Watchdog lock control
Write 16hE551 to this register to unlock watchdog.
Write other value to this register to lock watchdog
If reading this register, bit-0 is lock status, and other bits are reserved.
If watchdog is locked, all control registers cannot be written by software.</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_read_low" protect="rw">
        <comment>low 16 bits of watchdog counter value for read low 16 bits of watchdog counter value for read</comment>
        <bits access="r" name="wdg_cnt_read_low" pos="15:0" rst="0xffff">
          <comment>wdg_cnt_read_low: Low 16 bit of watchdog timer counter value for read.
wdg_cnt_read_high: High 16 bit of watchdog timer counter value for read.
wdg_cnt_read_higher: Higher 16 bit of watchdog timer counter value for read.
wdg_cnt_read_low and wdg_cnt_read_high  are used together.
This read-only register indicates current counter value.
Read once can get watchdog counter value. No need to double read this reg.
Refer to timers TIMER0_CNT_RD or TIMER1_CNT_RD</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_read_high" protect="rw">
        <comment>high 16 bits of watchdog counter value for read high 16 bits of watchdog counter value for read</comment>
        <bits access="r" name="wdg_cnt_read_high" pos="15:0" rst="0xffff">
          <comment>Refer to  wdg_cnt_read_low</comment>
        </bits>
      </reg>
      <reg name="wdg_irq_value_low" protect="rw">
        <comment>low 16 bits of watchdog irq value low 16 bits of watchdog irq value</comment>
        <bits access="rw" name="wdg_irq_value_low" pos="15:0" rst="0x0">
          <comment>wdg_ irq_value_low: Low 16 bit of watchdog irqvalue.
wdg_ irq_value_high: High 16 bit of watchdog irqvalue.
wdg_ irq_value_higher: Higher 16 bit of watchdog irqvalue.
wdg_ irq_value_low and wdg_ irq_value_high  are used together.
Its useful in interrupt mode and combined mode. When  wdg_cnt equal watchdog irqvalue, an interrupt is generated.
Default value of watchdog irqvalue is 480000_h0003_0000, corresponds to 6 seconds, which means reset will occur after irq is 1 for 6 seconds.</comment>
        </bits>
      </reg>
      <reg name="wdg_irq_value_high" protect="rw">
        <comment>high 16 bits of watchdog irq value high 16 bits of watchdog irq value</comment>
        <bits access="rw" name="wdg_irq_value_high" pos="15:0" rst="0x3">
          <comment>wdg_ irq_value_low: Low  16 bit of watchdog irq value.
wdg_ irq_value_high: High  16 bit of watchdog irq value.
wdg_ irq_value_higher: Higher 16 bit of watchdog irq value.
wdg_ irq_value_low, wdg_irq_value_mid and wdg_ irqvalue_high  are used together, which means reset will occur after irq is 1 for 6 seconds.
Its useful in interrupt mode and combined mode. When  wdg_cnt equal watchdog irq value, an interrupt is generated.
Default value of watchdog irqvalue is 48h0000_0003_0000, corresponds to 6 seconds.</comment>
        </bits>
      </reg>
      <reg name="wdg_load_higher" protect="rw">
        <comment>higher 16 bits of watchdog value higher 16 bits of watchdog value</comment>
        <bits access="rw" name="wdg_ld_value_higher" pos="15:0" rst="0x0">
          <comment>See wdg_ld_value_low description.</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_higher" protect="rw">
        <comment>higher 16 bits of watchdog counter value higher 16 bits of watchdog counter value</comment>
        <bits access="r" name="wdg_cnt_higher" pos="15:0" rst="0xffff">
          <comment>See wdg_cnt_low description.</comment>
        </bits>
      </reg>
      <reg name="wdg_cnt_read_higher" protect="rw">
        <comment>higher 16 bits of watchdog counter value for read higher 16 bits of watchdog counter value for read</comment>
        <bits access="r" name="wdg_cnt_read_higher" pos="15:0" rst="0xffff">
          <comment>Refer to  wdg_cnt_read_low</comment>
        </bits>
      </reg>
      <reg name="wdg_irq_value_higher" protect="rw">
        <comment>higher 16 bits of watchdog irq value higher 16 bits of watchdog irq value</comment>
        <bits access="rw" name="wdg_irq_value_higher" pos="15:0" rst="0x0">
          <comment>wdg_ irq_value_low: Low  16 bit of watchdog irq value.
wdg_ irq_value_high: High  16 bit of watchdog irq value.
wdg_ irq_value_higher: Higher 16 bit of watchdog irq value.
wdg_ irq_value_low, wdg_irq_value_high and wdg_ irq_value_higher  are used together, which means reset will occur after irq is 1 for 6 seconds.
Its useful in interrupt mode and combined mode. When  wdg_cnt equal watchdog irq value, an interrupt is generated.
Default value of watchdog irqvalue is 48h0000_0003_0000, corresponds to 6 seconds.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51108480" name="PMIC_WDT" type="PMIC_WDT"/>
  </archive>
  <archive relative="pmic_psm.xml">
    <module category="System" name="PMIC_PSM">
      <reg name="psm_reg_wr_protect" protect="rw">
        <bits access="rw" name="psm_reg_wr" pos="15:0" rst="0x0">
          <comment>if write 0x454e to enable write psm reg,  readback only [15] is high</comment>
        </bits>
      </reg>
      <reg name="psm_32k_cal_th" protect="rw">
        <bits access="rw" name="rc_32k_cal_pre_th" pos="11:8" rst="0x8">
          <comment>psm calibration pre time. The time is from pull DCXO high to OSC 26M stable. unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rc_32k_cal_cnt_n" pos="3:0" rst="0x7">
          <comment>psm calibration time 1s/(2^(16-rc_32k_cal_cnt_n))/( rc_32k_cal_cnt_p+1)</comment>
        </bits>
      </reg>
      <reg name="psm_26m_cal_dn_th" protect="rw">
        <bits access="rw" name="rc_26m_cal_cnt_dn_th" pos="15:0" rst="0x0">
          <comment>psm 26m calibration value update down threshold.
Value = (1/2)*26*10^6/(2^(16-rc_32k_cal_cnt_n)) /(2^9)</comment>
        </bits>
      </reg>
      <reg name="psm_26m_cal_up_th" protect="rw">
        <bits access="rw" name="rc_26m_cal_cnt_up_th" pos="15:0" rst="0x0">
          <comment>psm 26m calibration value update up threshold
Value = (3/2)*26*10^6/(2^(16-rc_32k_cal_cnt_n)) /(2^9)</comment>
        </bits>
      </reg>
      <reg name="psm_ctrl" protect="rw">
        <bits access="rw" name="rtc_32k_clk_sel" pos="15" rst="0x0">
          <comment>1'b1: rtc use psm cal 32K clock in 32K less mode,1'b0:rtc use RC 32K clock in 32K less mode</comment>
        </bits>
        <bits access="rw" name="psm_cal_en" pos="12" rst="0x0">
          <comment>enable psm cal</comment>
        </bits>
        <bits access="rw" name="psm_status_clr" pos="11" rst="0x0">
          <comment>clear psm int status</comment>
        </bits>
        <bits access="rw" name="psm_cnt_en" pos="10" rst="0x0">
          <comment>enble psm timer cnt</comment>
        </bits>
        <bits access="rw" name="psm_cnt_update" pos="9" rst="0x0">
          <comment>posedge to update psm cnt value</comment>
        </bits>
        <bits access="rw" name="psm_software_reset" pos="8" rst="0x0">
          <comment>software reset psm module, auto clear</comment>
        </bits>
        <bits access="rw" name="psm_cnt_alm_en" pos="7" rst="0x1">
          <comment>enable psm timer to wake up sys</comment>
        </bits>
        <bits access="rw" name="psm_cnt_alarm_en" pos="6" rst="0x0">
          <comment>enable psm alarm function</comment>
        </bits>
        <bits access="rw" name="charger_pwr_en" pos="5" rst="0x0">
          <comment>enable charger to power on sys</comment>
        </bits>
        <bits access="rw" name="pbint2_pwr_en" pos="4" rst="0x0">
          <comment>enable pbint2 to power on sys</comment>
        </bits>
        <bits access="rw" name="pbint1_pwr_en" pos="3" rst="0x0">
          <comment>enable pbint1 to power on sys</comment>
        </bits>
        <bits access="rw" name="ext_int_pwr_en" pos="2" rst="0x0">
          <comment>enable ext int to power on sys</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_on_timeout_en" pos="1" rst="0x0">
          <comment>enable rtc power on time out detect</comment>
        </bits>
        <bits access="rw" name="psm_en" pos="0" rst="0x0">
          <comment>enable psm fsm</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_off_th1" protect="rw">
        <bits access="rw" name="rtc_pwr_off_hold_th" pos="15:8" rst="0x4">
          <comment>The time to hold rtc ISO in power off rtc state, (clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_off_clk_en_th" pos="7:0" rst="0x2">
          <comment>The time to disable rtc clk  in power off rtc state, unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_off_th2" protect="rw">
        <bits access="rw" name="rtc_pwr_off_pd_th" pos="15:8" rst="0x8">
          <comment>The time to hold rtc ISO in power off rtc state, (clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_off_rstn_th" pos="7:0" rst="0x6">
          <comment>The time to reset rtc in power off rtc state, unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_off_th3" protect="rw">
        <bits access="rw" name="rtc_pwr_off_done_th" pos="7:0" rst="0xa">
          <comment>The time to power off rtc done  in power off rtc state, unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_on_th1" protect="rw">
        <bits access="rw" name="rtc_pwr_on_rstn_th" pos="15:8" rst="0x28">
          <comment>The time to release reset in power on rtc state, unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_on_pd_th" pos="7:0" rst="0x1">
          <comment>The time to power on rtc , unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_on_th2" protect="rw">
        <bits access="rw" name="rtc_pwr_on_clk_en_th" pos="15:8" rst="0x3">
          <comment>The time to clock enable in power on rtc state, unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_on_hold_th" pos="7:0" rst="0x2">
          <comment>The time to release hold ISO in power on rtc state, unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="rtc_pwr_on_th3" protect="rw">
        <bits access="rw" name="rtc_pwr_on_timeout_th" pos="15:8" rst="0xfa">
          <comment>The time to mark power on timeout in power on rtc state, unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
        <bits access="rw" name="rtc_pwr_on_done_th" pos="7:0" rst="0xff">
          <comment>The time to power on rtc done , unit is 4*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="psm_cnt_l_th" protect="rw">
        <bits access="rw" name="psm_cnt_th_15_0" pos="15:0" rst="0x7e40">
          <comment>The low 16 bits threshold of psm time , unit is 10*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="psm_cnt_h_th" protect="rw">
        <bits access="rw" name="psm_cnt_th_31_16" pos="15:0" rst="0x5">
          <comment>The high 16 bits threshold of psm time , unit is 10ms</comment>
        </bits>
      </reg>
      <reg name="psm_alarm_cnt_l_th" protect="rw">
        <bits access="rw" name="psm_alarm_cnt_th_15_0" pos="15:0" rst="0xffff">
          <comment>The low 16 bits threshold of psm alarm time , unit is 10*(clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="psm_alarm_cnt_h_th" protect="rw">
        <bits access="rw" name="psm_alarm_cnt_th_31_16" pos="15:0" rst="0x0">
          <comment>The high 16 bits threshold of psm alarm time</comment>
        </bits>
      </reg>
      <reg name="psm_cnt_interval_th" protect="rw">
        <bits access="rw" name="psm_cnt_interval_th_15_0" pos="15:0" rst="0x3c">
          <comment>The threshold of psm calibration interval , unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="psm_cnt_interval_phase" protect="rw">
        <bits access="rw" name="psm_cnt_interval_phase_15_0" pos="15:0" rst="0x3c">
          <comment>The threshold of psm calibration interval , unit is (clk_cal_64k_div_th +1)ms</comment>
        </bits>
      </reg>
      <reg name="dcxo" protect="rw">
        <bits access="rw" name="psm_reg_dbnc_sel" pos="15" rst="0x0">
          <comment>0sel clk_cal_1k1sel clk_rc_64k or xtal32k</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_lp_en" pos="14" rst="0x1">
          <comment>0disable 1enable</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_discharge_en" pos="13" rst="0x1">
          <comment>LDO_DCXO discharge en</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_shpt_en" pos="12" rst="0x1">
          <comment>LDO_DCXO short protect EN:
0 is disable
1 is enable(default)</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_stb" pos="11:10" rst="0x0">
          <comment>LDO_DCXO compensation capacitor and resistor adjust</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_rz_adj" pos="9" rst="0x1">
          <comment>compensation resistor  adjust</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_cl_adj" pos="8:6" rst="0x3">
          <comment>LDO_DCXO current limit threshold adjust , 111~000 380mA~240mA 20mA/step</comment>
        </bits>
        <bits access="rw" name="ldo_dcxo_v" pos="5:0" rst="0x7">
          <comment>DCXO LDO output voltage select, 000000~111111 1.625V~3.225V  25mV/step</comment>
        </bits>
      </reg>
      <reg name="psm_rc_clk_div" protect="rw">
        <bits access="rw" name="rc_32k_cal_cnt_p" pos="11:8" rst="0x0">
          <comment>Psm calibration divider,
1when rc_64k calib(clude xtal_32k calib use rc_64k por on first time)it is calculated with rc_32k_cal_cnt_n  log2(clk_cal_64k_div_th+1)e.g: I.  clk_cal_1k=128Hz, cnt_p=0x4,cnt_n=0x8div_th=0xfII.  clk_cal_1k=1KHz, cnt_p=0x4,cnt_n=0x5div_th=0x1
2when 32k_xtal calibit is calculated with rc_32k_cal_cnt_n-log2(clk_cal_64k_div_th+1)-1e.g: I. clk_cal_1k=128Hz, cnt_p=0x4,cnt_n=0x8div_th=0x7II. clk_cal_1k=1KHz, cnt_p=0x4,cnt_n=0x5div_th=0x0
3when 32k_xtal no calib, e.g: I. clk_cal_1k=128Hz,div_th=4'hf II. clk_cal_1k=1KHz,div_th=4'h0</comment>
        </bits>
        <bits access="rw" name="clk_cal_64k_div_th" pos="7:4" rst="0x0">
          <comment>psm rc 64K divider, the input RC clock is divider to CLK_64K/( clk_cal_64k_div_th+1)</comment>
        </bits>
        <bits access="rw" name="wdg_rst_clk_sel_en" pos="0" rst="0x0">
          <comment>Enable watchdog power on chip by internal RC clock</comment>
        </bits>
      </reg>
      <reg name="reserved_2" protect="rw">
        </reg>
      <reg name="reserved_3" protect="rw">
        </reg>
      <reg name="reserved_4" protect="rw">
        </reg>
      <reg name="reserved_5" protect="rw">
        </reg>
      <reg name="reserved_6" protect="rw">
        </reg>
      <reg name="psm_cnt_update_l_value" protect="rw">
        <bits access="r" name="psm_cnt_update_value_15_0" pos="15:0" rst="0x0">
          <comment>Psm cnt updated low 16 bits value, the step of read this value is :
(1)enable psm_cnt_update,
(2)wait till psm_cnt_update_vld ==1.(psm_fsm_status[6])</comment>
        </bits>
      </reg>
      <reg name="psm_cnt_update_h_value" protect="rw">
        <bits access="r" name="psm_cnt_update_value_31_16" pos="15:0" rst="0x0">
          <comment>Psm cnt updated high 16 bits value</comment>
        </bits>
      </reg>
      <reg name="psm_status" protect="rw">
        <bits access="rw" name="alarm_req_int_mask" pos="13" rst="0x0"/>
        <bits access="rw" name="psm_req_int_mask" pos="12" rst="0x0"/>
        <bits access="rw" name="charger_int_mask" pos="11" rst="0x0"/>
        <bits access="rw" name="pbint2_int_mask" pos="10" rst="0x0"/>
        <bits access="rw" name="pbint1_int_mask" pos="9" rst="0x0"/>
        <bits access="rw" name="ext_int_mask" pos="8" rst="0x0"/>
        <bits access="r" name="psm_cnt_update_vld" pos="6" rst="0x0">
          <comment>psm cnt updated valid</comment>
        </bits>
        <bits access="r" name="alarm_req_int" pos="5" rst="0x0">
          <comment>when psm_cnt_alarm_en==1, then if alarm cnt get psm_alarm_cnt_th, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
        <bits access="r" name="psm_req_int" pos="4" rst="0x0">
          <comment>when psm_cnt_en==1, then if psm cnt get psm_cnt_th, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
        <bits access="r" name="charger_int" pos="3" rst="0x0">
          <comment>when psm_cnt_alarm_en==1, then if alarm cnt get psm_alarm_cnt_th, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
        <bits access="r" name="pbint2_int" pos="2" rst="0x0">
          <comment>when pbint2_pwr_en==1, then if pbint2 is low, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
        <bits access="r" name="pbint1_int" pos="1" rst="0x0">
          <comment>when pbint1_pwr_en==1, then if pbint1 is low, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
        <bits access="r" name="ext_int" pos="0" rst="0x0">
          <comment>when ext_int_en==1, then if  ext_int is high, this bit is high,
When psm_status_clr is high, this bit is low</comment>
        </bits>
      </reg>
      <reg name="psm_fsm_status" protect="rw">
        <bits access="r" name="psm_fsm" pos="14:0" rst="0x0">
          <comment>Only debug use</comment>
        </bits>
      </reg>
      <reg name="psm_cal_cnt" protect="rw">
        <bits access="r" name="psm_cal_cnt" pos="15:0" rst="0xc6">
          <comment>We can use this value to calculate the RC 64K clock real frequency. Rc_64k=( clk_cal_64k_div_th+1)*(2^ rc_32k_cal_cnt_p)*26*10^6/ (psm_cal_cnt*2^9)</comment>
        </bits>
      </reg>
      <reg name="pbint_1s_thd" protect="rw">
        <bits access="rw" name="pbint_1s_thd" pos="11:0" rst="0x760">
          <comment>PBINT or CHGR_INT dbs time,0.244ms step</comment>
        </bits>
      </reg>
      <reg name="por_timer_thd" protect="rw">
        <bits access="rw" name="bg_pd_timer_thd" pos="15:10" rst="0x0">
          <comment>bg pd power on timer,0.244ms step</comment>
        </bits>
        <bits access="rw" name="ext_rst_timer_thd" pos="9:0" rst="0x17">
          <comment>ext rst_n release timer,0.244ms step</comment>
        </bits>
      </reg>
      <reg name="ext_xtl_dbs_timer" protect="rw">
        <bits access="rw" name="ext_xtl_dbs_timer1" pos="15:8" rst="0x2">
          <comment>ext xtl0_en~ext_xtl3_en dbs time32kHz</comment>
        </bits>
        <bits access="rw" name="ext_xtl_dbs_timer0" pos="7:0" rst="0x2">
          <comment>ext xtl0_en~ext_xtl3_en dbs time32kHz</comment>
        </bits>
      </reg>
      <reg name="ext_xtl_en_hl" protect="rw">
        <bits access="rw" name="ext_xtl_en_hl" pos="7:0" rst="0xff">
          <comment>0~7:ext_xtl_en0~7 high or low enable to exit psm0low vld1high vld</comment>
        </bits>
      </reg>
      <reg name="clk_32k_xtal_calibra_sel" protect="rw">
        <bits access="rw" name="psm_reg_xtal32k_pon" pos="1" rst="0x1">
          <comment>0disable xtal32k clk1enable xtal32k</comment>
        </bits>
        <bits access="rw" name="clk_32k_xtal_calibra_sel" pos="0" rst="0x1">
          <comment>0:clk_32k_xtal not calibra;1:clk_32k_xtal or rc_64k calibra</comment>
        </bits>
      </reg>
      <reg name="xtal_por_1st_clk_sel" protect="rw">
        <bits access="r" name="xtl7" pos="15" rst="0x0">
          <comment>xtl7_flag</comment>
        </bits>
        <bits access="r" name="xtl6" pos="14" rst="0x0">
          <comment>xtl6_flag</comment>
        </bits>
        <bits access="r" name="xtl5" pos="13" rst="0x0">
          <comment>xtl5_flag</comment>
        </bits>
        <bits access="r" name="xtl4" pos="12" rst="0x0">
          <comment>xtl4_flag</comment>
        </bits>
        <bits access="r" name="xtl3" pos="11" rst="0x0">
          <comment>xtl3_flag</comment>
        </bits>
        <bits access="r" name="xtl2" pos="10" rst="0x0">
          <comment>xtl2_flag</comment>
        </bits>
        <bits access="r" name="xtl1" pos="9" rst="0x0">
          <comment>xtl1_flag</comment>
        </bits>
        <bits access="r" name="xtl0" pos="8" rst="0x0">
          <comment>xtl0_flag</comment>
        </bits>
        <bits access="rw" name="xtal_por_1st_clk_sel" pos="0" rst="0x1">
          <comment>0:xtal_32k por on use xtal_32k,xtal not calibra must configure 0 ;1:xtal_32k por on use rc_64k</comment>
        </bits>
      </reg>
      <reg name="reserved23" protect="rw">
        <bits access="rw" name="reserved23" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved24" protect="rw">
        <bits access="rw" name="reserved24" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved25" protect="rw">
        <bits access="rw" name="reserved25" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved26" protect="rw">
        <bits access="rw" name="reserved26" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved27" protect="rw">
        <bits access="rw" name="reserved27" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved28" protect="rw">
        <bits access="rw" name="reserved28" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="reserved29" protect="rw">
        <bits access="rw" name="reserved29" pos="15:0" rst="0x0"/>
      </reg>
      <reg name="rtc_reserved1" protect="rw">
        <bits access="rw" name="rtc_reserved1" pos="15:8" rst="0xf0"/>
        <bits access="rw" name="pbint_pullh_enb" pos="2" rst="0x0"/>
        <bits access="rw" name="vbatlow_en" pos="1" rst="0x1"/>
        <bits access="rw" name="uvlo_en" pos="0" rst="0x1"/>
      </reg>
      <reg name="rg_rtc_vosel" protect="rw">
        <bits access="rw" name="rg_rtc_vosel" pos="10:8" rst="0x4"/>
        <bits access="rw" name="rg_vbatbk_vosel" pos="2:0" rst="0x4"/>
      </reg>
    </module>
    <instance address="0x51108700" name="PMIC_PSM" type="PMIC_PSM"/>
  </archive>
  <archive relative="pmic_int.xml">
    <module category="System" name="PMIC_INT">
      <reg name="int_mask_status" protect="rw">
        <comment>INT_MASK_STATUS</comment>
        <bits access="r" name="psm_int_mask_status" pos="8" rst="0x0"/>
        <bits access="r" name="cal_int_mask_status" pos="7" rst="0x0"/>
        <bits access="r" name="trm_int_mask_status" pos="6" rst="0x0"/>
        <bits access="r" name="eic_int_mask_status" pos="4" rst="0x0"/>
        <bits access="r" name="wdg_int_mask_status" pos="2" rst="0x0"/>
        <bits access="r" name="rtc_int_mask_status" pos="1" rst="0x0"/>
        <bits access="r" name="adc_int_mask_status" pos="0" rst="0x0"/>
      </reg>
      <reg name="int_raw_status" protect="rw">
        <comment>INT_RAW_STATUS</comment>
        <bits access="r" name="psm_int_raw_status" pos="8" rst="0x0"/>
        <bits access="r" name="cal_int_raw_status" pos="7" rst="0x0"/>
        <bits access="r" name="trm_int_raw_status" pos="6" rst="0x0"/>
        <bits access="r" name="eic_int_raw_status" pos="4" rst="0x0"/>
        <bits access="r" name="wdg_int_raw_status" pos="2" rst="0x0"/>
        <bits access="r" name="rtc_int_raw_status" pos="1" rst="0x0"/>
        <bits access="r" name="adc_int_raw_status" pos="0" rst="0x0"/>
      </reg>
      <reg name="int_en" protect="rw">
        <comment>INT_EN</comment>
        <bits access="rw" name="psm_int_en" pos="8" rst="0x1"/>
        <bits access="rw" name="cal_int_en" pos="7" rst="0x1"/>
        <bits access="rw" name="trm_int_en" pos="6" rst="0x1"/>
        <bits access="rw" name="eic_int_en" pos="4" rst="0x1"/>
        <bits access="rw" name="wdg_int_en" pos="2" rst="0x1"/>
        <bits access="rw" name="rtc_int_en" pos="1" rst="0x1"/>
        <bits access="rw" name="adc_int_en" pos="0" rst="0x1"/>
      </reg>
    </module>
    <instance address="0x51108400" name="PMIC_INT" type="PMIC_INT"/>
  </archive>
  <archive relative="pmic_pin_reg.xml">
    <module category="System" name="PMIC_PIN_REG">
      <reg name="pin_adi_sclk" protect="rw">
        <comment>PIN_ADI_SCLK</comment>
        <bits access="rw" name="adi_sclk_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="adi_sclk_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="adi_sclk_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="adi_sclk_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="pin_adi_d" protect="rw">
        <comment>PIN_ADI_D</comment>
        <bits access="rw" name="adi_d_bsr_drv" pos="9:8" rst="0x3"/>
        <bits access="rw" name="adi_d_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="adi_d_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="adi_d_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="adi_d_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="adi_d_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="adi_d_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="adi_d_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="pin_ext_rst_b" protect="rw">
        <comment>PIN_EXT_RST_B</comment>
        <bits access="rw" name="ext_rst_b_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_rst_b_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="ext_rst_b_slp_oe" pos="0" rst="0x1"/>
      </reg>
      <reg name="pin_ana_int" protect="rw">
        <comment>PIN_ANA_INT</comment>
        <bits access="rw" name="adi_sclk_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="adi_sclk_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="adi_sclk_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="adi_sclk_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="adi_sclk_slp_oe" pos="0" rst="0x1"/>
      </reg>
      <reg name="pin_chip_sellp" protect="rw">
        <comment>PIN_CHIP_SELLP</comment>
        <bits access="rw" name="chip_sleep_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="chip_sleep_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="chip_sleep_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="chip_sleep_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="chip_sleep_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="chip_sleep_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="chip_sleep_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="chip_sleep_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="pin_clk_32k" protect="rw">
        <comment>PIN_CLK_32K</comment>
        <bits access="rw" name="clk_32k_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="clk_32k_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="clk_32k_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="clk_32k_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="clk_32k_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="clk_32k_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="clk_32k_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="clk_32k_slp_oe" pos="0" rst="0x1"/>
      </reg>
      <reg name="pin_ptesto" protect="rw">
        <comment>PIN_PTESTO</comment>
        <bits access="rw" name="ptesto_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ptesto_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ptesto_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="ptesto_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ptesto_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ptesto_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="ptesto_slp_ie" pos="1" rst="0x0"/>
        <bits access="rw" name="ptesto_slp_oe" pos="0" rst="0x1"/>
      </reg>
      <reg name="pin_clk26m" protect="rw">
        <comment>PIN_CLK26M</comment>
        <bits access="rw" name="clk26m_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="clk26m_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="clk26m_fun_wpdo" pos="6" rst="0x0"/>
        <bits access="rw" name="clk26m_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="clk26m_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="clk26m_slp_wpdo" pos="2" rst="0x0"/>
        <bits access="rw" name="clk26m_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="clk26m_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en0" protect="rw">
        <comment>EXT_XTL_EN0</comment>
        <bits access="rw" name="ext_xtl_en0_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en0_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en0_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en0_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en0_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en0_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en0_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en0_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en1" protect="rw">
        <comment>EXT_XTL_EN1</comment>
        <bits access="rw" name="ext_xtl_en1_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en1_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en1_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en1_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en1_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en1_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en1_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en1_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en2" protect="rw">
        <comment>EXT_XTL_EN2</comment>
        <bits access="rw" name="ext_xtl_en2_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en2_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en2_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en2_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en2_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en2_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en2_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en2_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en3" protect="rw">
        <comment>EXT_XTL_EN3</comment>
        <bits access="rw" name="ext_xtl_en3_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en3_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en3_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en3_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en3_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en3_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en3_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en3_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en4" protect="rw">
        <comment>EXT_XTL_EN4</comment>
        <bits access="rw" name="ext_xtl_en4_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en4_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en4_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en4_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en4_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en4_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en4_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en4_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en5" protect="rw">
        <comment>EXT_XTL_EN5</comment>
        <bits access="rw" name="ext_xtl_en5_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en5_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en5_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en5_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en5_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en5_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en5_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en5_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en6" protect="rw">
        <comment>EXT_XTL_EN6</comment>
        <bits access="rw" name="ext_xtl_en6_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en6_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en6_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en6_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en6_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en6_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en6_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en6_slp_oe" pos="0" rst="0x0"/>
      </reg>
      <reg name="ext_xtl_en7" protect="rw">
        <comment>EXT_XTL_EN7</comment>
        <bits access="rw" name="ext_xtl_en7_bsr_drv" pos="9:8" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en7_fun_wpu" pos="7" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en7_fun_wpdo" pos="6" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en7_fun_sel" pos="5:4" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en7_slp_wpu" pos="3" rst="0x0"/>
        <bits access="rw" name="ext_xtl_en7_slp_wpdo" pos="2" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en7_slp_ie" pos="1" rst="0x1"/>
        <bits access="rw" name="ext_xtl_en7_slp_oe" pos="0" rst="0x0"/>
      </reg>
    </module>
    <instance address="0x511087c0" name="PMIC_PIN_REG" type="PMIC_PIN_REG"/>
  </archive>
  <archive relative="adi_mst.xml">
    <module category="Periph" name="ADI_MST">
      <reg name="adi_version" protect="rw">
        <bits access="rw" name="adi_version_low" pos="3:0" rst="0">
          <comment>adi low bits version.</comment>
        </bits>
        <bits access="r" name="adi_version_high" pos="15:4" rst="0x10">
          <comment>adi high bits version,read only.</comment>
        </bits>
      </reg>
      <reg name="adi_ctrl" protect="rw">
        <bits access="rw" name="addr_byte_sel" pos="1:0" rst="0">
          <comment>addr mode for access. &quot;00&quot; word mode,means addr[x:2],&quot;01&quot; half word,means addr[x:1], &quot;1x&quot; byte mode, means addr[x:0].</comment>
        </bits>
        <bits access="rw" name="wr_bit_flag" pos="2" rst="0">
          <comment>configure write bit flag.</comment>
        </bits>
        <bits access="rw" name="addr_bits_sel" pos="4:3" rst="0">
          <comment>addr bit number configure, &quot;00&quot; address is 12 bits, &quot;01&quot; address is 10 bits, &quot;10&quot; address is 15 bits.</comment>
        </bits>
        <bits access="rw" name="wr_cmd_en" pos="5" rst="0">
          <comment>&quot;1&quot; write uses command mode, in this mode, must first configure channel addr, then data.</comment>
        </bits>
      </reg>
      <reg name="adi_pril" protect="rw">
        <bits access="rw" name="chnl0_pri" pos="2:0" rst="0">
          <comment>write channel 0 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
        <bits access="rw" name="chnl1_pri" pos="5:3" rst="0">
          <comment>read channel 1 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
        <bits access="rw" name="event0_pri" pos="8:6" rst="0">
          <comment>read channel 2 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
        <bits access="rw" name="event1_pri" pos="11:9" rst="0">
          <comment>read channel 3 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
        <bits access="rw" name="event2_pri" pos="14:12" rst="0">
          <comment>read channel 4 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
        <bits access="rw" name="event3_pri" pos="17:15" rst="0">
          <comment>read channel 5 priority. 0 has lowest priority, 4 has highest priority.</comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="adi_int_en" protect="rw">
        <bits access="rw" name="wfifo_en" pos="0" rst="0">
          <comment>&quot;1&quot; write command fifo enable.</comment>
        </bits>
        <bits access="rw" name="fifo_overflow_int_en" pos="3" rst="0">
          <comment>fifo overfolow interrupt mask.</comment>
        </bits>
      </reg>
      <reg name="adi_int_raw" protect="r">
        <bits access="r" name="fifo_overflow_raw" pos="3" rst="0">
          <comment>fifo overfolow interrupt without mask status.</comment>
        </bits>
      </reg>
      <reg name="adi_int_status" protect="r">
        <bits access="r" name="fifo_overflow_status" pos="3" rst="0">
          <comment>fifo overfolow interrupt with mask status.</comment>
        </bits>
      </reg>
      <reg name="adi_int_clear" protect="w">
        <bits access="w" name="fifo_overflow_clear" pos="3" rst="0">
          <comment>fifo overfolow interrupt clear.</comment>
        </bits>
      </reg>
      <reg name="adi_cfg0" protect="rw">
        <bits access="rw" name="rf_gssi_frame_len" pos="5:0" rst="0x3d">
          <comment>total adi frame length = rf_gssi_cmd_len + rf_gssi_data_len.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_cmd_len" pos="10:6" rst="0x14">
          <comment>total adi cmd length = rf_gssi_addr_len + read/write flag.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_data_len" pos="15:11" rst="0x10">
          <comment>total adi data length .</comment>
        </bits>
        <bits access="rw" name="rf_gssi_wr_pos" pos="20:16" rst="0x10">
          <comment>write bit position in frame stream .</comment>
        </bits>
        <bits access="rw" name="rf_gssi_wr_pol" pos="21" rst="0x0">
          <comment>&quot;1&quot; write means 1, &quot;0&quot; write means 0.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sync_sel" pos="22" rst="0x1">
          <comment>&quot;1&quot; hardware auto generate sync, &quot;0&quot; software generates sync.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sync_mode" pos="23" rst="0x1">
          <comment>&quot;1&quot; sync is pulse, &quot;0&quot; sync is level.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sync" pos="24" rst="0x0">
          <comment>&quot;1&quot; software generates sync.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sck_rev" pos="25" rst="0x0">
          <comment>&quot;1&quot; invert output sck.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_oe_cfg" pos="26" rst="0x1">
          <comment>output oen : &quot;1&quot; oen add dummy cycle, &quot;0&quot; oen not add dummy cycle.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_ie_cfg" pos="27" rst="0x0">
          <comment>reserved.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_dummy_clk_en" pos="28" rst="0x1">
          <comment>&quot;1&quot; output dummy_clock, &quot;0&quot; gate dummy clock.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_fast_mode" pos="29" rst="0x0">
          <comment>&quot;1&quot; rx sample delay 1 adi clk cycle, &quot;0&quot; delay 0 adi clk cycle.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sck_all_on" pos="30" rst="0x1">
          <comment>&quot;1&quot; sck always on, &quot;0&quot; audo gate  clock.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_wr_disable" pos="31" rst="0x0">
          <comment>&quot;1&quot; write bit disable, &quot;0&quot; write bit enable.</comment>
        </bits>
      </reg>
      <reg name="adi_cfg1" protect="rw">
        <bits access="rw" name="rf_gssi_ng_tx" pos="0" rst="1">
          <comment>&quot;1&quot; tx data at negedge of sck.&quot;0&quot; tx data at posedge of sck.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_ng_rx" pos="1" rst="0">
          <comment>&quot;1&quot; rx data at negedge of sck.&quot;0&quot; rx data at posedge of sck.</comment>
        </bits>
        <bits access="rw" name="rf_gssi_clk_div" pos="9:2" rst="1">
          <comment>F_sck = F_clk/(2*(rf_gssi_clk_div+1))</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sync_head_len" pos="12:10" rst="0">
          <comment>sync before data transfer</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sync_end_len" pos="15:13" rst="0">
          <comment>sync end data transfer</comment>
        </bits>
        <bits access="rw" name="rf_gssi_dummy_len" pos="19:16" rst="3">
          <comment>extral dummy sck</comment>
        </bits>
        <bits access="rw" name="rf_gssi_sample_delay" pos="20" rst="0">
          <comment>extral dummy sck</comment>
        </bits>
        <bits access="rw" name="rf_gssi_scc_len" pos="23:21" rst="0">
          <comment>start sequence condition, only used in RFFE</comment>
        </bits>
        <bits access="rw" name="rf_gssi_wbp_len" pos="26:24" rst="0">
          <comment>master turn around to salve length , only used in RFFE</comment>
        </bits>
        <bits access="rw" name="rf_gssi_rbp_len" pos="30:28" rst="0">
          <comment>slave turn around to master length , only used in RFFE</comment>
        </bits>
        <bits access="rw" name="rf_gssi_strtbit_mode" pos="31" rst="0">
          <comment>&quot;1&quot; 2 wires enable</comment>
        </bits>
      </reg>
      <reg name="arm_rd_cmd" protect="rw">
        <bits access="rw" name="arm_rd_cmd" pos="16:0" rst="0">
          <comment>configure read address and start a read operation.</comment>
        </bits>
      </reg>
      <reg name="arm_rd_data" protect="r">
        <bits access="r" name="arm_rd_cmd" pos="15:0" rst="0">
          <comment>read data from analog die.</comment>
        </bits>
        <bits access="r" name="arm_rd_addr" pos="30:16" rst="0">
          <comment>read address map to arm_red_cmd[16:2].</comment>
        </bits>
        <bits access="r" name="arm_rd_cmd_busy" pos="31" rst="0">
          <comment>1 means has not been read back.</comment>
        </bits>
      </reg>
      <reg name="arm_cmd_status" protect="r">
        <bits access="r" name="arm_wr_status" pos="0" rst="0">
          <comment>&quot;1&quot; write channel is busy</comment>
        </bits>
        <bits access="r" name="arm_rd_status" pos="1" rst="0">
          <comment>&quot;1&quot; read channel is busy</comment>
        </bits>
        <bits access="r" name="adi_busy" pos="4" rst="0">
          <comment>&quot;1&quot; adi operation is busy</comment>
        </bits>
        <bits access="r" name="wfifo full" pos="8" rst="0">
          <comment>wfifo full status</comment>
        </bits>
        <bits access="r" name="wfifo empty" pos="9" rst="0">
          <comment>wfifo empty status</comment>
        </bits>
        <bits access="r" name="wfifo fill data level" pos="14:12" rst="0">
          <comment>wfifo fill data number</comment>
        </bits>
        <bits access="r" name="adi fsm status" pos="19:16" rst="0">
          <comment>adi fsm status</comment>
        </bits>
        <bits access="r" name="event0 wr status" pos="20" rst="0">
          <comment>event 0 wr status</comment>
        </bits>
        <bits access="r" name="event1 wr status" pos="21" rst="0">
          <comment>event 1 wr status</comment>
        </bits>
        <bits access="r" name="event2 wr status" pos="22" rst="0">
          <comment>event 2 wr status</comment>
        </bits>
        <bits access="r" name="event3 wr status" pos="23" rst="0">
          <comment>event 3 wr status</comment>
        </bits>
      </reg>
      <reg name="adi_chanel_en" protect="rw">
        <bits access="rw" name="event0 trigger negedge en" pos="0" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event0 trigger posedge en" pos="1" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event1 trigger negedge en" pos="2" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event1 trigger posedge en" pos="3" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event2 trigger negedge en" pos="4" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event2 trigger posedge en" pos="5" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event3 trigger negedge en" pos="6" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="event3 trigger posedge en" pos="7" rst="0">
          <comment/>
        </bits>
      </reg>
      <reg name="adi_cmd_wr" protect="rw">
        <bits access="rw" name="adi_cmd_wr" pos="16:0" rst="0">
          <comment>the address map to the PMIC chip space, just for write operation</comment>
        </bits>
      </reg>
      <reg name="adi_dat_wr" protect="rw">
        <bits access="rw" name="adi_dat_wr" pos="15:0" rst="0">
          <comment>the dat to the PMIC chip space, just for write operation</comment>
        </bits>
      </reg>
      <reg name="event0_waddr" protect="rw">
        <bits access="rw" name="event0_waddr" pos="16:0" rst="0x634">
          <comment/>
        </bits>
      </reg>
      <reg name="event1_waddr" protect="rw">
        <bits access="rw" name="event1_waddr" pos="16:0" rst="0">
          <comment/>
        </bits>
      </reg>
      <reg name="event2_waddr" protect="rw">
        <bits access="rw" name="event2_waddr" pos="16:0" rst="0">
          <comment/>
        </bits>
      </reg>
      <reg name="event3_waddr" protect="rw">
        <bits access="rw" name="event3_waddr" pos="16:0" rst="0">
          <comment/>
        </bits>
      </reg>
      <reg name="event0_wdata" protect="rw">
        <bits access="rw" name="event0_neg_wdata" pos="15:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="event0_pos_wdata" pos="31:16" rst="0x1">
          <comment/>
        </bits>
      </reg>
      <reg name="event1_wdata" protect="rw">
        <bits access="rw" name="event1_neg_wdata" pos="15:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="event1_pos_wdata" pos="31:16" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="event2_wdata" protect="rw">
        <bits access="rw" name="event2_neg_wdata" pos="15:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="event2_pos_wdata" pos="31:16" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="event3_wdata" protect="rw">
        <bits access="rw" name="event3_neg_wdata" pos="15:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="event3_pos_wdata" pos="31:16" rst="0x0">
          <comment/>
        </bits>
      </reg>
    </module>
    <instance address="0x51100000" name="ADI_MST" type="ADI_MST"/>
  </archive>
  <archive relative="aon_ifc.xml">
    <var name="AON_NB_BITS_ADDR" value="32"/>
    <var name="AON_IFC_ADDR_ALIGN" value="0"/>
    <var name="AON_IFC_TC_LEN" value="23"/>
    <var name="AON_IFC_STD_CHAN_NB" value="6"/>
    <var name="AON_IFC_RFSPI_CHAN" value="0"/>
    <var name="AON_IFC_AIF_CHAN" value="2"/>
    <var name="AON_IFC_DBG_CHAN" value="1"/>
    <enum name="AON_IFC_Request_IDs">
      <entry name="DMA_ID_TX_UART2"/>
      <entry name="DMA_ID_RX_UART2"/>
      <entry name="DMA_ID_TX_UART3"/>
      <entry name="DMA_ID_RX_UART3"/>
      <entry name="DMA_ID_TX_DBG_UART"/>
      <entry name="DMA_ID_RX_DBG_UART"/>
    </enum>
    <module category="System" name="AON_IFC">
      <reg name="get_ch" protect="--">
        <bits access="r" name="ch_to_use" pos="4:0" rst="0">
          <comment>
            This field indicates which standard channel to use.
            <br/>
             Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
            <br/>
             After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
            <br/>
            Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
            <br/>
            Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
            <br/>
            When non-secure cpu read this register, the return value will automatic exlude the secure channel.
            <br/>
            00000 = use Channel0
            <br/>
            00001 = use Channel1
            <br/>
            00010 = use Channel2
            <br/>
             ...
            <br/>
            01111 = use Channel15
            <br/>
            11111 = all channels are busy
          </comment>
          <options>
            <mask/>
            <shift/>
            <default/>
          </options>
        </bits>
      </reg>
      <reg name="dma_status" protect="r">
        <bits access="r" name="ch_enable" pos="AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN-1:0" rst="0">
          <comment>
            This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels disabled
            <br/>
            0000_0001 = Ch0 enabled
            <br/>
            0000_0010 = Ch1 enabled
            <br/>
            0000_0100 = Ch2 enabled
            <br/>
            0000_0101 = Ch0 and Ch2 enabled
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 enabled
            <br/>
            all 1     = all channels enabled
          </comment>
        </bits>
        <bits access="r" name="ch_busy" pos="AON_IFC_STD_CHAN_NB-1+16:16" rst="0">
          <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
        </bits>
      </reg>
      <reg name="debug_status" protect="r">
        <bits access="r" name="dbg_status" pos="0" rst="1">
          <comment>
            Debug Channel Status .
            <br/>
            0= The debug channel is running
      (not idle)
            <br/>
            1= The debug channel is in idle mode
          </comment>
        </bits>
      </reg>
      <reg name="ifc_sec" protect="rw">
        <bits access="rw" name="std_ch_reg_sec" pos="AON_IFC_STD_CHAN_NB-1:0" rst="0">
          <comment>
            This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels registers can be accessed by secure master or non-secure master.
            <br/>
            0000_0001 = Ch0 registers can only be accessed by secure master.
            <br/>
            0000_0010 = Ch1 registers can only be accessed by secure master.
            <br/>
            0000_0100 = Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels registers can only be accessed by secure master.
          </comment>
        </bits>
        <bits access="rw" name="aif_ch_reg_sec" pos="AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN+AON_IFC_AIF_CHAN-1:AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN" rst="0">
          <comment>This register indicates aif channel register can only be accessed by secure master.</comment>
        </bits>
        <bits access="rw" name="std_ch_dma_sec" pos="AON_IFC_STD_CHAN_NB-1+16:16" rst="all1">
          <comment>
            This register indicates which channel dma is secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels dma are non-secure master.
            <br/>
            0000_0001 = Ch0 dma is secure master.
            <br/>
            0000_0010 = Ch1 dma is secure master.
            <br/>
            0000_0100 = Ch2 dma is secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 dma are secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels dma are secure master.
          </comment>
        </bits>
        <bits access="rw" name="aif_ch_dma_sec" pos="AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN+AON_IFC_AIF_CHAN-1+16:AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN+16" rst="all1">
          <comment>This register indicates aif channel dma is secure master.</comment>
        </bits>
        <bits access="rw" name="dbg_ch_dma_sec" pos="AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN+AON_IFC_AIF_CHAN+AON_IFC_DBG_CHAN-1+16:AON_IFC_STD_CHAN_NB+AON_IFC_RFSPI_CHAN+AON_IFC_AIF_CHAN+16" rst="1">
          <comment>This register indicates dbghost channel dma is secure master.</comment>
        </bits>
      </reg>
      <struct count="AON_IFC_STD_CHAN_NB" name="std_ch">
        <reg name="control" protect="rw">
          <bits access="w" name="enable" pos="0" rst="no">
            <comment>
              Channel Enable, write one in this bit enable the channel.
              <br/>
              When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer.
            </comment>
          </bits>
          <bits access="w" name="disable" pos="1" rst="no">
            <comment>
              Channel Disable, write one in this bit disable the channel.
              <br/>
              When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled.
            </comment>
          </bits>
          <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
            <comment>
              Exchange the read data from fifo halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
            <comment>
              Exchange the write data to fifo  halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="autodisable" pos="4" rst="1">
            <comment>
              Set Auto-disable mode
              <br/>
               0 = when TC reach zero the
        channel is not automatically released.
              <br/>
               1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.
            </comment>
          </bits>
          <bits access="rw" name="size" pos="5" rst="0">
            <comment>
              Peripheral Size
              <br/>
               0= 8-bit peripheral
              <br/>
               1= 32-bit peripheral
            </comment>
          </bits>
          <bits access="rw" display="hex" name="req_src" pos="12:8" rst="0x1F">
            <options linkenum="AON_IFC_Request_IDs">
              <shift/>
              <mask/>
              <default/>
            </options>
            <comment>Select DMA Request source</comment>
          </bits>
          <bits access="rw" name="flush" pos="16" rst="0">
            <comment>
              When one, flush the internal FIFO channel.
              <br/>
              This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel.
              <br/>
               Before writting back this bit to zero the internal fifo must empty.
            </comment>
          </bits>
          <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
            <comment>
              Set the MAX burst length for channel 0,1.
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.
              <br/>
               The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4.
              <br/>
               .
            </comment>
          </bits>
        </reg>
        <reg name="status" protect="r">
          <bits access="r" name="enable" pos="0" rst="0">
            <comment>Enable bit, when '1' the channel is running</comment>
          </bits>
          <bits access="r" name="fifo_empty" pos="4" rst="1">
            <comment>The internal channel fifo is empty</comment>
          </bits>
        </reg>
        <reg name="start_addr" protect="rw">
          <bits access="rw" display="hex" name="start_addr" pos="AON_NB_BITS_ADDR-1:AON_IFC_ADDR_ALIGN" rst="0xFFFFFFF">
            <comment>
              AHB Address. This field represent the start address of the
        transfer.
              <br/>
              For a 32-bit peripheral, this address must be aligned 32-bit.
            </comment>
          </bits>
        </reg>
        <reg name="tc" protect="rw">
          <bits access="rw" display="hex" name="tc" pos="AON_IFC_TC_LEN-1:0" rst="0xFFFFFF">
            <comment>
              Transfer Count, this field indicated the transfer size in bytes to perform.
              <br/>
              During a transfer a write in this register add the new value to the current TC.
              <br/>
              A read of this register return the current current transfer count.
            </comment>
          </bits>
        </reg>
        <reg name="tc_threshold" protect="rw">
          <bits access="rw" display="hex" name="tc_threshold" pos="AON_IFC_TC_LEN-1:0" rst="0x0">
            <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.</comment>
          </bits>
        </reg>
      </struct>
    </module>
    <module category="System" name="AUDIO_IFC">
      <var name="AON_APB1_IFC_AHB_MAXSPACE" value="20"/>
      <var name="AON_APB1_IFC_ADDR_ALIGN" value="2"/>
      <struct count="AON_IFC_AIF_CHAN" name="ch">
        <comment>
          The Channel 0 conveys data from the AIF to the memory.
          <br/>
        The Channel 1 conveys data from the memory to the AIF.
          <br/>
          These Channels only exist with Voice Option.
        </comment>
        <reg name="control" protect="rw">
          <bits access="w" name="enable" pos="0" rst="no">
            <comment>
              Channel Enable, write one in this bit enable the channel.
              <br/>
              When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer.
            </comment>
          </bits>
          <bits access="w" name="disable" pos="1" rst="no">
            <comment>
              Channel Disable, write one in this bit disable the channel.
              <br/>
              When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled.
            </comment>
          </bits>
          <bits access="rw" name="auto_disable" pos="4" rst="0">
            <comment>Automatic channel Disable. When this bit is set, the channel is automatically disabled at the next interrupt.</comment>
          </bits>
        </reg>
        <reg name="status" protect="r">
          <bits access="r" name="enable" pos="0" rst="0">
            <comment>When 1 the channel is enabled</comment>
          </bits>
          <bits access="r" name="fifo_empty" pos="4" rst="1">
            <comment>When 1 the fifo is empty</comment>
          </bits>
          <bits access="r" name="cause_ief" pos="8" rst="0">
            <comment>Cause interrupt End of FIFO.</comment>
          </bits>
          <bits access="r" name="cause_ihf" pos="9" rst="0">
            <comment>Cause interrupt Half of FIFO.</comment>
          </bits>
          <bits access="r" name="cause_i4f" pos="10" rst="0">
            <comment>Cause interrupt Quarter of FIFO.</comment>
          </bits>
          <bits access="r" name="cause_i3_4f" pos="11" rst="0">
            <comment>Cause interrupt Three Quarter of FIFO.</comment>
          </bits>
          <bits access="r" name="cause_ahb_error" pos="12" rst="0">
            <comment>Cause interrupt ahb error.</comment>
          </bits>
          <bits access="r" name="ief" pos="16" rst="0">
            <comment>End of FIFO interrupt status bit.</comment>
          </bits>
          <bits access="r" name="ihf" pos="17" rst="0">
            <comment>Half of FIFO interrupt status bit.</comment>
          </bits>
          <bits access="r" name="i4f" pos="18" rst="0">
            <comment>Quarter of FIFO interrupt status bit.</comment>
          </bits>
          <bits access="r" name="i3_4f" pos="19" rst="0">
            <comment>Three Quarter of FIFO interrupt status bit.</comment>
          </bits>
          <bits access="r" name="ahb error" pos="20" rst="0">
            <comment>ahb error interrupt status bit.</comment>
          </bits>
          <bits access="r" name="ch_idle" pos="21" rst="0">
            <comment>channel busy status bit.</comment>
          </bits>
        </reg>
        <reg name="start_addr" protect="rw">
          <bits access="rw" display="hex" name="start_addr" pos="AON_NB_BITS_ADDR-1:AON_APB1_IFC_ADDR_ALIGN" rst="0xFFFFFFFF">
            <comment>AHB Start Address. This field represent the start address of the FIFO located in RAM.</comment>
          </bits>
        </reg>
        <reg name="fifo_size" protect="rw">
          <bits access="rw" display="hex" name="fifo_size" pos="19:4" rst="all1">
            <comment>
              Fifo size in bytes, max 1MBytes.
              <br/>
              The size of the fifo must be a multiple of 16 (The four LSB are always zero).
            </comment>
          </bits>
        </reg>
        <hole size="32"/>
        <reg name="int_mask" protect="rw">
          <bits access="rw" name="end_fifo" pos="8" rst="0">
            <comment>END FIFO Mask interrupt. When one this interrupt is enabled.</comment>
          </bits>
          <bits access="rw" name="half_fifo" pos="9" rst="0">
            <comment>HALF FIFO Mask interrupt. When one this interrupt is enabled.</comment>
          </bits>
          <bits access="rw" name="quarter_fifo" pos="10" rst="0">
            <comment>QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled.</comment>
          </bits>
          <bits access="rw" name="three_quarter_fifo" pos="11" rst="0">
            <comment>THREE QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled.</comment>
          </bits>
          <bits access="rw" name="ahb_error" pos="12" rst="0">
            <comment>ahb_error Mask interrupt. When one this interrupt is
        enabled.</comment>
          </bits>
        </reg>
        <reg name="int_clear" protect="rw">
          <bits access="c" name="end_fifo" pos="8" rst="0">
            <comment>Write one to clear end of fifo interrupt.</comment>
          </bits>
          <bits access="c" name="half_fifo" pos="9" rst="0">
            <comment>Write one to clear half of fifo interrupt.</comment>
          </bits>
          <bits access="c" name="quarter_fifo" pos="10" rst="0">
            <comment>Write one to clear Quarter fifo interrupt.</comment>
          </bits>
          <bits access="c" name="three_quarter_fifo" pos="11" rst="0">
            <comment>Write one to clear Three Quarter fifo interrupt.</comment>
          </bits>
          <bits access="c" name="ahb_error" pos="12" rst="0">
            <comment>Write one to clear ahb_error interrupt.</comment>
          </bits>
        </reg>
        <reg name="cur_ahb_addr" protect="r">
          <bits access="r" display="hex" name="cur_ahb_addr" pos="AON_NB_BITS_ADDR-1:0" rst="0">
            <comment>Current AHB address value. The nine MSB bit is constant and
        equal to the PAGE_ADDR field in the IFC_CH_AHB_START_ADDR register.</comment>
          </bits>
        </reg>
      </struct>
    </module>
    <instance address="0x5140E000" name="AON_IFC" type="AON_IFC"/>
  </archive>
  <archive relative="ap_ifc.xml">
    <var name="AP_NB_BITS_ADDR" value="32"/>
    <var name="AP_IFC_ADDR_ALIGN" value="0"/>
    <var name="AP_IFC_TC_LEN" value="23"/>
    <var name="AP_IFC_STD_CHAN_NB" value="10"/>
    <var name="AP_IFC_RFSPI_CHAN" value="0"/>
    <var name="AP_IFC_AIF_CHAN" value="0"/>
    <var name="AP_IFC_DBG_CHAN" value="0"/>
    <enum name="AP_IFC_Request_IDs">
      <entry name="DMA_ID_TX_UART4"/>
      <entry name="DMA_ID_RX_UART4"/>
      <entry name="DMA_ID_TX_UART5"/>
      <entry name="DMA_ID_RX_UART5"/>
      <entry name="DMA_ID_TX_UART6"/>
      <entry name="DMA_ID_RX_UART6"/>
      <entry name="DMA_ID_TX_SDMMC"/>
      <entry name="DMA_ID_RX_SDMMC"/>
      <entry name="DMA_ID_RSVD"/>
      <entry name="DMA_ID_RX_CAMERA"/>
    </enum>
    <module category="System" name="AP_IFC">
      <reg name="get_ch" protect="--">
        <bits access="r" name="ch_to_use" pos="4:0" rst="0">
          <comment>
            This field indicates which standard channel to use.
            <br/>
             Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
            <br/>
             After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
            <br/>
            Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
            <br/>
            Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
            <br/>
            When non-secure cpu read this register, the return value will automatic exlude the secure channel.
            <br/>
            00000 = use Channel0
            <br/>
            00001 = use Channel1
            <br/>
            00010 = use Channel2
            <br/>
             ...
            <br/>
            01111 = use Channel15
            <br/>
            11111 = all channels are busy
          </comment>
          <options>
            <mask/>
            <shift/>
            <default/>
          </options>
        </bits>
      </reg>
      <reg name="dma_status" protect="r">
        <bits access="r" name="ch_enable" pos="AP_IFC_STD_CHAN_NB+AP_IFC_RFSPI_CHAN-1:0" rst="0">
          <comment>
            This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels disabled
            <br/>
            0000_0001 = Ch0 enabled
            <br/>
            0000_0010 = Ch1 enabled
            <br/>
            0000_0100 = Ch2 enabled
            <br/>
            0000_0101 = Ch0 and Ch2 enabled
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 enabled
            <br/>
            all 1     = all channels enabled
          </comment>
        </bits>
        <bits access="r" name="ch_busy" pos="AP_IFC_STD_CHAN_NB-1+16:16" rst="0">
          <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
        </bits>
      </reg>
      <reg name="debug_status" protect="r">
        <bits access="r" name="dbg_status" pos="0" rst="1">
          <comment>
            Debug Channel Status .
            <br/>
            0= The debug channel is running
      (not idle)
            <br/>
            1= The debug channel is in idle mode
          </comment>
        </bits>
      </reg>
      <reg name="ifc_sec" protect="rw">
        <bits access="rw" name="std_ch_reg_sec" pos="AP_IFC_STD_CHAN_NB-1:0" rst="0">
          <comment>
            This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels registers can be accessed by secure master or non-secure master.
            <br/>
            0000_0001 = Ch0 registers can only be accessed by secure master.
            <br/>
            0000_0010 = Ch1 registers can only be accessed by secure master.
            <br/>
            0000_0100 = Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels registers can only be accessed by secure master.
          </comment>
        </bits>
        <bits access="rw" name="std_ch_dma_sec" pos="AP_IFC_STD_CHAN_NB-1+16:16" rst="all1">
          <comment>
            This register indicates which channel dma is secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels dma are non-secure master.
            <br/>
            0000_0001 = Ch0 dma is secure master.
            <br/>
            0000_0010 = Ch1 dma is secure master.
            <br/>
            0000_0100 = Ch2 dma is secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 dma are secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels dma are secure master.
          </comment>
        </bits>
      </reg>
      <struct count="AP_IFC_STD_CHAN_NB" name="std_ch">
        <reg name="control" protect="rw">
          <bits access="w" name="enable" pos="0" rst="no">
            <comment>
              Channel Enable, write one in this bit enable the channel.
              <br/>
              When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer.
            </comment>
          </bits>
          <bits access="w" name="disable" pos="1" rst="no">
            <comment>
              Channel Disable, write one in this bit disable the channel.
              <br/>
              When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled.
            </comment>
          </bits>
          <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
            <comment>
              Exchange the read data from fifo halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
            <comment>
              Exchange the write data to fifo  halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="autodisable" pos="4" rst="1">
            <comment>
              Set Auto-disable mode
              <br/>
               0 = when TC reach zero the
        channel is not automatically released.
              <br/>
               1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.
            </comment>
          </bits>
          <bits access="rw" name="size" pos="5" rst="0">
            <comment>
              Peripheral Size
              <br/>
               0= 8-bit peripheral
              <br/>
               1= 32-bit peripheral
            </comment>
          </bits>
          <bits access="rw" display="hex" name="req_src" pos="12:8" rst="0x1F">
            <options linkenum="AP_IFC_Request_IDs">
              <shift/>
              <mask/>
              <default/>
            </options>
            <comment>Select DMA Request source</comment>
          </bits>
          <bits access="rw" name="flush" pos="16" rst="0">
            <comment>
              When one, flush the internal FIFO channel.
              <br/>
              This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel.
              <br/>
               Before writting back this bit to zero the internal fifo must empty.
            </comment>
          </bits>
          <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
            <comment>
              Set the MAX burst length for channel 0,1.
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.
              <br/>
               The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4.
              <br/>
               .
            </comment>
          </bits>
        </reg>
        <reg name="status" protect="r">
          <bits access="r" name="enable" pos="0" rst="0">
            <comment>Enable bit, when '1' the channel is running</comment>
          </bits>
          <bits access="r" name="fifo_empty" pos="4" rst="1">
            <comment>The internal channel fifo is empty</comment>
          </bits>
        </reg>
        <reg name="start_addr" protect="rw">
          <bits access="rw" display="hex" name="start_addr" pos="AP_NB_BITS_ADDR-1:AP_IFC_ADDR_ALIGN" rst="0xFFFFFFF">
            <comment>
              AHB Address. This field represent the start address of the
        transfer.
              <br/>
              For a 32-bit peripheral, this address must be aligned 32-bit.
            </comment>
          </bits>
        </reg>
        <reg name="tc" protect="rw">
          <bits access="rw" display="hex" name="tc" pos="AP_IFC_TC_LEN-1:0" rst="0xFFFFFF">
            <comment>
              Transfer Count, this field indicated the transfer size in bytes to perform.
              <br/>
              During a transfer a write in this register add the new value to the current TC.
              <br/>
              A read of this register return the current current transfer count.
            </comment>
          </bits>
        </reg>
        <reg name="tc_threshold" protect="rw">
          <bits access="rw" display="hex" name="tc_threshold" pos="AP_IFC_TC_LEN-1:0" rst="0x0">
            <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.</comment>
          </bits>
        </reg>
      </struct>
    </module>
    <instance address="0x04405000" name="AP_IFC" type="AP_IFC"/>
  </archive>
  <archive relative="arm_axidma.xml">
    <module category="System" name="ARM_AXIDMA">
      <reg name="axidma_conf" protect="rw">
        <bits access="rw" name="gen_reg_secuirty_en" pos="6" rst="1">
          <comment>general used register security visit enable
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="resp_err_stop_en" pos="5" rst="0">
          <comment>response error stop function enable
0:enable
1:disable</comment>
        </bits>
        <bits access="rw" name="outstand" pos="4:3" rst="2">
          <comment>the number of outstanding that can be send out
0: 2
1: 3
2: 4</comment>
        </bits>
        <bits access="rw" name="priority" pos="2" rst="0">
          <comment>multe-channel transport priority mode control
0: there is no priority in the channels, using polling to DMA data
1: smaller channel number has high-priority.high-priority move data before low-priority channels</comment>
        </bits>
        <bits access="rw" name="stop_ie" pos="1" rst="0">
          <comment>interrupt control bit
0: no interruption occurs when all logical channels finish
1: interruption occurs when all logical channels finish</comment>
        </bits>
        <bits access="rw" name="stop" pos="0" rst="0">
          <comment>the control bit of logical channel transport finish
0: don't stop all the channel,or automatically clear after setting
1: stop all channel.the current transmission is stopped.the start bits of all channels are cleared</comment>
        </bits>
      </reg>
      <reg name="axidma_delay" protect="rw">
        <bits access="rw" name="delay" pos="15:0" rst="0">
          <comment>in the non-priority mode, the time interval between two COUNTP transmission. Take the system clock as the criterion to avoid AXIDMA long-term use of the bus.</comment>
        </bits>
      </reg>
      <reg name="axidma_status" protect="r">
        <bits access="r" name="stop_status" pos="4" rst="0">
          <comment>stop status
0: not finish
1: finish</comment>
        </bits>
        <bits access="r" name="ch_num" pos="3:0" rst="15">
          <comment>the channel number of the final transmission
0000: channel 0 just finished the transmission
0001: channel 1 just finished the transmission
0010: channel 2 just finished the transmission
......
1011: channel 11 just finished the transmission
others: nonentity</comment>
        </bits>
      </reg>
      <reg name="axidma_irq_stat" protect="r">
        <bits access="r" name="rst_fin_irq" pos="12" rst="0">
          <comment>logic channel stop interrupt status</comment>
        </bits>
        <bits access="r" name="ch11_irq" pos="11" rst="0">
          <comment>channel 11 interrupts state
0: the channel 11 has not been interrupted, or the interrupt bit has been cleared
1: channel 11 is interrupted</comment>
        </bits>
        <bits access="r" name="ch10_irq" pos="10" rst="0">
          <comment>channel 10 interrupts state
0: the channel 10 has not been interrupted, or the interrupt bit has been cleared
1: channel 10 is interrupted</comment>
        </bits>
        <bits access="r" name="ch9_irq" pos="9" rst="0">
          <comment>channel 9 interrupts state
0: the channel 9 has not been interrupted, or the interrupt bit has been cleared
1: channel 9 is interrupted</comment>
        </bits>
        <bits access="r" name="ch8_irq" pos="8" rst="0">
          <comment>channel 8 interrupts state
0: the channel 8 has not been interrupted, or the interrupt bit has been cleared
1: channel 8 is interrupted</comment>
        </bits>
        <bits access="r" name="ch7_irq" pos="7" rst="0">
          <comment>channel 7 interrupts state
0: the channel 7 has not been interrupted, or the interrupt bit has been cleared
1: channel 7 is interrupted</comment>
        </bits>
        <bits access="r" name="ch6_irq" pos="6" rst="0">
          <comment>channel 6 interrupts state
0: the channel 6 has not been interrupted, or the interrupt bit has been cleared
1: channel 6 is interrupted</comment>
        </bits>
        <bits access="r" name="ch5_irq" pos="5" rst="0">
          <comment>channel 5 interrupts state
0: the channel 5 has not been interrupted, or the interrupt bit has been cleared
1: channel 5 is interrupted</comment>
        </bits>
        <bits access="r" name="ch4_irq" pos="4" rst="0">
          <comment>channel 4 interrupts state
0: the channel 4 has not been interrupted, or the interrupt bit has been cleared
1: channel 4 is interrupted</comment>
        </bits>
        <bits access="r" name="ch3_irq" pos="3" rst="0">
          <comment>channel 3 interrupts state
0: the channel 3 has not been interrupted, or the interrupt bit has been cleared
1: channel 3 is interrupted</comment>
        </bits>
        <bits access="r" name="ch2_irq" pos="2" rst="0">
          <comment>channel 2 interrupts state
0: the channel 2 has not been interrupted, or the interrupt bit has been cleared
1: channel 2 is interrupted</comment>
        </bits>
        <bits access="r" name="ch1_irq" pos="1" rst="0">
          <comment>channel 1 interrupts state
0: the channel 1 has not been interrupted, or the interrupt bit has been cleared
1: channel 1 is interrupted</comment>
        </bits>
        <bits access="r" name="ch0_irq" pos="0" rst="0">
          <comment>channel 0 interrupts state
0: the channel 0 has not been interrupted, or the interrupt bit has been cleared
1: channel 0 is interrupted</comment>
        </bits>
      </reg>
      <reg name="axidma_arm_req_stat" protect="r">
        <bits access="r" name="irq23" pos="23" rst="0">
          <comment>state of IRQ 23 generate requests of moving data
0: IRQ 23 does not generate requests of moving data
1: IRQ 23 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq22" pos="22" rst="0">
          <comment>state of IRQ 22 generate requests of moving data
0: IRQ 22 does not generate requests of moving data
1: IRQ 22 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq21" pos="21" rst="0">
          <comment>state of IRQ 21 generate requests of moving data
0: IRQ 21 does not generate requests of moving data
1: IRQ 21 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq20" pos="20" rst="0">
          <comment>state of IRQ 20 generate requests of moving data
0: IRQ 20 does not generate requests of moving data
1: IRQ 20 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq19" pos="19" rst="0">
          <comment>state of IRQ 19 generate requests of moving data
0: IRQ 19 does not generate requests of moving data
1: IRQ 19 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq18" pos="18" rst="0">
          <comment>state of IRQ 18 generate requests of moving data
0: IRQ 18 does not generate requests of moving data
1: IRQ 18 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq17" pos="17" rst="0">
          <comment>state of IRQ 17 generate requests of moving data
0: IRQ 17 does not generate requests of moving data
1: IRQ 17 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq16" pos="16" rst="0">
          <comment>state of IRQ 16 generate requests of moving data
0: IRQ 16 does not generate requests of moving data
1: IRQ 16 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq15" pos="15" rst="0">
          <comment>state of IRQ 15 generate requests of moving data
0: IRQ 15 does not generate requests of moving data
1: IRQ 15 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq14" pos="14" rst="0">
          <comment>state of IRQ 14 generate requests of moving data
0: IRQ 14 does not generate requests of moving data
1: IRQ 14 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq13" pos="13" rst="0">
          <comment>state of IRQ 13 generate requests of moving data
0: IRQ 13 does not generate requests of moving data
1: IRQ 13 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq12" pos="12" rst="0">
          <comment>state of IRQ 12 generate requests of moving data
0: IRQ 12 does not generate requests of moving data
1: IRQ 12 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq11" pos="11" rst="0">
          <comment>state of IRQ 11 generate requests of moving data
0: IRQ 11 does not generate requests of moving data
1: IRQ 11 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq10" pos="10" rst="0">
          <comment>state of IRQ 10 generate requests of moving data
0: IRQ 10 does not generate requests of moving data
1: IRQ 10 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq9" pos="9" rst="0">
          <comment>state of IRQ 9 generate requests of moving data
0: IRQ 9 does not generate requests of moving data
1: IRQ 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq8" pos="8" rst="0">
          <comment>state of IRQ 8 generate requests of moving data
0: IRQ 8 does not generate requests of moving data
1: IRQ 8 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq7" pos="7" rst="0">
          <comment>state of IRQ 7 generate requests of moving data
0: IRQ 7 does not generate requests of moving data
1: IRQ 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq6" pos="6" rst="0">
          <comment>state of IRQ 6 generate requests of moving data
0: IRQ 6 does not generate requests of moving data
1: IRQ 6 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq5" pos="5" rst="0">
          <comment>state of IRQ 5 generate requests of moving data
0: IRQ 5 does not generate requests of moving data
1: IRQ 5 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq4" pos="4" rst="0">
          <comment>state of IRQ 4 generate requests of moving data
0: IRQ 4 does not generate requests of moving data
1: IRQ 4 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq3" pos="3" rst="0">
          <comment>state of IRQ 3 generate requests of moving data
0: IRQ 3 does not generate requests of moving data
1: IRQ 3 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq2" pos="2" rst="0">
          <comment>state of IRQ 2 generate requests of moving data
0: IRQ 2 does not generate requests of moving data
1: IRQ 2 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq1" pos="1" rst="0">
          <comment>state of IRQ 1 generate requests of moving data
0: IRQ 1 does not generate requests of moving data
1: IRQ 1 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="irq0" pos="0" rst="0">
          <comment>state of IRQ 0 generate requests of moving data
0: IRQ 0 does not generate requests of moving data
1: IRQ 0 generate requests of moving data</comment>
        </bits>
      </reg>
      <reg name="axidma_arm_ack_stat" protect="r">
        <bits access="r" name="ack23" pos="23" rst="0">
          <comment>state of ACK 23 generate requests of moving data
0: ACK 23 does not generate requests of moving data
1: ACK 23 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack22" pos="22" rst="0">
          <comment>state of ACK 22 generate requests of moving data
0: ACK 22 does not generate requests of moving data
1: ACK 22 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack21" pos="21" rst="0">
          <comment>state of ACK 21 generate requests of moving data
0: ACK 21 does not generate requests of moving data
1: ACK 21 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack20" pos="20" rst="0">
          <comment>state of ACK 20 generate requests of moving data
0: ACK 20 does not generate requests of moving data
1: ACK 20 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack19" pos="19" rst="0">
          <comment>state of ACK 19 generate requests of moving data
0: ACK 19 does not generate requests of moving data
1: ACK 19 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack18" pos="18" rst="0">
          <comment>state of ACK 18 generate requests of moving data
0: ACK 18 does not generate requests of moving data
1: ACK 18 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack17" pos="17" rst="0">
          <comment>state of ACK 17 generate requests of moving data
0: ACK 17 does not generate requests of moving data
1: ACK 17 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack16" pos="16" rst="0">
          <comment>state of ACK 16 generate requests of moving data
0: ACK 16 does not generate requests of moving data
1: ACK 16 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack15" pos="15" rst="0">
          <comment>state of ACK 15 generate requests of moving data
0: ACK 15 does not generate requests of moving data
1: ACK 15 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack14" pos="14" rst="0">
          <comment>state of ACK 14 generate requests of moving data
0: ACK 14 does not generate requests of moving data
1: ACK 14 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack13" pos="13" rst="0">
          <comment>state of ACK 13 generate requests of moving data
0: ACK 13 does not generate requests of moving data
1: ACK 13 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack12" pos="12" rst="0">
          <comment>state of ACK 12 generate requests of moving data
0: ACK 12 does not generate requests of moving data
1: ACK 12 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack11" pos="11" rst="0">
          <comment>state of ACK 11 generate requests of moving data
0: ACK 11 does not generate requests of moving data
1: ACK 11 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack10" pos="10" rst="0">
          <comment>state of ACK 10 generate requests of moving data
0: ACK 10 does not generate requests of moving data
1: ACK 10 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack9" pos="9" rst="0">
          <comment>state of ACK 9 generate requests of moving data
0: ACK 9 does not generate requests of moving data
1: ACK 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack8" pos="8" rst="0">
          <comment>state of ACK 8 generate requests of moving data
0: ACK 8 does not generate requests of moving data
1: ACK 8 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack7" pos="7" rst="0">
          <comment>state of ACK 7 generate requests of moving data
0: ACK 7 does not generate requests of moving data
1: ACK 7 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack6" pos="6" rst="0">
          <comment>state of ACK 6 generate requests of moving data
0: ACK 6 does not generate requests of moving data
1: ACK 6 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack5" pos="5" rst="0">
          <comment>state of ACK 5 generate requests of moving data
0: ACK 5 does not generate requests of moving data
1: ACK 5 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack4" pos="4" rst="0">
          <comment>state of ACK 4 generate requests of moving data
0: ACK 4 does not generate requests of moving data
1: ACK 4 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack3" pos="3" rst="0">
          <comment>state of ACK 3 generate requests of moving data
0: ACK 3 does not generate requests of moving data
1: ACK 3 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack2" pos="2" rst="0">
          <comment>state of ACK 2 generate requests of moving data
0: ACK 2 does not generate requests of moving data
1: ACK 2 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack1" pos="1" rst="0">
          <comment>state of ACK 1 generate requests of moving data
0: ACK 1 does not generate requests of moving data
1: ACK 1 generate requests of moving data</comment>
        </bits>
        <bits access="r" name="ack0" pos="0" rst="0">
          <comment>state of ACK 0 generate requests of moving data
0: ACK 0 does not generate requests of moving data
1: ACK 0 generate requests of moving data</comment>
        </bits>
      </reg>
      <hole size="64"/>
      <reg name="axidma_ch_irq_distr" protect="rw">
        <bits access="rw" name="ch11_irq_en0" pos="11" rst="0">
          <comment>channel 11 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch10_irq_en0" pos="10" rst="0">
          <comment>channel 10 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch9_irq_en0" pos="9" rst="0">
          <comment>channel 9 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch8_irq_en0" pos="8" rst="0">
          <comment>channel 8 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch7_irq_en0" pos="7" rst="0">
          <comment>channel 7 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch6_irq_en0" pos="6" rst="0">
          <comment>channel 6 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch5_irq_en0" pos="5" rst="0">
          <comment>channel 5 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch4_irq_en0" pos="4" rst="0">
          <comment>channel 4 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch3_irq_en0" pos="3" rst="0">
          <comment>channel 3 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch2_irq_en0" pos="2" rst="0">
          <comment>channel 2 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch1_irq_en0" pos="1" rst="0">
          <comment>channel 1 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
        <bits access="rw" name="ch0_irq_en0" pos="0" rst="0">
          <comment>channel 0 interrupt allocation bit
0: the interrupt of the channel is output to the dma_irq interruption
1: the interrupt of the channel is output to the dma_irq1 interruption</comment>
        </bits>
      </reg>
      <hole size="224"/>
      <reg name="axidma_c0_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="0">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="0">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c0_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c0_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c0_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c0_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c1_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="1">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="1">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c1_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c1_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c1_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c1_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c2_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="2">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="2">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c2_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c2_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c2_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c2_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c3_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="3">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="3">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c3_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c3_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c3_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c3_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c4_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="4">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="4">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c4_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c4_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c4_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c4_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c5_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="5">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="5">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c5_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c5_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c5_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c5_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c6_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="6">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="6">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c6_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c6_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c6_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c6_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c7_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="7">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="7">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c7_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c7_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c7_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c7_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c8_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="8">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="8">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c8_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c8_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c8_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c8_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c9_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="9">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="9">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c9_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c9_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c9_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c9_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c10_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="10">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="10">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c10_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c10_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c10_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c10_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
      <hole size="160"/>
      <reg name="axidma_c11_conf" protect="rw">
        <bits access="rw" name="err_int_en" pos="15" rst="0">
          <comment>response error interrupt enable
0:disable
1:enable</comment>
        </bits>
        <bits access="rw" name="security_en" pos="14" rst="1">
          <comment>security visit
0:security
1:unsecurity</comment>
        </bits>
        <bits access="rw" name="daddr_turnaround" pos="13" rst="0">
          <comment>after moving a COUNTP,the DADDR is automatically returned to the original destination addr
0: the destination addr does not automatically ring back
1: the destination addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="saddr_turnaround" pos="12" rst="0">
          <comment>after moving a COUNTP,the SADDR is automatically returned to initial source addr
0: the source addr does not automatically ring back
1: the source addr automatically ring back</comment>
        </bits>
        <bits access="rw" name="count_sel" pos="10" rst="0">
          <comment>the length of moving data in one interrupt in interrupted mode
0:  move a countp
1: move all count</comment>
        </bits>
        <bits access="rw" name="force_trans" pos="8" rst="0">
          <comment>mandatory transmission control bit
0: a transmission is not mandatory in interrupted mode. Or after seting, automatically cleared.
1: force a transmission without interruption in interrupted mode.</comment>
        </bits>
        <bits access="rw" name="daddr_fix" pos="7" rst="0">
          <comment>fixed destination addr control bit
0: destination addr can be incremented by different data types during transmission
1: the destination addr is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="saddr_fix" pos="6" rst="0">
          <comment>fixed source addr control bit
0: source addr can be incremented by different data types during transmission
1: the source add is fixed during transmission</comment>
        </bits>
        <bits access="rw" name="irq_t" pos="5" rst="0">
          <comment>control bit of each transmission interruption
0: each transmission does not produce an interrupt signal
1: each transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="irq_f" pos="4" rst="1">
          <comment>control bit of whole transmission interruption
0: whole transmission does not produce an interrupt signal
1: whole transmission prodece an interrupt signal</comment>
        </bits>
        <bits access="rw" name="syn_irq" pos="3" rst="0">
          <comment>control bit of synchronous interrupt trigger mode
0: this channel is in normal transmission mode
1: this channel is in sync interrupt trigger mode</comment>
        </bits>
        <bits access="rw" name="data_type" pos="2:1" rst="0">
          <comment>data types
00: Byte (8 bits)
01: Half Word (16 bits)
10: Word (32 bits)
11: DWord (64 bits)</comment>
        </bits>
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>start control bit
0: stop the transmission of this channel
1: start the transmission of this channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_map" protect="rw">
        <bits access="rw" name="ack_map" pos="12:8" rst="11">
          <comment>this channel corresponds to the ACK signal that is triggered
00000: ACK0
00001: ACK1
00010: ACK2
......
10111: ACK23</comment>
        </bits>
        <bits access="rw" name="req_source" pos="4:0" rst="11">
          <comment>the source of interrupt trigger for this channel
00000: IRQ0 trigger transmission
00001: IRQ1 trigger transmission
00010: IRQ2 trigger transmission
......
01111: IRQ15 trigger transmission
......
10111: IRQ23trigger transmission</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_saddr" protect="rw">
        <comment>the source addr of this channel</comment>
      </reg>
      <reg name="axidma_c11_daddr" protect="rw">
        <comment>the destination addr of this channel</comment>
      </reg>
      <reg name="axidma_c11_count" protect="rw">
        <bits access="rw" name="count" pos="23:0" rst="0">
          <comment>The total length of the transmitted data is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_countp" protect="rw">
        <bits access="rw" name="countp" pos="15:0" rst="0">
          <comment>the data length per transmission is measured in byte</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_status" protect="rw">
        <bits access="rc" name="resp_err_int" pos="26" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error interrupt flag
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="resp_err" pos="25" rst="0">
          <comment>bit type is changed from w1c to rc.
          response error status
0:unset
1:set</comment>
        </bits>
        <bits access="rc" name="sg_suspend_sta" pos="24" rst="0">
          <comment>bit type is changed from w1c to rc.
          data linked list is paused
0: not paused
1:  paused</comment>
        </bits>
        <bits access="rc" name="sg_finish_sta" pos="23" rst="0">
          <comment>bit type is changed from w1c to rc.
          the linked list is completed
0: not completed
1: completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_sta" pos="22" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_sta" pos="21" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNT transmission completion indication
0: COUNT is not completed
1: COUNT is completed</comment>
        </bits>
        <bits access="rc" name="sg_suspend_int" pos="20" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather pause</comment>
        </bits>
        <bits access="rc" name="sg_count" pos="19:4" rst="0">
          <comment>bit type is changed from w1c to rc.
          the number of scatter-gather transfers completed
0x0000: 0
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rc" name="sg_finish_int" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather transmission completion
0: scatter-gather is not completed
1: scatter-gather is completed</comment>
        </bits>
        <bits access="rc" name="countp_finish_int" pos="2" rst="0">
          <comment>bit type is changed from w1c to rc.
          COUNTP transmission completion indication
0: COUNTP is not completed
1: COUNTP is completed</comment>
        </bits>
        <bits access="rc" name="count_finish_int" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.
          the whole transmission completion indication
0: the whole transmission is not completed
1: the whole transmission is completed</comment>
        </bits>
        <bits access="rc" name="run" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          the channel runs state
0: IDLE
1: TRANS</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_sgaddr" protect="rw">
        <comment>first addr of the structural body</comment>
      </reg>
      <reg name="axidma_c11_sgconf" protect="rw">
        <bits access="rw" name="sg_num" pos="19:4" rst="0">
          <comment>scatter-gather transmission frequency
0x0: unlimited limit
......
0xFFFF: 65535 times</comment>
        </bits>
        <bits access="rw" name="desc_rd_ctrl" pos="3" rst="0">
          <comment>linked table read control
0: after the data is moved,the linked list isread and no descriptor_req are required
1: descriptor_req is needed to read the linked list</comment>
        </bits>
        <bits access="rw" name="sg_suspend_ie" pos="2" rst="0">
          <comment>scatter-gather pause interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rw" name="sg_finish_ie" pos="1" rst="0">
          <comment>scatter-gather complete interrupt enable
0: disable
1: enable</comment>
        </bits>
        <bits access="rc" name="sg_en" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.
          scatter-gather function enable
0: disable
1: enable</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_set" protect="rw">
        <bits access="rw" name="run_set" pos="0" rst="0">
          <comment>channel runs position
0: the running bit of the channel does not change
1: set the running bit of the channel</comment>
        </bits>
      </reg>
      <reg name="axidma_c11_clr" protect="rw">
        <bits access="rw" name="run_clr" pos="0" rst="0">
          <comment>clear the running bit of channel
0: the running bit of the channel does not change
1: clear the running bit of the channel</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x020c0000" name="AP_AXIDMA" type="ARM_AXIDMA"/>
    <instance address="0x12040000" name="CP_AXIDMA" type="ARM_AXIDMA"/>
  </archive>
  <archive relative="aud_2ad.xml">
    <module category="Periph" name="AUD_2AD">
      <reg name="aud_top_ctl" protect="rw">
        <bits access="rw" name="adc1_sinc_in_sel" pos="15:14" rst="0">
      </bits>
        <bits access="rw" name="adc1_iis_sel" pos="13:12" rst="0">
      </bits>
        <bits access="rw" name="adc1_en_r" pos="11" rst="0">
      </bits>
        <bits access="rw" name="adc1_en_l" pos="10" rst="0">
      </bits>
        <bits access="rw" name="adc_sinc_in_sel" pos="9:8" rst="0">
          <comment>[9:8]=='b00: select adc input data  ;
                   [9:8]=='b01: select dac output loop data ;
                   [9:8]=='b1x: force to zero ;</comment>
        </bits>
        <bits access="rw" name="adc_iis_sel" pos="7:6" rst="0">
          <comment>[6]==0: fm input to aif1; [6]=1: audio codec input to aif1;
                   [7]==0: fm input to aif2; [7]=1: audio codec input to aif2;</comment>
        </bits>
        <bits access="rw" name="dac_iis_sel" pos="5:4" rst="0">
          <comment>[5:4]=='bx1: aif1 output to audio codec ;
                   [5:4]=='b10: aif2 output to audio codec ;
                   [5:4]=='b00: zero output to audio codec ;</comment>
        </bits>
        <bits access="rw" name="adc_en_r" pos="3" rst="0">
          <comment>==1: enable adc left channel;</comment>
        </bits>
        <bits access="rw" name="dac_en_r" pos="2" rst="0">
          <comment>==1: enable dac right channel;</comment>
        </bits>
        <bits access="rw" name="adc_en_l" pos="1" rst="0">
          <comment>==1: enable adc left channel;</comment>
        </bits>
        <bits access="rw" name="dac_en_l" pos="0" rst="0">
          <comment>==1: enable adc right channel;</comment>
        </bits>
      </reg>
      <reg name="aud_clr" protect="rw">
        <bits access="w" name="adc_clr" pos="2" rst="0">
      </bits>
        <bits access="w" name="dac_clr" pos="1" rst="0">
      </bits>
        <bits access="w" name="adc1_clr" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="aud_iis_ctl" protect="rw">
        <bits access="rw" name="adc_iis_ckgate_en" pos="15" rst="0">
      </bits>
        <bits access="rw" name="dac_iis_ckgate_en" pos="14" rst="0">
      </bits>
        <bits access="rw" name="adc_bclk_pol" pos="13" rst="0">
      </bits>
        <bits access="rw" name="dac_bclk_pol" pos="12" rst="0">
      </bits>
        <bits access="rw" name="dac_sample_phase_sel" pos="11" rst="0">
      </bits>
        <bits access="rw" name="adc_iowl" pos="10:9" rst="3">
      </bits>
        <bits access="rw" name="dac_iowl" pos="8:7" rst="3">
      </bits>
        <bits access="rw" name="adc_io_mode" pos="6:5" rst="0">
      </bits>
        <bits access="rw" name="dac_io_mode" pos="4:3" rst="0">
      </bits>
        <bits access="rw" name="adc_lr_sel" pos="2" rst="0">
      </bits>
        <bits access="rw" name="dac_lr_sel" pos="1" rst="0">
      </bits>
        <bits access="rw" name="iis_clkdiv_mode" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="dac_src_ctl" protect="rw">
        <bits access="rw" name="dac_mute_en" pos="15" rst="1">
          <comment>==1: enable mute;</comment>
        </bits>
        <bits access="rw" name="dac_mute_ctl" pos="14" rst="0">
          <comment>==1: enable soft mute;</comment>
        </bits>
        <bits access="rw" name="dac_mute_div_ctl1" pos="13:10" rst="0">
          <comment>dac mute counter1 threshold, step is countrolled by counter 0;</comment>
        </bits>
        <bits access="rw" name="dac_mute_div_ctl0" pos="9:4" rst="63">
          <comment>dac mute counter0 threshold</comment>
        </bits>
        <bits access="rw" name="dac_fs_mode" pos="3:0" rst="4">
          <comment>dac fs frequency
            0:96K
            1:48K
            2:44.1K
            3:32K
            4:24K
            5:22.05K
            6:16K
            7:12K
            8:11.025K
            9:9.6K
            10:8K</comment>
        </bits>
      </reg>
      <reg name="dac_sdm_ctl0" protect="rw">
        <bits access="rw" name="dac_sdm_dolvl" pos="11:8" rst="1">
      </bits>
        <bits access="rw" name="dac_sdm_dilvl" pos="7:4" rst="0">
      </bits>
        <bits access="rw" name="dac_sdm_do" pos="3:2" rst="0">
      </bits>
        <bits access="rw" name="dac_sdm_di" pos="1:0" rst="0">
      </bits>
      </reg>
      <reg name="dac_sdm_ctl1" protect="rw">
        <bits access="rw" name="dac_sdm_soft_rst_r" pos="9" rst="0">
      </bits>
        <bits access="rw" name="dac_sdm_soft_rst_l" pos="8" rst="0">
      </bits>
        <bits access="rw" name="dac_sdm_test" pos="7:0" rst="8">
      </bits>
      </reg>
      <reg name="adc_src_ctl" protect="rw">
        <bits access="rw" name="adc1_src_n" pos="7:4" rst="0">
      </bits>
        <bits access="rw" name="adc_src_n" pos="3:0" rst="0">
          <comment>adc src upsample tap, sample rate=N*4K</comment>
        </bits>
      </reg>
      <reg name="aud_loop_test" protect="rw">
        <bits access="rw" name="loop_adc_path_sel" pos="9" rst="0">
      </bits>
        <bits access="rw" name="loop_fifo_ae_lvl" pos="8:6" rst="4">
      </bits>
        <bits access="rw" name="loop_fifo_af_lvl" pos="5:3" rst="4">
      </bits>
        <bits access="rw" name="loop_path_sel" pos="2:1" rst="0">
      </bits>
        <bits access="rw" name="aud_loop_test" pos="0" rst="0">
          <comment>==1: enable audio adc parallel data loop to dac parallel data path;</comment>
        </bits>
      </reg>
      <reg name="aud_sts0" protect="r">
        <bits access="r" name="aud_int_mask" pos="5:4" rst="0">
      </bits>
        <bits access="r" name="aud_int_raw" pos="3:2" rst="0">
      </bits>
        <bits access="r" name="st_mute" pos="1:0" rst="0">
      </bits>
      </reg>
      <reg name="aud_int_clr" protect="rw">
        <bits access="rw" name="aud_int_clr" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="aud_int_en" protect="rw">
        <bits access="rw" name="aud_int_en" pos="1:0" rst="0">
      </bits>
      </reg>
      <reg name="audif_fifo_ctl" protect="rw">
        <bits access="rw" name="adc_fifo_af_lvl" pos="2:0" rst="3">
      </bits>
      </reg>
      <reg name="aud_dmic_ctl" protect="rw">
        <bits access="rw" name="adc1_dmic_en" pos="7" rst="0">
      </bits>
        <bits access="rw" name="clk_aud_26m_sel" pos="6" rst="0">
          <comment>==0: force to 0 to select 26m audio clock;</comment>
        </bits>
        <bits access="rw" name="adc1_dmic_lr_sel" pos="5" rst="0">
      </bits>
        <bits access="rw" name="adc1_dmic_clk_mode" pos="4:3" rst="0">
      </bits>
        <bits access="rw" name="clk_aud_26m_inv" pos="2" rst="0">
          <comment>==1: invert output mclk ;</comment>
        </bits>
        <bits access="rw" name="adc_dmic_clk_mode" pos="1:0" rst="0">
      </bits>
      </reg>
      <reg name="adc1_iis_ctl" protect="rw">
        <bits access="rw" name="adc1_iis_ckgate_en" pos="6" rst="0">
      </bits>
        <bits access="rw" name="adc1_bclk_pol" pos="5" rst="0">
      </bits>
        <bits access="rw" name="adc1_iowl" pos="4:3" rst="3">
      </bits>
        <bits access="rw" name="adc1_io_mode" pos="2:1" rst="0">
      </bits>
        <bits access="rw" name="adc1_lr_sel" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="dac_sdm_dc_l" protect="rw">
        <bits access="rw" name="dac_sdm_dc_l" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="dac_sdm_dc_h" protect="rw">
        <bits access="rw" name="dac_sdm_dc_h" pos="7:0" rst="0">
      </bits>
      </reg>
      <reg name="audif_ctl0" protect="rw">
        <bits access="rw" name="audif_5p_mode" pos="6" rst="0">
      </bits>
        <bits access="rw" name="ad_sync_sel" pos="5:3" rst="0">
      </bits>
        <bits access="rw" name="adc_fifo_af_lvl_r" pos="2:0" rst="1">
      </bits>
      </reg>
      <reg name="audif_adc_fifo_sts" protect="r">
        <bits access="r" name="audif_adc_fifo_af_r" pos="10" rst="0">
      </bits>
        <bits access="r" name="audif_adc_fifo_empty_r" pos="9" rst="0">
      </bits>
        <bits access="r" name="audif_adc_fifo_full_r" pos="8" rst="0">
      </bits>
        <bits access="r" name="audif_adc_fifo_raddr_r" pos="7:4" rst="0">
      </bits>
        <bits access="r" name="audif_adc_fifo_waddr_r" pos="3:0" rst="0">
      </bits>
      </reg>
      <reg name="audif_dac_fifo_sts" protect="r">
        <bits access="r" name="audif_dac_fifo_empty" pos="9" rst="0">
      </bits>
        <bits access="r" name="audif_dac_fifo_full" pos="8" rst="0">
      </bits>
        <bits access="r" name="audif_dac_fifo_addr_r" pos="7:4" rst="0">
      </bits>
        <bits access="r" name="audif_dac_fifo_addr_w" pos="3:0" rst="0">
      </bits>
      </reg>
      <reg name="audif_sts" protect="r">
        <bits access="r" name="audif_adc_rx_data_ready" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="audif_sts_raw" protect="r">
        <bits access="r" name="audif_adc_fifo_underfl_raw" pos="1" rst="0">
      </bits>
        <bits access="r" name="audif_dac_fifo_ovfl_raw" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="audif_sts_clr" protect="rw">
        <bits access="rw" name="ovfl_sts_clr" pos="1" rst="0">
      </bits>
        <bits access="rw" name="underfl_sts_clr" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="dac_src_step" protect="rw">
        <bits access="rw" name="dac_src_step" pos="11:0" rst="0">
      </bits>
      </reg>
      <reg name="adc_dgain" protect="rw">
        <bits access="rw" name="adc_l_dgain" pos="3:0" rst="0">
          <comment>left adc channel dgain
            4'hf: 16dB
            4'he: 14dB
            4'hd: 12dB
            4'hc: 10dB
            4'hb:  8dB
            4'ha:  6dB
            4'h9:  4dB
            4'h8:  2dB
            4'h7:  0dB
            4'h6:-2dB
            4'h5:-4dB
            4'h4:-6dB
            4'h3:-8dB
            4'h2:-10dB
            4'h1:-12dB
            4'h0:mute</comment>
        </bits>
        <bits access="rw" name="adc_r_dgain" pos="7:4" rst="0">
          <comment>right adc channel dgain
            4'hf: 16dB
            4'he: 14dB
            4'hd: 12dB
            4'hc: 10dB
            4'hb:  8dB
            4'ha:  6dB
            4'h9:  4dB
            4'h8:  2dB
            4'h7:  0dB
            4'h6:-2dB
            4'h5:-4dB
            4'h4:-6dB
            4'h3:-8dB
            4'h2:-10dB
            4'h1:-12dB
            4'h0:mute</comment>
        </bits>
        <bits access="rw" name="adc_dgain_update" pos="8" rst="0">
      </bits>
      </reg>
      <reg name="dac_dgain0" protect="rw">
        <bits access="rw" name="dac_dgain_tone_sel" pos="0" rst="0">
          <comment>right adc channel dgain
            1:sel tone dac tone dgain
            0:sel normal dac dgain</comment>
        </bits>
        <bits access="rw" name="dac_dgain_update" pos="1" rst="0">
      </bits>
      </reg>
      <reg name="dac_dgain1" protect="rw">
        <bits access="rw" name="dac_l_nor_dgain" pos="7:0" rst="0x34">
          <comment>left dac channel dgain
            [5:1] =
            5'h1f:  05dB
            5'h1e:  04dB
            5'h1d:  03dB
            5'h1c:  02dB
            5'h1b:  01dB
            5'h1a:  00dB
            5'h19: -01dB
            5'h18: -02dB
            5'h17: -03dB
            5'h16: -04dB
            5'h15: -05dB
            5'h14: -06dB
            5'h13: -07dB
            5'h12: -08dB
            5'h11: -09dB
            5'h10: -10dB
            5'h0f: -11dB
            5'h0e: -12dB
            5'h0d: -13dB
            5'h0c: -14dB
            5'h0b: -15dB
            5'h0a: -16dB
            5'h09: -17dB
            5'h08: -18dB
            5'h07: -19dB
            5'h06: -20dB
            5'h05: -21dB
            5'h04: -22dB
            5'h03: -23dB
            5'h02: -24dB
            5'h01: -25dB
            5'h00: -26dB
            [0]:1'b1,+0.5dB
            [7]:1'b1,+12dB
            [6]:1'b1,+6dB</comment>
        </bits>
        <bits access="rw" name="dac_r_nor_dgain" pos="15:8" rst="0x34">
          <comment>right dac channel dgain
            detail see  dac_l_nor_dgain[7:0]</comment>
        </bits>
      </reg>
      <reg name="dac_dgain2" protect="rw">
        <bits access="rw" name="dac_l_tone_dgain" pos="7:0" rst="0x34">
          <comment>left dac channel dgain
            detail see  dac_l_nor_dgain[7:0]</comment>
        </bits>
        <bits access="rw" name="dac_r_tone_dgain" pos="15:8" rst="0x34">
          <comment>right dac channel dgain
            detail see  dac_l_nor_dgain[7:0]</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x5150a000" name="AUD_2AD" type="AUD_2AD"/>
  </archive>
  <archive relative="camera.xml">
    <var name="FIFORAM_SIZE" value="80"/>
    <module category="Periph" name="CAMERA">
      <reg name="ctrl" protect="rw">
        <bits access="rw" name="enable" pos="0" rst="0">
          <options>
            <default/>
            <option name="ENABLE" value="1"/>
            <option name="DISABLE" value="0"/>
          </options>
          <comment>Enable camera controller,high active.</comment>
        </bits>
        <bits access="rw" name="dctenable" pos="1" rst="0">
          <comment>Enable camera controller,high active.</comment>
        </bits>
        <bits access="rw" name="buf_enable" pos="2" rst="0">
    </bits>
        <bits access="rw" name="rgb_rfirst" pos="3" rst="0">
    </bits>
        <bits access="rw" name="dataformat" pos="5:4" rst="0">
          <options>
            <default/>
            <option name="RGB565" value="0"/>
            <option name="YUV422" value="1"/>
            <option name="JPEG" value="2"/>
            <option name="RESERVE" value="3"/>
          </options>
          <comment>
            &quot;0&quot; = RGB565.
            <br/>
             &quot;1&quot; = YUV422.
            <br/>
             &quot;2&quot; = Compressed Data.
            <br/>
             &quot;3&quot; = Reserved.
          </comment>
        </bits>
        <bits access="rw" name="cfg_cam_c2cse" pos="7:6" rst="0">
    </bits>
        <bits access="rw" name="reset_pol" pos="8" rst="1">
          <options>
            <default/>
            <option name="INVERT" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = keep output camera reset polarity.
            <br/>
             '1' = invert output camera reset polarity.
          </comment>
        </bits>
        <bits access="rw" name="pwdn_pol" pos="9" rst="0">
          <options>
            <default/>
            <option name="INVERT" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = keep output camera power down polarity.
            <br/>
             '1' = invert output camera power down polarity.
          </comment>
        </bits>
        <bits access="rw" name="vsync_pol" pos="10" rst="0">
          <options>
            <default/>
            <option name="INVERT" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = keep input VSYNC polarity.
            <br/>
             '1' = invert input VSYNC polarity.
          </comment>
        </bits>
        <bits access="rw" name="href_pol" pos="11" rst="0">
          <options>
            <default/>
            <option name="INVERT" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = keep input HREF polarity so data is sampled when HREF high.
            <br/>
             '1' = invert input HREF polarity so data is sampled when HREF low.
          </comment>
        </bits>
        <bits access="rw" name="pixclk_pol" pos="12" rst="0">
          <options>
            <default/>
            <option name="INVERT" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = keep pix clk polarity.
            <br/>
             '1' = invert pix clk polarity.
          </comment>
        </bits>
        <bits access="rw" name="vsync_drop" pos="14" rst="1">
          <options>
            <default/>
            <option name="DROP" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>
            '0' = VSYNC irq always exists when Frame decimation is enabled.
            <br/>
             '1' = VSYNC irq will drop when Frame data are dropped in decipation.
          </comment>
        </bits>
        <bits access="rw" name="decimfrm" pos="17:16" rst="0">
          <options>
            <default/>
            <option name="ORIGINAL" value="0"/>
            <option name="DIV_2" value="1"/>
            <option name="DIV_3" value="2"/>
            <option name="DIV_4" value="3"/>
          </options>
          <comment>
            &quot;0&quot;= All frame data will be sent.
            <br/>
             &quot;1&quot;= only one frame out of two (1/2) will be sent.
            <br/>
             &quot;2&quot;= only one frame out of three (1/3) will be sent.
            <br/>
             &quot;3&quot;= only one frame out of four (1/4) will be sent.
          </comment>
        </bits>
        <bits access="rw" name="decimcol" pos="19:18" rst="0">
          <options>
            <default/>
            <option name="ORIGINAL" value="0"/>
            <option name="DIV_2" value="1"/>
            <option name="DIV_3" value="2"/>
            <option name="DIV_4" value="3"/>
          </options>
          <comment>
            &quot;0&quot;= Pixel Decimation Disabled.
            <br/>
             &quot;1&quot;= Pixel Decimation 1/2.
            <br/>
             &quot;2&quot;= Pixel Decimation 1/3.
            <br/>
             &quot;3&quot;= Pixel Decimation 1/4.
          </comment>
        </bits>
        <bits access="rw" name="decimrow" pos="21:20" rst="0">
          <options>
            <default/>
            <option name="ORIGINAL" value="0"/>
            <option name="DIV_2" value="1"/>
            <option name="DIV_3" value="2"/>
            <option name="DIV_4" value="3"/>
          </options>
          <comment>
            &quot;0&quot;= line Decimation Disabled.
            <br/>
             &quot;1&quot;= line Decimation 1/2.
            <br/>
             &quot;2&quot;= line Decimation 1/3.
            <br/>
             &quot;3&quot;= line Decimation 1/4.
          </comment>
        </bits>
        <bits access="rw" name="reorder" pos="26:24" rst="0">
          <comment>
            Controls the Re-ordering of the FIFO data.
            <br/>
             In following table, for input data, right comes before left. So YUYV means V comes first.
            <br/>
             for output data, right data is the LSB. So YUYV means V is stored in low 8-bit (byte0) of 32-bit word.
            <br/>
            <br/>
             If Bit 26 is '1', byte2 and byte0 is Y.
            <br/>
             If Bit 25 is '1', both byte2/byte3 and byte1/byte0 interchange.
            <br/>
             If Bit 24 is '1', byte U and V should interchange. (UV bytes can be decided using bit 26).
            <br/>
            <br/>
             input YUYV, output YUYV: &quot;000&quot;
            <br/>
             input YVYU, output YUYV: &quot;001&quot;
            <br/>
             input UYVY, output YUYV: &quot;110&quot;
            <br/>
             input VYUY, output YUYV: &quot;111&quot;
            <br/>
            <br/>
             input YUYV, output UYVY: &quot;010&quot;
            <br/>
             input YVYU, output UYVY: &quot;011&quot;
            <br/>
             input UYVY, output UYVY: &quot;100&quot;
            <br/>
             input VYUY, output UYVY: &quot;101&quot;
            <br/>
            <br/>
             input YUYV, output YVYU: &quot;001&quot;
            <br/>
             input YVYU, output YVYU: &quot;000&quot;
            <br/>
             input UYVY, output YVYU: &quot;111&quot;
            <br/>
             input VYUY, output YVYU: &quot;110&quot;
            <br/>
            <br/>
             input YUYV, output VYUY: &quot;011&quot;
            <br/>
             input YVYU, output VYUY: &quot;010&quot;
            <br/>
             input UYVY, output VYUY: &quot;101&quot;
            <br/>
             input VYUY, output VYUY: &quot;100&quot;
            <br/>
            <br/>
             Decimation will reorder data flow also. Input UYVY becomes YUVY after decimation.
                      This reorder is corrected using Bit 26 infomation.
          </comment>
        </bits>
        <bits access="rw" name="cropen" pos="28" rst="0">
          <options>
            <default/>
            <option name="ENABLE" value="1"/>
            <option name="DISABLE" value="0"/>
          </options>
          <comment>
            &quot;0&quot;= Cropping Disabled.
            <br/>
             &quot;1&quot;= Cropping Enabled.
            <br/>
             Note: this bit should set to '0' when bit field &quot;DataFormat&quot; is &quot;10&quot; (compressed data)
          </comment>
        </bits>
        <bits access="rw" name="bist mode" pos="30" rst="0">
          <options>
            <default/>
            <option name="BIST" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>In Bist Mode, FIFO RAM are read and write by its address, FIFO mode is disabled.</comment>
        </bits>
        <bits access="rw" name="test" pos="31" rst="0">
          <options>
            <default/>
            <option name="TEST" value="1"/>
            <option name="NORMAL" value="0"/>
          </options>
          <comment>Debug only. A RGB565 test card is sent to system bus instead of real data from sensor.</comment>
        </bits>
      </reg>
      <reg name="status" protect="r">
        <bits access="r" name="ovfl" pos="0" rst="0">
          <comment>
            '1' = FIFO over-write IRQ status.
            <br/>
             Write to corresponding bit in IRQ CLEAR register will clear this bit.
          </comment>
        </bits>
        <bits access="r" name="vsync_r" pos="1" rst="0">
          <comment>
            '1' = VSYNC rising edge IRQ status
            <br/>
             Write to corresponding bit in IRQ CLEAR register will clear this bit.
          </comment>
        </bits>
        <bits access="r" name="vsync_f" pos="2" rst="0">
          <comment>
            '1' = VSYNC falling edge IRQ status
            <br/>
             Write to corresponding bit in IRQ CLEAR register will clear this bit.
          </comment>
        </bits>
        <bits access="r" name="dma done" pos="3" rst="0">
          <comment>
            '1' = DMA Done IRQ status
            <br/>
             Write to corresponding bit in IRQ CLEAR register will clear this bit.
          </comment>
        </bits>
        <bits access="r" name="fifo empty" pos="4" rst="1">
          <comment>'1' = FIFO Empty status, not clear-able.</comment>
        </bits>
        <bits access="r" name="spi ovfl" pos="5" rst="0">
        </bits>
      </reg>
      <reg name="data" protect="r">
        <comment>Read in the receive FIFO</comment>
      </reg>
      <reg name="irq mask" protect="rw">
        <bits access="rw" name="ovfl" pos="0" rst="0">
          <comment>'1' = FIFO over-write enable</comment>
        </bits>
        <bits access="rw" name="vsync_r" pos="1" rst="0">
          <comment>'1' = VSYNC rising edge enable</comment>
        </bits>
        <bits access="rw" name="vsync_f" pos="2" rst="0">
          <comment>'1' = VSYNC falling edge enable</comment>
        </bits>
        <bits access="rw" name="dma done" pos="3" rst="0">
          <comment>'1' = DMA Done enable</comment>
        </bits>
      </reg>
      <reg name="irq clear" protect="w">
        <bits access="w" name="ovfl" pos="0" rst="0">
          <comment>Write '1' to clear FIFO over-write interrupt</comment>
        </bits>
        <bits access="w" name="vsync_r" pos="1" rst="0">
          <comment>Write '1' to clear VSYNC rising edge interrupt</comment>
        </bits>
        <bits access="w" name="vsync_f" pos="2" rst="0">
          <comment>Write '1' to clear VSYNC falling edge interrupt</comment>
        </bits>
        <bits access="w" name="dma done" pos="3" rst="0">
          <comment>Write '1' to clear DMA Done interrupt</comment>
        </bits>
      </reg>
      <reg name="irq cause" protect="r">
        <bits access="r" name="ovfl" pos="0" rst="0">
          <comment>'1' = FIFO over-write cause</comment>
        </bits>
        <bits access="r" name="vsync_r" pos="1" rst="0">
          <comment>'1' = VSYNC rising edge cause</comment>
        </bits>
        <bits access="r" name="vsync_f" pos="2" rst="0">
          <comment>'1' = VSYNC falling edge cause</comment>
        </bits>
        <bits access="r" name="dma done" pos="3" rst="0">
          <comment>'1' = DMA Done cause</comment>
        </bits>
      </reg>
      <reg name="cmd set" protect="rw">
        <bits access="rs" name="pwdn" pos="0" rst="1">
          <comment>Power down pin of CMOS sensor .</comment>
        </bits>
        <bits access="rs" name="reset" pos="4" rst="1">
          <comment>
            Reset pin of CMOS sensor.
            <br/>
            Active Low.
          </comment>
        </bits>
        <bits access="s" name="fifo reset" pos="8" rst="0">
          <comment>For the software to clear FIFO. This bit is auto-reset to 0.</comment>
        </bits>
      </reg>
      <reg name="cmd clr" protect="rw">
        <bits access="rc" name="pwdn" pos="0" rst="1">
          <comment>Power down pin of CMOS sensor .</comment>
        </bits>
        <bits access="rc" name="reset" pos="4" rst="1">
          <comment>Reset pin of CMOS sensor.</comment>
        </bits>
      </reg>
      <reg name="dstwincol" protect="rw">
        <bits access="rw" name="dstwincolstart" pos="11:0" rst="0">
          <comment>start pixel of cropped window.</comment>
        </bits>
        <bits access="rw" name="dstwincolend" pos="27:16" rst="0">
          <comment>end pixel of cropped window.</comment>
        </bits>
      </reg>
      <reg name="dstwinrow" protect="rw">
        <bits access="rw" name="dstwinrowstart" pos="11:0" rst="0">
          <comment>start line of cropped window.</comment>
        </bits>
        <bits access="rw" name="dstwinrowend" pos="27:16" rst="0">
          <comment>end line of cropped window.</comment>
        </bits>
      </reg>
      <reg name="scl config" protect="rw">
        <bits access="rw" name="scale en" pos="0" rst="0">
        </bits>
        <bits access="rw" name="data_out_swap" pos="4" rst="0">
          <comment>swap camera data output [15:0],[31:16].</comment>
        </bits>
        <bits access="rw" name="scale col" pos="9:8" rst="0">
        </bits>
        <bits access="rw" name="scale row" pos="17:16" rst="0">
        </bits>
      </reg>
      <reg name="spi camera reg0" protect="rw">
        <bits access="rw" name="camera_spi_slave_en" pos="0" rst="0">
          <comment>spi slave enable.</comment>
        </bits>
        <bits access="rw" name="camera_spi_master_en" pos="1" rst="0">
          <comment>spi master enable.</comment>
        </bits>
        <bits access="rw" name="yuv_out_format" pos="4:2" rst="0">
          <comment>yuv out format.
			  3'b000: data_serial_mux = {Y0,U0,Y1,V0};
        3'b001: data_serial_mux = {Y0,V0,Y1,U0};
        3'b010: data_serial_mux = {U0,Y0,V0,Y1};
        3'b011: data_serial_mux = {U0,Y1,V0,Y0};
        3'b100: data_serial_mux = {V0,Y1,U0,Y0};
        3'b101: data_serial_mux = {V0,Y0,U0,Y1};
        3'b110: data_serial_mux = {Y1,V0,Y0,U0};
        3'b111: data_serial_mux = {Y1,U0,Y0,V0};</comment>
        </bits>
        <bits access="rw" name="overflow_rstn_only_vsync_low" pos="5" rst="0">
          <comment>overflow rstn only vsync low.</comment>
        </bits>
        <bits access="rw" name="overflow_observe_only_vsync_low" pos="6" rst="0">
          <comment>overflow_observe_only_vsync_low.</comment>
        </bits>
        <bits access="rw" name="overflow_rstn_en" pos="7" rst="0">
          <comment>overflow_rstn enable</comment>
        </bits>
        <bits access="rw" name="big_end_dis" pos="8" rst="0">
          <comment>big_end_dis</comment>
        </bits>
        <bits access="rw" name="overflow_inv" pos="9" rst="0">
          <comment>overflow inv control</comment>
        </bits>
        <bits access="rw" name="href_inv" pos="10" rst="0">
          <comment>href inv control</comment>
        </bits>
        <bits access="rw" name="vsync_inv" pos="11" rst="0">
          <comment>vsync inv control</comment>
        </bits>
        <bits access="rw" name="block_num_per_line" pos="21:12" rst="0">
          <comment>block_num_per_line[9:0] pixels num of a line</comment>
        </bits>
        <bits access="rw" name="line_num_per_frame" pos="31:22" rst="0">
          <comment>line_num_per_frame[9:0] lines num of a frame</comment>
        </bits>
      </reg>
      <reg name="spi camera reg1" protect="rw">
        <bits access="rw" name="camera_clk_div_num" pos="15:0" rst="0">
          <comment>camera_clk_div_num</comment>
        </bits>
        <bits access="rw" name="cts_spi_master_reg" pos="16" rst="0">
          <comment>cts_spi_master_reg</comment>
        </bits>
        <bits access="rw" name="ssn_cm_inv" pos="17" rst="0">
          <comment>ssn_cm inv control</comment>
        </bits>
        <bits access="rw" name="sck_cm_inv" pos="18" rst="0">
          <comment>sck_cm inv control</comment>
        </bits>
        <bits access="rw" name="ssn_spi_oenb_dr" pos="19" rst="0">
          <comment>ssn_spi_oen select, 1:from reg  0: from logic</comment>
        </bits>
        <bits access="rw" name="ssn_spi_oenb_reg" pos="20" rst="0">
          <comment>ssn_spi_oenb reg</comment>
        </bits>
        <bits access="rw" name="sck_spi_oenb_dr" pos="21" rst="0">
          <comment>sck_spi_oenb select, 1:from reg 0:from logic</comment>
        </bits>
        <bits access="rw" name="sck_spi_oenb_reg" pos="22" rst="0">
          <comment>sck_spi_oenb reg</comment>
        </bits>
        <bits access="rw" name="sdo_spi_swap" pos="29" rst="0">
          <comment>sdo_spi_swap reg,swap camera_spi_0 and camera_spi_1</comment>
        </bits>
        <bits access="rw" name="clk_inv" pos="30" rst="0">
          <comment>clk inv control</comment>
        </bits>
        <bits access="rw" name="sck_ddr_en" pos="31" rst="0">
          <comment>sck double edge enable</comment>
        </bits>
      </reg>
      <reg name="spi camera reg2" protect="rw">
        <bits access="rw" name="ssn_wait_length" pos="7:0" rst="0">
          <comment>ssn_wait_length[7:0]</comment>
        </bits>
        <bits access="rw" name="init_wait_length" pos="15:8" rst="0">
          <comment>init_wait_length[7:0]</comment>
        </bits>
        <bits access="rw" name="word_num_per_block" pos="23:16" rst="0">
          <comment>word_num_per_block[7:0]</comment>
        </bits>
        <bits access="rw" name="ssn_cs_delay" pos="25:24" rst="0">
          <comment>ssn_cs_delay[1:0]</comment>
        </bits>
        <bits access="rw" name="data_receive_choose_bit" pos="27:26" rst="0">
          <comment>data_receive_choose_bit[1:0]</comment>
        </bits>
        <bits access="rw" name="ready_cs_inv" pos="28" rst="0">
          <comment>ready_cs_inv</comment>
        </bits>
        <bits access="rw" name="ssn_cs_inv" pos="29" rst="0">
          <comment>ssn_cs_inv</comment>
        </bits>
        <bits access="rw" name="eco_bypass_isp" pos="31" rst="0">
          <comment>eco_bypass_isp</comment>
        </bits>
      </reg>
line_wait_length[15:0]
      <reg name="spi camera reg3" protect="rw">
        <bits access="rw" name="line_wait_length" pos="15:0" rst="0">
          <comment>line_wait_length</comment>
        </bits>
        <bits access="rw" name="block_wait_length" pos="23:16" rst="0">
          <comment>block_wait_length[7:0]</comment>
        </bits>
        <bits access="rw" name="ssn_high_length" pos="31:24" rst="0">
          <comment>ssn_high_length[7:0]</comment>
        </bits>
      </reg>
      <reg name="spi camera reg4" protect="rw">
        <bits access="rw" name="camera_spi_master_en_2" pos="0" rst="0">
          <comment>camera_spi_master no ssn mode enable</comment>
        </bits>
        <bits access="rw" name="sdo_line_choose_bit" pos="2:1" rst="0">
          <comment>sdo_line_choose_bit[1:0] 0:1 line 1: 2lines 2:4lines</comment>
        </bits>
        <bits access="rw" name="data_size_choose_bit" pos="3" rst="0">
          <comment>data_size_choose_bit  1: from reg  0:from logic</comment>
        </bits>
        <bits access="rw" name="image_height_choose_bit" pos="4" rst="0">
          <comment>image_height_choose_bit  1: from reg  0:from logic</comment>
        </bits>
        <bits access="rw" name="image_width_choose_bit" pos="5" rst="0">
          <comment>image_width_choose_bit 1: from reg  0:from logic</comment>
        </bits>
        <bits access="rw" name="block_num_per_packet" pos="15:6" rst="0">
          <comment>block_num_per_packet[9:0]</comment>
        </bits>
        <bits access="rw" name="spi_data0_phase_sel" pos="17:16" rst="0">
          <comment>0: spi data0 delay 0
			          1: spi data0 delay 2 cycles spi_cam_clk
			          2: spi data0 delay 3 cycles spi_cam_clk
			          3: spi data0 delay 4 cycles spi_cam_clk</comment>
        </bits>
        <bits access="rw" name="spi_data1_phase_sel" pos="19:18" rst="0">
          <comment>0: spi data1 delay 0
			          1: spi data1 delay 2 cycles spi_cam_clk
			          2: spi data1 delay 3 cycles spi_cam_clk
			          3: spi data1 delay 4 cycles spi_cam_clk</comment>
        </bits>
      </reg>
      <reg name="spi camera reg5" protect="rw">
        <bits access="rw" name="sync_code" pos="23:0" rst="0">
          <comment>sync code</comment>
        </bits>
      </reg>
      <reg name="spi camera reg6" protect="rw">
        <bits access="rw" name="packet_id_data_start" pos="7:0" rst="0">
          <comment>packet_id_data_start</comment>
        </bits>
        <bits access="rw" name="packet_id_line_start" pos="15:8" rst="0">
          <comment>packet_id_line_start</comment>
        </bits>
        <bits access="rw" name="packet_id_frame_end" pos="23:16" rst="0">
          <comment>packet_id_frame_end</comment>
        </bits>
        <bits access="rw" name="packet_id_frame_start" pos="31:24" rst="0">
          <comment>packet_id_frame_start</comment>
        </bits>
      </reg>
      <reg name="spi camera obs0" protect="rw">
        <bits access="ro" name="line_id[15:0]" pos="15:0" rst="0">
          <comment>line_id[15:0]</comment>
        </bits>
        <bits access="ro" name="data_id[7:0]" pos="23:16" rst="0">
          <comment>data_id[7:0]</comment>
        </bits>
        <bits access="ro" name="observe_data_size_wrong" pos="24" rst="0">
          <comment>observe_data_size_wrong</comment>
        </bits>
        <bits access="ro" name="observe_image_height_wrong" pos="25" rst="0">
          <comment>observe_image_height_wrong</comment>
        </bits>
        <bits access="ro" name="observe_image_width_wrong" pos="26" rst="0">
          <comment>observe_image_width_wrong</comment>
        </bits>
        <bits access="ro" name="observe_line_num_wrong" pos="27" rst="0">
          <comment>observe_line_num_wrong</comment>
        </bits>
        <bits access="ro" name="observe_data_id_wrong" pos="28" rst="0">
          <comment>observe_data_id_wrong</comment>
        </bits>
      </reg>
      <reg name="spi camera obs1" protect="rw">
        <bits access="ro" name="image_height" pos="15:0" rst="0">
          <comment>image_height[15:0]</comment>
        </bits>
        <bits access="ro" name="image_width" pos="31:16" rst="0">
          <comment>image_width[15:0]</comment>
        </bits>
      </reg>
      <reg name="csi config reg0" protect="rw">
        <bits access="rw" name="num_d_term_en" pos="7:0" rst="8">
          <comment>num_d_term_en[7:0]  term time reg</comment>
        </bits>
        <bits access="rw" name="cur_frame_line_num" pos="20:8" rst="240">
          <comment>cur_frame_line_num[12:0]</comment>
        </bits>
        <bits access="rw" name="data_lp_in_choose_bit" pos="22:21" rst="0">
          <comment>data_lp_in_choose_bit[1:0]</comment>
        </bits>
        <bits access="rw" name="clk_lp_inv" pos="23" rst="0">
          <comment>clk_lp inv</comment>
        </bits>
        <bits access="rw" name="trail_data_wrong_choose_bit" pos="24" rst="0">
          <comment>trail_data_wrong_choose_bit 1:secelt trail1  0:select trail0</comment>
        </bits>
        <bits access="rw" name="sync_bypass" pos="25" rst="0">
          <comment>sync_bypass</comment>
        </bits>
        <bits access="rw" name="rdata_bit_inv_en" pos="26" rst="0">
          <comment>rdata_bit_inv en</comment>
        </bits>
        <bits access="rw" name="hs_sync_find_en" pos="27" rst="0">
          <comment>hs_sync_find en</comment>
        </bits>
        <bits access="rw" name="line_packet_enable" pos="28" rst="0">
          <comment>line_packet_enable</comment>
        </bits>
        <bits access="rw" name="ecc_bypass" pos="29" rst="0">
          <comment>ecc_bypass</comment>
        </bits>
        <bits access="rw" name="data_lane_choose_bit" pos="30" rst="0">
          <comment>data_lane_choose_bit  1:select lane2  0:select lane1</comment>
        </bits>
        <bits access="rw" name="csi_module_enable" pos="31" rst="0">
          <comment>csi_module_enable</comment>
        </bits>
      </reg>
      <reg name="csi config reg1" protect="rw">
        <bits access="rw" name="num_hs_settle" pos="7:0" rst="8">
          <comment>num_hs_settle[7:0]  set hs settle time</comment>
        </bits>
        <bits access="rw" name="lp_data_length_choose_bit" pos="10:8" rst="0">
          <comment>lp_data_length_choose_bit[2:0]  set data length</comment>
        </bits>
        <bits access="rw" name="data_clk_lp_posedge_choose" pos="13:11" rst="0">
          <comment>data_clk_lp_posedge_choose[2:0]  select delay cycles</comment>
        </bits>
        <bits access="rw" name="clk_lp_ck_inv" pos="14" rst="0">
          <comment>clk_lp_ck_inv</comment>
        </bits>
        <bits access="rw" name="rclr_mask_en" pos="15" rst="1">
          <comment>rclr_mask_en</comment>
        </bits>
        <bits access="rw" name="rinc_mask_en" pos="16" rst="1">
          <comment>rinc_mask_en</comment>
        </bits>
        <bits access="rw" name="hs_enable_mask_en" pos="17" rst="1">
          <comment>hs_enable_mask_en</comment>
        </bits>
        <bits access="rw" name="den_csi_inv_bit" pos="18" rst="0">
          <comment>den_csi_inv_bit</comment>
        </bits>
        <bits access="rw" name="hsync_csi_inv_bit" pos="19" rst="0">
          <comment>hsync_csi_inv_bit</comment>
        </bits>
        <bits access="rw" name="vsync_csi_inv_bit" pos="20" rst="0">
          <comment>vsync_csi_inv_bit</comment>
        </bits>
        <bits access="rw" name="hs_data2_enable_reg" pos="21" rst="0">
          <comment>hs_data2_enable_reg</comment>
        </bits>
        <bits access="rw" name="hs_data1_enable_reg" pos="22" rst="0">
          <comment>hs_data1_enable_reg</comment>
        </bits>
        <bits access="rw" name="hs_data1_enable_choose_bit" pos="23" rst="0">
          <comment>hs_data1_enable_choose_bit</comment>
        </bits>
        <bits access="rw" name="hs_data1_enable_dr" pos="24" rst="0">
          <comment>hs_data1_enable_dr 1:select reg  0:select logic</comment>
        </bits>
        <bits access="rw" name="data2_terminal_enable_reg" pos="25" rst="0">
          <comment>data2_terminal_enable_reg</comment>
        </bits>
        <bits access="rw" name="data1_terminal_enable_reg" pos="26" rst="0">
          <comment>data1_terminal_enable_reg</comment>
        </bits>
        <bits access="rw" name="data1_terminal_enable_dr" pos="27" rst="0">
          <comment>data1_terminal_enable_dr 1:select reg  0:select logic</comment>
        </bits>
        <bits access="rw" name="lp_data_interrupt_clr" pos="28" rst="0">
          <comment>lp_data_interrupt_clr, clear flag</comment>
        </bits>
        <bits access="rw" name="lp_cmd_interrupt_clr" pos="29" rst="0">
          <comment>lp_cmd_interrupt_clr, clear flag</comment>
        </bits>
        <bits access="rw" name="lp_data_clr" pos="30" rst="0">
          <comment>lp_data_clr, clear data out</comment>
        </bits>
        <bits access="rw" name="lp_cmd_clr" pos="31" rst="0">
          <comment>lp_cmd_clr, clear cmd out</comment>
        </bits>
      </reg>
      <reg name="csi config reg2" protect="rw">
        <bits access="rw" name="num_hs_settle_clk" pos="15:0" rst="4096">
          <comment>num_hs_settle_clk[15:0], set hs settle counter</comment>
        </bits>
        <bits access="rw" name="num_c_term_en" pos="31:16" rst="4112">
          <comment>num_c_term_en[15:0],set clk term counter</comment>
        </bits>
      </reg>
      <reg name="csi config reg3" protect="rw">
        <bits access="rw" name="clk_lp_in_choose_bit" pos="7:6" rst="0">
          <comment>clk_lp_in_choose_bit</comment>
        </bits>
        <bits access="rw" name="pu_lprx_reg" pos="8" rst="0">
          <comment>pu_lprx_reg</comment>
        </bits>
        <bits access="rw" name="pu_hsrx_reg" pos="9" rst="0">
          <comment>pu_hsrx_reg</comment>
        </bits>
        <bits access="rw" name="pu_dr" pos="10" rst="0">
          <comment>pu_dr, 1:select reg  0:select logic</comment>
        </bits>
        <bits access="rw" name="data_pnsw_reg" pos="11" rst="0">
          <comment>data_pnsw_reg</comment>
        </bits>
        <bits access="rw" name="hs_clk_enable_reg" pos="12" rst="0">
          <comment>hs_clk_enable_reg</comment>
        </bits>
        <bits access="rw" name="hs_clk_enable_choose_bit" pos="13" rst="0">
          <comment>hs_clk_enable_choose_bit</comment>
        </bits>
        <bits access="rw" name="hs_clk_enable_dr" pos="14" rst="0">
          <comment>hs_clk_enable_dr  1:select reg  0:select logic</comment>
        </bits>
        <bits access="rw" name="clk_terminal_enable_reg" pos="15" rst="0">
          <comment>clk_terminal_enable_reg</comment>
        </bits>
        <bits access="rw" name="clk_terminal_enable_dr" pos="16" rst="0">
          <comment>clk_terminal_enable_dr   1:select reg  0:select logic</comment>
        </bits>
        <bits access="rw" name="observe_reg_5_low8_choose" pos="17" rst="0">
          <comment>observe_reg_5_low8_choose</comment>
        </bits>
        <bits access="rw" name="ecc_error_flag_reg" pos="18" rst="0">
          <comment>ecc_error_flag_reg</comment>
        </bits>
        <bits access="rw" name="ecc_error_dr" pos="19" rst="0">
          <comment>ecc_error_dr</comment>
        </bits>
        <bits access="rw" name="csi_channel_sel" pos="20" rst="0">
          <comment>csi_channel_sel</comment>
        </bits>
        <bits access="rw" name="two_lane_bit_reverse" pos="21" rst="0">
          <comment>two_lane_bit_reverse, reverse high and low 8bit</comment>
        </bits>
        <bits access="rw" name="data2_lane_bit_reverse" pos="22" rst="0">
          <comment>data2_lane_bit_reverse 1:select revert data</comment>
        </bits>
        <bits access="rw" name="data1_lane_bit_reverse" pos="23" rst="0">
          <comment>data1_lane_bit_reverse 1:select revert data</comment>
        </bits>
        <bits access="rw" name="data2_hs_no_mask" pos="24" rst="0">
          <comment>data2_hs_no_mask  1:data only valid when sync assert</comment>
        </bits>
        <bits access="rw" name="data1_hs_no_mask" pos="25" rst="0">
          <comment>data1_hs_no_mask  1:data only valid when sync assert</comment>
        </bits>
        <bits access="rw" name="pu_lprx_d2_reg" pos="26" rst="0">
          <comment>pu_lprx_d2_reg</comment>
        </bits>
        <bits access="rw" name="pu_lprx_d1_reg" pos="27" rst="0">
          <comment>pu_lprx_d1_reg</comment>
        </bits>
        <bits access="rw" name="clk_edge_sel" pos="29" rst="0">
          <comment>clk_edge_sel</comment>
        </bits>
        <bits access="rw" name="clk_x2_sel" pos="30" rst="0">
          <comment>clk_x2_sel</comment>
        </bits>
        <bits access="rw" name="single_data_lane_en" pos="31" rst="0">
          <comment>single_data_lane_en  1:1lane  0:2lanes</comment>
        </bits>
      </reg>
      <reg name="csi config reg4" protect="rw">
        <bits access="rw" name="num_hs_clk_useful" pos="30:0" rst="0">
          <comment>num_hs_clk_useful[30:0]   hs clk useful counter</comment>
        </bits>
        <bits access="rw" name="num_hs_clk_useful_en" pos="31" rst="0">
          <comment>num_hs_clk_useful_en</comment>
        </bits>
      </reg>
      <reg name="csi config reg5" protect="rw">
        <bits access="rw" name="vc_id_set" pos="1:0" rst="0">
          <comment>vc_id_set[1:0]</comment>
        </bits>
        <bits access="rw" name="data_lp_inv" pos="2" rst="0">
          <comment>data_lp_inv</comment>
        </bits>
        <bits access="rw" name="fifo_rclr_8809p_reg" pos="3" rst="0">
          <comment>fifo_rclr_8809p_reg</comment>
        </bits>
        <bits access="rw" name="fifo_wclr_8809p_reg" pos="4" rst="0">
          <comment>fifo_wclr_8809p_reg</comment>
        </bits>
        <bits access="rw" name="hs_sync_16bit_8809p_mode" pos="5" rst="0">
          <comment>hs_sync_16bit_8809p_mode</comment>
        </bits>
        <bits access="rw" name="d_term_small_8809p_en" pos="6" rst="0">
          <comment>d_term_small_8809p_en</comment>
        </bits>
        <bits access="rw" name="data_line_inv_8809p_en" pos="7" rst="0">
          <comment>data_line_inv_8809p_en</comment>
        </bits>
        <bits access="rw" name="hs_enable_8809p_mode" pos="8" rst="0">
          <comment>hs_enable_8809p_mode</comment>
        </bits>
        <bits access="rw" name="sp_to_trail_8809p_en" pos="9" rst="0">
          <comment>sp_to_trail_8809p_en</comment>
        </bits>
        <bits access="rw" name="trail_wrong_8809p_bypass" pos="10" rst="0">
          <comment>trail_wrong_8809p_bypass</comment>
        </bits>
        <bits access="rw" name="rinc_trail_8809p_bypass" pos="11" rst="0">
          <comment>rinc_trail_8809p_bypass</comment>
        </bits>
        <bits access="rw" name="hs_data_enable_8809p_mode" pos="12" rst="0">
          <comment>hs_data_enable_8809p_mode</comment>
        </bits>
        <bits access="rw" name="hs_clk_enable_8809p_mode" pos="13" rst="0">
          <comment>hs_clk_enable_8809p_mode</comment>
        </bits>
        <bits access="rw" name="data_type_re_check_en" pos="14" rst="0">
          <comment>data_type_re_check_en</comment>
        </bits>
        <bits access="rw" name="sync_id_reg" pos="22:15" rst="0">
          <comment>sync_id_reg</comment>
        </bits>
        <bits access="rw" name="sync_id_dr" pos="23" rst="0">
          <comment>sync_id_dr</comment>
        </bits>
        <bits access="rw" name="csi_observe_choose_bit" pos="28:24" rst="0">
          <comment>csi_observe_choose_bit</comment>
        </bits>
        <bits access="rw" name="crc_error_flag_reg" pos="29" rst="0">
          <comment>crc_error_flag_reg</comment>
        </bits>
        <bits access="rw" name="crc_error_flag_dr" pos="30" rst="0">
          <comment>crc_error_flag_dr  1:select reg 0:select logic</comment>
        </bits>
        <bits access="rw" name="csi_rinc_new_mode_dis" pos="31" rst="0">
          <comment>csi_rinc_new_mode_dis</comment>
        </bits>
      </reg>
      <reg name="csi config reg6" protect="rw">
        <bits access="rw" name="data_type_dp_reg" pos="5:0" rst="0">
          <comment>data_type_dp_reg[5:0],  set data type</comment>
        </bits>
        <bits access="rw" name="data_type_le_reg" pos="11:6" rst="0">
          <comment>data_type_le_reg  line end type</comment>
        </bits>
        <bits access="rw" name="data_type_ls_reg" pos="17:12" rst="0">
          <comment>data_type_ls_reg  line start type</comment>
        </bits>
        <bits access="rw" name="data_type_fe_reg" pos="23:18" rst="0">
          <comment>data_type_fe_reg  frame end type</comment>
        </bits>
        <bits access="rw" name="data_type_fs_reg" pos="29:24" rst="0">
          <comment>data_type_fs_reg  frame start type</comment>
        </bits>
        <bits access="rw" name="data_type_dp_dr" pos="30" rst="0">
          <comment>1: only support raw8   0:support more type</comment>
        </bits>
        <bits access="rw" name="data_type_dr" pos="31" rst="0">
          <comment>1:select reg value</comment>
        </bits>
      </reg>
      <reg name="csi config reg7" protect="rw">
        <bits access="rw" name="data_lane_16bits_mode" pos="2" rst="0">
          <comment>data_lane_16bits_mode</comment>
        </bits>
        <bits access="rw" name="terminal_2_hs_exchage_8809p" pos="3" rst="0">
          <comment>terminal_2_hs_exchage_8809p</comment>
        </bits>
        <bits access="rw" name="terminal_1_hs_exchage_8809p" pos="4" rst="0">
          <comment>terminal_1_hs_exchage_8809p</comment>
        </bits>
        <bits access="rw" name="data2_terminal_enable_8809p_dr" pos="5" rst="0">
          <comment>data2_terminal_enable_8809p_dr</comment>
        </bits>
        <bits access="rw" name="hs_data2_enable_8809p_dr" pos="6" rst="0">
          <comment>hs_data2_enable_8809p_dr</comment>
        </bits>
        <bits access="rw" name="csi_dout_test_8809p_en" pos="7" rst="0">
          <comment>csi_dout_test_8809p_en</comment>
        </bits>
        <bits access="rw" name="csi_dout_test_8809p" pos="15:8" rst="0">
          <comment>csi_dout_test_8809p[7:0]</comment>
        </bits>
        <bits access="rw" name="num_d_term_en" pos="23:16" rst="0">
          <comment>num_d_term_en[15:8]</comment>
        </bits>
        <bits access="rw" name="num_hs_settle" pos="31:24" rst="0">
          <comment>num_hs_settle[15:8]</comment>
        </bits>
      </reg>
      <reg name="csi obs4" protect="rw">
        <bits access="rw" name="hs_data_state" pos="13:0" rst="0">
          <comment>hs_data_state[13:0]</comment>
        </bits>
        <bits access="rw" name="phy_data_state" pos="28:14" rst="0">
          <comment>phy_data_state[14:0]</comment>
        </bits>
        <bits access="rw" name="fifo_wfull_almost" pos="29" rst="0">
          <comment>fifo_wfull_almost</comment>
        </bits>
        <bits access="rw" name="fifo_wfull" pos="30" rst="0">
          <comment>fifo_wfull</comment>
        </bits>
        <bits access="rw" name="fifo_wempty" pos="31" rst="1">
          <comment>fifo_wempty</comment>
        </bits>
      </reg>
      <reg name="csi obs5" protect="rw">
        <bits access="ro" name="csi_observe_reg_5_low" pos="7:0" rst="0">
          <comment>if observe_reg_5_low8_choose=1, out is data_id[7:0], else out is lp_cmd_out[7:0]</comment>
        </bits>
        <bits access="ro" name="lp_data_interrupt_flag" pos="8" rst="0">
          <comment>lp_data_interrupt_flag</comment>
        </bits>
        <bits access="ro" name="lp_cmd_interrupt_flag" pos="9" rst="0">
          <comment>lp_data_interrupt_flag</comment>
        </bits>
        <bits access="ro" name="phy_clk_state" pos="18:10" rst="0">
          <comment>phy_clk_state[8:0]</comment>
        </bits>
        <bits access="ro" name="fifo_rcount" pos="27:19" rst="0">
          <comment>fifo_rcount[8:0]</comment>
        </bits>
        <bits access="ro" name="crc_error" pos="28" rst="0">
          <comment>crc_error</comment>
        </bits>
        <bits access="ro" name="err_ecc_corrected_flag" pos="29" rst="0">
          <comment>err_ecc_corrected_flag</comment>
        </bits>
        <bits access="ro" name="err_data_corrected_flag" pos="30" rst="0">
          <comment>err_data_corrected_flag</comment>
        </bits>
        <bits access="ro" name="err_data_zero_flag" pos="31" rst="1">
          <comment>err_data_zero_flag</comment>
        </bits>
      </reg>
      <reg name="csi obs6" protect="rw">
        <comment>if observe_reg_5_low8_choose=1, out is csi_observe_mon, else out is lp_data_out[63:32]</comment>
      </reg>
      <reg name="csi obs7" protect="rw">
        <comment>csi_observe_reg_7[31:0]</comment>
      </reg>
      <reg name="csi enable" protect="rw">
        <bits access="rw" name="csi_enable" pos="0" rst="0">
          <comment>csi_enable</comment>
        </bits>
      </reg>
      <reg name="csi config reg8" protect="rw">
        <bits access="rw" name="dly_sel_clkn_reg" pos="3:0" rst="0">
          <comment>dly_sel_clkn_reg,set clkn delay,to csi analog phy</comment>
        </bits>
        <bits access="rw" name="dly_sel_clkp_reg" pos="7:4" rst="0">
          <comment>dly_sel_clkp_reg,set clkp delay,to csi analog phy</comment>
        </bits>
        <bits access="rw" name="dly_sel_data2_reg" pos="11:8" rst="0">
          <comment>dly_sel_data2_reg,set data2 delay,to csi analog phy</comment>
        </bits>
        <bits access="rw" name="dly_sel_data1_reg" pos="15:12" rst="0">
          <comment>dly_sel_data1_reg,set data1 delay,to csi analog phy</comment>
        </bits>
        <bits access="rw" name="vth_sel" pos="16" rst="0">
          <comment>vth_sel,to csi analog phy</comment>
        </bits>
      </reg>
      <hole size="222*32"/>
      <struct count="FIFORAM_SIZE" name="fiforam">
        <reg name="ramdata" protect="r">
          <comment>Direct FIFO Ram Access. They are enabled only in Bist Mode.</comment>
        </reg>
      </struct>
      <hole size="176*32"/>
      <reg name="soft_reset" protect="rw">
        <bits access="rw" name="dsp_reset" pos="0" rst="0x1">
          <comment>rstn of dsp</comment>
        </bits>
      </reg>
      <hole size="17*32"/>
      <reg name="awb_x1_min" protect="rw">
        <bits access="rw" name="awb_x1_min" pos="7:0" rst="0x78">
          <comment>for A ctd block, u2.7 format
                  awb_x1_min[8:0]=[awb_ctd_msb[0],awb_x1_min[7:0]]</comment>
        </bits>
      </reg>
      <reg name="awb_x1_max" protect="rw">
        <bits access="rw" name="awb_x1_max" pos="7:0" rst="0x99">
          <comment>for A ctd block, u2.7 format
                  awb_x1_max[8:0]=[awb_ctd_msb[1],awb_x1_max[7:0]]</comment>
        </bits>
      </reg>
      <reg name="awb_y1_min" protect="rw">
        <bits access="rw" name="awb_y1_min" pos="7:0" rst="0x27">
          <comment>for A ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y1_max" protect="rw">
        <bits access="rw" name="awb_y1_max" pos="7:0" rst="0x3c">
          <comment>for A ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x2_min" protect="rw">
        <bits access="rw" name="awb_x2_min" pos="7:0" rst="0x5b">
          <comment>for TL84 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x2_max" protect="rw">
        <bits access="rw" name="awb_x2_max" pos="7:0" rst="0x70">
          <comment>for TL84 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y2_min" protect="rw">
        <bits access="rw" name="awb_y2_min" pos="7:0" rst="0x34">
          <comment>for TL84 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y2_max" protect="rw">
        <bits access="rw" name="awb_y2_max" pos="7:0" rst="0x4d">
          <comment>for TL84 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x3_min" protect="rw">
        <bits access="rw" name="awb_x3_min" pos="7:0" rst="0x44">
          <comment>for CWF ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x3_max" protect="rw">
        <bits access="rw" name="awb_x3_max" pos="7:0" rst="0x5a">
          <comment>for CWF ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y3_min" protect="rw">
        <bits access="rw" name="awb_y3_min" pos="7:0" rst="0x2b">
          <comment>for CWF ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y3_max" protect="rw">
        <bits access="rw" name="awb_y3_max" pos="7:0" rst="0x44">
          <comment>for CWF ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x4_min" protect="rw">
        <bits access="rw" name="awb_x4_min" pos="7:0" rst="0x42">
          <comment>for Indoor ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x4_max" protect="rw">
        <bits access="rw" name="awb_x4_max" pos="7:0" rst="0x5c">
          <comment>for Indoor ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y4_min" protect="rw">
        <bits access="rw" name="awb_y4_min" pos="7:0" rst="0x4f">
          <comment>for Indoor ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y4_max" protect="rw">
        <bits access="rw" name="awb_y4_max" pos="7:0" rst="0x68">
          <comment>for Indoor ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x5_min" protect="rw">
        <bits access="rw" name="awb_x5_min" pos="7:0" rst="0x2d">
          <comment>for D65 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_x5_max" protect="rw">
        <bits access="rw" name="awb_x5_max" pos="7:0" rst="0x47">
          <comment>for D65 ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_y5_min" protect="rw">
        <bits access="rw" name="awb_y5_min" pos="7:0" rst="0x6d">
          <comment>for D65 ctd block, u2.7 format
                  awb_y5_min[8:0]=[awb_ctd_msb[2],awb_y5_min[7:0]]</comment>
        </bits>
      </reg>
      <reg name="awb_y5_max" protect="rw">
        <bits access="rw" name="awb_y5_max" pos="7:0" rst="0x83">
          <comment>for D65 ctd block, u2.7 format
                  awb_y5_max[8:0]=[awb_ctd_msb[3],awb_y5_max[7:0]]</comment>
        </bits>
      </reg>
      <reg name="awb_skin_x1_min" protect="rw">
        <bits access="rw" name="awb_skin_x1_min" pos="7:0" rst="0x90">
          <comment>for TL84 skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_x1_max" protect="rw">
        <bits access="rw" name="awb_skin_x1_max" pos="7:0" rst="0xa8">
          <comment>for TL84 skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_y1_min" protect="rw">
        <bits access="rw" name="awb_skin_y1_min" pos="7:0" rst="0x28">
          <comment>for TL84 skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_y1_max" protect="rw">
        <bits access="rw" name="awb_skin_y1_max" pos="7:0" rst="0x45">
          <comment>for TL84 skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_x2_min" protect="rw">
        <bits access="rw" name="awb_skin_x2_min" pos="7:0" rst="0x73">
          <comment>for CWF skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_x2_max" protect="rw">
        <bits access="rw" name="awb_skin_x2_max" pos="7:0" rst="0x8c">
          <comment>for CWF skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_y2_min" protect="rw">
        <bits access="rw" name="awb_skin_y2_min" pos="7:0" rst="0x18">
          <comment>for CWF skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_skin_y2_max" protect="rw">
        <bits access="rw" name="awb_skin_y2_max" pos="7:0" rst="0x39">
          <comment>for CWF skin ctd block, u1.7 format</comment>
        </bits>
      </reg>
      <reg name="awb_ctd_msb" protect="rw">
        <bits access="rw" name="awb_x1_min_msb" pos="0" rst="0x0">
          <comment>awb_x1_min[8:0]=[awb_x1_min_msb,awb_x1_min[7:0]]</comment>
        </bits>
        <bits access="rw" name="awb_x1_max_msb" pos="1" rst="0x0">
          <comment>awb_x1_max[8:0]=[awb_x1_max_msb,awb_x1_max[7:0]]</comment>
        </bits>
        <bits access="rw" name="awb_y5_min_msb" pos="2" rst="0x0">
          <comment>awb_y5_min[8:0]=[awb_y5_min_msb,awb_y5_min[7:0]]</comment>
        </bits>
        <bits access="rw" name="awb_y5_max_msb" pos="3" rst="0x0">
          <comment>awb_y5_max[8:0]=[awb_y5_max_msb,awb_y5_max[7:0]]</comment>
        </bits>
        <bits access="rw" name="awb_adj_mode" pos="5:4" rst="0x0">
          <comment>2d0: awb_adj_sig=1
                  2d1: awb_adj_sig= crsum_abs&gt;vld_cnt_cr_thr x2 or  cbsum_abs&gt;vld_cnt_cb_thr x2
                  2d2: awb_adj_sig= crsum_abs&gt;vld_cnt_cr_thr x3 or  cbsum_abs&gt;vld_cnt_cb_thr x3
                  2d3: awb_adj_sig= crsum_abs&gt;vld_cnt_cr_thr x2 and cbsum_abs&gt;vld_cnt_cb_thr x2</comment>
        </bits>
        <bits access="rw" name="awb_ratio_mode" pos="7:6" rst="0x0">
          <comment>2d3: awb_ratio_lmax=4
                  2d2: awb_ratio_lmax=2
                  2d1: awb_ratio_lmax=0
                  2d0: awb_ratio_lmax= according to the proportion of cnt_max and cnt_lmax</comment>
        </bits>
      </reg>
      <reg name="int_dif_thr_mid" protect="rw">
        <bits access="rw" name="int_dif_thr_mid" pos="7:0" rst="0x18">
          <comment/>
        </bits>
      </reg>
      <reg name="lb_soft_rstn" protect="rw">
        <bits access="rw" name="lb_soft_rstn" pos="0" rst="0x1">
          <comment/>
        </bits>
      </reg>
      <reg name="vsync_end_high" protect="rw">
        <bits access="rw" name="vsync_end_high" pos="7:0" rst="0x0">
          <comment>vsync_end_reg=[vsync_end_high,vsync_end_low]</comment>
        </bits>
      </reg>
      <reg name="vsync_end_low" protect="rw">
        <bits access="rw" name="vsync_end_low" pos="7:0" rst="0x01">
          <comment>vsync_end_reg=[vsync_end_high,vsync_end_low]</comment>
        </bits>
      </reg>
      <reg name="line_numl" protect="rw">
        <bits access="rw" name="line_numl" pos="7:0" rst="0xe8">
          <comment>line_num = [line_numH,line_numL]</comment>
        </bits>
      </reg>
      <reg name="pix_numl" protect="rw">
        <bits access="rw" name="pix_numl" pos="7:0" rst="0x88">
          <comment>pix_num = [pix_numH,pix_numL]</comment>
        </bits>
      </reg>
      <reg name="pix_line_numh" protect="rw">
        <bits access="rw" name="line_numh" pos="0" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="pix_numh_rsvd" pos="3:1" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="pix_numh" pos="5:4" rst="0x2">
          <comment/>
        </bits>
        <bits access="rw" name="line_numh_rsvd" pos="7:6" rst="0x0">
          <comment>not used here</comment>
        </bits>
      </reg>
      <reg name="lb_ctrl" protect="rw">
        <bits access="rw" name="low_order" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="use_fb_reg" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="not_cvp_reg" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="first_byte_reg" pos="5:3" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="data_format" protect="rw">
        <bits access="rw" name="data_format" pos="1:0" rst="0x0">
          <comment>00:YUV/RAW8(para)
                  01:RAW8(mipi)
                  10:RAW10(mipi)</comment>
        </bits>
      </reg>
      <reg name="lb_enable" protect="rw">
        <bits access="rw" name="lb_enable" pos="0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="vh_inv" protect="rw">
        <bits access="rw" name="hsync_inv" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="vsync_inv" pos="1" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="line_cnt_l" protect="ro">
        <bits access="ro" name="line_cnt_l" pos="7:0" rst="0x0">
          <comment>line_cnt=[line_cnt_H[1:0], [7:0]]</comment>
        </bits>
      </reg>
      <reg name="line_cnt_h" protect="ro">
        <bits access="ro" name="line_cnt_h" pos="1:0" rst="0x0">
          <comment>line_cnt=[line_cnt_H[1:0], line_cnt_L]</comment>
        </bits>
      </reg>
      <reg name="num_check" protect="rw">
        <bits access="ro" name="line_num_check" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="ro" name="byte_num_check" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="wo" name="line_num_clear" pos="4" rst="0x0">
          <comment/>
        </bits>
        <bits access="wo" name="byte_num_clear" pos="5" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="dci_ctrl_reg" protect="rw">
        <bits access="rw" name="kl_low_light_fix" pos="0" rst="0x1">
          <comment>1: kl 0: kldci ()</comment>
        </bits>
        <bits access="rw" name="kl_reg_fix" pos="1" rst="0x1">
          <comment>1: kl 0: kldci</comment>
        </bits>
        <bits access="rw" name="ku_low_light_fix" pos="2" rst="0x1">
          <comment>1: ku 0: kudci ()</comment>
        </bits>
        <bits access="rw" name="ku_reg_fix" pos="3" rst="0x1">
          <comment>1: ku 0: kudci</comment>
        </bits>
        <bits access="rw" name="hofst" pos="5:4" rst="0x0">
          <comment>hist 2</comment>
        </bits>
        <bits access="rw" name="vbh_sel" pos="7:6" rst="0x0">
          <comment>00: 0x98regae_dark_hist_reg
                  01: 0x98regyave_target_RO_reg
                  other: 0x98regyave_contr_reg</comment>
        </bits>
      </reg>
      <reg name="dci_ofst_reg" protect="rw">
        <bits access="rw" name="kl_ofstx1" pos="3:0" rst="0x8">
          <comment>kl_ofstx1[4:0] = [kl_ofstx1, 1b0] (kl0x80)</comment>
        </bits>
        <bits access="rw" name="ku_ofstx1" pos="7:4" rst="0x8">
          <comment>ku_ofstx1[4:0] = [ku_ofstx1, 1b0] (kl0x80)</comment>
        </bits>
      </reg>
      <reg name="dci_hist_reg" protect="rw">
        <bits access="rw" name="dk_histx1" pos="3:0" rst="0x8">
          <comment>dk_histx1[4:0] = [dk_histx1, 1b0] (dhist)</comment>
        </bits>
        <bits access="rw" name="br_histx1" pos="7:4" rst="0x8">
          <comment>br_histx1[4:0] = [br_histx1, 1b0] (bhist)</comment>
        </bits>
      </reg>
      <reg name="ae_sw_ctrl_reg" protect="rw">
        <bits access="rw" name="nexp_sw_in" pos="3:0" rst="0x0">
          <comment>swaeswexp/gainnexphw//</comment>
        </bits>
        <bits access="wo" name="ae_ext_adj_start" pos="7" rst="0x0">
          <comment>sw/hwae,SWae,</comment>
        </bits>
      </reg>
      <reg name="ae_thr_reg" protect="rw">
        <bits access="rw" name="thr_dark" pos="3:0" rst="0x3">
          <comment>THR_dark[4:0] = [THR_dark, 1'b0] (ytarget-yave  THR_darkae)</comment>
        </bits>
        <bits access="rw" name="thr_bright" pos="7:4" rst="0x8">
          <comment>THR_bright[4:0] = [THR_bright,1'b0](yave-ytargetTHR_brightae)</comment>
        </bits>
      </reg>
      <reg name="ae_misc_ctrl_reg" protect="rw">
        <bits access="rw" name="ofst_dec_low_sel" pos="1:0" rst="0x0">
          <comment>ytarget_dec
                  2d3:4indexytargetregd[3:0]8index08
                  2d2:2indexytargetregd[3:0]8index016
                  2d1:1indexytargetregd[3:0]8index032
                  2d0:1indexytargetregd[3:0]8index064</comment>
        </bits>
        <bits access="rw" name="ofst_dec_high_sel" pos="3:2" rst="0x0">
          <comment>ytarget_dec
                  2d3:4indexytargetregc[7:4]8index_max8
                  2d2:2indexytargetregc[7:4]8index_max16
                  2d1:1indexytargetregd[7:4]8index_max32
                  2d0:1indexytargetregd[7:4]8index_max64</comment>
        </bits>
        <bits access="rw" name="force_adj1" pos="4" rst="0x0">
          <comment>1yave_diff_2frame</comment>
        </bits>
        <bits access="rw" name="force_adj2" pos="5" rst="0x0">
          <comment>1THR_big</comment>
        </bits>
        <bits access="rw" name="force_adj3" pos="6" rst="0x0">
          <comment>1bhist&gt;0@is_dark</comment>
        </bits>
        <bits access="rw" name="index_ofst_no_step" pos="7" rst="0x0">
          <comment>1index_ofst</comment>
        </bits>
      </reg>
      <reg name="csup_xx_reg" protect="rw">
        <bits access="rw" name="x_low" pos="3:0" rst="0x0">
          <comment>@nexp</comment>
        </bits>
        <bits access="rw" name="x_high" pos="7:4" rst="0x8">
          <comment>@nexp</comment>
        </bits>
      </reg>
      <reg name="contr_ythr_reg" protect="rw">
        <bits access="rw" name="csup_gain_low_th_h" pos="0" rst="0x1">
          <comment>low_th = [[0], lsc_blc_gain_th[7:6]](nexp=low_th)</comment>
        </bits>
        <bits access="rw" name="csup_gain_high_th" pos="3:1" rst="0x3">
          <comment>nexp&gt;(8+high_th)</comment>
        </bits>
        <bits access="rw" name="fixed_contr_ythr" pos="7:4" rst="0x8">
          <comment>Fixed Ythr of contr = [[7:4], 4d0]</comment>
        </bits>
      </reg>
      <reg name="contr_yave_offset_reg" protect="rw">
        <bits access="rw" name="yave_offset_reg" pos="5:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="ythr_sel" pos="6" rst="0x1">
          <comment>1: dynamic yave (Yave)
                  0: fixed ythr contr_ythr_reg</comment>
        </bits>
        <bits access="rw" name="yave_offset_sign" pos="7" rst="0x0">
          <comment>YaveYthrofst (01)</comment>
        </bits>
      </reg>
      <reg name="contr_ku_lo_reg" protect="rw">
        <bits access="rw" name="ku" pos="6:0" rst="0x20">
          <comment>upper@Low gain
                  Yout = Yin +/- min(ku*(Yin-Ythr), ku*(255-Yin))</comment>
        </bits>
        <bits access="rw" name="ku_sign" pos="7" rst="0x1">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="contr_kl_lo_reg" protect="rw">
        <bits access="rw" name="kl" pos="6:0" rst="0x20">
          <comment>lower@Low gain
                  Yout = Yin -/+ min(kl*(Ythr-Yin), kl*Yin)</comment>
        </bits>
        <bits access="rw" name="kl_sign" pos="7" rst="0x1">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="contr_ku_mid_reg" protect="rw">
        <bits access="rw" name="ku" pos="6:0" rst="0x10">
          <comment>upper@Mid gain
                  Yout = Yin +/- min(ku*(Yin-Ythr), ku*(255-Yin))</comment>
        </bits>
        <bits access="rw" name="ku_sign" pos="7" rst="0x1">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="contr_kl_mid_reg" protect="rw">
        <bits access="rw" name="kl" pos="6:0" rst="0x10">
          <comment>lower@Mid gain
                  Yout = Yin -/+ min(kl*(Ythr-Yin), kl*Yin)</comment>
        </bits>
        <bits access="rw" name="kl_sign" pos="7" rst="0x1">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="contr_ku_hi_reg" protect="rw">
        <bits access="rw" name="ku" pos="6:0" rst="0x70">
          <comment>upper@High gain
                  Yout = Yin +/- min(ku*(Yin-Ythr), ku*(255-Yin))</comment>
        </bits>
        <bits access="rw" name="ku_sign" pos="7" rst="0x0">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="contr_kl_hi_reg" protect="rw">
        <bits access="rw" name="kl" pos="6:0" rst="0x70">
          <comment>lower@High gain
                  Yout = Yin -/+ min(kl*(Ythr-Yin), kl*Yin)</comment>
        </bits>
        <bits access="rw" name="kl_sign" pos="7" rst="0x0">
          <comment>1: 0</comment>
        </bits>
      </reg>
      <reg name="luma_offset_lo_reg" protect="rw">
        <bits access="rw" name="offset" pos="5:0" rst="0x0">
          <comment>@Low gain</comment>
        </bits>
        <bits access="rw" name="algo_sel" pos="6" rst="0x0">
          <comment>1: Yout = (256-offset)*Yin/256 + offset
                  0: Yout = Yin + offset</comment>
        </bits>
        <bits access="rw" name="offset_sign" pos="7" rst="0x0">
          <comment>0   1</comment>
        </bits>
      </reg>
      <reg name="luma_offset_mid_reg" protect="rw">
        <bits access="rw" name="offset" pos="5:0" rst="0x0">
          <comment>@Mid gain</comment>
        </bits>
        <bits access="rw" name="algo_sel" pos="6" rst="0x0">
          <comment>1: Yout = (256-offset)*Yin/256 + offset
                  0: Yout = Yin + offset</comment>
        </bits>
        <bits access="rw" name="offset_sign" pos="7" rst="0x0">
          <comment>0   1</comment>
        </bits>
      </reg>
      <reg name="luma_offset_hi_reg" protect="rw">
        <bits access="rw" name="offset" pos="5:0" rst="0x0">
          <comment>@High gain</comment>
        </bits>
        <bits access="rw" name="algo_sel" pos="6" rst="0x0">
          <comment>1: Yout = (256-offset)*Yin/256 + offset
                  0: Yout = Yin + offset</comment>
        </bits>
        <bits access="rw" name="offset_sign" pos="7" rst="0x0">
          <comment>0   1</comment>
        </bits>
      </reg>
      <reg name="u_gain_lo_reg" protect="rw">
        <bits access="rw" name="u_gain_lo_reg" pos="7:0" rst="0xb0">
          <comment>Cb@Low gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="v_gain_lo_reg" protect="rw">
        <bits access="rw" name="v_gain_lo_reg" pos="7:0" rst="0xb0">
          <comment>Cr@Low gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="u_gain_mid_reg" protect="rw">
        <bits access="rw" name="u_gain_mid_reg" pos="7:0" rst="0xa0">
          <comment>Cb@Mid gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="v_gain_mid_reg" protect="rw">
        <bits access="rw" name="v_gain_mid_reg" pos="7:0" rst="0xa0">
          <comment>Cr@Mid gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="u_gain_hi_reg" protect="rw">
        <bits access="rw" name="u_gain_hi_reg" pos="7:0" rst="0x80">
          <comment>Cb@High gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="v_gain_hi_reg" protect="rw">
        <bits access="rw" name="v_gain_hi_reg" pos="7:0" rst="0x80">
          <comment>Cr@High gain0x80 just x1.0</comment>
        </bits>
      </reg>
      <reg name="again_sel_th0_reg" protect="rw">
        <bits access="rw" name="contr_gain_low_th" pos="2:0" rst="0x4">
          <comment>@luma/contr/satur(nexp=low_th)</comment>
        </bits>
        <bits access="rw" name="again_sel_th0_rsvd" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="contr_gain_hi_th" pos="6:4" rst="0x3">
          <comment>@luma/contr/satur(nexp&gt;(8+high_th))</comment>
        </bits>
      </reg>
      <reg name="awb_cc_type_ctrl_reg" protect="rw">
        <bits access="rw" name="cc_type_mode" pos="3:0" rst="0x0">
          <comment>4'd0:         cc_type = 0; //D65
                  4'd1:         cc_type = 1; //U30
                  4'd2:if(is_outdoor) cc_type = 0;
                       else           cc_type = 1;
                  4'd3:if(ana_gain&gt;=cc_gain_th) cc_type = 0;
                       else                     cc_type = 1;
                  4'd4:if(rgain_bigger)         cc_type = 0; //D65
                       else if(bgain_bigger)    cc_type = 1; //U30
                  4'd5: if(is_outdoor)          cc_type = 0;
                        else if(rgain_bigger)   cc_type = 0;
                        else if(bgain_bigger)   cc_type = 1;
                  4'd6: if(is_outdoor)                 cc_type = 0;
                        else if(ana_gain=cc_gain_th) cc_type = 0;
                        else if(rgain_bigger)          cc_type = 0;
                        else if(bgain_bigger)          cc_type = 1;
                  4'd7: if(is_outdoor)                 cc_type = 0;
                        else if(ana_gain=cc_gain_th) cc_type = 1;
                        else if(rgain_bigger)          cc_type = 0;
                        else if(bgain_bigger)          cc_type = 1;
                  4'd8: if(r_awb_gain_outr_low_non_A)cc_type = 1;
                        else if(r_awb_gain_out(r_low_non_A+8)) cc_type = 0;
                  4d9: if(awb_idx_max2)       cc_type = 1;
                         else if(awb_idx_max2)  cc_type = 0;
                  other: SW driven  ( reg1c2)</comment>
        </bits>
        <bits access="rw" name="cc_gain_hi_th" pos="6:4" rst="0x0">
          <comment>nexp&gt;(8+high_th)</comment>
        </bits>
        <bits access="rw" name="luma_first" pos="7" rst="0x0">
          <comment>1:  0:</comment>
        </bits>
      </reg>
      <reg name="awb_cc_type_th_reg" protect="rw">
        <bits access="rw" name="r_big_th" pos="3:0" rst="0x1">
          <comment>r_big_th=[awb_cc_type_th_reg[3:0], 2d0]</comment>
        </bits>
        <bits access="rw" name=" b_big_th" pos="7:4" rst="0x1">
          <comment>b_big_th=[awb_cc_type_th_reg[7:4], 2d0]</comment>
        </bits>
      </reg>
      <reg name="isp_wrapper_ctrl_1" protect="rw">
        <bits access="rw" name="pout_mode" pos="1:0" rst="0x0">
          <comment>00: YUV422     01: RGB565
                  10: raw bayer  11: clip out</comment>
        </bits>
        <bits access="rw" name="yuv_mode" pos="3:2" rst="0x0">
          <comment>00:YUYV       01:YVYU
                  10:UYVY       11:VYUY
                 (Note:[2] uv_sel  0:UV  1:VU)</comment>
        </bits>
        <bits access="rw" name="vsync_toggle" pos="4" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="mipi_rstn" pos="5" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name=" hsync_fix" pos="6" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="top_dummy" protect="rw">
        <bits access="rw" name="top_dummy" pos="6:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="left_dummy" protect="rw">
        <bits access="rw" name="left_dummy" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="isp_wrapper_ctrl_2" protect="rw">
        <bits access="rw" name="rgb_mode_reg" pos="2:0" rst="0x0">
          <comment>Case(rgb_mode_reg)  @clip out
                  3'd0: to_n_clp_data     3'd1: y_data
                  3'd2: cnr_1d_cb         3'd3: cnr_1d_cr
                  3'd4: c_data            3'd5: yc2r_data
                  3'd6: yc2g_data         3'd7: yc2b_data
                  Note:rgb_mode_reg[0] is also used to
                  1, select the line of sub_YUV output</comment>
        </bits>
        <bits access="rw" name="sub_mode" pos="3" rst="0x0">
          <comment>not used, sca_reg=1:sub mode</comment>
        </bits>
        <bits access="rw" name="mon_mode_reg" pos="4" rst="0x0">
          <comment>bypass vsync_in and hsync_in</comment>
        </bits>
        <bits access="rw" name="oclk_inv_reg" pos="5" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="isp_out_en" pos="6" rst="0x1">
          <comment/>
        </bits>
      </reg>
      <reg name="line_num_l_reg" protect="rw">
        <bits access="rw" name="line_num_l_reg" pos="5:0" rst="0x3c">
          <comment>Line_num=[lin_num_l_reg[5:0], 3d0]</comment>
        </bits>
      </reg>
      <reg name="pix_num_l_reg" protect="rw">
        <bits access="rw" name="pix_num_l_reg" pos="6:0" rst="0x50">
          <comment>Pix_num=[pix_num_l_reg[6:0], 3d0]</comment>
        </bits>
        <bits access="rw" name="csi_mon_reg" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="v_dummy" protect="rw">
        <bits access="rw" name="vbot_dummy_reg" pos="3:0" rst="0x2">
          <comment>HsyncNvsync</comment>
        </bits>
        <bits access="rw" name="vtop_dummy_reg" pos="7:4" rst="0x0">
          <comment>Mvsync
                  top_dummy&gt;16, vtop_dummy=top_dummy-[7:4]</comment>
        </bits>
      </reg>
      <reg name="scg" protect="rw">
        <bits access="rw" name="kukl_sel" pos="0" rst="0x1">
          <comment>1blc[ku, kl]</comment>
        </bits>
        <bits access="rw" name="reg94_rd_sel" pos="1" rst="0x1">
          <comment>1:nexp[3:0]  0:mono_color</comment>
        </bits>
        <bits access="rw" name="bayer_out_sel" pos="2" rst="0x0">
          <comment>1: dpc_out  0: bayer_data</comment>
        </bits>
        <bits access="rw" name="csup_en" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="y_gamma_en" pos="5:4" rst="0x3">
          <comment>1: enable 0: disable
                  y_gamma_en = is_outdoor ? scg_reg[5] : scg_reg[4]</comment>
        </bits>
        <bits access="rw" name="yuv_sdi_en" pos="6" rst="0x1">
          <comment>1: SDI  0: BT.601</comment>
        </bits>
        <bits access="rw" name="reg92_rd_sel" pos="7" rst="0x0">
          <comment>1: [ae_ok, nexp_sel[1:0], awb_ok, exp[11:8]]
                  0: [ae_ok, 1b0, nexp_sel[1:0], awb_ok, exp[10:8]]
                     labview</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b0" protect="rw">
        <bits access="rw" name="y_gamma_b0" pos="7:0" rst="0x0">
          <comment>(0x00)0      (0x00)0     (0x00)0</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b1" protect="rw">
        <bits access="rw" name="y_gamma_b1" pos="7:0" rst="0x10">
          <comment>(0x13)19     (0x10)16    (0x08)8</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b2" protect="rw">
        <bits access="rw" name="y_gamma_b2" pos="7:0" rst="0x1c">
          <comment>(0x20)32     (0x1c)28    (0x10)16</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b4" protect="rw">
        <bits access="rw" name="y_gamma_b4" pos="7:0" rst="0x30">
          <comment>(0x36)54     (0x30)48    (0x20)32</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b6" protect="rw">
        <bits access="rw" name="y_gamma_b6" pos="7:0" rst="0x43">
          <comment>(0x49)73     (0x43)67    (0x30)48</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b8" protect="rw">
        <bits access="rw" name="y_gamma_b8" pos="7:0" rst="0x54">
          <comment>(0x5a)90     (0x54)84    (0x40)64</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b10" protect="rw">
        <bits access="rw" name="y_gamma_b10" pos="7:0" rst="0x65">
          <comment>(0x6b)107    (0x65)101   (0x50)80</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b12" protect="rw">
        <bits access="rw" name="y_gamma_b12" pos="7:0" rst="0x75">
          <comment>(0x7b)123    (0x75)117   (0x60)96</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b16" protect="rw">
        <bits access="rw" name="y_gamma_b16" pos="7:0" rst="0x93">
          <comment>RW(0x98)152    (0x93)147   (0x80)128</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b20" protect="rw">
        <bits access="rw" name="y_gamma_b20" pos="7:0" rst="0xb0">
          <comment>(0xb4)180    (0xb0)176   (0xa0)160</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b24" protect="rw">
        <bits access="rw" name="y_gamma_b24" pos="7:0" rst="0xcb">
          <comment>(0xce)206    (0xcb)203   (0xc0)192</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b28" protect="rw">
        <bits access="rw" name="y_gamma_b28" pos="7:0" rst="0xe6">
          <comment>(0xe7)231    (0xe6)230   (0xe0)224</comment>
        </bits>
      </reg>
      <reg name="y_gamma_b32" protect="rw">
        <bits access="rw" name="y_gamma_b32" pos="7:0" rst="0x0">
          <comment>0.75    0.8   1.0</comment>
        </bits>
      </reg>
      <reg name="r_awb_gain_in" protect="rw">
        <bits access="rw" name="r_awb_gain_in" pos="7:0" rst="0x40">
          <comment>r_gain_manual 2.6 format</comment>
        </bits>
      </reg>
      <reg name="g_awb_gain_in" protect="rw">
        <bits access="rw" name="g_awb_gain_in" pos="7:0" rst="0x40">
          <comment>g_gain_manual 2.6 format</comment>
        </bits>
      </reg>
      <reg name="b_awb_gain_in" protect="rw">
        <bits access="rw" name="b_awb_gain_in" pos="7:0" rst="0x40">
          <comment>b_gain_manual 2.6 format</comment>
        </bits>
      </reg>
      <reg name="r_drc_gain_in" protect="rw">
        <bits access="rw" name="r_drc_gain_in" pos="7:0" rst="0x40">
          <comment>2.6 format</comment>
        </bits>
      </reg>
      <reg name="gr_drc_gain_in" protect="rw">
        <bits access="rw" name="gr_drc_gain_in" pos="7:0" rst="0x40">
          <comment>2.6 format</comment>
        </bits>
      </reg>
      <reg name="gb_drc_gain_in" protect="rw">
        <bits access="rw" name="gb_drc_gain_in" pos="7:0" rst="0x40">
          <comment>2.6 format</comment>
        </bits>
      </reg>
      <reg name="b_drc_gain_in" protect="rw">
        <bits access="rw" name="b_drc_gain_in" pos="7:0" rst="0x40">
          <comment>2.6 format</comment>
        </bits>
      </reg>
      <reg name="ae_ctrl" protect="rw">
        <bits access="rw" name="ana_gain_in" pos="5:0" rst="0x8">
          <comment/>
        </bits>
        <bits access="rw" name="ae_update_en" pos="6" rst="0x1">
          <comment>also update cc_type,gamma_type,is_outdoor</comment>
        </bits>
        <bits access="rw" name="ae_en" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="ae_ctrl2" protect="rw">
        <bits access="rw" name=" awb_adj_sel" pos="1:0" rst="0x1">
          <comment>00: AWB
                  01: AWB
                  10: yaveAWB
                  11: nexpAWB</comment>
        </bits>
        <bits access="rw" name="gap_ae" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gap_be" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="ae_action_period" pos="6:4" rst="0x4">
          <comment/>
        </bits>
        <bits access="rw" name="yave_mon_sel" pos="7" rst="0x0">
          <comment>1: mon ae index  0:mon awb_debug</comment>
        </bits>
      </reg>
      <reg name="ae_ctrl3" protect="rw">
        <bits access="rw" name="yave_use_mean" pos="1:0" rst="0x3">
          <comment>0yave        1yave
                  2yave    3yave</comment>
        </bits>
        <bits access="rw" name="yave_diff_thr_reg" pos="3:2" rst="0x1">
          <comment>07/0f/17/1f Yave</comment>
        </bits>
        <bits access="rw" name="yave_sel" pos="5:4" rst="0x2">
          <comment>00: y2ave x1.0    01: y2ave x1.5
                  10: y3ave x1.0    11: y3ave x1.5</comment>
        </bits>
        <bits access="rw" name="yave_plus_bh_mode" pos="6" rst="0x1">
          <comment>1:plus bh   0: only yave</comment>
        </bits>
        <bits access="rw" name="ywave_plus_bh_mode" pos="7" rst="0x1">
          <comment>1:plus bh   0: only ywave</comment>
        </bits>
      </reg>
      <reg name="ae_ctrl4" protect="rw">
        <bits access="rw" name="ae_hist_big_en" pos="0" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="ae_hist_too_big_en" pos="1" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="hist_ofst0" pos="3:2" rst="0x2">
          <comment/>
        </bits>
        <bits access="rw" name="index_ofst0" pos="5:4" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="index_ofst1" pos="7:6" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="ae_win_start" protect="rw">
        <bits access="rw" name="pcnt_left" pos="3:0" rst="0x2">
          <comment>pcnt_left =[ae_win_start_reg[3:0] ,1'd0]</comment>
        </bits>
        <bits access="rw" name="lcnt_top" pos="7:4" rst="0x2">
          <comment>lcnt_top =[ae_win_start_reg[7:4] ,1'd0]</comment>
        </bits>
      </reg>
      <reg name="ae_win_width" protect="rw">
        <bits access="rw" name="ae_win_width" pos="7:0" rst="0x95">
          <comment>ae(yave) win_width = [ae_win_width[7:0], 2'd0]</comment>
        </bits>
      </reg>
      <reg name="ae_win_height" protect="rw">
        <bits access="rw" name="ae_win_height" pos="7:0" rst="0xdc">
          <comment>ae(yave) ae_win_height = [ae_win_height[7:0], 1'd0]</comment>
        </bits>
      </reg>
      <reg name="exp_init" protect="rw">
        <bits access="rw" name="exp_init" pos="7:0" rst="0x0">
          <comment>exp[7:0](ae_enMCUexp_init[6:0]indexae)</comment>
        </bits>
      </reg>
      <reg name="exp_ceil_init" protect="rw">
        <bits access="rw" name="exp_ceil_init" pos="3:0" rst="0x1">
          <comment>exp[11:8]</comment>
        </bits>
      </reg>
      <reg name="ae_exp_1e" protect="rw">
        <bits access="rw" name="ae_exp_1e" pos="7:0" rst="0x4a">
          <comment>10msexp</comment>
        </bits>
      </reg>
      <reg name="ae_diff_thr" protect="rw">
        <bits access="rw" name="thr2_dark" pos="3:0" rst="0x8">
          <comment>(ytarget)
                  THR_dark(reg41)
                  THR22index1
                  THR24index2
                  THR26index4+ofst0
                  THR28index8+ofst1
                                    index16</comment>
        </bits>
        <bits access="rw" name="thr2_bright" pos="7:4" rst="0x8">
          <comment>(ytarget)
                  THR_bright(reg41)
                  THR22index1
                  THR24index2
                  THR26index4+ofst0
                  THR28index8+ofst1
                                    index16</comment>
        </bits>
      </reg>
      <reg name="ae_bh_sel" protect="rw">
        <bits access="rw" name="bh_factor_indoor" pos="2:0" rst="0x3">
          <comment/>
        </bits>
        <bits access="rw" name="bh_factor_outdoor" pos="5:3" rst="0x2">
          <comment>Bh = Bh_mean * bh_factor /8
                  bh_factor = is_outdoor? bh_factor_outdoor : bh_factor_indoor</comment>
        </bits>
        <bits access="rw" name="bh_mean_sel" pos="7:6" rst="0x2">
          <comment>00:  curr frame     01:  2 frame ave
                  10:  3 frame ave    11:  4 frame ave</comment>
        </bits>
      </reg>
      <reg name="awb_ctrl" protect="rw">
        <bits access="rw" name="awb_sw_mon_en" pos="0" rst="0x0">
          <comment>awb_mon_out[7:0][cbsum_abs_eq, crsum_abs_eq]SWAWB</comment>
        </bits>
        <bits access="rw" name="fast_2x" pos="1" rst="0x0">
          <comment>2.0xr/b</comment>
        </bits>
        <bits access="rw" name="fast_4x" pos="2" rst="0x0">
          <comment>4.0xr/b</comment>
        </bits>
        <bits access="rw" name="awb_action_period" pos="5:3" rst="0x4">
          <comment>0: 1frame  or 2frame</comment>
        </bits>
        <bits access="rw" name="awb_update_en" pos="6" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="awb_en" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="awb_ctrl2" protect="rw">
        <bits access="rw" name="awb_mon_sel" pos="2:0" rst="0x0">
          <comment>[  2]  0:readback blc  1: readback awb
                  [1:0]  0: crsum_abs    1:cbsum_abs
                         2: vld_cnt      3:awb_idx_lmax and max</comment>
        </bits>
        <bits access="rw" name="awb_vld_sel" pos="3" rst="0x0">
          <comment>AWB</comment>
        </bits>
        <bits access="rw" name="awb_vld_mode" pos="6:4" rst="0x0">
          <comment>3'd0:awb_vld=vld_max||(vld_lmax and awb_ratio_lmax);
                  3'd1: awb_vld = awb_vld1;
                  3'd2: awb_vld = awb_vld2;
                  3'd3: awb_vld = awb_vld3;
                  3'd4: awb_vld = awb_vld4;
                  3'd5: awb_vld = awb_vld5;
                  3'd6: awb_vld =!skin_vld;
                  3'd7: awb_vld = awb_vld1|awb_vld2|awb_vld3| awb_vld4 | awb_vld5;</comment>
        </bits>
        <bits access="ro" name="awb_adj" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="awb_y_max" protect="rw">
        <bits access="rw" name="awb_y_max" pos="7:0" rst="0xf0">
          <comment>Y  Y_maxAWB</comment>
        </bits>
      </reg>
      <reg name="awb_stop" protect="rw">
        <bits access="rw" name="awb_stop_cb_neg_level" pos="1:0" rst="0x1">
          <comment>Levelawb_stop</comment>
        </bits>
        <bits access="rw" name="awb_stop_cb_pos_level" pos="3:2" rst="0x1">
          <comment>Levelawb_stop</comment>
        </bits>
        <bits access="rw" name="awb_stop_cr_neg_level" pos="5:4" rst="0x1">
          <comment>Levelawb_stop</comment>
        </bits>
        <bits access="rw" name="awb_stop_cr_pos_level" pos="7:6" rst="0x1">
          <comment>Levelawb_stop</comment>
        </bits>
      </reg>
      <reg name="awb_algo" protect="rw">
        <bits access="rw" name="awb_algo" pos="7:0" rst="0x80">
          <comment>[7:0]awb_algo_thr
                  Y &gt; cr_abs+cb_abs+awb_algo_reg
                  //</comment>
        </bits>
      </reg>
      <reg name="awb_ctrl3" protect="rw">
        <bits access="rw" name="cr_ofst_lt1x" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="cr_ofst_gt1x" pos="1" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="cb_ofst_lt1x" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="cb_ofst_gt1x" pos="3" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="awb_sum_vld_sel" pos="4" rst="0x0">
          <comment>0: (vld_cntawb_vld_thr)
                  1: (vld_cntawb_vld_thr)and(crsum_absawb_vld_thr)and(cbsum_absawb_vld_thr)</comment>
        </bits>
        <bits access="rw" name="awb_stop_sel_reg" pos="5" rst="0x1">
          <comment>0: awb_stopcb/cr
                  1:</comment>
        </bits>
        <bits access="rw" name="awb_skin_sel" pos="6" rst="0x0">
          <comment>0: use CTD block to detect skin
                  1: use cb,cr to detect skin</comment>
        </bits>
        <bits access="rw" name="awb_algo_mode" pos="7" rst="0x1">
          <comment>0: cb+cr
                  1: cb/cr</comment>
        </bits>
      </reg>
      <reg name="awb_ctrl4" protect="rw">
        <bits access="rw" name="awb_ctrl4" pos="7:0" rst="0x10">
          <comment>awb_vld_thr = [awb_ctrl4[7:0], 4'hf]</comment>
        </bits>
      </reg>
      <reg name="dig_gain_in" protect="rw">
        <bits access="rw" name="dig_gain_in" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="y_init_thr" protect="rw">
        <bits access="rw" name="y_init_mode" pos="0" rst="0x1">
          <comment>1:    0</comment>
        </bits>
        <bits access="rw" name="y_low_en" pos="1" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="y_high_en" pos="2" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="y_low_thr" pos="7:3" rst="0x8">
          <comment>y_low_thr = [1h0, y_thr_reg[7:3], 2'h0]
                  y_high_thr = ~y_low_thr</comment>
        </bits>
      </reg>
      <reg name="y_ave_target" protect="rw">
        <bits access="rw" name="y_ave_target" pos="7:0" rst="0x78">
          <comment/>
        </bits>
      </reg>
      <reg name="y_lmt_offset" protect="rw">
        <bits access="rw" name="y_low_limit" pos="2:0" rst="0x5">
          <comment>Only for awb_adj, yaveAWB
                  y_low_limit = y_ave_target - [y_lmt_offset_reg[2:0],4'd0]</comment>
        </bits>
        <bits access="rw" name="y_lmt_ofst" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="y_high_limit" pos="6:4" rst="0x6">
          <comment>Only for awb_adj, yaveAWB
                  y_high_limit = y_ave_target+ [y_lmt_offset_reg[6:4],4'd0]</comment>
        </bits>
      </reg>
      <reg name="again_sel_th2" protect="rw">
        <bits access="rw" name="ynr_gain_low_th" pos="2:0" rst="0x4">
          <comment>nexp=low_th</comment>
        </bits>
        <bits access="rw" name="again_sel_th2" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="ynr_gain_hi_th" pos="6:4" rst="0x3">
          <comment>nexp&gt;(8+high_th)</comment>
        </bits>
      </reg>
      <reg name="yave_target_chg1" protect="rw">
        <bits access="rw" name="yave_target_ofst_l" pos="3:0" rst="0x4">
          <comment>yave_target (yave_target0)</comment>
        </bits>
        <bits access="rw" name="yave_target_ofst_h" pos="7:4" rst="0x8">
          <comment>yave_target (yave_target0)</comment>
        </bits>
      </reg>
      <reg name="image_eff_reg" protect="rw">
        <bits access="rw" name="grey_en" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="sepia_en" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="negative_en" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="color_bar_en" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="image_eff_rsvd" pos="4" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="reg93_sel" pos="5" rst="0x0">
          <comment>1reg93vbright_hist</comment>
        </bits>
        <bits access="rw" name="reg94_sel" pos="6" rst="0x0">
          <comment>1reg94vdark_hist</comment>
        </bits>
        <bits access="rw" name="sharp_mon" pos="7" rst="0x0">
          <comment>display edge pixel for sharpness</comment>
        </bits>
      </reg>
      <reg name="ywave_out" protect="ro">
        <bits access="ro" name="ywave_out" pos="7:0" rst="0x0">
          <comment>Ywave+bhist histYwave</comment>
        </bits>
      </reg>
      <reg name="ae_bright_hist" protect="ro">
        <bits access="ro" name="ae_bright_hist" pos="7:0" rst="0x0">
          <comment>bright hist</comment>
        </bits>
      </reg>
      <reg name="yave_out" protect="ro">
        <bits access="ro" name="yave_out" pos="7:0" rst="0x0">
          <comment>Yave+bhisthistYave</comment>
        </bits>
      </reg>
      <reg name="exp_out" protect="ro">
        <bits access="ro" name="exp_out" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="misc_out" protect="ro">
        <bits access="ro" name="exp_out_h" pos="2:0" rst="0x1">
          <comment>exp_out[10:8]</comment>
        </bits>
        <bits access="ro" name="awb_ok" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="ro" name="nexp_sel" pos="5:4" rst="0x0">
          <comment>nexp_selbnr/dpc/int_dif</comment>
        </bits>
        <bits access="ro" name="fixed_0" pos="6" rst="0x0">
          <comment/>
        </bits>
        <bits access="ro" name="ae_ok" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="awb_debug_out" protect="ro">
        <bits access="ro" name="awb_crgt" pos="1:0" rst="0x0">
          <comment>00: cr_lt_1x     01: cr_gt_1x
                  10: cr_gt_2x    11: cr_gt_4x</comment>
        </bits>
        <bits access="ro" name="awb_cbgt" pos="3:2" rst="0x0">
          <comment>00: cb_lt_1x    01: cb_gt_1x
                  10: cb_gt_2x    11: cb_gt_4x</comment>
        </bits>
        <bits access="ro" name="awb_crsum_sign" pos="4" rst="0x0">
          <comment>0:crsum   (5R  B+4G)
                  1:crsum   (5R  B+4G)</comment>
        </bits>
        <bits access="ro" name="awb_cbsum_sign" pos="5" rst="0x0">
          <comment>0:cbsum   (3B  R+2G)
                  1:cbsum   (3B  R+2G)</comment>
        </bits>
        <bits access="ro" name="awb_cbcr" pos="6" rst="0x0">
          <comment>0: crsum_abs  cbsum_abs  (crsum)
                  1: crsum_abs  cbsum_abs  (cbsum)</comment>
        </bits>
        <bits access="ro" name="awb_sum_vld" pos="7" rst="0x0">
          <comment>ae_index
                  Note: regd[5]? ae_vbright_hist :
                  reg75[7]? ae_index[6:0] : awb_debug;</comment>
        </bits>
      </reg>
      <reg name="mono_color" protect="ro">
        <bits access="ro" name="mono_color" pos="7:0" rst="0x0">
          <comment>YUVnexp vdark_hist
                  Note:  regd[6]? ae_vdark_hist :
                         reg5F[1]? nexp[3:0] : mono_color</comment>
        </bits>
      </reg>
      <reg name="r_awb_gain" protect="ro">
        <bits access="ro" name="r_awb_gain" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="b_awb_gain" protect="ro">
        <bits access="ro" name="b_awb_gain" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="misc_status" protect="ro">
        <bits access="ro" name="ana_gain_out" pos="5:0" rst="0x0">
          <comment/>
        </bits>
        <bits access="ro" name="cc_type" pos="6" rst="0x0">
          <comment/>
        </bits>
        <bits access="ro" name="is_outdoor" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="yave_contr" protect="ro">
        <bits access="ro" name="yave_contr" pos="7:0" rst="0x0">
          <comment>yavehist
                  Vbh_sel[1]? Yave_contr_reg :
                  Vbh_sel[0]? Yave_target_RO_reg : ae_dark_hist
                  NoteVbh_sel[1:0] = reg3d[7:6]</comment>
        </bits>
      </reg>
      <reg name="gamma_type" protect="rw">
        <bits access="rw" name="gamma_type_mode" pos="2:0" rst="0x2">
          <comment>3d0:  gamma_type=0
                  3d1:  gamma_type=1
                  3d2:  gamma_type=is_outdoor
                  3d3:  gamma_type=ana_gain&gt;=gamma_gain_th
                  default:gamma_type=gamma_type_sw</comment>
        </bits>
        <bits access="rw" name="gamma_gain_hi_th" pos="5:3" rst="0x4">
          <comment>nexp&gt;(8+high_th)</comment>
        </bits>
        <bits access="rw" name="vgas" pos="7:6" rst="0x3">
          <comment>00:QVGA  240x320   01:QVGA 320x240
                  10:CIF   352x288   11:VGA  640x480</comment>
        </bits>
      </reg>
      <reg name="blc_line" protect="rw">
        <bits access="rw" name="blc_line" pos="7:0" rst="0x0">
          <comment>line_sel = [line_init_H, blc_line_reg[7:0]]</comment>
        </bits>
      </reg>
      <reg name="lsc_xx" protect="rw">
        <bits access="rw" name="x_low" pos="3:0" rst="0x8">
          <comment>lsc gain@</comment>
        </bits>
        <bits access="rw" name="x_high" pos="7:4" rst="0x8">
          <comment>lsc gain@</comment>
        </bits>
      </reg>
      <reg name="lsc_blc_gain_th" protect="rw">
        <bits access="rw" name="lsc_gain_low_th" pos="2:0" rst="0x4">
          <comment>nexp=low_th</comment>
        </bits>
        <bits access="rw" name="lsc_gain_hi_th" pos="5:3" rst="0x3">
          <comment>nexp&gt;(8+high_th)</comment>
        </bits>
        <bits access="rw" name="csup_gain_low_th" pos="7:6" rst="0x0">
          <comment>low_th = [csup_gain_low_th_H, [7:6]](nexp=low_th)</comment>
        </bits>
      </reg>
      <reg name="blc_ctrl" protect="rw">
        <bits access="rw" name="blc_out_mode" pos="1:0" rst="0x0">
          <comment>2'd0: [blc_out0_reg,blc_out1_reg] = [blc_00, blc_01]
                  2'd1: [blc_out0_reg,blc_out1_reg] = [blc_10, blc_11]
                  2'd2: [blc_out0_reg,blc_out1_reg] = [blc_00, blc_10]
                  2'd3: [blc_out0_reg,blc_out1_reg] = [blc_00, blc_11]</comment>
        </bits>
        <bits access="rw" name="line_init_h" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="blc_ofst_sign" pos="3" rst="0x0">
          <comment>0: plus   1: minus</comment>
        </bits>
        <bits access="rw" name="blc_mode" pos="5:4" rst="0x0">
          <comment>00: 1frame           01: 2frame ave
                  10: 3frame ave       11: 4frame ave</comment>
        </bits>
        <bits access="rw" name="blc_sel" pos="6" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="blc_en" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="blc_init" protect="rw">
        <bits access="rw" name="blc00_ofst" pos="3:0" rst="0x0">
          <comment>blc00_ofst =[blc_init_reg[3:0] , 1'b0]</comment>
        </bits>
        <bits access="rw" name="blc01_ofst" pos="7:4" rst="0x0">
          <comment>blc01_ofst =[blc_init_reg[7:4] , 1'b0]</comment>
        </bits>
      </reg>
      <reg name="blc_offset" protect="rw">
        <bits access="rw" name="blc10_ofst" pos="3:0" rst="0x0">
          <comment>blc10_ofst =[blc_offset_reg[3:0] , 1'b0]</comment>
        </bits>
        <bits access="rw" name="blc11_ofst" pos="7:4" rst="0x0">
          <comment>blc11_ofst =[blc_offset_reg[7:4] , 1'b0]</comment>
        </bits>
      </reg>
      <reg name="blc_thr" protect="rw">
        <bits access="rw" name="blc_thr" pos="5:0" rst="0x3e">
          <comment>High limit of black level pixel
                  blcofst</comment>
        </bits>
      </reg>
      <reg name="lsc_xy_cent" protect="rw">
        <bits access="rw" name="y_cent" pos="3:0" rst="0x4">
          <comment>y_cent=[3:0]+240</comment>
        </bits>
        <bits access="rw" name="x_cent" pos="7:4" rst="0x4">
          <comment>x_cent=[7:4]+320</comment>
        </bits>
      </reg>
      <reg name="cnr_dif_thr" protect="rw">
        <bits access="rw" name="cnr_v_en" pos="0" rst="0x1">
          <comment>CNR</comment>
        </bits>
        <bits access="rw" name="cnr_h_en" pos="1" rst="0x1">
          <comment>CNR</comment>
        </bits>
        <bits access="rw" name="vcnr_sel" pos="2" rst="0x1">
          <comment>1:  0:</comment>
        </bits>
        <bits access="rw" name="edge_mon" pos="3" rst="0x0">
          <comment>edge monitor</comment>
        </bits>
        <bits access="rw" name="awb_skin_mode" pos="6:4" rst="0x0">
          <comment>3d0: never skip           3d1: skip 2/8 skin point
                  3d2: skip 3/8 skin point  3d3: skip 4/8 skin point
                  3d4: skip 5/8 skin point  3d5: skip 6/8 skin point
                  3d6: skip 7/8 skin point  3d7: skip 8/8 skin point</comment>
        </bits>
        <bits access="ro" name="gamma_type" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="cnr_thr" protect="rw">
        <bits access="rw" name="cnr_thr_v" pos="2:0" rst="0x0">
          <comment>cnr_thr_v  = [cnr_thr[2:0], 2'd3]</comment>
        </bits>
        <bits access="rw" name="edge_en_v" pos="3" rst="0x0">
          <comment>enable</comment>
        </bits>
        <bits access="rw" name="cnr_thr_h" pos="6:4" rst="0x0">
          <comment>cnr_thr_h  = [cnr_thr[6:4], 2'd3]</comment>
        </bits>
        <bits access="rw" name="edge_en_h" pos="7" rst="0x0">
          <comment>enable</comment>
        </bits>
      </reg>
      <reg name="gamma_ctrl" protect="rw">
        <bits access="rw" name="gamma_p_id " pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gamma_l_id " pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gamma_en_non_outdoor" pos="2" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="gamma_en_outdoor" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="lsc_p_id" pos="4" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="lsc_l_id" pos="5" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="lsc_en_non_outdoor" pos="6" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="lsc_en_outdoor" pos="7" rst="0x1">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b0" protect="rw">
        <bits access="rw" name="bayer_gamma_b0" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b1" protect="rw">
        <bits access="rw" name="bayer_gamma_b1" pos="7:0" rst="0x9">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b2" protect="rw">
        <bits access="rw" name="bayer_gamma_b2" pos="7:0" rst="0x10">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b3" protect="rw">
        <bits access="rw" name="bayer_gamma_b3" pos="7:0" rst="0x16">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b4" protect="rw">
        <bits access="rw" name="bayer_gamma_b4" pos="7:0" rst="0x1c">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b6" protect="rw">
        <bits access="rw" name="bayer_gamma_b6" pos="7:0" rst="0x27">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b8" protect="rw">
        <bits access="rw" name="bayer_gamma_b8" pos="7:0" rst="0x30">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b10" protect="rw">
        <bits access="rw" name="bayer_gamma_b10" pos="7:0" rst="0x3a">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b12" protect="rw">
        <bits access="rw" name="bayer_gamma_b12" pos="7:0" rst="0x43">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b16" protect="rw">
        <bits access="rw" name="bayer_gamma_b16" pos="7:0" rst="0x54">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b20" protect="rw">
        <bits access="rw" name="bayer_gamma_b20" pos="7:0" rst="0x65">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b24" protect="rw">
        <bits access="rw" name="bayer_gamma_b24" pos="7:0" rst="0x75">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b28" protect="rw">
        <bits access="rw" name="bayer_gamma_b28" pos="7:0" rst="0x84">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b32" protect="rw">
        <bits access="rw" name="bayer_gamma_b32" pos="7:0" rst="0x93">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b36" protect="rw">
        <bits access="rw" name="bayer_gamma_b36" pos="7:0" rst="0xa1">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b40" protect="rw">
        <bits access="rw" name="bayer_gamma_b40" pos="7:0" rst="0xb0">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b48" protect="rw">
        <bits access="rw" name="bayer_gamma_b48" pos="7:0" rst="0xcb">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b56" protect="rw">
        <bits access="rw" name="bayer_gamma_b56" pos="7:0" rst="0xe6">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma_b64" protect="rw">
        <bits access="rw" name="bayer_gamma_b64" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="blc_out0" protect="ro">
        <bits access="ro" name="blc_out0" pos="7:0" rst="0x0">
          <comment>~awb_mon_sel? blc_out0_reg : kukl_sel ? kl : awb_mon_out[7:0]</comment>
        </bits>
      </reg>
      <reg name="blc_out1" protect="ro">
        <bits access="ro" name="blc_out1" pos="7:0" rst="0x0">
          <comment>~awb_mon_sel? blc_out1_reg : kukl_sel ? ku : awb_mon_out[15:8]
                   Note: awb_mon_sel = reg1[2] Kukl_sel    = reg5F[0]</comment>
        </bits>
      </reg>
      <reg name="dpc_ctrl_0" protect="rw">
        <bits access="rw" name="dpc_on" pos="0" rst="0x1">
          <comment>dpc on</comment>
        </bits>
        <bits access="rw" name="adp_med_sel" pos="1" rst="0x0">
          <comment>1: median  0:adp_median
                  sel=(nexp[3:0]&gt;dpc_ctrl0[3:2])? 1 : dpc_ctrl0[1]
                  This adp_med is used in int_dif_data and nrf_data_out</comment>
        </bits>
        <bits access="rw" name="ana_gain_cmp" pos="3:2" rst="0x2">
          <comment/>
        </bits>
        <bits access="rw" name="rsvd" pos="4" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="nrf_gaus_sel" pos="5" rst="0x0">
          <comment>1:gausian filter  0:median filter</comment>
        </bits>
        <bits access="rw" name="bayer_nr_on" pos="6" rst="0x0">
          <comment>bayer nr on</comment>
        </bits>
        <bits access="rw" name="cc_on" pos="7" rst="0x0">
          <comment>cc on</comment>
        </bits>
      </reg>
      <reg name="dpc_ctrl_1" protect="rw">
        <bits access="rw" name="int_flg_cmp" pos="1:0" rst="0x1">
          <comment>00: always not meet
          01: all round point must meet
          10: can be one except point
          11: can be two except point</comment>
        </bits>
        <bits access="rw" name="abs_sign_all_cmp" pos="3:2" rst="0x3">
          <comment>00: can be three sign diff with other
            01: can be two sign diff with other
            10: can be one sign diff with other
            11: 8 same sign</comment>
        </bits>
        <bits access="rw" name="int_dif_sel" pos="4" rst="0x0">
          <comment>1: gausian filter  0:median filter</comment>
        </bits>
      </reg>
      <reg name="y_thr_lo" protect="rw">
        <bits access="rw" name="y_thr_lo" pos="7:0" rst="0x12">
          <comment>Y_thr  @</comment>
        </bits>
      </reg>
      <reg name="y_thr_mid" protect="rw">
        <bits access="rw" name="y_thr_mid" pos="7:0" rst="0x18">
          <comment>Y_thr  @mid</comment>
        </bits>
      </reg>
      <reg name="y_thr_hi" protect="rw">
        <bits access="rw" name="y_thr_hi" pos="7:0" rst="0x18">
          <comment>Y_thr  @</comment>
        </bits>
      </reg>
      <reg name="intp_cfa_hv" protect="rw">
        <bits access="rw" name="cfa_v_thr_l" pos="2:0" rst="0x0">
          <comment>cfa_v_thr[2:0]</comment>
        </bits>
        <bits access="rw" name="rsvd1" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="cfa_h_thr_l" pos="6:4" rst="0x0">
          <comment>cfa_h_thr[2:0]</comment>
        </bits>
        <bits access="rw" name="rsvd2" pos="7" rst="0x0">
          <comment>not used here</comment>
        </bits>
      </reg>
      <reg name="manual_adj" protect="rw">
        <bits access="rw" name="b_gain_adj" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="g_gain_adj" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="r_gain_adj" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="ana_gain_adj" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="adj_direction" pos="4" rst="0x0">
          <comment>0: inc  1:dec</comment>
        </bits>
        <bits access="rw" name="index_manual_adj" pos="5" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="in_capture_awb" pos="6" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="in_capture_ae" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="dpc_int_thr_lo" protect="rw">
        <bits access="rw" name="dpc_int_thr_lo" pos="7:0" rst="0x10">
          <comment/>
        </bits>
      </reg>
      <reg name="dpc_int_thr_hi" protect="rw">
        <bits access="rw" name="dpc_int_thr_hi" pos="7:0" rst="0x30">
          <comment/>
        </bits>
      </reg>
      <reg name="again_sel_th1" protect="rw">
        <bits access="rw" name="bnr_gain_low_th" pos="2:0" rst="0x4">
          <comment>nexp=low_th @bnr/dpc/int_dif/sharp/cnr</comment>
        </bits>
        <bits access="rw" name="again_sel_th1_rsvd" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="bnr_gain_hi_th" pos="6:4" rst="0x3">
          <comment>nexp&gt;(8+high_th) @bnr/dpc/int_dif/sharp/cnr</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_lf_str_lo" protect="rw">
        <bits access="rw" name="dpc_nr_lf_str_lo" pos="7:0" rst="0x80">
          <comment>bnr low frequency str @Low gain @
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_hf_str_lo" protect="rw">
        <bits access="rw" name="dpc_nr_hf_str_lo" pos="7:0" rst="0x10">
          <comment>bnr high frequency str @Low gain
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_area_thr_lo" protect="rw">
        <bits access="rw" name="dpc_nr_area_thr_lo" pos="7:0" rst="0x80">
          <comment>4.4 format, 16x ~ 1/16x @Low gain
                  HF</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_lf_str_mid" protect="rw">
        <bits access="rw" name="dpc_nr_lf_str_mid" pos="7:0" rst="0xa0">
          <comment>bnr low frequency str @Mid gain
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_hf_str_mid" protect="rw">
        <bits access="rw" name="dpc_nr_hf_str_mid" pos="7:0" rst="0x20">
          <comment>bnr high frequency str @Mid gain
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_area_thr_mid" protect="rw">
        <bits access="rw" name="dpc_nr_area_thr_mid" pos="7:0" rst="0x80">
          <comment>4.4 format, 16x ~ 1/16x @Mid gain
                  HF</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_lf_str_hi" protect="rw">
        <bits access="rw" name="dpc_nr_lf_str_hi" pos="7:0" rst="0xc0">
          <comment>bnr low frequency str @high gain @
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_hf_str_hi" protect="rw">
        <bits access="rw" name="dpc_nr_hf_str_hi" pos="7:0" rst="0x40">
          <comment>bnr high frequency str @high gain
                  (ff)</comment>
        </bits>
      </reg>
      <reg name="dpc_nr_area_thr_hi" protect="rw">
        <bits access="rw" name="dpc_nr_area_thr_hi" pos="7:0" rst="0x80">
          <comment>4.4 format, 16x ~ 1/16x @high gain
                  HF</comment>
        </bits>
      </reg>
      <reg name="intp_ctrl" protect="rw">
        <bits access="rw" name="pid_inv_en" pos="0" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="lid_inv_en" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gfilter_en" pos="2" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="gfilter3_en" pos="3" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gfliter5_en" pos="4" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="sort_sel" pos="7:5" rst="0x3">
          <comment>0: 9        1:7
                  2: 5  3:3
                  4: median              5: adp_median</comment>
        </bits>
      </reg>
      <reg name="intp_cfa_h_thr" protect="rw">
        <bits access="rw" name="intp_cfa_h_thr" pos="7:0" rst="0x0">
          <comment>cfa_h_thr=[intp_cfa_h_thr[7:0], intp_cfa_hv[6:4]]</comment>
        </bits>
      </reg>
      <reg name="intp_cfa_v_thr" protect="rw">
        <bits access="rw" name="intp_cfa_v_thr" pos="7:0" rst="0x0">
          <comment>cfa_v_thr=[intp_cfa_v_thr[7:0], intp_cfa_hv[2:0]]</comment>
        </bits>
      </reg>
      <reg name="intp_grgb_sel_lmt" protect="rw">
        <bits access="rw" name="intp_grgb_sel_lmt" pos="7:0" rst="0x8">
          <comment/>
        </bits>
      </reg>
      <reg name="intp_gf_lmt_thr" protect="rw">
        <bits access="rw" name="intp_gf_lmt_thr" pos="7:0" rst="0x83">
          <comment>gf_lmt_thr=[3d0, intp_gf_lmt_thr_reg]</comment>
        </bits>
      </reg>
      <reg name="cc_r_offset" protect="rw">
        <bits access="rw" name="cc_r_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc_g_offset" protect="rw">
        <bits access="rw" name="cc_g_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc_b_offset" protect="rw">
        <bits access="rw" name="cc_b_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc_00" protect="rw">
        <bits access="rw" name="cc_00" pos="7:0" rst="0x58">
          <comment>S1.6 format, x1=64, cc00+cc01+cc02=1</comment>
        </bits>
      </reg>
      <reg name="cc_01" protect="rw">
        <bits access="rw" name="cc_01" pos="7:0" rst="0x90">
          <comment/>
        </bits>
      </reg>
      <reg name="cc_10" protect="rw">
        <bits access="rw" name="cc_10" pos="7:0" rst="0x88">
          <comment>S1.6 format, x1=64, cc10+cc11+cc12=1</comment>
        </bits>
      </reg>
      <reg name="cc_11" protect="rw">
        <bits access="rw" name="cc_11" pos="7:0" rst="0x50">
          <comment/>
        </bits>
      </reg>
      <reg name="cc_20" protect="rw">
        <bits access="rw" name="cc_20" pos="7:0" rst="0x88">
          <comment>S1.6 format, x1=64, cc20+cc21+cc22=1</comment>
        </bits>
      </reg>
      <reg name="cc_21" protect="rw">
        <bits access="rw" name="cc_21" pos="7:0" rst="0x90">
          <comment/>
        </bits>
      </reg>
      <reg name="cc_r_offset_post" protect="rw">
        <bits access="rw" name="cc_r_offset_post" pos="7:0" rst="0x0">
          <comment>S7 format, after cc</comment>
        </bits>
      </reg>
      <reg name="cc_g_offset_post" protect="rw">
        <bits access="rw" name="cc_g_offset_post" pos="7:0" rst="0x0">
          <comment>S7 format, after cc</comment>
        </bits>
      </reg>
      <reg name="cc_b_offset_post" protect="rw">
        <bits access="rw" name="cc_b_offset_post" pos="7:0" rst="0x0">
          <comment>S7 format, after cc</comment>
        </bits>
      </reg>
      <reg name="cc2_r_offset" protect="rw">
        <bits access="rw" name="cc2_r_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc2_g_offset" protect="rw">
        <bits access="rw" name="cc2_g_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc2_b_offset" protect="rw">
        <bits access="rw" name="cc2_b_offset" pos="7:0" rst="0x0">
          <comment>S7 format, before cc</comment>
        </bits>
      </reg>
      <reg name="cc2_00" protect="rw">
        <bits access="rw" name="cc2_00" pos="7:0" rst="0x40">
          <comment>S1.6 format, x1=64, cc00+cc01+cc02=1</comment>
        </bits>
      </reg>
      <reg name="cc2_01" protect="rw">
        <bits access="rw" name="cc2_01" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="cc2_10" protect="rw">
        <bits access="rw" name="cc2_10" pos="7:0" rst="0x0">
          <comment>S1.6 format, x1=64, cc10+cc11+cc12=1</comment>
        </bits>
      </reg>
      <reg name="cc2_11" protect="rw">
        <bits access="rw" name="cc2_11" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="cc2_20" protect="rw">
        <bits access="rw" name="cc2_20" pos="7:0" rst="0x0">
          <comment>S1.6 format, x1=64, cc20+cc21+cc22=1</comment>
        </bits>
      </reg>
      <reg name="cc2_21" protect="rw">
        <bits access="rw" name="cc2_21" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="sharp_lmt" protect="rw">
        <bits access="rw" name="sharp_lmt" pos="6:0" rst="0x7f">
          <comment>sharp data</comment>
        </bits>
        <bits access="rw" name="sharp_final_h" pos="7" rst="0x0">
          <comment>db/da/d9</comment>
        </bits>
      </reg>
      <reg name="sharp_mode" protect="rw">
        <bits access="rw" name="sharp_cmp_gap_lo" pos="3:0" rst="0x0">
          <comment>sharp_cmp&gt; (sharp_nr_area_thr[6:0]+sharp_cmp_gap)</comment>
        </bits>
        <bits access="rw" name="sharp_final" pos="5:4" rst="0x0">
          <comment>0: delay_df
                  1: delay_de
                  2: delay_dd
                  3: delay_dc</comment>
        </bits>
        <bits access="rw" name="sharp_sel" pos="6" rst="0x0">
          <comment>1:ppdif_sum
                  0:pp_dif (8)</comment>
        </bits>
        <bits access="rw" name="rgb_test_pattern" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="sharp_gain_str_lo" protect="rw">
        <bits access="rw" name="sharp_gain_str_lo" pos="7:0" rst="0x60">
          <comment>plus @Low gain (2.6 format)@</comment>
        </bits>
      </reg>
      <reg name="sharp_nr_area_thr_lo" protect="rw">
        <bits access="rw" name="sharp_nr_area_thr_lo" pos="6:0" rst="0x10">
          <comment>Sharp@Low gain
                  (edge)</comment>
        </bits>
      </reg>
      <reg name="sharp_gain_str_mid" protect="rw">
        <bits access="rw" name="sharp_gain_str_mid" pos="7:0" rst="0x60">
          <comment>plus @Mid gain (2.6 format)</comment>
        </bits>
      </reg>
      <reg name="sharp_nr_area_thr_mid" protect="rw">
        <bits access="rw" name="sharp_nr_area_thr_mid" pos="6:0" rst="0x10">
          <comment>Sharp@Mid gain
                  (edge)</comment>
        </bits>
      </reg>
      <reg name="sharp_gain_str_hi" protect="rw">
        <bits access="rw" name="sharp_gain_str_hi" pos="7:0" rst="0x60">
          <comment>plus @high gain (2.6 format)@</comment>
        </bits>
      </reg>
      <reg name="sharp_nr_area_thr_hi" protect="rw">
        <bits access="rw" name="sharp_nr_area_thr_hi" pos="6:0" rst="0x10">
          <comment>Sharp@high gain
                  (edge)</comment>
        </bits>
      </reg>
      <reg name="ynr_ctrl_reg" protect="rw">
        <bits access="rw" name="ynr_on" pos="0" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="ynr_edge_methode" pos="2:1" rst="0">
          <comment>(Ey)
        2d0:Ey_H/V/D1/D2
        2d1:
        2d2:
        2d3:</comment>
        </bits>
        <bits access="rw" name="sharp_on" pos="3" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="sharp_plus_mode" pos="5:4" rst="0">
          <comment>(sharpness)
                  00:
                  if(i_y_data8'ha0)       sharp_data = sharp_out[6:2];
                  else if(i_y_data8'h80)  sharp_data = sharp_out[6:1];
                  else                      sharp_data = sharp_out[6:0];
                  01: 0x80pixelsharpness
                  10: 0x90pixelsharpness
                  11:  No change</comment>
        </bits>
        <bits access="rw" name="y_ae_sel" pos="7:6" rst="0">
          <comment>AEYin
                  00:y=yuv_y
                  01:y=y_gamma   // after ygamma
                  10:y=luma_y_out // after y_luma
                  11:y=contr_y_out // after y_contr</comment>
        </bits>
      </reg>
      <reg name="ynr_lf_method_str" protect="rw">
        <bits access="rw" name="ynr_lf_method_str" pos="7:0" rst="0x00">
          <comment>GMYc</comment>
        </bits>
      </reg>
      <reg name="ynr_lf_str_lo" protect="rw">
        <bits access="rw" name="ynr_lf_str_lo" pos="7:0" rst="0x80">
          <comment>@low gain
                 GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_hf_str_lo" protect="rw">
        <bits access="rw" name="ynr_hf_str_lo" pos="7:0" rst="0x10">
          <comment>@low gain
               GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_area_thr_lo" protect="rw">
        <bits access="rw" name="ynr_area_thr_lo" pos="7:0" rst="0xc0">
          <comment>4.4 format, 16x ~ 1/16x @low gain
               HF</comment>
        </bits>
      </reg>
      <reg name="ynr_lf_str_mid" protect="rw">
        <bits access="rw" name="ynr_lf_str_mid" pos="7:0" rst="0xa0">
          <comment>@Mid gain
         GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_hf_str_mid" protect="rw">
        <bits access="rw" name="ynr_hf_str_mid" pos="7:0" rst="0x20">
          <comment>@Mid gain
        GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_area_thr_mid" protect="rw">
        <bits access="rw" name="ynr_area_thr_mid" pos="7:0" rst="0x80">
          <comment>4.4 format, 16x ~ 1/16x @Mid gain
                  HF</comment>
        </bits>
      </reg>
      <reg name="ynr_lf_str_hi" protect="rw">
        <bits access="rw" name="ynr_lf_str_hi" pos="7:0" rst="0xc0">
          <comment>@high gain
                GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_hf_str_hi" protect="rw">
        <bits access="rw" name="ynr_hf_str_hi" pos="7:0" rst="0x40">
          <comment>@high gain
               GMYc128Ey</comment>
        </bits>
      </reg>
      <reg name="ynr_area_thr_hi " protect="rw">
        <bits access="rw" name="ynr_area_thr_hi " pos="7:0" rst="0x20">
          <comment>4.4 format, 16x ~ 1/16x @high gain
                   HF</comment>
        </bits>
      </reg>
      <reg name="hue_sin_reg " protect="rw">
        <bits access="rw" name="hue_sin_reg " pos="7:0" rst="0x2c">
          <comment>sinx[7:0]=256*sin(x*pi/180)</comment>
        </bits>
      </reg>
      <reg name="hue_cos_reg" protect="rw">
        <bits access="rw" name="hue_cosx_reg" pos="6:0" rst="0x7c">
          <comment>cosx[7:0]=256*cos(x*pi/180)
                  cosx[7] fixed as 1, As abs(x) = pi/4</comment>
        </bits>
        <bits access="rw" name="sin_sign_reg" pos="7" rst="1">
          <comment>1: sinx is negative
        	      0: sinx is positive</comment>
        </bits>
      </reg>
      <reg name="cnr_1d_ctrl_reg" protect="rw">
        <bits access="rw" name="cnr_dif_thr_mid" pos="3:0" rst="0x8">
          <comment>CNR@Mid gain</comment>
        </bits>
        <bits access="rw" name="cnr_1d_on" pos="4" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name=" satur_on" pos="5" rst="0">
          <comment/>
        </bits>
        <bits access="rw" name="hue_on" pos="6" rst="0">
          <comment/>
        </bits>
      </reg>
      <reg name="cnr_xx_reg" protect="rw">
        <bits access="rw" name="cnr_dif_thr_low" pos="3:0" rst="0x4">
          <comment>CNR@Low gain</comment>
        </bits>
        <bits access="rw" name="cnr_dif_thr_high" pos="7:4" rst="0xc">
          <comment>CNR@High gain</comment>
        </bits>
      </reg>
      <reg name="in5_low_th_reg" protect="rw">
        <bits access="rw" name="in5_low_th_reg" pos="7:0" rst="0x40">
          <comment>Center point smaller than around, black point</comment>
        </bits>
      </reg>
      <reg name="in5_high_th_reg" protect="rw">
        <bits access="rw" name="in5_high_th_reg" pos="7:0" rst="0x90">
          <comment>Center point bigger than around, white point</comment>
        </bits>
      </reg>
      <hole size="72*32"/>
      <reg name="p2_up_r_reg" protect="rw">
        <bits access="rw" name="p2_up_r_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_up_g_reg" protect="rw">
        <bits access="rw" name="p2_up_g_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_up_b_reg" protect="rw">
        <bits access="rw" name="p2_up_b_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_down_r_reg" protect="rw">
        <bits access="rw" name="p2_down_r_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_down_g_reg" protect="rw">
        <bits access="rw" name="p2_down_g_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_down_b_reg" protect="rw">
        <bits access="rw" name="p2_down_b_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_left_r_reg" protect="rw">
        <bits access="rw" name="p2_left_r_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_left_g_reg" protect="rw">
        <bits access="rw" name="p2_left_g_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_left_b_reg" protect="rw">
        <bits access="rw" name="p2_left_b_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_right_r_reg" protect="rw">
        <bits access="rw" name="p2_right_r_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_right_g_reg" protect="rw">
        <bits access="rw" name="p2_right_g_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p2_right_b_reg" protect="rw">
        <bits access="rw" name="p2_right_b_reg" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q1_r_reg" protect="rw">
        <bits access="rw" name="p4_q1_r_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q1_g_reg" protect="rw">
        <bits access="rw" name="p4_q1_g_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q1_b_reg" protect="rw">
        <bits access="rw" name="p4_q1_b_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q2_r_reg" protect="rw">
        <bits access="rw" name="p4_q2_r_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q2_g_reg" protect="rw">
        <bits access="rw" name="p4_q2_g_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q2_b_reg" protect="rw">
        <bits access="rw" name="p4_q2_b_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q3_r_reg" protect="rw">
        <bits access="rw" name="p4_q3_r_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q3_g_reg" protect="rw">
        <bits access="rw" name="p4_q3_g_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q3_b_reg" protect="rw">
        <bits access="rw" name="p4_q3_b_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q4_r_reg" protect="rw">
        <bits access="rw" name="p4_q4_r_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q4_g_reg" protect="rw">
        <bits access="rw" name="p4_q4_g_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="p4_q4_b_reg" protect="rw">
        <bits access="rw" name="p4_q4_b_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="ae_e00_sta_reg" protect="rw">
        <bits access="rw" name="ae_e00_sta_line" pos="5:0" rst="0x2">
          <comment>E00</comment>
        </bits>
      </reg>
      <reg name="ae_e00_num_reg" protect="rw">
        <bits access="rw" name="ae_e00_num" pos="3:0" rst="0x7">
          <comment>E00</comment>
        </bits>
        <bits access="rw" name="ae_e00_interval" pos="5:4" rst="0x2">
          <comment>E00 max is 3Line</comment>
        </bits>
      </reg>
      <reg name="ae_e01_sta_reg" protect="rw">
        <bits access="rw" name="ae_e01_sta_line" pos="5:0" rst="0x10">
          <comment>E01</comment>
        </bits>
      </reg>
      <reg name="ae_e01_num_reg" protect="rw">
        <bits access="rw" name="ae_e01_num" pos="3:0" rst="0x4">
          <comment>E01</comment>
        </bits>
        <bits access="rw" name="ae_e01_interval" pos="6:4" rst="0x4">
          <comment>E01 max is 7Line</comment>
        </bits>
      </reg>
      <reg name="ae_e02_sta_reg" protect="rw">
        <bits access="rw" name="ae_e02_sta_line" pos="6:0" rst="0x20">
          <comment>E02max is 7F</comment>
        </bits>
      </reg>
      <reg name="ae_e02_num_reg" protect="rw">
        <bits access="rw" name="ae_e02_num" pos="3:0" rst="0x6">
          <comment>E02</comment>
        </bits>
        <bits access="rw" name="ae_e02_interval" pos="7:4" rst="0x8">
          <comment>E02 max is 15Line</comment>
        </bits>
      </reg>
      <reg name="ae_e1_sta_reg" protect="rw">
        <bits access="rw" name="ae_e1_sta_gain" pos="5:0" rst="0x0">
          <comment>E1 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e1_num_reg" protect="rw">
        <bits access="rw" name="ae_e1_num_reg" pos="3:0" rst="0x7">
          <comment>E1 (1E)</comment>
        </bits>
      </reg>
      <reg name="ae_e2_sta_reg" protect="rw">
        <bits access="rw" name="ae_e2_sta_gain" pos="5:0" rst="0x0">
          <comment>E2 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e2_num_reg" protect="rw">
        <bits access="rw" name="ae_e2_num_reg" pos="3:0" rst="0x4">
          <comment>E2 (2E)</comment>
        </bits>
      </reg>
      <reg name="ae_e3_sta_reg" protect="rw">
        <bits access="rw" name="ae_e3_sta_gain" pos="5:0" rst="0x0">
          <comment>E3 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e3_num_reg" protect="rw">
        <bits access="rw" name="ae_e3_num_reg" pos="3:0" rst="0x3">
          <comment>E3 (3E)</comment>
        </bits>
      </reg>
      <reg name="ae_e4_sta_reg" protect="rw">
        <bits access="rw" name="ae_e4_sta_gain" pos="5:0" rst="0x0">
          <comment>E4 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e4_num_reg" protect="rw">
        <bits access="rw" name="ae_e4_num_reg" pos="4:0" rst="0x9">
          <comment>E4 (4E)</comment>
        </bits>
      </reg>
      <reg name="ae_e5_sta_reg" protect="rw">
        <bits access="rw" name="ae_e5_sta_gain" pos="5:0" rst="0xa">
          <comment>E5 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e5_num_reg" protect="rw">
        <bits access="rw" name="ae_e5_num_reg" pos="4:0" rst="0x8">
          <comment>E5 (5E)</comment>
        </bits>
      </reg>
      <reg name="ae_e6_sta_reg" protect="rw">
        <bits access="rw" name="ae_e6_sta_gain" pos="5:0" rst="0x15">
          <comment>E6 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e6_num_reg" protect="rw">
        <bits access="rw" name="ae_e6_num_reg" pos="3:0" rst="0x6">
          <comment>E6 (6E)</comment>
        </bits>
      </reg>
      <reg name="ae_e7_sta_reg" protect="rw">
        <bits access="rw" name="ae_e7_sta_gain" pos="5:0" rst="0x1d">
          <comment>E7 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e7_num_reg" protect="rw">
        <bits access="rw" name="ae_e7_num_reg" pos="3:0" rst="0x3">
          <comment>E7 (7E)</comment>
        </bits>
      </reg>
      <reg name="ae_e8_sta_reg" protect="rw">
        <bits access="rw" name="ae_e8_sta_gain" pos="5:0" rst="0x20">
          <comment>E8 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e8_num_reg" protect="rw">
        <bits access="rw" name="ae_e8_num_reg" pos="3:0" rst="0x3">
          <comment>E8 (8E)</comment>
        </bits>
      </reg>
      <reg name="ae_e9_sta_reg" protect="rw">
        <bits access="rw" name="ae_e9_sta_gain" pos="5:0" rst="0x23">
          <comment>E9 (64)</comment>
        </bits>
      </reg>
      <reg name="ae_e9_num_reg" protect="rw">
        <bits access="rw" name="ae_e9_num_reg" pos="3:0" rst="0x3">
          <comment>E9 (9E)</comment>
        </bits>
      </reg>
      <reg name="ae_ea_sta_reg" protect="rw">
        <bits access="rw" name="ae_ea_sta_gain" pos="5:0" rst="0x26">
          <comment>Ea (64)</comment>
        </bits>
      </reg>
      <reg name="ae_ea_num_reg" protect="rw">
        <bits access="rw" name="ae_ea_num_reg" pos="3:0" rst="0x3">
          <comment>Ea (aE)</comment>
        </bits>
      </reg>
      <reg name="ae_eb_sta_reg" protect="rw">
        <bits access="rw" name="ae_eb_sta_gain" pos="5:0" rst="0x29">
          <comment>Eb (64)</comment>
        </bits>
      </reg>
      <reg name="ae_eb_num_reg" protect="rw">
        <bits access="rw" name="ae_eb_num_reg" pos="3:0" rst="0x3">
          <comment>Eb (bE)</comment>
        </bits>
      </reg>
      <reg name="ae_ec_sta_reg" protect="rw">
        <bits access="rw" name="ae_ec_sta_gain" pos="5:0" rst="0x2c">
          <comment>Ec (64)</comment>
        </bits>
      </reg>
      <reg name="ae_ec_num_reg" protect="rw">
        <bits access="rw" name="ae_ec_num_reg" pos="3:0" rst="0x5">
          <comment>Ec (cE)</comment>
        </bits>
      </reg>
      <reg name="ae_ed_sta_reg" protect="rw">
        <bits access="rw" name="ae_ed_sta_gain" pos="5:0" rst="0x0">
          <comment>Ed (64)</comment>
        </bits>
      </reg>
      <reg name="ae_ed_num_reg" protect="rw">
        <bits access="rw" name="ae_ed_num_reg" pos="3:0" rst="0x0">
          <comment>Ed (dE)</comment>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b0" protect="rw">
        <bits access="rw" name="bayer_gamma2_b0" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b1" protect="rw">
        <bits access="rw" name="bayer_gamma2_b1" pos="7:0" rst="0x20">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b2" protect="rw">
        <bits access="rw" name="bayer_gamma2_b2" pos="7:0" rst="0x2d">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b3" protect="rw">
        <bits access="rw" name="bayer_gamma2_b3" pos="7:0" rst="0x37">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b4" protect="rw">
        <bits access="rw" name="bayer_gamma2_b4" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b6" protect="rw">
        <bits access="rw" name="bayer_gamma2_b6" pos="7:0" rst="0x4e">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b8" protect="rw">
        <bits access="rw" name="bayer_gamma2_b8" pos="7:0" rst="0x5a">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b10" protect="rw">
        <bits access="rw" name="bayer_gamma2_b10" pos="7:0" rst="0x65">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b12" protect="rw">
        <bits access="rw" name="bayer_gamma2_b12" pos="7:0" rst="0x6f">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b16" protect="rw">
        <bits access="rw" name="bayer_gamma2_b16" pos="7:0" rst="0x80">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b20" protect="rw">
        <bits access="rw" name="bayer_gamma2_b20" pos="7:0" rst="0x8f">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b24" protect="rw">
        <bits access="rw" name="bayer_gamma2_b24" pos="7:0" rst="0x9c">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b28" protect="rw">
        <bits access="rw" name="bayer_gamma2_b28" pos="7:0" rst="0xa9">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b32" protect="rw">
        <bits access="rw" name="bayer_gamma2_b32" pos="7:0" rst="0xb5">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b36" protect="rw">
        <bits access="rw" name="bayer_gamma2_b36" pos="7:0" rst="0xc0">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b40" protect="rw">
        <bits access="rw" name="bayer_gamma2_b40" pos="7:0" rst="0xca">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b48" protect="rw">
        <bits access="rw" name="bayer_gamma2_b48" pos="7:0" rst="0xdd">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b56" protect="rw">
        <bits access="rw" name="bayer_gamma2_b56" pos="7:0" rst="0xef">
          <comment/>
        </bits>
      </reg>
      <reg name="bayer_gamma2_b64" protect="rw">
        <bits access="rw" name="bayer_gamma2_b64" pos="7:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="y_thr7_lo_reg" protect="rw">
        <bits access="rw" name="y_thr7_lo_reg" pos="7:0" rst="0x30">
          <comment>Y_thr7 (for 2 dead point) @</comment>
        </bits>
      </reg>
      <reg name="y_thr7_mid_reg" protect="rw">
        <bits access="rw" name="y_thr7_mid_reg" pos="7:0" rst="0x38">
          <comment>Y_thr7 (for 2 dead point) @ mid</comment>
        </bits>
      </reg>
      <reg name="y_thr7_hi_reg" protect="rw">
        <bits access="rw" name="y_thr7_hi_reg" pos="7:0" rst="0x40">
          <comment>Y_thr7 (for 2 dead point) @</comment>
        </bits>
      </reg>
      <reg name="dpa_new_ctrl_reg" protect="rw">
        <bits access="rw" name="inflg_ctrl_reg_0" pos="0" rst="0x1">
          <comment>0: check one black dead point
                   1: don't check one black dead point</comment>
        </bits>
        <bits access="rw" name="inflg_ctrl_reg_1" pos="1" rst="0x1">
          <comment>0: check 2 black dead point
                   1: don't check 2 black dead point</comment>
        </bits>
        <bits access="rw" name="inflg_ctrl_reg_2" pos="2" rst="0x1">
          <comment>0: don't check 2 dead point
              1: check 2 dead point</comment>
        </bits>
      </reg>
      <reg name="dpa_new_ctrl_hi_reg" protect="rw">
        <bits access="rw" name="inflg_ctrl_reg0_h" pos="0" rst="0x0">
          <comment>(Note)
                   0: check one black dead point
                   1: don't check one black dead point</comment>
        </bits>
        <bits access="rw" name="inflg_ctrl_reg1_h" pos="1" rst="0x0">
          <comment>(Note)
                   0: check 2 black dead point
                   1: don't check 2 black dead point</comment>
        </bits>
        <bits access="rw" name="inflg_ctrl_reg2_h" pos="2" rst="0x1">
          <comment>(Note)
                   0: don't check 2 dead point
                   1: check 2 dead point</comment>
        </bits>
        <bits access="rw" name="threshold_rsvd" pos="4:3" rst="0x2">
          <comment>not used here</comment>
        </bits>
      </reg>
      <reg name="ae_index_gap" protect="rw">
        <bits access="rw" name="gap_2e" pos="0" rst="0x0">
          <comment>2E 12</comment>
        </bits>
        <bits access="rw" name="gap_3e" pos="1" rst="0x0">
          <comment>3E 12</comment>
        </bits>
        <bits access="rw" name="gap_4e" pos="2" rst="0x0">
          <comment>4E 12</comment>
        </bits>
        <bits access="rw" name="gap_5e" pos="3" rst="0x0">
          <comment>5E 12</comment>
        </bits>
        <bits access="rw" name="gap_6e" pos="4" rst="0x0">
          <comment>6E 12</comment>
        </bits>
        <bits access="rw" name="gap_7e" pos="5" rst="0x0">
          <comment>7E 12</comment>
        </bits>
        <bits access="rw" name="gap_8e" pos="6" rst="0x0">
          <comment>8E 12</comment>
        </bits>
        <bits access="rw" name="gap_9e" pos="7" rst="0x0">
          <comment>9E 12</comment>
        </bits>
      </reg>
      <reg name="awb_calc_height_reg" protect="rw">
        <bits access="rw" name="awb_calc_height_reg" pos="7:0" rst="0xf0">
          <comment>awb_win_height = [[7:0],1'd0]
            //4:3 and keep height as even number</comment>
        </bits>
      </reg>
      <reg name="drc_r_clp_value_reg" protect="rw">
        <bits access="rw" name="drc_r_clp_value_reg" pos="5:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="drc_gr_clp_value_reg" protect="rw">
        <bits access="rw" name="drc_gr_clp_value_reg" pos="5:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="drc_gb_clp_value_reg" protect="rw">
        <bits access="rw" name="drc_gb_clp_value_reg" pos="5:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="drc_b_clp_value_reg" protect="rw">
        <bits access="rw" name="drc_b_clp_value_reg" pos="5:0" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="sepia_cr_reg" protect="rw">
        <bits access="rw" name="sepia_cr_reg" pos="7:0" rst="0xab">
          <comment>blue: 0x72  red: 0xD4  brown:0xAB</comment>
        </bits>
      </reg>
      <reg name="sepia_cb_reg" protect="rw">
        <bits access="rw" name="sepia_cb_reg" pos="7:0" rst="0x60">
          <comment>blue: 0xD4  red: 0x64  brown:0x60</comment>
        </bits>
      </reg>
      <reg name="csup_y_min_hi_reg" protect="rw">
        <bits access="rw" name="csup_y_min_hi_reg" pos="7:0" rst="0xdc">
          <comment/>
        </bits>
      </reg>
      <reg name="csup_gain_hi_reg" protect="rw">
        <bits access="rw" name="csup_gain_hi_reg" pos="7:0" rst="0x00">
          <comment>0x20~ff (x1~8) ()</comment>
        </bits>
      </reg>
      <reg name="csup_y_max_low_reg" protect="rw">
        <bits access="rw" name="csup_y_max_low_reg" pos="7:0" rst="0x40">
          <comment/>
        </bits>
      </reg>
      <reg name="csup_gain_low_reg" protect="rw">
        <bits access="rw" name="csup_gain_low_reg" pos="7:0" rst="0x00">
          <comment>0x20~ff (x1~8) ()</comment>
        </bits>
      </reg>
      <reg name="ae_dk_hist_thr_reg" protect="rw">
        <bits access="rw" name="ae_dk_hist_thr_reg" pos="7:0" rst="0x48">
          <comment>If bhist&gt;bhist_too_big_thr, then bhist_too_big</comment>
        </bits>
      </reg>
      <reg name="ae_br_hist_thr_reg" protect="rw">
        <bits access="rw" name="ae_br_hist_thr_reg" pos="7:0" rst="0x18">
          <comment>If bhist&gt;bhist_big_thr, then bhist_big</comment>
        </bits>
      </reg>
      <reg name="hist_bp_level_reg" protect="rw">
        <bits access="rw" name="hist_bp_level_reg" pos="7:0" rst="0xd0">
          <comment>Y level of bhist and 4pbhist</comment>
        </bits>
      </reg>
      <reg name="outdoor_th_reg" protect="rw">
        <bits access="rw" name="outdoor_th" pos="3:0" rst="0x4">
          <comment>outdoor_th=[outdoor_th_reg[3:0], 4'd0]</comment>
        </bits>
        <bits access="rw" name="non_outdoor_th" pos="7:4" rst="0x8">
          <comment>non_outdoor_th=[outdoor_th_reg[7:4], 4'd0]</comment>
        </bits>
      </reg>
      <reg name="awb_rgain_low_reg" protect="rw">
        <bits access="rw" name="awb_rgain_low_reg" pos="7:2" rst="0xe">
          <comment>Low limit of rgain = [[7:2], 2d0]</comment>
        </bits>
      </reg>
      <reg name="awb_rgain_high_reg" protect="rw">
        <bits access="rw" name="awb_rgain_high_reg" pos="7:2" rst="0x1c">
          <comment>High limit of rgain = [[7:2], 2d0]</comment>
        </bits>
      </reg>
      <reg name="awb_bgain_low_reg" protect="rw">
        <bits access="rw" name="awb_bgain_low_reg" pos="7:2" rst="0xe">
          <comment>Low limit of bgain = [[7:2], 2d0]</comment>
        </bits>
      </reg>
      <reg name="awb_bgain_high_reg" protect="rw">
        <bits access="rw" name="awb_bgain_high_reg" pos="7:2" rst="0x20">
          <comment>High limit of bgain = [[7:2], 2d0]</comment>
        </bits>
      </reg>
      <reg name="awb_calc_start_reg" protect="rw">
        <bits access="rw" name="awb_win_y_start" pos="3:0" rst="0x1">
          <comment>awb_win_y_start = [[3:0], 2'd0];</comment>
        </bits>
        <bits access="rw" name="awb_win_x_start" pos="7:4" rst="0x1">
          <comment>awb_win_x_start = [[7:4], 2'd0];</comment>
        </bits>
      </reg>
      <reg name="awb_calc_width_reg" protect="rw">
        <bits access="rw" name="awb_calc_width_reg" pos="7:0" rst="0xa0">
          <comment>awb_win_width =[[7:0],2'd0];
            //4:3 and keep height as even number</comment>
        </bits>
      </reg>
      <reg name="hist_dp_level_reg" protect="rw">
        <bits access="rw" name="hist_dp_level_reg" pos="7:0" rst="0x30">
          <comment>Y level of dark_hist</comment>
        </bits>
      </reg>
      <reg name="awb_y_fmin" protect="rw">
        <bits access="rw" name="awb_y_fmin" pos="7:0" rst="0x40">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_y_fmax" protect="rw">
        <bits access="rw" name="awb_y_fmax" pos="7:0" rst="0xb4">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_cb_fmin" protect="rw">
        <bits access="rw" name="awb_cb_fmin" pos="7:0" rst="0x4d">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_cb_fmax" protect="rw">
        <bits access="rw" name="awb_cb_fmax" pos="7:0" rst="0x7f">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_cr_fmin" protect="rw">
        <bits access="rw" name="awb_cr_fmin" pos="7:0" rst="0x85">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_cr_fmax" protect="rw">
        <bits access="rw" name="awb_cr_fmax" pos="7:0" rst="0xad">
          <comment>for skin</comment>
        </bits>
      </reg>
      <reg name="awb_y_fmin2" protect="rw">
        <bits access="rw" name="awb_y_fmin2" pos="7:0" rst="0x40">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="awb_y_fmax2" protect="rw">
        <bits access="rw" name="awb_y_fmax2" pos="7:0" rst="0xb4">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="awb_cb_fmin2" protect="rw">
        <bits access="rw" name="awb_cb_fmin2" pos="7:0" rst="0x34">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="awb_cb_fmax2" protect="rw">
        <bits access="rw" name="awb_cb_fmax2" pos="7:0" rst="0x5c">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="awb_cr_fmin2" protect="rw">
        <bits access="rw" name="awb_cr_fmin2" pos="7:0" rst="0x24">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="awb_cr_fmax2" protect="rw">
        <bits access="rw" name="awb_cr_fmax2" pos="7:0" rst="0x4c">
          <comment>for mono color</comment>
        </bits>
      </reg>
      <reg name="ae_use_mean" protect="rw">
        <bits access="rw" name="ycave_use_mean" pos="1:0" rst="0x3">
          <comment>0yave        1yave
                  2yave    3yave</comment>
        </bits>
        <bits access="rw" name="ywave_use_mean" pos="3:2" rst="0x3">
          <comment>0yave        1yave
                  2yave    3yave</comment>
        </bits>
        <bits access="rw" name="yave_weight_mode" pos="4" rst="0x1">
          <comment>0: win yave     1: ywave</comment>
        </bits>
        <bits access="rw" name="nexp_out_sel_reg" pos="5" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="ae_ext_adj_val_reg" pos="6" rst="0x1">
          <comment/>
        </bits>
        <bits access="rw" name="ae_ext_adj_on_reg" pos="7" rst="0x1">
          <comment/>
        </bits>
      </reg>
      <reg name="ae_weight_sta" protect="rw">
        <bits access="rw" name="ywave_pcnt_left" pos="3:0" rst="0x4">
          <comment>ae ywave</comment>
        </bits>
        <bits access="rw" name="ywave_lcnt_top" pos="7:4" rst="0x4">
          <comment>ae ywave</comment>
        </bits>
      </reg>
      <reg name="ae_qwidth" protect="rw">
        <bits access="rw" name="qwidth" pos="7:0" rst="0xa0">
          <comment>QVGA 240x320 :8d60      QVGA 320x240: 8d80
                  CIF  352x288: 8d88       VGA 640x480: 8d160</comment>
        </bits>
      </reg>
      <reg name="ae_qheight" protect="rw">
        <bits access="rw" name="qheight" pos="6:0" rst="0x78">
          <comment>QVGA 240x320 :8d80      QVGA 320x240: 8d60
                  CIF  352x288: 8d72       VGA 640x480: 8d120</comment>
        </bits>
        <bits access="rw" name="ywave_sel" pos="7" rst="0x0">
          <comment>0: x1(CIFx1)  1:x1.5</comment>
        </bits>
      </reg>
      <reg name="ae_win_sta" protect="rw">
        <bits access="rw" name="yave_pcnt_sta" pos="3:0" rst="0x2">
          <comment>yave pcnt_sta=[[3:0], 1b0]</comment>
        </bits>
        <bits access="rw" name="yave_lcnt_sta" pos="7:4" rst="0x2">
          <comment>yave lcnt_sta=[[7:4], 1b0]</comment>
        </bits>
      </reg>
      <reg name="ae_width" protect="rw">
        <bits access="rw" name="width" pos="7:0" rst="0x95">
          <comment>yave Width=[[7:0],  2d0]
                  QVGA 240x320 :10d216     QVGA 320x240: 10d304
                  CIF  352x288: 10d304      VGA 640x480: 10d596</comment>
        </bits>
      </reg>
      <reg name="ae_height" protect="rw">
        <bits access="rw" name="height" pos="7:0" rst="0xdc">
          <comment>yave Height=[[7:0], 1d0]
                  QVGA 240x320 :10d304     QVGA 320x240: 10d216
                  CIF   352x288: 10d216      VGA 640x480: 10d440</comment>
        </bits>
      </reg>
      <reg name="sw_update" protect="rw">
        <bits access="rw" name="cc_type_sw" pos="0" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="is_outdoor_sw" pos="1" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="gamma_type_sw" pos="2" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="sw_update_rsvd" pos="3" rst="0x0">
          <comment>not used here</comment>
        </bits>
        <bits access="rw" name="is_outdoor_mode" pos="6:4" rst="0x0">
          <comment>3'd0:   is_outdoor = 0;
                  3'd1:   is_outdoor = 1;
                  3'd2:
                       if(ana_gain==0) begin
                         if(expoutdoor_th)          is_outdoor = 1;
                         else if(expnon_outdoor_th) is_outdoor = 0;    end
                       else                           is_outdoor = 0;
                  3'd3:
                       if(ana_gain==0 and rgain_bigger) begin
                         if(expoutdoor_th)          is_outdoor = 1;
                         else if(expnon_outdoor_th) is_outdoor = 0;   end
                       else                           is_outdoor = 0;
                 default:
                       if(vsync_rp_d and sw_update_en)    is_outdoor = is_outdoor_sw;</comment>
        </bits>
        <bits access="rw" name="awb_outdoor_en" pos="7" rst="0x0">
          <comment>1: when is_outdoor=1, only detect white point at D65 and Indoor CTD block
                  0: dont care is_outdoor, detect white point at all ctd block</comment>
        </bits>
      </reg>
      <reg name="awb_ctrl5" protect="rw">
        <bits access="rw" name="r_low_non_a" pos="7:0" rst="0x3c">
          <comment/>
        </bits>
      </reg>
      <reg name="awb_ctrl6" protect="rw">
        <bits access="rw" name="awb_stop_h" pos="3:0" rst="0x0">
          <comment>awb_stop_cr_pos_level =[[3],awb_stop_reg[7:6]];
                  awb_stop_cr_neg_level =[[2],awb_stop_reg[5:4]];
                  awb_stop_cb_pos_level =[[1],awb_stop_reg[3:2]];
                  awb_stop_cb_neg_level =[[0],awb_stop_reg[1:0]];</comment>
        </bits>
        <bits access="rw" name="awb_adj_again" pos="5:4" rst="0x0">
          <comment>awb_adj_again = [2'b11, [5:4]]</comment>
        </bits>
        <bits access="rw" name="awb_algo_en" pos="6" rst="0x0">
          <comment>1: add awb_algo_thr condition to detect white point@A
                  0: detect white point according to A ctd block</comment>
        </bits>
        <bits access="rw" name="check_r_low" pos="7" rst="0x0">
          <comment/>
        </bits>
      </reg>
      <reg name="sca_reg" protect="rw">
        <bits access="rw" name="sca_mode" pos="2:0" rst="0x0">
          <comment>0: normal(no scale)
                  1: sub(yuv sub mode)
                  2: sca_320x240(1/2)
                  3: sca_176x144(1/3)
                  4: sca_160x120(1/4)
                  5: sca352x288(2/3)
                  6: sca352x288(3/5)
                  7: 3/4</comment>
        </bits>
      </reg>
      <reg name="ae_ee_sta_reg" protect="rw">
        <bits access="rw" name="ae_ee_sta_gain" pos="5:0" rst="0x0">
          <comment>Ee (64)</comment>
        </bits>
      </reg>
      <reg name="ae_ee_num_reg" protect="rw">
        <bits access="rw" name="ae_ee_num_reg" pos="3:0" rst="0x0">
          <comment>Ee (eE)</comment>
        </bits>
      </reg>
      <reg name="ae_ef_sta_reg" protect="rw">
        <bits access="rw" name="ae_ef_sta_gain" pos="5:0" rst="0x0">
          <comment>Ef (64)</comment>
        </bits>
      </reg>
      <reg name="ae_ef_num_reg" protect="rw">
        <bits access="rw" name="ae_ef_num_reg" pos="3:0" rst="0x0">
          <comment>Ef (fE)</comment>
        </bits>
      </reg>
      <reg name="ae_thr_big_reg" protect="rw">
        <bits access="rw" name="ae_thr_big_dark" pos="3:0" rst="0x6">
          <comment>ae_thr_big = [reg1CA[3:0],2d0]@dark</comment>
        </bits>
        <bits access="rw" name="ae_thr_big_bright" pos="7:4" rst="0x8">
          <comment>ae_thr_big = [reg1CA[7:4],2d0]@bright</comment>
        </bits>
      </reg>
      <reg name="sharp_gain_minus_low" protect="rw">
        <bits access="rw" name="sharp_gain_minus_low" pos="7:0" rst="0x70">
          <comment>sharp gain @low gain(2.6 format)</comment>
        </bits>
      </reg>
      <reg name="sharp_gain_minus_mid" protect="rw">
        <bits access="rw" name="sharp_gain_minus_mid" pos="7:0" rst="0x90">
          <comment>sharp gain @medium gain(2.6 format)</comment>
        </bits>
      </reg>
      <reg name="sharp_gain_minus_hi" protect="rw">
        <bits access="rw" name="sharp_gain_minus_hi" pos="7:0" rst="0xb0">
          <comment>sharp gain @high gain(2.6 format)</comment>
        </bits>
      </reg>
      <reg name="sharp_mode_mid_hi" protect="rw">
        <bits access="rw" name="sharp_cmp_gap_mid" pos="3:0" rst="0x8">
          <comment>sharp_cmp&gt; (sharp_nr_area_thr[6:0]+sharp_cmp_gap)</comment>
        </bits>
        <bits access="rw" name="sharp_cmp_gap_hi" pos="7:4" rst="0x8">
          <comment>sharp_cmp&gt; (sharp_nr_area_thr[6:0]+sharp_cmp_gap)</comment>
        </bits>
      </reg>
      <reg name="fw_version_reg" protect="rw">
        <bits access="rw" name="fw_version" pos="7:0" rst="0x00">
          <comment/>
        </bits>
      </reg>
      <reg name="awb_y_min_reg" protect="rw">
        <bits access="rw" name="awb_y_min" pos="7:0" rst="0x40">
          <comment>Y = Y_min ( AWB)</comment>
        </bits>
      </reg>
      <reg name="y_red_coef_reg" protect="rw">
        <bits access="rw" name="y_red_coef" pos="7:0" rst="0x4d">
          <comment/>
        </bits>
      </reg>
      <reg name="y_blue_coef_reg" protect="rw">
        <bits access="rw" name="y_blue_coef" pos="7:0" rst="0x1d">
          <comment/>
        </bits>
      </reg>
      <reg name="cb_red_coef_reg" protect="rw">
        <bits access="rw" name="cb_red_coef" pos="7:0" rst="0x2b">
          <comment/>
        </bits>
      </reg>
      <reg name="cr_blue_coef_reg" protect="rw">
        <bits access="rw" name="cr_blue_coef" pos="7:0" rst="0x15">
          <comment/>
        </bits>
      </reg>
      <reg name="hist_vbp_level_reg" protect="rw">
        <bits access="rw" name="hist_vbp_level" pos="7:0" rst="0xd8">
          <comment>Y level of vbright_hist</comment>
        </bits>
      </reg>
      <reg name="hist_vdp_level_reg" protect="rw">
        <bits access="rw" name="hist_vdp_level" pos="7:0" rst="0x18">
          <comment>Y level of vdark_hist</comment>
        </bits>
      </reg>
      <hole size="40*32"/>
    </module>
    <instance address="0x04404000" name="CAMERA" type="CAMERA"/>
  </archive>
  <archive relative="cp_ifc.xml">
    <var name="CP_NB_BITS_ADDR" value="32"/>
    <var name="CP_IFC_ADDR_ALIGN" value="0"/>
    <var name="CP_IFC_TC_LEN" value="23"/>
    <var name="CP_IFC_STD_CHAN_NB" value="4"/>
    <var name="CP_IFC_RFSPI_CHAN" value="0"/>
    <var name="CP_IFC_AIF_CHAN" value="0"/>
    <var name="CP_IFC_DBG_CHAN" value="0"/>
    <enum name="CP_IFC_Request_IDs">
      <entry name="DMA_ID_TX_SCI1"/>
      <entry name="DMA_ID_RX_SCI1"/>
      <entry name="DMA_ID_TX_SCI2"/>
      <entry name="DMA_ID_RX_SCI2"/>
    </enum>
    <module category="System" name="CP_IFC">
      <reg name="get_ch" protect="--">
        <bits access="r" name="ch_to_use" pos="4:0" rst="0">
          <comment>
            This field indicates which standard channel to use.
            <br/>
             Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
            <br/>
             After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
            <br/>
            Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
            <br/>
            Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
            <br/>
            When non-secure cpu read this register, the return value will automatic exlude the secure channel.
            <br/>
            00000 = use Channel0
            <br/>
            00001 = use Channel1
            <br/>
            00010 = use Channel2
            <br/>
             ...
            <br/>
            01111 = use Channel15
            <br/>
            11111 = all channels are busy
          </comment>
          <options>
            <mask/>
            <shift/>
            <default/>
          </options>
        </bits>
      </reg>
      <reg name="dma_status" protect="r">
        <bits access="r" name="ch_enable" pos="CP_IFC_STD_CHAN_NB+CP_IFC_RFSPI_CHAN-1:0" rst="0">
          <comment>
            This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels disabled
            <br/>
            0000_0001 = Ch0 enabled
            <br/>
            0000_0010 = Ch1 enabled
            <br/>
            0000_0100 = Ch2 enabled
            <br/>
            0000_0101 = Ch0 and Ch2 enabled
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 enabled
            <br/>
            all 1     = all channels enabled
          </comment>
        </bits>
        <bits access="r" name="ch_busy" pos="CP_IFC_STD_CHAN_NB-1+16:16" rst="0">
          <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
        </bits>
      </reg>
      <reg name="debug_status" protect="r">
        <bits access="r" name="dbg_status" pos="0" rst="1">
          <comment>
            Debug Channel Status .
            <br/>
            0= The debug channel is running
      (not idle)
            <br/>
            1= The debug channel is in idle mode
          </comment>
        </bits>
      </reg>
      <reg name="ifc_sec" protect="rw">
        <bits access="rw" name="std_ch_reg_sec" pos="CP_IFC_STD_CHAN_NB-1:0" rst="0">
          <comment>
            This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels registers can be accessed by secure master or non-secure master.
            <br/>
            0000_0001 = Ch0 registers can only be accessed by secure master.
            <br/>
            0000_0010 = Ch1 registers can only be accessed by secure master.
            <br/>
            0000_0100 = Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels registers can only be accessed by secure master.
          </comment>
        </bits>
        <bits access="rw" name="std_ch_dma_sec" pos="CP_IFC_STD_CHAN_NB-1+16:16" rst="all1">
          <comment>
            This register indicates which channel dma is secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels dma are non-secure master.
            <br/>
            0000_0001 = Ch0 dma is secure master.
            <br/>
            0000_0010 = Ch1 dma is secure master.
            <br/>
            0000_0100 = Ch2 dma is secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 dma are secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels dma are secure master.
          </comment>
        </bits>
      </reg>
      <struct count="CP_IFC_STD_CHAN_NB" name="std_ch">
        <reg name="control" protect="rw">
          <bits access="w" name="enable" pos="0" rst="no">
            <comment>
              Channel Enable, write one in this bit enable the channel.
              <br/>
              When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer.
            </comment>
          </bits>
          <bits access="w" name="disable" pos="1" rst="no">
            <comment>
              Channel Disable, write one in this bit disable the channel.
              <br/>
              When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled.
            </comment>
          </bits>
          <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
            <comment>
              Exchange the read data from fifo halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
            <comment>
              Exchange the write data to fifo  halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="autodisable" pos="4" rst="1">
            <comment>
              Set Auto-disable mode
              <br/>
               0 = when TC reach zero the
        channel is not automatically released.
              <br/>
               1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.
            </comment>
          </bits>
          <bits access="rw" name="size" pos="5" rst="0">
            <comment>
              Peripheral Size
              <br/>
               0= 8-bit peripheral
              <br/>
               1= 32-bit peripheral
            </comment>
          </bits>
          <bits access="rw" display="hex" name="req_src" pos="12:8" rst="0x1F">
            <options linkenum="CP_IFC_Request_IDs">
              <shift/>
              <mask/>
              <default/>
            </options>
            <comment>Select DMA Request source</comment>
          </bits>
          <bits access="rw" name="flush" pos="16" rst="0">
            <comment>
              When one, flush the internal FIFO channel.
              <br/>
              This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel.
              <br/>
               Before writting back this bit to zero the internal fifo must empty.
            </comment>
          </bits>
          <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
            <comment>
              Set the MAX burst length for channel 0,1.
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.
              <br/>
               The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4.
              <br/>
               .
            </comment>
          </bits>
        </reg>
        <reg name="status" protect="r">
          <bits access="r" name="enable" pos="0" rst="0">
            <comment>Enable bit, when '1' the channel is running</comment>
          </bits>
          <bits access="r" name="fifo_empty" pos="4" rst="1">
            <comment>The internal channel fifo is empty</comment>
          </bits>
        </reg>
        <reg name="start_addr" protect="rw">
          <bits access="rw" display="hex" name="start_addr" pos="CP_NB_BITS_ADDR-1:CP_IFC_ADDR_ALIGN" rst="0xFFFFFFF">
            <comment>
              AHB Address. This field represent the start address of the
        transfer.
              <br/>
              For a 32-bit peripheral, this address must be aligned 32-bit.
            </comment>
          </bits>
        </reg>
        <reg name="tc" protect="rw">
          <bits access="rw" display="hex" name="tc" pos="CP_IFC_TC_LEN-1:0" rst="0xFFFFFF">
            <comment>
              Transfer Count, this field indicated the transfer size in bytes to perform.
              <br/>
              During a transfer a write in this register add the new value to the current TC.
              <br/>
              A read of this register return the current current transfer count.
            </comment>
          </bits>
        </reg>
        <reg name="tc_threshold" protect="rw">
          <bits access="rw" display="hex" name="tc_threshold" pos="CP_IFC_TC_LEN-1:0" rst="0x0">
            <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.</comment>
          </bits>
        </reg>
      </struct>
    </module>
    <instance address="0x14002000" name="CP_IFC" type="CP_IFC"/>
  </archive>
  <archive relative="debug_host.xml">
    <module category="Debug" name="DEBUG_HOST">
      <reg name="cmd" protect="--">
        <bits access="r" name="addr" pos="28:0" rst="-">
          <comment>Address of data to be read or written.</comment>
        </bits>
        <bits access="r" name="size" pos="30:29" rst="-">
          <comment>
            These two bits indicates element data size.
            <br/>
            when &quot;00&quot; = &quot;byte&quot;.
            <br/>
            when &quot;01&quot; = &quot;half word&quot;.
            <br/>
            when &quot;10&quot; = &quot;word&quot;.
          </comment>
        </bits>
        <bits access="r" name="write_h" pos="31" rst="-">
          <comment>
            This bit indicates command is read or write.
            <br/>
        when &quot;0&quot; = &quot;Read&quot;.
            <br/>
        when &quot;1&quot; = &quot;Write&quot;.
          </comment>
        </bits>
      </reg>
      <reg name="data" protect="--">
        <comment>Those bits are data to be read or written by IFC.</comment>
      </reg>
      <reg name="event" protect="rw">
        <bits access="rw" name="event0_sema" pos="0" rst="0">
          <comment>
            When read, this bit is used for event semaphore.
            <br/>
            '0' = no new event should be programed.
            <br/>
            '1' = no pending event, new event is authorised.
            <br/>
            If host is not enabled, this bit is always '1'. However in this case,
            any event written will be ignored.
            <br/>
            When Write, this bit is the least significant bit for a 32-bit event.
          </comment>
        </bits>
        <bits access="w" name="event31_1" pos="31:1" rst="-">
          <comment>These bits combined with bit0 consists a 32-bit event number. If a
            new event is written before the previous event has been sent, it will
            be ignored.</comment>
        </bits>
      </reg>
      <reg name="mode" protect="rw">
        <bits access="rw" name="force_on" pos="0" rst="1">
          <comment>When '1', force the debug host on, use clock UART if clock host is not
            detected.</comment>
        </bits>
        <bits access="r" name="clk_host_on" pos="1" rst="0">
          <comment>
            This bit indicates if clock host is detected to be on or not.
            <br/>
            '0' = no clock host.
            <br/>
            '1' = clock host detected.
          </comment>
        </bits>
      </reg>
      <reg name="h2p_status" protect="rw">
        <bits access="r" name="h2p_status" pos="7:0" rst="0">
          <comment>Status which can be written through debug uart interface into a debug host
            internal register and read by APB.</comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="w" name="h2p_status_rst" pos="16" rst="0">
          <comment>write in this bit will reset h2p status register.</comment>
        </bits>
      </reg>
      <reg name="p2h_status" protect="rw">
        <bits access="rw" name="p2h_status" pos="7:0" rst="0">
          <comment>Status which can be written by APB and read through debug uart interface
            as a debug host internal register.</comment>
        </bits>
      </reg>
      <reg name="irq" protect="r">
        <bits access="r" name="xcpu_irq" pos="0" rst="0">
          <comment>
            when write '1', clear the xcpu irq level which is programmed in a debug host
          internal register, this bit is automatic cleared.
            <br/>
             when read, get the xcpu
          irq status.
          </comment>
        </bits>
        <bits access="r" name="bcpu_irq" pos="1" rst="0">
          <comment>
            when write '1', clear the bcpu irq level which is programmed in a debug host
            internal register, this bit is automatic cleared.
            <br/>
             when read, get the bcpu
            irq status.
          </comment>
        </bits>
      </reg>
    </module>
    <instance address="0x5140f000" name="DEBUG_HOST" type="DEBUG_HOST"/>
  </archive>
  <archive relative="debug_uart.xml">
    <module category="System" name="DEBUG_UART">
      <var name="DEBUG_UART_RX_FIFO_SIZE" value="16"/>
      <var name="DEBUG_UART_TX_FIFO_SIZE" value="16"/>
      <var name="DEBUG_UART_NB_RX_FIFO_BITS" value="4"/>
      <var name="DEBUG_UART_NB_TX_FIFO_BITS" value="4"/>
      <var name="ESC_DAT" value="92"/>
      <reg name="ctrl" protect="rw">
        <bits access="rw" name="enable" pos="0" rst="0">
          <options>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
            <default/>
          </options>
          <comment>
            Allows to turn off the UART:
            <br/>
            0 = Disable
            <br/>
            1 = Enable
          </comment>
        </bits>
        <bits access="rw" name="data bits" pos="1" rst="0">
          <options>
            <option name="7_BITS" value="0"/>
            <option name="8_BITS" value="1"/>
            <default/>
          </options>
          <comment>
            Number of data bits per character (least significant bit
          first):
            <br/>
            0 = 7 bits
            <br/>
            1 = 8 bits
            <br/>
             This bit will be masked to
          '1' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="tx stop bits" pos="2" rst="0">
          <options>
            <option name="1_BIT" value="0"/>
            <option name="2_BITS" value="1"/>
            <default/>
          </options>
          <comment>
            Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).
            <br/>
            0 = one stop bit is
      transmitted in the serial data.
            <br/>
            1 = two stop bits are generated and
      transmitted in the serial data out.
            <br/>
             This bit will be masked to
      '0' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="parity enable" pos="3" rst="0">
          <options>
            <option name="NO" value="0"/>
            <option name="YES" value="1"/>
            <default/>
          </options>
          <comment>
            Parity is enabled when this bit is set.
            <br/>
             This bit will be masked to
      '0' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="parity select" pos="5:4" rst="0">
          <options>
            <option name="ODD" value="0"/>
            <option name="EVEN" value="1"/>
            <option name="SPACE" value="2"/>
            <option name="MARK" value="3"/>
            <default/>
          </options>
          <comment>
            Controls the parity format when parity is enabled:
            <br/>
            00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).
            <br/>
            01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).
            <br/>
            10 = a space is
      generated and received as parity bit.
            <br/>
            11 = a mark is generated and
      received as parity bit.
            <br/>
             These bit will be ignored if debug host is
      enabled.
          </comment>
        </bits>
        <bits access="rw" name="tx break control" pos="6" rst="0">
          <comment>
            Sends a break signal by holding the Uart_Tx line low until
          this bit is cleared.
            <br/>
             This bit will be masked to '0' if debug host
          is enabled.
          </comment>
          <options>
            <option name="OFF" value="0"/>
            <option name="ON" value="1"/>
            <default/>
          </options>
        </bits>
        <bits access="rw" name="rx fifo reset" pos="7" rst="0">
          <comment>reset rx fifo.</comment>
        </bits>
        <bits access="rw" name="tx fifo reset" pos="8" rst="0">
          <comment>reset tx fifo.</comment>
        </bits>
        <bits access="rw" name="dma mode" pos="9" rst="0">
          <options>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
            <default/>
          </options>
          <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC.</comment>
        </bits>
        <bits access="rw" name="swrx flow ctrl" pos="13:12" rst="1">
          <comment>
            When this field is &quot;00&quot; and SWTX_flow_Ctrl is also &quot;00&quot;, hardwre
            flow ctrl is used. Otherwise, software flow control is used:
            <br/>
            00 = no transmit flow control.
            <br/>
            01 = transmit XON1/XOFF1 as flow control bytes
            <br/>
            10 = transmit XON2/XOFF2 as flow control bytes
            <br/>
            11 = transmit XON1 and XON2/XOFF1 and XOFF2 as flow control bytes
            <br/>
          </comment>
          <options>
            <default/>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="swtx flow ctrl" pos="15:14" rst="1">
          <comment>
            When this field is &quot;00&quot; and SWRX_flow_Ctrl is also &quot;00&quot;, hardwre
            flow ctrl is used. Otherwise, software flow control is used:
            <br/>
            00 = no receive flow control
            <br/>
            01 = receive XON1/XOFF1 as flow control bytes
            <br/>
            10 = receive XON2/XOFF2 as flow control bytes
            <br/>
            11 = receive XON1 and XON2/XOFF1 and XOFF2 as flow control bytes
            <br/>
            <br/>
             Note: If single XON/XOFF character is used for flow contol, the received
            XON/XOFF character will not be put into Rx FIFO. This is also the case if XON is
            received when XOFF is expected.
            <br/>
            If double XON/XOFF characters are expected, the XON1/XOFF1 must followed sequently
            by XON2/XOFF2 to be considered as patterns, which will not be put into Rx FIFO.
            Otherwise they will be considered as data. This is also the case if XOFF1 is followed
            by character other than XOFF2.
            <br/>
          </comment>
          <options>
            <default/>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="backslash en" pos="16" rst="1">
          <comment>When soft flow control characters or backslash are encountered in the data file,
            they will be inverted and a backslash will be added before them. for example, if tx data
            is XON(0x11) with BackSlash_En = '1', then uart will send 5Ch(Backslash) + EEh (~XON).</comment>
        </bits>
        <bits access="rw" name="tx finish n wait" pos="19" rst="0">
          <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
        </bits>
        <bits access="rw" name="divisor mode" pos="20" rst="0">
          <comment>
            Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.
            <br/>
            0 =
      (BCLK = SCLK / 4)
            <br/>
            1 = (BCLK = SCLK / 16)
            <br/>
             This bit will be
      masked to '0' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="irda enable" pos="21" rst="0">
          <comment>
            When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details).
            <br/>
             This bit will be
      masked to '0' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="rx rts" pos="22" rst="0">
          <comment>
            Controls the Uart_RTS output (not directly in auto flow control
      mode).
            <br/>
            0 = the Uart_RTS will be inactive high
            <br/>
            1 = the Uart_RTS
      will be active low
            <br/>
             This bit will be masked to '1' if debug host is
      enabled.
          </comment>
          <options>
            <option name="INACTIVE" value="0"/>
            <option name="ACTIVE" value="1"/>
            <default/>
          </options>
        </bits>
        <bits access="rw" name="auto flow control" pos="23" rst="0">
          <options>
            <option name="ENABLE" value="1"/>
            <option name="DISABLE" value="0"/>
            <default/>
          </options>
          <comment>
            Enables the auto flow control.
            <br/>
          In case HW flow control (both swTx_Flow_ctrl=0 and swRx_Flow_Ctrl=0),
          If Auto_Flow_Control is enabled, Uart_RTS is controlled by the Rx RTS bit in
          CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register).
          Tx data flow is stopped If Uart_CTS become inactive high.
            <br/>
          If Auto_Flow_Control is disabled, Uart_RTS is controlled only by the Rx RTS
          bit in CMD_Set register. Uart_CTS will not take effect.
            <br/>
            <br/>
          In case SW flow control(either swTx_Flow_ctrl/=0 or swRx_Flow_Ctrl/=0),
          If Auto_Flow_Control is enabled, XON/XOFF will be controlled by the Rx RTS bit
          in CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register).
            <br/>
          If Auto_Flow_Control is disabled, XON/XOFF will be controlled only by Rx RTS bit
          in CMD_Set register. Tx data flow will be stoped when XOFF is received either
          this bit is enable or disabled.
            <br/>
            <br/>
             This bit will be masked to '1' if debug host is enabled.
          </comment>
        </bits>
        <bits access="rw" name="loop back mode" pos="24" rst="0">
          <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support).</comment>
        </bits>
        <bits access="rw" name="rx lock err" pos="25" rst="0">
          <comment>
            Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept.
            <br/>
             This bit
      will be masked to '0' if debug host is enabled.
          </comment>
          <options>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
            <default/>
          </options>
        </bits>
        <bits access="rw" name="hst txd oen" pos="26" rst="0">
          <comment>HST TXD output enable. '0' enable.</comment>
          <options>
            <option name="DISABLE" value="1"/>
            <option name="ENABLE" value="0"/>
            <default/>
          </options>
        </bits>
        <bits access="rw" name="rx break length" pos="31:28" rst="0xF">
          <comment>
            Length of a break, in number of bits.
            <br/>
             This bit will be masked
      to &quot;1011&quot; if debug host is enabled.
          </comment>
        </bits>
      </reg>
      <reg name="status" protect="r">
        <bits access="r" name="rx fifo level" pos="4:0" rst="0">
          <options>
            <mask/>
            <shift/>
          </options>
          <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read.</comment>
        </bits>
        <bits access="r" name="tx fifo level" pos="12:8" rst="0">
          <options>
            <mask/>
            <shift/>
          </options>
          <comment>Those bits indicate the number of data available in the Tx
      Fifo. Those data will be sent.</comment>
        </bits>
        <bits access="r" name="tx active" pos="13" rst="0">
          <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface.</comment>
        </bits>
        <bits access="r" name="rx active" pos="14" rst="0">
          <comment>This bit indicates that the UART is receiving a byte.</comment>
        </bits>
        <bits access="r" name="rx overflow err" pos="16" rst="0">
          <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="tx overflow err" pos="17" rst="0">
          <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when
          the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx parity err" pos="18" rst="0">
          <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx framing err" pos="19" rst="0">
          <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value.</comment>
        </bits>
        <bits access="r" name="rx break int" pos="20" rst="0">
          <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value.</comment>
        </bits>
        <bits access="r" name="tx dcts" pos="24" rst="0">
          <comment>
            In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0),
            This bit is set when the Uart_CTS line changed since the last
            time this register has been written.
            <br/>
            In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0),
            This bit is set when received XON/XOFF status changed since the last time
            this register has been writtern.
            <br/>
            This bit is cleared when the UART_STATUS register is written with any value.
          </comment>
        </bits>
        <bits access="r" name="tx cts" pos="25" rst="0">
          <comment>
            In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0),
            current value of the Uart_CTS line.
            <br/>
             '1' = Tx not allowed.
            <br/>
             '0' = Tx allowed.
            <br/>
            In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0),
            current state of software flow control.
            <br/>
             '1' = when XOFF received.
            <br/>
             '0' = when XON received.
          </comment>
        </bits>
        <bits access="r" name="tx fifo rsted l" pos="28" rst="0">
          <comment>This bit is set when Tx Fifo Reset command is received by CTRL
      register and is cleared when Tx fifo reset process has finished.</comment>
        </bits>
        <bits access="r" name="rx fifo rsted l" pos="29" rst="0">
          <comment>This bit is set when Rx Fifo Reset command is received by CTRL
      register and is cleared when Rx fifo reset process has finished.</comment>
        </bits>
        <bits access="r" name="enable n finished" pos="30" rst="0">
          <comment>This bit is set when bit enable is changed from '0' to '1' or
      from '1' to '0', it is cleared when the enable process has finished.</comment>
        </bits>
        <bits access="r" name="clk enabled" pos="31" rst="0">
          <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      Rx RTS too early.</comment>
        </bits>
      </reg>
      <reg name="rxtx_buffer" protect="--">
        <bits access="r" name="rx data" pos="7:0" rst="no">
          <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur.</comment>
        </bits>
        <bits access="w" name="tx data" pos="7:0" rst="no">
          <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost.</comment>
        </bits>
      </reg>
      <reg name="irq_mask" protect="rw">
        <bits access="rw" name="tx modem status" pos="0" rst="0">
          <comment>Clear to send signal change or XON/XOFF detected.</comment>
        </bits>
        <bits access="rw" name="rx data available" pos="1" rst="0">
          <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level).</comment>
        </bits>
        <bits access="rw" name="tx data needed" pos="2" rst="0">
          <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level).</comment>
        </bits>
        <bits access="rw" name="rx timeout" pos="3" rst="0">
          <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time.</comment>
        </bits>
        <bits access="rw" name="rx line err" pos="4" rst="0">
          <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt.</comment>
        </bits>
        <bits access="rw" name="tx dma done" pos="5" rst="0">
          <comment>Pulse detected on Uart_Dma_Tx_Done_H signal.</comment>
        </bits>
        <bits access="rw" name="rx dma done" pos="6" rst="0">
          <comment>Pulse detected on Uart_Dma_Rx_Done_H signal.</comment>
        </bits>
        <bits access="rw" name="rx dma timeout" pos="7" rst="0">
          <comment>In DMA mode, there is at least 1 character that has been read
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.</comment>
        </bits>
        <bits access="rw" name="xoff_detected" pos="8" rst="0">
    </bits>
      </reg>
      <reg name="irq_cause" protect="rw">
        <bits access="r" name="tx modem status" pos="0" rst="0">
          <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx data available" pos="1" rst="0">
          <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level.</comment>
        </bits>
        <bits access="r" name="tx data needed" pos="2" rst="0">
          <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level.</comment>
        </bits>
        <bits access="r" name="rx timeout" pos="3" rst="0">
          <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.</comment>
        </bits>
        <bits access="r" name="rx line err" pos="4" rst="0">
          <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value.</comment>
        </bits>
        <bits access="rw" name="tx dma done" pos="5" rst="0">
          <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="rx dma done" pos="6" rst="0">
          <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="rx dma timeout" pos="7" rst="0">
          <comment>In DMA mode, there is at least 1 character that has been read
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.</comment>
        </bits>
        <bits access="r" name="tx modem status u" pos="16" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx data available u" pos="17" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="tx data needed u" pos="18" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx timeout u" pos="19" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx line err u" pos="20" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="tx dma done u" pos="21" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx dma done u" pos="22" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx dma timeout u" pos="23" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
      </reg>
      <reg name="triggers" protect="rw">
        <bits access="rw" name="rx trigger" pos="3:0" rst="0">
          <comment>
            Defines the threshold level at which the Data Available
      Interrupt will be generated.
            <br/>
            The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.
          </comment>
        </bits>
        <bits access="rw" name="tx trigger" pos="7:4" rst="0">
          <comment>
            Defines the threshold level at which the Data Needed
      Interrupt will be generated.
            <br/>
            The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.
          </comment>
        </bits>
        <bits access="rw" name="afc level" pos="11:8" rst="0">
          <comment>
            Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).
            <br/>
            The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.
          </comment>
        </bits>
      </reg>
      <reg name="xchar" protect="rw">
        <bits access="rw" name="xon1" pos="7:0" rst="17">
          <comment>XON1 character value. Reset Value is CTRL-Q 0x11.</comment>
        </bits>
        <bits access="rw" name="xoff1" pos="15:8" rst="19">
          <comment>XOFF1 character value. Reset Value is CTRL-S 0x13</comment>
        </bits>
        <bits access="rw" name="xon2" pos="23:16" rst="0">
          <comment>XON2 character value.</comment>
        </bits>
        <bits access="rw" name="xoff2" pos="31:24" rst="0">
          <comment>XOFF2 character value.</comment>
        </bits>
        <comment>These characters must respect following constraints: They must be different if used in software control, if BackSlash_En='1', they cannot be '\' and they cannot be complementary to each other, for example neither XON1 = ~XOFF1 nor XON1 = ~'\' is permitted.</comment>
      </reg>
    </module>
    <instance address="0x51402000" name="DEBUG_UART" type="DEBUG_UART"/>
  </archive>
  <archive relative="dmc400.xml">
    <module category="Periph" name="DMC400">
      <reg name="memc_status" protect="r">
        <bits access="r" name="memc_status" pos="1:0" rst="0">
          <options>
            <option name="config" value="0"/>
            <option name="low_power" value="1"/>
            <option name="paused" value="2"/>
            <option name="ready" value="3"/>
          </options>
        </bits>
      </reg>
      <reg name="memc_config" protect="r">
        <bits access="r" name="system_interfaces_cfg" pos="1:0" rst="0">
          <options>
            <option name="1_system_interface" value="0"/>
            <option name="2_system_interface" value="1"/>
            <option name="4_system_interface" value="3"/>
          </options>
        </bits>
        <bits access="r" name="memory_interfaces_cfg" pos="5:4" rst="0">
          <options>
            <option name="1_memory_interface" value="0"/>
            <option name="2_memory_interface" value="1"/>
          </options>
        </bits>
        <bits access="r" name="memory_data_width_cfg" pos="9:8" rst="1">
          <options>
            <option name="32bit_phy_if" value="1"/>
            <option name="64bit_phy_if" value="2"/>
            <option name="128bit_phy_if" value="3"/>
          </options>
        </bits>
        <bits access="r" name="memory_chip_selects_cfg" pos="13:12" rst="0">
          <options>
            <option name="1_chip_sel" value="0"/>
            <option name="2_chip_sel" value="1"/>
          </options>
        </bits>
        <bits access="r" name="read_queue_depth_cfg" pos="18:16" rst="0">
          <options>
            <option name="16_entry" value="0"/>
            <option name="32_entry" value="1"/>
            <option name="64_entry" value="3"/>
            <option name="128_entry" value="7"/>
          </options>
        </bits>
        <bits access="r" name="write_queue_depth_cfg" pos="22:20" rst="1">
          <options>
            <option name="16_entry" value="0"/>
            <option name="32_entry" value="1"/>
            <option name="64_entry" value="3"/>
            <option name="128_entry" value="7"/>
          </options>
        </bits>
        <bits access="r" name="max_burst_length_cfg" pos="25:24" rst="3">
          <options>
            <option name="2_dmc_cycle" value="1"/>
            <option name="4_dmc_cycle" value="2"/>
            <option name="8_dmc_cycle" value="3"/>
          </options>
        </bits>
        <bits access="r" name="memory_ecc_cfg" pos="28" rst="0">
          <options>
            <option name="false" value="0"/>
            <option name="true" value="1"/>
          </options>
        </bits>
      </reg>
      <reg name="memc_cmd" protect="w">
        <bits access="w" name="memc_cmd" pos="2:0" rst="0">
          <options>
            <option name="config" value="0"/>
            <option name="sleep" value="1"/>
            <option name="pause" value="2"/>
            <option name="go" value="3"/>
            <option name="invalidate" value="4"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="address_control" protect="rw">
        <bits access="rw" name="column_bits" pos="3:0" rst="0">
          <options>
            <option name="8_col_bits" value="0"/>
            <option name="9_col_bits" value="1"/>
            <option name="10_col_bits" value="2"/>
            <option name="11_col_bits" value="3"/>
            <option name="12_col_bits" value="4"/>
          </options>
        </bits>
        <bits access="rw" name="row_bits" pos="11:8" rst="2">
          <options>
            <option name="13_row_bits" value="2"/>
            <option name="14_row_bits" value="3"/>
            <option name="15_row_bits" value="4"/>
            <option name="16_row_bits" value="5"/>
          </options>
        </bits>
        <bits access="rw" name="bank_bits" pos="19:16" rst="3">
          <options>
            <option name="2_bank_bits_4bk" value="2"/>
            <option name="3_bank_bits_8bk" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="chip_bits" pos="25:24" rst="0">
          <options>
            <option name="0_chip_bits_1cs" value="0"/>
            <option name="1_chip_bits_2cs" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="channel_bits" pos="29:28" rst="0">
          <options>
            <option name="0_channel_bits_1memif" value="0"/>
            <option name="1_channel_bits_2memif" value="1"/>
          </options>
        </bits>
      </reg>
      <reg name="decode_control" protect="rw">
        <bits access="rw" name="addr_decode" pos="1:0" rst="0">
          <options>
            <option name="channel_chip_row_bank_col" value="0"/>
            <option name="row_channel_chip_bank_col" value="1"/>
            <option name="chip_bank_row_channel_col" value="2"/>
            <option name="row_chip_bank_channel_col" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="strip_decode" pos="7:4" rst="5">
          <options>
            <option name="page_addr_13_12" value="0"/>
            <option name="page_addr_12_11" value="1"/>
            <option name="page_addr_11_10" value="2"/>
            <option name="page_addr_10_9" value="3"/>
            <option name="page_addr_9_8" value="4"/>
            <option name="page_addr_8_7" value="5"/>
            <option name="page_addr_7_6" value="6"/>
            <option name="page_addr_6_5" value="7"/>
          </options>
        </bits>
      </reg>
      <reg name="format_control" protect="rw">
        <bits access="rw" name="mem_width" pos="1:0" rst="1">
          <options>
            <option name="phy_width_32_x16_ddr" value="1"/>
            <option name="phy_width_64_x32_ddr" value="2"/>
            <option name="phy_width_128_x64_ddr" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="mem_burst" pos="9:8" rst="2">
          <options>
            <option name="mem_burst_2_ddr_bl4" value="1"/>
            <option name="mem_burst_4_ddr_bl8" value="2"/>
            <option name="mem_burst_8_ddr_bl16" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="acc_granu" pos="25:24" rst="2">
          <options>
            <option name="acc_granu_1_ddr_2n" value="0"/>
            <option name="acc_granu_2_ddr_4n" value="1"/>
            <option name="acc_granu_4_ddr_8n" value="2"/>
            <option name="acc_granu_8_ddr_16n" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="align_boundary" pos="29:28" rst="2">
          <options>
            <option name="align_boundary_1_col_1bit" value="0"/>
            <option name="align_boundary_2_col_2bit" value="1"/>
            <option name="align_boundary_4_col_3bit" value="2"/>
            <option name="align_boundary_8_col_4bit" value="3"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="low_power_control" protect="rw">
        <bits access="rw" name="stop_mem_clock_idle" pos="0" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="stop_mem_clock_sref" pos="1" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="auto_power_down" pos="2" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="auto_self_refresh" pos="3" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="asr_period" pos="7:4" rst="1">
        </bits>
      </reg>
      <hole size="(3)*32"/>
      <reg name="turnaround_priority" protect="rw">
        <bits access="rw" name="turnaround_priority" pos="3:0" rst="0">
        </bits>
        <bits access="rw" name="turnaround_limit" pos="7:4" rst="0">
        </bits>
      </reg>
      <reg name="hit_priority" protect="rw">
        <bits access="rw" name="hit_priority" pos="3:0" rst="0">
        </bits>
        <bits access="rw" name="hit_limit" pos="7:4" rst="0">
        </bits>
      </reg>
      <reg name="qos0_control" protect="rw">
        <bits access="rw" name="qos0_priority" pos="3:0" rst="0">
        </bits>
        <bits access="rw" name="qos0_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos1_control" protect="rw">
        <bits access="rw" name="qos1_priority" pos="3:0" rst="1">
        </bits>
        <bits access="rw" name="qos1_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos2_control" protect="rw">
        <bits access="rw" name="qos2_priority" pos="3:0" rst="2">
        </bits>
        <bits access="rw" name="qos2_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos3_control" protect="rw">
        <bits access="rw" name="qos3_priority" pos="3:0" rst="3">
        </bits>
        <bits access="rw" name="qos3_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos4_control" protect="rw">
        <bits access="rw" name="qos4_priority" pos="3:0" rst="4">
        </bits>
        <bits access="rw" name="qos4_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos5_control" protect="rw">
        <bits access="rw" name="qos5_priority" pos="3:0" rst="5">
        </bits>
        <bits access="rw" name="qos5_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos6_control" protect="rw">
        <bits access="rw" name="qos6_priority" pos="3:0" rst="6">
        </bits>
        <bits access="rw" name="qos6_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos7_control" protect="rw">
        <bits access="rw" name="qos7_priority" pos="3:0" rst="7">
        </bits>
        <bits access="rw" name="qos7_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos8_control" protect="rw">
        <bits access="rw" name="qos8_priority" pos="3:0" rst="8">
        </bits>
        <bits access="rw" name="qos8_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos9_control" protect="rw">
        <bits access="rw" name="qos9_priority" pos="3:0" rst="9">
        </bits>
        <bits access="rw" name="qos9_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos10_control" protect="rw">
        <bits access="rw" name="qos10_priority" pos="3:0" rst="10">
        </bits>
        <bits access="rw" name="qos10_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos11_control" protect="rw">
        <bits access="rw" name="qos11_priority" pos="3:0" rst="11">
        </bits>
        <bits access="rw" name="qos11_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos12_control" protect="rw">
        <bits access="rw" name="qos12_priority" pos="3:0" rst="12">
        </bits>
        <bits access="rw" name="qos12_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="qos13_control" protect="rw">
        <bits access="rw" name="qos13_priority" pos="3:0" rst="13">
        </bits>
        <bits access="rw" name="qos13_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos14_control" protect="rw">
        <bits access="rw" name="qos14_priority" pos="3:0" rst="14">
        </bits>
        <bits access="rw" name="qos14_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="qos15_control" protect="rw">
        <bits access="rw" name="qos15_priority" pos="3:0" rst="15">
        </bits>
        <bits access="rw" name="qos15_timeout" pos="11:8" rst="0">
        </bits>
      </reg>
      <reg name="timeout_control" protect="rw">
        <bits access="rw" name="timeout_prescalar" pos="1:0" rst="1">
          <options>
            <option name="8_clk" value="0"/>
            <option name="16_clk" value="1"/>
            <option name="32_clk" value="2"/>
            <option name="64_clk" value="3"/>
          </options>
        </bits>
      </reg>
      <reg name="queue_control" protect="rw">
        <bits access="rw" name="s0_reserve" pos="3:0" rst="0">
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="write_priority_control" protect="rw">
        <bits access="rw" name="write_threshold_en" pos="0" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="write_fill_priority_1_16ths" pos="7:4" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_2_16ths" pos="11:8" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_3_16ths" pos="15:12" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_4_16ths" pos="19:16" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_5_16ths" pos="23:20" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_6_16ths" pos="27:24" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_7_16ths" pos="31:28" rst="0">
        </bits>
      </reg>
      <reg name="write_priority_control2" protect="rw">
        <bits access="rw" name="write_fill_priority_8_16ths" pos="3:0" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_9_16ths" pos="7:4" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_10_16ths" pos="11:8" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_11_16ths" pos="15:12" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_12_16ths" pos="19:16" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_13_16ths" pos="23:20" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_14_16ths" pos="27:24" rst="0">
        </bits>
        <bits access="rw" name="write_fill_priority_15_16ths" pos="31:28" rst="0">
        </bits>
      </reg>
      <reg name="read_priority_control" protect="rw">
        <bits access="rw" name="read_escalation" pos="0" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="read_in_burst_prioritisation" pos="1" rst="1">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="read_fill_priority_1_16ths" pos="7:4" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_2_16ths" pos="11:8" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_3_16ths" pos="15:12" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_4_16ths" pos="19:16" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_5_16ths" pos="23:20" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_6_16ths" pos="27:24" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_7_16ths" pos="31:28" rst="0">
        </bits>
      </reg>
      <reg name="read_priority_control2" protect="rw">
        <bits access="rw" name="read_fill_priority_8_16ths" pos="3:0" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_9_16ths" pos="7:4" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_10_16ths" pos="11:8" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_11_16ths" pos="15:12" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_12_16ths" pos="19:16" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_13_16ths" pos="23:20" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_14_16ths" pos="27:24" rst="0">
        </bits>
        <bits access="rw" name="read_fill_priority_15_16ths" pos="31:28" rst="0">
        </bits>
      </reg>
      <reg name="access_address_match" protect="rw">
        <bits access="rw" name="access_address_match" pos="31:12" rst="0">
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="access_address_mask" protect="rw">
        <bits access="rw" name="access_address_mask" pos="31:12" rst="0">
        </bits>
      </reg>
      <hole size="(23)*32"/>
      <reg name="channel_status" protect="r">
        <bits access="r" name="m0_state" pos="3:0" rst="1">
          <options>
            <option name="standby" value="0"/>
            <option name="dpd" value="1"/>
            <option name="idle" value="2"/>
            <option name="self_refresh" value="3"/>
            <option name="reading" value="4"/>
            <option name="power_down" value="5"/>
            <option name="writing" value="6"/>
          </options>
        </bits>
        <bits access="r" name="m1_state" pos="7:4" rst="0">
          <options>
            <option name="standby" value="0"/>
            <option name="dpd" value="1"/>
            <option name="idle" value="2"/>
            <option name="self_refresh" value="3"/>
            <option name="reading" value="4"/>
            <option name="power_down" value="5"/>
            <option name="writing" value="6"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="direct_cmd" protect="w">
        <bits access="w" name="direct_addr" pos="15:0" rst="0">
        </bits>
        <bits access="w" name="direct_ba" pos="18:16" rst="0">
        </bits>
        <bits access="w" name="chip_addr" pos="20" rst="0">
          <options>
            <option name="chip_0" value="0"/>
            <option name="chip_1" value="1"/>
          </options>
        </bits>
        <bits access="w" name="channel_addr" pos="24" rst="0">
          <options>
            <option name="channel_0" value="0"/>
            <option name="channel_1" value="1"/>
          </options>
        </bits>
        <bits access="w" name="direct_cmd" pos="31:28" rst="0">
          <options>
            <option name="nop" value="0"/>
            <option name="mrs" value="1"/>
            <option name="prechargeall" value="2"/>
            <option name="autorefresh" value="3"/>
            <option name="selfrefresh_entry" value="4"/>
            <option name="zqc" value="5"/>
            <option name="mrr" value="6"/>
            <option name="powerdown_entry" value="7"/>
            <option name="deep_powerdown_entry" value="8"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="mr_data" protect="r">
        <bits access="r" name="mr_data" pos="7:0" rst="0">
        </bits>
      </reg>
      <hole size="(3)*32"/>
      <reg name="refresh_control" protect="rw">
        <bits access="rw" name="per_bank_refresh" pos="0" rst="0">
          <options>
            <option name="all_bank_autorefresh" value="0"/>
            <option name="pre_bank_autorefresh" value="1"/>
          </options>
        </bits>
      </reg>
      <hole size="(55)*32"/>
      <reg name="t_refi" protect="rw">
        <bits access="rw" name="t_refi" pos="10:0" rst="0x100">
        </bits>
      </reg>
      <reg name="t_rfc" protect="rw">
        <bits access="rw" name="t_rfc" pos="8:0" rst="0x23">
        </bits>
        <bits access="rw" name="t_rfcab" pos="24:16" rst="0x23">
        </bits>
      </reg>
      <reg name="t_mrr" protect="rw">
        <bits access="rw" name="t_mrr" pos="2:0" rst="2">
        </bits>
      </reg>
      <reg name="t_mrw" protect="rw">
        <bits access="rw" name="t_mrw" pos="6:0" rst="2">
        </bits>
      </reg>
      <hole size="(2)*32"/>
      <reg name="t_rcd" protect="rw">
        <bits access="rw" name="t_rcd" pos="3:0" rst="5">
        </bits>
      </reg>
      <reg name="t_ras" protect="rw">
        <bits access="rw" name="t_ras" pos="5:0" rst="0xe">
        </bits>
      </reg>
      <reg name="t_rp" protect="rw">
        <bits access="rw" name="t_rp" pos="4:0" rst="5">
        </bits>
      </reg>
      <reg name="t_rpall" protect="rw">
        <bits access="rw" name="t_rpall" pos="4:0" rst="5">
        </bits>
      </reg>
      <reg name="t_rrd" protect="rw">
        <bits access="rw" name="t_rrd" pos="3:0" rst="4">
        </bits>
      </reg>
      <reg name="t_faw" protect="rw">
        <bits access="rw" name="t_faw" pos="5:0" rst="0x14">
        </bits>
      </reg>
      <reg name="read_latency" protect="rw">
        <bits access="rw" name="read_latency" pos="3:0" rst="5">
        </bits>
      </reg>
      <reg name="t_rtr" protect="rw">
        <bits access="rw" name="t_rtr" pos="3:0" rst="4">
        </bits>
      </reg>
      <reg name="t_rtw" protect="rw">
        <bits access="rw" name="t_rtw" pos="4:0" rst="6">
        </bits>
      </reg>
      <reg name="t_rtp" protect="rw">
        <bits access="rw" name="t_rtp" pos="3:0" rst="0">
        </bits>
      </reg>
      <reg name="write_latency" protect="rw">
        <bits access="rw" name="write_latency" pos="3:0" rst="4">
        </bits>
      </reg>
      <reg name="t_wr" protect="rw">
        <bits access="rw" name="t_wr" pos="4:0" rst="5">
        </bits>
      </reg>
      <reg name="t_wtr" protect="rw">
        <bits access="rw" name="t_wtr" pos="4:0" rst="4">
        </bits>
        <bits access="rw" name="t_wtr_cs" pos="20:16" rst="4">
        </bits>
      </reg>
      <reg name="t_wtw" protect="rw">
        <bits access="rw" name="t_wtw" pos="21:16" rst="4">
        </bits>
      </reg>
      <reg name="t_eckd" protect="rw">
        <bits access="rw" name="t_eckd" pos="3:0" rst="5">
        </bits>
      </reg>
      <reg name="t_xckd" protect="rw">
        <bits access="rw" name="t_xckd" pos="3:0" rst="5">
        </bits>
      </reg>
      <reg name="t_ep" protect="rw">
        <bits access="rw" name="t_ep" pos="3:0" rst="2">
        </bits>
      </reg>
      <reg name="t_xp" protect="rw">
        <bits access="rw" name="t_xp" pos="4:0" rst="2">
        </bits>
        <bits access="rw" name="t_xpdll" pos="20:16" rst="2">
        </bits>
      </reg>
      <reg name="t_esr" protect="rw">
        <bits access="rw" name="t_esr" pos="8:0" rst="0xe">
        </bits>
      </reg>
      <reg name="t_xsr" protect="rw">
        <bits access="rw" name="t_xsr" pos="9:0" rst="0x100">
        </bits>
        <bits access="rw" name="t_xsrdll" pos="25:16" rst="0x100">
        </bits>
      </reg>
      <reg name="t_srckd" protect="rw">
        <bits access="rw" name="t_srckd" pos="3:0" rst="5">
        </bits>
      </reg>
      <reg name="t_cksrd" protect="rw">
        <bits access="rw" name="t_cksrd" pos="3:0" rst="5">
        </bits>
      </reg>
      <hole size="(36)*32"/>
      <reg name="t_rddata_en" protect="rw">
        <bits access="rw" name="t_rddata_en" pos="3:0" rst="1">
        </bits>
      </reg>
      <reg name="t_phywrlat" protect="rw">
        <bits access="rw" name="t_phywrlat" pos="3:0" rst="1">
        </bits>
        <bits access="rw" name="t_phywrdata" pos="8" rst="1">
        </bits>
      </reg>
      <reg name="rdlvl_control" protect="rw">
        <bits access="rw" name="rdlvl_mode" pos="1:0" rst="0">
          <options>
            <option name="no_training" value="0"/>
            <option name="phy_independent_mode" value="1"/>
            <option name="phy_evaluation_mode" value="2"/>
          </options>
        </bits>
        <bits access="rw" name="rdlvl_setup" pos="4" rst="0">
          <options>
            <option name="mrs_prior_train" value="0"/>
            <option name="nop_prior_train" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="rdlvl_cmd" pos="8" rst="0">
          <options>
            <option name="read_for_train" value="0"/>
            <option name="mrr_for_train" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="rdlvl_refresh" pos="12" rst="1">
          <options>
            <option name="prechargeall_prior_train" value="0"/>
            <option name="prechargeall_autorefresh_prior_train" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="rdlvl_reg_sel" pos="16" rst="0">
          <options>
            <option name="mr32_for_train" value="0"/>
            <option name="mr40_for_train" value="1"/>
          </options>
        </bits>
      </reg>
      <reg name="rdlvl_mrs" protect="rw">
        <bits access="rw" name="rdlvl_mrs" pos="2:0" rst="4">
        </bits>
      </reg>
      <reg name="rdlvl_direct" protect="w">
        <bits access="w" name="rdlvl_req" pos="1:0" rst="0">
          <options>
            <option name="read_eye_train" value="1"/>
            <option name="read_gate_train" value="2"/>
          </options>
        </bits>
        <bits access="w" name="rdlvl_chip_addr" pos="24" rst="0">
          <options>
            <option name="chip_0" value="0"/>
            <option name="chip_1" value="1"/>
          </options>
        </bits>
        <bits access="w" name="rdlvl_channel_addr" pos="28" rst="0">
          <options>
            <option name="channel_0" value="0"/>
            <option name="channel_1" value="1"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="t_rdlvl_en" protect="rw">
        <bits access="rw" name="t_rdlvl_en" pos="5:0" rst="1">
        </bits>
      </reg>
      <reg name="t_rdlvl_rr" protect="rw">
        <bits access="rw" name="t_rdlvl_rr" pos="5:0" rst="4">
        </bits>
      </reg>
      <hole size="(2)*32"/>
      <reg name="wrlvl_control" protect="rw">
        <bits access="rw" name="wrlvl_mode" pos="1:0" rst="0">
          <options>
            <option name="no_training" value="0"/>
            <option name="phy_independent_mode" value="1"/>
            <option name="phy_evaluation_mode" value="2"/>
          </options>
        </bits>
        <bits access="rw" name="wrlvl_refresh" pos="12" rst="1">
          <options>
            <option name="prechargeall_prior_train" value="0"/>
            <option name="prechargeall_autorefresh_prior_train" value="1"/>
          </options>
        </bits>
      </reg>
      <reg name="wrlvl_mrs" protect="rw">
        <bits access="rw" name="wrlvl_mrs" pos="12:0" rst="0x86">
        </bits>
      </reg>
      <reg name="wrlvl_direct" protect="w">
        <bits access="w" name="wrlvl_req" pos="0" rst="0">
        </bits>
        <bits access="w" name="wrlvl_chip_addr" pos="24" rst="0">
          <options>
            <option name="chip_0" value="0"/>
            <option name="chip_1" value="1"/>
          </options>
        </bits>
        <bits access="w" name="wrlvl_channel_addr" pos="28" rst="0">
          <options>
            <option name="channel_0" value="0"/>
            <option name="channel_1" value="1"/>
          </options>
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="t_wrlvl_en" protect="rw">
        <bits access="rw" name="t_wrlvl_en" pos="5:0" rst="1">
        </bits>
      </reg>
      <reg name="t_wrlvl_ww" protect="rw">
        <bits access="rw" name="t_wrlvl_ww" pos="5:0" rst="4">
        </bits>
      </reg>
      <hole size="(2)*32"/>
      <reg name="phy_power_control" protect="rw">
        <bits access="rw" name="lp_wr_en" pos="0" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_rd_en" pos="1" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_idle_en" pos="2" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_pd_en" pos="3" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_sref_en" pos="4" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_dpd_en" pos="5" rst="0">
          <options>
            <option name="disable" value="0"/>
            <option name="enable" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="lp_wakeup_wr" pos="11:8" rst="0">
        </bits>
        <bits access="rw" name="lp_wakeup_rd" pos="15:12" rst="0">
        </bits>
        <bits access="rw" name="lp_wakeup_idle" pos="19:16" rst="0">
        </bits>
        <bits access="rw" name="lp_wakeup_pd" pos="23:20" rst="0">
        </bits>
        <bits access="rw" name="lp_wakeup_sref" pos="27:24" rst="0">
        </bits>
        <bits access="rw" name="lp_wakeup_dpd" pos="31:28" rst="0">
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="phy_update_control" protect="rw">
        <bits access="rw" name="phyupd_type_00" pos="1:0" rst="0">
          <options>
            <option name="sref" value="0"/>
            <option name="stall" value="1"/>
            <option name="refnstall" value="2"/>
            <option name="defer" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="phyupd_type_01" pos="3:2" rst="0">
          <options>
            <option name="sref" value="0"/>
            <option name="stall" value="1"/>
            <option name="refnstall" value="2"/>
            <option name="defer" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="phyupd_type_10" pos="5:4" rst="0">
          <options>
            <option name="sref" value="0"/>
            <option name="stall" value="1"/>
            <option name="refnstall" value="2"/>
            <option name="defer" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="phyupd_type_11" pos="7:6" rst="0">
          <options>
            <option name="sref" value="0"/>
            <option name="stall" value="1"/>
            <option name="refnstall" value="2"/>
            <option name="defer" value="3"/>
          </options>
        </bits>
      </reg>
      <hole size="(43)*32"/>
      <reg name="user_status" protect="r">
        <bits access="r" name="user_status" pos="7:0" rst="0">
        </bits>
      </reg>
      <reg name="user_config0" protect="rw">
        <bits access="rw" name="user_config0" pos="7:0" rst="0">
        </bits>
      </reg>
      <reg name="user_config1" protect="rw">
        <bits access="rw" name="user_config1" pos="7:0" rst="0">
        </bits>
      </reg>
      <hole size="(637)*32"/>
      <reg name="integ_cfg" protect="rw">
        <bits access="rw" name="integ_test_en" pos="0" rst="0">
        </bits>
      </reg>
      <hole size="(1)*32"/>
      <reg name="integ_outputs" protect="w">
        <bits access="w" name="combined_integ" pos="0" rst="0">
        </bits>
        <bits access="w" name="ecc_sec_integ" pos="1" rst="0">
        </bits>
        <bits access="w" name="ecc_ded_integ" pos="2" rst="0">
        </bits>
        <bits access="w" name="ecc_overflow_integ" pos="3" rst="0">
        </bits>
      </reg>
      <hole size="(117)*32"/>
      <reg name="periph_id_0" protect="r">
        <bits access="r" name="part_0" pos="7:0" rst="0x40">
        </bits>
      </reg>
      <reg name="periph_id_1" protect="r">
        <bits access="r" name="part_1" pos="3:0" rst="4">
        </bits>
        <bits access="r" name="des_0" pos="7:4" rst="0xb">
        </bits>
      </reg>
      <reg name="periph_id_2" protect="r">
        <bits access="r" name="des_1" pos="2:0" rst="3">
        </bits>
        <bits access="r" name="jedec" pos="3" rst="1">
        </bits>
        <bits access="r" name="revision" pos="7:4" rst="1">
        </bits>
      </reg>
      <reg name="periph_id_3" protect="r">
        <bits access="r" name="cmod" pos="7:0" rst="0">
        </bits>
      </reg>
      <reg name="component_id_0" protect="r">
        <bits access="r" name="prmbl_0" pos="7:0" rst="0xd">
        </bits>
      </reg>
      <reg name="component_id_1" protect="r">
        <bits access="r" name="prmbl_1" pos="3:0" rst="0">
        </bits>
        <bits access="r" name="pclass" pos="7:4" rst="0xf">
        </bits>
      </reg>
      <reg name="component_id_2" protect="r">
        <bits access="r" name="prmbl_2" pos="7:0" rst="5">
        </bits>
      </reg>
      <reg name="component_id_3" protect="r">
        <bits access="r" name="prmbl_3" pos="7:0" rst="0xb1">
        </bits>
      </reg>
    </module>
    <instance address="0x51600000" name="DMC_CTRL" type="DMC400"/>
  </archive>
  <archive relative="gic400_reg.xml">
    <module category="System" name="GIC400">
      <hole size="32768"/>
      <reg name="gicd_ctrl" protect="rw">
        <bits access="rw" name="enablegrp1" pos="1" rst="0">
          <comment>Global enable for forwarding pending Group 1 interrupts from the Distributor to the CPU interfaces:
          0    Group 1 interrupts not forward.
          1    Group 1 interrupts forwarded, subject to the priority rules.</comment>
        </bits>
        <bits access="rw" name="enablegrp0" pos="0" rst="0">
          <comment>Global enable for forwarding pending Group 0 interrupts from the Distributor to the CPU interfaces:
          0    Group 0 interrupts not forwarded.
          1    Group 0 interrupts forwarded, subject to the priority rules.</comment>
        </bits>
      </reg>
      <reg name="gicd_typer" protect="r">
        <bits access="r" name="lspi" pos="15:11" rst="31">
          <comment>If the GIC implements the Security Extensions, the value of this field is the maximum number of
          implemented lockable SPIs, from 0 (0b00000) to 31 (0b11111), see Configuration lockdown on
          page 4-82. If this field is 0b00000 then the GIC does not implement configuration lockdown.
          If the GIC does not implement the Security Extensions, this field is reserved.</comment>
        </bits>
        <bits access="r" name="securityextn" pos="10" rst="1">
          <comment>Indicates whether the GIC implements the Security Extensions.
          0 Security Extensions not implemented.
          1 Security Extensions implemented.</comment>
        </bits>
        <bits access="r" name="cpunumber" pos="7:5" rst="1">
          <comment>Indicates the number of implemented CPU interfaces. The number of implemented CPU interfaces is
          one more than the value of this field, for example if this field is 0b011, there are four CPU interfaces.
          If the GIC implements the Virtualization Extensions, this is also the number of virtual CPU interfaces.</comment>
        </bits>
        <bits access="r" name="itlinesnumber" pos="4:0" rst="3">
          <comment>Indicates the maximum number of interrupts that the GIC supports. If ITLinesNumber=N, the
          maximum number of interrupts is 32(N+1). The interrupt ID range is from 0 to (number of IDs C 1).
          For example:
          0b00011 Up to 128 interrupt lines, interrupt IDs 0-127.
          The maximum number of interrupts is 1020 (0b11111). See the text in this section for more information.
          Regardless of the range of interrupt IDs defined by this field, interrupt IDs 1020-1023 are reserved for
          special purposes.</comment>
        </bits>
      </reg>
      <reg name="gicd_iddr" protect="r">
        <bits access="r" name="productid" pos="31:24" rst="2">
          <comment>Product ID</comment>
        </bits>
        <bits access="r" name="variant" pos="19:16" rst="0">
          <comment>An IMPLEMENTATION DEFINED variant number. Typically, this field is used to distinguish product variants,
          or major revisions of a product.</comment>
        </bits>
        <bits access="r" name="revision" pos="15:12" rst="1">
          <comment>An IMPLEMENTATION DEFINED revision number. Typically, this field is used to distinguish minor revisions
          of a product.</comment>
        </bits>
        <bits access="r" name="implementer" pos="11:0" rst="1083">
          <comment>Contains the JEP106 code of the company that implemented the GIC Distributor:
          Bits [11:8] The JEP106 continuation code of the implementer. For an ARM implementation, this field
          is 0x4.
          Bits [7] Always 0.
          Bits [6:0] The JEP106 identity code of the implementer. For an ARM implementation, bits[7:0] are
          0x3B.</comment>
        </bits>
      </reg>
      <hole size="928"/>
      <reg count="4" name="gicd_igrouprn" protect="rw">
        <comment>The GICD_IGROUPR registers provide a status bit for each interrupt supported by the GIC.
          Each bit controls whether the corresponding interrupt is in Group 0 or Group 1.
          Accessible by Secure accesses Only.
          For each bit:
          0 The corresponding interrupt is Group 0.
          1 The corresponding interrupt is Group 1.For interrupt ID m, when DIV and MOD are the integer division and
          modulo operations:
          a. the corresponding GICD_IGROUPRn number, n, is given by n = m DIV 32
          b. the offset of the required GICD_IGROUPR is (0x080 + (4*n))
          c. the bit number of the required group status bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg name="gicd_isenabler0" protect="rw">
        <comment>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Enables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 1.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ISENABLER number, n, is given by n = m DIV 32
          b.the offset of the required GICD_ISENABLER is (0x100 + (4*n))
          c.the bit number of the required Set-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_isenabler1" protect="rw">
        <comment>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Enables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 1.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ISENABLER number, n, is given by n = m DIV 32
          b.the offset of the required GICD_ISENABLER is (0x100 + (4*n))
          c.the bit number of the required Set-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_isenabler2" protect="rw">
        <comment>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Enables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 1.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ISENABLER number, n, is given by n = m DIV 32
          b.the offset of the required GICD_ISENABLER is (0x100 + (4*n))
          c.the bit number of the required Set-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_isenabler3" protect="rw">
        <comment>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Enables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 1.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ISENABLER number, n, is given by n = m DIV 32
          b.the offset of the required GICD_ISENABLER is (0x100 + (4*n))
          c.the bit number of the required Set-enable bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg name="gicd_icenabler0" protect="rw">
        <comment>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the
          GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Disables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 0.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ICENABLERn number, n, is given by m = n DIV 32
          b.the offset of the required GICD_ICENABLERn is (0x180 + (4*n))
          c.the bit number of the required Clear-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_icenabler1" protect="rw">
        <comment>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the
          GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Disables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 0.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ICENABLERn number, n, is given by m = n DIV 32
          b.the offset of the required GICD_ICENABLERn is (0x180 + (4*n))
          c.the bit number of the required Clear-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_icenabler2" protect="rw">
        <comment>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the
          GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Disables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 0.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ICENABLERn number, n, is given by m = n DIV 32
          b.the offset of the required GICD_ICENABLERn is (0x180 + (4*n))
          c.the bit number of the required Clear-enable bit in this register is m MOD 32.</comment>
      </reg>
      <reg name="gicd_icenabler3" protect="rw">
        <comment>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the
          GIC.
          For SPIs and PPIs, each bit controls the forwarding of the corresponding interrupt from the Distributor to
          the CPU interfaces:
          Reads  0 Forwarding of the corresponding interrupt is disabled.
                 1 Forwarding of the corresponding interrupt is enabled.
          Writes 0 Has no effect.
                 1 Disables the forwarding of the corresponding interrupt.
          After a write of 1 to a bit, a subsequent read of the bit returns the value 0.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a.the corresponding GICD_ICENABLERn number, n, is given by m = n DIV 32
          b.the offset of the required GICD_ICENABLERn is (0x180 + (4*n))
          c.the bit number of the required Clear-enable bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg count="4" name="gicd_ispendrn" protect="rw">
        <comment>The GICD_ISPENDRs provide a Set-pending bit for each interrupt supported by the GIC.
          For each bit:
          Reads 0  The corresponding interrupt is not pending on any processor.
                1  a. For PPIs and SGIs, the corresponding interrupt is pendinga on this
                      processor.
                   b. For SPIs, the corresponding interrupt is pendinga on at least one
                      processor.
          Writes For SPIs and PPIs:
                0  Has no effect.
                1  The effect depends on whether the interrupt is edge-triggered or
                   level-sensitive:
                   Edge-triggered
                         Changes the status of the corresponding interrupt to:
                         a.pending if it was previously inactive
                         b.active and pending if it was previously active.
                         Has no effect if the interrupt is already pending.
                   Level sensitive
                         If the corresponding interrupt is not pendinga, changes the status
                         of the corresponding interrupt to:
                         a. pending if it was previously inactive
                         b. active and pending if it was previously active.
                         If the interrupt is already pending:
                         a. because of a write to the GICD_ISPENDR, the write has
                           no effect.
                         b. because the corresponding interrupt signal is asserted, the
                           write has no effect on the status of the interrupt, but the
                           interrupt remains pendinga if the interrupt signal is
                           deasserted.
                For SGIs, the write is ignored. SGIs have their own Set-Pending registers.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ISPENDR number, n, is given by n = m DIV 32
          b. the offset of the required GICD_ISPENDR is (0x200 + (4*n))
          c. the bit number of the required Set-pending bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg count="4" name="gicd_icpendrn" protect="rw">
        <comment>The GICD_ICPENDRs provide a Clear-pending bit for each interrupt supported by the GIC.
          For each bit:
          Reads 0   The corresponding interrupt is not pending on any processor.
                1   a. For SGIs and PPIs, the corresponding interrupt is pendinga on this
                       processor.
                    b. For SPIs, the corresponding interrupt is pendinga on at least one
                       processor.
          Writes For SPIs and PPIs:
                0   Has no effect.
                1   The effect depends on whether the interrupt is edge-triggered or level-sensitive:
                    Edge-triggered
                          Changes the status of the corresponding interrupt to:
                          a. inactive if it was previously pending
                          b. active if it was previously active and pending.
                          Has no effect if the interrupt is not pending.
                    Level-sensitive
                          If the corresponding interrupt is pendinga only because of a write to
                          GICD_ISPENDRn, the write changes the status of the interrupt to:
                          a. inactive if it was previously pending
                          b. active if it was previously active and pending.
                          Otherwise the interrupt remains pending if the interrupt signal
                          remains asserted.
                For SGIs, the write is ignored. SGIs have their own Clear-Pending registers.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICPENDR number, n, is given by n = m DIV 32
          b. the offset of the required GICD_ICPENDR is (0x280 + (4*n))
          c. the bit number of the required Set-pending bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg count="4" name="gicd_isactivern" protect="rw">
        <comment>The GICD_ISACTIVERs provide a Set-active bit for each interrupt that the GIC supports.
          For each bit:
          Reads  0  The corresponding interrupt is not active.
                 1  The corresponding interrupt is active.
          Writes 0  Has no effect.
                 1  Activates the corresponding interrupt, if it is not already active. If the interrupt
                    is already active, the write has no effect.
                    After a write of 1 to this bit, a subsequent read of the bit returns the value 1.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ISACTIVERn number, n, is given by n = m DIV 32
          b. the offset of the required GICD_ISACTIVERn is (0x300 + (4*n))
          c. the bit number of the required Set-active bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg count="4" name="gicd_icactivern" protect="rw">
        <comment>The GICD_ICACTIVERs provide a Clear-active bit for each interrupt that the GIC
          supports.
          For each bit:
          Reads  0  The corresponding interrupt is not activea.
                 1  The corresponding interrupt is activea.
          Writes 0  Has no effect.
                 1  Deactivates the corresponding interrupt, if the interrupt is active. If the
                    interrupt is already deactivated, the write has no effect.
                    After a write of 1 to this bit, a subsequent read of the bit returns the value 0.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICACTIVERn number, n, is given by n = m DIV 32
          b. the offset of the required GICD_ICACTIVERn is (0x380 + (4*n))
          c. the bit number of the required Clear-active bit in this register is m MOD 32.</comment>
      </reg>
      <hole size="896"/>
      <reg count="32" name="gicd_ipriorityrn" protect="rw">
        <comment>The GICD_IPRIORITYRs provide an 8-bit priority field for each interrupt supported by the
          GIC.
          Each priority field holds a priority value, from an IMPLEMENTATION DEFINED range. The lower the
          value, the greater the priority of the corresponding interrupt.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_IPRIORITYRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_IPRIORITYRn is (0x400 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <hole size="7168"/>
      <reg name="gicd_itargetsr0" protect="r">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr1" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr2" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr3" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr4" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr5" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr6" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr7" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr8" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr9" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr10" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr11" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr12" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr13" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr14" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr15" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr16" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr17" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr18" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr19" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr20" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr21" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr22" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr23" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr24" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr25" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr26" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr27" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr28" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr29" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr30" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <reg name="gicd_itargetsr31" protect="rw">
        <comment>The GICD_ITARGETSRs provide an 8-bit CPU targets field for each interrupt supported
          by the GIC.This field stores the list of target processors for the interrupt. That is, it holds
          the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and
          has sufficient priority.
          GICD_ITARGETSR0 to GICD_ITARGETSR7 are read-only, and each field returns
          a value that corresponds only to the processor reading the register.
          Processors in the system number from 0, and each bit in a CPU targets field refers to the
          corresponding processor. For example, a value of 0x3 means that the Pending
          interrupt is sent to processors 0 and 1.
          For GICD_ITARGETSR0 to GICD_ITARGETSR7, a read of any CPU targets field returns
          the number of the processor performing the read.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ITARGETSRn number, n, is given by n = m DIV 4
          b. the offset of the required GICD_ITARGETSR is (0x800 + (4*n))
          c. the byte offset of the required Priority field in this register is m MOD 4, where:
             (1) byte offset 0 refers to register bits [7:0]
             (2) byte offset 1 refers to register bits [15:8]
             (3) byte offset 2 refers to register bits [23:16]
             (4) byte offset 3 refers to register bits [31:24].</comment>
      </reg>
      <hole size="7168"/>
      <reg name="gicd_icfgr0" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr1" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr2" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr3" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr4" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr5" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr6" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <reg name="gicd_icfgr7" protect="rw">
        <comment>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC.
          For Int_config[1], the most significant bit, bit [2F+1], the encoding is:
          0 Corresponding interrupt is level-sensitive.
          1 Corresponding interrupt is edge-triggered.
          Int_config[0], the least significant bit, bit [2F], reserved
          For SGIs:
          Int_config[1] Not programmable, RAO/WI.
          For PPIs:
          Int_config[1] Not programmable, RAZ/WI.
          For SPIs:
          Int_config[1] For SPIs, this bit is programmable. A read of this bit always returns the correct value
          to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_ICFGR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_ICFGRn is (0xC00 + (4*n))
          c. the required Priority field in this register, F, is given by F = m MOD 16, where field 0 refers to register bits
          [1:0], field 1 refers to bits [3:2], up to field 15 that refers to bits [31:30].</comment>
      </reg>
      <hole size="1792"/>
      <reg name="gicd_ppisr" protect="r">
        <bits access="r" name="ppi_status" pos="15:9" rst="0">
          <comment>Asserted when the PPI inputs to the Distributor are active.
          ID 31 nLEGACYIRQ signal
          ID 30 Non-secure physical timer event
          ID 29 Secure physical timer event
          ID 28 nLEGACYFIQ signal
          ID 27 Virtual timer event
          ID 26 Hypervisor timer event
          ID 25 Virtual maintenance interrupt.</comment>
        </bits>
      </reg>
      <reg count="3" name="gicd_spisrn" protect="r">
        <comment>Returns the status of the IRQS inputs on the Distributor. For each bit:
          0 IRQS is LOW
          1 IRQS is HIGH.</comment>
      </reg>
      <hole size="1920"/>
      <reg count="8" name="gicd_nsacrn" protect="rw">
        <comment>The GICD_NSACRs enable Secure software to permit Non-secure software on a particular
          processor to create and manage Group 0 interrupts. They provide an access control for each
          implemented interrupt.
          If the corresponding interrupt does not support configurable Non-secure access, the field is
          RAZ/WI. Otherwise, the field is RW and configures the level of Non-secure access permitted
          when the interrupt is in Group 0. If the interrupt is in Group 1, this field is ignored. The possible
          values of the field are:
          0b00 No Non-secure access is permitted to fields associated with the corresponding
               interrupt.
          0b01 Non-secure write access is permitted to fields associated with the corresponding
               interrupt in the GICD_ISPENDRn registers. A Non-secure write access to
               GICD_SGIR is permitted to generate a Group 0 SGI for the corresponding
               interrupt.
          0b10 Adds Non-secure write access permission to fields associated with the
               corresponding interrupt in the GICD_ICPENDRn registers. Also adds
               Non-secure read access permission to fields associated with the corresponding
               interrupt in the GICD_ISACTIVERn and GICD_ICACTIVERn registers.
          0b11 Adds Non-secure read and write access permission to fields associated with the
               corresponding interrupt in the GICD_ITARGETSRn registers.
          The GICD_NSACRn registers do not support PPI accesses, meaning that GICD_NSACR0 bits [31:16] are
          RAZ/WI.
          For interrupt ID m, when DIV and MOD are the integer division and modulo operations:
          a. the corresponding GICD_NSACR number, n, is given by n = m DIV 16
          b. the offset of the required GICD_NSACRn is (0xE00 + (4*n)).</comment>
      </reg>
      <hole size="1792"/>
      <reg name="gicd_sgir" protect="rw">
        <bits access="w" name="targetlistfilter" pos="25:24" rst="0">
          <comment>Determines how the distributor must process the requested SGI:
          0b00 Forward the interrupt to the CPU interfaces specified in the CPUTargetList fielda.
          0b01 Forward the interrupt to all CPU interfaces except that of the processor that requested the
               interrupt.
          0b10 Forward the interrupt only to the CPU interface of the processor that requested the
               interrupt.
          0b11 Reserved.</comment>
        </bits>
        <bits access="w" name="cputargetlist" pos="23:16" rst="0">
          <comment>When TargetList Filter = 0b00, defines the CPU interfaces to which the Distributor must forward the
          interrupt.
          Each bit of CPUTargetList[7:0] refers to the corresponding CPU interface, for example
          CPUTargetList[0] corresponds to CPU interface 0. Setting a bit to 1 indicates that the interrupt must be
          forwarded to the corresponding interface.
          If this field is 0x00 when TargetListFilter is 0b00, the Distributor does not forward the interrupt to any
          CPU interface.</comment>
        </bits>
        <bits access="w" name="nsatt" pos="15" rst="0">
          <comment>Implemented only if the GIC includes the Security Extensions.
          Specifies the required security value of the SGI:
          0   Forward the SGI specified in the SGIINTID field to a specified CPU interface only if the
              SGI is configured as Group 0 on that interface.
          1   Forward the SGI specified in the SGIINTID field to a specified CPU interfaces only if
              the SGI is configured as Group 1 on that interface.
          This field is writable only by a Secure access. Any Non-secure write to the GICD_SGIR generates an
          SGI only if the specified SGI is programmed as Group 1, regardless of the value of bit[15] of the write.</comment>
        </bits>
        <bits access="w" name="sgiintid" pos="3:0" rst="0">
          <comment>The Interrupt ID of the SGI to forward to the specified CPU interfaces. The value of this field is the
          Interrupt ID, in the range 0-15, for example a value of 0b0011 specifies Interrupt ID 3.</comment>
        </bits>
      </reg>
      <hole size="96"/>
      <reg count="4" name="gicd_cpendsgirn" protect="rw">
        <comment>The GICD_CPENDSGIRs provide a clear-pending bit for each supported SGI and source
          processor combination.
          For each bit:
          Reads  0 SGI x from the corresponding processor is not pending.
                 1 SGI x from the corresponding processor is pending.
          Writes 0 Has no effect.
                 1 Removes the pending state of SGI x for the corresponding processor.
          For SGI ID x, generated by CPU C writing to its GICD_SGIR, when DIV and MOD are the integer division and
          modulo operations:
          a. the corresponding GICD_CPENDSGIR register number, n, is given by n = x DIV 4
          b. the offset of the required GICD_CPENDSGIR is (0xF10 + (4*n));
          c. the SGI Clear-pending field offset, y, is given by y = x MOD 4
          d. the required bit in the SGI x Clear-pending field is bit C.</comment>
      </reg>
      <reg count="4" name="gicd_spendsgirn" protect="rw">
        <comment>The GICD_SPENDSGIRn registers provide a set-pending bit for each supported SGI and
          source processor combination.
          For each bit:
          Reads  0 SGI x for the corresponding processor is not pendinga.
                 1 SGI x for the corresponding processor is pendinga.
          Writes 0 Has no effect.
                 1 Adds the pending state of SGI x for the corresponding processor,
                   if it is not already pending. If SGI x is already pending for the
                   corresponding processor then the write has no effect.
          For SGI ID x, generated by CPU C writing to its GICD_SGIR, when DIV and MOD are the integer division and
          modulo operations:
          a. the corresponding GICD_SPENDSGIR register number, n, is given by n = x DIV 4
          b. the offset of the required GICD_SPENDSGIR is (0xF20 + (4*n))
          c. the SGI Set-pending field offset, y, is given by y = x MOD 4
          d. the required bit in the SGI x Set-pending field is bit C.</comment>
      </reg>
      <hole size="1664"/>
      <reg name="gicc_ctrl" protect="rw">
        <bits access="rw" name="eoimodens" pos="10" rst="0">
          <comment>Alias of EOImodeNS from the Non-secure copy of this register.</comment>
        </bits>
        <bits access="rw" name="eoimodes" pos="9" rst="0">
          <comment>Controls the behavior of accesses to GICC_EOIR and GICC_DIR registers. In a GIC implementation
          that includes the Security Extensions, this control applies only to Secure accesses, and the EOImodeNS
          bit controls the behavior of Non-secure accesses to these registers:
          0   GICC_EOIR has both priority drop and deactivate interrupt functionality. Accesses to
              the GICC_DIR are UNPREDICTABLE.
          1   GICC_EOIR has priority drop functionality only. GICC_DIR has deactivate interrupt
              functionality.</comment>
        </bits>
        <bits access="rw" name="irqbypdisgrp1" pos="8" rst="0">
          <comment>Alias of IRQBypDisGrp1 from the Non-secure copy of this register.</comment>
        </bits>
        <bits access="rw" name="fiqbypdisgrp1" pos="7" rst="0">
          <comment>Alias of FIQBypDisGrp1 from the Non-secure copy of this register.</comment>
        </bits>
        <bits access="rw" name="irqbypdisgrp0" pos="6" rst="0">
          <comment>When the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the bypass
          IRQ signal is signaled to the processor:
          0 Bypass IRQ signal is signaled to the processor
          1 Bypass IRQ signal is not signaled to the processor.</comment>
        </bits>
        <bits access="rw" name="fiqbypdisgrp0" pos="5" rst="0">
          <comment>When the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the bypass
          FIQ signal is signaled to the processor:
          0 Bypass FIQ signal is signaled to the processor
          1 Bypass FIQ signal is not signaled to the processor.</comment>
        </bits>
        <bits access="rw" name="cbpr" pos="4" rst="0">
          <comment>Controls whether the GICC_BPR provides common control to Group 0 and Group 1 interrupts.
          0 To determine any preemption, use:
          ? the GICC_BPR for Group 0 interrupts
          ? the GICC_ABPR for Group 1 interrupts.
          1 To determine any preemption use the GICC_BPR for both Group 0 and Group 1
          interrupts.</comment>
        </bits>
        <bits access="rw" name="fiqen" pos="3" rst="0">
          <comment>Controls whether the CPU interface signals Group 0 interrupts to a target processor using the FIQ or
          the IRQ signal.
          0 Signal Group 0 interrupts using the IRQ signal.
          1 Signal Group 0 interrupts using the FIQ signal.
          The GIC always signals Group 1 interrupts using the IRQ signal.</comment>
        </bits>
        <bits access="rw" name="ackctl" pos="2" rst="0">
          <comment>When the highest priority pending interrupt is a Group 1 interrupt, determines both:
          ? whether a read of GICC_IAR acknowledges the interrupt, or returns a spurious interrupt ID
          ? whether a read of GICC_HPPIR returns the ID of the highest priority pending interrupt, or
          returns a spurious interrupt ID.
          0 If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR
          or the GICC_HPPIR returns an Interrupt ID of 1022. A read of the GICC_IAR does
          not acknowledge the interrupt, and has no effect on the pending status of the interrupt.
          1 If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR
          or the GICC_HPPIR returns the Interrupt ID of the Group 1 interrupt. A read of
          GICC_IAR acknowledges and Activates the interrupt.</comment>
        </bits>
        <bits access="rw" name="enablegrp1" pos="1" rst="0">
          <comment>Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor:
          0 Disable signaling of Group 1 interrupts.
          1 Enable signaling of Group 1 interrupts.</comment>
        </bits>
        <bits access="rw" name="enablegrp0" pos="0" rst="0">
          <comment>Enable for the signaling of Group 0 interrupts by the CPU interface to the connected processor:
          0 Disable signaling of Group 0 interrupts.
          1 Enable signaling of Group 0 interrupts.</comment>
        </bits>
      </reg>
      <reg name="gicc_pmr" protect="rw">
        <bits access="rw" name="priority" pos="7:0" rst="0">
          <comment>The priority mask level for the CPU interface. If the priority of an interrupt is higher than the
          value indicated by this field, the interface signals the interrupt to the processor.
          If the GIC supports fewer than 256 priority levels then some bits are RAZ/WI, as follows:
          128 supported levels Bit [0] = 0.
          64 supported levels Bit [1:0] = 0b00.
          32 supported levels Bit [2:0] = 0b000.
          16 supported levels Bit [3:0] = 0b0000.</comment>
        </bits>
      </reg>
      <reg name="gicc_bpr" protect="rw">
        <bits access="rw" name="binary_point" pos="2:0" rst="2">
          <comment>The value of this field controls how the 8-bit interrupt priority field is split into a group
          priority field, used to determine interrupt preemption, and a subpriority field.
          The minimum value of the Binary Point Register depends on which
          security-banked copy is considered:
          0x2 Secure copy
          0x3 Non-secure copy</comment>
        </bits>
      </reg>
      <reg name="gicc_iar" protect="r">
        <bits access="r" name="cpuid" pos="12:10" rst="0">
          <comment>For SGIs in a multiprocessor implementation, this field identifies the processor that
          requested the interrupt. It returns the number of the CPU interface that made the
          request, for example a value of 3 means the request was generated by a write to the
          GICD_SGIR on CPU interface 3.
          For all other interrupts this field is RAZ.</comment>
        </bits>
        <bits access="r" name="interrupt_id" pos="9:0" rst="1023">
          <comment>The interrupt ID.</comment>
        </bits>
      </reg>
      <reg name="gicc_eoir" protect="rw">
        <bits access="w" name="cpuid" pos="12:10" rst="0">
          <comment>On a multiprocessor implementation, if the write refers to an SGI, this
          the CPUID value from the corresponding GICC_IAR access.
          In all other cases this field SBZ.</comment>
        </bits>
        <bits access="w" name="eoiintid" pos="9:0" rst="0">
          <comment>The Interrupt ID value from the corresponding GICC_IAR access.</comment>
        </bits>
      </reg>
      <reg name="gicc_rpr" protect="r">
        <bits access="r" name="priority" pos="7:0" rst="255">
          <comment>The current running priority on the CPU interface.</comment>
        </bits>
      </reg>
      <reg name="gicc_hppir" protect="r">
        <bits access="r" name="cpuid" pos="12:10" rst="0">
          <comment>On a multiprocessor implementation, if the PENDINTID field returns the ID of an
          SGI, this field contains the CPUID value for that interrupt. This identifies the
          processor that generated the interrupt.
          In all other cases this field is RAZ.</comment>
        </bits>
        <bits access="r" name="pendintid" pos="9:0" rst="1023">
          <comment>The interrupt ID of the highest priority pending interrupt. See Table 4-42 on
          page 4-144 for more information about the result of Non-secure reads of the
          GICC_HPPIR when the GIC implements the Security Extensions.</comment>
        </bits>
      </reg>
      <reg name="gicc_abpr" protect="rw">
        <bits access="rw" name="binary_point" pos="2:0" rst="3">
          <comment>A Binary Point Register for handling Group 1 interrupts.</comment>
        </bits>
      </reg>
      <reg name="gicc_aiar" protect="r">
        <bits access="r" name="cpuid" pos="12:10" rst="0">
          <comment>CPUID For SGIs in a multiprocessor implementation, this field identifies the processor that
          requested the interrupt. It returns the number of the CPU interface that made the request,
          for example a value of 3 means the request was generated by a write to the GICD_SGIR
          on CPU interface 3.
          For all other interrupts this field is RAZ.</comment>
        </bits>
        <bits access="r" name="interrupt_id" pos="9:0" rst="1023">
          <comment>Interrupt ID The interrupt ID.</comment>
        </bits>
      </reg>
      <reg name="gicc_aeoir" protect="rw">
        <bits access="w" name="cpuid" pos="12:10" rst="0">
          <comment>On a multiprocessor implementation, when processing an SGI, this field must contain
          the CPUID value from the corresponding GICC_AIAR, or Non-secure GICC_IAR,
          access.
          In all other cases this field SBZ.</comment>
        </bits>
        <bits access="w" name="interrupt_id" pos="9:0" rst="0">
          <comment>The Interrupt ID value from the corresponding GICC_AIAR, or Non-secure GICC_IAR,
          access.</comment>
        </bits>
      </reg>
      <reg name="gicc_ahppir" protect="r">
        <bits access="r" name="cpuid" pos="12:10" rst="0">
          <comment>On a multiprocessor implementation, if the PENDINTID field returns the ID of an
          SGI, this field contains the CPUID value for that interrupt. This identifies the
          processor that generated the interrupt.
          In all other cases this field is RAZ.</comment>
        </bits>
        <bits access="r" name="pendintid" pos="9:0" rst="1023">
          <comment>The interrupt ID of the highest priority pending interrupt, if that interrupt is a Group 1
          interrupt. Otherwise, the spurious interrupt ID, 1023.</comment>
        </bits>
      </reg>
      <hole size="1312"/>
      <reg name="gicc_aprn" protect="rw">
        <comment>Active Priorities Registers</comment>
      </reg>
      <hole size="96"/>
      <reg name="gicc_nsaprn" protect="rw">
        <comment>NonSecure Active Priorities Registers</comment>
      </reg>
      <hole size="192"/>
      <reg name="gicc_iidr" protect="r">
        <bits access="r" name="productid" pos="31:24" rst="2">
          <comment>An IMPLEMENTATION DEFINED product identifier.</comment>
        </bits>
        <bits access="r" name="architecture_version" pos="19:16" rst="2">
          <comment>The value of this field depends on the GIC architecture version, as follows:
          ? 0x1 for GICv1
          ? 0x2 for GICv2.</comment>
        </bits>
        <bits access="r" name="revision" pos="15:12" rst="1">
          <comment>An IMPLEMENTATION DEFINED revision number for the CPU interface.</comment>
        </bits>
        <bits access="r" name="implementer" pos="11:0" rst="1083">
          <comment>Contains the JEP106 code of the company that implemented the GIC CPU
          interface:
          Bits [11:8] The JEP106 continuation code of the implementer.
          Bit  [7]    Always 0.
          Bits [6:0] The JEP106 identity code of the implementer.</comment>
        </bits>
      </reg>
      <hole size="30720"/>
      <reg name="gicc_dir" protect="rw">
        <bits access="w" name="cpuid" pos="12:10" rst="0">
          <comment>For an SGI in a multiprocessor implementation, this field
          identifies the processor that requested the interrupt.
          For all other interrupts this field is RAZ.</comment>
        </bits>
        <bits access="w" name="interrupt_id" pos="9:0" rst="0">
          <comment>The interrupt ID</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x00800000" name="GIC400" type="GIC400"/>
  </archive>
  <archive relative="gouda.xml">
    <include file="globals.xml"/>
    <module category="System" name="GOUDA">
      <var name="GD_MAX_OUT_WIDTH" value="640"/>
      <comment>Maximum output width in pixels</comment>
      <var name="GD_NB_BITS_LCDPOS" value="11"/>
      <comment>Number of bits coding position in virtual screen</comment>
      <var name="GD_FP_FRAC_SIZE" value="8"/>
      <comment>Number of bits of fractional part of internal fixed point values</comment>
      <var name="GD_FIXEDPOINT_SIZE" value="3+GD_FP_FRAC_SIZE"/>
      <comment>Number of bits of internal fixed point values</comment>
      <var name="GD_NB_BITS_STRIDE" value="13"/>
      <comment>Number of bits for stride storage</comment>
      <var name="GD_MAX_SLCD_READ_LEN" value="4"/>
      <var name="GD_MAX_SLCD_CLK_DIVIDER" value="255"/>
      <reg name="gd_command" protect="rw">
        <bits access="rw" name="start" pos="0" rst="0x0">
          <comment>Starts the image transfer. Autoreset</comment>
        </bits>
      </reg>
      <reg name="gd_status" protect="r">
        <bits access="r" name="ia_busy" pos="0" rst="0x0">
          <comment>High while image accelerator is busy</comment>
        </bits>
        <bits access="r" name="lcd_busy" pos="4" rst="0x0">
          <comment>High while LCD controller is busy</comment>
        </bits>
      </reg>
      <reg name="gd_eof_irq" protect="rc">
        <bits access="rc" name="eof_cause" pos="0" rst="0x0">
          <comment>
            High when End Of Frame IRQ has been generated.
            <br/>
            To clear it, write 1 in this bit or in eof_status.
          </comment>
        </bits>
        <bits access="rc" name="eof_status" pos="16" rst="0x0">
          <comment>
            Unmasked version of eof_cause.
            <br/>
            To clear it, write 1 in this bit or in eof_status.
          </comment>
        </bits>
      </reg>
      <reg name="gd_eof_irq_mask" protect="rw">
        <bits access="rw" name="eof_mask" pos="0" rst="0x0">
          <comment>
            EOF interrupt generation mask:
            <br/>
            0: EOF IRQ disabled
            <br/>
            1: EOF IRQ enabled
          </comment>
        </bits>
      </reg>
      <reg name="gd_roi_tl_ppos" protect="rw">
        <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
          <comment>LCD Region Of Interest Top-Left pixel x-axis</comment>
        </bits>
        <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
          <comment>LCD Region Of Interest Top-Left pixel y-axis</comment>
        </bits>
      </reg>
      <reg name="gd_roi_br_ppos" protect="rw">
        <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
          <comment>LCD Region Of Interest Bottom-Right pixel x-axis</comment>
        </bits>
        <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
          <comment>LCD Region Of Interest Bottom-Right pixel y-axis</comment>
        </bits>
      </reg>
      <reg name="gd_roi_bg_color" protect="rw">
        <bits access="rw" name="b" pos="4:0" rst="0x0">
          <comment>Blue component of the ROI background color</comment>
        </bits>
        <bits access="rw" name="g" pos="10:5" rst="0x0">
          <comment>Green component of the ROI background color</comment>
        </bits>
        <bits access="rw" name="r" pos="15:11" rst="0x0">
          <comment>Red component of the ROI background color</comment>
        </bits>
      </reg>
      <reg name="gd_vl_input_fmt" protect="rw">
        <bits access="rw" name="format" pos="1:0" rst="0x0">
          <comment>
            Input image format
            <br/>
            00b: RGB565 pixel packed
            <br/>
            01b: YUV4:2:2 pixel packed (UYVY)
            <br/>
            10b: YUV4:2:2 pixel packed (YUYV)
            <br/>
            11b: YUV4:2:0 planar (IYUV)
          </comment>
        </bits>
        <bits access="rw" name="stride" pos="GD_NB_BITS_STRIDE+1:2" rst="0x0">
          <comment>
            Image stride in bytes (of Y component for planar formats).
            <br/>
            This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
          </comment>
        </bits>
        <bits access="rw" name="active" pos="31" rst="0x0">
          <comment>
            Defines Layer's activity:
            <br/>
            0: Layer disabled
            <br/>
            1: Layer active
          </comment>
        </bits>
      </reg>
      <reg name="gd_vl_tl_ppos" protect="rw">
        <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
          <comment>Video Layer (layer 0) Top-Left pixel x-axis position</comment>
        </bits>
        <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
          <comment>Video Layer (layer 0) Top-Left pixel y-axis position</comment>
        </bits>
      </reg>
      <reg name="gd_vl_br_ppos" protect="rw">
        <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
          <comment>Video Layer (layer 0) Bottom-Right pixel x-axis position</comment>
        </bits>
        <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
          <comment>Video Layer (layer 0) Bottom-Right pixel y-axis position</comment>
        </bits>
      </reg>
      <reg name="gd_vl_extents" protect="rw">
        <bits access="rw" name="max_line" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
          <comment>Number of lines of source image (idem gd_vl_br_ppos.y1 when
                 vertical scaling factor is one).</comment>
        </bits>
        <bits access="rw" name="max_col" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
          <comment>Number of columns of source image (idem gd_vl_br_ppos.x1 when
                 vertical scaling factor is one).</comment>
        </bits>
      </reg>
      <reg name="gd_vl_blend_opt" protect="rw">
        <bits access="rw" name="chroma key b" pos="4:0" rst="0x0">
          <comment>Blue component of the Chroma Key</comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="chroma key g" pos="10:5" rst="0x0">
          <comment>Green component of the Chroma Key</comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="chroma key r" pos="15:11" rst="0x0">
          <comment>Red component of the Chroma Key</comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bitgroup name="chroma key color">
          <entry ref="chroma key b"/>
          <entry ref="chroma key g"/>
          <entry ref="chroma key r"/>
        </bitgroup>
        <bits access="rw" name="chroma key enable" pos="16" rst="0x0">
          <comment>Enables the Chroma Keying</comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="chroma key mask" pos="19:17" rst="0x0">
          <comment>
            Allows a range of color for the Chroma Keying:
            <br/>
            000b: exact color match
            <br/>
            001b: disregard 1 LSBit of each color component for matching
            <br/>
            011b: disregard 2 LSBit of each color component for matching
            <br/>
            111b: disregard 3 LSBit of each color component for matching
          </comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="alpha" pos="27:20" rst="0x0">
          <comment>Layer Alpha blending coefficient</comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="rotation" pos="29:28" rst="0x0">
          <comment>
            Layer rotation selection
            <br/>
            00b: No rotation
            <br/>
            01b: 90  degrees rotation (clockwise)
            <br/>
            10b: reserved
            <br/>
            11b: reserved
          </comment>
          <options>
            <mask/>
          </options>
        </bits>
        <bits access="rw" name="depth" pos="31:30" rst="0x0">
          <comment>
            Layer depth
            <br/>
            00b: Video layer behind all Overlay layers
            <br/>
            01b: Video layer between Overlay layers 1 and 0
            <br/>
            10b: Video layer between Overlay layers 2 and 1
            <br/>
            11b: Video layer on top of all Overlay layers
          </comment>
          <options>
            <mask/>
          </options>
        </bits>
      </reg>
      <reg name="gd_vl_y_src" protect="rw">
        <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
          <comment>Dword-aligned address of the Y component (or RGB) of the source image</comment>
        </bits>
      </reg>
      <reg name="gd_vl_u_src" protect="rw">
        <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
          <comment>Dword-aligned address of the U component of the source image</comment>
        </bits>
      </reg>
      <reg name="gd_vl_v_src" protect="rw">
        <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
          <comment>Dword-aligned address of the V component of the source image</comment>
        </bits>
      </reg>
      <reg name="gd_vl_resc_ratio" protect="rw">
        <bits access="rw" name="xpitch" pos="GD_FIXEDPOINT_SIZE-1:0" rst="0x0">
          <comment>Video layer rescaling ratio upon x-axis. This is a 2.8 fixed point number representing the input/output width ratio.</comment>
        </bits>
        <bits access="rw" name="ypitch" pos="GD_FIXEDPOINT_SIZE+15:16" rst="0x0">
          <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
        </bits>
        <bits access="w" name="pre_fetch_en" pos="29" rst="0x0">
          <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
        </bits>
        <bits access="rw" name="iy_dctenable" pos="30" rst="0x0">
          <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
        </bits>
        <bits access="rw" name="ypitch_scale_enable" pos="31" rst="0x0">
          <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
        </bits>
      </reg>
      <struct count="3" name="overlay_layer">
        <comment>The Overlay layers have a fixed depth relative to their index. Overlay layer 0 is the first to be drawn (thus the deepest), overlay layer 2 is the last to be drawn.</comment>
        <reg name="gd_ol_input_fmt" protect="rw">
          <bits access="rw" name="format" pos="1:0" rst="0x0">
            <comment>
              Input image format
              <br/>
              0: RGB565 pixel packed
              <br/>
              1: ARGB8888 pixel packed
              <br/>
              others: reserved
            </comment>
          </bits>
          <bits access="rw" name="stride" pos="GD_NB_BITS_STRIDE+1:2" rst="0x0">
            <comment>
              Image stride in 16-bits word.
              <br/>
              This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
            </comment>
          </bits>
          <bits access="rw" name="prefetch" pos="18" rst="0x1">
            <comment>
              Image stride in 16-bits word.
              <br/>
              This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
            </comment>
          </bits>
          <bits access="rw" name="active" pos="31" rst="0x0">
            <comment>
              Defines Layer's activity:
              <br/>
              0: Layer disabled
              <br/>
              1: Layer active
            </comment>
          </bits>
        </reg>
        <reg name="gd_ol_tl_ppos" protect="rw">
          <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
            <comment>Overlay Layer (layer X+1) Top-Left pixel x-axis position</comment>
          </bits>
          <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
            <comment>Overlay Layer (layer X+1) Top-Left pixel y-axis position</comment>
          </bits>
        </reg>
        <reg name="gd_ol_br_ppos" protect="rw">
          <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
            <comment>Overlay Layer (layer X+1) Bottom-Right pixel x-axis position</comment>
          </bits>
          <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
            <comment>Overlay Layer (layer X+1) Bottom-Right pixel y-axis position</comment>
          </bits>
        </reg>
        <reg name="gd_ol_blend_opt" protect="rw">
          <bits access="rw" name="chroma key b" pos="4:0" rst="0x0">
            <comment>Blue component of the Chroma Key</comment>
          </bits>
          <bits access="rw" name="chroma key g" pos="10:5" rst="0x0">
            <comment>Green component of the Chroma Key</comment>
          </bits>
          <bits access="rw" name="chroma key r" pos="15:11" rst="0x0">
            <comment>Red component of the Chroma Key</comment>
          </bits>
          <bitgroup name="chroma key color">
            <entry ref="chroma key b"/>
            <entry ref="chroma key g"/>
            <entry ref="chroma key r"/>
          </bitgroup>
          <bits access="rw" name="chroma key enable" pos="16" rst="0x0">
            <comment>Enables the Chroma Keying</comment>
          </bits>
          <bits access="rw" name="chroma key mask" pos="19:17" rst="0x0">
            <comment>
              Allows a range of color for the Chroma Keying:
              <br/>
              000b: exact color match
              <br/>
              001b: disregard 1 LSBit of each color component for matching
              <br/>
              011b: disregard 2 LSBit of each color component for matching
              <br/>
              111b: disregard 3 LSBit of each color component for matching
            </comment>
          </bits>
          <bits access="rw" name="alpha" pos="27:20" rst="0x0">
            <comment>Layer Alpha blending coefficient</comment>
          </bits>
        </reg>
        <reg name="gd_ol_rgb_src" protect="rw">
          <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
            <comment>Dword-aligned address of the source image</comment>
          </bits>
        </reg>
      </struct>
      <reg name="gd_lcd_ctrl" protect="rw">
        <bits access="rw" name="destination" pos="1:0" rst="0x0">
          <comment>Destination Selection</comment>
          <options>
            <option name="LCD CS 0" value="0"/>
            <option name="LCD CS 1" value="1"/>
            <option name="Memory LCD type" value="2"/>
            <option name="Memory RAM" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="output format" pos="6:4" rst="0x0">
          <comment>
            Output format
            <br/>
            000b:  8-bit - RGB3:3:2 - 1cycle/1pixel - RRRGGGBB
            <br/>
            001b:  8-bit - RGB4:4:4 - 3cycle/2pixel - RRRRGGGG/BBBBRRRR/GGGGBBBB
            <br/>
            010b:  8-bit - RGB5:6:5 - 2cycle/1pixel - RRRRRGGG/GGGBBBBB
            <br/>
            011b:  reserved
            <br/>
            100b: 16-bit - RGB3:3:2 - 1cycle/2pixel - RRRGGGBBRRRGGGBB
            <br/>
            101b: 16-bit - RGB4:4:4 - 1cycle/1pixel - XXXXRRRRGGGGBBBB
            <br/>
            110b: 16-bit - RGB5:6:5 - 1cycle/1pixel - RRRRRGGGGGGBBBBB
            <br/>
            111b: 32-bit - RGB5:6:5 - 1cycle/2pixel - RRRRRGGGGGGBBBBB/RRRRRGGGGGGBBBBB
            <br/>
            <br/>
             The MSB select also the AHB access size (8-bit or 16-bit) when Memory destination is selected.
            <br/>
             Must set to RGB565 when RAM type destination selected
          </comment>
          <options>
            <option name="8-bit;RGB332" value="0"/>
            <option name="8-bit;RGB444" value="1"/>
            <option name="8-bit;RGB565" value="2"/>
            <option name="16-bit;RGB332" value="4"/>
            <option name="16-bit;RGB444" value="5"/>
            <option name="16-bit;RGB565" value="6"/>
          </options>
        </bits>
        <bits access="rw" name="high byte" pos="7" rst="0x0">
    </bits>
        <bits access="rw" name="cs0 polarity" pos="8" rst="0x0">
          <comment>
            Change Polarity of CS0 signal
            <br/>
             0: no change
            <br/>
             1: Inverted
          </comment>
        </bits>
        <bits access="rw" name="cs1 polarity" pos="9" rst="0x0">
          <comment>
            Change Polarity of CS1 signal
            <br/>
             0: no change
            <br/>
             1: Inverted
          </comment>
        </bits>
        <bits access="rw" name="rs polarity" pos="10" rst="0x0">
          <comment>
            Change Polarity of RS signal
            <br/>
             0: no change
            <br/>
             1: Inverted
          </comment>
        </bits>
        <bits access="rw" name="wr polarity" pos="11" rst="0x0">
          <comment>
            Change Polarity of WR signal
            <br/>
             0: no change
            <br/>
             1: Inverted
          </comment>
        </bits>
        <bits access="rw" name="rd polarity" pos="12" rst="0x0">
          <comment>
            Change Polarity of RD signal
            <br/>
             0: no change
            <br/>
             1: Inverted
          </comment>
        </bits>
        <bits access="rw" name="nb command" pos="21:16" rst="0x0">
          <comment>Number of command to be send to the LCD command (up to 31)</comment>
        </bits>
        <bits access="w" name="start command" pos="24" rst="0x0">
          <comment>Start command transfer only. Autoreset</comment>
        </bits>
        <bits access="rw" name="lcd resetb" pos="25" rst="0x1">
          <comment>LCD reset signal. Low active</comment>
        </bits>
      </reg>
      <reg name="gd_lcd_timing" protect="rw">
        <comment>All value are in cycle number of system clock</comment>
        <bits access="rw" name="tas" pos="2:0" rst="0x0">
          <comment>Address setup time (RS to WR, RS to RD)</comment>
        </bits>
        <bits access="rw" name="tah" pos="6:4" rst="0x0">
          <comment>Adress hold time</comment>
        </bits>
        <bits access="rw" name="pwl" pos="13:8" rst="0x0">
          <comment>Pulse Width Low level, between 2 and 63.</comment>
        </bits>
        <bits access="rw" name="pwh" pos="21:16" rst="0x0">
          <comment>Pulse Width High level, between 2 and 63 (must be &gt; (TAH+TAS) ).</comment>
        </bits>
      </reg>
      <reg name="gd_lcd_mem_address" protect="rw">
        <bits access="rw" name="addr_dst" pos="NB_BITS_ADDR-1:2" rst="all0">
          <comment>
            Address destination pointer when memory destination is selected.
            <br/>
            The addr_dst[1] which correspond to the M_A[0] on the memory interface is used to select between command/data.
          </comment>
        </bits>
      </reg>
      <reg name="gd_lcd_stride_offset" protect="rw">
        <bits access="rw" name="stride_offset" pos="9:0" rst="all0">
          <comment>
            Address offset (in Bytes) skipped at the end of each line when memory destination is selected.
            <br/>
            This 2D feature allows for in-memory image compositing.
          </comment>
        </bits>
      </reg>
      <reg name="gd_lcd_single_access" protect="rw">
        <bits access="rw" name="lcd_data" pos="15:0" rst="all0">
          <comment>data to write or data readen (the readen data is ready when the lcd is not busy)</comment>
        </bits>
        <bits access="rw" name="type" pos="16" rst="0x0">
          <comment>
            Acesss type selection
            <br/>
            0: Command
            <br/>
            1: Data
          </comment>
        </bits>
        <bits access="w" name="start_write" pos="17" rst="0x0">
          <comment>Start a single write access. Autoreset</comment>
        </bits>
        <bits access="w" name="start_read" pos="18" rst="0x0">
          <comment>Start a single read access (only when LCD output selected). Autoreset.</comment>
        </bits>
      </reg>
      <reg name="gd_spilcd_config" protect="rw">
        <bits access="rw" name="spi_lcd_select" pos="0" rst="0"> </bits>
        <bits access="rw" name="spi_device_id" pos="6:1" rst="all0">
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="spi_clk_divider" pos="14:7" rst="0a">
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="spi_dummy_cycle" pos="17:15" rst="all0">
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="spi_line" pos="19:18" rst="all0">
          <comment>0:4 line mode
                   1:3 line mode
                   2:command mode
                   3:3 line 2 lane mode tx</comment>
          <options>
            <mask/>
            <option name="4" value="0"/>
            <option name="3" value="1"/>
            <option name="4_Start_Byte" value="2"/>
            <option name="3_Two_Lane" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="spi_rx_byte" pos="22:20" rst="all0">
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="spi_rw" pos="23" rst="0">
          <options>
            <option name="Write" value="0"/>
            <option name="Read" value="1"/>
          </options>
        </bits>
      </reg>
      <reg name="gd_spilcd_rd" protect="r">
        <comment/>
      </reg>
      <reg name="gd_vl_fix_ratio" protect="rw">
        <bits access="rw" name="reg_vl_only_sel" pos="19" rst="0x0">
          <comment/>
        </bits>
        <bits access="rw" name="mirror" pos="18" rst="0x0">
          <comment>Mirror enable.</comment>
        </bits>
        <bits access="rw" name="l_yfixen" pos="17" rst="0x0">
          <comment>.</comment>
        </bits>
        <bits access="rw" name="l_xfixen" pos="16" rst="0x0">
          <comment>.</comment>
        </bits>
        <bits access="rw" name="l_yratio" pos="15:8" rst="0x0">
          <comment>.</comment>
        </bits>
        <bits access="rw" name="l_xratio" pos="7:0" rst="0x0">
          <comment>.</comment>
        </bits>
      </reg>
      <hole size="(80-38-1)*32"/>
      <reg name="tecon" protect="rw">
        <bits access="rw" name="te_count2" pos="27:16" rst="0x0">
          <comment>Count value to detect vsync pulse</comment>
        </bits>
        <bits access="rw" name="te_mode" pos="2" rst="0x0">
          <comment>0:vsync te only 1:vsync and hsync te</comment>
        </bits>
        <bits access="rw" name="te_edge_sel" pos="1" rst="0x0">
          <comment>Pol select</comment>
        </bits>
        <bits access="rw" name="te_en" pos="0" rst="0x0">
          <comment>Te enable.</comment>
        </bits>
      </reg>
      <reg name="tecon2" protect="rw">
        <bits access="rw" name="te_count1" pos="28:0" rst="0x0">
          <comment>Te counter value</comment>
        </bits>
      </reg>
      <hole size="(256-81-1)*32"/>
    </module>
    <module category="System" name="GOUDA_SRAM">
      <var name="GD_NB_WORKBUF_WORDS" value="5856"/>
      <var name="GD_NB_LCD_CMD_WORDS" value="64"/>
      <var name="GD_SRAM_SIZE" value="(GD_NB_WORKBUF_WORDS+GD_NB_LCD_CMD_WORDS)*2"/>
      <var name="GD_SRAM_ADDR_WIDTH" value="13"/>
      <memory name="sram_array" size="GD_SRAM_SIZE">
        <comment>Gouda internal Sram space</comment>
      </memory>
    </module>
    <instance address="0x04804000" name="GOUDA" type="GOUDA"/>
  </archive>
  <archive relative="i2c_master.xml">
    <module category="Periph" name="I2C_MASTER">
      <reg name="ctrl" protect="rw">
        <bits access="rw" name="en" pos="0" rst="0">
          <comment>I2C master enable, high active.</comment>
        </bits>
        <bits access="rw" name="irq_mask" pos="8" rst="0">
          <comment>I2C master interrupt enable, high active.</comment>
        </bits>
        <bits access="rw" name="clock_prescale" pos="31:16" rst="0xFFFF">
          <comment>
            This register is used to prescale the SCL clock line. Due to the structure of I2C interface, this module uses a 5*SCL clock frequency. Clock_Prescale must be programmed to this 5*SCL clock frequency (minus 1). Change the value of Clock_Prescale only when bit EN is cleared.
            <br/>
            <br/>
             Example:
            <br/>
             PCLK_MOD is 52 MHz, desired SCL is 100 KHz.
            <br/>
             Prescale = 52MHz / (5 * 100KHz) -1 = 103.
          </comment>
          <options>
            <mask/>
          </options>
        </bits>
      </reg>
      <reg name="status" protect="r">
        <bits access="r" name="irq_cause" pos="0" rst="0">
          <comment>IRQ Cause bit. This bit is set when one byte transfer has been completed or arbitration is lost, this bit is generated by bit IRQ_Status AND bit IRQ_MASK.</comment>
        </bits>
        <bits access="r" name="irq_status" pos="4" rst="0">
          <comment>IRQ status bit.</comment>
        </bits>
        <bits access="r" name="tip" pos="8" rst="0">
          <comment>TIP, Transfer in progress.
				'1' when transferring data. '0' when transfer complete.</comment>
        </bits>
        <bits access="r" name="al" pos="12" rst="0">
          <comment>AL,Arbitration lost.
				This bit is set when the I2C master lost arbitration.</comment>
        </bits>
        <bits access="r" name="busy" pos="16" rst="0">
          <comment>Busy,I2C bus busy.
				'1' after START signal detected.
				'0' after STOP signal detected.</comment>
        </bits>
        <bits access="r" name="rxack" pos="20" rst="0">
          <comment>RxACK, Received acknowledge from slave.
				'1'= &quot;No ACK&quot; received.
				'0'= ACK received.</comment>
        </bits>
      </reg>
      <reg name="txrx_buffer" protect="rw">
        <bits access="w" name="tx_data" pos="7:0" rst="-">
          <comment>
            Byte to transmit via I2C.
            <br/>
             for Bit 0, In case of a data transfer this bit represents the data's LSB. In case of a slave address transfer this bit represents the RW bit.
            <br/>
             '1' = reading from slave.
            <br/>
             '0' = writing to slave.
          </comment>
        </bits>
        <bits access="r" name="rx_data" pos="7:0" rst="-">
          <comment>Last byte received via I2C.</comment>
        </bits>
      </reg>
      <reg name="cmd" protect="w">
        <bits access="w" name="ack" pos="0" rst="0">
          <comment>ACK,when master works as a receiver,sent ACK(ACK='0') or NACK(ACK='1').</comment>
        </bits>
        <bits access="w" name="rd" pos="4" rst="0">
          <comment>RD,read from slave, this bit is auto cleared.</comment>
        </bits>
        <bits access="w" name="sto" pos="8" rst="0">
          <comment>STO,generate stop condition, this bit is auto cleared.</comment>
        </bits>
        <bits access="w" name="rw" pos="12" rst="0">
          <comment>WR,write to slave, this bit is auto cleared.</comment>
        </bits>
        <bits access="w" name="sta" pos="16" rst="0">
          <comment>STA,generate (repeated) start condition, this bit is auto cleared.</comment>
        </bits>
      </reg>
      <reg name="irq_clr" protect="rw">
        <bits access="c" name="irq_clr" pos="0" rst="0">
          <comment>When write '1', clears a pending I2C interrupt.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04807000" name="I2C_MASTER1" type="I2C_MASTER"/>
    <instance address="0x04808000" name="I2C_MASTER2" type="I2C_MASTER"/>
    <instance address="0x51504000" name="I2C_MASTER3" type="I2C_MASTER"/>
  </archive>
  <archive relative="lps_ifc.xml">
    <var name="LPS_NB_BITS_ADDR" value="32"/>
    <var name="LPS_IFC_ADDR_ALIGN" value="0"/>
    <var name="LPS_IFC_TC_LEN" value="23"/>
    <var name="LPS_IFC_STD_CHAN_NB" value="2"/>
    <var name="LPS_IFC_RFSPI_CHAN" value="0"/>
    <var name="LPS_IFC_AIF_CHAN" value="0"/>
    <var name="LPS_IFC_DBG_CHAN" value="0"/>
    <enum name="LPS_IFC_Request_IDs">
      <entry name="DMA_ID_TX_UART1"/>
      <entry name="DMA_ID_RX_UART1"/>
    </enum>
    <module category="System" name="LPS_IFC">
      <reg name="get_ch" protect="--">
        <bits access="r" name="ch_to_use" pos="4:0" rst="0">
          <comment>
            This field indicates which standard channel to use.
            <br/>
             Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
            <br/>
             After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
            <br/>
            Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
            <br/>
            Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
            <br/>
            When non-secure cpu read this register, the return value will automatic exlude the secure channel.
            <br/>
            00000 = use Channel0
            <br/>
            00001 = use Channel1
            <br/>
            00010 = use Channel2
            <br/>
             ...
            <br/>
            01111 = use Channel15
            <br/>
            11111 = all channels are busy
          </comment>
          <options>
            <mask/>
            <shift/>
            <default/>
          </options>
        </bits>
      </reg>
      <reg name="dma_status" protect="r">
        <bits access="r" name="ch_enable" pos="LPS_IFC_STD_CHAN_NB+LPS_IFC_RFSPI_CHAN-1:0" rst="0">
          <comment>
            This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels disabled
            <br/>
            0000_0001 = Ch0 enabled
            <br/>
            0000_0010 = Ch1 enabled
            <br/>
            0000_0100 = Ch2 enabled
            <br/>
            0000_0101 = Ch0 and Ch2 enabled
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 enabled
            <br/>
            all 1     = all channels enabled
          </comment>
        </bits>
        <bits access="r" name="ch_busy" pos="LPS_IFC_STD_CHAN_NB-1+16:16" rst="0">
          <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
        </bits>
      </reg>
      <reg name="debug_status" protect="r">
        <bits access="r" name="dbg_status" pos="0" rst="1">
          <comment>
            Debug Channel Status .
            <br/>
            0= The debug channel is running
      (not idle)
            <br/>
            1= The debug channel is in idle mode
          </comment>
        </bits>
      </reg>
      <reg name="ifc_sec" protect="rw">
        <bits access="rw" name="std_ch_reg_sec" pos="LPS_IFC_STD_CHAN_NB-1:0" rst="0">
          <comment>
            This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels registers can be accessed by secure master or non-secure master.
            <br/>
            0000_0001 = Ch0 registers can only be accessed by secure master.
            <br/>
            0000_0010 = Ch1 registers can only be accessed by secure master.
            <br/>
            0000_0100 = Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels registers can only be accessed by secure master.
          </comment>
        </bits>
        <bits access="rw" name="std_ch_dma_sec" pos="LPS_IFC_STD_CHAN_NB-1+16:16" rst="all1">
          <comment>
            This register indicates which channel dma is secure master. One bit per
      channel, for example:
            <br/>
            0000_0000 = All channels dma are non-secure master.
            <br/>
            0000_0001 = Ch0 dma is secure master.
            <br/>
            0000_0010 = Ch1 dma is secure master.
            <br/>
            0000_0100 = Ch2 dma is secure master.
            <br/>
            0000_0101 = Ch0 and Ch2 dma are secure master.
            <br/>
            0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
            <br/>
             ......
            <br/>
            all 1 = all channels dma are secure master.
          </comment>
        </bits>
      </reg>
      <struct count="LPS_IFC_STD_CHAN_NB" name="std_ch">
        <reg name="control" protect="rw">
          <bits access="w" name="enable" pos="0" rst="no">
            <comment>
              Channel Enable, write one in this bit enable the channel.
              <br/>
              When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer.
            </comment>
          </bits>
          <bits access="w" name="disable" pos="1" rst="no">
            <comment>
              Channel Disable, write one in this bit disable the channel.
              <br/>
              When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled.
            </comment>
          </bits>
          <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
            <comment>
              Exchange the read data from fifo halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
            <comment>
              Exchange the write data to fifo  halfword MSB or LSB
              <br/>
            </comment>
          </bits>
          <bits access="rw" name="autodisable" pos="4" rst="1">
            <comment>
              Set Auto-disable mode
              <br/>
               0 = when TC reach zero the
        channel is not automatically released.
              <br/>
               1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.
            </comment>
          </bits>
          <bits access="rw" name="size" pos="5" rst="0">
            <comment>
              Peripheral Size
              <br/>
               0= 8-bit peripheral
              <br/>
               1= 32-bit peripheral
            </comment>
          </bits>
          <bits access="rw" display="hex" name="req_src" pos="12:8" rst="0x1F">
            <options linkenum="LPS_IFC_Request_IDs">
              <shift/>
              <mask/>
              <default/>
            </options>
            <comment>Select DMA Request source</comment>
          </bits>
          <bits access="rw" name="flush" pos="16" rst="0">
            <comment>
              When one, flush the internal FIFO channel.
              <br/>
              This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel.
              <br/>
               Before writting back this bit to zero the internal fifo must empty.
            </comment>
          </bits>
          <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
            <comment>
              Set the MAX burst length for channel 0,1.
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.
              <br/>
               The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4.
              <br/>
               .
            </comment>
          </bits>
        </reg>
        <reg name="status" protect="r">
          <bits access="r" name="enable" pos="0" rst="0">
            <comment>Enable bit, when '1' the channel is running</comment>
          </bits>
          <bits access="r" name="fifo_empty" pos="4" rst="1">
            <comment>The internal channel fifo is empty</comment>
          </bits>
        </reg>
        <reg name="start_addr" protect="rw">
          <bits access="rw" display="hex" name="start_addr" pos="LPS_NB_BITS_ADDR-1:LPS_IFC_ADDR_ALIGN" rst="0xFFFFFFF">
            <comment>
              AHB Address. This field represent the start address of the
        transfer.
              <br/>
              For a 32-bit peripheral, this address must be aligned 32-bit.
            </comment>
          </bits>
        </reg>
        <reg name="tc" protect="rw">
          <bits access="rw" display="hex" name="tc" pos="LPS_IFC_TC_LEN-1:0" rst="0xFFFFFF">
            <comment>
              Transfer Count, this field indicated the transfer size in bytes to perform.
              <br/>
              During a transfer a write in this register add the new value to the current TC.
              <br/>
              A read of this register return the current current transfer count.
            </comment>
          </bits>
        </reg>
        <reg name="tc_threshold" protect="rw">
          <bits access="rw" display="hex" name="tc_threshold" pos="LPS_IFC_TC_LEN-1:0" rst="0x0">
            <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.</comment>
          </bits>
        </reg>
      </struct>
    </module>
    <instance address="0x5170e000" name="LPS_IFC" type="LPS_IFC"/>
  </archive>
  <archive relative="lzma.xml">
    <module category="System" name="LZMA">
      <reg name="lzma_cmd_reg" protect="rw">
        <bits access="rw" name="start" pos="0" rst="0">
          <comment>Writing 1 starts block decode</comment>
        </bits>
      </reg>
      <reg name="lzma_status_reg" protect="rw">
        <bits access="rw" name="axi_err" pos="2" rst="0">
          <comment>AXI bus error flag. Reading 1 indicates AXI bus operation fails and Lzma should be reset.</comment>
        </bits>
        <bits access="rw" name="dec_err" pos="1" rst="0">
          <comment>Decode error flag. Reading 1 indicates block decode error and Lzma should be reset.</comment>
        </bits>
        <bits access="rw" name="dec_done" pos="0" rst="0">
          <comment>Decode done flag. Reading 1 indicates block decode done, writing 1 clears.</comment>
        </bits>
      </reg>
      <reg name="lzma_irq_mask" protect="rw">
        <bits access="rw" name="axi_errirqmask" pos="2" rst="0">
          <comment>Writing 1 indicates a interrupt will be generated when lzma_status_reg[2]=1</comment>
        </bits>
        <bits access="rw" name="dec_errirqmask" pos="1" rst="0">
          <comment>Writing 1 indicates a interrupt will be generated when lzma_status_reg[1]=1</comment>
        </bits>
        <bits access="rw" name="dec_doneirqmask" pos="0" rst="0">
          <comment>Writing 1 indicates a interrupt will be generated when lzma_status_reg[0]=1</comment>
        </bits>
      </reg>
      <reg name="reserve0" protect="r">
        <comment>not used</comment>
      </reg>
      <reg name="lzma_config_reg1" protect="rw">
        <bits access="rw" name="reg_dict_size" pos="29:17" rst="0">
          <comment>Lzma dictionary size in byte</comment>
        </bits>
        <bits access="rw" name="reg_block_size" pos="16:0" rst="0">
          <comment>lzma block size in byte</comment>
        </bits>
      </reg>
      <reg name="lzma_config_reg2" protect="rw">
        <bits access="rw" name="reg_stream_len" pos="16:0" rst="0">
          <comment>lzma zip stream lenght in byte</comment>
        </bits>
      </reg>
      <reg name="lzma_config_reg3" protect="rw">
        <bits access="rw" name="reg_refbyte_en" pos="2" rst="0">
          <comment>1: refbyte enable; 0: refbyte disable</comment>
        </bits>
        <bits access="rw" name="reg_cabac_movebits" pos="1" rst="0">
          <comment>1: cabac_movebits=5; 0: cabac_movebits=4</comment>
        </bits>
        <bits access="rw" name="reg_cabac_totalbits" pos="0" rst="0">
          <comment>1: cabac_totalbits=11; 0: cabac_totalbits=10</comment>
        </bits>
      </reg>
      <reg name="lzma_status_reg2" protect="r">
        <bits access="r" name="stream_byte_pos" pos="16:0" rst="0">
          <comment>current decoding byte position in zip stream</comment>
        </bits>
      </reg>
      <reg name="lzma_status_reg3" protect="r">
        <bits access="r" name="dict_byte_pos" pos="16:0" rst="0">
          <comment>current recovering byte position in dictionary</comment>
        </bits>
      </reg>
      <reg name="lzma_error_type" protect="r">
        <bits access="r" name="inbuf_underflow" pos="6" rst="0">
          <comment>Equals to 1 when block decode finishes with zip stream reading byte position less than (reg_stream_len-2)</comment>
        </bits>
        <bits access="r" name="outbuf_overflow" pos="5" rst="0">
          <comment>Equals to 1 when block decode finishes with block buffer writing byte position exceeds the block size</comment>
        </bits>
        <bits access="r" name="symbol_len_err" pos="4" rst="0">
          <comment>Equals to 1 when a symbol is decoded as match type with length more than 273</comment>
        </bits>
        <bits access="r" name="symbol_reps_err0" pos="3" rst="0">
          <comment>Equals to 1 when a symbol is decoded as match type with reps0 more than dictionary size</comment>
        </bits>
        <bits access="r" name="symbol_reps_err1" pos="2" rst="0">
          <comment>Equals to 1 when a symbol is decoded as match type with reps0 more than dictionary recovery byte postion</comment>
        </bits>
        <bits access="r" name="symbol_type_err" pos="1" rst="0">
          <comment>Equals to 1 when first symbol in a block is decoded as match type</comment>
        </bits>
        <bits access="r" name="inbuf_overflow" pos="0" rst="0">
          <comment>Equals to 1 when zip stream reading byte position exceeds the stream length</comment>
        </bits>
      </reg>
      <reg name="reserve1" protect="r">
        <comment>not used</comment>
      </reg>
      <reg name="reserve2" protect="r">
        <comment>not used</comment>
      </reg>
      <reg name="lzma_input_crc" protect="r">
        <comment>Crc of lzma rdma read bytes</comment>
      </reg>
      <reg name="lzma_output_crc" protect="r">
        <comment>Crc of lzma wdma write bytes</comment>
      </reg>
      <reg name="reserve3" protect="r">
        <comment>not used</comment>
      </reg>
      <reg name="reserve4" protect="r">
        <comment>not used</comment>
      </reg>
      <reg name="lzma_dma_raddr_reg" protect="rw">
        <comment>Base address of lzma rdma</comment>
      </reg>
      <reg name="lzma_dma_waddr_reg" protect="rw">
        <comment>Base address of lzma wdma</comment>
      </reg>
      <reg name="lzma_inbuf_rwmargin_reg" protect="rw">
        <bits access="rw" name="inbuf_rwmargin_reg" pos="5:0" rst="10">
          <comment>Set the margin between input_buf wrptr and rdptr for pending the decode process</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04800000" name="LZMA" type="LZMA"/>
  </archive>
  <archive relative="rtc_timer.xml">
    <module category="System" name="RTC_TIMER">
      <reg name="ctrl" protect="rw">
        <bits access="rc" name="load_value" pos="6" rst="0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="rc" name="data_valid_clr" pos="5" rst="0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="r" name="data_valid" pos="4" rst="0">
      </bits>
        <bits access="rc" name="read_lock" pos="3" rst="0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="rw" name="wrap_int_enable" pos="2" rst="0">
      </bits>
        <bits access="rw" name="alarm_enable" pos="1" rst="0">
      </bits>
        <bits access="rw" name="timer_enable" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="cur_val_l" protect="r">
        <bits access="r" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="cur_val_m" protect="r">
        <bits access="r" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="cur_val_h" protect="r">
        <bits access="r" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="alarm_val_l" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="alarm_val_m" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="alarm_val_h" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="load_val_l" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="load_val_m" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="load_val_h" protect="rw">
        <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="int_mask" protect="rw">
        <bits access="rw" name="alarm" pos="1" rst="0">
      </bits>
        <bits access="rw" name="wrap" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="int_clr" protect="rw">
        <bits access="rc" name="alarm" pos="1" rst="0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
        <bits access="rc" name="wrap" pos="0" rst="0">
          <comment>bit type is changed from w1c to rc.</comment>
        </bits>
      </reg>
      <reg name="int_status" protect="r">
        <bits access="r" name="alarm" pos="1" rst="0">
      </bits>
        <bits access="r" name="wrap" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="int_cause" protect="r">
        <bits access="r" name="alarm" pos="1" rst="0">
      </bits>
        <bits access="r" name="wrap" pos="0" rst="0">
      </bits>
      </reg>
    </module>
    <instance address="0x51708000" name="RTC_TIMER" type="RTC_TIMER"/>
  </archive>
  <archive relative="sci.xml">
    <module category="Periph" name="SCI">
      <reg name="sci_config" protect="rw">
        <bits access="rw" name="enable" pos="0" rst="0">
          <comment>Enables the SIM Card IF module</comment>
        </bits>
        <bits access="rw" name="parity" pos="1" rst="0">
          <comment>Selects the parity generation/detection</comment>
          <options>
            <option name="Even_parity" value="0"/>
            <option name="Odd_parity" value="1"/>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="perf" pos="2" rst="0">
          <comment>
            Parity Error Receive Feed-through
            <br/>
            0 = Don't store bytes with detected parity errors
            <br/>
            1 = Feed-through bytes with detected parity errors
          </comment>
        </bits>
        <bits access="rw" name="filter_disable" pos="3" rst="0">
          <comment>
            Enable or disable NULL (0x60) character filtering when SIM card sends NULL to reset WWT timer.
            <br/>
            0 = Enable NULL character filtering, NULL characters are not reported if not data.
            <br/>
            1 = Disable NULL character filtering.  NULL characters (0x60) are transferred to the SCI data buffer.
          </comment>
        </bits>
        <bits access="rw" name="clockstop" pos="4" rst="1">
          <comment>
            Manual SCI Clock Stop control.  Manually starts and stops the SCI clock.  This bit must be set to '1' when Autostop mode is enabled.
            <br/>
            0 = Enable the SCI clock
            <br/>
            1 = Disable SCI clock
          </comment>
        </bits>
        <bits access="rw" name="autostop_en_h" pos="5" rst="0">
          <comment>
            Enables automatic clock shutdown when command is complete.  Enabling this will generate the necessary startup and shutdown delays required by the SIM protocol.
            <br/>
            0 = Auto clock control not enabled.  SCI clock controlled by SCI_Clockstop bit
            <br/>
            1 = Auto clock control enabled.
          </comment>
        </bits>
        <bits access="rw" name="msbh_lsbl" pos="6" rst="1">
          <comment>
            Sets the transmission and reception bit order:
            <br/>
            0 = LSB is sent/recieved first (Direct convention)
            <br/>
            1 = MSB is sent/received first (Inverse convention)
          </comment>
        </bits>
        <bits access="rw" name="lli" pos="7" rst="1">
          <comment>
            Logic Level Invert:
            <br/>
            0 = Logic level 0 data is sent/received as '0' or 'A' which is the same as the start bit.  (Direct convention)
            <br/>
            1 = Logic level 0 data is sent/received as '1' or 'Z' which is the opposite of the start bit.  (Inverse convention)
          </comment>
        </bits>
        <bits access="rw" name="pegen_len" pos="8" rst="0">
          <comment>
            Parity Error signal length.  This configuration bit can be used to extend the duration of the parity error signal generation from 1 ETU to 1.5 ETU
            <br/>
            0 = Parity Error signal duration is 1 ETU starting at 10.5 ETU
            <br/>
            1 = Parity Error signal duration is 1.5 ETU starting at 10.5 ETU
          </comment>
        </bits>
        <bits access="rw" name="parity_en" pos="9" rst="0">
          <comment>
            Enable or disable parity error checking on the receive data
            <br/>
            0 = Disable parity error checking
            <br/>
            1 = Enable parity error checking
          </comment>
        </bits>
        <bits access="rw" name="stop_level" pos="10" rst="1">
          <comment>
            Logical value of the clock signal when SCI clock is stopped (either due to automatic shutdown or manual shutdown)
            <br/>
            0 = Stop clock at low level
            <br/>
            1 = Stop clock at high level
          </comment>
        </bits>
        <bits access="rw" name="arg_h" pos="16" rst="0">
          <comment>Automatic Reset Generator.  Write a '1' to this bit to initiate an automatic reset procedure on the SIM.  Write '0' to switch back to SCI_Reset control (bit 20).  An ARG interrupt will be generated if the ARG process succeeded or failed.  The ARG status bit (ARG_Det) must be read to determine if a reset response from the card was detected.  This bit needs to be cleared between ARG attempts.</comment>
        </bits>
        <bits access="rw" name="afd_en_h" pos="17" rst="0">
          <comment>
            Automatic format detection.  This bit is generally set in conjunction with the ARG_H bit to enable automatic detection of the data convention.
            <br/>
            1 = Enable TS detection and automatic convention settings programming
            <br/>
            0 = disable automatic settings and use the register bits (MSBH_LSBL and LLI) to control the convention
          </comment>
        </bits>
        <bits access="rw" name="tx_resend_en_h" pos="18" rst="1">
          <comment>
            1 = Enable automatic resend of characters when Tx parity error is detected
            <br/>
            0 = Disable automatic resend
          </comment>
        </bits>
        <bits access="rw" name="reset" pos="20" rst="0">
          <comment>
            Direct connection to the SIM card reset pin.  This is overridden when ARG_H is enabled
            <br/>
            0 = SCI_Reset low voltage
            <br/>
            1 = SCI Reset high voltage
          </comment>
        </bits>
        <bits access="rw" name="dly_sel" pos="21" rst="0">
          <comment>
            This selects between two delay times for the automatic clock stop startup and shutdown:
            <br/>
            0 = short delay
            <br/>
            Startup/Shutdown : 744 SCI clocks / 1860 SCI clocks
            <br/>
            1 = long delay
            <br/>
            Startup/Shutdown : (2 x 744) SCI clocks / (2 x 1860) SCI clocks
          </comment>
        </bits>
        <bits access="rw" name="in_avg_en" pos="22" rst="1">
          <comment>
            Input data average enable.
            <br/>
            0 = Disable
            <br/>
            1 = Enable
          </comment>
        </bits>
        <bits access="rw" name="par_chk_offset" pos="29:24" rst="0xe">
          <comment>Allows fine control of the parity check position during the parity error time period.</comment>
        </bits>
      </reg>
      <reg name="status" protect="r">
        <bits access="r" name="rxdata_rdy" pos="0" rst="0">
          <comment>
            Returns the status of the Rx FIFO:
            <br/>
            0 = Rx FIFO empty
            <br/>
            1 = There is at least 1 character in the Rx FIFO
          </comment>
        </bits>
        <bits access="r" name="tx_fifo_rdy" pos="1" rst="1">
          <comment>
            Returns the status of the Tx FIFO:
            <br/>
            0 = Tx FIFO is full
            <br/>
            1 = There is at least 1 free spot in the Tx FIFO
          </comment>
        </bits>
        <bits access="r" name="format_det" pos="2" rst="0">
          <comment>
            Returns the status of the automatic format detection after reset:
            <br/>
            0 = TS character has not been detected in the ATR
            <br/>
            1 = TS character has been detected and SCI module is using the automatic convention settings
            <br/>
            <br/>
            This bit is cleared when the AFD_En bit is cleared
          </comment>
        </bits>
        <bits access="r" name="arg_det" pos="3" rst="0">
          <comment>
            Returns the status of the automatic reset procedure:
            <br/>
            0 = ARG detection has failed
            <br/>
            1 = ARG detection has detected that the SIM has responded to the reset
            <br/>
            <br/>
            This bit is used in conjunction with the ARG interrupt.  The ARG interrupt will be generated at the successful or unsuccessful termination of the ARG process.  This bit can be used to determine the success or failure.
          </comment>
        </bits>
        <bits access="r" name="reset_det" pos="4" rst="0">
          <comment>This is the status of the Reset pin when automatic reset generation is enabled.  This bit can be used to discover whether the SIM card that has successfully responded to an ARG procedure has an active high or active low reset. (Det means 'Detection')</comment>
        </bits>
        <bits access="r" name="clk_rdy_h" pos="5" rst="0">
          <comment>
            Status of the control signal to the clock control module.  This bit respects the startup and shutdown phases, so during these times, the clock may actually be on, but it is not considered to be 'ready'
            <br/>
            0 = SCI clock may be on or off but is not ready for use
            <br/>
            1 = SCI clock is on and ready for use
          </comment>
        </bits>
        <bits access="r" name="clk_off" pos="6" rst="1">
          <comment>
            Status bit of the Sci clock.
            <br/>
            0 = Sci clock is ON
            <br/>
            1 = Sci clock is OFF
          </comment>
        </bits>
        <bits access="r" name="rx_err" pos="8" rst="0">
          <comment>A receive parity error was detected. Reading this register clears the bit.</comment>
        </bits>
        <bits access="r" name="tx_err" pos="9" rst="0">
          <comment>A transmit parity error was detected. Reading this register clears the bit.</comment>
        </bits>
        <bits access="r" name="rxoverflow" pos="10" rst="0">
          <comment>The internal receive FIFO has reached an overflow condition. Reading this register clears the bit.</comment>
        </bits>
        <bits access="r" name="txoverflow" pos="11" rst="0">
          <comment>The internal transmit FIFO has reached an overflow condition. Reading this register clears the bit.</comment>
        </bits>
        <bits access="r" name="autostop_state" pos="31:30" rst="0">
          <comment>Returns the state of the clock management state machine when AutoStop mode is enabled.  This value is '00' when manual mode is selected.</comment>
          <options>
            <option name="Startup_phase" value="0">
              <comment>Clock is on, but not ready to be used.</comment>
            </option>
            <option name="Auto_on" value="1">
              <comment>Clock is on and ready to be used</comment>
            </option>
            <option name="Shutdown_phase" value="2">
              <comment>Clock is still on, but should not be used.</comment>
            </option>
            <option name="Clock_off" value="3">
              <comment>Clock is off.</comment>
            </option>
            <mask/>
            <shift/>
          </options>
        </bits>
      </reg>
      <reg name="data" protect="--">
        <bits access="w" name="data_in" pos="7:0" rst="FF">
          <comment>Writing to this register will send the data to the SIM card. If automatic clock shutdown is enabled, the appropriate delay will be applied before the data is actually sent.</comment>
        </bits>
        <bits access="r" name="data_out" pos="7:0" rst="FF">
          <comment>Reading this register will read from the receive data FIFO.</comment>
        </bits>
      </reg>
      <reg name="clkdiv_reg" protect="rw">
        <bits access="rw" name="clkdiv" pos="8:0" rst="0x174">
          <comment>Clock divider for generating the baud clock from the SCI clock.  This value must match the value used by the SIM card whose default value is 0x174.</comment>
        </bits>
        <bits access="rw" name="baud_x8_en" pos="9" rst="0">
          <comment>
            Speed mode enable.
            <br/>
            0 = Low speed mode
            <br/>
            1 = High speed mode(372/32, 372/64, 512/64)
          </comment>
        </bits>
        <bits access="rw" name="rx_clk_cnt_limit" pos="14:10" rst="0x10">
          <comment>Rx_clk_cnt wrap value.</comment>
        </bits>
        <bits access="rw" name="clk_tst" pos="15" rst="0">
          </bits>
        <bits access="rw" name="clkdiv_16" pos="23:16" rst="0x16">
          <comment>Secondary clock divider for generating 16x baud clock.</comment>
        </bits>
        <bits access="rw" name="maindiv" pos="29:24" rst="0x4">
          <comment>
            Main clock divider to generate the SCI clock.  This value should be calculated as follows:
            <br/>
            MainDiv = Clk_Sys/(2xSCI_Clk) - 1
            <br/>
            where SCI_Clk is in the range of 3-5 MHz as specified in the SIM specification.
          </comment>
          <options>
            <mask/>
            <default/>
          </options>
        </bits>
        <bits access="rw" name="clk_out_inv" pos="30" rst="0">
          <comment>
            Inverts the polarity of the SCI clock to the SIM card only.
            <br/>
            0 = No inversion
            <br/>
            1 = Invert external SCI clock
          </comment>
        </bits>
        <bits access="rw" name="clk_inv" pos="31" rst="0">
          <comment>
            Inverts the polarity of the SCI clock to the SIM card and internal.
            <br/>
            0 = No inversion
            <br/>
            1 = Invert external SCI clock
          </comment>
        </bits>
      </reg>
      <reg name="rxcnt_reg" protect="rw">
        <bits access="rw" name="rxcnt" pos="9:0" rst="0">
          <comment>
            This value should be programmed with the number of expected characters to receive.  It will be decremented each time a character is
            <strong>actually</strong>
             received and should be 0 when the transfer is complete.  If a character is sent after the RxCnt reaches zero, the extra character flag will be set but this value will stay at zero.
          </comment>
        </bits>
        <bits access="rw" name="clk_persist" pos="31" rst="0">
          <comment>
            When in automatic clock shutdown mode, this bit can prevent the clock from entering shutdown mode when the transfer is complete.  This should be used for multi-transfer commands where the clock must not be shut down until the command is complete.  This bit must be programmed for each transfer.
            <br/>
            1 = Keep clock on
            <br/>
            0 = Allow clock shutdown when transfer is complete
          </comment>
        </bits>
      </reg>
      <reg name="times" protect="rw">
        <bits access="rw" name="chguard" pos="7:0" rst="1">
          <comment>This is the extra guard time that can be added to the 2 ETU minimum (and default) guard time between successive transmitted characters.  This should be programmed depending on the SIM's ATR.  The total ETU guard time will be ChGuard + 1.</comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="turnaroundguard" pos="11:8" rst="0x6">
          <comment>
            Turnaround guard time configuration.  This value can be used to adjust the delay between the leading edge of a received character and the leading edge of the next transmitted character.  The minimum time specified in the SIM recommendation is 16 ETU.  The number of ETUs can be calculated using the following formula:
            <br/>
            Total Turnaround Time (in ETUs) = 11 + TurnaroundGuard
          </comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="wi" pos="23:16" rst="0x0A">
          <comment>
            Work Waiting Time factor.  A timeout will be generated when the WWT is exceeded.  The WWT is calculated by:
            <br/>
                   WWT = 960 x WI x (F/Fi)
            <br/>
            where Fi is the main SCI clock frequency (3-5 MHz) and F is 372 before an enhanced PPS and 512 after an enhanced PPS.
            <br/>
            The SCI_WI value must be calculated as follows:
            <br/>
                   SCI_WI = WI * D
            <br/>
            Thus, by default (WI = 10) this value needs to be set to 10 before an EPPS, but needs to be scaled to WI*D=80 after the EPPS procedure.
          </comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="rw" name="tx_pert" pos="31:24" rst="0xFF">
          <comment>Number of times to try resending character when the SIM indicates a parity error.</comment>
        </bits>
      </reg>
      <reg name="ch_filt_reg" protect="rw">
        <bits access="rw" name="ch_filt" pos="7:0" rst="0x60">
          <comment>
            Value of the character to be filtered.  0x60 is the NULL character in the SIM protocol.  If character filtering is enabled, the
            <strong>first</strong>
             0x60 character that is received by the SIM during a transfer will
            <strong>not</strong>
             be recorded.  The purpose of this character is to enable the SIM to reset the WWT counter when the SIM is not ready to send the data.  This filter has no effect on characters within the datastream.
          </comment>
        </bits>
      </reg>
      <reg name="dbg" protect="w">
        <bits access="w" name="fifo_rx_clr" pos="0" rst="0">
          <comment>Clear RX FIFO.</comment>
        </bits>
        <bits access="w" name="fifo_tx_clr" pos="1" rst="0">
          <comment>Clear TX FIFO.</comment>
        </bits>
        <comment>clear RX/TX FIFO</comment>
      </reg>
      <reg name="int_cause" protect="r">
        <bits access="r" name="rx_done" pos="0" rst="0">
          <comment>Number of expected Rx characters, as programmed in the RxCnt register, has been received.</comment>
        </bits>
        <bits access="r" name="rx_half" pos="1" rst="0">
          <comment>Receiver FIFO is half full.</comment>
        </bits>
        <bits access="r" name="wwt_timeout" pos="2" rst="0">
          <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.</comment>
        </bits>
        <bits access="r" name="extra_rx" pos="3" rst="0">
          <comment>An extra character has been received after the number of characters in RxCnt has been received.</comment>
        </bits>
        <bits access="r" name="resend_ovfl" pos="4" rst="0">
          <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the Tx_PERT field.</comment>
        </bits>
        <bits access="r" name="arg_end" pos="5" rst="0">
          <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.</comment>
        </bits>
        <bits access="r" name="sci_dma_tx_done" pos="6" rst="0">
          <comment>DMA tx done.</comment>
        </bits>
        <bits access="r" name="sci_dma_rx_done" pos="7" rst="0">
          <comment>DMA rx done.</comment>
        </bits>
        <comment>
          This register is a
          <b>READ ONLY</b>
           register that returns the logical
          <b>and</b>
           of the SCI_INT_STATUS register and the SCI_INT_MASK. If any of these bits is '1', the SCI module will generate an interrupt.  Bits 21:16 return the
          <u>status</u>
           of the interrupt which is the interrupt state before the mask is applied.  These bits should only be used for debugging.
        </comment>
      </reg>
      <reg name="int_clr" protect="rw">
        <bits access="c" name="rx_done" pos="0" rst="0">
          <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.</comment>
        </bits>
        <bits access="c" name="rx_half" pos="1" rst="0">
          <comment>Receiver FIFO is half full.</comment>
        </bits>
        <bits access="c" name="wwt_timeout" pos="2" rst="0">
          <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.</comment>
        </bits>
        <bits access="c" name="extra_rx" pos="3" rst="0">
          <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.</comment>
        </bits>
        <bits access="c" name="resend_ovfl" pos="4" rst="0">
          <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.</comment>
        </bits>
        <bits access="c" name="arg_end" pos="5" rst="0">
          <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.</comment>
        </bits>
        <bits access="c" name="sci_dma_tx_done" pos="6">
          <comment>DMA tx done.</comment>
        </bits>
        <bits access="c" name="sci_dma_rx_done" pos="7">
          <comment>DMA rx done.</comment>
        </bits>
        <comment>This is a WRITE ONLY register that is used to clear an SCI interrupt. Write a '1' to the interrupt that is to be cleared. Writing '0' has no effect.</comment>
      </reg>
      <reg name="int_mask" protect="rw">
        <bits access="rw" name="rx_done" pos="0" rst="0">
          <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.</comment>
        </bits>
        <bits access="rw" name="rx_half" pos="1" rst="0">
          <comment>Receiver FIFO is half full.</comment>
        </bits>
        <bits access="rw" name="wwt_timeout" pos="2" rst="0">
          <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.</comment>
        </bits>
        <bits access="rw" name="extra_rx" pos="3" rst="0">
          <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.</comment>
        </bits>
        <bits access="rw" name="resend_ovfl" pos="4" rst="0">
          <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.</comment>
        </bits>
        <bits access="rw" name="arg_end" pos="5" rst="0">
          <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.</comment>
        </bits>
        <bits access="rw" name="sci_dma_tx_done" pos="6" rst="0">
          <comment>DMA tx done.</comment>
        </bits>
        <bits access="rw" name="sci_dma_rx_done" pos="7" rst="0">
          <comment>DMA rx done.</comment>
        </bits>
        <comment>This register is READ/WRITE register that enables the desired interrupt. A '1' in a bit position indicates that the corresponding interrupt is enabled and if the interrupt occurs, the SCI will generate a hardware interrupt.</comment>
      </reg>
      <reg name="pa_clk_stop_en" protect="rw">
    </reg>
      <reg name="pa_status" protect="rw">
    </reg>
    </module>
    <instance address="0x14000000" name="SCI1" type="SCI"/>
    <instance address="0x14001000" name="SCI2" type="SCI"/>
  </archive>
  <archive relative="sdmmc.xml">
    <module category="Periph" name="SDMMC">
      <reg name="apbi_ctrl_sdmmc" protect="rw">
        <bits access="rw" name="l_endian" pos="2:0" rst="000">
          <comment>
            Controls the big endian or little endian of the FIFO data.
            <br/>
            Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
            <br/>
            &quot;000&quot;: the order is not changed.
            <br/>
            Byte3=&quot;0A&quot;,Byte2=&quot;0B&quot;,Byte1=&quot;0C&quot;,Byte0=&quot;0D&quot;.
            <br/>
            &quot;001&quot;: reversed on byte.
            <br/>
            Byte3=&quot;0D&quot;,Byte2=&quot;0C,Byte1=&quot;0B&quot;,Byte0=&quot;0A&quot;.
            <br/>
            &quot;010&quot;: reversed on half word.
            <br/>
            Byte3=&quot;0C&quot;,Byte2=&quot;0D,Byte1=&quot;0A&quot;,Byte0=&quot;0B&quot;.
            <br/>
            &quot;010&quot;: reversed on bit.
            <br/>
            Byte3=&quot;B0&quot;,Byte2=&quot;30,Byte1=&quot;D0&quot;,Byte0=&quot;50&quot;.
            <br/>
            &quot;100&quot;: reversed on bit.
            <br/>
            Byte3=&quot;0A&quot;,Byte2=&quot;0X,Byte1=&quot;0D&quot;,Byte0=&quot;0C&quot;.
          </comment>
        </bits>
        <bits access="rw" name="soft_rst_l" pos="3" rst="1">
          <comment>
            For the software to clear FIFO in case there is an error in communication with SD controller and some data are left behind.
            <br/>
            Active Low.
          </comment>
        </bits>
      </reg>
      <hole size="32"/>
      <reg name="apbi_fifo_txrx" protect="--">
        <bits access="r" name="data_out" pos="31:0" rst="0">
          <comment>Read in the receive FIFO</comment>
        </bits>
        <comment>Write to the transmit FIFO</comment>
      </reg>
      <hole size="16288"/>
      <reg name="sdmmc_config" protect="rw">
        <bits access="rw" name="sdmmc_sendcmd" pos="0" rst="0">
          <comment>
            SD/MMC operation begin register, active high.
            <br/>
		When '1', the controller finishes the last command and goes into suspend status. At suspend status, the controller will not execute the next command until the bit is set '0'.
          </comment>
        </bits>
        <bits access="rw" name="sdmmc_suspend" pos="1" rst="1">
          <comment>SD/MMC operation suspend register, active high.</comment>
        </bits>
        <bits access="rw" name="rsp_en" pos="4" rst="0">
          <comment>'1'indicates having a response,'0'indicates no response.</comment>
        </bits>
        <bits access="rw" name="rsp_sel" pos="6:5" rst="0">
          <options>
            <default/>
            <option name="R2" value="0b10"/>
            <option name="R3" value="0b01"/>
            <option name="OTHER" value="0b00"/>
          </options>
          <comment>Response select register,&quot;10&quot; means R2 response, &quot;01&quot; means R3 response, &quot;00&quot; means others response, &quot;11&quot; is reserved.</comment>
        </bits>
        <bits access="rw" name="rd_wt_en" pos="8" rst="0">
          <comment>'1' indicates data operation, which includes read and write.</comment>
        </bits>
        <bits access="rw" name="rd_wt_sel" pos="9" rst="0">
          <options>
            <default/>
            <option name="READ" value="0"/>
            <option name="WRITE" value="1"/>
          </options>
          <comment>'1' means write operation,'0' means read operation.</comment>
        </bits>
        <bits access="rw" name="s_m_sel" pos="10" rst="0">
          <options>
            <default/>
            <option name="SIMPLE" value="0"/>
            <option name="MULTIPLE" value="1"/>
          </options>
          <comment>'1'means multiple block data operation.</comment>
        </bits>
        <bits access="rw" name="bit_16" pos="16" rst="1">
	</bits>
      </reg>
      <reg name="sdmmc_status" protect="r">
        <bits access="r" name="not_sdmmc_over" pos="0" rst="0">
          <comment>'1' means the SD/MMC operation is not over.</comment>
        </bits>
        <bits access="r" name="busy" pos="1" rst="0">
          <comment>'1' means SD/MMC is busy.</comment>
        </bits>
        <bits access="r" name="dl_busy" pos="2" rst="0">
          <comment>'1' means the data line is busy.</comment>
        </bits>
        <bits access="r" name="suspend" pos="3" rst="1">
          <comment>'1' means the controller will not perform the new command when SDMMC_SENDCMD= '1'.</comment>
        </bits>
        <bits access="r" name="rsp_error" pos="8" rst="0">
          <comment>Response CRC checks error register '1' means response CRC check error.</comment>
        </bits>
        <bits access="r" name="no_rsp_error" pos="9" rst="0">
          <comment>'1' means the card has no response to command.</comment>
        </bits>
        <bits access="r" name="crc_status" pos="14:12" rst="0">
          <comment>
            CRC check for SD/MMC write operation
            <br/>
		&quot;101&quot; transmission error
            <br/>
		&quot;010&quot; transmission right
            <br/>
		&quot;111&quot; flash programming error
          </comment>
        </bits>
        <bits access="r" name="data_error" pos="23:16" rst="0">
          <comment>8 bits data CRC check, &quot;00000000&quot; means no data error, &quot;00000001&quot; means DATA0 CRC check error, &quot;10000000&quot; means DATA7 CRC check error, each bit match one data line.</comment>
        </bits>
        <bits access="r" name="dat3_val" pos="24" rst="-">
          <comment>SDMMC DATA 3 value.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_cmd_index" protect="rw">
        <bits access="rw" name="command" pos="5:0" rst="0">
          <comment>SD/MMC command register.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_cmd_arg" protect="rw">
        <comment>SD/MMC command argument register, write data to the SD/MMC card.</comment>
      </reg>
      <reg name="sdmmc_resp_index" protect="r">
        <bits access="r" name="response" pos="5:0" rst="0">
          <comment>SD/MMC response index register.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_resp_arg3" protect="r">
        <comment>Response argument of R1, R3 and R6, or 127 to 96 bit response argument of R2.</comment>
      </reg>
      <reg name="sdmmc_resp_arg2" protect="r">
        <comment>95 to 64 bit response argument of R2.</comment>
      </reg>
      <reg name="sdmmc_resp_arg1" protect="r">
        <comment>63 to 32 bit response argument of R2.</comment>
      </reg>
      <reg name="sdmmc_resp_arg0" protect="r">
        <comment>31 to 0 bit response argument of R2.</comment>
      </reg>
      <reg name="sdmmc_data_width_reg" protect="rw">
        <bits access="rw" name="sdmmc_data_width" pos="3:0" rst="0">
          <comment>
            SD/MMC data width:
            <br/>
		0x1: 1 data line
            <br/>
		0x2: 2 reserved
            <br/>
		0x4: 4 data lines
            <br/>
		0x8: 8 data lines
          </comment>
        </bits>
      </reg>
      <reg name="sdmmc_block_size_reg" protect="rw">
        <bits access="rw" name="sdmmc_block_size" pos="3:0" rst="0">
          <comment>
            SD/MMC size of one block:
            <br/>
		0-1:reserved
            <br/>
		2: 1 word
            <br/>
		3: 2 words
            <br/>
		4: 4 words
            <br/>
		5: 8 words
            <br/>
		6: 16 words
            <br/>
            <br/>
		11: 512 words
            <br/>
		12-15 reserved
          </comment>
        </bits>
      </reg>
      <reg name="sdmmc_block_cnt_reg" protect="rw">
        <bits access="rw" name="sdmmc_block_cnt" pos="15:0" rst="0">
          <comment>Block number that wants to transfer.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_int_status" protect="r">
        <bits access="r" name="no_rsp_int" pos="0" rst="0">
          <comment>'1' means no response.</comment>
        </bits>
        <bits access="r" name="rsp_err_int" pos="1" rst="0">
          <comment>'1' means CRC error of response.</comment>
        </bits>
        <bits access="r" name="rd_err_int" pos="2" rst="0">
          <comment>'1' means CRC error of reading data.</comment>
        </bits>
        <bits access="r" name="wr_err_int" pos="3" rst="0">
          <comment>'1' means CRC error of writing data.</comment>
        </bits>
        <bits access="r" name="dat_over_int" pos="4" rst="0">
          <comment>'1' means data transmission is over.</comment>
        </bits>
        <bits access="r" name="txdma_done_int" pos="5" rst="0">
          <comment>'1' means tx dma done.</comment>
        </bits>
        <bits access="r" name="rxdma_done_int" pos="6" rst="0">
          <comment>'1' means rx dma done.</comment>
        </bits>
        <bits access="r" name="no_rsp_sc" pos="8" rst="0">
          <comment>'1' means no response is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="rsp_err_sc" pos="9" rst="0">
          <comment>'1' means CRC error of response is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="rd_err_sc" pos="10" rst="0">
          <comment>'1' means CRC error of reading data is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="wr_err_sc" pos="11" rst="0">
          <comment>'1' means CRC error of writing data is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="dat_over_sc" pos="12" rst="0">
          <comment>'1' means the end of data transmission is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="txdma_done_sc" pos="13" rst="0">
          <comment>'1' means tx dma done is the source of interrupt.</comment>
        </bits>
        <bits access="r" name="rxdma_done_sc" pos="14" rst="0">
          <comment>'1' means rx dma done is the source of interrupt.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_int_mask" protect="rw">
        <bits access="rw" name="no_rsp_mk" pos="0" rst="0">
          <comment>When no response, '1' means INT is disable.</comment>
        </bits>
        <bits access="rw" name="rsp_err_mk" pos="1" rst="0">
          <comment>When CRC error of response, '1' means INT is disable.</comment>
        </bits>
        <bits access="rw" name="rd_err_mk" pos="2" rst="0">
          <comment>When CRC error of reading data, '1' means INT is disable.</comment>
        </bits>
        <bits access="rw" name="wr_err_mk" pos="3" rst="0">
          <comment>When CRC error of writing data, '1' means INT is disable.</comment>
        </bits>
        <bits access="rw" name="dat_over_mk" pos="4" rst="0">
          <comment>When data transmission is over, '1' means INT is disable.</comment>
        </bits>
        <bits access="rw" name="txdma_done_mk" pos="5" rst="0">
          <comment>when tx dma done, '1' means INT is disabled.</comment>
        </bits>
        <bits access="rw" name="rxdma_done_mk" pos="6" rst="0">
          <comment>'1' means rx dma done, '1' means INT is disabled.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_int_clear" protect="w">
        <bits access="w" name="no_rsp_cl" pos="0" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in NO_RSP_SC.</comment>
        </bits>
        <bits access="w" name="rsp_err_cl" pos="1" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in RSP_ERR_SC.</comment>
        </bits>
        <bits access="w" name="rd_err_cl" pos="2" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in RD_ERR_SC.</comment>
        </bits>
        <bits access="w" name="wr_err_cl" pos="3" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in WR_ERR_SC.</comment>
        </bits>
        <bits access="w" name="dat_over_cl" pos="4" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in DAT_OVER_SC.</comment>
        </bits>
        <bits access="w" name="txdma_done_cl" pos="5" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in TXDMA_DONE_SC.</comment>
        </bits>
        <bits access="w" name="rxdma_done_cl" pos="6" rst="0">
          <comment>Write a '1' to this bit to clear the source of interrupt in RXDMA_DONE_SC.</comment>
        </bits>
      </reg>
      <reg name="sdmmc_trans_speed_reg" protect="rw">
        <bits access="rw" name="sdmmc_trans_speed" pos="9:0" rst="0">
          <comment>Mclk = Pclk/(2*(SDMMC_TRANS_SPEED +1)).</comment>
        </bits>
      </reg>
      <reg name="sdmmc_mclk_adjust_reg" protect="rw">
        <bits access="rw" name="sdmmc_mclk_adjust" pos="3:0" rst="0">
          <comment>This register may delay the mclk output.
			 When MCLK_ADJUSTER = n, Mclk is outputted with  n Pclk.</comment>
        </bits>
        <bits access="rw" name="clk_inv" pos="4" rst="0">
          <comment>Invert Mclk.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x04403000" name="SDMMC" type="SDMMC"/>
  </archive>
  <archive relative="spi_flash.xml">
    <module category="System" name="SPI_FLASH">
      <reg name="spi_cmd_addr" protect="rw">
        <bits access="rw" name="spi_tx_cmd" pos="7:0" rst="all0">
          <comment>spi flash command to send.</comment>
        </bits>
        <bits access="rw" name="spi_address" pos="31:8" rst="all0">
          <comment>spi flash address to send.</comment>
        </bits>
      </reg>
      <reg name="spi_block_size" protect="rw">
        <bits access="rw" name="spi_modebit" pos="7:0" rst="all0">
          <comment>spi flash modebit,set 0xA0 to enable continuous read.</comment>
        </bits>
        <bits access="rw" name="spi_rw_blk_size" pos="21:8" rst="0x1">
          <comment>spi flash spi read/write block size.</comment>
        </bits>
        <bits access="rw" name="continuous_enable" pos="24" rst="0x0">
        </bits>
      </reg>
      <reg name="spi_data_fifo" protect="rw">
        <bits access="w" name="spi_tx_data" pos="7:0" rst="no">
          <comment>spi flash data to send.</comment>
        </bits>
        <bits access="w" name="spi_send_type" pos="8" rst="no">
          <comment>spi send byte, 1: quad send 0: spi send.</comment>
        </bits>
      </reg>
      <reg name="spi_status" protect="r">
        <bits access="r" name="spi_flash_busy" pos="0" rst="0x0">
          <comment>spi flash busy.</comment>
        </bits>
        <bits access="r" name="tx_fifo_empty" pos="1" rst="0x1">
          <comment>tx fifo empty.</comment>
        </bits>
        <bits access="r" name="tx_fifo_full" pos="2" rst="0x0">
          <comment>tx fifo full.</comment>
        </bits>
        <bits access="r" name="rx_fifo_empty" pos="3" rst="0x1">
          <comment>rx fifo empty.</comment>
        </bits>
        <bits access="r" name="rx_fifo_count" pos="8:4" rst="all0">
          <comment>rx fifo data count.</comment>
        </bits>
        <bits access="r" name="read_stat_busy" pos="9" rst="0x0">
          <comment>read busy.</comment>
        </bits>
        <bits access="r" name="nand_int" pos="10" rst="0x0">
          <comment>nand int .</comment>
        </bits>
        <bits access="r" name="spiflash_int" pos="11" rst="0x0">
          <comment>spiflash_int = nand_int and nand_int_mask .</comment>
        </bits>
      </reg>
      <reg name="spi_read_back" protect="r">
        <comment>flash rx status.</comment>
      </reg>
      <reg name="spi_config" protect="rw">
        <bits access="rw" name="quad_mode" pos="0" rst="0x0">
          <comment>spi flash read mode from AHB.</comment>
          <options>
            <option name="spi read" value="0"/>
            <option name="quad read" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="spi_wprotect_pin" pos="1" rst="0x0">
          <comment>spi flash wprotect pin.</comment>
        </bits>
        <bits access="rw" name="spi_hold_pin" pos="2" rst="0x0">
          <comment>spi flash hold pin.</comment>
        </bits>
        <bits access="rw" name="sample_delay" pos="6:4" rst="0x2">
          <comment>spi flash read sample delay cycles.</comment>
        </bits>
        <bits access="rw" name="clk_divider" pos="15:8" rst="0x8">
          <comment>spi flash clock divider.</comment>
        </bits>
        <bits access="rw" name="cmd_quad" pos="16" rst="0x0">
          <comment>spi flash send command using quad lines.</comment>
        </bits>
        <bits access="rw" name="tx_rx_size" pos="18:17" rst="0x0">
        </bits>
      </reg>
      <reg name="spi_fifo_control" protect="w">
        <bits access="w" name="rx_fifo_clr" pos="0" rst="0x0">
          <comment>rx fifo_clr,self clear.</comment>
        </bits>
        <bits access="w" name="tx_fifo_clr" pos="1" rst="0x0">
          <comment>tx fifo_clr,self clear.</comment>
        </bits>
      </reg>
      <reg name="spi_cs_size" protect="rw">
        <bits access="rw" name="spi_cs_num" pos="0" rst="0x0">
          <comment>spi flash cs num.</comment>
          <options>
            <option name="1 spiflash" value="0"/>
            <option name="2 spiflash" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="spi size" pos="2:1" rst="all0">
          <comment>single chip spi flash size.</comment>
          <options>
            <option name="32m" value="0"/>
            <option name="64m" value="1"/>
            <option name="16m" value="2"/>
            <option name="8m" value="3"/>
          </options>
        </bits>
        <bits access="rw" name="spi_128m" pos="3" rst="0x0">
          <comment>spi flash is 128m flash.</comment>
          <options>
            <option name="other spiflash" value="0"/>
            <option name="128m  spiflash" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="ahb_read_disable" pos="4" rst="0x0">
          <comment>disable read from ahb.</comment>
          <options>
            <option name="enable ahb read" value="0"/>
            <option name="disable ahb read" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="sel_flash_1" pos="5" rst="0x0">
          <comment>sel flash 1, addr[24].</comment>
          <options>
            <option name="sel flash 0" value="0"/>
            <option name="sel flash 1" value="1"/>
          </options>
        </bits>
        <bits access="rw" name="sel1_flash_1" pos="6" rst="0x0">
          <comment>addr[25].</comment>
        </bits>
        <bits access="rw" name="diff_128m_diff_cmd_en" pos="7" rst="0x0">
          <comment>diff 128m diff cmd en.</comment>
        </bits>
        <bits access="rw" name="spi_256m" pos="8" rst="0x0">
          <comment>spi_256m.</comment>
        </bits>
        <bits access="rw" name="spi_512m" pos="9" rst="0x0">
          <comment>spi_512m.</comment>
        </bits>
        <bits access="rw" name="spi_cs1_sel2" pos="10" rst="0x0">
          <comment>spi_cs1_sel2.</comment>
        </bits>
        <bits access="rw" name="spi_1g" pos="11" rst="0x0">
          <comment>spi_1g .</comment>
        </bits>
        <bits access="rw" name="spi_2g" pos="12" rst="0x0">
          <comment>spi_2g.</comment>
        </bits>
        <bits access="rw" name="spi_4g" pos="13" rst="0x0">
          <comment>spi_4g.</comment>
        </bits>
        <bits access="rw" name="spi_cs1_sel3" pos="14" rst="0x0">
          <comment>spi_cs1_sel3.</comment>
        </bits>
        <bits access="rw" name="spi_cs1_sel4" pos="15" rst="0x0">
          <comment>spi_cs1_sel4.</comment>
        </bits>
        <bits access="rw" name="spi_cs1_sel5" pos="16" rst="0x0">
          <comment>spi_cs1_sel5.</comment>
        </bits>
      </reg>
      <reg name="spi_read_cmd" protect="rw">
        <bits access="rw" name="qread_cmd" pos="7:0" rst="0xeb">
          <comment>quad read command.</comment>
        </bits>
        <bits access="rw" name="fread_cmd" pos="15:8" rst="0x0b">
          <comment>fast read command.</comment>
        </bits>
        <bits access="rw" name="read_cmd" pos="23:16" rst="0x03">
          <comment>fast read command.</comment>
        </bits>
        <bits access="w" name="protect_byte" pos="31:24" rst="all0">
          <comment>protect_byte, must be 0x55 when program this register.</comment>
        </bits>
      </reg>
      <reg name="spi_nand_config" protect="rw">
        <bits access="rw" name="nand_sel" pos="0" rst="all0">
		</bits>
        <bits access="rw" name="nand_addr" pos="2:1" rst="all0">
        </bits>
        <bits access="rw" name="reuse_nand_ram" pos="3" rst="all0">
        </bits>
        <bits access="rw" name="reuse_read" pos="4" rst="all0">
        </bits>
        <bits access="rw" name="write_page_hit" pos="5" rst="all0">
        </bits>
        <bits access="rw" name="nand_data_trans" pos="6" rst="all0">
        </bits>
        <bits access="rw" name="page_size_sel" pos="7" rst="all0">
		</bits>
        <bits access="rw" name="page_read_cmd" pos="15:8" rst="0x13">
        </bits>
        <bits access="rw" name="get_sts_cmd" pos="23:16" rst="0x0f">
        </bits>
        <bits access="rw" name="ram_read_cmd" pos="31:24" rst="0x03">
        </bits>
      </reg>
      <reg name="spi_nand_config2" protect="rw">
        <bits access="rw" name="get_sts_addr" pos="7:0" rst="0xc0">
        </bits>
        <bits access="rw" name="sts_qip" pos="23:16" rst="0x01">
        </bits>
      </reg>
      <reg name="spi_256_512_flash_config" protect="rw">
        <bits access="rw" name="four_byte_addr" pos="0" rst="all0">
		</bits>
        <bits access="rw" name="dummy_cycle_en" pos="1" rst="all0">
		</bits>
        <bits access="rw" name="dummy_cycle" pos="11:8" rst="0x08">
        </bits>
        <bits access="rw" name="wrap_en" pos="12" rst="all0">
        </bits>
        <bits access="rw" name="wrap_code" pos="19:16" rst="all0">
        </bits>
      </reg>
      <reg name="spi_128_flash_config" protect="rw">
        <bits access="rw" name="first_128m_cmd" pos="7:0" rst="0x8c">
		</bits>
        <bits access="rw" name="second_128m_cmd" pos="15:8" rst="0x8d">
        </bits>
        <bits access="rw" name="third_128m_cmd" pos="23:16" rst="0x0">
        </bits>
        <bits access="rw" name="fourth_128m_cmd" pos="31:24" rst="0x0">
        </bits>
      </reg>
      <reg name="spi_cs4_sel" protect="rw">
        <bits access="rw" name="spi_cs4_sel" pos="2:0" rst="0x0">
		</bits>
      </reg>
      <reg name="page0_addr" protect="rw">
        <bits access="rw" name="page0_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page0_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page1_addr" protect="rw">
        <bits access="rw" name="page1_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page1_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page2_addr" protect="rw">
        <bits access="rw" name="page2_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page2_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page3_addr" protect="rw">
        <bits access="rw" name="page3_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page3_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page4_addr" protect="rw">
        <bits access="rw" name="page4_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page4_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page5_addr" protect="rw">
        <bits access="rw" name="page5_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page5_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page6_addr" protect="rw">
        <bits access="rw" name="page6_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page6_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page7_addr" protect="rw">
        <bits access="rw" name="page7_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page7_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page8_addr" protect="rw">
        <bits access="rw" name="page8_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page8_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page9_addr" protect="rw">
        <bits access="rw" name="page9_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page9_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page10_addr" protect="rw">
        <bits access="rw" name="page10_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page10_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page11_addr" protect="rw">
        <bits access="rw" name="page11_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page11_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page12_addr" protect="rw">
        <bits access="rw" name="page12_addr" pos="23:0" rst="0x0">
        </bits>
        <bits access="rw" name="page12_valid" pos="31" rst="0x0">
		</bits>
      </reg>
      <reg name="page13_addr" protect="rw">
        <bits access="rw" name="page13_addr" pos="23:0" rst="0x0">
         </bits>
        <bits access="rw" name="page13_valid" pos="31" rst="0x0">
	 	</bits>
      </reg>
      <reg name="page14_addr" protect="rw">
        <bits access="rw" name="page14_addr" pos="23:0" rst="0x0">
         </bits>
        <bits access="rw" name="page14_valid" pos="31" rst="0x0">
	 	</bits>
      </reg>
      <reg name="page15_addr" protect="rw">
        <bits access="rw" name="page15_addr" pos="23:0" rst="0x0">
         </bits>
        <bits access="rw" name="page15_valid" pos="31" rst="0x0">
	 	</bits>
      </reg>
      <reg name="spi_page_config" protect="rw">
        <bits access="rw" name="multi_page_enable/multi_page_start" pos="0" rst="0x0">
         </bits>
        <bits access="rw" name="page_num" pos="12:8" rst="0x0">
	 	</bits>
      </reg>
      <reg name="spi_cmd_reconfig" protect="rw">
        <bits access="rw" name="program_exe_cmd" pos="7:0" rst="0x0">
         </bits>
        <bits access="rw" name="program_load_cmd" pos="15:8" rst="0x0">
         </bits>
        <bits access="rw" name="write_enable_cmd" pos="23:16" rst="0x0">
         </bits>
      </reg>
      <reg name="page0_col_addr" protect="rw">
        <bits access="rw" name="page0_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page1_col_addr" protect="rw">
        <bits access="rw" name="page1_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page2_col_addr" protect="rw">
        <bits access="rw" name="page2_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page3_col_addr" protect="rw">
        <bits access="rw" name="page3_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page4_col_addr" protect="rw">
        <bits access="rw" name="page4_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page5_col_addr" protect="rw">
        <bits access="rw" name="page5_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page6_col_addr" protect="rw">
        <bits access="rw" name="page6_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page7_col_addr" protect="rw">
        <bits access="rw" name="page7_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page8_col_addr" protect="rw">
        <bits access="rw" name="page8_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page9_col_addr" protect="rw">
        <bits access="rw" name="page9_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page10_col_addr" protect="rw">
        <bits access="rw" name="page10_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page11_col_addr" protect="rw">
        <bits access="rw" name="page11_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page12_col_addr" protect="rw">
        <bits access="rw" name="page12_col_addr" pos="15:0" rst="0x0">
        </bits>
      </reg>
      <reg name="page13_col_addr" protect="rw">
        <bits access="rw" name="page13_col_addr" pos="15:0" rst="0x0">
         </bits>
      </reg>
      <reg name="page14_col_addr" protect="rw">
        <bits access="rw" name="page14_col_addr" pos="15:0" rst="0x0">
         </bits>
      </reg>
      <reg name="page15_col_addr" protect="rw">
        <bits access="rw" name="page15_col_addr" pos="15:0" rst="0x0">
         </bits>
      </reg>
      <reg name="nand_int_mask" protect="rw">
        <bits access="rw" name="nand_int_mask" pos="0" rst="0x0">
		</bits>
      </reg>
    </module>
    <instance address="0x02000000" name="SPI_FLASH" type="SPI_FLASH"/>
    <instance address="0x02040000" name="SPI_FLASH_EXT" type="SPI_FLASH"/>
  </archive>
  <archive relative="timer_ap.xml">
    <module category="System" name="TIMER_AP">
      <reg name="ostimer_loadval_l" protect="rw">
        <comment>Value low 32bits loaded to OS timer.</comment>
      </reg>
      <reg name="ostimer_ctrl" protect="rw">
        <bits access="rw" name="loadval_h" pos="23:0" rst="0">
          <comment>Value high 24bits loaded to OS timer.</comment>
        </bits>
        <bits access="rw" name="enable" pos="24" rst="0">
          <comment>
            Write '1' to this bit will enable OS timer.
            <br/>
            When read, the value is what we have written to this bit, it changes immediately  after been written.
          </comment>
        </bits>
        <bits access="r" name="enabled" pos="25" rst="0">
          <comment>
            Read this bit will get the information if OS timer is really enabled or not. This bit will change only after the next front of 16 KHz system clock.
            <br/>
            <br/>
            '1' indicates OS timer enabled.
            <br/>
            '0' indicates OS timer not enabled.
          </comment>
        </bits>
        <bits access="r" name="cleared" pos="26" rst="0">
          <comment>
            Read this bit will get the information if OS timer interruption clear operation is finished or not.
            <br/>
            <br/>
            '1' indicates OS timer interruption clear operation is on going.
            <br/>
            '0' indicates no OS timer interruption clear operation is on going.
          </comment>
        </bits>
        <bits access="rw" name="repeat" pos="28" rst="0">
          <comment>
            Write '1' to this bit will set OS timer to repeat mode.
            <br/>
            When read, get the information if OS timer is in repeat mode.
            <br/>
            <br/>
            '1' indicates OS timer in repeat mode.
            <br/>
            '0' indicates OS timer not in repeat mode.
          </comment>
        </bits>
        <bits access="rw" name="wrap" pos="29" rst="0">
          <comment>
            Write '1' to this bit will set OS timer to wrap mode.
            <br/>
            When read, get the information if OS timer is in wrap mode.
            <br/>
            <br/>
            '1' indicates OS timer in wrap mode.
            <br/>
            '0' indicates OS timer not in wrap mode.
          </comment>
        </bits>
        <bits access="rw" name="load" pos="30" rst="0">
          <comment>Write '1' to this bit will load the initial value to OS timer.</comment>
        </bits>
      </reg>
      <reg name="ostimer_curval_l" protect="rw">
        <comment>Current value low 32bits of OS timer.</comment>
      </reg>
      <reg name="ostimer_curval_h" protect="rw">
        <comment>Current value high bits of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.</comment>
      </reg>
      <reg name="ostimer_lockval_l" protect="rw">
        <comment>Current locked value low 32bits of OS timer.</comment>
      </reg>
      <reg name="ostimer_lockval_h" protect="rw">
        <comment>Current locked value high bits of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.</comment>
      </reg>
      <reg name="hwtimer_ctrl" protect="rw">
        <bits access="rw" name="interval_en" pos="8" rst="0">
          <comment>
            This bit enables interval IRQ mode.
            <br/>
            <br/>
            '0': hw delay timer does not generate interval IRQ.
            <br/>
            '1': hw delay timer generate an IRQ each interval.
          </comment>
        </bits>
        <bits access="rw" name="interval" pos="1:0" rst="00">
          <comment>
            interval of generating an HwTimer IRQ.
            <br/>
            <br/>
            &quot;00&quot;: interval of 1/8 second.
            <br/>
            &quot;01&quot;: interval of 1/4 second.
            <br/>
            &quot;10&quot;: interval of 1/2 second.
            <br/>
            &quot;11&quot;: interval of 1 second.
          </comment>
        </bits>
      </reg>
      <reg name="hwtimer_curval_l" protect="rw">
        <comment>Current low 32bits value of the hardware delay timer.</comment>
      </reg>
      <reg name="hwtimer_curval_h" protect="rw">
        <comment>Current high 32bits value of the hardware delay timer.</comment>
      </reg>
      <reg name="hwtimer_lockval_l" protect="rw">
        <comment>Current locked low 32bits value of the hardware delay timer.</comment>
      </reg>
      <reg name="hwtimer_lockval_h" protect="rw">
        <comment>Current locked high 32bits value of the hardware delay timer.</comment>
      </reg>
      <reg name="timer_irq_mask_set" protect="rw">
        <bits access="rs" name="ostimer_mask" pos="0" rst="0">
          <comment>Set mask for OS timer IRQ.</comment>
        </bits>
        <bits access="rs" name="hwtimer_wrap_mask" pos="1" rst="0">
          <comment>Set mask for hardwre delay timer wrap IRQ.</comment>
        </bits>
        <bits access="rs" name="hwtimer_itv_mask" pos="2" rst="0">
          <comment>Set mask for hardwre delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_mask_clr" protect="rw">
        <bits access="rc" name="ostimer_mask" pos="0" rst="0">
          <comment>Clear mask for OS timer IRQ.</comment>
        </bits>
        <bits access="rc" name="hwtimer_wrap_mask" pos="1" rst="0">
          <comment>Clear mask for hardwre delay timer wrap IRQ.</comment>
        </bits>
        <bits access="rc" name="hwtimer_itv_mask" pos="2" rst="0">
          <comment>Clear mask for hardwre delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_clr" protect="rw">
        <bits access="c" name="ostimer_clr" pos="0" rst="0">
          <comment>Clear OS timer IRQ.</comment>
        </bits>
        <bits access="c" name="hwtimer_wrap_clr" pos="1" rst="0">
          <comment>Clear hardware delay timer wrap IRQ.</comment>
        </bits>
        <bits access="c" name="hwtimer_itv_clr" pos="2" rst="0">
          <comment>Clear hardware delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_cause" protect="rw">
        <bits access="r" name="ostimer_cause" pos="0" rst="0">
          <comment>OS timer IRQ cause.</comment>
        </bits>
        <bits access="r" name="hwtimer_wrap_cause" pos="1" rst="0">
          <comment>hardware delay timer wrap IRQ cause.</comment>
        </bits>
        <bits access="r" name="hwtimer_itv_cause" pos="2" rst="0">
          <comment>hardware delay timer interval IRQ cause.</comment>
        </bits>
        <bits access="r" name="ostimer_status" pos="16" rst="0">
          <comment>OS timer IRQ status.</comment>
        </bits>
        <bits access="r" name="hwtimer_wrap_status" pos="17" rst="0">
          <comment>hardware delay timer wrap IRQ status.</comment>
        </bits>
        <bits access="r" name="hwtimer_itv_status" pos="18" rst="0">
          <comment>hardware delay timer interval IRQ status.</comment>
        </bits>
        <bitgroup name="other_tims_irq">
          <entry ref="hwtimer_wrap_cause"/>
          <entry ref="hwtimer_itv_cause"/>
        </bitgroup>
      </reg>
    </module>
    <instance address="0x04806000" name="TIMER2" type="TIMER_AP"/>
    <instance address="0x14007000" name="TIMER4" type="TIMER_AP"/>
    <instance address="0x04806800" name="TIMER5" type="TIMER_AP"/>
  </archive>
  <archive relative="timer.xml">
    <module category="System" name="TIMER">
      <var name="NB_INTERVAL" value="1"/>
      <var name="INT_TIMER_NB_BITS" value="24"/>
      <var name="WD_TIMER_NB_BITS" value="24"/>
      <var name="HW_TIMER_NB_BITS" value="32"/>
      <var name="TIM_MAXVAL" value="0xffffff"/>
      <reg name="ostimer_ctrl" protect="rw">
        <bits access="rw" name="loadval" pos="23:0" rst="0">
          <comment>Value loaded to OS timer.</comment>
        </bits>
        <bits access="rw" name="enable" pos="24" rst="0">
          <comment>
            Write '1' to this bit will enable OS timer.
            <br/>
            When read, the value is what we have written to this bit, it changes immediately  after been written.
          </comment>
        </bits>
        <bits access="r" name="enabled" pos="25" rst="0">
          <comment>
            Read this bit will get the information if OS timer is really enabled or not. This bit will change only after the next front of 16 KHz system clock.
            <br/>
            <br/>
            '1' indicates OS timer enabled.
            <br/>
            '0' indicates OS timer not enabled.
          </comment>
        </bits>
        <bits access="r" name="cleared" pos="26" rst="0">
          <comment>
            Read this bit will get the information if OS timer interruption clear operation is finished or not.
            <br/>
            <br/>
            '1' indicates OS timer interruption clear operation is on going.
            <br/>
            '0' indicates no OS timer interruption clear operation is on going.
          </comment>
        </bits>
        <bits access="rw" name="repeat" pos="28" rst="0">
          <comment>
            Write '1' to this bit will set OS timer to repeat mode.
            <br/>
            When read, get the information if OS timer is in repeat mode.
            <br/>
            <br/>
            '1' indicates OS timer in repeat mode.
            <br/>
            '0' indicates OS timer not in repeat mode.
          </comment>
        </bits>
        <bits access="rw" name="wrap" pos="29" rst="0">
          <comment>
            Write '1' to this bit will set OS timer to wrap mode.
            <br/>
            When read, get the information if OS timer is in wrap mode.
            <br/>
            <br/>
            '1' indicates OS timer in wrap mode.
            <br/>
            '0' indicates OS timer not in wrap mode.
          </comment>
        </bits>
        <bits access="rw" name="load" pos="30" rst="0">
          <comment>Write '1' to this bit will load the initial value to OS timer.</comment>
        </bits>
      </reg>
      <reg name="ostimer_curval" protect="rw">
        <comment>Current value of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.</comment>
      </reg>
      <reg name="wdtimer_ctrl" protect="rw">
        <bits access="s" name="start" pos="0" rst="0">
          <comment>Write '1' to this bit will enable watchdog timer and Load it with WDTimer_LoadVal.</comment>
        </bits>
        <bits access="c" name="stop" pos="4" rst="0">
          <comment>Write '1' to this bit will stop watchdog timer.</comment>
        </bits>
        <bits access="w" name="reload" pos="16" rst="0">
          <comment>
            Write '1' to this bit will load WDTimer_LoadVal value to watchdog timer.
            <br/>
            Use this bit to implement the watchog keep alive.
          </comment>
        </bits>
        <bits access="r" name="wdenabled" pos="8" rst="0">
          <comment>
            Read this bit will get the information if watchdog timer is really enabled or not. This bit will change only after the next front of 32 KHz system clock.
            <br/>
            <br/>
            '1' indicates watchdog timer is enabled, if current watchdog timer value reaches 0, the system will be reseted.
            <br/>
            '0' indicates watchdog timer is not enabled.
          </comment>
        </bits>
      </reg>
      <reg name="wdtimer_loadval" protect="rw">
        <bits access="rw" name="wdloadval" pos="WD_TIMER_NB_BITS-1:0" rst="-">
          <comment>
            Load value of watchdog timer. Number of 32kHz Clock before Reset.
            <br/>
          </comment>
        </bits>
      </reg>
      <reg name="hwtimer_ctrl" protect="rw">
        <bits access="rw" name="interval_en" pos="8" rst="0">
          <comment>
            This bit enables interval IRQ mode.
            <br/>
            <br/>
            '0': hw delay timer does not generate interval IRQ.
            <br/>
            '1': hw delay timer generate an IRQ each interval.
          </comment>
        </bits>
        <bits access="rw" name="interval" pos="1:0" rst="00">
          <comment>
            interval of generating an HwTimer IRQ.
            <br/>
            <br/>
            &quot;00&quot;: interval of 1/8 second.
            <br/>
            &quot;01&quot;: interval of 1/4 second.
            <br/>
            &quot;10&quot;: interval of 1/2 second.
            <br/>
            &quot;11&quot;: interval of 1 second.
          </comment>
        </bits>
      </reg>
      <reg name="hwtimer_curval" protect="rw">
        <comment>Current value of the hardware delay timer. The value is incremented every 61 us. This timer is running all the time and wrap at value 0xFFFFFFFF.</comment>
      </reg>
      <reg name="timer_irq_mask_set" protect="rw">
        <bits access="rs" name="ostimer_mask" pos="0" rst="0">
          <comment>Set mask for OS timer IRQ.</comment>
        </bits>
        <bits access="rs" name="hwtimer_wrap_mask" pos="1" rst="0">
          <comment>Set mask for hardwre delay timer wrap IRQ.</comment>
        </bits>
        <bits access="rs" name="hwtimer_itv_mask" pos="2" rst="0">
          <comment>Set mask for hardwre delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_mask_clr" protect="rw">
        <bits access="rc" name="ostimer_mask" pos="0" rst="0">
          <comment>Clear mask for OS timer IRQ.</comment>
        </bits>
        <bits access="rc" name="hwtimer_wrap_mask" pos="1" rst="0">
          <comment>Clear mask for hardwre delay timer wrap IRQ.</comment>
        </bits>
        <bits access="rc" name="hwtimer_itv_mask" pos="2" rst="0">
          <comment>Clear mask for hardwre delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_clr" protect="rw">
        <bits access="c" name="ostimer_clr" pos="0" rst="0">
          <comment>Clear OS timer IRQ.</comment>
        </bits>
        <bits access="c" name="hwtimer_wrap_clr" pos="1" rst="0">
          <comment>Clear hardware delay timer wrap IRQ.</comment>
        </bits>
        <bits access="c" name="hwtimer_itv_clr" pos="2" rst="0">
          <comment>Clear hardware delay timer interval IRQ.</comment>
        </bits>
      </reg>
      <reg name="timer_irq_cause" protect="rw">
        <bits access="r" name="ostimer_cause" pos="0" rst="0">
          <comment>OS timer IRQ cause.</comment>
        </bits>
        <bits access="r" name="hwtimer_wrap_cause" pos="1" rst="0">
          <comment>hardware delay timer wrap IRQ cause.</comment>
        </bits>
        <bits access="r" name="hwtimer_itv_cause" pos="2" rst="0">
          <comment>hardware delay timer interval IRQ cause.</comment>
        </bits>
        <bits access="r" name="ostimer_status" pos="16" rst="0">
          <comment>OS timer IRQ status.</comment>
        </bits>
        <bits access="r" name="hwtimer_wrap_status" pos="17" rst="0">
          <comment>hardware delay timer wrap IRQ status.</comment>
        </bits>
        <bits access="r" name="hwtimer_itv_status" pos="18" rst="0">
          <comment>hardware delay timer interval IRQ status.</comment>
        </bits>
        <bitgroup name="other_tims_irq">
          <entry ref="hwtimer_wrap_cause"/>
          <entry ref="hwtimer_itv_cause"/>
        </bitgroup>
      </reg>
    </module>
    <instance address="0x04805000" name="TIMER1" type="TIMER"/>
    <instance address="0x14006000" name="TIMER3" type="TIMER"/>
  </archive>
  <archive relative="uart.xml">
    <module category="Periph" name="UART">
      <var name="UART_RX_FIFO_SIZE" value="128"/>
      <var name="UART_TX_FIFO_SIZE" value="16"/>
      <var name="NB_RX_FIFO_BITS" value="7"/>
      <var name="NB_TX_FIFO_BITS" value="4"/>
      <reg name="ctrl" protect="rw">
        <bits access="rw" name="enable" pos="0" rst="0">
          <options>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
            <default/>
          </options>
          <comment>
            Allows to turn off the UART:
            <br/>
            0 = Disable
            <br/>
            1 = Enable
          </comment>
        </bits>
        <bits access="rw" name="data bits" pos="1" rst="0">
          <comment>Number of data bits per character (least significant bit first),
          if {Data_Bits_56, Data_Bits} is 00, the number of data bits is 7;
          if {Data_Bits_56, Data_Bits} is 01, the number of data bits is 8;
          if {Data_Bits_56, Data_Bits} is 10, the number of data bits is 5;
          if {Data_Bits_56, Data_Bits} is 11, the number of data bits is 6;</comment>
        </bits>
        <bits access="rw" name="tx stop bits" pos="2" rst="0">
          <options>
            <option name="1_BIT" value="0"/>
            <option name="2_BITS" value="1"/>
            <default/>
          </options>
          <comment>
            Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).
            <br/>
            0 = one stop bit is
      transmitted in the serial data.
            <br/>
            1 = two stop bits are generated and
      transmitted in the serial data out.
          </comment>
        </bits>
        <bits access="rw" name="parity enable" pos="3" rst="0">
          <options>
            <option name="NO" value="0"/>
            <option name="YES" value="1"/>
            <default/>
          </options>
          <comment>Parity is enabled when this bit is set.</comment>
        </bits>
        <bits access="rw" name="parity select" pos="5:4" rst="0">
          <options>
            <option name="ODD" value="0"/>
            <option name="EVEN" value="1"/>
            <option name="SPACE" value="2"/>
            <option name="MARK" value="3"/>
            <default/>
          </options>
          <comment>
            Controls the parity format when parity is enabled:
            <br/>
            00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).
            <br/>
            01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).
            <br/>
            10 = a space is
      generated and received as parity bit.
            <br/>
            11 = a mark is generated and
      received as parity bit.
          </comment>
        </bits>
        <bits access="rw" name="soft flow ctrl enable" pos="6" rst="0">
          <comment>
            Controls whether enable or disable soft flow ctrl function.
            <br/>
            0 = disable flow ctrl function
            <br/>
            1 = enable flow ctrl function
          </comment>
        </bits>
        <bits access="rw" name="auto_enable" pos="8" rst="0">
          <comment>
            Controls whether enable or disable auto baud rate function.
            <br/>
            0 = disable auto baud rate function
            <br/>
            1 = enable auto baud rate function
          </comment>
        </bits>
        <bits access="rw" name="data bits_56" pos="12" rst="0">
          <comment>Number of data bits per character (least significant bit first),
          if {Data_Bits_56, Data_Bits} is 00, the number of data bits is 7;
          if {Data_Bits_56, Data_Bits} is 01, the number of data bits is 8;
          if {Data_Bits_56, Data_Bits} is 10, the number of data bits is 5;
          if {Data_Bits_56, Data_Bits} is 11, the number of data bits is 6;</comment>
        </bits>
        <bits access="rw" name="divisor mode" pos="20:19" rst="2'h1">
          <comment>
            Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.
            <br/>
            0 =
      (BCLK = SCLK / 16)
            <br/>
            1 = (BCLK = SCLK / 4)
            <br/>
            2 = (BCLK = SCLK / 3)
          </comment>
        </bits>
        <bits access="rw" name="irda enable" pos="21" rst="0">
          <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details).</comment>
        </bits>
        <bits access="rw" name="dma mode" pos="22" rst="0">
          <options>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
            <default/>
          </options>
          <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC.</comment>
        </bits>
        <bits access="rw" name="auto flow control" pos="23" rst="0">
          <options>
            <option name="ENABLE" value="1"/>
            <option name="DISABLE" value="0"/>
            <default/>
          </options>
          <comment>Enables the auto flow control. Uart_RTS is controlled by the Rx
      RTS bit and the UART Auto Control Flow System. If Uart_CTS
      become inactive high, the Tx data flow is stopped.</comment>
        </bits>
        <bits access="rw" name="loop back mode" pos="24" rst="0">
          <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support).</comment>
        </bits>
        <bits access="rw" name="rx lock err" pos="25" rst="0">
          <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept.</comment>
        </bits>
        <bits access="rw" name="rx break length" pos="31:28" rst="0xF">
          <comment>Length of a break, in number of bits.</comment>
        </bits>
      </reg>
      <reg name="status" protect="r">
        <bits access="r" name="rx fifo level" pos="NB_RX_FIFO_BITS:0" rst="0">
          <options>
            <mask/>
            <shift/>
          </options>
          <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read.</comment>
        </bits>
        <bits access="r" name="tx fifo space" pos="NB_TX_FIFO_BITS+8:8" rst="5'h10">
          <options>
            <mask/>
            <shift/>
          </options>
          <comment>Those bits indicate the number of space available in the Tx
      Fifo.</comment>
        </bits>
        <bits access="r" name="at_match_flag" pos="13" rst="0">
          <comment>
            at_match flag
            <br/>
             '0' = AT is detected successfully.
            <br/>
             '1' = at is detected successfully.
            When auto_enable is 0,this bit is cleared to 0.
          </comment>
        </bits>
        <bits access="r" name="tx active" pos="14" rst="0">
          <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface.</comment>
        </bits>
        <bits access="r" name="rx active" pos="15" rst="0">
          <comment>This bit indicates that the UART is receiving a byte.</comment>
        </bits>
        <bits access="r" name="rx overflow err" pos="16" rst="0">
          <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="tx overflow err" pos="17" rst="0">
          <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when
          the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx parity err" pos="18" rst="0">
          <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx framing err" pos="19" rst="0">
          <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value.</comment>
        </bits>
        <bits access="r" name="rx break int" pos="20" rst="0">
          <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value.</comment>
        </bits>
        <bits access="r" name="character_miscompare" pos="21" rst="0">
          <comment>
            character miscompare flag
            <br/>
             '0' = AT or at compare failed.
            <br/>
             '1' = AT or at compare successfully.
            When auto_enable is 0,this bit is cleared to 0.
          </comment>
        </bits>
        <bits access="r" name="auto_baud_locked" pos="22" rst="0">
          <comment>
            auto baud locked flag
            <br/>
             '0' = baud rate is detected failed.
            <br/>
             '1' = baud rate is detected successfully.
            When auto_enable is 0,this bit is cleared to 0.
          </comment>
        </bits>
        <bits access="r" name="dcts" pos="24" rst="1">
          <comment>This bit is set when the Uart_CTS line changed since the last
      time this register has been written. This bit is cleared when the
      UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="cts" pos="25" rst="0">
          <comment>
            current value of the Uart_CTS line.
            <br/>
             '1' = Tx not allowed.
            <br/>
             '0' = Tx allowed.
          </comment>
        </bits>
        <bits access="r" name="auto ratio flag" pos="26" rst="0">
          <comment>Auto mode ratio flag.</comment>
        </bits>
        <bits access="r" name="mask tx enable flag" pos="27" rst="0">
          <comment>Mask tx enable flag.</comment>
        </bits>
        <bits access="r" name="dtr" pos="28" rst="0">
          <comment>Current value of the DTR line.</comment>
        </bits>
        <bits access="r" name="clk enabled" pos="31" rst="0">
          <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      RTS too early.</comment>
        </bits>
      </reg>
      <reg name="rxtx_buffer" protect="--">
        <bits access="rw" name="rxtx_data" pos="7:0">
          <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost.</comment>
        </bits>
      </reg>
      <reg name="irq_mask" protect="rw">
        <bits access="rw" name="tx modem status" pos="0" rst="0">
          <comment>Clear to send signal change detected.</comment>
        </bits>
        <bits access="rw" name="rx data available" pos="1" rst="0">
          <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level).</comment>
        </bits>
        <bits access="rw" name="tx data needed" pos="2" rst="0">
          <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level).</comment>
        </bits>
        <bits access="rw" name="rx timeout" pos="3" rst="0">
          <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time.</comment>
        </bits>
        <bits access="rw" name="rx line err" pos="4" rst="0">
          <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt.</comment>
        </bits>
        <bits access="rw" name="tx dma done" pos="5" rst="0">
          <comment>Pulse detected on Uart_Dma_Tx_Done_H signal.</comment>
        </bits>
        <bits access="rw" name="rx dma done" pos="6" rst="0">
          <comment>Pulse detected on Uart_Dma_Rx_Done_H signal.</comment>
        </bits>
        <bits access="rw" name="rx dma timeout" pos="7" rst="0">
          <comment>In DMA mode, there is at least 1 character that has been read
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.</comment>
        </bits>
        <bits access="rw" name="dtr rise" pos="8" rst="0">
          <comment>Rising edge detected on the UART_DTR signal.</comment>
        </bits>
        <bits access="rw" name="dtr fall" pos="9" rst="0">
          <comment>Falling edge detected on the UART_DTR signal.</comment>
        </bits>
        <bits access="rw" name="auto fail" pos="10" rst="0">
          <comment>Auto function fail.</comment>
        </bits>
        <bits access="rw" name="uart dma rx adone" pos="11" rst="0">
          <comment>When rx transfer num equals to transfer threshold, there is a interrupt flag.</comment>
        </bits>
        <bits access="rw" name="uart dma tx adone" pos="12" rst="0">
          <comment>When tx transfer num equals to transfer threshold, there is a interrupt flag.</comment>
        </bits>
        <bits access="rw" name="xoff_trig" pos="13" rst="0">
          <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xoff.</comment>
        </bits>
        <bits access="rw" name="xon_trig" pos="14" rst="0">
          <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xon.</comment>
        </bits>
        <bits access="rw" name="start_det" pos="15" rst="0">
          <comment>This interrupt is generated when start bit is detected.</comment>
        </bits>
      </reg>
      <reg name="irq_cause" protect="rw">
        <bits access="r" name="tx modem status" pos="0" rst="0">
          <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.</comment>
        </bits>
        <bits access="r" name="rx data available" pos="1" rst="0">
          <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level.</comment>
        </bits>
        <bits access="r" name="tx data needed" pos="2" rst="0">
          <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level.</comment>
        </bits>
        <bits access="r" name="rx timeout" pos="3" rst="0">
          <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.</comment>
        </bits>
        <bits access="r" name="rx line err" pos="4" rst="0">
          <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value.</comment>
        </bits>
        <bits access="rw" name="tx dma done" pos="5" rst="0">
          <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="rx dma done" pos="6" rst="0">
          <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="rx dma timeout" pos="7" rst="0">
          <comment>In DMA mode, there is at least 1 character that has been read
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.
            Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="dtr rise" pos="8" rst="0">
          <comment>This interrupt is generated when a rising edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="dtr fall" pos="9" rst="0">
          <comment>This interrupt is generated when a falling edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.</comment>
        </bits>
        <bits access="rw" name="auto fail" pos="10" rst="0">
          <comment>This interrupt is generated when auto function fail.
      Reset control: Write  0 in auto_enable.</comment>
        </bits>
        <bits access="rw" name="uart dma rx adone" pos="11" rst="0">
          <comment>This interrupt is generated when rx transfer num is not less than transfer threshold.
      Reset control: Write  1 in this register.</comment>
        </bits>
        <bits access="rw" name="uart dma tx adone" pos="12" rst="0">
          <comment>This interrupt is generated when tx transfer num is not less than transfer threshold.
      Reset control: Write  1 in this register.</comment>
        </bits>
        <bits access="rw" name="xoff_trig" pos="13" rst="0">
          <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xoff.
      Reset control: Write  1 in this register.</comment>
        </bits>
        <bits access="rw" name="xon_trig" pos="14" rst="0">
          <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xon.
      Reset control: Write  1 in this register.</comment>
        </bits>
        <bits access="rw" name="start_det" pos="15" rst="0">
          <comment>This interrupt is generated when start is detected.
      Reset control: Write  1 in this register.</comment>
        </bits>
        <bits access="r" name="tx modem status u" pos="16" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx data available u" pos="17" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="tx data needed u" pos="18" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx timeout u" pos="19" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx line err u" pos="20" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="tx dma done u" pos="21" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx dma done u" pos="22" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="rx dma timeout u" pos="23" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="dtr rise u" pos="24" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="dtr fall u" pos="25" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="r" name="auto fail u" pos="26" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="rw" name="uart dma rx adone u" pos="27" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="rw" name="uart dma tx adone u" pos="28" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="rw" name="xoff_trig u" pos="29" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="rw" name="xon_trig u" pos="30" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
        <bits access="rw" name="start_det u" pos="31" rst="0">
          <comment>Same as previous, not masked.</comment>
        </bits>
      </reg>
      <reg name="triggers" protect="rw">
        <bits access="rw" name="rx trigger" pos="NB_RX_FIFO_BITS-1:0" rst="0">
          <comment>
            Defines the empty threshold level at which the Data Available
      Interrupt will be generated.
            <br/>
            The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.
          </comment>
        </bits>
        <bits access="rw" name="tx trigger" pos="NB_TX_FIFO_BITS-1+8:8" rst="0">
          <comment>
            Defines the empty threshold level at which the Data Needed
      Interrupt will be generated.
            <br/>
            The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.
          </comment>
        </bits>
        <bits access="rw" name="afc level" pos="NB_RX_FIFO_BITS-1+16:16" rst="0">
          <comment>
            Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).
            <br/>
            The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.
          </comment>
        </bits>
      </reg>
      <reg name="cmd_set" protect="rw">
        <bits access="rs" name="ri" pos="0" rst="0">
          <comment>Ring indicator. When write '1', set RI bit. When read, get RI bit
            value.</comment>
        </bits>
        <bits access="rs" name="dcd" pos="1" rst="0">
          <comment>Data carrier detect. When write '1', set DCD bit. When read, get DCD
            bit value.</comment>
        </bits>
        <bits access="rs" name="dsr" pos="2" rst="0">
          <comment>Data set ready. When write '1', set RI bit. When read, get RI bit
            value.</comment>
        </bits>
        <bits access="rs" name="tx break control" pos="3" rst="0">
          <comment>Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared.</comment>
        </bits>
        <bits access="rs" name="tx finish n wait" pos="4" rst="0">
          <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
        </bits>
        <bits access="rs" name="rts" pos="5" rst="0">
          <comment>
            Controls the Uart_RTS output.
            <br/>
            0 = the Uart_RTS will be inactive high (Rx not allowed).
            <br/>
            1 = the Uart_RTS will be active low (Rx allowed).
          </comment>
        </bits>
        <bits access="r" name="rx fifo reset" pos="6" rst="0">
          <comment>Writing a 1 to this bit resets and flushes the Receive Fifo.
      This bit does not need to be cleared.</comment>
        </bits>
        <bits access="r" name="tx fifo reset" pos="7" rst="0">
          <comment>Writing a 1 to this bit resets and flushes the Transmit Fifo.
      This bit does not need to be cleared.</comment>
        </bits>
      </reg>
      <reg name="cmd_clr" protect="rw">
        <bits access="rc" name="ri" pos="0" rst="0">
          <comment>Ring indicator. When write '1', clear RI bit. When read, get RI bit
            value.</comment>
        </bits>
        <bits access="rc" name="dcd" pos="1" rst="0">
          <comment>Data carrier detect. When write '1', clear DCD bit. When read, get DCD
            bit value.</comment>
        </bits>
        <bits access="rc" name="dsr" pos="2" rst="0">
          <comment>Data set ready. When write '1', clear RI bit. When read, get RI bit
            value.</comment>
        </bits>
        <bits access="rc" name="tx break control" pos="3" rst="0">
          <comment>Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared.</comment>
        </bits>
        <bits access="rc" name="tx finish n wait" pos="4" rst="0">
          <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
        </bits>
        <bits access="rc" name="rts" pos="5" rst="0">
          <comment>
            Controls the Uart_RTS output.
            <br/>
            0 = the Uart_RTS will be inactive high.
            <br/>
            1 = the Uart_RTS will be active low.
          </comment>
        </bits>
      </reg>
      <reg name="auto ratio" protect="r">
        <bits access="r" name="auto ratio" pos="15:0" rst="0">
          <comment>Auto mode ratio.</comment>
        </bits>
      </reg>
      <reg name="xon" protect="rw">
        <bits access="rw" name="xon" pos="7:0" rst="8'h11">
          <comment>XON character value.</comment>
        </bits>
      </reg>
      <reg name="xoff" protect="rw">
        <bits access="rw" name="xoff" pos="7:0" rst="8'h13">
          <comment>XOFF character value.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51700000" name="UART1" type="UART"/>
    <instance address="0x51400000" name="UART2" type="UART"/>
    <instance address="0x51401000" name="UART3" type="UART"/>
    <instance address="0x04400000" name="UART4" type="UART"/>
    <instance address="0x04401000" name="UART5" type="UART"/>
    <instance address="0x04402000" name="UART6" type="UART"/>
  </archive>
  <archive relative="efuse.xml">
    <module category="System" name="EFUSE">
      <hole size="64"/>
      <reg name="efuse_all0_index" protect="rw">
        <bits access="rw" name="efuse_all0_start_index" pos="31:16" rst="0">
      </bits>
        <bits access="rw" name="efuse_all0_end_index" pos="15:0" rst="127">
      </bits>
      </reg>
      <reg name="efuse_mode_ctrl" protect="rw">
        <bits access="rw" name="efuse_all0_check_start" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_cfg1" protect="rw">
        <bits access="rw" name="tpgm_time_cnt2" pos="24:16" rst="310">
      </bits>
        <bits access="rw" name="tpgm_time_cnt1" pos="8:0" rst="310">
      </bits>
      </reg>
      <reg name="efuse_ip_ver" protect="r">
        <bits access="r" name="efuse_type" pos="17:16" rst="0">
      </bits>
        <bits access="r" name="efuse_ip_ver" pos="15:0" rst="2048">
      </bits>
      </reg>
      <reg name="efuse_cfg0" protect="rw">
        <bits access="rw" name="clk_efs_div" pos="31:24" rst="0">
      </bits>
        <bits access="rw" name="efuse_strobe_low_width" pos="23:16" rst="0">
      </bits>
        <bits access="rw" name="tpgm_time_cnt" pos="8:0" rst="310">
      </bits>
      </reg>
      <reg name="efuse_cfg2" protect="rw">
        <bits access="rw" name="tpgm_time_bist" pos="24:16" rst="310">
      </bits>
        <bits access="rw" name="tpgm_time_cnt3" pos="8:0" rst="310">
      </bits>
      </reg>
      <reg name="efuse_ns_en" protect="rw">
        <bits access="rw" name="ns_lock_bit_wr_en" pos="4" rst="0">
      </bits>
        <bits access="rw" name="ns_margin_rd_enable" pos="3" rst="0">
      </bits>
        <bits access="rw" name="double_bit_en_ns" pos="2" rst="0">
      </bits>
        <bits access="rw" name="ns_auto_check_enable" pos="1" rst="0">
      </bits>
        <bits access="rw" name="ns_vdd_en" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_ns_err_flag" protect="r">
        <bits access="r" name="ns_all0_check_flag" pos="13" rst="0">
      </bits>
        <bits access="r" name="ns_enk_err_flag" pos="12" rst="0">
      </bits>
        <bits access="r" name="ns_magnum_wr_flag" pos="11" rst="0">
      </bits>
        <bits access="r" name="ns_block0_rd_flag" pos="10" rst="0">
      </bits>
        <bits access="r" name="ns_vdd_on_rd_flag" pos="9" rst="0">
      </bits>
        <bits access="r" name="ns_pg_en_wr_flag" pos="8" rst="0">
      </bits>
        <bits access="r" name="ns_word1_prot_flag" pos="5" rst="0">
      </bits>
        <bits access="r" name="ns_word0_prot_flag" pos="4" rst="0">
      </bits>
        <bits access="r" name="ns_word1_err_flag" pos="1" rst="0">
      </bits>
        <bits access="r" name="ns_word0_err_flag" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_ns_flag_clr" protect="rw">
        <bits access="rw" name="ns_all0_check_clr" pos="13" rst="0">
      </bits>
        <bits access="rw" name="ns_enk_err_clr" pos="12" rst="0">
      </bits>
        <bits access="rw" name="ns_magnum_wr_clr" pos="11" rst="0">
      </bits>
        <bits access="rw" name="ns_block0_rd_clr" pos="10" rst="0">
      </bits>
        <bits access="rw" name="ns_vdd_on_rd_clr" pos="9" rst="0">
      </bits>
        <bits access="rw" name="ns_pg_en_wr_clr" pos="8" rst="0">
      </bits>
        <bits access="rw" name="ns_word1_prot_clr" pos="5" rst="0">
      </bits>
        <bits access="rw" name="ns_word0_prot_clr" pos="4" rst="0">
      </bits>
        <bits access="rw" name="ns_word1_err_clr" pos="1" rst="0">
      </bits>
        <bits access="rw" name="ns_word0_err_clr" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_ns_magic_number" protect="rw">
        <bits access="rw" name="ns_magic_nubmer" pos="15:0" rst="0">
      </bits>
      </reg>
      <hole size="128"/>
      <reg name="efuse_s_en" protect="rw">
        <bits access="rw" name="s_lock_bit_wr_en" pos="4" rst="0">
      </bits>
        <bits access="rw" name="s_margin_rd_enable" pos="3" rst="0">
      </bits>
        <bits access="rw" name="double_bit_en_s" pos="2" rst="0">
      </bits>
        <bits access="rw" name="s_auto_check_enable" pos="1" rst="0">
      </bits>
        <bits access="rw" name="s_vdd_en" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_s_err_flag" protect="r">
        <bits access="r" name="s_all0_check_flag" pos="13" rst="0">
      </bits>
        <bits access="r" name="s_enk_err_flag" pos="12" rst="0">
      </bits>
        <bits access="r" name="s_magnum_wr_flag" pos="11" rst="0">
      </bits>
        <bits access="r" name="s_block0_rd_flag" pos="10" rst="0">
      </bits>
        <bits access="r" name="s_vdd_on_rd_flag" pos="9" rst="0">
      </bits>
        <bits access="r" name="s_pg_en_wr_flag" pos="8" rst="0">
      </bits>
        <bits access="r" name="s_word1_prot_flag" pos="5" rst="0">
      </bits>
        <bits access="r" name="s_word0_prot_flag" pos="4" rst="0">
      </bits>
        <bits access="r" name="s_word1_err_flag" pos="1" rst="0">
      </bits>
        <bits access="r" name="s_word0_err_flag" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_s_flag_clr" protect="rw">
        <bits access="rw" name="s_all0_check_clr" pos="13" rst="0">
      </bits>
        <bits access="rw" name="s_enk_err_clr" pos="12" rst="0">
      </bits>
        <bits access="rw" name="s_magnum_wr_clr" pos="11" rst="0">
      </bits>
        <bits access="rw" name="s_block0_rd_clr" pos="10" rst="0">
      </bits>
        <bits access="rw" name="s_vdd_on_rd_clr" pos="9" rst="0">
      </bits>
        <bits access="rw" name="s_pg_en_wr_clr" pos="8" rst="0">
      </bits>
        <bits access="rw" name="s_word1_prot_clr" pos="5" rst="0">
      </bits>
        <bits access="rw" name="s_word0_prot_clr" pos="4" rst="0">
      </bits>
        <bits access="rw" name="s_word1_err_clr" pos="1" rst="0">
      </bits>
        <bits access="rw" name="s_word0_err_clr" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_s_magic_number" protect="rw">
        <bits access="rw" name="s_magic_nubmer" pos="15:0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_fw_cfg" protect="rw">
        <bits access="rw" name="access_prot" pos="1" rst="0">
      </bits>
        <bits access="rw" name="conf_prot" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="efuse_pw_swt" protect="rw">
        <bits access="rw" name="ns_s_pg_en" pos="2" rst="0">
      </bits>
        <bits access="rw" name="efs_enk2_on" pos="1" rst="1">
      </bits>
        <bits access="rw" name="efs_enk1_on" pos="0" rst="0">
      </bits>
      </reg>
      <hole size="128"/>
      <reg name="pw_on_rd_end_flag" protect="r">
        <bits access="r" name="pw_on_rd_end_flag" pos="0" rst="0">
      </bits>
      </reg>
      <reg name="ns_s_flag" protect="r">
        <bits access="r" name="ns_s_flag" pos="0" rst="1">
      </bits>
      </reg>
      <reg name="por_read_data_sp" protect="r">
        </reg>
      <reg name="por_read_data_sp1" protect="r">
        </reg>
      <reg name="block3" protect="r">
        </reg>
      <reg name="block89" protect="r">
        </reg>
      <reg name="efuse_enc_bypass_en" protect="rw">
        <bits access="rw" name="efuse_enc_bypass_en" pos="7:0" rst="0">
      </bits>
      </reg>
    </module>
    <instance address="0x51200000" name="EFUSE" type="EFUSE"/>
  </archive>
  <archive relative="keypad.xml">
    <module category="Periph" name="KEYPAD">
      <var name="KEY_NB" value="36">
        <comment>Number of key in the keypad</comment>
      </var>
      <var name="LOW_KEY_NB" value="30">
        <comment>Number of key in the low data register</comment>
      </var>
      <var name="HIGH_KEY_NB" value="6">
        <comment>Number of key in the high data register</comment>
      </var>
      <reg name="kp_data_l" protect="r">
        <comment>For keys in column Idx_KeyOut(from 0 to 3) and in line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_L(Idx_KeyOut*8+Idx_KeyIn) :</comment>
      </reg>
      <reg name="kp_data_h" protect="r">
        <comment>For keys in column Idx_KeyOut(from 4 to 7) and line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_H(Idx_KeyIn*8-32+Idx_KeyIn):</comment>
      </reg>
      <reg name="kp_status" protect="r">
        <bits access="r" name="keyin_status" pos="7:0" rst="0x08">
          <comment>
            For keys in lines status
            <br/>
            0 = Released
            <br/>
            1 = Pressed
          </comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits access="r" name="kp_on" pos="31" rst="0">
          <comment>
            Indicate Key ON pressing status :
            <br/>
            0 = Release
            <br/>
            1 = Pressed
          </comment>
          <options>
            <default/>
            <mask/>
            <shift/>
          </options>
        </bits>
      </reg>
      <reg name="kp_ctrl" protect="rw">
        <bits access="rw" name="kp_en" pos="0" rst="0">
          <comment>
            This bit enables key detection. If this bit is '0', the key detection function
            is disabled. Key ON is an exception, it can be still detected and generate key interrupt
            even if KP_En = '0', however in this case, the debouncing time configuration in key
            control register is ignored and the key ON state is considerred to be stable if it keeps
            same in consecutive 2 cycles of 16KHz clock.
            <br/>
            <br/>
            0 = keypad disable
            <br/>
            1 = keypad enable
          </comment>
        </bits>
        <bits access="rw" name="kp_dbn_time" pos="9:2" rst="0">
          <comment>De-bounce time = (KP_DBN_TIME + 1) * SCAN_TIME, SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_DBN_TIME = 7, KP_OUT_MASK = &quot;111111&quot;, then De-bounce time = (7+1)*0.3125*6=15 ms. The maximum debounce time is 480 ms.</comment>
        </bits>
        <bits access="rw" name="kp_itv_time" pos="15:10" rst="0">
          <comment>Configure interval of generating an IRQ if one key or several keys are pressed long time. Interval of IRQ generation = (KP_ITV_Time + 1) * (KP_DBN_TIME + 1) * SCAN_TIME. SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_ITV_TIME = 7, KP_DBN_TIME = 7, KP_OUT_MASK = &quot;111111&quot;, then De-bounce time = (7+1)*(7+1)*0.3125*6=120 ms.</comment>
        </bits>
        <bits access="rw" name="kp_in_mask" pos="23:16" rst="0xff">
          <comment>
            each bit masks one input lines.
            <br/>
            '1' = enabled
            <br/>
             '0' = disabled
            <br/>
            The Key In pins 0 to 5 are muxed with the boot mode pins, latched during Reset.
            <br/>
             Key_In 0: BOOT_MODE_NO_AUTO_PU.
            <br/>
             Key_In 1: BOOT_MODE_FORCE_MONITOR.
            <br/>
             Key_In 2: BOOT_MODE_UART_MONITOR_ENABLE.
            <br/>
             Key_In 3: BOOT_MODE_USB_MONITOR_DISABLE.
            <br/>
             Key_In 4: reserved
          </comment>
        </bits>
        <bits access="rw" name="kp_out_mask" pos="31:24" rst="0xff">
          <comment>
            each bit masks one output lines.
            <br/>
            '1' = enabled
            <br/>
             '0' = disabled
          </comment>
        </bits>
      </reg>
      <reg name="kp_irq_mask" protect="rw">
        <bits access="rw" name="kp_evt0_irq_mask" pos="0" rst="0">
          <comment>
            This bit mask keypad irq generated by event0 (key press or key release event, not including all keys release event which is event1).
            <br/>
            0 = keypad event irq disable
            <br/>
            1 = keypad event irq enable
          </comment>
        </bits>
        <bits access="rw" name="kp_evt1_irq_mask" pos="1" rst="0">
          <comment>
            This bit mask keypad irq generated by event1 (all keys release event).
            <br/>
            0 = keypad event irq disable
            <br/>
            1 = keypad event irq enable
          </comment>
        </bits>
        <bits access="rw" name="kp_itv_irq_mask" pos="2" rst="0">
          <comment>
            This bit mask keypad irq generated by key pressed long time (generated each interval configured in KP_ITV_Time.
            <br/>
            0 = keypad interval irq disable
            <br/>
            1 = keypad interval irq enable
          </comment>
        </bits>
      </reg>
      <reg name="kp_irq_cause" protect="r">
        <bits access="r" name="kp_evt0_irq_cause" pos="0" rst="0">
          <comment>keypad event0(key press or key release event, not including all keys release which is event1) IRQ cause.</comment>
        </bits>
        <bits access="r" name="kp_evt1_irq_cause" pos="1" rst="0">
          <comment>keypad event1(all keys release event) IRQ cause.</comment>
        </bits>
        <bits access="r" name="kp_itv_irq_cause" pos="2" rst="0">
          <comment>keypad interval irq cause.</comment>
        </bits>
        <bits access="r" name="kp_evt0_irq_status" pos="16" rst="0">
          <comment>keypad event0(key press or key release event, not including all keys release which is event1) irq status.</comment>
        </bits>
        <bits access="r" name="kp_evt1_irq_status" pos="17" rst="0">
          <comment>keypad event1(all keys release event) irq status.</comment>
        </bits>
        <bits access="r" name="kp_itv_irq_status" pos="18" rst="0">
          <comment>keypad interval irq status.</comment>
        </bits>
      </reg>
      <reg name="kp_irq_clr" protect="rw">
        <bits access="c" name="kp_irq_clr" pos="0" rst="0">
          <comment>Write '1' to this bit clears key IRQ.</comment>
        </bits>
      </reg>
    </module>
    <instance address="0x51706000" name="KEYPAD" type="KEYPAD"/>
  </archive>
  <archive relative="gpio.xml">
    <var name="IDX_GPIO_DCON" value="0"/>
    <var name="IDX_GPO_CHG" value="0"/>
    <module category="Periph" name="GPIO">
      <reg name="gpio_oen_val" protect="rw">
        <comment>Set the direction of the GPIO n.</comment>
      </reg>
      <reg name="gpio_oen_set_out" protect="rw">
        <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
      </reg>
      <reg name="gpio_oen_set_in" protect="rw">
        <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
      </reg>
      <reg name="gpio_val_reg" protect="rw">
        <comment>When write, update the output value. When read, get the input
      value.</comment>
      </reg>
      <reg name="gpio_set_reg" protect="rw">
        <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
      </reg>
      <reg name="gpio_clr_reg" protect="rw">
        <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value.</comment>
      </reg>
      <reg name="gpint_ctrl_r_set_reg" protect="rw">
        <comment>'Write '1' will set GPIO interrupt mask for rising edge and
      level high. When read, get the GPIO interrupt mask for rising edge and
      level high.</comment>
      </reg>
      <reg name="gpint_ctrl_r_clr_reg" protect="rw">
        <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
      level high.</comment>
      </reg>
      <reg name="int_clr" protect="w">
        <comment>'Write '1' will clear GPIO interrupt.</comment>
      </reg>
      <reg name="int_status" protect="r">
        <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      </reg>
      <reg name="chg_ctrl" protect="rw">
        <bits access="rw" display="hex" name="out_time" pos="3:0" rst="0xf">
          <comment>
            time for which GPIO0 is set to output mode, after a start read
            DCON command is issued.
            <br/>
            The output time = (OUT_TIME+1)*30.5us.
          </comment>
        </bits>
        <bits access="rw" display="hex" name="wait_time" pos="9:4" rst="0x3f">
          <comment>
            time for which GPIO0 should wait before reading DC_ON, after
            a start read DCON command is issued.
            <br/>
            The wait time = (WAIT_TIME+1)*30.5us.
            <br/>
            NOTE: wait_time must be strictly greater than out_time;
          </comment>
        </bits>
        <bits access="rw" display="hex" name="int_mode" pos="17:16" rst="0x3">
          <comment>
            interruption mode of GPIO0 in mode DC_ON detection.
            <br/>
          </comment>
          <options>
            <option name="L2H" value="0">
              <comment>&quot;00&quot; = send IRQ if last read DCON is '0' and now is '1'.</comment>
            </option>
            <option name="H2L" value="1">
              <comment>&quot;01&quot; = send IRQ if last read DCON is '1' and now is '0'.</comment>
            </option>
            <option name="RR" value="3">
              <comment>&quot;11&quot; = send IRQ every time read is ready.</comment>
            </option>
          </options>
        </bits>
      </reg>
      <reg name="chg_cmd" protect="w">
        <bits access="s" name="dcon_mode_set" pos="0" rst="0">
          <comment>Write '1' to set GPIO0 to charger DCON detect mode.</comment>
        </bits>
        <bits access="s" name="chg_mode_set" pos="4" rst="0">
          <comment>Write '1' to set GPO0 to charger watchdog mode.</comment>
        </bits>
        <bits access="c" name="dcon_mode_clr" pos="8" rst="0">
          <comment>Write '1' to clear charger DCON detect mode of GPIO0.</comment>
        </bits>
        <bits access="c" name="chg_mode_clr" pos="12" rst="0">
          <comment>Write '1' to clear the charger watchdog mode of GPO0.</comment>
        </bits>
        <bits access="s" name="chg_down" pos="24" rst="0">
          <comment>Write '1' to generate a pulse of '0' on GPO0 for 16 CLK_OSC cycles.</comment>
        </bits>
      </reg>
      <reg name="gpo_set_reg" protect="rw">
        <bits access="rs" display="hex" name="gpo_set" pos="7:0" rst="0xaa">
          <comment>'Write '1' will set GPO output value. When read, get the GPO
      output value.</comment>
        </bits>
      </reg>
      <reg name="gpo_clr_reg" protect="rw">
        <bits access="rc" display="hex" name="gpo_clr" pos="7:0" rst="0xaa">
          <comment>'Write '1' will clear GPO output value. When read, get the GPO
      output value.</comment>
        </bits>
      </reg>
      <reg name="gpint_ctrl_f_set_reg" protect="rw">
        <comment>'Write '1' will set GPIO interrupt mask for rising edge and
      level high. When read, get the GPIO interrupt mask for rising edge and
      level high.</comment>
      </reg>
      <reg name="gpint_ctrl_f_clr_reg" protect="rw">
        <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
      level high.</comment>
      </reg>
      <reg name="dbn_en_set_reg" protect="rw">
        <comment>'Write '1' will enable debounce mechanism.</comment>
      </reg>
      <reg name="dbn_en_clr_reg" protect="rw">
        <comment>'Write '1' will disable debounce mechanism.</comment>
      </reg>
      <reg name="gpint_mode_set_reg" protect="rw">
        <comment>Write '1' will set interruption mode to level.</comment>
      </reg>
      <reg name="gpint_mode_clr_reg" protect="rw">
        <comment>Write '1' will set interruption mode to edge
      triggered.</comment>
      </reg>
    </module>
    <instance address="0x51703000" name="GPIO1" type="GPIO"/>
    <instance address="0x51503000" name="GPIO2" type="GPIO"/>
  </archive>
</bigarchive>