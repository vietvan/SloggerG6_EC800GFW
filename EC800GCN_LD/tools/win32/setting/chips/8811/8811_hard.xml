<bigarchive>
<archive relative="****phantomglobalvars****">
</archive>
<archive relative = "globals_1811.xml" vhdlpkg="chip_cfg_pkg">

  <var name="PMIC_NB_BITS_PADDR" value="8"></var>
  <var name="PMIC_STEP" value="exp2(PMIC_NB_BITS_PADDR)"/>

  
  <enum name="Pmic_Module_Id">
    <entry name="PMIC_ID_IOMUX"/>
    <entry name="PMIC_ID_GPIO"/>
    <entry name="PMIC_ID_GPT"/>
    <entry name="PMIC_ID_TIMER"/>
    <entry name="PMIC_ID_WDT"/>
    <entry name="PMIC_ID_INTC"/>
    <entry name="PMIC_ID_PMUC"/>
    <entry name="PMIC_ID_PMUC_h"/>
    <entry name="PMIC_ID_ADC"/>
    <entry name="PMIC_ID_EFS"/>
    <entry name="PMIC_ID_DIG"/>
    <entry name="PMIC_ID_EIC"/>
  </enum>

  

</archive>
<archive relative="starcpu.xml">
  <module name="NVIC" category="StarCPU">
    <reg protect="rw" name="ISER" count="16">
    </reg>
    <hole size="512"/>
    <reg protect="rw" name="ICER" count="16">
    </reg>
    <hole size="512"/>
    <reg protect="rw" name="ISPR" count="16">
    </reg>
    <hole size="512"/>
    <reg protect="rw" name="ICPR" count="16">
    </reg>
    <hole size="512"/>
    <reg protect="rw" name="IABR" count="16">
    </reg>
    <hole size="512"/>
    <reg protect="rw" name="ITNS" count="16">
    </reg>
    <hole size="512"/>
    <reg8 protect="rw" name="IPR" count="496">
    </reg8>
    <hole size="18560"/>
    <reg protect="rw" name="STIR">
      <bits name="INTID" pos="0"/>
    </reg>
  </module>
  <module name="SCB" category="StarCPU">
    <reg name="CPUID" protect="r">
      <bits name="IMPLEMENTER" pos="31:24"/>
      <bits name="VARIANT" pos="23:20"/>
      <bits name="ARCHITECTURE" pos="19:16"/>
      <bits name="PARTNO" pos="15:4"/>
      <bits name="REVISION" pos="3:0"/>
    </reg>
    <reg name="ICSR" protect="rw">
      <bits name="PENDNMISET" pos="31"/>
      <bits name="PENDNMICLR" pos="30"/>
      <bits name="PENDSVSET" pos="28"/>
      <bits name="PENDSVCLR" pos="27"/>
      <bits name="PENDSTSET" pos="26"/>
      <bits name="PENDSTCLR" pos="25"/>
      <bits name="STTNS" pos="24"/>
      <bits name="ISRPREEMPT" pos="23"/>
      <bits name="ISRPENDING" pos="22"/>
      <bits name="VECTPENDING" pos="20:12"/>
      <bits name="RETTOBASE" pos="11"/>
      <bits name="VECTACTIVE" pos="8:0"/>
    </reg>
    <reg name="VTOR" protect="rw"/>
    <reg name="AIRCR" protect="rw">
      <bits name="VECTKEY" pos="31:16"/>
      <bits name="ENDIANESS" pos="15"/>
      <bits name="PRIS" pos="14"/>
      <bits name="BFHFNMINS" pos="13"/>
      <bits name="PRIGROUP" pos="10:8"/>
      <bits name="SYSRESETREQS" pos="3"/>
      <bits name="SYSRESETREQ" pos="2"/>
      <bits name="VECTCLRACTIVE" pos="1"/>
    </reg>
    <reg name="SCR" protect="rw">
      <bits name="SEVONPEND" pos="4"/>
      <bits name="SLEEPDEEPS" pos="3"/>
      <bits name="SLEEPDEEP" pos="2"/>
      <bits name="SLEEPONEXIT" pos="1"/>
    </reg>
    <reg name="CCR" protect="rw">
      <bits name="BP" pos="18"/>
      <bits name="IC" pos="17"/>
      <bits name="DC" pos="16"/>
      <bits name="STKOFHFNMIGN" pos="10"/>
      <bits name="BFHFNMIGN" pos="8"/>
      <bits name="DIV_0_TRP" pos="4"/>
      <bits name="UNALIGN_TRP" pos="3"/>
      <bits name="USERSETMPEND" pos="1"/>
    </reg>
    <reg8 name="SHPR" count="12" protect="rw">
    </reg8>
    <reg name="SHCSR" protect="rw">
      <bits name="HARDFAULTPENDED" pos="21"/>
      <bits name="SECUREFAULTPENDED" pos="20"/>
      <bits name="SECUREFAULTENA" pos="19"/>
      <bits name="USGFAULTENA" pos="18"/>
      <bits name="BUSFAULTENA" pos="17"/>
      <bits name="MEMFAULTENA" pos="16"/>
      <bits name="SVCALLPENDED" pos="15"/>
      <bits name="BUSFAULTPENDED" pos="14"/>
      <bits name="MEMFAULTPENDED" pos="13"/>
      <bits name="USGFAULTPENDED" pos="12"/>
      <bits name="SYSTICKACT" pos="11"/>
      <bits name="PENDSVACT" pos="10"/>
      <bits name="MONITORACT" pos="8"/>
      <bits name="SVCALLACT" pos="7"/>
      <bits name="NMIACT" pos="5"/>
      <bits name="SECUREFAULTACT" pos="4"/>
      <bits name="USGFAULTACT" pos="4"/>
      <bits name="HARDFAULTACT" pos="2"/>
      <bits name="BUSFAULTACT" pos="1"/>
      <bits name="MEMFAULTACT" pos="0"/>
    </reg>
    <reg name="CFSR" protect="rw">
      <bits name="USGFAULTSR" pos="31:16"/>
      <bits name="BUSFAULTSR" pos="15:8"/>
      <bits name="MEMFAULTSR" pos="7:0"/>
    </reg>
    <reg name="HFSR" protect="rw">
      <bits name="DEBUGEVT" pos="31"/>
      <bits name="FORCED" pos="30"/>
      <bits name="VECTTBL" pos="1"/>
    </reg>
    <reg name="DFSR" protect="rw">
      <bits name="EXTERNAL" pos="4"/>
      <bits name="VCATCH" pos="3"/>
      <bits name="DWTTRAP" pos="2"/>
      <bits name="BKPT" pos="1"/>
      <bits name="HALTED" pos="0"/>
    </reg>
    <reg name="MMFAR" protect="rw">
    </reg>
    <reg name="BFAR" protect="rw">
    </reg>
    <reg name="AFSR" protect="rw">
    </reg>
    <reg name="ID_PFR" count="2" protect="r">
    </reg>
    <reg name="ID_DFR" protect="r">
    </reg>
    <reg name="ID_ADR" protect="r">
    </reg>
    <reg name="ID_MMFR" count="4" protect="r">
    </reg>
    <reg name="ID_ISAR" count="6" protect="r">
    </reg>
    <reg name="CLIDR" protect="r">
    </reg>
    <reg name="CTR" protect="r">
    </reg>
    <reg name="CCSIDR" protect="r">
      <bits name="WT" pos="31"/>
      <bits name="WB" pos="30"/>
      <bits name="RA" pos="29"/>
      <bits name="WA" pos="28"/>
      <bits name="NUMSETS" pos="27:13"/>
      <bits name="ASSOCIATIVITY" pos="12:3"/>
      <bits name="LINESIZE" pos="2:0"/>
    </reg>
    <reg name="CSSELR" protect="rw">
      <bits name="LEVEL" pos="3:1"/>
      <bits name="IND" pos="0"/>
    </reg>
    <reg name="CPACR" protect="rw">
    </reg>
    <reg name="NSACR" protect="rw">
    </reg>
    <hole size="2944"/>
    <reg name="STIR" protect="w">
      <bits name="INTID" pos="8:0"/>
    </reg>
    <hole size="480"/>
    <reg name="MVFR0" protect="r">
    </reg>
    <reg name="MVFR1" protect="r">
    </reg>
    <reg name="MVFR2" protect="r">
    </reg>
    <hole size="32"/>
    <reg name="ICIALLU" protect="w">
    </reg>
    <hole size="32"/>
    <reg name="ICIMVAU" protect="w">
    </reg>
    <reg name="DCIMVAC" protect="w">
    </reg>
    <reg name="DCISW" protect="w">
    </reg>
    <reg name="DCCMVAU" protect="w">
    </reg>
    <reg name="DCCMVAC" protect="w">
    </reg>
    <reg name="DCCSW" protect="w">
    </reg>
    <reg name="DCCIMVAC" protect="w">
    </reg>
    <reg name="DCCISW" protect="w">
    </reg>
  </module>
  <module name="SCnSCB" category="StarCPU">
    <hole size="32"/>
    <reg name="ICTR" protect="r">
      <bits name="INTLINESNUM" pos="7:0"/>
    </reg>
    <reg name="ACTLR" protect="rw">
    </reg>
    <reg name="CPPWR" protect="rw">
    </reg>
  </module>
  <module name="SysTick" category="StarCPU">
    <reg name="CTRL" protect="rw">
      <bits name="COUNTFLAG" pos="16"/>
      <bits name="CLKSOURCE" pos="2"/>
      <bits name="TICKINT" pos="1"/>
      <bits name="ENABLE" pos="0"/>
    </reg>
    <reg name="LOAD" protect="rw">
      <bits name="RELOAD" pos="23:0"/>
    </reg>
    <reg name="VAL" protect="rw">
      <bits name="CURRENT" pos="23:0"/>
    </reg>
    <reg name="CALIB" protect="r">
      <bits name="NOREF" pos="31"/>
      <bits name="SKEW" pos="30"/>
      <bits name="TENMS" pos="23:0"/>
    </reg>
  </module>
  <module name="MPU" category="StarCPU">
    <reg name="TYPE" protect="r">
      <bits name="IREGION" pos="31:16"/>
      <bits name="DREGION" pos="15:8"/>
      <bits name="SEPARATE" pos="0"/>
    </reg>
    <reg name="CTRL" protect="rw">
      <bits name="PRIVDEFENA" pos="2"/>
      <bits name="HFNMIENA" pos="1"/>
      <bits name="ENABLE" pos="0"/>
    </reg>
    <reg name="RNR" protect="rw">
      <bits name="REGION" pos="7:0"/>
    </reg>
    <reg name="RBAR" protect="rw">
      <bits name="BASE" pos="31:5"/>
      <bits name="SH" pos="4:3"/>
      <bits name="AP" pos="2:1"/>
      <bits name="XN" pos="0"/>
    </reg>
    <reg name="RLAR" protect="rw">
      <bits name="LIMIT" pos="31:5"/>
      <bits name="AttrIndx" pos="3:1"/>
      <bits name="EN" pos="0"/>
    </reg>
    <reg name="RBAR_A1" protect="rw">
      <bits name="BASE" pos="31:5"/>
      <bits name="SH" pos="4:3"/>
      <bits name="AP" pos="2:1"/>
      <bits name="XN" pos="0"/>
    </reg>
    <reg name="RLAR_A1" protect="rw">
      <bits name="LIMIT" pos="31:5"/>
      <bits name="AttrIndx" pos="3:1"/>
      <bits name="EN" pos="0"/>
    </reg>
    <reg name="RBAR_A2" protect="rw">
      <bits name="BASE" pos="31:5"/>
      <bits name="SH" pos="4:3"/>
      <bits name="AP" pos="2:1"/>
      <bits name="XN" pos="0"/>
    </reg>
    <reg name="RLAR_A2" protect="rw">
      <bits name="LIMIT" pos="31:5"/>
      <bits name="AttrIndx" pos="3:1"/>
      <bits name="EN" pos="0"/>
    </reg>
    <reg name="RBAR_A3" protect="rw">
      <bits name="BASE" pos="31:5"/>
      <bits name="SH" pos="4:3"/>
      <bits name="AP" pos="2:1"/>
      <bits name="XN" pos="0"/>
    </reg>
    <reg name="RLAR_A3" protect="rw">
      <bits name="LIMIT" pos="31:5"/>
      <bits name="AttrIndx" pos="3:1"/>
      <bits name="EN" pos="0"/>
    </reg>
    <hole size="32"/>
    <reg name="MAIR0" protect="rw">
      <bits name="Attr3" pos="31:24"/>
      <bits name="Attr2" pos="23:16"/>
      <bits name="Attr1" pos="15:8"/>
      <bits name="Attr0" pos="7:0"/>
    </reg>
    <reg name="MAIR1" protect="rw">
      <bits name="Attr7" pos="31:24"/>
      <bits name="Attr6" pos="23:16"/>
      <bits name="Attr5" pos="15:8"/>
      <bits name="Attr4" pos="7:0"/>
    </reg>
  </module>
  <module name="SAU" category="StarCPU">
    <reg name="CTRL" protect="rw">
      <bits name="ALLNS" pos="1"/>
      <bits name="ENABLE" pos="0"/>
    </reg>
    <reg name="TYPE" protect="r">
      <bits name="SREGION" pos="7:0"/>
    </reg>
    <reg name="RNR" protect="rw">
      <bits name="REGION" pos="7:0"/>
    </reg>
    <reg name="RBAR" protect="rw">
      <bits name="BADDR" pos="31:5"/>
    </reg>
    <reg name="RLAR" protect="rw">
      <bits name="LADDR" pos="31:5"/>
      <bits name="NSC" pos="1"/>
      <bits name="ENABLE" pos="0"/>
    </reg>
    <reg name="SFSR" protect="rw">
      <bits name="LSERR" pos="7"/>
      <bits name="SFARVALID" pos="6"/>
      <bits name="LSPERR" pos="5"/>
      <bits name="INVTRAN" pos="4"/>
      <bits name="AUVIOL" pos="3"/>
      <bits name="INVER" pos="2"/>
      <bits name="INVIS" pos="1"/>
      <bits name="INVEP" pos="0"/>
    </reg>
    <reg name="SFAR" protect="rw">
    </reg>
  </module>
  <module name="FPU" category="StarCPU">
    <hole size="32"/>
    <reg name="FPCCR" protect="rw">
      <bits name="ASPEN" pos="31"/>
      <bits name="LSPEN" pos="30"/>
      <bits name="LSPENS" pos="29"/>
      <bits name="CLRONRET" pos="28"/>
      <bits name="CLRONRETS" pos="27"/>
      <bits name="TS" pos="26"/>
      <bits name="UFRDY" pos="10"/>
      <bits name="SPLIMVIOL" pos="9"/>
      <bits name="MONRDY" pos="8"/>
      <bits name="SFRDY" pos="7"/>
      <bits name="BFRDY" pos="6"/>
      <bits name="MMRDY" pos="5"/>
      <bits name="HFRDY" pos="4"/>
      <bits name="THREAD" pos="3"/>
      <bits name="S" pos="2"/>
      <bits name="USER" pos="1"/>
      <bits name="LSPACT" pos="0"/>
    </reg>
    <reg name="FPCAR" protect="rw">
      <bits name="ADDRESS" pos="31:3"/>
    </reg>
    <reg name="FPDSCR" protect="rw">
      <bits name="AHP" pos="26"/>
      <bits name="DN" pos="25"/>
      <bits name="FZ" pos="24"/>
      <bits name="RMode" pos="23:22"/>
    </reg>
    <reg name="MVFR0" protect="r">
      <bits name="FP_rounding_modes" pos="31:28"/>
      <bits name="Short_vectors" pos="27:24"/>
      <bits name="Square_root" pos="23:20"/>
      <bits name="Divide" pos="19:16"/>
      <bits name="FP_excep_trapping" pos="15:12"/>
      <bits name="Double_precision" pos="11:8"/>
      <bits name="Single_precision" pos="7:4"/>
      <bits name="A_SIMD_registers" pos="3:0"/>
    </reg>
    <reg name="MVFR1" protect="r">
      <bits name="FP_fused_MAC" pos="31:28"/>
      <bits name="FP_HPFP" pos="27:24"/>
      <bits name="D_NaN_mode" pos="7:4"/>
      <bits name="FtZ_mode" pos="3:0"/>
    </reg>
  </module>
</archive>
<archive relative="pmic_adc.xml">
  <module name="pmic_adc" category="Pmic">
    <reg protect="r" name="auxadc_version">
      <bits access="r" name="auxadc_version" pos="15:0" rst="1792">
        <comment>
          IP version r7p0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_cfg_ctrl">
      <bits access="r" name="adc_cfg_ctrl_reserved_0" pos="15:13" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="adc_offset_cal_en" pos="12" rst="0">
        <comment>
          Auxadc offset function enable&#10;0: disable offset function&#10;1: enable offset function
        </comment>
      </bits>
      <bits access="r" name="adc_cfg_ctrl_reserved_1" pos="11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rg_auxad_average" pos="10:8" rst="1">
        <comment>
          auxadc convert data out average control:&#10;000: disable adc average, output 12bit data and valid after once conversion;&#10;001: adc convert twice and output the average data;&#10;010: adc convert 4 times and output the average data;&#10;011: adc convert 8 times and output the average data;&#10;100: adc convert 16 times and output the average data;&#10;101: adc convert 32 times and output the average data;&#10;110: adc convert 64 times and output the average data;&#10;111: adc convert 128 times and output the average data;
        </comment>
      </bits>
      <bits access="rw" name="sw_ch_run_num" pos="7:4" rst="0">
        <comment>
          the number of SW channel accessing, N+1.
        </comment>
      </bits>
      <bits access="rw" name="adc_sign_code" pos="3" rst="0">
        <comment>
          AUXADC output code selection:&#10;0:  adc_dout = (data-Doff)&#10;1: if adc_offset_cal_en is 0&#10;adc_dout = data&#10;    if adc_offset_cal_en is 1&#10;adc_dout = data-(Doff-2047)&#10;more detail see Function Description&#10;
        </comment>
      </bits>
      <bits access="rw" name="adc_12b" pos="2" rst="1">
        <comment>
          ADC 12bits mode&#10;0: ADC in 10bits mode;&#10;1: ADC in 12bits mode.
        </comment>
      </bits>
      <bits access="rw" name="sw_ch_run" pos="1" rst="0">
        <comment>
          SW channel run,&#10;Write &apos;1&apos; to run a SW channel accessing, it is cleared by HW.
        </comment>
      </bits>
      <bits access="rw" name="adc_en" pos="0" rst="0">
        <comment>
          ADC global enable,&#10;0: ADC module disable;&#10;1: ADC module enable.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_sw_ch_cfg">
      <bits access="r" name="adc_sw_ch_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="adc_scale" pos="10:9" rst="0">
        <comment>
          ADC scale setting for current ADC channel
        </comment>
      </bits>
      <bits access="r" name="adc_sw_ch_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="adc_sw_ch_cfg_reserved_2" pos="7" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="adc_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_sw_ch_cfg_reserved_3" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="adc_cs" pos="4:0" rst="0">
        <comment>
          ADC software config channel ID.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch0_cfg">
      <bits access="r" name="adc_fast_hw_ch0_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_scale" pos="10:9" rst="0">
        <comment>
          ADC scale setting for current ADC channel
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch0_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="frq_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch0_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch1_cfg">
      <bits access="r" name="adc_fast_hw_ch1_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_scale" pos="10:9" rst="0">
        <comment>
          ADC scale setting for current ADC channel
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch1_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="frq_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch1_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch2_cfg">
      <bits access="r" name="adc_fast_hw_ch2_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_scale" pos="10:9" rst="0">
        <comment>
          ADC scale setting for current ADC channel
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch2_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="frq_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch2_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch3_cfg">
      <bits access="r" name="adc_fast_hw_ch3_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_scale" pos="10:9" rst="0">
        <comment>
          ADC scale setting for current ADC channel
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch3_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="frq_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch3_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch4_cfg">
      <bits access="r" name="adc_fast_hw_ch4_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_scale" pos="10:9" rst="0">
        <comment>
          ADC scale setting for current ADC channel
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch4_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="frq_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch4_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch5_cfg">
      <bits access="r" name="adc_fast_hw_ch5_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_scale" pos="10:9" rst="0">
        <comment>
          ADC scale setting for current ADC channel
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch5_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="frq_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch5_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch6_cfg">
      <bits access="r" name="adc_fast_hw_ch6_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_scale" pos="10:9" rst="0">
        <comment>
          ADC scale setting for current ADC channel
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch6_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="frq_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch6_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch7_cfg">
      <bits access="r" name="adc_fast_hw_ch7_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_scale" pos="10:9" rst="0">
        <comment>
          ADC scale setting for current ADC channel
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch7_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="frq_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_fast_hw_ch7_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="frq_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_slow_hw_ch0_cfg">
      <bits access="r" name="adc_slow_hw_ch0_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_scale" pos="10:9" rst="0">
        <comment>
          output the analog
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch0_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="req_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch0_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_slow_hw_ch1_cfg">
      <bits access="r" name="adc_slow_hw_ch1_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_scale" pos="10:9" rst="0">
        <comment>
          output the analog
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch1_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="req_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch1_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_slow_hw_ch2_cfg">
      <bits access="r" name="adc_slow_hw_ch2_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_scale" pos="10:9" rst="0">
        <comment>
          output the analog
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch2_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="req_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch2_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_slow_hw_ch3_cfg">
      <bits access="r" name="adc_slow_hw_ch3_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_scale" pos="10:9" rst="0">
        <comment>
          output the analog
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch3_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="req_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch3_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_slow_hw_ch4_cfg">
      <bits access="r" name="adc_slow_hw_ch4_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_scale" pos="10:9" rst="0">
        <comment>
          output the analog
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch4_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="req_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch4_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_slow_hw_ch5_cfg">
      <bits access="r" name="adc_slow_hw_ch5_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_scale" pos="10:9" rst="0">
        <comment>
          output the analog
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch5_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="req_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch5_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_slow_hw_ch6_cfg">
      <bits access="r" name="adc_slow_hw_ch6_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_scale" pos="10:9" rst="0">
        <comment>
          output the analog
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch6_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="req_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch6_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_slow_hw_ch7_cfg">
      <bits access="r" name="adc_slow_hw_ch7_cfg_reserved_0" pos="15:11" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_scale" pos="10:9" rst="0">
        <comment>
          output the analog
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch7_cfg_reserved_1" pos="8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_delay_en" pos="7" rst="0">
        <comment>
          current channel delay enable, 0-diable; 1-enable.
        </comment>
      </bits>
      <bits access="rw" name="req_slow" pos="6" rst="0">
        <comment>
          ADC conversion speed control:&#10;0: quick mode, conversion initial includes 50 ADC clocks;&#10;1: slow mode, conversion initial includes 70 ADC clocks.
        </comment>
      </bits>
      <bits access="r" name="adc_slow_hw_ch7_cfg_reserved_2" pos="5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="req_cs" pos="4:0" rst="0">
        <comment>
          ADC channel ID
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_hw_ch_delay">
      <bits access="r" name="adc_hw_ch_delay_reserved_0" pos="15:8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="hw_ch_delay" pos="7:0" rst="0">
        <comment>
          ADC HW channel accessing delay, its unit is ADC clock.&#10;It can be use for signal without enough setup time.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_dat">
      <bits access="r" name="adc_dat_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="r" name="adc_dat_sw" pos="11:0" rst="0">
        <comment>
          ADC conversion result.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_cfg_int_en">
      <bits access="r" name="adc_cfg_int_en_reserved_0" pos="15:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="adc_int_en" pos="0" rst="0">
        <comment>
          ADC interrupt enable, 0: disable; 1: enable.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_cfg_int_clr">
      <bits access="r" name="adc_cfg_int_clr_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="w" name="adc_int_clr" pos="0" rst="0">
        <comment>
          ADC interrupt clear. Write &quot;1&quot; to clear.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_cfg_int_status">
      <bits access="r" name="adc_cfg_int_status_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="r" name="adc_int_status" pos="0" rst="0">
        <comment>
          ADC masked interrupt.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_cfg_int_raw">
      <bits access="r" name="adc_cfg_int_raw_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="r" name="adc_int_raw" pos="0" rst="0">
        <comment>
          ADC raw interrupt.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_debug">
      <bits access="r" name="adc_dbg_ch" pos="15:11" rst="0">
        <comment>
          0~7: fast HW channels;&#10;8: SW channels;&#10;9~16: slow HW channel;&#10;31: no request.
        </comment>
      </bits>
      <bits access="r" name="adc_dbg_state" pos="10:8" rst="0">
        <comment>
          ADC accessing state:&#10;0: idle;&#10;1: fast HW request;&#10;2: SW request;&#10;3: slow HW request;&#10;4: wait for fast HW request;&#10;5: wait for slow HW request.
        </comment>
      </bits>
      <bits access="r" name="adc_dbg_cnt" pos="7:0" rst="0">
        <comment>
          ADC internal counter status, 0: idle; 1~n: work or wait counter.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_timer_en">
      <bits access="r" name="adc_fast_hw_timer_en_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="rg_adc_fast_hw_ch7_timer_en" pos="7" rst="0">
        <comment>
          ADC fast HW channel7 timer enable, 0:disable; 1: enable.
        </comment>
      </bits>
      <bits access="rw" name="rg_adc_fast_hw_ch6_timer_en" pos="6" rst="0">
        <comment>
          ADC fast HW channel6 timer enable, 0:disable; 1: enable.
        </comment>
      </bits>
      <bits access="rw" name="rg_adc_fast_hw_ch5_timer_en" pos="5" rst="0">
        <comment>
          ADC fast HW channel5 timer enable, 0:disable; 1: enable.
        </comment>
      </bits>
      <bits access="rw" name="rg_adc_fast_hw_ch4_timer_en" pos="4" rst="0">
        <comment>
          ADC fast HW channel4 timer enable, 0:disable; 1: enable.
        </comment>
      </bits>
      <bits access="rw" name="rg_adc_fast_hw_ch3_timer_en" pos="3" rst="0">
        <comment>
          ADC fast HW channel3 timer enable, 0:disable; 1: enable.
        </comment>
      </bits>
      <bits access="rw" name="rg_adc_fast_hw_ch2_timer_en" pos="2" rst="0">
        <comment>
          ADC fast HW channel2 timer enable, 0:disable; 1: enable.
        </comment>
      </bits>
      <bits access="rw" name="rg_adc_fast_hw_ch1_timer_en" pos="1" rst="0">
        <comment>
          ADC fast HW channel1 timer enable, 0:disable; 1: enable.
        </comment>
      </bits>
      <bits access="rw" name="rg_adc_fast_hw_ch0_timer_en" pos="0" rst="0">
        <comment>
          ADC fast HW channel0 timer enable, 0:disable; 1: enable.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_timer_div">
      <bits access="rw" name="rg_adc_fast_hw_timer_div" pos="15:0" rst="0">
        <comment>
          ADC fast HW channel timer working clock divider.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch0_timer_thresh">
      <bits access="rw" name="rg_adc_fast_hw_ch0_timer_thresh" pos="15:0" rst="0">
        <comment>
          ADC fast HW ch0 timer threshold.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch1_timer_thresh">
      <bits access="rw" name="rg_adc_fast_hw_ch1_timer_thresh" pos="15:0" rst="0">
        <comment>
          ADC fast HW ch1 timer threshold.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch2_timer_thresh">
      <bits access="rw" name="rg_adc_fast_hw_ch2_timer_thresh" pos="15:0" rst="0">
        <comment>
          ADC fast HW ch2 timer threshold.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch3_timer_thresh">
      <bits access="rw" name="rg_adc_fast_hw_ch3_timer_thresh" pos="15:0" rst="0">
        <comment>
          ADC fast HW ch3 timer threshold.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch4_timer_thresh">
      <bits access="rw" name="rg_adc_fast_hw_ch4_timer_thresh" pos="15:0" rst="0">
        <comment>
          ADC fast HW ch4 timer threshold.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch5_timer_thresh">
      <bits access="rw" name="rg_adc_fast_hw_ch5_timer_thresh" pos="15:0" rst="0">
        <comment>
          ADC fast HW ch5 timer threshold.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch6_timer_thresh">
      <bits access="rw" name="rg_adc_fast_hw_ch6_timer_thresh" pos="15:0" rst="0">
        <comment>
          ADC fast HW ch6 timer threshold.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adc_fast_hw_ch7_timer_thresh">
      <bits access="rw" name="rg_adc_fast_hw_ch7_timer_thresh" pos="15:0" rst="0">
        <comment>
          ADC fast HW ch7 timer threshold.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_fast_hw_ch0_dat">
      <bits access="r" name="adc_fast_hw_ch0_dat_reserved_0" pos="15:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch0_dat" pos="11:0" rst="0">
        <comment>
          ADC fast HW ch0 data, read twice, and capture the second value.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_fast_hw_ch1_dat">
      <bits access="r" name="adc_fast_hw_ch1_dat_reserved_0" pos="15:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch1_dat" pos="11:0" rst="0">
        <comment>
          ADC fast HW ch1 data, read twice, and capture the second value.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_fast_hw_ch2_dat">
      <bits access="r" name="adc_fast_hw_ch2_dat_reserved_0" pos="15:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch2_dat" pos="11:0" rst="0">
        <comment>
          ADC fast HW ch2 data, read twice, and capture the second value.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_fast_hw_ch3_dat">
      <bits access="r" name="adc_fast_hw_ch3_dat_reserved_0" pos="15:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch3_dat" pos="11:0" rst="0">
        <comment>
          ADC fast HW ch3 data, read twice, and capture the second value.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_fast_hw_ch4_dat">
      <bits access="r" name="adc_fast_hw_ch4_dat_reserved_0" pos="15:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch4_dat" pos="11:0" rst="0">
        <comment>
          ADC fast HW ch4 data, read twice, and capture the second value.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_fast_hw_ch5_dat">
      <bits access="r" name="adc_fast_hw_ch5_dat_reserved_0" pos="15:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch5_dat" pos="11:0" rst="0">
        <comment>
          ADC fast HW ch5 data, read twice, and capture the second value.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_fast_hw_ch6_dat">
      <bits access="r" name="adc_fast_hw_ch6_dat_reserved_0" pos="15:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch6_dat" pos="11:0" rst="0">
        <comment>
          ADC fast HW ch6 data, read twice, and capture the second value.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_fast_hw_ch7_dat">
      <bits access="r" name="adc_fast_hw_ch7_dat_reserved_0" pos="15:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch7_dat" pos="11:0" rst="0">
        <comment>
          ADC fast HW ch7 data, read twice, and capture the second value.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="auxadc_ctrl0">
      <bits access="r" name="auxadc_ctrl0_reserved_0" pos="15:6" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rg_auxad_ref_sel" pos="5" rst="0">
        <comment>
          output to analog
        </comment>
      </bits>
      <bits access="rw" name="rg_auxad_thm_cal" pos="4" rst="0">
        <comment>
          output to analog&#10;THM calibration enable signal,&#10;0: disable THM calibration(default)&#10;1: enable THM calibration, must set high 100us before AUXADC measure THM voltage and start the calibration
        </comment>
      </bits>
      <bits access="r" name="auxadc_ctrl0_reserved_1" pos="3:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rg_auxad_currentsen_en" pos="0" rst="0">
        <comment>
          output to analog&#10;Aux ADC current sense enable signal, active high, default 0.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="adc_fast_hw_dvalid">
      <bits access="r" name="adc_fast_hw_dvalid_reserved_0" pos="15:8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch7_dvld" pos="7" rst="0">
        <comment>
          ADC fast HW channel7 data valid.
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch6_dvld" pos="6" rst="0">
        <comment>
          ADC fast HW channel6 data valid.
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch5_dvld" pos="5" rst="0">
        <comment>
          ADC fast HW channel5 data valid.
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch4_dvld" pos="4" rst="0">
        <comment>
          ADC fast HW channel4 data valid.
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch3_dvld" pos="3" rst="0">
        <comment>
          ADC fast HW channel3 data valid.
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch2_dvld" pos="2" rst="0">
        <comment>
          ADC fast HW channel2 data valid.
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch1_dvld" pos="1" rst="0">
        <comment>
          ADC fast HW channel1 data valid.
        </comment>
      </bits>
      <bits access="r" name="rg_adc_fast_hw_ch0_dvld" pos="0" rst="0">
        <comment>
          ADC fast HW channel0 data valid.
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="pmic_pmuc.xml">
  <module name="pmic_pmuc" category="Pmic">
    <reg protect="rw" name="clock_select">
      <bits access="r" name="clock_select_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="rw" name="sel_rc32k_div" pos="5:4" rst="0">
        <comment>
          0:8k 1:4k 2:1k 3:16k
        </comment>
      </bits>
      <bits access="r" name="clock_select_reserved_1" pos="3" rst="0">
      </bits>
      <bits access="rw" name="sel_clk_wdt_src" pos="2:1" rst="0">
        <comment>
          0:8k 1:4k 2:2k 3:1k
        </comment>
      </bits>
      <bits access="rw" name="sel_32k_src" pos="0" rst="0">
        <comment>
          0: rc32k 1:xtal32k
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clock_32k_div_cfg">
      <bits access="r" name="clock_32k_div_cfg_reserved_0" pos="15:13" rst="0">
      </bits>
      <bits access="rw" name="wakeup_denom" pos="12:7" rst="1">
      </bits>
      <bits access="rw" name="denom" pos="6:1" rst="1">
      </bits>
      <bits access="rc" name="update" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ip_clk_disable_ctrl">
      <bits access="r" name="ip_clk_disable_ctrl_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="rw" name="iomux_clk_disable" pos="5" rst="0">
      </bits>
      <bits access="rw" name="gpio_clk_disable" pos="4" rst="0">
      </bits>
      <bits access="rw" name="gpt_clk_disable" pos="3" rst="0">
      </bits>
      <bits access="rw" name="timer_clk_disable" pos="2" rst="0">
      </bits>
      <bits access="rw" name="wdt_clk_disable" pos="1" rst="0">
      </bits>
      <bits access="rw" name="efs_clk_disable" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ip_soft_rst_ctrl">
      <bits access="r" name="ip_soft_rst_ctrl_reserved_0" pos="15:7" rst="0">
      </bits>
      <bits access="rw" name="pmuc_reg_soft_rst" pos="6" rst="1">
      </bits>
      <bits access="rw" name="iomux_soft_rst" pos="5" rst="1">
      </bits>
      <bits access="rw" name="gpio_soft_rst" pos="4" rst="1">
      </bits>
      <bits access="rw" name="gpt_soft_rst" pos="3" rst="1">
      </bits>
      <bits access="rw" name="timer_soft_rst" pos="2" rst="1">
      </bits>
      <bits access="rw" name="wdt_soft_rst" pos="1" rst="1">
      </bits>
      <bits access="rw" name="efs_soft_rst" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="wakeup_mask">
      <bits access="r" name="wakeup_mask_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="bypass_pin_rst" pos="11" rst="0">
      </bits>
      <bits access="rw" name="bypass_vbatlow_reset" pos="10" rst="0">
      </bits>
      <bits access="rw" name="bypass_uvlo_reset" pos="9" rst="1">
      </bits>
      <bits access="rw" name="bypass_ovlo_reset" pos="8" rst="1">
      </bits>
      <bits access="rw" name="bypass_otp_reset" pos="7" rst="1">
      </bits>
      <bits access="rw" name="bypass_wdt_reset" pos="6" rst="0">
      </bits>
      <bits access="rw" name="bypass_pwrkey_wakeup" pos="5" rst="0">
      </bits>
      <bits access="rw" name="bypass_chg_on_wakeup" pos="4" rst="0">
      </bits>
      <bits access="rw" name="bypass_gpio_wakeup" pos="3" rst="0">
      </bits>
      <bits access="rw" name="bypass_gpt_wakeup" pos="2" rst="0">
      </bits>
      <bits access="rw" name="bypass_timer_wakeup" pos="1" rst="0">
      </bits>
      <bits access="rw" name="bypass_wdt_wakeup" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="wakeup_clr">
      <bits access="r" name="wakeup_clr_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rc" name="wakeup_status_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          Write 1 to clear all wakeup status
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="wakeup_status">
      <bits access="r" name="wakeup_status_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="r" name="smpl_pwron_status" pos="8" rst="0">
      </bits>
      <bits access="r" name="pin_rst_pwron_status" pos="7" rst="0">
      </bits>
      <bits access="r" name="wdt_rst_pwron_status" pos="6" rst="0">
      </bits>
      <bits access="r" name="pwrkey_wakeup_status" pos="5" rst="0">
      </bits>
      <bits access="r" name="chg_on_wakeup_status" pos="4" rst="0">
      </bits>
      <bits access="r" name="gpio_wakeup_status" pos="3" rst="0">
      </bits>
      <bits access="r" name="gpt_wakeup_status" pos="2" rst="0">
      </bits>
      <bits access="r" name="timer_wakeup_status" pos="1" rst="0">
      </bits>
      <bits access="r" name="wdt_wakeup_status" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="int_clr">
      <bits access="r" name="int_clr_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rc" name="pwrkey_int_clr" pos="2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="chg_off_int_clr" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="chg_on_int_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="power_mode_ctrl_0">
      <bits access="r" name="power_mode_ctrl_0_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="vbat_det_delay_time" pos="14:7" rst="63">
        <comment>
          wait time after vbat_det on, default is 2ms
        </comment>
      </bits>
      <bits access="r" name="power_mode_ctrl_0_reserved_1" pos="6" rst="0">
      </bits>
      <bits access="rw" name="vcore_ret_wrap_val_sel" pos="5:2" rst="4">
        <comment>
          0:32,1:64,,7:4096,8:8192,9:16384,10:32768, default is 512
        </comment>
      </bits>
      <bits access="rw" name="pm_reg" pos="1:0" rst="3">
      </bits>
    </reg>
    <reg protect="rw" name="power_mode_ctrl_1">
      <bits access="rw" name="pm3_ldo_dcxo_mode" pos="15" rst="0">
      </bits>
      <bits access="rw" name="pm3_ldo_vio18_mode" pos="14" rst="0">
      </bits>
      <bits access="rw" name="pm3_ldo_vio33_mode" pos="13" rst="0">
      </bits>
      <bits access="rw" name="pm3_ldo_lp18_mode" pos="12" rst="0">
        <comment>
          0: pd, 1: lp
        </comment>
      </bits>
      <bits access="rw" name="pm2_ldo_dcxo_mode" pos="11" rst="0">
      </bits>
      <bits access="rw" name="pm2_ldo_vio18_mode" pos="10" rst="0">
      </bits>
      <bits access="rw" name="pm2_ldo_vio33_mode" pos="9" rst="0">
      </bits>
      <bits access="rw" name="pm2_ldo_lp18_mode" pos="8" rst="1">
        <comment>
          0: pd, 1: lp
        </comment>
      </bits>
      <bits access="rw" name="pm0_ldo_dcxo_mode" pos="7:6" rst="1">
      </bits>
      <bits access="rw" name="pm0_ldo_vio18_mode" pos="5:4" rst="1">
      </bits>
      <bits access="rw" name="pm0_ldo_vio33_mode" pos="3:2" rst="1">
      </bits>
      <bits access="rw" name="pm0_ldo_lp18_mode" pos="1:0" rst="1">
        <comment>
          00: pd 01: pu 11: lp
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="power_mode_ctrl_2">
      <bits access="r" name="power_mode_ctrl_2_reserved_0" pos="15:4" rst="0">
      </bits>
      <bits access="rw" name="pm3_vrf_mode" pos="3" rst="0">
      </bits>
      <bits access="rw" name="pm2_vrf_mode" pos="2" rst="0">
      </bits>
      <bits access="rw" name="pm0_vrf_mode" pos="1" rst="1">
      </bits>
      <bits access="rw" name="ldo_emm_mode" pos="0" rst="1">
        <comment>
          0: pd 1: pu
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="power_mode_status_0">
      <bits access="r" name="power_mode_status_0_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="r" name="pm03_sw_state" pos="14:10" rst="0">
      </bits>
      <bits access="r" name="pm02_sw_state" pos="9:5" rst="0">
      </bits>
      <bits access="r" name="first_pwron_state" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="power_mode_status_1">
      <bits access="r" name="power_mode_status_1_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="r" name="ldo_vio33_ulp_en" pos="14" rst="0">
      </bits>
      <bits access="r" name="ldo_vio33_pd" pos="13" rst="0">
      </bits>
      <bits access="r" name="ldo_vio18_lp_en" pos="12" rst="0">
      </bits>
      <bits access="r" name="ldo_vio18_pd" pos="11" rst="0">
      </bits>
      <bits access="r" name="ldo_lp18_ulp_en" pos="10" rst="0">
      </bits>
      <bits access="r" name="ldo_lp18_pd" pos="9" rst="0">
      </bits>
      <bits access="r" name="ext_resetb" pos="8" rst="0">
      </bits>
      <bits access="r" name="resetb_efs" pos="7" rst="0">
      </bits>
      <bits access="r" name="resetb_dig_top" pos="6" rst="0">
      </bits>
      <bits access="r" name="iso_aon" pos="5" rst="0">
      </bits>
      <bits access="r" name="pd_dig_top" pos="4" rst="0">
      </bits>
      <bits access="r" name="pu_done" pos="3" rst="0">
      </bits>
      <bits access="r" name="pm_state" pos="2:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="power_mode_status_2">
      <bits access="r" name="dvdd_iso" pos="15" rst="0">
      </bits>
      <bits access="r" name="psm_vref_pd" pos="14" rst="0">
      </bits>
      <bits access="r" name="ldo_dcxo_lp_en" pos="13" rst="0">
      </bits>
      <bits access="r" name="ldo_dcxo_pd" pos="12" rst="0">
      </bits>
      <bits access="r" name="ldo_vibr_lp_en" pos="11" rst="0">
      </bits>
      <bits access="r" name="ldo_emm_pd" pos="10" rst="0">
      </bits>
      <bits access="r" name="ldo_sim1_lp_en" pos="9" rst="0">
      </bits>
      <bits access="r" name="ldo_sim1_pd" pos="8" rst="0">
      </bits>
      <bits access="r" name="ldo_sim0_lp_en" pos="7" rst="0">
      </bits>
      <bits access="r" name="ldo_sim0_pd" pos="6" rst="0">
      </bits>
      <bits access="r" name="vcore_ulp_en" pos="5" rst="0">
      </bits>
      <bits access="r" name="vcore_pd" pos="4" rst="0">
      </bits>
      <bits access="r" name="vrf_pd" pos="3" rst="0">
      </bits>
      <bits access="r" name="power_det_en" pos="2" rst="0">
      </bits>
      <bits access="r" name="osc3m_en" pos="1" rst="0">
      </bits>
      <bits access="r" name="bg_pd" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="direct_ctrl_0">
      <bits access="rw" name="ldo_sim1_lp_en" pos="15" rst="0">
      </bits>
      <bits access="rw" name="ldo_sim1_dr" pos="14" rst="0">
      </bits>
      <bits access="rw" name="ldo_sim0_lp_en" pos="13" rst="0">
      </bits>
      <bits access="rw" name="ldo_sim0_dr" pos="12" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio33_ulp_en" pos="11" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio33_pd" pos="10" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio33_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio18_pd" pos="8" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio18_lp_en" pos="7" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio18_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="ldo_dcxo_pd" pos="5" rst="0">
      </bits>
      <bits access="rw" name="ldo_dcxo_lp_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="ldo_dcxo_dr" pos="3" rst="0">
      </bits>
      <bits access="rw" name="ldo_lp18_ulp_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="ldo_lp18_pd" pos="1" rst="1">
      </bits>
      <bits access="rw" name="ldo_lp18_dr" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="direct_ctrl_1">
      <bits access="r" name="direct_ctrl_1_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rc" name="soft_efs_read_start" pos="13" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="ldo_vibr_lp_en" pos="12" rst="0">
      </bits>
      <bits access="rw" name="ldo_vibr_dr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="vrf_pd" pos="10" rst="1">
      </bits>
      <bits access="rw" name="vrf_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="vcore_ulp_en" pos="8" rst="0">
      </bits>
      <bits access="rw" name="vcore_pd" pos="7" rst="0">
      </bits>
      <bits access="rw" name="vcore_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="bg_pd" pos="5" rst="1">
      </bits>
      <bits access="rw" name="bg_pd_dr" pos="4" rst="0">
      </bits>
      <bits access="rw" name="power_det_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="power_det_en_dr" pos="2" rst="0">
      </bits>
      <bits access="rw" name="osc3m_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="osc3m_en_dr" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="direct_ctrl_2">
      <bits access="r" name="direct_ctrl_2_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="psm_vref_pd" pos="13" rst="0">
      </bits>
      <bits access="rw" name="psm_vref_pd_dr" pos="12" rst="0">
      </bits>
      <bits access="rw" name="dvdd_iso" pos="11" rst="1">
      </bits>
      <bits access="rw" name="dvdd_iso_dr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="ext_resetb" pos="9" rst="1">
      </bits>
      <bits access="rw" name="ext_resetb_dr" pos="8" rst="0">
      </bits>
      <bits access="rw" name="resetb_efs" pos="7" rst="1">
      </bits>
      <bits access="rw" name="resetb_efs_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="resetb_dig_top" pos="5" rst="1">
      </bits>
      <bits access="rw" name="resetb_dig_top_dr" pos="4" rst="0">
      </bits>
      <bits access="rw" name="iso_aon" pos="3" rst="1">
      </bits>
      <bits access="rw" name="iso_aon_dr" pos="2" rst="0">
      </bits>
      <bits access="rw" name="pd_dig_top" pos="1" rst="1">
      </bits>
      <bits access="rw" name="pd_dig_top_dr" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="vcore_vosel_ctrl_0">
      <bits access="r" name="vcore_vosel_ctrl_0_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="step_number" pos="14:10" rst="6">
      </bits>
      <bits access="rw" name="dest_vcore_vosel" pos="9:1" rst="288">
      </bits>
      <bits access="rc" name="soft_vosel_load" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="vcore_vosel_ctrl_1">
      <bits access="r" name="vcore_vosel_ctrl_1_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rc" name="soft_start_pulse" pos="14" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="volt_up" pos="13" rst="0">
      </bits>
      <bits access="rw" name="step_value" pos="12:4" rst="16">
      </bits>
      <bits access="rw" name="step_interval" pos="3:0" rst="1">
      </bits>
    </reg>
    <reg protect="r" name="efs_rd_data_0">
      <bits access="r" name="emm_pro" pos="15" rst="0">
      </bits>
      <bits access="r" name="vio33_ulp_trim" pos="14:10" rst="0">
      </bits>
      <bits access="r" name="ldo_vext_reftrim" pos="9:5" rst="0">
      </bits>
      <bits access="r" name="ldo_vbat_reftrim" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efs_rd_data_1">
      <bits access="r" name="efs_rd_data_1_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="r" name="lp18_ulp_trim" pos="14:10" rst="0">
      </bits>
      <bits access="r" name="dcdc_osc3m_freq" pos="9:5" rst="0">
      </bits>
      <bits access="r" name="rtcbg_trim" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efs_rd_data_2">
      <bits access="r" name="efs_rd_data_2_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="r" name="vpa_votrim" pos="14:10" rst="0">
      </bits>
      <bits access="r" name="vrf_votrim" pos="9:5" rst="0">
      </bits>
      <bits access="r" name="vcore_votrim" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efs_rd_data_3">
      <bits access="r" name="efs_rd_data_3_reserved_0" pos="15:5" rst="0">
      </bits>
      <bits access="r" name="vcore_votrim_lp" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="trim_ctrl_0">
      <bits access="rw" name="trim_dr_ctrl" pos="15" rst="0">
      </bits>
      <bits access="rw" name="vio33_ulp_trim" pos="14:10" rst="16">
      </bits>
      <bits access="rw" name="ldo_vext_reftrim" pos="9:5" rst="16">
      </bits>
      <bits access="rw" name="ldo_vbat_reftrim" pos="4:0" rst="16">
      </bits>
    </reg>
    <reg protect="rw" name="trim_ctrl_1">
      <bits access="r" name="trim_ctrl_1_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="lp18_ulp_trim" pos="14:10" rst="16">
      </bits>
      <bits access="rw" name="dcdc_osc3m_freq" pos="9:5" rst="16">
      </bits>
      <bits access="rw" name="rtcbg_trim" pos="4:0" rst="16">
      </bits>
    </reg>
    <reg protect="rw" name="trim_ctrl_2">
      <bits access="r" name="trim_ctrl_2_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="vpa_votrim" pos="14:10" rst="16">
      </bits>
      <bits access="rw" name="vrf_votrim" pos="9:5" rst="16">
      </bits>
      <bits access="rw" name="vcore_votrim" pos="4:0" rst="16">
      </bits>
    </reg>
    <reg protect="rw" name="trim_ctrl_3">
      <bits access="r" name="trim_ctrl_3_reserved_0" pos="15:5" rst="0">
      </bits>
      <bits access="rw" name="vcore_votrim_lp" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ana_clk32k_ctrl">
      <bits access="r" name="ana_clk32k_ctrl_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="xtal32k_pu" pos="7" rst="1">
      </bits>
      <bits access="rw" name="xtal32k_coarse" pos="6:4" rst="4">
      </bits>
      <bits access="rw" name="xtal32k_fine" pos="3:1" rst="5">
      </bits>
      <bits access="rw" name="rc32k_pu" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="ana_rtc_ctrl_0">
      <bits access="r" name="ana_rtc_ctrl_0_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="rw" name="rtc_vosel" pos="5:3" rst="4">
      </bits>
      <bits access="rw" name="vbatbk_vosel" pos="2:0" rst="4">
      </bits>
    </reg>
    <reg protect="rw" name="ana_rtc_ctrl_1">
      <bits access="rw" name="rtc_rsvd1" pos="15:8" rst="240">
      </bits>
      <bits access="rw" name="rtc_rsvd0" pos="7:0" rst="240">
      </bits>
    </reg>
    <reg protect="rw" name="ana_powerdet_ctrl">
      <bits access="r" name="ana_powerdet_ctrl_reserved_0" pos="15:13" rst="0">
      </bits>
      <bits access="rw" name="uvlo_en" pos="12" rst="0">
      </bits>
      <bits access="rw" name="vbatlow_en" pos="11" rst="0">
      </bits>
      <bits access="rw" name="ovlo_en" pos="10" rst="1">
      </bits>
      <bits access="rw" name="ovlo_t" pos="9:8" rst="0">
      </bits>
      <bits access="rw" name="ovlo_v" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="uvlo_v" pos="5:4" rst="0">
      </bits>
      <bits access="rw" name="vbat_crash_v" pos="3:2" rst="0">
      </bits>
      <bits access="rw" name="buadet_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pbint_pullh_enb" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ana_ldo_vbat_ctrl_0">
      <bits access="rw" name="ldo_lp18_ulp_ifb_en" pos="15" rst="0">
      </bits>
      <bits access="rw" name="ldo_lp18_ulp_itrim" pos="14:13" rst="0">
      </bits>
      <bits access="rw" name="ldo_dcxo_vosel" pos="12:7" rst="7">
      </bits>
      <bits access="rw" name="ldo_lp18_lp_en" pos="6" rst="0">
      </bits>
      <bits access="rw" name="ldo_lp18_vosel" pos="5:0" rst="7">
      </bits>
    </reg>
    <reg protect="rw" name="ana_ldo_vbat_ctrl_1">
      <bits access="r" name="ana_ldo_vbat_ctrl_1_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio18_vosel" pos="5:0" rst="7">
      </bits>
    </reg>
    <reg protect="rw" name="ana_ldo_vext_ctrl_0">
      <bits access="r" name="ana_ldo_vext_ctrl_0_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio33_ulp_ifb_en" pos="14" rst="0">
      </bits>
      <bits access="rw" name="ldo_sim0_pd" pos="13" rst="1">
      </bits>
      <bits access="rw" name="ldo_sim0_vosel" pos="12:7" rst="7">
      </bits>
      <bits access="rw" name="ldo_sim1_pd" pos="6" rst="1">
      </bits>
      <bits access="rw" name="ldo_sim1_vosel" pos="5:0" rst="7">
      </bits>
    </reg>
    <reg protect="rw" name="ana_ldo_vext_ctrl_1">
      <bits access="rw" name="ldo_vio33_ulp_itrim" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio33_lp_en" pos="13" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio33_vosel" pos="12:7" rst="43">
      </bits>
      <bits access="rw" name="ldo_vibr_pd" pos="6" rst="1">
      </bits>
      <bits access="rw" name="ldo_vibr_vosel" pos="5:0" rst="47">
      </bits>
    </reg>
    <reg protect="rw" name="ana_dcdc_ctrl_0">
      <bits access="r" name="ana_dcdc_ctrl_0_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="rw" name="vrf_vosel" pos="10:2" rst="384">
      </bits>
      <bits access="rw" name="vrf_lp_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="vcore_lp_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ana_dcdc_ctrl_1">
      <bits access="r" name="ana_dcdc_ctrl_1_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="r" name="vcore_vosel" pos="8:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="chgr_ctrl">
      <bits access="r" name="chgr_ctrl_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="r" name="chgr_int" pos="1" rst="0">
      </bits>
      <bits access="rw" name="chgr_pd" pos="0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="boundary_test_ctrl">
      <bits access="r" name="boundary_test_ctrl_reserved_0" pos="15:7" rst="0">
      </bits>
      <bits access="rw" name="psm_indicator_enable" pos="6" rst="0">
      </bits>
      <bits access="r" name="clk_26m" pos="5" rst="0">
      </bits>
      <bits access="r" name="chip_sleep" pos="4" rst="0">
      </bits>
      <bits access="rw" name="bua_det" pos="3" rst="0">
      </bits>
      <bits access="rw" name="pmic_int" pos="2" rst="0">
      </bits>
      <bits access="rw" name="clk_32k_ext" pos="1" rst="0">
      </bits>
      <bits access="rw" name="enable" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="timer_clk_div_cfg">
      <bits access="r" name="timer_clk_div_cfg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="sel_timer_32k_src" pos="7" rst="0">
      </bits>
      <bits access="rw" name="denom" pos="6:1" rst="4">
      </bits>
      <bits access="rc" name="update" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pad_ctrl_0">
      <bits access="rw" name="sleep_wpu" pos="15" rst="0">
      </bits>
      <bits access="rw" name="sleep_wpd" pos="14" rst="0">
      </bits>
      <bits access="rw" name="clk_26m_wpu" pos="13" rst="0">
      </bits>
      <bits access="rw" name="clk_26m_wpd" pos="12" rst="0">
      </bits>
      <bits access="rw" name="pmic_int_wpu" pos="11" rst="0">
      </bits>
      <bits access="rw" name="pmic_int_wpd" pos="10" rst="0">
      </bits>
      <bits access="rw" name="bua_det_wpu" pos="9" rst="0">
      </bits>
      <bits access="rw" name="bua_det_wpd" pos="8" rst="0">
      </bits>
      <bits access="rw" name="resetb_ext_wpu" pos="7" rst="0">
      </bits>
      <bits access="rw" name="resetb_ext_wpd" pos="6" rst="0">
      </bits>
      <bits access="rw" name="clk_32k_wpu" pos="5" rst="0">
      </bits>
      <bits access="rw" name="clk_32k_wpd" pos="4" rst="0">
      </bits>
      <bits access="rw" name="adi_sck_wpu" pos="3" rst="0">
      </bits>
      <bits access="rw" name="adi_sck_wpd" pos="2" rst="0">
      </bits>
      <bits access="rw" name="adi_d_wpu" pos="1" rst="0">
      </bits>
      <bits access="rw" name="adi_d_wpd" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pad_ctrl_1">
      <bits access="r" name="pad_ctrl_1_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="gpio_ie" pos="9:2" rst="255">
      </bits>
      <bits access="rw" name="ibit_die_if" pos="1:0" rst="2">
      </bits>
    </reg>
    <reg protect="rw" name="pad_ctrl_2">
      <bits access="rw" name="ibit_gpio1" pos="15:8" rst="255">
      </bits>
      <bits access="rw" name="ibit_gpio0" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pwrkey_dbnc_time_cfg">
      <bits access="r" name="pwrkey_dbnc_time_cfg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="pwrkey_dbnc_time" pos="13:0" rst="4095">
        <comment>
          default is 500ms
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pin_rst_dbnc_time_cfg">
      <bits access="r" name="pin_rst_dbnc_time_cfg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="pin_rst_dbnc_time" pos="13:0" rst="8191">
        <comment>
          default is 1s
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="chgr_int_dbnc_time_cfg">
      <bits access="r" name="chgr_int_dbnc_time_cfg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="chgr_int_dbnc_time" pos="13:0" rst="4095">
        <comment>
          default is 500ms
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="otp_dbnc_time_cfg">
      <bits access="r" name="otp_dbnc_time_cfg_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="otp_dbnc_time" pos="11:0" rst="819">
        <comment>
          default is 100ms
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ovlo_dbnc_time_cfg">
      <bits access="r" name="ovlo_dbnc_time_cfg_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="ovlo_dbnc_time" pos="11:0" rst="819">
        <comment>
          default is 100ms
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="uvlo_dbnc_time_cfg">
      <bits access="r" name="uvlo_dbnc_time_cfg_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="uvlo_dbnc_time" pos="11:0" rst="1638">
        <comment>
          default is 200ms
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="smpl_cfg">
      <bits access="r" name="smpl_cfg_reserved_0" pos="15:13" rst="0">
      </bits>
      <bits access="rw" name="smpl_threshold" pos="12:1" rst="82">
        <comment>
          default is 10ms
        </comment>
      </bits>
      <bits access="rw" name="smpl_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="abnormal_occur_status">
      <bits access="r" name="abnormal_occur_status_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="r" name="pin_rst" pos="5" rst="0">
      </bits>
      <bits access="r" name="wdt_rst" pos="4" rst="0">
      </bits>
      <bits access="r" name="otp" pos="3" rst="0">
      </bits>
      <bits access="r" name="ovlo" pos="2" rst="0">
      </bits>
      <bits access="r" name="uvlo" pos="1" rst="0">
      </bits>
      <bits access="r" name="vbatlow" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="abnormal_occur_clr">
      <bits access="r" name="abnormal_occur_clr_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rc" name="abnormal_status_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          Write 1 to clear all abnormal status
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="bonding_option">
      <bits access="r" name="bonding_option_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="r" name="powerkey" pos="1" rst="0">
      </bits>
      <bits access="r" name="bond_opt" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_reg_0">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_reg_1">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_reg_2">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_reg_3">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_reg_4">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_reg_5">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_reg_6">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_reg_7">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="vcore_vosel_ctrl_2">
      <bits access="r" name="vcore_vosel_ctrl_2_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="wakeup_step_number" pos="8:4" rst="6">
      </bits>
      <bits access="rw" name="wakeup_step_interval" pos="3:0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="vcore_vosel_ctrl_3">
      <bits access="r" name="vcore_vosel_ctrl_3_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="wakeup_step_value" pos="8:0" rst="16">
      </bits>
    </reg>
    <reg protect="rw" name="abnormal_rst_time_cfg">
      <bits access="r" name="abnormal_rst_time_cfg_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="rw" name="reset_extend_time" pos="10:0" rst="409">
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_ports">
      <bits access="r" name="rsvd_ports_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="r" name="rsvd_ports_in" pos="7:4" rst="0">
      </bits>
      <bits access="rw" name="rsvd_ports_out" pos="3:0" rst="3">
      </bits>
    </reg>
  </module>
</archive>
<archive relative="pmic_apb_efs.xml">
  <module name="pmic_apb_efs" category="Pmic">
    <reg protect="rw" name="efuse_glb_ctrl">
      <bits access="r" name="efuse_glb_ctrl_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rw" name="efuse_type" pos="2:1" rst="0">
        <comment>
          Efuse type select, 00:TSMC default
        </comment>
      </bits>
      <bits access="rw" name="efuse_pgm_en" pos="0" rst="0">
        <comment>
          Efuse SW programme enable
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="efuse_data_rd">
      <bits access="r" name="efuse_data_rd" pos="15:0" rst="0">
        <comment>
          Efuse read data,&#10;If SW  use efuse controller to send a read command to efuse memory, the return value will store here.&#10; 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="efuse_data_wr">
      <bits access="rw" name="efuse_data_wr" pos="15:0" rst="0">
        <comment>
          Efuse data to be write.&#10;If SW want to program the efuse memory, the data to be programmed  will write to this register before SW issue a PGM command. 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="efuse_addr_index">
      <bits access="r" name="efuse_addr_index_reserved_0" pos="15:5" rst="0">
      </bits>
      <bits access="rw" name="read_write_index" pos="4:0" rst="0">
        <comment>
          The efuse memory block index to be read or write.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="efuse_mode_ctrl">
      <bits access="r" name="efuse_mode_ctrl_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rc" name="efuse_normal_rd_flag_clr" pos="2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          Write 1 to this bit will clear normal read flag.This bit is self-clear, read this bit will always get 0 
        </comment>
      </bits>
      <bits access="rc" name="efuse_rd_start" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          Write 1 to this bit start READ mode(read mode).This bit is self-clear, read this bit will always get 0 
        </comment>
      </bits>
      <bits access="rc" name="efuse_pg_start" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          Write 1 to this bit start PGM mode(PGM mode). This bit is self-clear, read this bit will always get 0
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="efuse_status">
      <bits access="r" name="efuse_status_reserved_0" pos="15:5" rst="0">
      </bits>
      <bits access="r" name="efuse_normal_rd_done" pos="4" rst="0">
        <comment>
          1 indicate EFUSE normal read has been done
        </comment>
      </bits>
      <bits access="r" name="efuse_global_prot" pos="3" rst="0">
        <comment>
          If SW send a PGM command to memory and memory controller find the memory need to be protected (LSB of 64 bit is 1), this flag will be set to 1.
        </comment>
      </bits>
      <bits access="r" name="efuse_idle" pos="2" rst="0">
        <comment>
          1 indicate efuse memory in standby mode
        </comment>
      </bits>
      <bits access="r" name="read_busy" pos="1" rst="0">
        <comment>
          1 indicate efuse memory in read mode
        </comment>
      </bits>
      <bits access="r" name="pgm_busy" pos="0" rst="0">
        <comment>
          1 indicate efuse memory in programming mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="efuse_magic_number">
      <bits access="rw" name="efuse_magic_number" pos="15:0" rst="0">
        <comment>
          Magic number, only when this field is  0x1811, the Efuse programming command can be handle.&#10;So if SW want to program efuse memory, except open clocks and power, 2 other  conditions must be met :&#10;a) PGM_EN =1;&#10;b) EFUSE_MAGIC_NUMBER = 0x1811&#10;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="efuse_margin_magic_number">
      <bits access="rw" name="efuse_margin_magic_number" pos="15:0" rst="0">
        <comment>
          Magic number, only when this field is  0x6688,  the margin read is usable.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="efuse_wr_timing_ctrl">
      <bits access="rw" name="efuse_wr_timing_ctrl" pos="15:0" rst="24595">
        <comment>
          Config this register to control the timing of writing operation related signals
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="efuse_rd_timing_ctrl">
      <bits access="rw" name="efuse_rd_timing_ctrl" pos="15:0" rst="62">
        <comment>
          Config this register to control the timing of writing operation related signals
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="efuse_version">
      <bits access="rw" name="efuse_version" pos="15:0" rst="256">
        <comment>
          Efuse control version register 
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="pmic_dig.xml">
  <module name="pmic_dig" category="Pmic">
    <reg protect="r" name="chip_id_low">
      <bits access="r" name="chip_id_l" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="chip_id_high">
      <bits access="r" name="chip_id_h" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ip_clk_disable">
      <bits access="r" name="ip_clk_disable_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="adc" pos="1" rst="0">
      </bits>
      <bits access="rw" name="efs" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ip_soft_rst">
      <bits access="r" name="ip_soft_rst_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rw" name="adc" pos="2" rst="1">
      </bits>
      <bits access="rw" name="efs" pos="1" rst="1">
      </bits>
      <bits access="rw" name="dig_reg" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="clk_adc_div_cfg">
      <bits access="r" name="clk_adc_div_cfg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="clk_adc_div_num" pos="9:7" rst="1">
      </bits>
      <bits access="rw" name="clk_adc_div_denom" pos="6:1" rst="1">
      </bits>
      <bits access="rc" name="clk_adc_div_update" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_vcore_cfg">
      <bits access="r" name="clk_vcore_cfg_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="rc" name="update" pos="10" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="dither_en" pos="9" rst="0">
      </bits>
      <bits access="rw" name="dither_sel" pos="8:6" rst="0">
      </bits>
      <bits access="rw" name="phase" pos="5:2" rst="0">
      </bits>
      <bits access="rw" name="pol" pos="1" rst="0">
      </bits>
      <bits access="rw" name="en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="clk_vrf_cfg">
      <bits access="r" name="clk_vrf_cfg_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="rc" name="update" pos="10" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="dither_en" pos="9" rst="0">
      </bits>
      <bits access="rw" name="dither_sel" pos="8:6" rst="0">
      </bits>
      <bits access="rw" name="phase" pos="5:2" rst="0">
      </bits>
      <bits access="rw" name="pol" pos="1" rst="0">
      </bits>
      <bits access="rw" name="en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="clk_vpa_cfg">
      <bits access="r" name="clk_vpa_cfg_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="rc" name="update" pos="10" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="dither_en" pos="9" rst="0">
      </bits>
      <bits access="rw" name="dither_sel" pos="8:6" rst="0">
      </bits>
      <bits access="rw" name="phase" pos="5:2" rst="0">
      </bits>
      <bits access="rw" name="pol" pos="1" rst="0">
      </bits>
      <bits access="rw" name="en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="sim_bua_prot_cfg">
      <bits access="r" name="sim_bua_prot_cfg_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="pd_delay_time" pos="8:1" rst="255">
      </bits>
      <bits access="rw" name="enable" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ana_rtc_ctrl">
      <bits access="rw" name="rtc_rsvd1" pos="15:8" rst="240">
      </bits>
      <bits access="rw" name="rtc_rsvd0" pos="7:0" rst="240">
      </bits>
    </reg>
    <reg protect="rw" name="ana_bg_ctrl">
      <bits access="r" name="ana_bg_ctrl_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="rw" name="batdet_cur_en" pos="10" rst="0">
        <comment>
          AUXADC current mode enable&#10;1&apos;b0: default, off&#10;1&apos;b1: current mode on
        </comment>
      </bits>
      <bits access="rw" name="batdet_cur_sel" pos="9:7" rst="0">
        <comment>
          AUXADC current step select
        </comment>
      </bits>
      <bits access="rw" name="ib_trim" pos="6:0" rst="64">
        <comment>
          AUXADC current calibration
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ana_thm_otp_ctrl">
      <bits access="r" name="ana_thm_otp_ctrl_reserved_0" pos="15:4" rst="0">
      </bits>
      <bits access="rw" name="otp_op" pos="3:1" rst="3">
        <comment>
          OTP threshold&#10;3&apos;b011: 135C, default
        </comment>
      </bits>
      <bits access="rw" name="otp_en" pos="0" rst="0">
        <comment>
          OTP function enable control bit
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ana_ldo_vbat_ctrl_0">
      <bits access="rw" name="ldo_lp18_cl_adj" pos="15:13" rst="3">
        <comment>
          LDO_LP18 current limit threshold adjust                                         default 1&apos;b011                                                                             111~000 380mA~240mA 20mA/step
        </comment>
      </bits>
      <bits access="rw" name="ldo_lp18_shpt_en" pos="12" rst="1">
        <comment>
          LDO_LP18 short protect EN:&#10;0 is disable&#10;1 is enable(default)
        </comment>
      </bits>
      <bits access="rw" name="ldo_lp18_shpt_adj" pos="11" rst="1">
        <comment>
          LDO_LP18 short protect current threshold adjust                                         default 1&apos;b1
        </comment>
      </bits>
      <bits access="rw" name="ldo_lp18_stb" pos="10:9" rst="0">
        <comment>
          LDO_LP18 compensation capacitor and resistor adjust
        </comment>
      </bits>
      <bits access="rw" name="ldo_lp18_discharge_en" pos="8" rst="1">
        <comment>
          LDO_LP18 discharge en
        </comment>
      </bits>
      <bits access="rw" name="ldo_dcxo_cl_adj" pos="7:5" rst="3">
      </bits>
      <bits access="rw" name="ldo_dcxo_shpt_en" pos="4" rst="1">
      </bits>
      <bits access="rw" name="ldo_dcxo_shpt_adj" pos="3" rst="1">
      </bits>
      <bits access="rw" name="ldo_dcxo_stb" pos="2:1" rst="0">
      </bits>
      <bits access="rw" name="ldo_dcxo_discharge_en" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="ana_ldo_vbat_ctrl_1">
      <bits access="r" name="ana_ldo_vbat_ctrl_1_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio18_cl_adj" pos="7:5" rst="3">
      </bits>
      <bits access="rw" name="ldo_vio18_shpt_en" pos="4" rst="1">
      </bits>
      <bits access="rw" name="ldo_vio18_shpt_adj" pos="3" rst="1">
      </bits>
      <bits access="rw" name="ldo_vio18_stb" pos="2:1" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio18_discharge_en" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="ana_ldo_vext_ctrl_0">
      <bits access="rw" name="ldo_sim0_cl_adj" pos="15:13" rst="3">
      </bits>
      <bits access="rw" name="ldo_sim0_shpt_en" pos="12" rst="1">
      </bits>
      <bits access="rw" name="ldo_sim0_shpt_adj" pos="11" rst="1">
      </bits>
      <bits access="rw" name="ldo_sim0_stb" pos="10:9" rst="0">
      </bits>
      <bits access="rw" name="ldo_sim0_discharge_en" pos="8" rst="1">
      </bits>
      <bits access="rw" name="ldo_sim1_cl_adj" pos="7:5" rst="3">
      </bits>
      <bits access="rw" name="ldo_sim1_shpt_en" pos="4" rst="1">
      </bits>
      <bits access="rw" name="ldo_sim1_shpt_adj" pos="3" rst="1">
      </bits>
      <bits access="rw" name="ldo_sim1_stb" pos="2:1" rst="0">
      </bits>
      <bits access="rw" name="ldo_sim1_discharge_en" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="ana_ldo_vext_ctrl_1">
      <bits access="rw" name="ldo_vio33_cl_adj" pos="15:13" rst="3">
      </bits>
      <bits access="rw" name="ldo_vio33_shpt_en" pos="12" rst="1">
      </bits>
      <bits access="rw" name="ldo_vio33_shpt_adj" pos="11" rst="1">
      </bits>
      <bits access="rw" name="ldo_vio33_stb" pos="10:9" rst="0">
      </bits>
      <bits access="rw" name="ldo_vio33_discharge_en" pos="8" rst="1">
      </bits>
      <bits access="rw" name="ldo_vibr_cl_adj" pos="7:5" rst="3">
      </bits>
      <bits access="rw" name="ldo_vibr_shpt_en" pos="4" rst="1">
      </bits>
      <bits access="rw" name="ldo_vibr_shpt_adj" pos="3" rst="1">
      </bits>
      <bits access="rw" name="ldo_vibr_stb" pos="2:1" rst="0">
      </bits>
      <bits access="rw" name="ldo_vibr_discharge_en" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="ana_dcdc_ctrl_0">
      <bits access="r" name="ana_dcdc_ctrl_0_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="dcdc_clkout_sel" pos="14:12" rst="0">
        <comment>
          clock selection for each channel&#10;RG_CLKOUT_SEL[0]:  VCORE clk selection&#10;RG_CLKOUT_SEL[1]:  VRF clk selection&#10;RG_CLKOUT_SEL[2]:  VPA clk selection&#10;0: internal mode, default&#10;1: external mode
        </comment>
      </bits>
      <bits access="rw" name="dcdc_clkout_uniphase" pos="11" rst="0">
        <comment>
          phase shift option&#10;1&apos;b0: default, w/i 1/5 phase shift at internal mode&#10;1&apos;b1: uni-phase mode, all ouputs = channel 0
        </comment>
      </bits>
      <bits access="rw" name="dcdc_clk3m_test_en" pos="10" rst="0">
        <comment>
          test mode control.&#10;0: default, clock output off&#10;0: default, clock output on
        </comment>
      </bits>
      <bits access="rw" name="vcore_antiring_en" pos="9" rst="0">
        <comment>
          anti-ring enable&#10;1&apos;b0: default, anti-ring off&#10;1&apos;b1: anti-ring on
        </comment>
      </bits>
      <bits access="rw" name="vcore_curlimit_r" pos="8:7" rst="0">
        <comment>
          current limit threshold tuning&#10;2&apos;b00: default&#10;2&apos;b01: -20%&#10;2&apos;b10: +40%&#10;2&apos;b11: +20%
        </comment>
      </bits>
      <bits access="rw" name="vcore_curses_r" pos="6:5" rst="0">
        <comment>
          current sense R ratio tuning&#10;current sense multiplier tuning&#10;2&apos;b00: default, x1&#10;2&apos;b01: -20%&#10;2&apos;b10: +40%&#10;2&apos;b11: +20%
        </comment>
      </bits>
      <bits access="rw" name="vcore_force_pwm" pos="4" rst="0">
        <comment>
          force PWM mode&#10;1&apos;b0: default, PFM/PWM auto mode&#10;1&apos;b1: force PWM mode
        </comment>
      </bits>
      <bits access="rw" name="vcore_pfm_vh" pos="3:2" rst="0">
        <comment>
          PFM mode threshold for upper limit&#10;2&apos;b00: default, 0.6V&#10;2&apos;b01: 0.55V&#10;2&apos;b10: 0.65V&#10;2&apos;b11: 0.7V
        </comment>
      </bits>
      <bits access="rw" name="vcore_rcomp" pos="1:0" rst="0">
        <comment>
          compensation R select&#10;2&apos;b00: default, 360k&#10;2&apos;b01: 320k&#10;2&apos;b10: 400k&#10;2&apos;b11: 440k
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ana_dcdc_ctrl_1">
      <bits access="r" name="ana_dcdc_ctrl_1_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="vcore_slope" pos="14:13" rst="0">
        <comment>
          slope compensation tuning&#10;2&apos;b00: default&#10;2&apos;b01: 0.5x&#10;2&apos;b10: 1.5x&#10;2&apos;b11: 2x
        </comment>
      </bits>
      <bits access="rw" name="vcore_sr_hs" pos="12:11" rst="0">
        <comment>
          high side slew rate control&#10;2&apos;b00: default&#10;2&apos;b01: 0.75x&#10;2&apos;b10: 0.5x&#10;2&apos;b11: 0.25x
        </comment>
      </bits>
      <bits access="rw" name="vcore_sr_ls" pos="10:9" rst="0">
        <comment>
          low side slew rate control&#10;2&apos;b00: default&#10;2&apos;b01: 0.75x&#10;2&apos;b10: 0.5x&#10;2&apos;b11: 0.25x
        </comment>
      </bits>
      <bits access="rw" name="vcore_zx_disable" pos="8" rst="0">
        <comment>
          force zero-cross off&#10;1&apos;b0: default, zero_cross detect on&#10;1&apos;b1: zero-cross detect off
        </comment>
      </bits>
      <bits access="rw" name="vcore_zx_offset" pos="7:6" rst="0">
        <comment>
          zero-cross offset tuning&#10;2&apos;b00: default&#10;2&apos;b01: +5mV offset&#10;2&apos;b10: -5mV offset&#10;2&apos;b11: -10mV offset
        </comment>
      </bits>
      <bits access="rw" name="vrf_antiring_en" pos="5" rst="0">
        <comment>
          anti-ring enable&#10;1&apos;b0: default, anti-ring off&#10;1&apos;b1: anti-ring on
        </comment>
      </bits>
      <bits access="rw" name="vrf_curlimit_r" pos="4:3" rst="0">
        <comment>
          current limit threshold tuning&#10;2&apos;b00: default&#10;2&apos;b01: -20%&#10;2&apos;b10: +40%&#10;2&apos;b11: +20%
        </comment>
      </bits>
      <bits access="rw" name="vrf_curses_r" pos="2:1" rst="0">
        <comment>
          current sense R ratio tuning&#10;current sense multiplier tuning&#10;2&apos;b00: default, x1&#10;2&apos;b01: -20%&#10;2&apos;b10: +40%&#10;2&apos;b11: +20%
        </comment>
      </bits>
      <bits access="rw" name="vrf_force_pwm" pos="0" rst="0">
        <comment>
          force PWM mode&#10;1&apos;b0: default, PFM/PWM auto mode&#10;1&apos;b1: force PWM mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ana_dcdc_ctrl_2">
      <bits access="rw" name="vrf_pfm_vh" pos="15:14" rst="0">
        <comment>
          PFM mode threshold for upper limit&#10;2&apos;b00: default, 0.6V&#10;2&apos;b01: 0.55V&#10;2&apos;b10: 0.65V&#10;2&apos;b11: 0.7V
        </comment>
      </bits>
      <bits access="rw" name="vrf_rcomp" pos="13:12" rst="0">
        <comment>
          compensation R select&#10;2&apos;b00: default, 360k&#10;2&apos;b01: 320k&#10;2&apos;b10: 400k&#10;2&apos;b11: 440k
        </comment>
      </bits>
      <bits access="rw" name="vrf_slope" pos="11:10" rst="0">
        <comment>
          slope compensation tuning&#10;2&apos;b00: default&#10;2&apos;b01: 0.5x&#10;2&apos;b10: 1.5x&#10;2&apos;b11: 2x
        </comment>
      </bits>
      <bits access="rw" name="vrf_sr_hs" pos="9:8" rst="0">
        <comment>
          high side slew rate control&#10;2&apos;b00: default&#10;2&apos;b01: 0.75x&#10;2&apos;b10: 0.5x&#10;2&apos;b11: 0.25x
        </comment>
      </bits>
      <bits access="rw" name="vrf_sr_ls" pos="7:6" rst="0">
        <comment>
          low side slew rate control&#10;2&apos;b00: default&#10;2&apos;b01: 0.75x&#10;2&apos;b10: 0.5x&#10;2&apos;b11: 0.25x
        </comment>
      </bits>
      <bits access="rw" name="vrf_zx_disable" pos="5" rst="0">
        <comment>
          force zero-cross off&#10;1&apos;b0: default, zero_cross detect on&#10;1&apos;b1: zero-cross detect off
        </comment>
      </bits>
      <bits access="rw" name="vrf_zx_offset" pos="4:3" rst="0">
        <comment>
          zero-cross offset tuning&#10;2&apos;b00: default&#10;2&apos;b01: +5mV offset&#10;2&apos;b10: -5mV offset&#10;2&apos;b11: -10mV offset
        </comment>
      </bits>
      <bits access="rw" name="vpa_pd" pos="2" rst="1">
        <comment>
          DCDC power down&#10;1&apos;b0: DCDC on&#10;1&apos;b1: DCDC power down
        </comment>
      </bits>
      <bits access="rw" name="vpa_lp_en" pos="1" rst="0">
        <comment>
          low power mode&#10;1&apos;b0: active mode&#10;1&apos;b1: low-power mode
        </comment>
      </bits>
      <bits access="rw" name="vpa_antiring_en" pos="0" rst="0">
        <comment>
          anti-ring enable&#10;1&apos;b0: default, anti-ring off&#10;1&apos;b1: anti-ring on
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ana_dcdc_ctrl_3">
      <bits access="r" name="ana_dcdc_ctrl_3_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="vpa_apc_enable" pos="14" rst="0">
        <comment>
          APC mode enable&#10;1&apos;b0: default, RG control mode&#10;1&apos;b1: APC mode
        </comment>
      </bits>
      <bits access="rw" name="vpa_apc_ramp_sel" pos="13" rst="0">
        <comment>
          APC ramp selection&#10;1&apos;b0: default, 2.0x ramp&#10;1&apos;b1: 2.5x ramp
        </comment>
      </bits>
      <bits access="rw" name="vpa_bypass_disable" pos="12" rst="0">
        <comment>
          bypass mode disable&#10;1&apos;b0: default, auto bypass&#10;1&apos;b1: bypass off
        </comment>
      </bits>
      <bits access="rw" name="vpa_bypass_forceon" pos="11" rst="0">
        <comment>
          bypass force on&#10;1&apos;b0: default, auto bypass&#10;1&apos;b1: force bypass mode on
        </comment>
      </bits>
      <bits access="rw" name="vpa_bypass_threshold" pos="10:9" rst="0">
        <comment>
          bypass mode threshold&#10;2&apos;b00: default, ~200mV
        </comment>
      </bits>
      <bits access="rw" name="vpa_ccomp3" pos="8:7" rst="0">
        <comment>
          compensation C3&#10;2&apos;b00: default&#10;2&apos;b01: -20%&#10;2&apos;b10: +40%&#10;2&apos;b11: +20%
        </comment>
      </bits>
      <bits access="rw" name="vpa_curlimit_r" pos="6:5" rst="0">
        <comment>
          current limit threshold tuning&#10;2&apos;b00: default&#10;2&apos;b01: -0.5pF&#10;2&apos;b10: +1pF&#10;2&apos;b11: +0.5pF
        </comment>
      </bits>
      <bits access="rw" name="vpa_curses_m" pos="4:3" rst="0">
        <comment>
          current sense multiplier tuning&#10;2&apos;b00: default, x1&#10;2&apos;b01: x0.5&#10;2&apos;b10: x2&#10;2&apos;b11: x1.5
        </comment>
      </bits>
      <bits access="rw" name="vpa_dvs_on" pos="2" rst="0">
        <comment>
          DVS control&#10;1&apos;b0: default, off&#10;1&apos;b0: on, for DCM down discharge
        </comment>
      </bits>
      <bits access="rw" name="vpa_force_pwm" pos="1" rst="0">
        <comment>
          force PWM mode&#10;1&apos;b0: default, PFM/PWM auto mode&#10;1&apos;b1: force PWM mode
        </comment>
      </bits>
      <bits access="rw" name="vpa_maxduty_sel" pos="0" rst="0">
        <comment>
          100% duty selection&#10;1&apos;b0: default, max duty=100%&#10;1&apos;b1: max duty ~95%
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ana_dcdc_ctrl_4">
      <bits access="r" name="ana_dcdc_ctrl_4_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="vcore_curavg" pos="14:13" rst="0">
        <comment>
          current sense average ratio&#10;current sense multiplier tuning&#10;2&apos;b00: default, x1&#10;2&apos;b01: -20%&#10;2&apos;b10: +40%&#10;2&apos;b11: +20%
        </comment>
      </bits>
      <bits access="rw" name="vpa_pfm_threshold" pos="12:11" rst="0">
        <comment>
          PFM mode threshold for upper limit&#10;2&apos;b00: default&#10;2&apos;b01: -50mV&#10;2&apos;b10: +50mV&#10;2&apos;b11: +100mV
        </comment>
      </bits>
      <bits access="rw" name="vpa_rcomp2" pos="10:9" rst="0">
        <comment>
          compensation R2 select&#10;2&apos;b00: default, 960k&#10;2&apos;b01: 880k&#10;2&apos;b10: 1040k&#10;2&apos;b11: 1120k
        </comment>
      </bits>
      <bits access="rw" name="vpa_rcomp3" pos="8:7" rst="0">
        <comment>
          compensation R3 select&#10;2&apos;b00: default, 5k&#10;2&apos;b01: 2.5k&#10;2&apos;b10: 10k&#10;2&apos;b11: 7.5k
        </comment>
      </bits>
      <bits access="rw" name="vpa_sawtooth_slope" pos="6:5" rst="0">
        <comment>
          sawtooth tuning manully&#10;2&apos;b00: default&#10;2&apos;b01: +15%&#10;2&apos;b10: -30%&#10;2&apos;b11: -15%
        </comment>
      </bits>
      <bits access="rw" name="vpa_sawtoothcal_rst" pos="4" rst="0">
        <comment>
          sawtooth calibration&#10;1&apos;b0: default, auto calibration before power-on&#10;1&apos;b1: calibration manully
        </comment>
      </bits>
      <bits access="rw" name="vpa_sr_hs" pos="3:2" rst="0">
        <comment>
          high side slew rate control&#10;2&apos;b00: default&#10;2&apos;b01: 0.75x&#10;2&apos;b10: 0.5x&#10;2&apos;b11: 0.25x
        </comment>
      </bits>
      <bits access="rw" name="vpa_sr_ls" pos="1:0" rst="0">
        <comment>
          low side slew rate control&#10;2&apos;b00: default&#10;2&apos;b01: 0.75x&#10;2&apos;b10: 0.5x&#10;2&apos;b11: 0.25x
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ana_dcdc_ctrl_5">
      <bits access="r" name="ana_dcdc_ctrl_5_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="vrf_curavg" pos="14:13" rst="0">
        <comment>
          current sense average ratio&#10;current sense multiplier tuning&#10;2&apos;b00: default, x1&#10;2&apos;b01: -20%&#10;2&apos;b10: +40%&#10;2&apos;b11: +20%
        </comment>
      </bits>
      <bits access="rw" name="vpa_vosel" pos="12:6" rst="120">
        <comment>
          output voltage selection, 25mV/step.&#10;7&apos;h00=0.4V,&#10;7&apos;h7C=3.5V&#10;default 7&apos;h78=3.4V
        </comment>
      </bits>
      <bits access="rw" name="vpa_zx_disable" pos="5" rst="0">
        <comment>
          force zero-cross off&#10;1&apos;b0: default, zero_cross detect on&#10;1&apos;b1: zero-cross detect off
        </comment>
      </bits>
      <bits access="rw" name="vpa_zx_offset" pos="4:3" rst="0">
        <comment>
          zero-cross offset tuning&#10;2&apos;b00: default&#10;2&apos;b01: +5mV offset&#10;2&apos;b10: -5mV offset&#10;2&apos;b11: -10mV offset
        </comment>
      </bits>
      <bits access="rw" name="dcdc_auxtrim_sel" pos="2:0" rst="0">
        <comment>
          DCDC to AUXADC trim channel selection&#10;3&apos;b001: select VCORE&#10;3&apos;b010: select VRF (VRF*18/37)&#10;3&apos;b011: select VPA (VPA*18/68)&#10;RG_DCDC_AUXTRIM_SEL[2], internal test mode select:&#10;0: default, internal test mode disable&#10;1: internal test mode enable. Monitor internal signals by reuse CLK3M_OUT path&#10;3&apos;b100: enpwm_vrf&#10;3&apos;b101: zx_vrf&#10;3&apos;b110: enpwm_vcore&#10;3&apos;b111: zx_vcore
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ana_chgr_ctrl">
      <bits access="r" name="ana_chgr_ctrl_reserved_0" pos="15:5" rst="0">
      </bits>
      <bits access="r" name="pd_vbus_safe" pos="4" rst="0">
      </bits>
      <bits access="r" name="typec_vbus_ok" pos="3" rst="0">
      </bits>
      <bits access="rw" name="rg_pd_vbus_safe_det_v" pos="2:1" rst="2">
      </bits>
      <bits access="rw" name="chgr_ptest" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ana_auxadc_ctrl">
      <bits access="r" name="ana_auxadc_ctrl_reserved_0" pos="15:7" rst="0">
      </bits>
      <bits access="rw" name="ldo_auxcal_sel" pos="6:4" rst="0">
      </bits>
      <bits access="rw" name="auxad_test_en" pos="3" rst="0">
        <comment>
          AUX ADC channel ATE test scan mode control. 1 for ATE test channel scan, 0 for normal work. For ATE test channel scan, set this reg to 1, and using AUXAD_CS[4:0] to scan channel.
        </comment>
      </bits>
      <bits access="rw" name="aux_ldo_sel" pos="2:1" rst="0">
        <comment>
          AUXADC LDO output voltage selection,&#10;00: AVDD_LDO=1.8V&#10;01: AVDD_LDO=1.88V&#10;10: AVDD_LDO=1.72V&#10;11: AVDD_LDO=1.65V&#10;Default 00.
        </comment>
      </bits>
      <bits access="rw" name="aux_ldo_en" pos="0" rst="0">
        <comment>
          AUXADC LDO enable signal, default 0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_ports">
      <bits access="r" name="rsvd_ports_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="r" name="rsvd_ports_in" pos="7:4" rst="0">
      </bits>
      <bits access="rw" name="rsvd_ports_out" pos="3:0" rst="3">
      </bits>
    </reg>
  </module>
</archive>

<archive relative ="pmic_gpio_lite.xml">

  <var name="NB_GPIO_LITE" value="8" />

<module name="pmic_gpio_lite" category="Pmic">

  

  <reg protect="rw" name="gpio_oen_val">
    <bits access="rw" name="oen_val" pos="NB_GPIO_LITE-1:0" rst="0xffffffff" display="hex">
      <options>
        <option name="INPUT" value="1" />

        <option name="OUTPUT" value="0" />

        <default />
      </options>

      <comment>Set the direction of the GPIO n.<br />0 = output<br />1 =
      input</comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpio_out_val">
    <bits access="rw" name="out_val" pos="NB_GPIO_LITE-1:0" rst="0xffffffff" display="hex">
      <comment>When write, update the output value. When read, get the output
      value. </comment>
    </bits>
  </reg>

  <reg protect="ro" name="gpio_in_val">
    <bits access="ro" name="in_val" pos="NB_GPIO_LITE-1:0" rst="0x0" display="hex">
      <comment>When read, get the input value. </comment>
    </bits>
  </reg>


  

  <reg protect="rw" name="gpint_ctrl_r">
    <bits access="rw" name="gpint_r" pos="NB_GPIO_LITE-1:0" rst="0">
      <comment>'1',  for rising edge and level high. </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gpint_ctrl_f">
    <bits access="rw" name="gpint_f" pos="NB_GPIO_LITE-1:0" rst="0">
      <comment>'1',  for falling edge and level low. </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gpint_ctrl_mode">
    <bits access="rw" name="gpint_mode" pos="NB_GPIO_LITE-1:0" rst="0">
      <comment>'1',  for level mode. </comment>
    </bits>
  </reg>

  

  <reg protect="w" name="int_clr">
    <bits access="c" name="gpint_clr" pos="NB_GPIO_LITE-1:0" rst="0">
      <comment>'Write '1' will clear GPIO interrupt.</comment>
    </bits>
  </reg>

  <reg protect="r" name="int_status">
    <bits access="r" name="gpint_status" pos="NB_GPIO_LITE-1:0" rst="0">
      <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      <options>
        <default/>
        <mask/>
        <shift/>
      </options>
    </bits>
  </reg>

  <reg protect="rw" name="gpint_ctrl">
    <bits access="rw" name="negedge_logic_en" pos="0" rst="0">
      <comment>'1',  open negedge logic. </comment>
    </bits>
  </reg>


</module>


</archive>
<archive relative="pmic_gpt16.xml">
  <module name="pmic_gpt16" category="Pmic">
    <reg protect="rw" name="cr">
      <bits access="r" name="cr_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="refclk_sel" pos="11" rst="1">
      </bits>
      <bits access="rw" name="tri_cnt_en" pos="10" rst="0">
        <comment>
          Input triger number count enable
        </comment>
      </bits>
      <bits access="rw" name="tri" pos="9" rst="0">
        <comment>
          slave_mode trigger select
        </comment>
      </bits>
      <bits access="rw" name="arpe" pos="8" rst="1">
        <comment>
          auto preload value
        </comment>
      </bits>
      <bits access="rw" name="cms" pos="7:6" rst="0">
        <comment>
          Center-aligned mode select 00: disable , other:enable
        </comment>
      </bits>
      <bits access="rw" name="dir" pos="5" rst="0">
        <comment>
          counter dir , 0: cnt ++ , 1: cnt --
        </comment>
      </bits>
      <bits access="rw" name="opm" pos="4" rst="0">
        <comment>
          one pulse mode,  0:disable 1:enable
        </comment>
      </bits>
      <bits access="rw" name="udis" pos="3" rst="0">
        <comment>
          update disable, 0:disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="ckd" pos="2:1" rst="0">
        <comment>
          clock fdts didiver, 01: divided by 2 10:divided by 4, other:bypass
        </comment>
      </bits>
      <bits access="rw" name="cen" pos="0" rst="0">
        <comment>
          counter enable, 0: disbale, 1:enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="smcr">
      <bits access="r" name="smcr_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rw" name="sms" pos="2:0" rst="0">
        <comment>
          slave mode select: 100: slave mode, 101:gate mode, 110:trig mode, others disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="egr">
      <bits access="r" name="egr_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rc" name="ug" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          user trigger gen
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccmr_oc">
      <bits access="rw" name="oc2ce" pos="15" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc2m" pos="14:12" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc2pe" pos="11" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc2fe" pos="10" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc2s" pos="9:8" rst="1">
        <comment>
          channel source sel, bit[9] 0: output enable, 1 output disable bit[8] 0: use ti2, 1: use ti1
        </comment>
      </bits>
      <bits access="rw" name="oc1ce" pos="7" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc1m" pos="6:4" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc1pe" pos="3" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc1fe" pos="2" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc1s" pos="1:0" rst="1">
        <comment>
          channel source sel, bit[0] 0: output enable, 1 output disable bit[1] 0: use ti2, 1: use ti1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccmr_ic">
      <bits access="r" name="ccmr_ic_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="ic2f" pos="11:8" rst="0">
        <comment>
          ti2 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic2psc" pos="7:6" rst="0">
        <comment>
          ti2 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
      <bits access="rw" name="ic1f" pos="5:2" rst="0">
        <comment>
          ti1 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic1psc" pos="1:0" rst="0">
        <comment>
          ti1 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccer">
      <bits access="r" name="ccer_reserved_0" pos="15:4" rst="0">
      </bits>
      <bits access="rw" name="cc2p" pos="3" rst="0">
        <comment>
          ti2 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc2e" pos="2" rst="0">
        <comment>
          ti2 enable
        </comment>
      </bits>
      <bits access="rw" name="cc1p" pos="1" rst="0">
        <comment>
          ti1 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc1e" pos="0" rst="0">
        <comment>
          ti1 enable
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="cnt">
      <bits access="r" name="cnt_value" pos="15:0" rst="0">
        <comment>
          cnt value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="psc">
      <bits access="rw" name="psc_value" pos="15:0" rst="0">
        <comment>
          cnt prescale value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="arr">
      <bits access="rw" name="arr_value" pos="15:0" rst="65535">
        <comment>
          cnt max value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr1_ic">
      <bits access="r" name="timer_ccr1_capture" pos="15:0" rst="65535">
        <comment>
          ic1 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr2_ic">
      <bits access="r" name="timer_ccr2_capture" pos="15:0" rst="65535">
        <comment>
          ic2 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr1_oc">
      <bits access="rw" name="timer_ccr1_compare" pos="15:0" rst="65535">
        <comment>
          ic1 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr2_oc">
      <bits access="rw" name="timer_ccr2_compare" pos="15:0" rst="65535">
        <comment>
          ic2 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="isr">
      <bits access="r" name="isr_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="r" name="event_update" pos="5" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="r" name="slave_trig" pos="4" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="capture_int" pos="3:2" rst="0">
      </bits>
      <bits access="r" name="compare_int" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="irsr">
      <bits access="r" name="irsr_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="r" name="event_update" pos="5" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="r" name="slave_trig" pos="4" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="capture_int" pos="3:2" rst="0">
      </bits>
      <bits access="r" name="compare_int" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mask">
      <bits access="r" name="mask_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="rw" name="event_update" pos="5" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="rw" name="slave_trig" pos="4" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="rw" name="capture_int" pos="3:2" rst="0">
      </bits>
      <bits access="rw" name="compare_int" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="clr">
      <bits access="r" name="clr_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="rc" name="event_update" pos="5" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="rc" name="slave_trig" pos="4" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="rc" name="capture_int" pos="3:2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="compare_int" pos="1:0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="pmic_intc.xml">
  <module name="pmic_intc" category="Pmic">
    <reg protect="r" name="int_status">
      <bits access="r" name="int_status_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="r" name="adc" pos="7" rst="0">
      </bits>
      <bits access="r" name="chg_off" pos="6" rst="0">
      </bits>
      <bits access="r" name="chg_on" pos="5" rst="0">
      </bits>
      <bits access="r" name="pwrkey" pos="4" rst="0">
      </bits>
      <bits access="r" name="wdt" pos="3" rst="0">
      </bits>
      <bits access="r" name="timer" pos="2" rst="0">
      </bits>
      <bits access="r" name="gpt" pos="1" rst="0">
      </bits>
      <bits access="r" name="gpio" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="int_raw">
      <bits access="r" name="int_raw_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="r" name="adc" pos="7" rst="0">
      </bits>
      <bits access="r" name="chg_off" pos="6" rst="0">
      </bits>
      <bits access="r" name="chg_on" pos="5" rst="0">
      </bits>
      <bits access="r" name="pwrkey" pos="4" rst="0">
      </bits>
      <bits access="r" name="wdt" pos="3" rst="0">
      </bits>
      <bits access="r" name="timer" pos="2" rst="0">
      </bits>
      <bits access="r" name="gpt" pos="1" rst="0">
      </bits>
      <bits access="r" name="gpio" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="int_en">
      <bits access="rw" name="int_en_reserved_0" pos="15:8" rst="255">
      </bits>
      <bits access="rw" name="adc" pos="7" rst="1">
      </bits>
      <bits access="rw" name="chg_off" pos="6" rst="1">
      </bits>
      <bits access="rw" name="chg_on" pos="5" rst="1">
      </bits>
      <bits access="rw" name="pwrkey" pos="4" rst="1">
      </bits>
      <bits access="rw" name="wdt" pos="3" rst="1">
      </bits>
      <bits access="rw" name="timer" pos="2" rst="1">
      </bits>
      <bits access="rw" name="gpt" pos="1" rst="1">
      </bits>
      <bits access="rw" name="gpio" pos="0" rst="1">
      </bits>
    </reg>
  </module>
</archive>
<archive relative ="pmic_iomux.xml">
<module name="pmic_iomux" category="Pmic">
  
 

  <reg name="pad_GPIO_0_cfg" protect="rw">
     <bits name="pad_GPIO_0_pull_frc" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_0_pull_dn" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_0 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_0_pull_up" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_0 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_0_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_0_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_0 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_0 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_0 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_0 select</comment>
     <options>
            <option name="fun_GPIO_0_sel" value ="0"></option>
            <option name="fun_CHIP_SLEEP_sel" value ="4"></option>
            <option name="fun_CLK_AUXAD_6P5M_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_1_cfg" protect="rw">
     <bits name="pad_GPIO_1_pull_frc" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_1_pull_dn" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_1 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_1_pull_up" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_1 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_1_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_1_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_1 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_1 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_1 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_1 select</comment>
     <options>
            <option name="fun_GPIO_1_sel" value ="0"></option>
            <option name="fun_GPT3_PWM_0_sel" value ="1"></option>
            <option name="fun_GPT3_TI_1_sel" value ="2"></option>
            <option name="fun_XTAL26M_REQ_sel" value ="3"></option>
            <option name="fun_CLK_26M_sel" value ="4"></option>
            <option name="fun_AUXAD_INIT_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_2_cfg" protect="rw">
     <bits name="pad_GPIO_2_pull_frc" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_2 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_2_pull_dn" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_2 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_2_pull_up" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_2 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_2_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_2 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_2_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_2 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_2_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_2 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_2_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_2 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_2 select</comment>
     <options>
            <option name="fun_GPIO_2_sel" value ="0"></option>
            <option name="fun_GPT3_PWM_1_sel" value ="1"></option>
            <option name="fun_GPT3_TI_0_sel" value ="2"></option>
            <option name="fun_CLK_32K_sel" value ="3"></option>
            <option name="fun_DBG_CLK_sel" value ="4"></option>
            <option name="fun_AUXAD_VLD_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_3_cfg" protect="rw">
     <bits name="pad_GPIO_3_pull_frc" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_3 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_3_pull_dn" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_3 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_3_pull_up" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_3 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_3_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_3 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_3_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_3 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_3_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_3 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_3_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_3 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_3 select</comment>
     <options>
            <option name="fun_GPIO_3_sel" value ="0"></option>
            <option name="fun_GPT3_PWM_0_sel" value ="1"></option>
            <option name="fun_GPT3_TI_1_sel" value ="2"></option>
            <option name="fun_XTAL26M_REQ_sel" value ="3"></option>
            <option name="fun_DBG_SIG_sel" value ="4"></option>
            <option name="fun_AUXAD_DAT0_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_4_cfg" protect="rw">
     <bits name="pad_GPIO_4_pull_frc" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_4 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_4_pull_dn" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_4 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_4_pull_up" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_4 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_4_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_4 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_4_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_4 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_4_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_4 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_4_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_4 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_4_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_4 select</comment>
     <options>
            <option name="fun_GPIO_4_sel" value ="0"></option>
            <option name="fun_GPT3_PWM_1_sel" value ="1"></option>
            <option name="fun_CLK_OSC_3M_sel" value ="4"></option>
            <option name="fun_AUXAD_DAT1_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_5_cfg" protect="rw">
     <bits name="pad_GPIO_5_pull_frc" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_5 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_5_pull_dn" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_5 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_5_pull_up" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_5 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_5_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_5 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_5_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_5 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_5_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_5 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_5_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_5 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_5_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_5 select</comment>
     <options>
            <option name="fun_GPIO_5_sel" value ="0"></option>
            <option name="fun_GPT3_PWM_0_sel" value ="1"></option>
            <option name="fun_CLK_32K_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_6_cfg" protect="rw">
     <bits name="pad_GPIO_6_pull_frc" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_6 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_6_pull_dn" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_6 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_6_pull_up" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_6 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_6_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_6 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_6_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_6 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_6_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_6 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_6_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_6 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_6_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_6 select</comment>
     <options>
            <option name="fun_GPIO_6_sel" value ="0"></option>
            <option name="fun_GPT3_PWM_1_sel" value ="1"></option>
            <option name="fun_GPT3_TI_0_sel" value ="2"></option>
            <option name="fun_XTAL26M_REQ_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_7_cfg" protect="rw">
     <bits name="pad_GPIO_7_pull_frc" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_7 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_7_pull_dn" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_7 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_7_pull_up" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_7 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_7_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_7 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_7_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_7 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_7_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_7 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_7_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_7 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_7_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_7 select</comment>
     <options>
            <option name="fun_GPIO_7_sel" value ="0"></option>
            <option name="fun_GPT3_PWM_0_sel" value ="1"></option>
            <option name="fun_GPT3_TI_1_sel" value ="2"></option>
            <option name="fun_XTAL26M_REQ_sel" value ="3"></option>
            <option name="fun_CLK_32K_sel" value ="4"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
   </module>
</archive>
<archive relative="pmic_rtc_timer.xml">
  <module name="pmic_rtc_timer" category="Pmic">
    <reg protect="rw" name="ctrl">
      <bits access="r" name="ctrl_reserved_0" pos="15:7" rst="0">
      </bits>
      <bits access="rc" name="load_value" pos="6" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="data_valid_clr" pos="5" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="r" name="data_valid" pos="4" rst="0">
      </bits>
      <bits access="rc" name="read_lock" pos="3" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="wrap_int_enable" pos="2" rst="0">
      </bits>
      <bits access="rw" name="alarm_enable" pos="1" rst="0">
      </bits>
      <bits access="rw" name="timer_enable" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="cur_val_l">
      <bits access="r" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="cur_val_m">
      <bits access="r" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="cur_val_h">
      <bits access="r" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="alarm_val_l">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="alarm_val_m">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="alarm_val_h">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="load_val_l">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="load_val_m">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="load_val_h">
      <bits access="rw" name="data" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="int_mask">
      <bits access="r" name="int_mask_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="alarm" pos="1" rst="0">
      </bits>
      <bits access="rw" name="wrap" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="int_clr">
      <bits access="r" name="int_clr_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rc" name="alarm" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="wrap" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="int_status">
      <bits access="r" name="int_status_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="r" name="alarm" pos="1" rst="0">
      </bits>
      <bits access="r" name="wrap" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="int_cause">
      <bits access="r" name="int_cause_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="r" name="alarm" pos="1" rst="0">
      </bits>
      <bits access="r" name="wrap" pos="0" rst="0">
      </bits>
    </reg>
  </module>
</archive>
<archive relative="pmic_wdt16.xml">
  <module name="pmic_wdt16" category="Pmic">
    <reg protect="rw" name="wdt_cvr0_l">
      <bits access="rw" name="count_value_0_l" pos="15:0" rst="65535">
        <comment>
          lower 16 bit of Count Value for 1st Timeout
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wdt_cvr0_m">
      <bits access="rw" name="count_value_0_m" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="wdt_cvr0_h">
      <bits access="rw" name="count_value_0_h" pos="15:0" rst="65535">
        <comment>
          upper 16 bit of Count Value for 1st Timeout
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wdt_cvr1_l">
      <bits access="rw" name="count_value_1_l" pos="15:0" rst="15872">
        <comment>
          lower 16 bit of Count Value for 2nd Timeout
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wdt_cvr1_m">
      <bits access="rw" name="count_value_1_m" pos="15:0" rst="73">
      </bits>
    </reg>
    <reg protect="rw" name="wdt_cvr1_h">
      <bits access="rw" name="count_value_1_h" pos="15:0" rst="0">
        <comment>
          upper 16 bit of Count Value for 2nd Timeout
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wdt_cr">
      <bits access="r" name="wdt_cr_reserved_0" pos="15:5" rst="0">
      </bits>
      <bits access="rw" name="mode" pos="4" rst="1">
        <comment>
          0: reset only, 1: interrupt and reset
        </comment>
      </bits>
      <bits access="r" name="wdt_cr_reserved_1" pos="3" rst="0">
      </bits>
      <bits access="rw" name="reset_length" pos="2:0" rst="0">
        <comment>
          reset pulse length in number of wdt clock cycles
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wdt_cmd">
      <bits access="r" name="wdt_cmd_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rc" name="cmd" pos="7:0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          write 8&apos;h76 to restart, write 8&apos;h34 to stop, else do nothing
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wdt_icr">
      <bits access="r" name="wdt_icr_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rc" name="int_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          A pulse to clear interrupt
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="wdt_sr">
      <bits access="r" name="wdt_sr_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="r" name="wdt_active" pos="1" rst="0">
        <comment>
          1 when watchdog running, else 0
        </comment>
      </bits>
      <bits access="r" name="int_assert" pos="0" rst="0">
        <comment>
          interrupt assert when 1
        </comment>
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "config_1811.xml">
<include file="globals_1811.xml"/>
  
  
  <var name="REG_PMIC_BASE" value="0x41a48000"><comment>pmic base address</comment></var>

  
  <instance address="REG_PMIC_BASE + PMIC_STEP * PMIC_ID_IOMUX" type="pmic_iomux" name="PMIC_IOMUX" />
  <instance address="REG_PMIC_BASE + PMIC_STEP * PMIC_ID_GPIO" type="pmic_gpio_lite" name="PMIC_GPIO" />
  <instance address="REG_PMIC_BASE + PMIC_STEP * PMIC_ID_GPT" type="pmic_gpt16" name="PMIC_GPT" />
  <instance address="REG_PMIC_BASE + PMIC_STEP * PMIC_ID_TIMER" type="pmic_rtc_timer" name="PMIC_TIMER" />
  <instance address="REG_PMIC_BASE + PMIC_STEP * PMIC_ID_WDT" type="pmic_wdt16" name="PMIC_WDT" />
  <instance address="REG_PMIC_BASE + PMIC_STEP * PMIC_ID_INTC" type="pmic_intc" name="PMIC_INTC" />
  <instance address="REG_PMIC_BASE + PMIC_STEP * PMIC_ID_PMUC" type="pmic_pmuc" name="PMIC_PMUC" />
  <instance address="REG_PMIC_BASE + PMIC_STEP * PMIC_ID_ADC" type="pmic_adc" name="PMIC_ADC" />
  <instance address="REG_PMIC_BASE + PMIC_STEP * PMIC_ID_EFS" type="pmic_apb_efs" name="PMIC_EFUSE" />
  <instance address="REG_PMIC_BASE + PMIC_STEP * PMIC_ID_DIG" type="pmic_dig" name="PMIC_DIG" />
  


</archive>


<archive relative = "globals.xml" vhdlpkg="chip_cfg_pkg">

  
  <var name="NB_BITS_ADDR" value="32" ><comment>AHB Address bus size</comment></var>
  <var name="SYS_IFC1_NB_STD_CHANNEL" value="4" >
    <comment>System Ifc1 Number of generic channel
    </comment>
  </var>
  <var name="SYS_IFC2_NB_STD_CHANNEL" value="14" >
    <comment>System Ifc2 Number of generic channel
    </comment>
  </var>
  <var name="BB_IFC_NB_STD_CHANNEL" value="2" >
    <comment>BB Ifc Number of generic channel
    </comment>
  </var>


  
  
  <enum name="Sys_Master_Id">
    <entry name="SYS_MID_STARC1"/>
    <entry name="SYS_MID_STARC2"/>
    <entry name="SYS_MID_STARS1"/>
    <entry name="SYS_MID_STARS2"/>
    <entry name="SYS_MID_SYSIFC1_STDCH0"/>
    <entry name="SYS_MID_SYSIFC1_STDCH1"/>
    <entry name="SYS_MID_SYSIFC1_STDCH2"/>
    <entry name="SYS_MID_SYSIFC1_STDCH3"/>
    <entry name="SYS_MID_DMA"/>
    <entry name="SYS_MID_CE_PUB"/>
    <entry name="SYS_MID_CE_SEC"/>
    <entry name="SYS_MID_F8"/>
    <entry name="SYS_MID_NBIOT"/>
    <entry name="SYS_MID_RFIF"/>
    <entry name="SYS_MID_RSVD_14"/>
    <entry name="SYS_MID_RSVD_15"/>
    <entry name="SYS_MID_SYSIFC2_STDCH0"/>
    <entry name="SYS_MID_SYSIFC2_STDCH1"/>
    <entry name="SYS_MID_SYSIFC2_STDCH2"/>
    <entry name="SYS_MID_SYSIFC2_STDCH3"/>
    <entry name="SYS_MID_SYSIFC2_STDCH4"/>
    <entry name="SYS_MID_SYSIFC2_STDCH5"/>
    <entry name="SYS_MID_SYSIFC2_STDCH6"/>
    <entry name="SYS_MID_SYSIFC2_STDCH7"/>
    <entry name="SYS_MID_SYSIFC2_STDCH8"/>
    <entry name="SYS_MID_SYSIFC2_STDCH9"/>
    <entry name="SYS_MID_SYSIFC2_STDCH10"/>
    <entry name="SYS_MID_SYSIFC2_STDCH11"/>
    <entry name="SYS_MID_SYSIFC2_STDCH12"/>
    <entry name="SYS_MID_SYSIFC2_STDCH13"/>
    <entry name="SYS_MID_SYSIFC2_DBGCH"/>
    <entry name="SYS_MID_RSVD_31"/>
    <entry name="SYS_MID_BBIFC_STDCH0"/>
    <entry name="SYS_MID_BBIFC_STDCH1"/>
    <entry name="SYS_MID_BBIFC_RFSPICH"/>
    <bound name="SYS_MID_RR_End"/>
  </enum>
  <var name="SYS_NB_MASTERS" value="SYS_MID_RR_End"/>


  <var name="SYS_NB_BITS_SLAVE" value="4"/>
  
  <enum name="Sys_slave_Id">
    <entry name="SYS_SID_STARTCM"/>
    <entry name="SYS_SID_RAM0"/>
    <entry name="SYS_SID_RAM1"/>
    <entry name="SYS_SID_RAM2"/>
    <entry name="SYS_SID_RAM3"/>
    <entry name="SYS_SID_PSRAM"/>
    <entry name="SYS_SID_FLASH"/>
    <entry name="SYS_SID_SYSDEC1"/>
    <entry name="SYS_SID_SYSDEC2"/>
    <entry name="SYS_SID_BBDEC"/>
    <entry name="SYS_SID_NBIOT"/>
    <entry name="SYS_SID_FLASH_EXT"/>
    <entry name="SYS_SID_STARMTBRAM"/>
    <bound name="SYS_SID_End"/>
  </enum>
  <var name="SYS_NB_SLAVES" value="SYS_SID_End" />

  <var name="SYS1_NB_BITS_PADDR" value="12"></var>
  <var name="SYS_APB1_STEP" value="exp2(SYS1_NB_BITS_PADDR)"/>

  
  <enum name="Sys1_Module_Id">
    <entry name="SYS_ID1_UART1"/>
    <entry name="SYS_ID1_UART2"/>
    <entry name="SYS_ID1_GPIO1"/>
    <entry name="SYS_ID1_GPT1"/>
    <entry name="SYS_ID1_PWR_CTRL"/>
    <entry name="SYS_ID1_NB_LPS"/>
    <entry name="SYS_ID1_TIMER1"/>
    <entry name="SYS_ID1_IOMUX1"/>
    <entry name="SYS_ID1_IOMUX2"/>
    <entry name="SYS_ID1_SYS_WDT"/>
    <entry name="SYS_ID1_RSVD0_0"/>
    <entry name="SYS_ID1_RSVD0_1"/>
    <entry name="SYS_ID1_RSVD0_2"/>
    <entry name="SYS_ID1_RSVD0_3"/>
    <entry name="SYS_ID1_SYS_IFC1"/>
  </enum>

  <var name="SYS2_NB_BITS_PADDR" value="12"></var>
  <var name="SYS_APB2_STEP" value="exp2(SYS2_NB_BITS_PADDR)"/>

  
  <enum name="Sys2_Module_Id">
    <entry name="SYS_ID2_SCI2"><comment>The following modules are linked to ifc dma req with 2 requests per module</comment></entry>
    <entry name="SYS_ID2_SPI1"/>
    <entry name="SYS_ID2_SPI2"/>
    <entry name="SYS_ID2_DEBUG_UART"/>
    <entry name="SYS_ID2_UART3"/>
    <entry name="SYS_ID2_UART4"/>
    <entry name="SYS_ID2_UART5"/>
    <entry name="SYS_ID2_SDMMC2"/>
    <entry name="SYS_ID2_I2S"/>
    <entry name="SYS_ID2_RSVD0_0"/>
    <entry name="SYS_ID2_RSVD0_1"/>
    <entry name="SYS_ID2_RSVD0_2"/>
    <entry name="SYS_ID2_RSVD0_3"/>
    <entry name="SYS_ID2_RSVD0_4"/>
    <entry name="SYS_ID2_SYS_IFC2"/>
    <entry name="SYS_ID2_DEBUG_HOST"/>
    <entry name="SYS_ID2_GPIO2"/>
    <entry name="SYS_ID2_GPT2"/>
    <entry name="SYS_ID2_KEYPAD"/>
    <entry name="SYS_ID2_SEG_LCD"/>
    <entry name="SYS_ID2_I2C1"/>
    <entry name="SYS_ID2_I2C2"/>
    <entry name="SYS_ID2_I2C3"/>
    <entry name="SYS_ID2_TIMER2"/>
    <entry name="SYS_ID2_DMA"/>
    <entry name="SYS_ID2_CTRL"/>
    <entry name="SYS_ID2_ROM_PATCH"/>
    <entry name="SYS_ID2_RSVD1_0"/>
    <entry name="SYS_ID2_PSRAM8_CTRL"/>
    <entry name="SYS_ID2_RSVD1_1"/>
    <entry name="SYS_ID2_RSVD1_2"/>
    <entry name="SYS_ID2_RSVD1_3"/>
    <entry name="SYS_ID2_RSVD2_0"/>
    <entry name="SYS_ID2_RSVD2_1"/>
    <entry name="SYS_ID2_RSVD2_2"/>
    <entry name="SYS_ID2_RSVD2_3"/>
    <entry name="SYS_ID2_RSVD2_4"/>
    <entry name="SYS_ID2_RSVD2_5"/>
    <entry name="SYS_ID2_RSVD2_6"/>
    <entry name="SYS_ID2_RSVD2_7"/>
    <entry name="SYS_ID2_RSVD2_8"/>
    <entry name="SYS_ID2_RSVD2_9"/>
    <entry name="SYS_ID2_RSVD2_10"/>
    <entry name="SYS_ID2_RSVD2_11"/>
    <entry name="SYS_ID2_RSVD2_12"/>
    <entry name="SYS_ID2_RSVD2_13"/>
    <entry name="SYS_ID2_RSVD2_14"/>
    <entry name="SYS_ID2_RSVD2_15"/>
    <entry name="SYS_ID2_MED"/>
    <entry name="SYS_ID2_MED_H"/>
    <entry name="SYS_ID2_CE_SEC"/>
    <entry name="SYS_ID2_CE_SEC_H"/>
    <entry name="SYS_ID2_CE_PUB"/>
    <entry name="SYS_ID2_CE_PUB_H"/>
    <entry name="SYS_ID2_EFUSE"/>
    <entry name="SYS_ID2_EFUSE_H"/>
    <entry name="SYS_ID2_RSVD3_0"/>
    <entry name="SYS_ID2_RSVD3_1"/>
    <entry name="SYS_ID2_RSVD3_2"/>
    <entry name="SYS_ID2_RSVD3_3"/>
    <entry name="SYS_ID2_RSVD3_4"/>
    <entry name="SYS_ID2_RSVD3_5"/>
    <entry name="SYS_ID2_SPIFLASH"/>
    <entry name="SYS_ID2_SPIFLASH_EXT"/>
    <entry name="SYS_ID2_ADI_IF"/>
    <entry name="SYS_ID2_ADI_IF_41"/>
    <entry name="SYS_ID2_ADI_IF_42"/>
    <entry name="SYS_ID2_ADI_IF_43"/>
    <entry name="SYS_ID2_ADI_IF_44"/>
    <entry name="SYS_ID2_ADI_IF_45"/>
    <entry name="SYS_ID2_ADI_IF_46"/>
    <entry name="SYS_ID2_ADI_IF_47"/>
    <entry name="SYS_ID2_ADI_IF_48"/>
    <entry name="SYS_ID2_ADI_IF_49"/>
    <entry name="SYS_ID2_ADI_IF_4a"/>
    <entry name="SYS_ID2_ADI_IF_4b"/>
    <entry name="SYS_ID2_ADI_IF_4c"/>
    <entry name="SYS_ID2_ADI_IF_4d"/>
    <entry name="SYS_ID2_ADI_IF_4e"/>
    <entry name="SYS_ID2_ADI_IF_4f"/>
    <entry name="SYS_ID2_ADI_IF_50"/>
    <entry name="SYS_ID2_ADI_IF_51"/>
    <entry name="SYS_ID2_ADI_IF_52"/>
    <entry name="SYS_ID2_ADI_IF_53"/>
    <entry name="SYS_ID2_ADI_IF_54"/>
    <entry name="SYS_ID2_ADI_IF_55"/>
    <entry name="SYS_ID2_ADI_IF_56"/>
    <entry name="SYS_ID2_ADI_IF_57"/>
    <entry name="SYS_ID2_ADI_IF_58"/>
    <entry name="SYS_ID2_ADI_IF_59"/>
    <entry name="SYS_ID2_ADI_IF_5a"/>
    <entry name="SYS_ID2_ADI_IF_5b"/>
    <entry name="SYS_ID2_ADI_IF_5c"/>
    <entry name="SYS_ID2_ADI_IF_5d"/>
    <entry name="SYS_ID2_ADI_IF_5e"/>
    <entry name="SYS_ID2_ADI_IF_5f"/>
    <entry name="SYS_ID2_ADI_IF_60"/>
    <entry name="SYS_ID2_ADI_IF_61"/>
    <entry name="SYS_ID2_ADI_IF_62"/>
    <entry name="SYS_ID2_ADI_IF_63"/>
    <entry name="SYS_ID2_ADI_IF_64"/>
    <entry name="SYS_ID2_ADI_IF_65"/>
    <entry name="SYS_ID2_ADI_IF_66"/>
    <entry name="SYS_ID2_ADI_IF_67"/>
    <entry name="SYS_ID2_ADI_IF_68"/>
    <entry name="SYS_ID2_ADI_IF_69"/>
    <entry name="SYS_ID2_ADI_IF_6a"/>
    <entry name="SYS_ID2_ADI_IF_6b"/>
    <entry name="SYS_ID2_ADI_IF_6c"/>
    <entry name="SYS_ID2_ADI_IF_6d"/>
    <entry name="SYS_ID2_ADI_IF_6e"/>
    <entry name="SYS_ID2_ADI_IF_6f"/>
    <entry name="SYS_ID2_ADI_IF_70"/>
    <entry name="SYS_ID2_ADI_IF_71"/>
    <entry name="SYS_ID2_ADI_IF_72"/>
    <entry name="SYS_ID2_ADI_IF_73"/>
    <entry name="SYS_ID2_ADI_IF_74"/>
    <entry name="SYS_ID2_ADI_IF_75"/>
    <entry name="SYS_ID2_ADI_IF_76"/>
    <entry name="SYS_ID2_ADI_IF_77"/>
    <entry name="SYS_ID2_ADI_IF_78"/>
    <entry name="SYS_ID2_ADI_IF_79"/>
    <entry name="SYS_ID2_ADI_IF_7a"/>
    <entry name="SYS_ID2_ADI_IF_7b"/>
    <entry name="SYS_ID2_ADI_IF_7c"/>
    <entry name="SYS_ID2_ADI_IF_7d"/>
    <entry name="SYS_ID2_ADI_IF_7e"/>
    <entry name="SYS_ID2_ADI_IF_7f"/>
    <entry name="SYS_ID2_MC"/>
    <entry name="SYS_ID2_SFW1"/>
    <entry name="SYS_ID2_SFW2"/>
    <entry name="SYS_ID2_SFW3"/>
    <entry name="SYS_ID2_SFW4"/>
    <entry name="SYS_ID2_SFW5"/>
    <entry name="SYS_ID2_RSVD8_0"/>
    <entry name="SYS_ID2_RSVD8_1"/>
    <entry name="SYS_ID2_RSVD8_2"/>
    <entry name="SYS_ID2_RSVD8_3"/>
    <entry name="SYS_ID2_RSVD8_4"/>
    <entry name="SYS_ID2_RSVD8_5"/>
    <entry name="SYS_ID2_RSVD8_6"/>
    <entry name="SYS_ID2_RSVD8_7"/>
    <entry name="SYS_ID2_RSVD8_8"/>
    <entry name="SYS_ID2_RSVD8_9"/>
    <entry name="SYS_ID2_MFW_NBRAM"/>
    <entry name="SYS_ID2_MFW_NBRAM_H"/>
    <entry name="SYS_ID2_MFW_SRAM0"/>
    <entry name="SYS_ID2_MFW_SRAM0_H"/>
    <entry name="SYS_ID2_MFW_SRAM1"/>
    <entry name="SYS_ID2_MFW_SRAM1_H"/>
    <entry name="SYS_ID2_MFW_SRAM2"/>
    <entry name="SYS_ID2_MFW_SRAM2_H"/>
    <entry name="SYS_ID2_MFW_SRAM3"/>
    <entry name="SYS_ID2_MFW_SRAM3_H"/>
    <entry name="SYS_ID2_MFW_PSRAM"/>
    <entry name="SYS_ID2_MFW_PSRAM_H"/>
    <entry name="SYS_ID2_MFW_FLASH"/>
    <entry name="SYS_ID2_MFW_FLASH_H"/>
    <entry name="SYS_ID2_MFW_FLASH_EXT"/>
    <entry name="SYS_ID2_MFW_FLASH_EXT_H"/>
  </enum>

  
  <enum name="SYS_Ifc1_Request_IDs">
    <entry name="SYS_ID1_TX_UART1"/>      
    <entry name="SYS_ID1_RX_UART1"/>      
    <entry name="SYS_ID1_TX_UART2"/>      
    <entry name="SYS_ID1_RX_UART2"/>      
  </enum>

  
  <enum name="SYS_Ifc2_Request_IDs">
    <entry name="SYS_ID2_TX_SCI2"/>      
    <entry name="SYS_ID2_RX_SCI2"/>      
    <entry name="SYS_ID2_TX_SPI1"/>      
    <entry name="SYS_ID2_RX_SPI1"/>      
    <entry name="SYS_ID2_TX_SPI2"/>      
    <entry name="SYS_ID2_RX_SPI2"/>      
    <entry name="SYS_ID2_TX_DEBUG_UART"/>     
    <entry name="SYS_ID2_RX_DEBUG_UART"/>     
    <entry name="SYS_ID2_TX_UART3"/>     
    <entry name="SYS_ID2_RX_UART3"/>     
    <entry name="SYS_ID2_TX_UART4"/>     
    <entry name="SYS_ID2_RX_UART4"/>     
    <entry name="SYS_ID2_TX_UART5"/>     
    <entry name="SYS_ID2_RX_UART5"/>     
    <entry name="SYS_ID2_TX_SDMMC2"/>    
    <entry name="SYS_ID2_RX_SDMMC2"/>    
    <entry name="SYS_ID2_TX_I2S"/>       
    <entry name="SYS_ID2_RX_I2S"/>       
  </enum>

  
  <enum name="BB_Ifc_Request_IDs">
    <entry name="BB_ID_TX_SCI1"/>      
    <entry name="BB_ID_RX_SCI1"/>      
  </enum>

  
  <enum name="Sys_Irq_Id">
      <entry name="SYS_IRQ_UART1"/>
      <entry name="SYS_IRQ_UART2"/>
      <entry name="SYS_IRQ_GPIO1"/>
      <entry name="SYS_IRQ_GPT1"/>
      <entry name="SYS_IRQ_PWR_CTRL"/>
      <entry name="SYS_IRQ_PMIC"/>
      <entry name="SYS_IRQ_LPS"/>
      <entry name="SYS_IRQ_TIMER1"/>
      <entry name="SYS_IRQ_TIMER1_OS"/>
      <entry name="SYS_IRQ_STAR_FPU"/>
      <entry name="SYS_IRQ_SCI2"/>
      <entry name="SYS_IRQ_SPI1"/>
      <entry name="SYS_IRQ_SPI2"/>
      <entry name="SYS_IRQ_DEBUG_UART"/>
      <entry name="SYS_IRQ_UART3"/>
      <entry name="SYS_IRQ_UART4"/>
      <entry name="SYS_IRQ_UART5"/>
      <entry name="SYS_IRQ_SDMMC2"/>
      <entry name="SYS_IRQ_I2S"/>
      <entry name="SYS_IRQ_DEBUG_HOST"/>
      <entry name="SYS_IRQ_GPIO2"/>
      <entry name="SYS_IRQ_GPT2"/>
      <entry name="SYS_IRQ_KEYPAD"/>
      <entry name="SYS_IRQ_I2C1"/>
      <entry name="SYS_IRQ_I2C2"/>
      <entry name="SYS_IRQ_I2C3"/>
      <entry name="SYS_IRQ_TIMER2"/>
      <entry name="SYS_IRQ_TIMER2_OS"/>
      <entry name="SYS_IRQ_DMA"/>
      <entry name="SYS_IRQ_PSRAM8_CTRL"/>
      <entry name="SYS_IRQ_MED"/>
      <entry name="SYS_IRQ_CE_SEC"/>
      <entry name="SYS_IRQ_CE_PUB"/>
      <entry name="SYS_IRQ_FLASH"/>
      <entry name="SYS_IRQ_FLASH_EXT"/>
      <entry name="SYS_IRQ_ADI_IF"/>
      <entry name="SYS_IRQ_CALIB_32K"/>
      <entry name="SYS_IRQ_CALIB_RC26M"/>
      <entry name="SYS_IRQ_MON_26M"/>
      <entry name="SYS_IRQ_MON_32K"/>
      <entry name="SYS_IRQ_SFW1"/>
      <entry name="SYS_IRQ_SFW2"/>
      <entry name="SYS_IRQ_SFW3"/>
      <entry name="SYS_IRQ_SFW4"/>
      <entry name="SYS_IRQ_SFW5"/>
      <entry name="SYS_IRQ_MFW_NBRAM"/>
      <entry name="SYS_IRQ_MFW_SRAM0"/>
      <entry name="SYS_IRQ_MFW_SRAM1"/>
      <entry name="SYS_IRQ_MFW_SRAM2"/>
      <entry name="SYS_IRQ_MFW_SRAM3"/>
      
      <entry name="SYS_IRQ_RSVD50"/>
      <entry name="SYS_IRQ_MFW_FLASH"/>
      <entry name="SYS_IRQ_MFW_FLASH_EXT"/>
      <entry name="SYS_IRQ_SCI1"/>
      <entry name="SYS_IRQ_NB_RFSPI"/>
      <entry name="SYS_IRQ_NB_TCU_SYNC"/>
      <entry name="SYS_IRQ_RFIF_TX"/>
      <entry name="SYS_IRQ_RFIF_RX"/>
      <entry name="SYS_IRQ_RFIF_DBGNB"/>
      <entry name="SYS_IRQ_DFE_SYNC"/>
      <entry name="SYS_IRQ_NBRX_DSP"/>
      <entry name="SYS_IRQ_NBRX_MCU"/>
      <entry name="SYS_IRQ_NBTX_DSP"/>
      <entry name="SYS_IRQ_NBACC_DSP"/>
      <entry name="SYS_IRQ_F8"/>
      <entry name="SYS_IRQ_INT_SPIAPB2REG"/>
      <entry name="SYS_IRQ_RF_THM"/>
      <entry name="SYS_IRQ_NB_FINT"/>
      <entry name="SYS_IRQ_NB_TCU_0"/>
      <entry name="SYS_IRQ_NB_TCU_1"/>
      <entry name="SYS_IRQ_NB_TCU_2"/>
      <entry name="SYS_IRQ_NB_TCU_3"/>
      <entry name="SYS_IRQ_NB_TCU_4"/>
      <entry name="SYS_IRQ_NB_TCU_5"/>
      <entry name="SYS_IRQ_NB_TCU_6"/>
      <entry name="SYS_IRQ_NB_TCU_7"/>
      <entry name="SYS_IRQ_NB_TCU_8"/>
      <entry name="SYS_IRQ_NB_TCU_9"/>
      <entry name="SYS_IRQ_NB_TCU_10"/>
      <entry name="SYS_IRQ_NB_TCU_11"/>
      <entry name="SYS_IRQ_NB_TCU_12"/>
      <entry name="SYS_IRQ_NB_TCU_13"/>
      <entry name="SYS_IRQ_NB_TCU_14"/>
      <entry name="SYS_IRQ_NB_TCU_15"/>
      <entry name="SYS_IRQ_GPT3"/>
      <entry name="SYS_IRQ_GPT4"/>
      <bound name="SYS_NB_IRQ"><comment>Number of IRQ</comment></bound>
  </enum>

  <var name="BB_NB_BITS_PADDR" value="12"></var>
  <var name="BB_APB_STEP" value="exp2(BB_NB_BITS_PADDR)"/>

  
  <enum name="BB_Module_Id">
    <entry name="BB_ID_SCI1"/>
    <entry name="BB_ID_NB_RF_SPI"/>
    <entry name="BB_ID_NB_TCU"/>
    <entry name="BB_ID_RF_IF"/>
    <entry name="BB_ID_RSVD0_0"/>
    <entry name="BB_ID_RSVD0_1"/>
    <entry name="BB_ID_RSVD0_2"/>
    <entry name="BB_ID_RSVD0_3"/>
    <entry name="BB_ID_RF_INTERFACE"/>
    <entry name="BB_ID_RF_INTERFACE_H"/>
    <entry name="BB_ID_DFE"/>
    <entry name="BB_ID_DFE_H"/>
    <entry name="BB_ID_RFFE"/>
    <entry name="BB_ID_RFFE_H"/>
    <entry name="BB_ID_BB_IFC"/>
    <entry name="BB_ID_RSVD0_5"/>
    <entry name="BB_ID_BB_CTRL"/>
    <entry name="BB_ID_RSVD1_0"/>
    <entry name="BB_ID_RSVD1_1"/>
    <entry name="BB_ID_RSVD1_2"/>
    <entry name="BB_ID_RSVD1_3"/>
    <entry name="BB_ID_RSVD1_4"/>
    <entry name="BB_ID_RSVD1_5"/>
    <entry name="BB_ID_RSVD1_6"/>
    <entry name="BB_ID_RSVD1_7"/>
    <entry name="BB_ID_RSVD1_8"/>
    <entry name="BB_ID_RSVD1_9"/>
    <entry name="BB_ID_RSVD1_10"/>
    <entry name="BB_ID_RSVD1_11"/>
    <entry name="BB_ID_RSVD1_12"/>
    <entry name="BB_ID_RSVD1_13"/>
    <entry name="BB_ID_RSVD1_14"/>
    <entry name="NB_ID_NB_CTRL"/>
    <entry name="NB_ID_COMMON"/>
    <entry name="NB_ID_INTC"/>
    <entry name="NB_ID_CS"/>
    <entry name="NB_ID_FFT"/>
    <entry name="NB_ID_VITERBI"/>
    <entry name="NB_ID_MEAS"/>
    <entry name="NB_ID_DS_BSEL"/>
    <entry name="NB_ID_TX_PUSCH"/>
    <entry name="NB_ID_TX_CHSC"/>
    <entry name="NB_ID_TX_FE"/>
    <entry name="BB_ID_RSVD2_0"/>
    <entry name="BB_ID_RSVD2_1"/>
    <entry name="BB_ID_RSVD2_2"/>
    <entry name="BB_ID_RSVD2_3"/>
    <entry name="BB_ID_RSVD2_4"/>
    <entry name="BB_ID_F8"/>
    <bound name="BB_NB_PSEL"><comment></comment></bound>
  </enum>

  <cjoker>
    /// XHALT macro will send the event 0x4a17 to the debug host and
    /// will stall the XCPU.  The XCPU can be released from Coolwatcher
    /// by issuing a xrbp command.
    #define XHALT { \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        while (hwp_debugHost->event != DEBUG_HOST_EVENT0_SEMA); \
        hwp_debugHost->event = 0x4a17; \
        hwp_sysCtrl->XCpu_Dbg_BKP |= SYS_CTRL_STALLED; \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
    }
  </cjoker>


</archive>

<archive relative = "global_macros.xml" asm="no">

<cjoker>

#define KSEG0(addr)     (addr)
#define KSEG1(addr)     (addr)

#define KSEG01_PHY_ADDR(addr)    ((UINT32)(addr) &amp; 0x0fffffff)

#define barrier() __asm__ __volatile__("": : :"memory")
 
#define REG_ACCESS_ADDRESS(addr)    KSEG1(addr)

/* Define access cached or uncached */
#define MEM_ACCESS_CACHED(addr)     ((UINT32*)((UINT32)(addr)&amp;0xdfffffff))
#define MEM_ACCESS_UNCACHED(addr)   ((UINT32*)((UINT32)(addr)|0x20000000))

/* Register access for assembly */
#define BASE_HI(val) (((0x40000000 | val) &amp; 0xfffff000) + (val &amp; 0x1000))
#define BASE_LO(val) (((val) &amp; 0xfff) - (val &amp; 0x1000))



/* to extract bitfield from register value */
#define GET_BITFIELD(dword, bitfield) (((dword) &amp; (bitfield ## _MASK)) &gt;&gt; (bitfield ## _SHIFT))

#define EXP2(n) (1&lt;&lt;(n))


/// XHALT macro will send the event 0x4a17 to the debug host and
/// will stall the XCPU.  The XCPU can be released from Coolwatcher
/// by issuing a xrbp command.
#define XHALT { \
    asm("nop "); \
    asm("nop "); \
    asm("nop "); \
    asm("nop "); \
    while (hwp_debugHost->event != DEBUG_HOST_EVENT0_SEMA); \
    hwp_debugHost->event = 0x4a17; \
    hwp_sysCtrl->XCpu_Dbg_BKP |= SYS_CTRL_STALLED; \
    asm("nop "); \
    asm("nop "); \
    asm("nop "); \
    asm("nop "); \
}

</cjoker>

</archive>
<archive relative = "adi_mst.xml">
<module name="adi_mst" category="Periph">
    <reg name="adi_version" protect="rw">
        <bits name="adi_version_low"  pos="3:0" access="rw" rst="0">
            <comment> adi low bits version.
            </comment>
        </bits>
        <bits name="adi_version_high" pos="15:4" access="r" rst="0x10">
            <comment> adi high bits version,read only.
            </comment>
        </bits>
    </reg>
        
    <reg name="adi_ctrl" protect="rw">
        <bits name="addr_byte_sel" pos="1:0" access="rw" rst="0">
            <comment> addr mode for access. "00" word mode,means addr[x:2],"01" half word,means addr[x:1], "1x" byte mode, means addr[x:0].
            </comment>
        </bits>
        <bits name="wr_bit_flag" pos="2" access="rw" rst="0">
            <comment> configure write bit flag.
            </comment>
        </bits>
        <bits name="addr_bits_sel" pos="4:3" access="rw" rst="0">
            <comment> addr bit number configure, "00" address is 12 bits, "01" address is 10 bits, "10" address is 15 bits. 
            </comment>
        </bits>
        <bits name="wr_cmd_en" pos="5" access="rw" rst="0">
            <comment>"1" write uses command mode, in this mode, must first configure channel addr, then data.
            </comment>
        </bits>
    </reg>
    <reg name="adi_pril" protect="rw">
        <bits name="chnl0_pri" pos="2:0" access="rw" rst="0">
            <comment> write channel 0 priority. 0 has lowest priority, 4 has highest priority.
            </comment>
        </bits>
        <bits name="chnl1_pri" pos="5:3" access="rw" rst="0">
            <comment> read channel 1 priority. 0 has lowest priority, 4 has highest priority.
            </comment>
        </bits>
        <bits name="event0_pri" pos="8:6" access="rw" rst="0">
            <comment> read channel 2 priority. 0 has lowest priority, 4 has highest priority.
            </comment>
        </bits>
        <bits name="event1_pri" pos="11:9" access="rw" rst="0">
            <comment> read channel 3 priority. 0 has lowest priority, 4 has highest priority.
            </comment>
        </bits>
        <bits name="event2_pri" pos="14:12" access="rw" rst="0">
            <comment> read channel 4 priority. 0 has lowest priority, 4 has highest priority.
            </comment>
        </bits>
        <bits name="event3_pri" pos="17:15" access="rw" rst="0">
            <comment> read channel 5 priority. 0 has lowest priority, 4 has highest priority.
            </comment>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="adi_int_en" protect="rw">
        <bits name="wfifo_en" pos="0" access="rw" rst="0">
            <comment> "1" write command fifo enable.
            </comment>
        </bits>
        <bits name="fifo_overflow_int_en" pos="3" access="rw" rst="0">
            <comment> fifo overfolow interrupt mask.
            </comment>
        </bits>
    </reg>
    <reg name="adi_int_raw" protect="r">
        <bits name="fifo_overflow_raw" pos="3" access="r" rst="0">
            <comment> fifo overfolow interrupt without mask status.
            </comment>
        </bits>
    </reg>
    <reg name="adi_int_status" protect="r">
        <bits name="fifo_overflow_status" pos="3" access="r" rst="0">
            <comment> fifo overfolow interrupt with mask status.
            </comment>
        </bits>
    </reg>
    <reg name="adi_int_clear" protect="w">
        <bits name="fifo_overflow_clear" pos="3" access="w" rst="0">
            <comment> fifo overfolow interrupt clear.
            </comment>
        </bits>
    </reg>
    <reg name="adi_cfg0" protect="rw">
        <bits name="rf_gssi_frame_len" pos="5:0" access="rw" rst="0x1b">
            <comment> total adi frame length = rf_gssi_cmd_len + rf_gssi_data_len.
            </comment>
        </bits>
        <bits name="rf_gssi_cmd_len" pos="10:6" access="rw" rst="0x0b">
            <comment> total adi cmd length = rf_gssi_addr_len + read/write flag.
            </comment>
        </bits>
        <bits name="rf_gssi_data_len" pos="15:11" access="rw" rst="0x10">
            <comment> total adi data length .
            </comment>
        </bits>
        <bits name="rf_gssi_wr_pos" pos="20:16" access="rw" rst="0x10">
            <comment> write bit position in frame stream .
            </comment>
        </bits>
        <bits name="rf_gssi_wr_pol" pos="21" access="rw" rst="0x0">
            <comment> "1" write means 1, "0" write means 0.
            </comment>
        </bits>
        <bits name="rf_gssi_sync_sel" pos="22" access="rw" rst="0x1">
            <comment> "1" hardware auto generate sync, "0" software generates sync.
            </comment>
        </bits>
        <bits name="rf_gssi_sync_mode" pos="23" access="rw" rst="0x1">
            <comment> "1" sync is pulse, "0" sync is level.
            </comment>
        </bits>
        <bits name="rf_gssi_sync" pos="24" access="rw" rst="0x0">
            <comment> "1" software generates sync.
            </comment>
        </bits>
        <bits name="rf_gssi_sck_rev" pos="25" access="rw" rst="0x0">
            <comment> "1" invert output sck.
            </comment>
        </bits>
        <bits name="rf_gssi_oe_cfg" pos="26" access="rw" rst="0x0">
            <comment> output oen : "1" oen add dummy cycle, "0" oen not add dummy cycle.
            </comment>
        </bits>
        <bits name="rf_gssi_ie_cfg" pos="27" access="rw" rst="0x0">
            <comment> reserved.
            </comment>
        </bits>
        <bits name="rf_gssi_dummy_clk_en" pos="28" access="rw" rst="0x1">
            <comment> "1" output dummy_clock, "0" gate dummy clock.
            </comment>
        </bits>
        <bits name="rf_gssi_fast_mode" pos="29" access="rw" rst="0x0">
            <comment> "1" rx sample delay 1 adi clk cycle, "0" delay 0 adi clk cycle.
            </comment>
        </bits>
        <bits name="rf_gssi_sck_all_on" pos="30" access="rw" rst="0x1">
            <comment> "1" sck always on, "0" audo gate  clock.
            </comment>
        </bits>
        <bits name="rf_gssi_wr_disable" pos="31" access="rw" rst="0x0">
            <comment> "1" write bit disable, "0" write bit enable.
            </comment>
        </bits>
    </reg>
    <reg name="adi_cfg1" protect="rw">
        <bits name="rf_gssi_ng_tx" pos="0" access="rw" rst="1">
            <comment> "1" tx data at negedge of sck."0" tx data at posedge of sck.
            </comment>
        </bits>
        <bits name="rf_gssi_ng_rx" pos="1" access="rw" rst="0">
            <comment> "1" rx data at negedge of sck."0" rx data at posedge of sck.
            </comment>
        </bits>
        <bits name="rf_gssi_clk_div" pos="9:2" access="rw" rst="0">
            <comment>  F_sck = F_clk/(2*(rf_gssi_clk_div+1))
            </comment>
        </bits>
        <bits name="rf_gssi_sync_head_len" pos="12:10" access="rw" rst="0">
            <comment> sync before data transfer 
            </comment>
        </bits>
        <bits name="rf_gssi_sync_end_len" pos="15:13" access="rw" rst="0">
            <comment> sync end data transfer 
            </comment>
        </bits>
        <bits name="rf_gssi_dummy_len" pos="19:16" access="rw" rst="0">
            <comment> extral dummy sck 
            </comment>
        </bits>
        <bits name="rf_gssi_sample_delay" pos="20" access="rw" rst="0">
            <comment> extral dummy sck 
            </comment>
        </bits>
        <bits name="rf_gssi_scc_len" pos="23:21" access="rw" rst="0">
            <comment> start sequence condition, only used in RFFE 
            </comment>
        </bits>
        <bits name="rf_gssi_wbp_len" pos="27:24" access="rw" rst="0">
            <comment> master turn around to salve length , only used in RFFE 
            </comment>
        </bits>
        <bits name="rf_gssi_rbp_len" pos="30:28" access="rw" rst="0">
            <comment> slave turn around to master length , only used in RFFE 
            </comment>
        </bits>
        <bits name="rf_gssi_strtbit_mode" pos="31" access="rw" rst="0">
            <comment> "1" 2 wires enable 
            </comment>
        </bits>
    </reg>
    <reg name="arm_rd_cmd" protect="rw">
        <bits name="arm_rd_cmd" pos="16:0" access="rw" rst="0">
            <comment> configure read address and start a read operation.
            </comment>
        </bits>
    </reg>
    <reg name="arm_rd_data" protect="r">
        <bits name="arm_rd_cmd" pos="15:0" access="r" rst="0">
            <comment> read data from analog die.
            </comment>
        </bits>
        <bits name="arm_rd_addr" pos="30:16" access="r" rst="0">
            <comment> read address map to arm_red_cmd[16:2].
            </comment>
        </bits>
        <bits name="arm_rd_cmd_busy" pos="31" access="r" rst="0">
            <comment> 1 means has not been read back.
            </comment>
        </bits>
    </reg>
    <reg name="arm_cmd_status" protect="r">
        <bits name="arm_wr_status" pos="0" access="r" rst="0">
            <comment> "1" write channel is busy 
            </comment>
        </bits>
        <bits name="arm_rd_status" pos="1" access="r" rst="0">
            <comment> "1" read channel is busy 
            </comment>
        </bits>
        <bits name="adi_busy" pos="4" access="r" rst="0">
            <comment> "1" adi operation is busy 
            </comment>
        </bits>
        <bits name="wfifo full" pos="8" access="r" rst="0">
            <comment> wfifo full status 
            </comment>
        </bits>
        <bits name="wfifo empty" pos="9" access="r" rst="0">
            <comment> wfifo empty status 
            </comment>
        </bits>
        <bits name="wfifo fill data level" pos="14:12" access="r" rst="0">
            <comment> wfifo fill data number 
            </comment>
        </bits>
        <bits name="adi fsm status" pos="19:16" access="r" rst="0">
            <comment> adi fsm status 
            </comment>
        </bits>
        <bits name="event0 wr status" pos="20" access="r" rst="0">
            <comment> event 0 wr status 
            </comment>
        </bits>
        <bits name="event1 wr status" pos="21" access="r" rst="0">
            <comment> event 1 wr status 
            </comment>
        </bits>
        <bits name="event2 wr status" pos="22" access="r" rst="0">
            <comment> event 2 wr status 
            </comment>
        </bits>
        <bits name="event3 wr status" pos="23" access="r" rst="0">
            <comment> event 3 wr status 
            </comment>
        </bits>
    </reg>
    <reg name="adi_chanel_en" protect="rw">
        <bits name="event0 trigger negedge en" pos="0" access="rw" rst="0">
            <comment>  
            </comment>
        </bits>
        <bits name="event0 trigger posedge en" pos="1" access="rw" rst="0">
            <comment>  
            </comment>
        </bits>
        <bits name="event1 trigger negedge en" pos="2" access="rw" rst="0">
            <comment>  
            </comment>
        </bits>
        <bits name="event1 trigger posedge en" pos="3" access="rw" rst="0">
            <comment>  
            </comment>
        </bits>
        <bits name="event2 trigger negedge en" pos="4" access="rw" rst="0">
            <comment>  
            </comment>
        </bits>
        <bits name="event2 trigger posedge en" pos="5" access="rw" rst="0">
            <comment>  
            </comment>
        </bits>
        <bits name="event3 trigger negedge en" pos="6" access="rw" rst="0">
            <comment>  
            </comment>
        </bits>
        <bits name="event3 trigger posedge en" pos="7" access="rw" rst="0">
            <comment>  
            </comment>
        </bits>
    </reg>
    
    <reg name="adi_cmd_wr" protect="rw">
        <bits name="adi_cmd_wr" pos="16:0" access="rw" rst="0">
            <comment> the address map to the PMIC chip space, just for write operation 
            </comment>
        </bits>
    </reg>
    <reg name="adi_dat_wr" protect="rw">
        <bits name="adi_dat_wr" pos="15:0" access="rw" rst="0">
            <comment> the dat to the PMIC chip space, just for write operation 
            </comment>
        </bits>
    </reg>
    <reg name="event0_waddr" protect="rw">
        <bits name="event0_waddr" pos="16:0" access="rw" rst="0x634">
            <comment> 
            </comment>
        </bits>
    </reg>
    <reg name="event1_waddr" protect="rw">
        <bits name="event1_waddr" pos="16:0" access="rw" rst="0">
            <comment> 
            </comment>
        </bits>
    </reg>
    <reg name="event2_waddr" protect="rw">
        <bits name="event2_waddr" pos="16:0" access="rw" rst="0">
            <comment> 
            </comment>
        </bits>
    </reg>
    <reg name="event3_waddr" protect="rw">
        <bits name="event3_waddr" pos="16:0" access="rw" rst="0">
            <comment> 
            </comment>
        </bits>
    </reg>
    <reg name="event0_wdata" protect="rw">
        <bits name="event0_neg_wdata" pos="15:0" access="rw" rst="0x0">
            <comment> 
            </comment>
        </bits>
        <bits name="event0_pos_wdata" pos="31:16" access="rw" rst="0x1">
            <comment> 
            </comment>
        </bits>
    </reg>
    <reg name="event1_wdata" protect="rw">
        <bits name="event1_neg_wdata" pos="15:0" access="rw" rst="0x0">
            <comment> 
            </comment>
        </bits>
        <bits name="event1_pos_wdata" pos="31:16" access="rw" rst="0x1">
            <comment> 
            </comment>
        </bits>
    </reg>
    <reg name="event2_wdata" protect="rw">
        <bits name="event2_neg_wdata" pos="15:0" access="rw" rst="0x0">
            <comment> 
            </comment>
        </bits>
        <bits name="event2_pos_wdata" pos="31:16" access="rw" rst="0x1">
            <comment> 
            </comment>
        </bits>
    </reg>
    <reg name="event3_wdata" protect="rw">
        <bits name="event3_neg_wdata" pos="15:0" access="rw" rst="0x0">
            <comment> 
            </comment>
        </bits>
        <bits name="event3_pos_wdata" pos="31:16" access="rw" rst="0x1">
            <comment> 
            </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative = "bb_ctrl.xml">

<module name="bb_ctrl" category="System">

  <reg name="bb_revid" protect="r">
    <bits access="r" name="bb_revid" pos="15:0" rst="0x0">
    </bits>
  </reg>

  <reg name="bb_rst_set0" protect="rw">
    <bits access="rw1s" name="set_rst_rfspi" pos="11:11" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sci1" pos="10:10" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_spiapb2reg" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_rf_interface" pos="7:7" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_dfe" pos="6:6" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_rffe" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_f8" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_tcu" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_rf_if" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_nbiot" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_bb_ifc" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="bb_rst_clr0" protect="rw">
    <bits access="rw1c" name="clr_rst_rfspi" pos="11:11" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sci1" pos="10:10" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_spiapb2reg" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_rf_interface" pos="7:7" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_dfe" pos="6:6" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_rffe" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_f8" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_tcu" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_rf_if" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_nbiot" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_bb_ifc" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="clk_bb_enable0" protect="rw">
    <bits access="rw1s" name="enable_rfspi" pos="11:11" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sci1" pos="10:10" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_spiapb2reg" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_rf_interface" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_dfe" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_rffe" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_f8" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_tcu" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_rf_if" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_nbiot" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_bb_ifc" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_bb_disable0" protect="rw">
    <bits access="rw1c" name="disable_rfspi" pos="11:11" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sci1" pos="10:10" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_spiapb2reg" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_rf_interface" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_dfe" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_rffe" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_f8" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_tcu" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_rf_if" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_nbiot" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_bb_ifc" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="misc_ctrl" protect="rw">
    <bits access="rw" name="hresp_err_mask_bbifc" pos="7:7" rst="0x1">
    </bits>
    <bits access="rw" name="msk_spiapb2reg_int" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1s" name="clr_spiapb2reg_int" pos="5:5" rst="0x0">
    </bits>
    <bits access="r" name="status_spiapb2reg_int" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_nb_tcu" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="ext_xcv_sel" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="mipi_clk_half_sel" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_ctrl" protect="rw">
    <bits access="rw" name="cfg_clkout_sel" pos="3:1" rst="0x0">
    </bits>
    <bits access="rw" name="cfg_clkout_en" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg0" protect="rw">
    <bits access="rw" name="disable_acg0" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg1" protect="rw">
    <bits access="rw" name="disable_acg1" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg2" protect="rw">
    <bits access="rw" name="disable_acg2" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="bb_ctrl_rsd0" protect="rw">
    <bits access="rw" name="bb_ctrl_rsd0" pos="31:0" rst="0xffff0000">
    </bits>
  </reg>

  <reg name="bb_ctrl_rsd1" protect="rw">
    <bits access="rw" name="bb_ctrl_rsd1" pos="31:0" rst="0xffff0000">
    </bits>
  </reg>

  <reg name="bb_ctrl_rsd2" protect="rw">
    <bits access="rw" name="bb_ctrl_rsd2" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="bb_ctrl_rsd3" protect="rw">
    <bits access="rw" name="bb_ctrl_rsd3" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="bb_pad_ctrl" protect="rw">
    <bits access="rw" name="xcv_gpio_ie" pos="14:8" rst="0x7f">
    </bits>
    <bits access="rw" name="xcv_gpio_se" pos="6:0" rst="0x7f">
    </bits>
  </reg>

  <reg name="cfg_clk_rffe" protect="rw">
    <bits access="rw" name="rffe_freq" pos="3:0" rst="0xF">
    </bits>
  </reg>

</module>
</archive>

<archive relative = "bb_ifc.xml">

<include file="globals.xml"/>



<var name="BB_IFC_ADDR_ALIGN" value="0" />

<var name="BB_IFC_TC_LEN" value="23" />

<var name="BB_IFC_STD_CHAN_NB" value="BB_IFC_NB_STD_CHANNEL" /> 

<var name="BB_IFC_RFSPI_CHAN" value="1" />

<var name="BB_IFC_DBG_CHAN" value="0" />

<module name="bb_ifc" category="Baseband">
  

  <reg protect="--" name="get_ch">
    <bits access="r" name="ch_to_use" pos="4:0" rst="0">
      <comment>This field indicates which standard channel to use.
      <br /> Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
      <br /> After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
      <br />Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
      <br />Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
      <br />When non-secure cpu read this register, the return value will automatic exlude the secure channel.
      <br />00000 = use Channel0
      <br />00001 = use Channel1
      <br />00010 = use Channel2 
      <br /> ...
      <br />01111 = use Channel15
      <br />11111 = all channels are busy</comment>
      <options><mask/><shift/><default/></options>
    </bits>
  </reg>

  <reg protect="r" name="dma_status">
    <bits access="r" name="ch_enable" pos="BB_IFC_STD_CHAN_NB+BB_IFC_RFSPI_CHAN-1:0" rst="0">
      <comment>This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
      <br />0000_0000 = All channels disabled 
      <br />0000_0001 = Ch0 enabled 
      <br />0000_0010 = Ch1 enabled 
      <br />0000_0100 = Ch2 enabled 
      <br />0000_0101 = Ch0 and Ch2 enabled 
      <br />0000_0111 = Ch0, Ch1 and Ch2 enabled 
      <br />all 1     = all channels enabled</comment>
    </bits>

    <bits access="r" name="ch_busy" pos="BB_IFC_STD_CHAN_NB-1+16:16" rst="0">
      <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
    </bits>
  </reg>

  <reg protect="r" name="debug_status">
    <bits access="r" name="dbg_status" pos="0" rst="1">
      <comment>Debug Channel Status .<br />0= The debug channel is running
      (not idle) <br />1= The debug channel is in idle mode</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ifc_sec">
    <bits access="rw" name="std_ch_reg_sec" pos="BB_IFC_STD_CHAN_NB-1:0" rst="0">
      <comment>This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
      <br />0000_0000 = All channels registers can be accessed by secure master or non-secure master.
      <br />0000_0001 = Ch0 registers can only be accessed by secure master.
      <br />0000_0010 = Ch1 registers can only be accessed by secure master.
      <br />0000_0100 = Ch2 registers can only be accessed by secure master.
      <br />0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
      <br />0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
      <br /> ......
      <br />all 1 = all channels registers can only be accessed by secure master.</comment>
    </bits>
    <bits access="rw" name="rfspi_ch_reg_sec" pos="BB_IFC_STD_CHAN_NB+BB_IFC_RFSPI_CHAN-1:BB_IFC_STD_CHAN_NB" rst="0">
      <comment>This register indicates rfspi channel register can only be accessed by secure master.</comment>
    </bits>
    <bits access="rw" name="std_ch_dma_sec" pos="BB_IFC_STD_CHAN_NB-1+16:16" rst="all1">
      <comment>This register indicates which channel dma is secure master. One bit per
      channel, for example:
      <br />0000_0000 = All channels dma are non-secure master.
      <br />0000_0001 = Ch0 dma is secure master.
      <br />0000_0010 = Ch1 dma is secure master.
      <br />0000_0100 = Ch2 dma is secure master.
      <br />0000_0101 = Ch0 and Ch2 dma are secure master.
      <br />0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
      <br /> ......
      <br />all 1 = all channels dma are secure master.</comment>
    </bits>
    <bits access="rw" name="rfspi_ch_dma_sec" pos="BB_IFC_STD_CHAN_NB+BB_IFC_RFSPI_CHAN-1+16:BB_IFC_STD_CHAN_NB+16" rst="all1">
      <comment>This register indicates rfspi channel dma is secure master.</comment>
    </bits>
    
  </reg>

  

  

  <struct count="BB_IFC_STD_CHAN_NB" name="std_ch">
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>


      <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
        <comment>Exchange the read data from fifo halfword MSB or LSB
        <br />
    </comment>
      </bits>

      <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
        <comment>Exchange the write data to fifo  halfword MSB or LSB
        <br />
    </comment>
      </bits>


      <bits access="rw" name="autodisable" pos="4" rst="1">
        <comment>Set Auto-disable mode<br /> 0 = when TC reach zero the
        channel is not automatically released.<br /> 1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.</comment>
      </bits>
      
      <bits access="rw" name="Size" pos="5" rst="0">
        <comment>Peripheral Size
            <br /> 0= 8-bit peripheral
            <br /> 1= 32-bit peripheral
        </comment>
      </bits>

      <bits access="rw" name="req_src" pos="12:8" rst="0x1F" display="hex">
        <options linkenum="BB_Ifc_Request_IDs"> 
          
          <shift/><mask/><default/>
        </options>

        <comment>Select DMA Request source</comment>
      </bits>

        <bits access="rw" name="flush" pos="16" rst="0">
        <comment>When one, flush the internal FIFO channel. 
        <br />This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel. 
        <br /> Before writting back this bit to zero the internal fifo must empty.
        </comment>
      </bits>

        <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
        <comment>Set the MAX burst length for channel 0,1. 
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.  
        <br /> The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4. 
        <br /> .
        </comment>



        
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="NB_BITS_ADDR-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB Address. This field represent the start address of the
        transfer.
        <br />For a 32-bit peripheral, this address must be aligned 32-bit.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc">
      <bits access="rw" name="tc" pos="BB_IFC_TC_LEN-1:0" rst="0xFFFFFF" display="hex">
        <comment>Transfer Count, this field indicated the transfer size in bytes to perform.
        <br />During a transfer a write in this register add the new value to the current TC. 
        <br />A read of this register return the current current transfer count.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc_threshold">
      <bits access="rw" name="tc_threshold" pos="BB_IFC_TC_LEN-1:0" rst="0x0" display="hex">
        <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.
        </comment>
      </bits>
    </reg>
  </struct>
  
  

  <struct count="BB_IFC_RFSPI_CHAN" name="rfspi_ch">
  <reg protect="rw" name="ch_rfspi_control">
      <bits access="s" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />This channel works only in fifo mode. </comment>
      </bits>

      <bits access="c" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit to disable the channel.
        </comment>
      </bits>
    </reg>

    <reg protect="r" name="ch_rfspi_status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
      
      <bits access="r" name="fifo_level" pos="12:8" rst="0">
        <comment>Internal fifo level </comment>
      </bits>
    </reg>

    <reg protect="rw" name="ch_rfspi_start_addr">
      <bits access="rw" name="start_AHB_addr"
            pos="NB_BITS_ADDR-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB Start Address. <br />This field represent the start address of the fifo.
                 The start address must 32-bit aligned.
        </comment>
      </bits>
    </reg>
    
    <reg protect="rw" name="ch_rfspi_end_addr">
      <bits access="rw" name="end_AHB_addr"
            pos="NB_BITS_ADDR-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB End Address. <br />This field represent the last address of the fifo (it is the first address not used in the fifo). <br />The end address must 32-bit aligned.
        </comment>
      </bits>
    </reg>


    <reg protect="rw" name="ch_rfspi_tc">
      <bits access="rw" name="tc" pos="13:0" rst="0x0" display="hex">
        <comment>Transfer Count, transfer size in bytes. <br />This bit
        indicated the transfer size in bytes to perform. Up to 16kbytes per
        transfer. <br />During a transfer a write in this register add the new
        value to the current TC. A read of this register return the current
        current transfer count.</comment>
      </bits>
    </reg>
  </struct>
</module>

</archive>
<archive relative="ce_pub_top.xml">
  <module name="ce_pub_top" category="System">
    <reg protect="r" name="ce_debug_dma_status">
      <bits access="r" name="rf_ce_wready" pos="31" rst="0">
        <comment>
          axi write data channel ready
        </comment>
      </bits>
      <bits access="r" name="rf_ce_awready" pos="30" rst="0">
        <comment>
          axi write address channel ready
        </comment>
      </bits>
      <bits access="r" name="rf_ce_arready" pos="29" rst="0">
        <comment>
          axi read address channel ready
        </comment>
      </bits>
      <bits access="r" name="rf_ce_busy" pos="28" rst="0">
        <comment>
          dma is working,and CPU can&apos;t access ce registers except ce_clear register.
        </comment>
      </bits>
      <bits access="r" name="ce_debug_dma_status_reserved_0" pos="27" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_dma_dst_state" pos="26:22" rst="0">
        <comment>
          dma write port state:                                         4&apos;d0: idle                                                           4&apos;d1: write burst calculate                                   4&apos;d2: write burst calculate data number              4&apos;d3: write burst wait enough data                    4&apos;d4: write burst start                                        4&apos;d5: write burst execute                                   4&apos;d6: write burst wait burst end                         4&apos;d7: write burst end
        </comment>
      </bits>
      <bits access="r" name="rf_ce_dma_src_state" pos="21:17" rst="0">
        <comment>
          dma read port state:                                         4&apos;d0: idle                                                           4&apos;d1: read burst wait enough buffer space        4&apos;d2: read burst wait one cycle                         4&apos;d3: read burst start                                        4&apos;d4: read burst execute                                   4&apos;d5: read burst wait burst end                         4&apos;d6: read burst done
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_cmd_fifo_non_empty" pos="16" rst="0">
        <comment>
          fde cmd fifo is non-empty
        </comment>
      </bits>
      <bits access="r" name="rf_ce_cmd_fifo_non_empty" pos="15" rst="0">
        <comment>
          cmd fifo is non-empty
        </comment>
      </bits>
      <bits access="r" name="rf_ce_int_raw_status_vld" pos="14" rst="0">
        <comment>
          interrupt raw status is valid
        </comment>
      </bits>
      <bits access="r" name="rf_ce_dma_err" pos="13" rst="0">
        <comment>
          ce in error status
        </comment>
      </bits>
      <bits access="r" name="rf_ce_dma_main_write_state" pos="12:8" rst="0">
        <comment>
          dma control main write port state:                     5&apos;d0: idle                                                           5&apos;d1: STD hash start                                            5&apos;d2: STD start                                                  5&apos;d3: STD wait done                                          5&apos;d4: STD send done                                        5&apos;d5: STD next state judgement                        5&apos;d6: STD pause                                               5&apos;d7: STD done                                                 5&apos;d8: LLIST check node buffer status               5&apos;d9: LLIST load node                                       5&apos;d10: LLIST load node wait                               5&apos;d11: LLIST load node update parameter       5&apos;d12: LLIST load node done                            5&apos;d13: LLIST hash start                                     5&apos;d14: LLIST start                                             5&apos;d15: LLIST wait done                                     5&apos;d16: LLIST send done                                    5&apos;d17: LLIST next start judgement                    5&apos;d18: LLIST pause                                           5&apos;d19: LLIST done
        </comment>
      </bits>
      <bits access="r" name="rf_ce_dma_pka_main_read_state" pos="7:5" rst="0">
        <comment>
          3&apos;d0: idle                                                      3&apos;d1: pka read instruction start                                                                         3&apos;d2: pka load start                                                                                                    3&apos;d3: pka wait done                                                                                                   3&apos;d4: pka send done                                                                                                 3&apos;d5: pka jump judgement
        </comment>
      </bits>
      <bits access="r" name="rf_ce_dma_main_read_state" pos="4:0" rst="0">
        <comment>
          dma control main read port state:                     5&apos;d0: idle                                                                                                                     5&apos;d1: read key/hmac key/aad start                                                            5&apos;d2: wait read key/hmac key/aad done                                                5&apos;d3: read key/hmac key/aad, send done                                             5&apos;d4: read key/hmac key/aad done                                                          5&apos;d5: STD read start                                                                                                5&apos;d6: STD wait done                                                                                           5&apos;d7: STD send done                                                                                        5&apos;d8: STD done,then judgement                                                               5&apos;d9: STD pause                                                                                                     5&apos;d10: STD done                                                                                                     5&apos;d11: LLIST read list                                                                                                  5&apos;d12: LLIST read list wait done                                                                 5&apos;d13: LLIST read list send done                                                              5&apos;d14: LLIST read list done                                                                            5&apos;d15: LLIST read node                                                                                        5&apos;d16: LLIST read node wait                                                                               5&apos;d17: LLIST read node done                                                                      5&apos;d18: LLIST node execution                                                                                    5&apos;d19: LLIST node execution, wait done                                                   5&apos;d20: LLIST node execution, send done                                             5&apos;d21: LLIST node execution done                                                               5&apos;d22: LLIST judge next state                                                                                    5&apos;d23: LLIST pause                                                                                         5&apos;d24: LLIST done                                                                                                        5&apos;d25: read session key start                                                                                  5&apos;d26: read session key done
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="ce_debug_aes_status">
      <bits access="r" name="ce_debug_aes_status_reserved_0" pos="31:29" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_rdma_data_status" pos="28:27" rst="0">
        <comment>
          rdma data status:                                             2&apos;d0: idle                                                           2&apos;d1: read start                                                 2&apos;d2: read wait                                                  2&apos;d3: read finish
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_wdma_data_status" pos="26:25" rst="0">
        <comment>
          wdma data status:                                             2&apos;d0: idle                                                           2&apos;d1: read start                                                 2&apos;d2: read wait                                                  2&apos;d3: read finish
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_dma_main_read_state" pos="24:20" rst="0">
        <comment>
          dma control main read port state:                     5&apos;d0: idle                                                                                                                     5&apos;d1: read key/hmac key/aad start                                                            5&apos;d2: wait read key/hmac key/aad done                                                5&apos;d3: read key/hmac key/aad, send done                                             5&apos;d4: read key/hmac key/aad done                                                          5&apos;d5: STD read start                                                                                                5&apos;d6: STD wait done                                                                                           5&apos;d7: STD send done                                                                                        5&apos;d8: STD done,then judgement                                                               5&apos;d9: STD pause                                                                                                     5&apos;d10: STD done                                                                                                     5&apos;d11: LLIST read list                                                                                                  5&apos;d12: LLIST read list wait done                                                                 5&apos;d13: LLIST read list send done                                                              5&apos;d14: LLIST read list done                                                                            5&apos;d15: LLIST read node                                                                                        5&apos;d16: LLIST read node wait                                                                               5&apos;d17: LLIST read node done                                                                      5&apos;d18: LLIST node execution                                                                                    5&apos;d19: LLIST node execution, wait done                                                   5&apos;d20: LLIST node execution, send done                                             5&apos;d21: LLIST node execution done                                                               5&apos;d22: LLIST judge next state                                                                                    5&apos;d23: LLIST pause                                                                                         5&apos;d24: LLIST done                                                                                                        5&apos;d25: read session key start                                                                                  5&apos;d26: read session key done
        </comment>
      </bits>
      <bits access="r" name="ce_debug_aes_status_reserved_1" pos="19:18" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_rdma_data_status" pos="17:15" rst="0">
        <comment>
          rdma data status:                                             2&apos;d0: idle                                                           2&apos;d1: read start                                                 2&apos;d2: read wait                                                  2&apos;d3: read finish
        </comment>
      </bits>
      <bits access="r" name="rf_ce_sm4_status" pos="14:12" rst="0">
        <comment>
          sm4 state:                                                         3&apos;d0: idle                                                                 3&apos;d1: generate key                                            3&apos;d2: round start                                                3&apos;d3: rounding                                                   3&apos;d4: xts generate key                                       3&apos;d5: xts round start                                          3&apos;d6: xts rounding                                             3&apos;d7: done
        </comment>
      </bits>
      <bits access="r" name="rf_ce_wdma_data_status" pos="11:10" rst="0">
        <comment>
          wdma data status:                                             2&apos;d0: idle                                                           2&apos;d1: read start                                                 2&apos;d2: read wait                                                  2&apos;d3: read finish
        </comment>
      </bits>
      <bits access="r" name="ce_debug_aes_status_reserved_2" pos="9:8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_aes_status" pos="7:0" rst="0">
        <comment>
          [3:0]: aes read counter;                                    [7:4]: aes work state                                          4&apos;d0: idle                                                           4&apos;d1: key expand                                               4&apos;d2: xts encrypto tweek                                    4&apos;d3: enc/decrpto select                                    4&apos;d4: wait                                                                 4&apos;d5: one block done                                        4&apos;d6: xts encrypto tweek post                            4&apos;d7: xts encrypto tweek pre   &apos;                          4&apos;d8: zero encrypto                                           4&apos;d9: aad ghash                                                4&apos;d10: length ghash                                          4&apos;d11: gcm wait
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="ce_debug_tdes_status">
      <bits access="r" name="ce_debug_tdes_status_reserved_0" pos="31:29" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_tdes_status" pos="28:24" rst="0">
        <comment>
          tdes module status:                                           [3:0]: des run cycle counter &#10;[4]: des key check error
        </comment>
      </bits>
      <bits access="r" name="rf_ce_dma_wvalid_state" pos="23:20" rst="0">
        <comment>
          generate wvalid state:                                       4&apos;d0: idle                                                           4&apos;d1: wait enough data                               4&apos;d2: generate wvalid                                        4&apos;d3: wait enough data when bursting               4&apos;d4: wait wready for next burst data
        </comment>
      </bits>
      <bits access="r" name="rf_ce_efuse_access_status" pos="19:16" rst="0">
        <comment>
          efuse access status:                                         4&apos;d0: idle                                                           4&apos;d1: trng write start                                          4&apos;d2: hmac read start                                        4&apos;d3: hmac session key read start                              4&apos;d4: trng write                                                  4&apos;d5: hmac read                                                4&apos;d6: hmac session key read                             4&apos;d7: cpu access start                                       4&apos;d8: cpu read                                                   4&apos;d9: cpu write                                                   4&apos;d10: symmetric key1 read start                      4&apos;d11: symmetric key2 read start                      4&apos;d12: symmetric key1 read                              4&apos;d13: symmetric key2 read                              4&apos;d14: done
        </comment>
      </bits>
      <bits access="r" name="rf_ce_pka_dma_main_write_state" pos="15:13" rst="0">
        <comment>
          3&apos;d0: idle                                                          3&apos;d1: pka store start                                        3&apos;d2: pka wait done                                         3&apos;d3: pka send done                                       3&apos;d4: pka jump judgement
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_dma_main_write_state" pos="12:8" rst="0">
        <comment>
          dma control main write port state:                     5&apos;d0: idle                                                           5&apos;d1: STD hash start                                            5&apos;d2: STD start                                                  5&apos;d3: STD wait done                                          5&apos;d4: STD send done                                        5&apos;d5: STD next state judgement                        5&apos;d6: STD pause                                               5&apos;d7: STD done                                                 5&apos;d8: LLIST check node buffer status               5&apos;d9: LLIST load node                                       5&apos;d10: LLIST load node wait                               5&apos;d11: LLIST load node update parameter       5&apos;d12: LLIST load node done                            5&apos;d13: LLIST hash start                                     5&apos;d14: LLIST start                                             5&apos;d15: LLIST wait done                                     5&apos;d16: LLIST send done                                    5&apos;d17: LLIST next start judgement                    5&apos;d18: LLIST pause                                           5&apos;d19: LLIST done                                              5&apos;d20: pka store start                                        5&apos;d21: pka wait done                                         5&apos;d22: pka send done                                       5&apos;d23: pka jump judgement
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_aes_status" pos="7:0" rst="0">
        <comment>
          [3:0]: aes read counter;                                    [7:4]: aes work state                                          4&apos;d0: idle                                                           4&apos;d1: key expand                                               4&apos;d2: xts encrypto tweek                                    4&apos;d3: enc/decrpto select                                    4&apos;d4: wait                                                                 4&apos;d5: one block done                                        4&apos;d6: xts encrypto tweek post                            4&apos;d7: xts encrypto tweek pre   &apos;                          4&apos;d8: zero encrypto                                           4&apos;d9: aad ghash                                                4&apos;d10: length ghash                                          4&apos;d11: gcm wait
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="ce_debug_hash_status0">
      <bits access="r" name="rf_ce_hash_status0" pos="31:0" rst="0">
        <comment>
          hash module status:                                          [31:0]: hash register a value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="ce_debug_hash_status1">
      <bits access="r" name="ce_debug_hash_status1_reserved_0" pos="31:10" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_hash_status1" pos="9:0" rst="0">
        <comment>
          hash module status:                                          [2:0]: hash state                                            3&apos;d0: idle          3&apos;d1: data request                        3&apos;d2: no-hmac  3&apos;d3: hmac key                           3&apos;d4: first hmac message                                  3&apos;d5: second hmac message                              3&apos;d6: digest out                                                 [8:3]: hash run cycle
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="ce_clk_en">
      <bits access="r" name="ce_clk_en_reserved_0" pos="31:29" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_clk_en" pos="28" rst="0">
        <comment>
          force fde aes clock enable
        </comment>
      </bits>
      <bits access="r" name="ce_clk_en_reserved_1" pos="27:24" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_chacha_clk_en" pos="23" rst="0">
        <comment>
          force chacha engine clock enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_poly_clk_en" pos="22" rst="0">
        <comment>
          force poly engine clock enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_rng_clk_en" pos="21" rst="0">
        <comment>
          force rng autogate clock enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_clk_en" pos="20" rst="0">
        <comment>
          force aes key expan autogate clock enable
        </comment>
      </bits>
      <bits access="r" name="ce_clk_en_reserved_2" pos="19" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dma_axi_clk_en" pos="18" rst="0">
        <comment>
          force dma axi autogate clock enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dma_ctrl_clk_en" pos="17" rst="0">
        <comment>
          force dma ctrl autogate  clock enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_apb_rf_clk_en" pos="16" rst="0">
        <comment>
          force apb regbank autogate clock enable
        </comment>
      </bits>
      <bits access="r" name="ce_clk_en_reserved_3" pos="15:10" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_ck_en" pos="9" rst="0">
        <comment>
          simon speck clock  enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_pka_ck_en" pos="8" rst="0">
        <comment>
          pka clock enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_chacah_poly_ck_en" pos="7" rst="0">
        <comment>
          chacha poly clock  enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_sm4_ck_en" pos="6" rst="0">
        <comment>
          sm4 clock enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_trng_ck_en" pos="5" rst="0">
        <comment>
          trng clock enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_des_ck_en" pos="4" rst="0">
        <comment>
          des clock  enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_hash_ck_en" pos="3" rst="0">
        <comment>
          hash clock  enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_ck_en" pos="2" rst="0">
        <comment>
          fde aes clock  enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_ck_en" pos="1" rst="0">
        <comment>
          aes clock  enable
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dma_ck_en" pos="0" rst="0">
        <comment>
          dma_main clock enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_int_en">
      <bits access="r" name="ce_int_en_reserved_0" pos="31:22" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_en_len_err_int" pos="21" rst="0">
        <comment>
          enable src/dst length error int
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_en_cmd_done_int" pos="20" rst="0">
        <comment>
          enable one command done int
        </comment>
      </bits>
      <bits access="r" name="ce_int_en_reserved_1" pos="19:18" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_en_len_err_int" pos="17" rst="0">
        <comment>
          enable src/dst length error int
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_en_cmd_done_int" pos="16" rst="0">
        <comment>
          enable one command done int
        </comment>
      </bits>
      <bits access="r" name="ce_int_en_reserved_2" pos="15:6" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_en_tdes_key_err_int" pos="5" rst="0">
        <comment>
          enable tdes key check error int
        </comment>
      </bits>
      <bits access="r" name="ce_int_en_reserved_3" pos="4:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="ce_int_status">
      <bits access="r" name="ce_int_status_reserved_0" pos="31:22" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_en_len_err_status" pos="21" rst="0">
        <comment>
          src/dst length error int status
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_en_cmd_done_status" pos="20" rst="0">
        <comment>
          one command done int status,
        </comment>
      </bits>
      <bits access="r" name="ce_int_status_reserved_1" pos="19:18" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_en_len_err_status" pos="17" rst="0">
        <comment>
          src/dst length error int status
        </comment>
      </bits>
      <bits access="r" name="rf_ce_en_cmd_done_status" pos="16" rst="0">
        <comment>
          one command done int status,
        </comment>
      </bits>
      <bits access="r" name="ce_int_status_reserved_2" pos="15:6" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_tdes_key_err_int_status" pos="5" rst="0">
        <comment>
          ce tdes key check error int status
        </comment>
      </bits>
      <bits access="r" name="ce_int_status_reserved_3" pos="4:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_int_clear">
      <bits access="r" name="ce_int_clear_reserved_0" pos="31:22" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_en_len_err_status" pos="21" rst="0">
        <comment>
          src/dst length error int status
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_en_cmd_done_status" pos="20" rst="0">
        <comment>
          one command done int status,
        </comment>
      </bits>
      <bits access="r" name="ce_int_clear_reserved_1" pos="19:18" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_len_err_int" pos="17" rst="0">
        <comment>
        bit type is changed from wc to rc.

          clear error int status
        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_cmd_done_int" pos="16" rst="0">
        <comment>
        bit type is changed from wc to rc.

          clear one command done int status,
        </comment>
      </bits>
      <bits access="r" name="ce_int_clear_reserved_2" pos="15:6" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_tdes_key_err_int" pos="5" rst="0">
        <comment>
        bit type is changed from wc to rc.

          clear tdes key check error int status
        </comment>
      </bits>
      <bits access="r" name="ce_int_clear_reserved_3" pos="4:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_start">
      <bits access="r" name="ce_start_reserved_0" pos="31:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rc" name="rf_ce_start" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          start ce
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_clear">
      <bits access="r" name="ce_clear_reserved_0" pos="31:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          reset ce status
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_mode">
      <bits access="r" name="ce_aes_mode_reserved_0" pos="31:16" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_key_update_n" pos="15" rst="0">
        <comment>
          1: dont update key, 0: update key
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_xts_iv_rotation" pos="14" rst="1">
        <comment>
          0: rtl rotation, 1: no-rotation
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_key_len_sel" pos="13:12" rst="0">
        <comment>
          00: key 128bits,01:192bits,10,11:256bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_work_mode" pos="11:8" rst="0">
        <comment>
          0000:ECB,0001:CBC,0010:CTR,0011:XTS,0100:CMAC,0101:GCM,0110:GMAC,0111:CCM,1000:CBCMAC,1001:CFB,1010:OFB
        </comment>
      </bits>
      <bits access="r" name="ce_aes_mode_reserved_1" pos="7" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_mac_ctr_inc_mode" pos="6:5" rst="0">
        <comment>
          aes mac ctr inc mode:  00: normal mode; 01: low 64bit is valid
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_enc_dec_sel" pos="4" rst="0">
        <comment>
          0:encode,1:decode
        </comment>
      </bits>
      <bits access="r" name="ce_aes_mode_reserved_2" pos="3:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_en" pos="0" rst="0">
        <comment>
          aes module enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_tdes_mode">
      <bits access="r" name="ce_tdes_mode_reserved_0" pos="31:14" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_tdes_key_evenodd_check_on" pos="13" rst="0">
        <comment>
          0: disable,  1: enable even/odd check
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_tdes_key_even_sel" pos="12" rst="0">
        <comment>
          0:odd check,1:even check
        </comment>
      </bits>
      <bits access="r" name="ce_tdes_mode_reserved_1" pos="11:10" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_tdes_work_mode" pos="9:8" rst="0">
        <comment>
          00:ECB,01:CBC
        </comment>
      </bits>
      <bits access="r" name="ce_tdes_mode_reserved_2" pos="7:5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_tdes_enc_dec_sel" pos="4" rst="0">
        <comment>
          0:encode,1:decode
        </comment>
      </bits>
      <bits access="r" name="ce_tdes_mode_reserved_3" pos="3:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_tdes_en" pos="0" rst="0">
        <comment>
          tdes module enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_hash_mode">
      <bits access="r" name="ce_hash_mode_reserved_0" pos="31:24" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_hash_sha3_shake_out_len" pos="23:16" rst="0">
        <comment>
          sha3 shake out length
        </comment>
      </bits>
      <bits access="r" name="ce_hash_mode_reserved_1" pos="15:14" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_hash_hmac_pad_sel" pos="13:12" rst="0">
        <comment>
          00: normal hash; 01: ipad ;10: opad; 11: reserved
        </comment>
      </bits>
      <bits access="r" name="ce_hash_mode_reserved_2" pos="11:9" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_hash_mode" pos="8:4" rst="0">
        <comment>
          hash work module,                                     &#10;5d0: Doesnt work&#10;5d1: MD5&#10;5d2: SHA-1 mode&#10;5d3: SHA-224 mode&#10;5d4: SHA-256 mode&#10;5d5: SHA-384 mode&#10;5d6: SHA-512 mode&#10;5d7: SHA-512/224 mode&#10;5d8: SHA-512/256 mode&#10;5d9: SM3 mode&#10;5d10: SHA3-224&#10;5d11: SHA3-256&#10;5d12: SHA3-384&#10;5d13: SHA3-512&#10;5d14: SHA3-SHAKE128&#10;5d15: SHA3-SHAKE256
        </comment>
      </bits>
      <bits access="r" name="ce_hash_mode_reserved_3" pos="3:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_hash_en" pos="0" rst="0">
        <comment>
          hash module enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_chacha_poly_mode">
      <bits access="r" name="ce_chacha_poly_mode_reserved_0" pos="31:10" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_chacha_poly_mode" pos="9:8" rst="0">
        <comment>
          00:chacha20 ; 01:poly1305;&#10;10:AEAD_CHACHA20_POLY1305
        </comment>
      </bits>
      <bits access="r" name="ce_chacha_poly_mode_reserved_1" pos="7:5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_chacha_poly_enc_dec_sel" pos="4" rst="0">
        <comment>
          0:encrypt,1:decrypt
        </comment>
      </bits>
      <bits access="r" name="ce_chacha_poly_mode_reserved_2" pos="3:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_chacha_poly_en" pos="0" rst="0">
        <comment>
          chacha poly module enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_simon_speck_mode">
      <bits access="r" name="ce_simon_speck_mode_reserved_0" pos="31:16" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_key_update_n" pos="15" rst="0">
        <comment>
          1: dont update key, 0: update key
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_key_len_sel" pos="14:13" rst="0">
        <comment>
          00: key 128bits,01:192bits,10:256bits
        </comment>
      </bits>
      <bits access="rw" name="ce_simon_speck_mode_reserved_1" pos="12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_work_mode" pos="11:9" rst="0">
        <comment>
          000:ECB,001:CBC,010:CTR,100:CFB,101:OFB
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_sel" pos="8" rst="0">
        <comment>
          0:speck; 1:simon
        </comment>
      </bits>
      <bits access="r" name="ce_simon_speck_mode_reserved_2" pos="7:5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_enc_dec_sel" pos="4" rst="0">
        <comment>
          0:encrypt,1:decrypt
        </comment>
      </bits>
      <bits access="r" name="ce_simon_speck_mode_reserved_3" pos="3:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_en" pos="0" rst="0">
        <comment>
          chacha poly module enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_cfg">
      <bits access="r" name="ce_cfg_reserved_0" pos="31:24" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_src_word_switch" pos="23" rst="0">
        <comment>
          switch source high 32bits and low 32bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dst_word_switch" pos="22" rst="0">
        <comment>
          switch destination high 32bits and low 32bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_src_byte_switch" pos="21" rst="1">
        <comment>
          source data switch of one word
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dst_byte_switch" pos="20" rst="0">
        <comment>
          destination data switch of one word
        </comment>
      </bits>
      <bits access="r" name="ce_cfg_reserved_1" pos="19:18" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_list_update_iv_sec_cnt" pos="17" rst="0">
        <comment>
          list update iv/sec/cnt flag
        </comment>
      </bits>
      <bits access="r" name="rf_ce_list_data_end_flag" pos="16" rst="0">
        <comment>
          data end in link list mode
        </comment>
      </bits>
      <bits access="r" name="rf_ce_list_end_flag" pos="15" rst="0">
        <comment>
          list end flag
        </comment>
      </bits>
      <bits access="r" name="rf_ce_list_aad_flag" pos="14" rst="0">
        <comment>
          0: isn&apos;t aad list 1: is aad list
        </comment>
      </bits>
      <bits access="r" name="rf_ce_list_aad_end_flag" pos="13" rst="0">
        <comment>
          0: aad no-end list 1: aad end list
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_do_wait_bdone" pos="12" rst="1">
        <comment>
          wait axi B channel bready
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_key_in_iram_flag" pos="11" rst="0">
        <comment>
          0:normal mode, 1: iram key or secure ddr key
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_key_in_session_key_flag" pos="10" rst="0">
        <comment>
          0: normal mode, 1: aes/sm4 key from session key
        </comment>
      </bits>
      <bits access="r" name="ce_cfg_reserved_2" pos="9" rst="1">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_key_in_ddr_flag" pos="8" rst="0">
        <comment>
          1: all crypto key in ddr/iram; 0: from registers
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dma_bypass" pos="7" rst="0">
        <comment>
          0:normal mode, 1: bypass ce
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_std_mode_aad_flag" pos="6" rst="0">
        <comment>
          0: std flag 1: std aad flag
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_std_mode_aad_end_flag" pos="5" rst="0">
        <comment>
          0: std aad no-end flag 1: std aad end flag
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_std_mode_end_flag" pos="4" rst="0">
        <comment>
          std end flag
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_cmd_ioc" pos="3" rst="0">
        <comment>
          0: enable cmd int output: 1: don&apos;t output int
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dont_dump_ddr" pos="2" rst="0">
        <comment>
          0: dump from ddr; 1: don&apos;t dump
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dont_rcv_ddr" pos="1" rst="0">
        <comment>
          0: rcv from ddr; 1: don&apos;t rcv
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_link_mode_flag" pos="0" rst="0">
        <comment>
          0:std mode, 1: link mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_src_frag_length">
      <bits access="r" name="ce_src_frag_length_reserved_0" pos="31:28" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_src_addr_hi" pos="27:24" rst="0">
        <comment>
          source address high 4bits; or aes mac aad address high 4bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_src_frag_len" pos="23:0" rst="0">
        <comment>
          source fragment length of each node;  or aes mac aad length
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_dst_frag_length">
      <bits access="r" name="ce_dst_frag_length_reserved_0" pos="31:28" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dst_addr_hi" pos="27:24" rst="0">
        <comment>
          destination address high 4bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dst_frag_len" pos="23:0" rst="0">
        <comment>
          destination fragment length of each node
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_src_addr">
      <bits access="rw" name="rf_ce_src_addr" pos="31:0" rst="0">
        <comment>
          source address; or aes mac aad address
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_dst_addr">
      <bits access="rw" name="rf_ce_dst_addr" pos="31:0" rst="0">
        <comment>
          destination address;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_list_length">
      <bits access="r" name="ce_list_length_reserved_0" pos="31:20" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_list_ptr_hi" pos="19:16" rst="0">
        <comment>
          ce_list_ptr high 4bits
        </comment>
      </bits>
      <bits access="r" name="ce_list_length_reserved_1" pos="15:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_list_len" pos="11:0" rst="0">
        <comment>
          first list length,support max 256 nodes
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_list_ptr">
      <bits access="rw" name="rf_ce_list_ptr" pos="31:0" rst="0">
        <comment>
          first list start address
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_tdes_rsa_key_length">
      <bits access="r" name="ce_aes_tdes_rsa_key_length_reserved_0" pos="31:28" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_tdes_rsa_key_addr_hi" pos="27:24" rst="0">
        <comment>
          aes hmac key address high 4bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_tdes_rsa_key_len" pos="23:0" rst="0">
        <comment>
          aes hmac key length
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_tdes_rsa_key_address">
      <bits access="rw" name="rf_ce_aes_tdes_rsa_key_addr" pos="31:0" rst="0">
        <comment>
          aes rsa  hamc key address;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_tag_length">
      <bits access="r" name="ce_aes_tag_length_reserved_0" pos="31:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_tag_addr_hi" pos="11:8" rst="0">
        <comment>
          aes tag address high 4bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_aes_tag_len" pos="7:0" rst="0">
        <comment>
          aes tag length
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_tag_address">
      <bits access="rw" name="rf_ce_aes_tag_addr_lo" pos="31:0" rst="0">
        <comment>
          aes tag address low 32bits
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iv_sec_cnt0">
      <bits access="rw" name="rf_ce_iv_sec_cnt0" pos="31:0" rst="0">
        <comment>
          iv/sec/cnt shared register for aes;iv[127:0],iv[127:96] in low address,and little-edian
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iv_sec_cnt1">
      <bits access="rw" name="rf_ce_iv_sec_cnt1" pos="31:0" rst="0">
        <comment>
          iv/sec/cnt shared register for aes;iv[95:64]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iv_sec_cnt2">
      <bits access="rw" name="rf_ce_iv_sec_cnt2" pos="31:0" rst="0">
        <comment>
          iv/sec/cnt shared register for aes;iv[63:32]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iv_sec_cnt3">
      <bits access="rw" name="rf_ce_iv_sec_cnt3" pos="31:0" rst="0">
        <comment>
          iv/sec/cnt shared register for aes;iv[31:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key10">
      <bits access="rw" name="rf_ce_aes_des_key10" pos="31:0" rst="0">
        <comment>
          secure read;aes key1/sm4 key1;key[127:0],key[127:96] in low address,and little-edian
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key11">
      <bits access="rw" name="rf_ce_aes_des_key11" pos="31:0" rst="0">
        <comment>
          aes key1/sm4 key1;key[95:64]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key12">
      <bits access="rw" name="rf_ce_aes_des_key12" pos="31:0" rst="0">
        <comment>
          aes key1/sm4 key1;key[63:32]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key13">
      <bits access="rw" name="rf_ce_aes_des_key13" pos="31:0" rst="0">
        <comment>
          aes key1/sm4 key1;key[31:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key14">
      <bits access="rw" name="rf_ce_aes_des_key14" pos="31:0" rst="0">
        <comment>
          aes key1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key15">
      <bits access="rw" name="rf_ce_aes_des_key15" pos="31:0" rst="0">
        <comment>
          aes key1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key16">
      <bits access="rw" name="rf_ce_aes_des_key16" pos="31:0" rst="0">
        <comment>
          aes key1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key17">
      <bits access="rw" name="rf_ce_aes_des_key17" pos="31:0" rst="0">
        <comment>
          aes key1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key20">
      <bits access="rw" name="rf_ce_aes_des_key20" pos="31:0" rst="0">
        <comment>
          aes key2/sm4 key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key21">
      <bits access="rw" name="rf_ce_aes_des_key21" pos="31:0" rst="0">
        <comment>
          aes key2/sm4 key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key22">
      <bits access="rw" name="rf_ce_aes_des_key22" pos="31:0" rst="0">
        <comment>
          aes key2/sm4 key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key23">
      <bits access="rw" name="rf_ce_aes_des_key23" pos="31:0" rst="0">
        <comment>
          aes key2/sm4 key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key24">
      <bits access="rw" name="rf_ce_aes_des_key24" pos="31:0" rst="0">
        <comment>
          aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key25">
      <bits access="rw" name="rf_ce_aes_des_key25" pos="31:0" rst="0">
        <comment>
          aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key26">
      <bits access="rw" name="rf_ce_aes_des_key26" pos="31:0" rst="0">
        <comment>
          aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key27">
      <bits access="rw" name="rf_ce_aes_des_key27" pos="31:0" rst="0">
        <comment>
          aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_sm4_mode">
      <bits access="r" name="ce_sm4_mode_reserved_0" pos="31:13" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_sm4_key_update_n" pos="12" rst="0">
        <comment>
          1: dont update key, 0: update key
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_sm4_xts_inv_rotation" pos="11" rst="1">
        <comment>
          0: rtl rotation, 1: no-rotation
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_sm4_work_mode" pos="10:8" rst="0">
        <comment>
          000:ECB,001:CBC,010:CTR,011:XTS,100:CFB,101:OFB
        </comment>
      </bits>
      <bits access="r" name="ce_sm4_mode_reserved_1" pos="7:5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_sm4_enc_dec_sel" pos="4" rst="0">
        <comment>
          0:encode,1:decode
        </comment>
      </bits>
      <bits access="r" name="ce_sm4_mode_reserved_2" pos="3:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_sm4_en" pos="0" rst="0">
        <comment>
          sm4 module enable
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="ce_ip_version">
      <bits access="r" name="rf_ce_ip_version_hi" pos="31:4" rst="64">
        <comment>
          r4
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_ip_version_lo" pos="3:0" rst="0">
        <comment>
          px
        </comment>
      </bits>
    </reg>
    <hole size="1056"/>
    <reg protect="r" name="ce_pf_calc">
      <bits access="r" name="rf_ce_pf_calc" pos="31:0" rst="0">
        <comment>
          ce performace counter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_user_flag">
      <bits access="r" name="ce_user_flag_reserved_0" pos="31:9" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_pub_priority_vld" pos="8" rst="0">
        <comment>
          when the siganl is high ,then flag the pub aes/sm4/hash is catch the cmd from the pub cmd buf or the pub is working
        </comment>
      </bits>
      <bits access="r" name="ce_user_flag_reserved_1" pos="7:5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_sec_priority_vld" pos="4" rst="0">
        <comment>
          when the siganl is high ,then flag the sec aes/sm4/hash is catch the cmd from the sec cmd buf or the sec is working
        </comment>
      </bits>
      <bits access="r" name="ce_user_flag_reserved_2" pos="3:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_use_flag" pos="0" rst="0">
        <comment>
          ce sec or pub use the ce aes/sm4/hash cicpher module
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_axi_axcache">
      <bits access="r" name="ce_axi_axcache_reserved_0" pos="31:16" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_src_outstanding_num" pos="15:12" rst="7">
        <comment>
          axi read port outstanding number
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dst_outstanding_num" pos="11:8" rst="7">
        <comment>
          axi write port outstanding number
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_axi_awcache" pos="7:4" rst="0">
        <comment>
          axi bus wcache
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_axi_arcache" pos="3:0" rst="0">
        <comment>
          axi bus rcache
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_cmd_stop_ctrl">
      <bits access="r" name="ce_cmd_stop_ctrl_reserved_0" pos="31:23" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rc" name="rf_ce_fde_cmd_stop_clear" pos="22" rst="0">
        <comment>
        bit type is changed from wc to rc.

          fde to restart
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_cmd_stop_status" pos="21" rst="0">
        <comment>
          1: fde stop command is valid
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_cmd_stop" pos="20" rst="0">
        <comment>
          0:fde  to execute next cmd; 1: fde finish current cmd,then stop
        </comment>
      </bits>
      <bits access="r" name="ce_cmd_stop_ctrl_reserved_1" pos="19" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rc" name="rf_ce_cmd_stop_clear" pos="18" rst="0">
        <comment>
        bit type is changed from wc to rc.

          to restart
        </comment>
      </bits>
      <bits access="r" name="rf_ce_cmd_stop_status" pos="17" rst="0">
        <comment>
          1: stop command is valid
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_cmd_stop" pos="16" rst="0">
        <comment>
          0: to execute next cmd; 1: finish current cmd,then stop
        </comment>
      </bits>
      <bits access="r" name="ce_cmd_stop_ctrl_reserved_2" pos="15:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_axi_protect_sel">
      <bits access="r" name="ce_axi_protect_sel_reserved_0" pos="31:16" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="fde_dummy" pos="15:13" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="fde_axi_prot_sel_wtxt" pos="12" rst="0">
        <comment>
          0: non_prot; 1: prot;
        </comment>
      </bits>
      <bits access="rw" name="fde_axi_prot_sel_rtxt" pos="11" rst="0">
        <comment>
          0: non_prot; 1: prot;
        </comment>
      </bits>
      <bits access="rw" name="fde_axi_prot_sel_rlist" pos="10" rst="0">
        <comment>
          0: non_prot; 1: prot;
        </comment>
      </bits>
      <bits access="rw" name="fde_axi_prot_sel_rkey" pos="9" rst="0">
        <comment>
          0: non_prot; 1: prot;
        </comment>
      </bits>
      <bits access="rw" name="fde_axi_prot_sel_en" pos="8" rst="0">
        <comment>
          0: disable fde side sel; 1: enable fde side axi sel
        </comment>
      </bits>
      <bits access="rw" name="pub_dummy" pos="7:5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pub_axi_prot_sel_wtxt" pos="4" rst="0">
        <comment>
          0: non_prot; 1: prot;
        </comment>
      </bits>
      <bits access="rw" name="pub_axi_prot_sel_rtxt" pos="3" rst="0">
        <comment>
          0: non_prot; 1: prot;
        </comment>
      </bits>
      <bits access="rw" name="pub_axi_prot_sel_rlist" pos="2" rst="0">
        <comment>
          0: non_prot; 1: prot;
        </comment>
      </bits>
      <bits access="rw" name="pub_axi_prot_sel_rkey" pos="1" rst="0">
        <comment>
          0: non_prot; 1: prot;
        </comment>
      </bits>
      <bits access="rw" name="pub_axi_prot_sel_en" pos="0" rst="0">
        <comment>
          0: disable pub side sel; 1: enable pub side axi sel
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="ce_pf_calc_high">
      <bits access="r" name="rf_ce_pf_calc_high" pos="31:0" rst="0">
        <comment>
          ce performace counter high 32 bit
        </comment>
      </bits>
    </reg>
    <hole size="3264"/>
    <reg protect="rw" name="ce_session_key0">
      <bits access="rw" name="rf_ce_session_key0" pos="31:0" rst="0">
        <comment>
          secure os; can&apos;t support wrote by commandfifo mode,hash key can&apos;t be from session key
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key1">
      <bits access="rw" name="rf_ce_session_key1" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key2">
      <bits access="rw" name="rf_ce_session_key2" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key3">
      <bits access="rw" name="rf_ce_session_key3" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key4">
      <bits access="rw" name="rf_ce_session_key4" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key5">
      <bits access="rw" name="rf_ce_session_key5" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key6">
      <bits access="rw" name="rf_ce_session_key6" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key7">
      <bits access="rw" name="rf_ce_session_key7" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key0">
      <bits access="rw" name="rf_ce_iram_key0" pos="31:0" rst="0">
        <comment>
          secure os; can&apos;t support wrote by commandfifo mode,hash key can&apos;t be from iram key
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key1">
      <bits access="rw" name="rf_ce_iram_key1" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key2">
      <bits access="rw" name="rf_ce_iram_key2" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key3">
      <bits access="rw" name="rf_ce_iram_key3" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key4">
      <bits access="rw" name="rf_ce_iram_key4" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key5">
      <bits access="rw" name="rf_ce_iram_key5" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key6">
      <bits access="rw" name="rf_ce_iram_key6" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key7">
      <bits access="rw" name="rf_ce_iram_key7" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <hole size="3584"/>
    <reg protect="w" name="ce_cmd_fifo_entry">
      <bits access="w" name="rf_ce_cmd_fifo_entry" pos="31:0" rst="26">
        <comment>
          ce command fifo entry
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="ce_cmd_fifo_status">
      <bits access="r" name="rf_ce_cmd_fifo_status" pos="31:0" rst="26">
        <comment>
          ce command fifo status
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_rcv_addr_lo">
      <bits access="rw" name="rf_ce_rcv_addr_lo" pos="31:0" rst="26">
        <comment>
          ce rcv address lo
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_dump_addr_lo">
      <bits access="rw" name="rf_ce_dump_addr_lo" pos="31:0" rst="26">
        <comment>
          ce dump address lo
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_dump_addr_hi">
      <bits access="r" name="ce_dump_addr_hi_reserved_0" pos="31:8" rst="20">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_dump_addr_hi" pos="7:4" rst="4">
        <comment>
          ce dump address hi
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_rcv_addr_hi" pos="3:0" rst="4">
        <comment>
          ce rcv address hi
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="ce_finish_cmd_cnt">
      <bits access="r" name="rf_ce_finish_cmd_cnt" pos="31:0" rst="26">
        <comment>
          cmd finish counter,cpu read then clear
        </comment>
      </bits>
    </reg>
    <hole size="3904"/>
    <reg protect="w" name="ce_fde_aes_cmd_fifo_entry">
      <bits access="w" name="rf_ce_fde_aes_cmd_fifo_entry" pos="31:0" rst="26">
        <comment>
          ce  fde aes cipher command fifo entry
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="ce_fde_aes_cmd_fifo_status">
      <bits access="r" name="rf_ce_fde_aes_cmd_fifo_status" pos="31:0" rst="26">
        <comment>
          ce  fde aes cipher command fifo status
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_rcv_addr_lo">
      <bits access="rw" name="rf_ce_fde_aes_rcv_addr_lo" pos="31:0" rst="26">
        <comment>
          ce  fde_aes cipher rcv address lo
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_dump_addr_lo">
      <bits access="rw" name="rf_ce_fde_aes_dump_addr_lo" pos="31:0" rst="26">
        <comment>
          ce  fde_aes cipher dump address lo;or aes tag address low 32bits
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_dump_addr_hi">
      <bits access="r" name="ce_fde_aes_dump_addr_hi_reserved_0" pos="31:8" rst="20">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_dump_addr_hi" pos="7:4" rst="4">
        <comment>
          ce  fde_aes cipher dump address hi,or aes tag address high 4bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_rcv_addr_hi" pos="3:0" rst="4">
        <comment>
          ce  fde_aes cipher rcv address hi
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="ce_fde_aes_finish_cmd_cnt">
      <bits access="r" name="rf_ce_fde_aes_finish_cmd_cnt" pos="31:0" rst="26">
        <comment>
          fde_aes cipher cmd finish counter,cpu read then clear
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_start">
      <bits access="r" name="ce_fde_aes_start_reserved_0" pos="31:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rc" name="rf_ce_fde_aes_start" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          start fde_aes cipher ce(TDES/AES/SM4/SM1/SM7/GHASH)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_clear">
      <bits access="r" name="ce_fde_aes_clear_reserved_0" pos="31:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rc" name="rf_ce_fde_aes_clear" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          reset ce fde_aes cipher status
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_mode">
      <bits access="r" name="ce_fde_aes_mode_reserved_0" pos="31:22" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_mac_ctr_inc_mode" pos="21:20" rst="0">
        <comment>
          aes mac ctr inc mode:  00: normal mode; 01: low 64bit is valid
        </comment>
      </bits>
      <bits access="r" name="ce_fde_aes_mode_reserved_1" pos="19:18" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_key_len_sel" pos="17:16" rst="0">
        <comment>
          00: key 128bits,01:192bits,10,11:256bits
        </comment>
      </bits>
      <bits access="r" name="ce_fde_aes_mode_reserved_2" pos="15:13" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_xts_iv_rotation" pos="12" rst="1">
        <comment>
          0: rtl rotation, 1: no-rotation(sm4/aes)
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_work_mode" pos="11:8" rst="0">
        <comment>
          0000:ECB,0001:CBC,0010:CTR,0011:XTS
        </comment>
      </bits>
      <bits access="r" name="ce_fde_aes_mode_reserved_3" pos="7:5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_enc_dec_sel" pos="4" rst="0">
        <comment>
          0:encode,1:decode
        </comment>
      </bits>
      <bits access="r" name="ce_fde_aes_mode_reserved_4" pos="3:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_en" pos="0" rst="0">
        <comment>
          fde_aes cipher module enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_cfg">
      <bits access="r" name="ce_fde_aes_cfg_reserved_0" pos="31:25" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_auto_update_iv_sec_cnt" pos="24" rst="1">
        <comment>
          ce fde iv auto add 1b1 each 512Byte msg
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_src_word_switch" pos="23" rst="0">
        <comment>
          fde_aes switch source high 32bits and low 32bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_dst_word_switch" pos="22" rst="0">
        <comment>
          fde_aes switch destination high 32bits and low 32bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_src_byte_switch" pos="21" rst="1">
        <comment>
          fde_aes cipher source data switch of one byte
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_dst_byte_switch" pos="20" rst="0">
        <comment>
          fde_aes cipher destination data switch of one byte
        </comment>
      </bits>
      <bits access="r" name="ce_fde_aes_cfg_reserved_1" pos="19:18" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_list_update_iv_sec_cnt" pos="17" rst="0">
        <comment>
          list update iv/sec/cnt flag
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_aes_list_data_end_flag" pos="16" rst="0">
        <comment>
          fde_aes cipher data end in link list mode
        </comment>
      </bits>
      <bits access="r" name="rf_ce_fde_aes_list_end_flag" pos="15" rst="0">
        <comment>
          fde_aes cipher list end flag
        </comment>
      </bits>
      <bits access="r" name="ce_fde_aes_cfg_reserved_2" pos="14:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_key_in_iram_flag" pos="11" rst="0">
        <comment>
          0:normal mode, 1: iram key or secure ddr key
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_key_in_session_key_flag" pos="10" rst="0">
        <comment>
          0: normal mode, 1: aes key from session key
        </comment>
      </bits>
      <bits access="r" name="ce_fde_aes_cfg_reserved_3" pos="9" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_key_in_ddr_flag" pos="8" rst="0">
        <comment>
          1: fde_aes cipher all crypto key in ddr/iram,and the iv also come from drr except the link list mode; 0:fde_aes cipher from registers
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_bypass" pos="7" rst="0">
      </bits>
      <bits access="r" name="ce_fde_aes_cfg_reserved_4" pos="6:5" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_std_mode_end_flag" pos="4" rst="0">
        <comment>
          fde_aes cipher std end flag
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_cmd_ioc" pos="3" rst="0">
        <comment>
          0: fde_aes cipher enable cmd int output: 1: don&apos;t output int
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_dont_dump_ddr" pos="2" rst="0">
        <comment>
          0:fde_aes cipher dump from ddr; 1:fde_aes cipher don&apos;t dump
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_dont_rcv_ddr" pos="1" rst="0">
        <comment>
          0:fde_aes cipher rcv from ddr; 1:fde_aes cipher don&apos;t rcv
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_link_mode_flag" pos="0" rst="0">
        <comment>
          0:fde_aes cipher std mode, 1:fde_aes cipher link mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_list_length">
      <bits access="r" name="ce_fde_aes_list_length_reserved_0" pos="31:20" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_list_ptr_hi" pos="19:16" rst="0">
        <comment>
          ce_fde_aes_list_ptr high 4bits
        </comment>
      </bits>
      <bits access="r" name="ce_fde_aes_list_length_reserved_1" pos="15:12" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_list_len" pos="11:0" rst="0">
        <comment>
          fde_aes cipher first list length,support max 40 nodes
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_list_ptr">
      <bits access="rw" name="rf_ce_fde_aes_list_ptr" pos="31:0" rst="0">
        <comment>
          fde_aes cipher first list start address
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_src_frag_length">
      <bits access="rw" name="rf_ce_fde_aes_dst_addr_hi" pos="31:28" rst="0">
        <comment>
          fde_aes cipher destination address high 4bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_src_addr_hi" pos="27:24" rst="0">
        <comment>
          fde_aes cipher source address high 4bits; or aes mac aad address high 4bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_src_frag_len" pos="23:0" rst="0">
        <comment>
          fde_aes cipher source fragment length of each node;  or aes mac aad length
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_src_addr">
      <bits access="rw" name="rf_ce_fde_aes_src_addr" pos="31:0" rst="0">
        <comment>
          fde_aes cipher source address;or aes mac aad address
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_dst_addr">
      <bits access="rw" name="rf_ce_fde_aes_dst_addr" pos="31:0" rst="0">
        <comment>
          fde_aes cipher destination address;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key_length">
      <bits access="r" name="ce_fde_aes_key_length_reserved_0" pos="31:28" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_key_addr_hi" pos="27:24" rst="0">
        <comment>
          fde aes key address high 4bits
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_key_len" pos="23:0" rst="0">
        <comment>
          fde aes key length
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key_address">
      <bits access="rw" name="rf_ce_fde_aes_key_addr" pos="31:0" rst="0">
        <comment>
          fde aes key address;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_dst_ddr_sel">
      <bits access="r" name="ce_fde_aes_dst_ddr_sel_reserved_0" pos="31:1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_dst_ddr_sel" pos="0" rst="0">
        <comment>
          axi awprot under key in iram mode&#10;0: non_sec 1: sec
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_dummy_reg">
      <bits access="r" name="ce_fde_aes_dummy_reg_reserved_0" pos="31:8" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="rf_ce_fde_dummy_reg" pos="7:0" rst="0">
        <comment>
          ce fde aes dummy register
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="ce_fde_iv_sec_cnt0">
      <bits access="rw" name="rf_ce_fde_iv_sec_cnt0" pos="31:0" rst="0">
        <comment>
          iv/sec/cnt shared register for aes;iv[127:0],iv[127:96] in low address,and little-edian,when the key from ddr, the iv also come from ddr,except link list mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iv_sec_cnt1">
      <bits access="rw" name="rf_ce_fde_iv_sec_cnt1" pos="31:0" rst="0">
        <comment>
          iv/sec/cnt shared register for aes ;iv[95:64]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iv_sec_cnt2">
      <bits access="rw" name="rf_ce_fde_iv_sec_cnt2" pos="31:0" rst="0">
        <comment>
          iv/sec/cnt shared register for aes ;iv[63:32]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iv_sec_cnt3">
      <bits access="rw" name="rf_ce_fde_iv_sec_cnt3" pos="31:0" rst="0">
        <comment>
          iv/sec/cnt shared register for aes;iv[31:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key10">
      <bits access="rw" name="rf_ce_fde_aes_key10" pos="31:0" rst="0">
        <comment>
          secure read;fde aes key1key1;key[127:0],key[127:96] in low address,and little-edian
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key11">
      <bits access="rw" name="rf_ce_fde_aes_key11" pos="31:0" rst="0">
        <comment>
          fde aes key1;key[95:64]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key12">
      <bits access="rw" name="rf_ce_fde_aes_key12" pos="31:0" rst="0">
        <comment>
          fde aes key1;key[63:32]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key13">
      <bits access="rw" name="rf_ce_fde_aes_key13" pos="31:0" rst="0">
        <comment>
          fde aes key1;key[31:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key14">
      <bits access="rw" name="rf_ce_fde_aes_key14" pos="31:0" rst="0">
        <comment>
          fde aes key1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key15">
      <bits access="rw" name="rf_ce_fde_aes_key15" pos="31:0" rst="0">
        <comment>
          fde aes key1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key16">
      <bits access="rw" name="rf_ce_fde_aes_key16" pos="31:0" rst="0">
        <comment>
          fde aes key1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key17">
      <bits access="rw" name="rf_ce_fde_aes_key17" pos="31:0" rst="0">
        <comment>
          fde aes key1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key20">
      <bits access="rw" name="rf_ce_fde_aes_key20" pos="31:0" rst="0">
        <comment>
          fde aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key21">
      <bits access="rw" name="rf_ce_fde_aes_key21" pos="31:0" rst="0">
        <comment>
          fde aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key22">
      <bits access="rw" name="rf_ce_fde_aes_key22" pos="31:0" rst="0">
        <comment>
          fde aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key23">
      <bits access="rw" name="rf_ce_fde_aes_key23" pos="31:0" rst="0">
        <comment>
          fde aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key24">
      <bits access="rw" name="rf_ce_fde_aes_key24" pos="31:0" rst="0">
        <comment>
          fde aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key25">
      <bits access="rw" name="rf_ce_fde_aes_key25" pos="31:0" rst="0">
        <comment>
          fde aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key26">
      <bits access="rw" name="rf_ce_fde_aes_key26" pos="31:0" rst="0">
        <comment>
          fde aes key2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_aes_key27">
      <bits access="rw" name="rf_ce_fde_aes_key27" pos="31:0" rst="0">
        <comment>
          fde aes key2
        </comment>
      </bits>
    </reg>
    <hole size="768"/>
    <reg protect="rw" name="ce_fde_session_key0">
      <bits access="rw" name="rf_ce_fde_session_key0" pos="31:0" rst="0">
        <comment>
          secure os; can&apos;t support wrote by commandfifo mode,hash/rc4 key can&apos;t be from session key
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_session_key1">
      <bits access="rw" name="rf_ce_fde_session_key1" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_session_key2">
      <bits access="rw" name="rf_ce_fde_session_key2" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_session_key3">
      <bits access="rw" name="rf_ce_fde_session_key3" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_session_key4">
      <bits access="rw" name="rf_ce_fde_session_key4" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_session_key5">
      <bits access="rw" name="rf_ce_fde_session_key5" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_session_key6">
      <bits access="rw" name="rf_ce_fde_session_key6" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_session_key7">
      <bits access="rw" name="rf_ce_fde_session_key7" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iram_key0">
      <bits access="rw" name="rf_ce_fde_iram_key0" pos="31:0" rst="0">
        <comment>
          secure os; can&apos;t support wrote by commandfifo mode,hash/rc4 key can&apos;t be from iram key
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iram_key1">
      <bits access="rw" name="rf_ce_fde_iram_key1" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iram_key2">
      <bits access="rw" name="rf_ce_fde_iram_key2" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iram_key3">
      <bits access="rw" name="rf_ce_fde_iram_key3" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iram_key4">
      <bits access="rw" name="rf_ce_fde_iram_key4" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iram_key5">
      <bits access="rw" name="rf_ce_fde_iram_key5" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iram_key6">
      <bits access="rw" name="rf_ce_fde_iram_key6" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_fde_iram_key7">
      <bits access="rw" name="rf_ce_fde_iram_key7" pos="31:0" rst="0">
        <comment>
          secure os permited;
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="ce_sec_top.xml">
  <module name="ce_sec_top" category="System">
    <reg protect="r" name="ce_debug_dma_status">
      <bits access="r" name="rf_ce_wready" pos="31" rst="0">
      </bits>
      <bits access="r" name="rf_ce_awready" pos="30" rst="0">
      </bits>
      <bits access="r" name="rf_ce_arready" pos="29" rst="0">
      </bits>
      <bits access="r" name="rf_ce_busy" pos="28" rst="0">
      </bits>
      <bits access="r" name="ce_debug_dma_status_reserved_0" pos="27" rst="0">
      </bits>
      <bits access="r" name="rf_ce_dma_dst_state" pos="26:22" rst="0">
      </bits>
      <bits access="r" name="rf_ce_dma_src_state" pos="21:17" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_cmd_fifo_non_empty" pos="16" rst="0">
      </bits>
      <bits access="r" name="rf_ce_cmd_fifo_non_empty" pos="15" rst="0">
      </bits>
      <bits access="r" name="rf_ce_int_raw_status_vld" pos="14" rst="0">
      </bits>
      <bits access="r" name="rf_ce_dma_err" pos="13" rst="0">
      </bits>
      <bits access="r" name="rf_ce_dma_main_write_state" pos="12:8" rst="0">
      </bits>
      <bits access="r" name="rf_ce_dma_pka_main_read_state" pos="7:5" rst="0">
      </bits>
      <bits access="r" name="rf_ce_dma_main_read_state" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_debug_aes_status">
      <bits access="r" name="ce_debug_aes_status_reserved_0" pos="31:29" rst="0">
      </bits>
      <bits access="r" name="rf_ce_fde_rdma_data_status" pos="28:27" rst="0">
      </bits>
      <bits access="r" name="rf_ce_fde_wdma_data_status" pos="26:25" rst="0">
      </bits>
      <bits access="r" name="rf_ce_fde_dma_main_read_state" pos="24:20" rst="0">
      </bits>
      <bits access="r" name="ce_debug_aes_status_reserved_1" pos="19:18" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rdma_data_status" pos="17:15" rst="0">
      </bits>
      <bits access="r" name="rf_ce_sm4_status" pos="14:12" rst="0">
      </bits>
      <bits access="r" name="rf_ce_wdma_data_status" pos="11:10" rst="0">
      </bits>
      <bits access="r" name="ce_debug_aes_status_reserved_2" pos="9:8" rst="0">
      </bits>
      <bits access="r" name="rf_ce_aes_status" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_debug_tdes_status">
      <bits access="r" name="ce_debug_tdes_status_reserved_0" pos="31:29" rst="0">
      </bits>
      <bits access="r" name="rf_ce_tdes_status" pos="28:24" rst="0">
      </bits>
      <bits access="r" name="rf_ce_dma_wvalid_state" pos="23:20" rst="0">
      </bits>
      <bits access="r" name="rf_ce_efuse_access_status" pos="19:16" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_dma_main_write_state" pos="15:13" rst="0">
      </bits>
      <bits access="r" name="rf_ce_fde_dma_main_write_state" pos="12:8" rst="0">
      </bits>
      <bits access="r" name="rf_ce_fde_aes_status" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_debug_hash_status0">
      <bits access="r" name="rf_ce_hash_status0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_debug_hash_status1">
      <bits access="r" name="ce_debug_hash_status1_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="rf_ce_hash_status1" pos="9:0" rst="0">
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="ce_clk_en">
      <bits access="r" name="ce_clk_en_reserved_0" pos="31:29" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_clk_en" pos="28" rst="0">
      </bits>
      <bits access="r" name="ce_clk_en_reserved_1" pos="27:24" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_chacha_clk_en" pos="23" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_poly_clk_en" pos="22" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_clk_en" pos="21" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_clk_en" pos="20" rst="0">
      </bits>
      <bits access="r" name="ce_clk_en_reserved_2" pos="19" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_dma_axi_clk_en" pos="18" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_dma_ctrl_clk_en" pos="17" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_apb_rf_clk_en" pos="16" rst="0">
      </bits>
      <bits access="r" name="ce_clk_en_reserved_3" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_ck_en" pos="9" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_ck_en" pos="8" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_chacah_poly_ck_en" pos="7" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_sm4_ck_en" pos="6" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_trng_ck_en" pos="5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_des_ck_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_hash_ck_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_fde_aes_ck_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_ck_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_dma_ck_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_int_en">
      <bits access="r" name="ce_int_en_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_pka_len_err_int" pos="14" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_pka_cmd_done_done_int" pos="13" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_pka_find_prime_err_int" pos="12" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_pka_div_zero_err_int" pos="11" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_use_efuse_err_int" pos="10" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_pka_one_cmd_done_int" pos="9" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_pka_store_done_int" pos="8" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_rng_int" pos="7" rst="0">
      </bits>
      <bits access="r" name="ce_int_en_reserved_1" pos="6" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_tdes_key_err_int" pos="5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_len_err_int" pos="4" rst="0">
      </bits>
      <bits access="r" name="ce_int_en_reserved_2" pos="3" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_efs_all_zero_int" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_efs_huk_unstable_int" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_en_cmd_done_int" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_int_status">
      <bits access="r" name="ce_int_status_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_len_err_int_status" pos="14" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_cmd_done_done_int_status" pos="13" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_find_prime_err_flag" pos="12" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_div_zero_err_flag" pos="11" rst="0">
      </bits>
      <bits access="r" name="rf_ce_use_efuse_err_flag" pos="10" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_one_cmd_done_flag" pos="9" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_store_done_flag" pos="8" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_int_status" pos="7" rst="0">
      </bits>
      <bits access="r" name="ce_int_status_reserved_1" pos="6" rst="0">
      </bits>
      <bits access="r" name="rf_ce_tdes_key_err_int_status" pos="5" rst="0">
      </bits>
      <bits access="r" name="rf_ce_len_err_int_status" pos="4" rst="0">
      </bits>
      <bits access="r" name="ce_int_status_reserved_2" pos="3" rst="0">
      </bits>
      <bits access="r" name="rf_ce_efs_all_zero_int_status" pos="2" rst="0">
      </bits>
      <bits access="r" name="rf_ce_efs_huk_unstable_int_status" pos="1" rst="0">
      </bits>
      <bits access="r" name="rf_ce_cmd_done_int_status" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_int_clear">
      <bits access="r" name="ce_int_clear_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_clear_pka_len_err_int" pos="14" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_pka_cmd_done_done_int" pos="13" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_pka_find_prime_err_int" pos="12" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_pka_div_zero_err_int" pos="11" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_use_efuse_err_int" pos="10" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_pka_one_cmd_done_int" pos="9" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_pka_store_done_int" pos="8" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="r" name="ce_int_clear_reserved_1" pos="7" rst="0">
      </bits>
      <bits access="r" name="ce_int_clear_reserved_2" pos="6" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_clear_tdes_key_err_int" pos="5" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_len_err_int" pos="4" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="r" name="ce_int_clear_reserved_3" pos="3" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_clear_efs_all_zero_int" pos="2" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_efs_huk_unstable_int" pos="1" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_clear_cmd_done_int" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_start">
      <bits access="r" name="ce_start_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_start" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_clear">
      <bits access="r" name="ce_clear_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_clear" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_mode">
      <bits access="r" name="ce_aes_mode_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_key_update_n" pos="15" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_xts_iv_rotation" pos="14" rst="1">
      </bits>
      <bits access="rw" name="rf_ce_aes_key_len_sel" pos="13:12" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_work_mode" pos="11:8" rst="0">
      </bits>
      <bits access="r" name="ce_aes_mode_reserved_1" pos="7" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_mac_ctr_inc_mode" pos="6:5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_enc_dec_sel" pos="4" rst="0">
      </bits>
      <bits access="r" name="ce_aes_mode_reserved_2" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_tdes_mode">
      <bits access="r" name="ce_tdes_mode_reserved_0" pos="31:14" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_tdes_key_evenodd_check_on" pos="13" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_tdes_key_even_sel" pos="12" rst="0">
      </bits>
      <bits access="r" name="ce_tdes_mode_reserved_1" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_tdes_work_mode" pos="9:8" rst="0">
      </bits>
      <bits access="r" name="ce_tdes_mode_reserved_2" pos="7:5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_tdes_enc_dec_sel" pos="4" rst="0">
      </bits>
      <bits access="r" name="ce_tdes_mode_reserved_3" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_tdes_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_hash_mode">
      <bits access="r" name="ce_hash_mode_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="rf_hash_sha3_shake_out_len" pos="23:16" rst="0">
      </bits>
      <bits access="r" name="ce_hash_mode_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="rf_hash_hmac_pad_sel" pos="13:12" rst="0">
      </bits>
      <bits access="r" name="ce_hash_mode_reserved_2" pos="11:9" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_hash_mode" pos="8:4" rst="0">
      </bits>
      <bits access="r" name="ce_hash_mode_reserved_3" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_hash_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_chacha_poly_mode">
      <bits access="r" name="ce_chacha_poly_mode_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_chacha_poly_mode" pos="9:8" rst="0">
      </bits>
      <bits access="r" name="ce_chacha_poly_mode_reserved_1" pos="7:5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_chacha_poly_enc_dec_sel" pos="4" rst="0">
      </bits>
      <bits access="r" name="ce_chacha_poly_mode_reserved_2" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_chacha_poly_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_simon_speck_mode">
      <bits access="r" name="ce_simon_speck_mode_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_key_update_n" pos="15" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_key_len_sel" pos="14:13" rst="0">
      </bits>
      <bits access="rw" name="ce_simon_speck_mode_reserved_1" pos="12" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_work_mode" pos="11:9" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_sel" pos="8" rst="0">
      </bits>
      <bits access="r" name="ce_simon_speck_mode_reserved_2" pos="7:5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_enc_dec_sel" pos="4" rst="0">
      </bits>
      <bits access="r" name="ce_simon_speck_mode_reserved_3" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_simon_speck_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_cfg">
      <bits access="r" name="ce_cfg_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_src_word_switch" pos="23" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_dst_word_switch" pos="22" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_src_byte_switch" pos="21" rst="1">
      </bits>
      <bits access="rw" name="rf_ce_dst_byte_switch" pos="20" rst="0">
      </bits>
      <bits access="r" name="ce_cfg_reserved_1" pos="19:18" rst="0">
      </bits>
      <bits access="r" name="rf_ce_list_update_iv_sec_cnt" pos="17" rst="0">
      </bits>
      <bits access="r" name="rf_ce_list_data_end_flag" pos="16" rst="0">
      </bits>
      <bits access="r" name="rf_ce_list_end_flag" pos="15" rst="0">
      </bits>
      <bits access="r" name="rf_ce_list_aad_flag" pos="14" rst="0">
      </bits>
      <bits access="r" name="rf_ce_list_aad_end_flag" pos="13" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_do_wait_bdone" pos="12" rst="1">
      </bits>
      <bits access="rw" name="rf_ce_key_in_iram_flag" pos="11" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_key_in_session_key_flag" pos="10" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_key_in_efuse_flag" pos="9" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_key_in_ddr_flag" pos="8" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_dma_bypass" pos="7" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_std_mode_aad_flag" pos="6" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_std_mode_aad_end_flag" pos="5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_std_mode_end_flag" pos="4" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_cmd_ioc" pos="3" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_dont_dump_ddr" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_dont_rcv_ddr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_link_mode_flag" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_src_frag_length">
      <bits access="r" name="ce_src_frag_length_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_src_addr_hi" pos="27:24" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_src_frag_len" pos="23:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_dst_frag_length">
      <bits access="r" name="ce_dst_frag_length_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_dst_addr_hi" pos="27:24" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_dst_frag_len" pos="23:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_src_addr">
      <bits access="rw" name="rf_ce_src_addr" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_dst_addr">
      <bits access="rw" name="rf_ce_dst_addr" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_list_length">
      <bits access="r" name="ce_list_length_reserved_0" pos="31:20" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_list_ptr_hi" pos="19:16" rst="0">
      </bits>
      <bits access="r" name="ce_list_length_reserved_1" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_list_len" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_list_ptr">
      <bits access="rw" name="rf_ce_list_ptr" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_tdes_rsa_key_length">
      <bits access="r" name="ce_aes_tdes_rsa_key_length_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_tdes_rsa_key_addr_hi" pos="27:24" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_tdes_rsa_key_len" pos="23:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_tdes_rsa_key_address">
      <bits access="rw" name="rf_ce_aes_tdes_rsa_key_addr" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_tag_length">
      <bits access="r" name="ce_aes_tag_length_reserved_0" pos="31:12" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_tag_addr_hi" pos="11:8" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_aes_tag_len" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_tag_address">
      <bits access="rw" name="rf_ce_aes_tag_addr_lo" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iv_sec_cnt0">
      <bits access="rw" name="rf_ce_iv_sec_cnt0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iv_sec_cnt1">
      <bits access="rw" name="rf_ce_iv_sec_cnt1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iv_sec_cnt2">
      <bits access="rw" name="rf_ce_iv_sec_cnt2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iv_sec_cnt3">
      <bits access="rw" name="rf_ce_iv_sec_cnt3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key10">
      <bits access="rw" name="rf_ce_aes_des_key10" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key11">
      <bits access="rw" name="rf_ce_aes_des_key11" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key12">
      <bits access="rw" name="rf_ce_aes_des_key12" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key13">
      <bits access="rw" name="rf_ce_aes_des_key13" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key14">
      <bits access="rw" name="rf_ce_aes_des_key14" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key15">
      <bits access="rw" name="rf_ce_aes_des_key15" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key16">
      <bits access="rw" name="rf_ce_aes_des_key16" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key17">
      <bits access="rw" name="rf_ce_aes_des_key17" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key20">
      <bits access="rw" name="rf_ce_aes_des_key20" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key21">
      <bits access="rw" name="rf_ce_aes_des_key21" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key22">
      <bits access="rw" name="rf_ce_aes_des_key22" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key23">
      <bits access="rw" name="rf_ce_aes_des_key23" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key24">
      <bits access="rw" name="rf_ce_aes_des_key24" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key25">
      <bits access="rw" name="rf_ce_aes_des_key25" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key26">
      <bits access="rw" name="rf_ce_aes_des_key26" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_aes_des_key27">
      <bits access="rw" name="rf_ce_aes_des_key27" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_sm4_mode">
      <bits access="r" name="ce_sm4_mode_reserved_0" pos="31:13" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_sm4_key_update_n" pos="12" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_sm4_xts_inv_rotation" pos="11" rst="1">
      </bits>
      <bits access="rw" name="rf_ce_sm4_work_mode" pos="10:8" rst="0">
      </bits>
      <bits access="r" name="ce_sm4_mode_reserved_1" pos="7:5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_sm4_enc_dec_sel" pos="4" rst="0">
      </bits>
      <bits access="r" name="ce_sm4_mode_reserved_2" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_sm4_en" pos="0" rst="0">
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="ce_ip_version">
      <bits access="r" name="rf_ce_ip_version_hi" pos="31:4" rst="64">
      </bits>
      <bits access="rw" name="rf_ce_ip_version_lo" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_pka_mode">
      <bits access="rw" name="rf_ce_pka_cmd_addr_hi" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_src_word_switch" pos="27" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_dst_word_switch" pos="26" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_src_byte_switch" pos="25" rst="1">
      </bits>
      <bits access="rw" name="rf_ce_pka_dst_byte_switch" pos="24" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_find_prime_num" pos="23:16" rst="255">
      </bits>
      <bits access="r" name="ce_pka_mode_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_reg_num_sel" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_pka_reg_length01">
      <bits access="r" name="ce_pka_reg_length01_reserved_0" pos="31:26" rst="6">
      </bits>
      <bits access="rw" name="rf_ce_pka_reg_length1" pos="25:16" rst="8">
      </bits>
      <bits access="r" name="ce_pka_reg_length01_reserved_1" pos="15:10" rst="6">
      </bits>
      <bits access="rw" name="rf_ce_pka_reg_length0" pos="9:0" rst="8">
      </bits>
    </reg>
    <reg protect="rw" name="ce_pka_reg_length23">
      <bits access="r" name="ce_pka_reg_length23_reserved_0" pos="31:26" rst="6">
      </bits>
      <bits access="rw" name="rf_ce_pka_reg_length3" pos="25:16" rst="8">
      </bits>
      <bits access="r" name="ce_pka_reg_length23_reserved_1" pos="15:10" rst="6">
      </bits>
      <bits access="rw" name="rf_ce_pka_reg_length2" pos="9:0" rst="8">
      </bits>
    </reg>
    <hole size="704"/>
    <reg protect="r" name="ce_pka_inst_pc">
      <bits access="r" name="rf_ce_pka_div_zero_err_flag" pos="31" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_infinity_point_flag" pos="30" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_modinv_err" pos="29" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_addsub_co" pos="28" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_find_prime_err_flag" pos="27" rst="0">
      </bits>
      <bits access="r" name="ce_pka_inst_pc_reserved_0" pos="26" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_one_cmd_done" pos="25" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_store_done" pos="24" rst="0">
      </bits>
      <bits access="r" name="ce_pka_inst_pc_reserved_1" pos="23:17" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_inst_pc" pos="16:0" rst="15">
      </bits>
    </reg>
    <reg protect="r" name="ce_pka_debug0">
      <bits access="r" name="rf_ce_pka_debug0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_pka_debug1">
      <bits access="r" name="rf_ce_pka_debug1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_pka_debug2">
      <bits access="r" name="rf_ce_pka_debug2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_pka_debug3">
      <bits access="r" name="rf_ce_pka_debug3" pos="31:0" rst="0">
      </bits>
    </reg>
    <hole size="96"/>
    <reg protect="r" name="ce_pf_calc">
      <bits access="r" name="rf_ce_pf_calc" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_user_flag">
      <bits access="r" name="ce_user_flag_reserved_0" pos="31:17" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_efuse_double_bit_en" pos="16" rst="1">
      </bits>
      <bits access="r" name="ce_user_flag_reserved_1" pos="15:9" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pub_priority_vld" pos="8" rst="0">
      </bits>
      <bits access="r" name="ce_user_flag_reserved_2" pos="7:5" rst="0">
      </bits>
      <bits access="r" name="rf_ce_sec_priority_vld" pos="4" rst="0">
      </bits>
      <bits access="r" name="ce_user_flag_reserved_3" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_use_flag" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_axi_axcache">
      <bits access="r" name="ce_axi_axcache_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_src_outstanding_num" pos="15:12" rst="7">
      </bits>
      <bits access="rw" name="rf_ce_dst_outstanding_num" pos="11:8" rst="7">
      </bits>
      <bits access="rw" name="rf_ce_axi_awcache" pos="7:4" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_axi_arcache" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_cmd_stop_ctrl">
      <bits access="r" name="ce_cmd_stop_ctrl_reserved_0" pos="31:13" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_pka_cmd_stop_clear" pos="12" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="r" name="ce_cmd_stop_ctrl_reserved_1" pos="11:10" rst="0">
      </bits>
      <bits access="r" name="rf_ce_pka_cmd_stop_status" pos="9" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_cmd_stop" pos="8" rst="0">
      </bits>
      <bits access="r" name="ce_cmd_stop_ctrl_reserved_2" pos="7:5" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_cmd_stop_clear" pos="4" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="r" name="ce_cmd_stop_ctrl_reserved_3" pos="3:2" rst="0">
      </bits>
      <bits access="r" name="rf_ce_cmd_stop_status" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_cmd_stop" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_axi_protect_sel">
      <bits access="r" name="ce_axi_protect_sel_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="pka_dummy" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="pka_axi_prot_sel_st" pos="11" rst="1">
      </bits>
      <bits access="rw" name="pka_axi_prot_sel_ld" pos="10" rst="1">
      </bits>
      <bits access="rw" name="pka_axi_prot_sel_cmd" pos="9" rst="1">
      </bits>
      <bits access="rw" name="pka_axi_prot_sel_en" pos="8" rst="0">
      </bits>
      <bits access="rw" name="sec_dummy" pos="7:5" rst="0">
      </bits>
      <bits access="rw" name="sec_axi_prot_sel_wtxt" pos="4" rst="1">
      </bits>
      <bits access="rw" name="sec_axi_prot_sel_rtxt" pos="3" rst="1">
      </bits>
      <bits access="rw" name="sec_axi_prot_sel_rlist" pos="2" rst="1">
      </bits>
      <bits access="rw" name="sec_axi_prot_sel_rkey" pos="1" rst="1">
      </bits>
      <bits access="rw" name="sec_axi_prot_sel_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_pf_calc_high">
      <bits access="r" name="rf_ce_pf_calc_high" pos="31:0" rst="0">
      </bits>
    </reg>
    <hole size="1216"/>
    <reg protect="rw" name="ce_rng_en">
      <bits access="r" name="ce_rng_en_reserved_0" pos="31:19" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_data_mux_enable" pos="18" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_mux_ring_enable" pos="17" rst="0">
      </bits>
      <bits access="rw" name="rf_rng_auto_enable" pos="16" rst="1">
      </bits>
      <bits access="rw" name="rf_rng_src_sel_enable" pos="15:8" rst="255">
      </bits>
      <bits access="r" name="ce_rng_en_reserved_1" pos="7:5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_trng_ptest_mode_en" pos="4" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_rng_rst_from_cpu" pos="3" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rw" name="rf_ce_rng_src_from_cpu_enable" pos="2" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_trng_src_en" pos="1" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rw" name="rf_ce_rng_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_config">
      <bits access="rw" name="number_of_samples_threshold" pos="31:20" rst="4095">
      </bits>
      <bits access="r" name="ce_rng_config_reserved_0" pos="19:17" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_ptest_data_in" pos="16" rst="0">
      </bits>
      <bits access="r" name="ce_rng_config_reserved_1" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_data_valid_threshold" pos="11:8" rst="3">
      </bits>
      <bits access="rw" name="rf_ce_rng_exotic_fault_rst_sel" pos="7" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_source_sel" pos="6:5" rst="3">
      </bits>
      <bits access="rw" name="rf_ce_rng_data_len_sel" pos="4" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_trng_sel" pos="3" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_ring_sel" pos="2:0" rst="3">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_data">
      <bits access="rw" name="rf_ce_rng_data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_sample_period">
      <bits access="rw" name="rf_ce_rng_first_sample_en" pos="31" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_first_sample_period" pos="30:16" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_second_sample_period" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_post_process_en">
      <bits access="r" name="ce_rng_post_process_en_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_post_eight_en" pos="7" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_post_seven_en" pos="6" rst="1">
      </bits>
      <bits access="rw" name="rf_ce_rng_post_six_en" pos="5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_post_five_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_post_four_en" pos="3" rst="1">
      </bits>
      <bits access="rw" name="rf_ce_rng_post_three_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_post_second_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_post_first_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_rng_work_status">
      <bits access="r" name="rf_ce_rng_rsa_key_gen_rand_num" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="ce_rng_work_status_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_test_result" pos="8" rst="0">
      </bits>
      <bits access="r" name="ce_rng_work_status_reserved_1" pos="7:5" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_fifo_empty" pos="4" rst="1">
      </bits>
      <bits access="r" name="rf_ce_rng_error_fault" pos="3" rst="0">
      </bits>
      <bits access="r" name="rf_rng_rsa_pka_busy" pos="2" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_data_valid" pos="1" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_auto_mode_ongoing" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_timeout_cnt">
      <bits access="rw" name="rf_ce_rng_timeout_cnt" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_int_en">
      <bits access="r" name="ce_rng_int_en_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_sram_short_int_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_timeout_int_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_process2_int_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_process1_int_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_process0_int_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_rng_sts">
      <bits access="r" name="ce_rng_sts_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_sram_short_int_sts" pos="4" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_timeout_int_sts" pos="3" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_process2_int_sts" pos="2" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_process1_int_sts" pos="1" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_process0_int_sts" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_int_clr">
      <bits access="r" name="ce_rng_int_clr_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_rng_clear_sram_short_int" pos="4" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_rng_clear_timeout_int" pos="3" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_rng_clear_process2_int" pos="2" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_rng_clear_process1_int" pos="1" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
      <bits access="rc" name="rf_ce_rng_clear_process0_int" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_mode">
      <bits access="r" name="ce_rng_mode_reserved_0" pos="31:9" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_prng_mode" pos="8" rst="0">
      </bits>
      <bits access="r" name="ce_rng_mode_reserved_1" pos="7:2" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_mode" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_prng_seed_update">
      <bits access="r" name="ce_prng_seed_update_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_prng_seed_update" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_prng_seed_config">
      <bits access="rw" name="rf_ce_prng_seed" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_rng_bit_rate">
      <bits access="r" name="rf_rng_gen_bit_cnt" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="rf_rng_bit_rate" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_sram_data_threshhold">
      <bits access="r" name="ce_rng_sram_data_threshhold_reserved_0" pos="31:4" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_sram_valid_threshholdd" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_rng_sram_data_residue_num">
      <bits access="r" name="ce_rng_sram_data_residue_num_reserved_0" pos="31:4" rst="0">
      </bits>
      <bits access="r" name="rf_ce_rng_sram_data_residue_num" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_exotic_fault_counter_config">
      <bits access="r" name="ce_rng_exotic_fault_counter_config_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_exotic_fault_counter_config" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rng_drbg_seed_cnt">
      <bits access="r" name="ce_rng_drbg_seed_cnt_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_rng_drbg_seed_cnt" pos="15:0" rst="12">
      </bits>
    </reg>
    <hole size="1472"/>
    <reg protect="rw" name="ce_session_key0">
      <bits access="rw" name="rf_ce_session_key0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key1">
      <bits access="rw" name="rf_ce_session_key1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key2">
      <bits access="rw" name="rf_ce_session_key2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key3">
      <bits access="rw" name="rf_ce_session_key3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key4">
      <bits access="rw" name="rf_ce_session_key4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key5">
      <bits access="rw" name="rf_ce_session_key5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key6">
      <bits access="rw" name="rf_ce_session_key6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_session_key7">
      <bits access="rw" name="rf_ce_session_key7" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key0">
      <bits access="rw" name="rf_ce_iram_key0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key1">
      <bits access="rw" name="rf_ce_iram_key1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key2">
      <bits access="rw" name="rf_ce_iram_key2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key3">
      <bits access="rw" name="rf_ce_iram_key3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key4">
      <bits access="rw" name="rf_ce_iram_key4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key5">
      <bits access="rw" name="rf_ce_iram_key5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key6">
      <bits access="rw" name="rf_ce_iram_key6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_iram_key7">
      <bits access="rw" name="rf_ce_iram_key7" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_secure_key_use_way">
      <bits access="rw" name="rf_ce_secure_key_trng_write" pos="31" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_secure_key_cpu_access" pos="30" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_secure_key_len" pos="29:21" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_secure_key2_start_raddr" pos="20:11" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_secure_key1_start_raddr" pos="10:1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_secure_key2_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_huk_key_config">
      <bits access="rw" name="rf_ce_write_efs_addr" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="ce_huk_key_config_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_write_efs_length" pos="7:0" rst="0">
      </bits>
    </reg>
    <hole size="3520"/>
    <reg protect="w" name="ce_cmd_fifo_entry">
      <bits access="w" name="rf_ce_cmd_fifo_entry" pos="31:0" rst="26">
      </bits>
    </reg>
    <reg protect="r" name="ce_cmd_fifo_status">
      <bits access="r" name="rf_ce_cmd_fifo_status" pos="31:0" rst="26">
      </bits>
    </reg>
    <reg protect="rw" name="ce_rcv_addr_lo">
      <bits access="rw" name="rf_ce_rcv_addr_lo" pos="31:0" rst="26">
      </bits>
    </reg>
    <reg protect="rw" name="ce_dump_addr_lo">
      <bits access="rw" name="rf_ce_dump_addr_lo" pos="31:0" rst="26">
      </bits>
    </reg>
    <reg protect="rw" name="ce_dump_addr_hi">
      <bits access="r" name="ce_dump_addr_hi_reserved_0" pos="31:8" rst="20">
      </bits>
      <bits access="rw" name="rf_ce_dump_addr_hi" pos="7:4" rst="4">
      </bits>
      <bits access="rw" name="rf_ce_rcv_addr_hi" pos="3:0" rst="4">
      </bits>
    </reg>
    <reg protect="r" name="ce_finish_cmd_cnt">
      <bits access="r" name="rf_ce_finish_cmd_cnt" pos="31:0" rst="26">
      </bits>
    </reg>
    <hole size="1856"/>
    <reg protect="w" name="ce_pka_cmd_fifo_entry">
      <bits access="w" name="rf_ce_pka_cmd_fifo_entry" pos="31:0" rst="26">
      </bits>
    </reg>
    <reg protect="r" name="ce_pka_cmd_fifo_status">
      <bits access="r" name="rf_ce_pka_cmd_fifo_status" pos="31:0" rst="26">
      </bits>
    </reg>
    <reg protect="rw" name="ce_pka_cmd_addr">
      <bits access="rw" name="rf_ce_pka_cmd_addr" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_pka_store_addr_hi">
      <bits access="r" name="ce_pka_store_addr_hi_reserved_0" pos="31:19" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_store_addr_hi" pos="18:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ce_pka_load_addr_hi">
      <bits access="r" name="ce_pka_load_addr_hi_reserved_0" pos="31:19" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_load_addr_hi" pos="18:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ce_pka_finish_cmd_cnt">
      <bits access="r" name="rf_ce_pka_finish_cmd_cnt" pos="31:0" rst="26">
      </bits>
    </reg>
    <reg protect="rw" name="ce_pka_start">
      <bits access="r" name="ce_pka_start_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_pka_start" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ce_pka_clear">
      <bits access="r" name="ce_pka_clear_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="rf_ce_pka_clear" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="ce_pka_rng_force_ssb_bit">
      <bits access="r" name="ce_pka_rng_force_ssb_bit_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="rf_ce_pka_rng_force_ssb_bit" pos="0" rst="1">
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "debug_host_internals.xml">

<include file="globals.xml"/>

	<module name="debug_host_internal_registers" category="Debug">
		<ireg name="CTRL_SET" protect="rw">
			<comment>General control signals set.</comment>
			<bits name="Debug_Reset" pos="0" rst="0" access="rs">
				<comment>Debug host generated reset. Signal to system control. Active high.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="XCPU_Force_Reset" pos="1" rst="0" access="rs">
				<comment>Force XCPU Reset signal. Active high. Hold XCPU in reset state until this bit is cleared.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_Wakeup" pos="2" rst="0" access="rs">
				<comment>Force wakeup. Active high.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_BP_XCPU" pos="3" rst="0" access="rs">
				<comment>Force XCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by XCPU.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Force_BP_BCPU" pos="4" rst="0" access="rs">
				<comment>Force BCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by BCPU.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="IT_XCPU" pos="5" rst="0" access="rs">
				<comment>When write '1, generate a level IRQ to XCPU. Write '0 is ignored. This IRQ can be cleared by written APB register. When Read, Get the IRQ status.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="IT_BCPU" pos="6" rst="0" access="rs">
				<comment>When write '1', generate a level IRQ to BCPU. Write '0' is ignored. This IRQ can be cleared by written APB register. When Read, Get the IRQ status.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Debug_Port_Lock" pos="7" rst="0" access="rs">
				<comment>Lock Debug port set.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
		</ireg>
		
		<ireg name="CTRL_CLR" protect="rw">
			<comment>General control signals clear.</comment>		
			<bits name="XCPU_Force_Reset" pos="1" rst="0" access="rc">
				<comment>Force XCPU Reset signal. Active high. Hold XCPU in reset state until this bit is cleared.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_Wakeup" pos="2" rst="0" access="rc">
				<comment>Force wakeup. Active high.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_BP_XCPU" pos="3" rst="0" access="rc">
				<comment>Force XCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by XCPU.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>	
			<bits name="Force_BP_BCPU" pos="4" rst="0" access="rc">
				<comment>Force BCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by BCPU.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Debug_Port_Lock" pos="7" rst="0" access="rc">
				<comment>Lock Debug port clear.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>            
		</ireg>

		<ireg name="CLKDIV" protect="rw">
			<comment>Configure Debug UART Clock divider.</comment>
			<bits name="CFG_CLK" pos="5:0" rst="2" access="rw">
				<comment>Debug host clock divider. The serial clock is generated by dividing  14,7456MHz Host Clock by (CFG_CLK+2). So By default, the serial clock is 14,7456MHz / (2+2) = 3,6864 MHz which corresponds to the 921,6K Baud-rate.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
        </ireg>

		<ireg name="CFG" protect="rw">
			<comment>Configure Debug UART.</comment>
			<bits name="Disable_Uart_H" pos="0" rst="0" access="rw">
                <comment>When '1', Disable Normal Uart functional group.
                    <br/>This bit is set to '1' when break.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Disable_IFC_H" pos="1" rst="0" access="rw">
                <comment>When '1', Ignore IFC write and read access so only debug host internal is accessible.
                    <br/>This bit is set to '1' when break.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Debug_Host_Sel" pos="2" rst="0" access="rw">
                <comment>The usage of this bit is deternimed by the specific chip.
                    <br/>Can be used as Debug_Port_Lock register to protect some register change by the regular software while debug hosr is used to set thoses registers to specific values.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Force_Prio_H" pos="7" rst="1" access="rw">
				<comment>When '1', force the Debug Uart to have priority on TX.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>	
        </ireg>
        

		<ireg name="CRC_REG" protect="rw">
			<comment>Status of CRC.</comment>
			<bits name="CRC" pos="0" rst="0" access="rc">
				<comment>This bit represents that an CRC error has occured in commands received by Debug Host. Once set to '1', it will keep the value until this register is clearred by write '1'.<br/>'0' = no CRC error.<br/>'1' = CRC error.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="FC_Fifo_Ovf" pos="1" rst="0" access="r">
				<comment>This bit represents if the 16-byte Flow Control FIFO has an overflow error. This status will be kept until a RX break is received.<br/>'0' = no Flow Control Overflow Error.<br/>'1' = Flow Control Overflow Error.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>
			
		<ireg name="H2P_STATUS" protect="rw">
			<comment>Host write, APB readable register.</comment>
			<bits name="STATUS" pos="7:0" rst="0" access="rw">
				<comment>These bits can be read by APB and write by host. Corresponds to APB register STATUS. They can also be reseted to zeros by APB command. (see details in debug host APB register mapping) <br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>

		<ireg name="P2H_STATUS" protect="rw">
			<comment>APB write, Host readable register.</comment>
			<bits name="STATUS" pos="7:0" rst="0" access="rw">
				<comment>These bits can be written by APB and read by host. Corresponds to APB register STATUS.<br/>Write to Bit 0 can reset the P2H status.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>

        
        
	</module>

</archive>

<archive relative = "debug_host_test_chip.xml">

  <include file="debug_host.xml" />
  <include file="debug_host_internals.xml" />


</archive>


<archive relative = "debug_host.xml">


<module name="debug_host" category="Debug">
  <reg protect="--" name="cmd">
    <bits access="r" name="Addr" pos="28:0" rst="-">
      <comment>Address of data to be read or written. </comment>
    </bits>

    <bits access="r" name="Size" pos="30:29" rst="-">
      <comment>These two bits indicates element data size. <br />
            when "00" = "byte". <br />
            when "01" = "half word". <br />
            when "10" = "word". 
        </comment>
    </bits>

    <bits access="r" name="Write_H" pos="31" rst="-">
      <comment>This bit indicates command is read or write. <br />
        when "0" = "Read". <br />
        when "1" = "Write".  
      </comment>
    </bits>

  </reg>

  <reg protect="--" name="data">
    <bits access="rw" name="data" pos="31:0" rst="-">
      <comment>Those bits are data to be read or written by IFC. </comment>
    </bits>
    
  </reg>

  <reg protect="rw" name="event">
    <bits access="rw" name="event0_sema" pos="0" rst="0">
      <comment>When read, this bit is used for event semaphore. <br />
            '0' = no new event should be programed. <br />
            '1' = no pending event, new event is authorised. <br />
            If host is not enabled, this bit is always '1'. However in this case, 
            any event written will be ignored. <br />
            When Write, this bit is the least significant bit for a 32-bit event.
      </comment>
    </bits>

    <bits access="w" name="event31_1" pos="31:1" rst="-">
      <comment> These bits combined with bit0 consists a 32-bit event number. If a
            new event is written before the previous event has been sent, it will 
            be ignored. 
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="mode">
    <bits access="rw" name="force_on" pos="0" rst="1">
      <comment>When '1', force the debug host on, use clock UART if clock host is not
            detected. </comment>
    </bits>

    <bits access="r" name="Clk_Host_On" pos="1" rst="0">
      <comment>This bit indicates if clock host is detected to be on or not. <br />
            '0' = no clock host. <br />
            '1' = clock host detected. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="h2p_status">
    <bits access="r" name="h2p_status" pos="7:0" rst="0">
      <comment>Status which can be written through debug uart interface into a debug host
            internal register and read by APB. </comment>
      <options>
        <mask/>
        <shift/>
      </options>
    </bits>
    <bits access="w" name="h2p_status_rst" pos="16" rst="0">
      <comment>write in this bit will reset h2p status register. </comment>
    </bits>
  </reg>
  
  <reg protect="rw" name="p2h_status">
    <bits access="rw" name="p2h_status" pos="7:0" rst="0">
      <comment>Status which can be written by APB and read through debug uart interface 
            as a debug host internal register.
      </comment>
    </bits>
  </reg>
  
  <reg protect="r" name="irq">
    <bits access="r" name="xcpu_irq" pos="0" rst="0">
      <comment>when write '1', clear the xcpu irq level which is programmed in a debug host
          internal register, this bit is automatic cleared. <br /> when read, get the xcpu
          irq status. </comment>
    </bits>
    
    <bits access="r" name="bcpu_irq" pos="1" rst="0">
      <comment>when write '1', clear the bcpu irq level which is programmed in a debug host
            internal register, this bit is automatic cleared.<br /> when read, get the bcpu
            irq status.</comment>
    </bits>
    
  </reg>
</module>



</archive>

<archive relative = "debug_uart.xml">
<module name="debug_uart" category="System">
  <var  name="DEBUG_UART_RX_FIFO_SIZE"    value="16"  />
  <var  name="DEBUG_UART_TX_FIFO_SIZE"    value="16"  />
  <var  name="DEBUG_UART_NB_RX_FIFO_BITS" value="4"   />
  <var  name="DEBUG_UART_NB_TX_FIFO_BITS" value="4"   />
  <var  name="ESC_DAT"                    value="92"  />
  
  <reg protect="rw" name="ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Allows to turn off the UART:<br />0 = Disable<br />1 = Enable
      </comment>
    </bits>

    <bits access="rw" name="Data Bits" pos="1" rst="0">
      <options>
        <option name="7_BITS" value="0" />

        <option name="8_BITS" value="1" />

        <default />
      </options>

      <comment>Number of data bits per character (least significant bit
          first):<br />0 = 7 bits<br />1 = 8 bits <br /> This bit will be masked to
          '1' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Tx Stop Bits" pos="2" rst="0">
      <options>
        <option name="1_BIT" value="0" />

        <option name="2_BITS" value="1" />

        <default />
      </options>

      <comment>Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).<br />0 = one stop bit is
      transmitted in the serial data.<br />1 = two stop bits are generated and
      transmitted in the serial data out. <br /> This bit will be masked to
      '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Parity Enable" pos="3" rst="0">
      <options>
        <option name="NO" value="0" />

        <option name="YES" value="1" />

        <default />
      </options>

      <comment> Parity is enabled when this bit is set. <br /> This bit will be masked to
      '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Parity Select" pos="5:4" rst="0">
      <options>
        <option name="ODD" value="0" />

        <option name="EVEN" value="1" />

        <option name="SPACE" value="2" />

        <option name="MARK" value="3" />

        <default />
      </options>

      <comment> Controls the parity format when parity is enabled:<br />00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).<br />01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).<br />10 = a space is
      generated and received as parity bit.<br />11 = a mark is generated and
      received as parity bit. <br /> These bit will be ignored if debug host is
      enabled. </comment>
    </bits>

    <bits access="rw" name="Tx Break Control" pos="6" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
          this bit is cleared.<br /> This bit will be masked to '0' if debug host
          is enabled. </comment>
      <options>
        <option name="OFF" value="0" />
        <option name="ON"  value="1" />
        <default />
      </options>
    </bits>

   <bits access="rw" name="RX FIFO RESET" pos="7" rst="0">
      <comment>reset rx fifo. </comment>
   </bits>

   <bits access="rw" name="TX FIFO RESET" pos="8" rst="0">
      <comment>reset tx fifo. </comment>
   </bits>


    <bits access="rw" name="DMA Mode" pos="9" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC. </comment>
    </bits>

    <bits access="rw" name="SWRX flow ctrl" pos="13:12" rst="1">
        <comment> When this field is "00" and SWTX_flow_Ctrl is also "00", hardwre
            flow ctrl is used. Otherwise, software flow control is used: <br />
            00 = no transmit flow control. <br />
            01 = transmit XON1/XOFF1 as flow control bytes<br />
            10 = transmit XON2/XOFF2 as flow control bytes<br />
            11 = transmit XON1 and XON2/XOFF1 and XOFF2 as flow control bytes<br />
        </comment>
        <options><default/><mask/><shift/></options>
    </bits>

    <bits access="rw" name="SWTX flow ctrl" pos="15:14" rst="1">
        <comment> When this field is "00" and SWRX_flow_Ctrl is also "00", hardwre
            flow ctrl is used. Otherwise, software flow control is used: <br />
            00 = no receive flow control<br />
            01 = receive XON1/XOFF1 as flow control bytes<br />
            10 = receive XON2/XOFF2 as flow control bytes<br />
            11 = receive XON1 and XON2/XOFF1 and XOFF2 as flow control bytes<br />
            <br /> Note: If single XON/XOFF character is used for flow contol, the received 
            XON/XOFF character will not be put into Rx FIFO. This is also the case if XON is
            received when XOFF is expected. <br />
            If double XON/XOFF characters are expected, the XON1/XOFF1 must followed sequently 
            by XON2/XOFF2 to be considered as patterns, which will not be put into Rx FIFO. 
            Otherwise they will be considered as data. This is also the case if XOFF1 is followed
            by character other than XOFF2. <br />
        </comment>
        <options><default/><mask/><shift/></options>
    </bits>

    <bits access="rw" name="BackSlash En" pos="16" rst="1">
        <comment> When soft flow control characters or backslash are encountered in the data file, 
            they will be inverted and a backslash will be added before them. for example, if tx data
            is XON(0x11) with BackSlash_En = '1', then uart will send 5Ch(Backslash) + EEh (~XON).
        </comment>
    </bits>    
    
    <bits access="rw" name="Tx Finish n Wait" pos="19" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>

    <bits access="rw" name="Divisor Mode" pos="20" rst="0">
      <comment>Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.<br />0 =
      (BCLK = SCLK / 4)<br />1 = (BCLK = SCLK / 16) <br /> This bit will be
      masked to '0' if debug host is enabled.</comment>
    </bits>

    <bits access="rw" name="IrDA Enable" pos="21" rst="0">
      <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details). <br /> This bit will be
      masked to '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Rx RTS" pos="22" rst="0">
      <comment>Controls the Uart_RTS output (not directly in auto flow control
      mode).<br />0 = the Uart_RTS will be inactive high<br />1 = the Uart_RTS
      will be active low <br /> This bit will be masked to '1' if debug host is
      enabled. </comment>
      <options>
        <option name="INACTIVE" value="0" />
        <option name="ACTIVE"  value="1" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="Auto Flow Control" pos="23" rst="0">
      <options>       
        <option name="ENABLE" value="1" />
        
        <option name="DISABLE" value="0" />
        
        <default />
      </options>
      <comment>Enables the auto flow control. <br/> 
          In case HW flow control (both swTx_Flow_ctrl=0 and swRx_Flow_Ctrl=0),
          If Auto_Flow_Control is enabled, Uart_RTS is controlled by the Rx RTS bit in 
          CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register). 
          Tx data flow is stopped If Uart_CTS become inactive high.<br/>
          If Auto_Flow_Control is disabled, Uart_RTS is controlled only by the Rx RTS
          bit in CMD_Set register. Uart_CTS will not take effect. <br/><br/>

          In case SW flow control(either swTx_Flow_ctrl/=0 or swRx_Flow_Ctrl/=0),
          If Auto_Flow_Control is enabled, XON/XOFF will be controlled by the Rx RTS bit
          in CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register). <br/>
          If Auto_Flow_Control is disabled, XON/XOFF will be controlled only by Rx RTS bit
          in CMD_Set register. Tx data flow will be stoped when XOFF is received either
          this bit is enable or disabled.<br/>
          <br /> This bit will be masked to '1' if debug host is enabled.
      </comment>
    </bits>

    <bits access="rw" name="Loop Back Mode" pos="24" rst="0">
      <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support). </comment>
    </bits>

    <bits access="rw" name="Rx Lock Err" pos="25" rst="0">
      <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept. <br /> This bit 
      will be masked to '0' if debug host is enabled. </comment>
      <options>
        <option name="DISABLE" value="0" />
        <option name="ENABLE" value="1" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="HST TXD oen" pos="26" rst="0">
      <comment>HST TXD output enable. '0' enable.</comment>
      <options>
        <option name="DISABLE" value="1" />
        <option name="ENABLE" value="0" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="Rx Break Length" pos="31:28" rst="0xF">
      <comment>Length of a break, in number of bits. <br /> This bit will be masked
      to "1011" if debug host is enabled. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Rx Fifo Level" pos="4:0" rst="0">
        <options>
            <mask/>
            <shift/>
        </options>
    <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read. </comment>
    </bits>

    <bits access="r" name="Tx Fifo Level" pos="12:8" rst="0">
         <options>
            <mask/>
            <shift/>
        </options>
      <comment>Those bits indicate the number of data available in the Tx
      Fifo. Those data will be sent. </comment>
    </bits>

    <bits access="r" name="Tx Active" pos="13" rst="0">
      <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface. </comment>
    </bits>

    <bits access="r" name="Rx Active" pos="14" rst="0">
      <comment>This bit indicates that the UART is receiving a byte.
      </comment>
    </bits>

    <bits access="r" name="Rx Overflow Err" pos="16" rst="0">
      <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Tx Overflow Err" pos="17" rst="0">
      <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when 
          the UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Parity Err" pos="18" rst="0">
      <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Framing Err" pos="19" rst="0">
      <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Break Int" pos="20" rst="0">
      <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value. </comment>
    </bits>

    <bits access="r" name="Tx DCTS" pos="24" rst="0">
      <comment>In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0), 
            This bit is set when the Uart_CTS line changed since the last
            time this register has been written. <br/>
            In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0), 
            This bit is set when received XON/XOFF status changed since the last time
            this register has been writtern. <br/>
            This bit is cleared when the UART_STATUS register is written with any value. 
       </comment>
    </bits>

    <bits access="r" name="Tx CTS" pos="25" rst="0">
        <comment>In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0),
            current value of the Uart_CTS line. 
            <br/> '1' = Tx not allowed. 
            <br/> '0' = Tx allowed. 
            <br/>In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0),
            current state of software flow control.
            <br/> '1' = when XOFF received. 
            <br/> '0' = when XON received. 
        </comment>
    </bits>

    <bits access="r" name="Tx Fifo Rsted L" pos="28" rst="0">
      <comment>This bit is set when Tx Fifo Reset command is received by CTRL
      register and is cleared when Tx fifo reset process has finished.      
      </comment>
    </bits>

    <bits access="r" name="Rx Fifo Rsted L" pos="29" rst="0">
      <comment>This bit is set when Rx Fifo Reset command is received by CTRL
      register and is cleared when Rx fifo reset process has finished.      
      </comment>
    </bits>
    
    <bits access="r" name="Enable n finished" pos="30" rst="0">
      <comment>This bit is set when bit enable is changed from '0' to '1' or 
      from '1' to '0', it is cleared when the enable process has finished.      
      </comment>
    </bits>
    
    <bits access="r" name="Clk Enabled" pos="31" rst="0">
      <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      Rx RTS too early.</comment>
    </bits>
  </reg>

  <reg protect="--" name="rxtx_buffer">
    <bits access="r" name="Rx Data" pos="7:0" rst="no">
      <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. </comment>
    </bits>

    <bits access="w" name="Tx Data" pos="7:0" rst="no">
      <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="irq_mask">
    <bits access="rw" name="Tx Modem Status" pos="0" rst="0">
        <comment>Clear to send signal change or XON/XOFF detected. </comment>
    </bits>

    <bits access="rw" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. </comment>
    </bits>

    <bits access="rw" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>Pulse detected on Uart_Dma_Tx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>Pulse detected on Uart_Dma_Rx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
      <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.</comment>
        </bits>

    <bits access="rw" name="XOFF_detected" pos="8" rst="0">
    </bits>
    
  </reg>

  <reg protect="rw" name="irq_cause">
    <bits access="r" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level. </comment>
    </bits>

    <bits access="r" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.
      </comment>
    </bits>

    <bits access="r" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.</comment>
    </bits>

    <bits access="r" name="Tx Modem Status U" pos="16" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Data Available U" pos="17" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed U" pos="18" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Timeout U" pos="19" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Line Err U" pos="20" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Dma Done U" pos="21" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Done U" pos="22" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Timeout U" pos="23" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="triggers">
    <bits access="rw" name="Rx Trigger" pos="3:0" rst="0">
      <comment>Defines the threshold level at which the Data Available
      Interrupt will be generated. <br />The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.</comment>
    </bits>

    <bits access="rw" name="Tx Trigger" pos="7:4" rst="0">
      <comment>Defines the threshold level at which the Data Needed
      Interrupt will be generated.<br />The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.</comment>
    </bits>

    <bits access="rw" name="AFC Level" pos="11:8" rst="0">
      <comment>Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).<br />The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.</comment>
    </bits>
  </reg>
  <reg protect="rw" name="XChar">
    <bits access="rw" name="XON1" pos="7:0" rst="17">
        <comment>XON1 character value. Reset Value is CTRL-Q 0x11.</comment>
    </bits>
    <bits access="rw" name="XOFF1" pos="15:8" rst="19">
        <comment>XOFF1 character value. Reset Value is CTRL-S 0x13</comment>
    </bits>
    <bits access="rw" name="XON2" pos="23:16" rst="0">
        <comment>XON2 character value. </comment>
    </bits>
    <bits access="rw" name="XOFF2" pos="31:24" rst="0">
        <comment>XOFF2 character value. </comment>
    </bits>
    <comment> These characters must respect following constraints: They must be different if used in software control, if BackSlash_En='1', they cannot be '\' and they cannot be complementary to each other, for example neither XON1 = ~XOFF1 nor XON1 = ~'\' is permitted. </comment>
  </reg>
  
</module>
</archive>
<archive relative="dfe.xml">
  <module name="dfe" category="RF_Dig">
    <reg protect="rw" name="general_mode">
      <bits access="r" name="general_mode_reserved_0" pos="15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dfe_dump_sel" pos="14:11" rst="0">
        <comment>
          Dump source selection.
0: dump RX data from DFE
1: dump TX data from BB
2: dump DFE internal RX path data. It works with rxdp_test_dac_sel_rg register 
3: dump DFE internal TX path data. It works with txdp_test_dac_sel_rg register
        </comment>
      </bits>
      <bits access="rw" name="rxtx_switch" pos="10" rst="0">
        <comment>
          RX/TX work mode in DFE:
0: RX
1: TX
        </comment>
      </bits>
      <bits access="rw" name="resetn_cgu" pos="9" rst="1">
        <comment>
          Software reset for CGU, active low.
0: reset
1: no reset
        </comment>
      </bits>
      <bits access="rw" name="resetn_txdp" pos="8" rst="0">
        <comment>
          Software reset for TXDP, active low.
0: reset
1: no reset
        </comment>
      </bits>
      <bits access="rw" name="resetn_rxdp" pos="7" rst="0">
        <comment>
          Software reset for RXDP when reset_mode is 1, active low.
0: reset
1: no reset
        </comment>
      </bits>
      <bits access="rw" name="sw_resetn" pos="6" rst="1">
        <comment>
          SW controlled reset for RXDP when reset_mode is 0, active low.
0: reset
1: no reset
        </comment>
      </bits>
      <bits access="rw" name="reset_mode" pos="5" rst="0">
        <comment>
          Reset source for RXDP.
0: reset from BB TCU event signal with precise timing control
1: reset from register resetn_rxdp
        </comment>
      </bits>
      <bits access="rw" name="clk_fbc_en_mode" pos="4" rst="0">
        <comment>
          PolarIQ mode enable for NB/WT TX
0: PolarIQ disabled
1: PolarIQ enabled
        </comment>
      </bits>
      <bits access="r" name="general_mode_reserved_1" pos="3:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="general_mode_reserved_2" pos="1:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clock_ctrl">
      <bits access="r" name="clock_ctrl_reserved_0" pos="15:13" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_mode" pos="12" rst="0">
        <comment>
          0: RX CIC1 doesn't work in loft mode; 1: RX CIC1 works in loft mode
        </comment>
      </bits>
      <bits access="rw" name="sel_clk_61p44m_bb" pos="11" rst="0">
        <comment>
          clock select for BB NB  or dump.
0: 61.44MHz
1: 26MHz 
        </comment>
      </bits>
      <bits access="rw" name="reg_clkgate_en" pos="10" rst="0">
        <comment>
          0: registers module clk gating enabled; 1: registers module clk always on
        </comment>
      </bits>
      <bits access="rw" name="clk_dac_inv_mode" pos="9" rst="0">
        <comment>
          Invert DAC clock or not.
0: clk_dac is not inverted
1: clk_dac is inverted
        </comment>
      </bits>
      <bits access="rw" name="clk_adc_inv_mode" pos="8" rst="0">
        <comment>
          Invert ADC clock or not.
0: clk_adc is not inverted
1: clk_adc is inverted
        </comment>
      </bits>
      <bits access="rw" name="clk_rate_convert_rg" pos="7" rst="0">
        <comment>
          DFE clock shift control.
0: clock shift disabled
1: clock shift enabled. When it is enabled, all DFE clocks except GSM TX clock are working in 17/16 normal frequency
        </comment>
      </bits>
      <bits access="r" name="clock_ctrl_reserved_1" pos="6" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="clk_61p44m_en" pos="5" rst="1">
        <comment>
          clock enable for BB NB/WT 61.44MHz
        </comment>
      </bits>
      <bits access="rw" name="txdp_nb_dfe_clk_en" pos="4" rst="0">
        <comment>
          clock enable for DFE NB/WT TX
        </comment>
      </bits>
      <bits access="r" name="clock_ctrl_reserved_2" pos="3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_dfe_clk_en" pos="2" rst="0">
        <comment>
          clock enable for DFE RX
        </comment>
      </bits>
      <bits access="rw" name="txdp_clk_dac_en" pos="1" rst="0">
        <comment>
          clock enable for DFE DAC
        </comment>
      </bits>
      <bits access="rw" name="rxdp_adc_clk_en" pos="0" rst="0">
        <comment>
          clock enable for DFE ADC.
0: clock disabled
1: clock enabled
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dcc">
      <bits access="r" name="rxdp_dcc_reserved_0" pos="15:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_dcc_load" pos="6" rst="0">
        <comment>
          Start to load DC value, active high. Before next load, set it low firstly
        </comment>
      </bits>
      <bits access="rw" name="dcc_imgrej_rg" pos="5" rst="0">
        <comment>
          IQ swap in DC module
0: no swap
1. swap
        </comment>
      </bits>
      <bits access="rw" name="dcc_hold_en_rg" pos="4" rst="0">
        <comment>
          Hold DC accumulator calculation in DC calibration mode
        </comment>
      </bits>
      <bits access="rw" name="dcc_bypass_rg" pos="3" rst="0">
        <comment>
          This register is not used. But DC module bypass is actrually controlled by register rxdp_bypass_dcc and rxdp_bypass_mode_dcc
        </comment>
      </bits>
      <bits access="rw" name="dcc_dc_delta_ld_st_rg" pos="2" rst="0">
        <comment>
          Store initial value to DC accumulator at positive edge in DC cancel mode or DC calibration mode.
        </comment>
      </bits>
      <bits access="rw" name="dcc_dc_calib_en_rg" pos="1" rst="0">
        <comment>
          Load DC value in calibration mode to debug port, only used for debug purpose
        </comment>
      </bits>
      <bits access="rw" name="dcc_rx_calib_sel_rg" pos="0" rst="0">
        <comment>
          DC module work mode.
0: DC calibration mode
1: DC cancel mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dc_calib_re">
      <bits access="rw" name="rxdp_dc_calib_re_rg" pos="15:0" rst="0">
        <comment>
          DC real part value used in cancel mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dc_calib_im">
      <bits access="rw" name="rxdp_dc_calib_im_rg" pos="15:0" rst="0">
        <comment>
          DC image part value used in cancel mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dc_delta_re">
      <bits access="rw" name="rxdp_dc_delta_re_rg" pos="15:0" rst="0">
        <comment>
          Accumulator initial real part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dc_delta_im">
      <bits access="rw" name="rxdp_dc_delta_im_rg" pos="15:0" rst="0">
        <comment>
          Accumulator initial image part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dc_cr">
      <bits access="r" name="rxdp_dc_cr_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="conv_slow_bw_ct_rg" pos="11:9" rst="0">
        <comment>
          Slow convergence control, work with conv_mode_ct_rg register
        </comment>
      </bits>
      <bits access="rw" name="conv_fast_bw_ct_rg" pos="8:6" rst="0">
        <comment>
          Fast convergence control, work with conv_mode_ct_rg register
        </comment>
      </bits>
      <bits access="rw" name="conv_tmr_ct_rg" pos="5:2" rst="0">
        <comment>
          Duration time of DC calibration, which is based on sample unit
        </comment>
      </bits>
      <bits access="rw" name="conv_mode_ct_rg" pos="1:0" rst="0">
        <comment>
          DC convergence loop mode selection.
0: fast
1: slow
2: fast-&gt;slow
3: fast-&gt;hold
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gain_ct_reg">
      <bits access="r" name="rxdp_gain_ct_reg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="rxdp_gain_ct_load" pos="13" rst="0">
        <comment>
          load rxdp_gain_ct to DFE. Write it to 1b'0 before assert it
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gain_ct_load_bypass" pos="12" rst="1">
        <comment>
          bypass rxdp_gain_ct_load
        </comment>
      </bits>
      <bits access="r" name="rxdp_gain_ct_reg_reserved_1" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="rxdp_gain_ct" pos="9:0" rst="0">
        <comment>
          Gain BB control. [-24db, 57.875db], step=0.125db
        </comment>
      </bits>
    </reg>
    <hole size="160"/>
    <reg protect="rw" name="rxdp_gdeq_coef0_rg_1">
      <bits access="rw" name="rxdp_gdeq_coef0_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of RX group delay coefficient 0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef0_rg_2">
      <bits access="r" name="rxdp_gdeq_coef0_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gdeq_coef0_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of RX group delay coefficient 0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef1_rg_1">
      <bits access="rw" name="rxdp_gdeq_coef1_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of RX group delay coefficient 1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef1_rg_2">
      <bits access="r" name="rxdp_gdeq_coef1_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gdeq_coef1_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of RX group delay coefficient 1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef2_rg_1">
      <bits access="rw" name="rxdp_gdeq_coef2_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of RX group delay coefficient 2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef2_rg_2">
      <bits access="r" name="rxdp_gdeq_coef2_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gdeq_coef2_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of RX group delay coefficient 2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef3_rg_1">
      <bits access="rw" name="rxdp_gdeq_coef3_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of RX group delay coefficient 2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef3_rg_2">
      <bits access="r" name="rxdp_gdeq_coef3_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gdeq_coef3_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of RX group delay coefficient 2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_bypass">
      <bits access="r" name="rxdp_gdeq_bypass_reserved_0" pos="15:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_zf_if_sel" pos="1" rst="0">
        <comment>
          RF data type.
0: IF
1: ZF
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gdeq_bp_lp_sel" pos="0" rst="0">
        <comment>
          RF filter type.
0: BP
1: LP
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="rxdp_adc_wr_buf_fifo">
      <bits access="r" name="rxdp_adc_wr_buf_fifo_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_adc_smp_rate_rg" pos="11:7" rst="1">
        <comment>
          Read rate of DFE ADC FIFO, which depends on RX mode.
5'h01: NB/WT
        </comment>
      </bits>
      <bits access="r" name="rxdp_adc_wr_buf_fifo_reserved_1" pos="6" rst="0">
      </bits>
      <bits access="r" name="rxdp_adc_wr_buf_fifo_reserved_2" pos="5:1" rst="0">
      </bits>
      <bits access="rw" name="rxdp_adc_wr_en_rg" pos="0" rst="1">
        <comment>
          Write enable of DFE ADC FIFO, active high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rxdp_dcc_valid_o_reg">
      <bits access="r" name="rxdp_dcc_valid_o_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rxdp_dcc_val_reg" pos="0" rst="0">
        <comment>
          Valid indication of DC value after assert rxdp_dcc_load to avoid metastability. rxdp_dcc_re_o and rxdp_dcc_im_o are stable when this register is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rxdp_dcc_re_o_reg">
      <bits access="r" name="rxdp_dcc_re_o" pos="15:0" rst="0">
        <comment>
          Real part of DC value, it is stable when rxdp_dcc_val_reg is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rxdp_dcc_im_o_reg">
      <bits access="r" name="rxdp_dcc_im_o" pos="15:0" rst="0">
        <comment>
          Image part of DC value, it is stable when rxdp_dcc_val_reg is high
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="rxdp_notch_ct">
      <bits access="r" name="rxdp_notch_ct_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch_dataen0" pos="0" rst="1">
        <comment>
          Data enable of Notch DC
0: disable
1: enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch_a0_i_reg">
      <bits access="r" name="rxdp_notch_a0_i_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch_a0_i" pos="11:0" rst="0">
        <comment>
          Coefficient a for real part of Notch DC
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch_a0_q_reg">
      <bits access="r" name="rxdp_notch_a0_q_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch_a0_q" pos="11:0" rst="0">
        <comment>
          Coefficient a for image part of Notch DC
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="rxdp_notch_k_reg">
      <bits access="r" name="rxdp_notch_k_reg_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch_k0" pos="3:0" rst="0">
        <comment>
          Coefficient k of Notch DC
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_ct">
      <bits access="r" name="rxdp_notch2_ct_reserved_0" pos="15:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_dataen0" pos="1" rst="1">
        <comment>
          Data enable of Notch H 1st core
0: disable
1: enable
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_dataen1" pos="0" rst="1">
        <comment>
          Data enable of Notch H 2nd core
0: disable
1: enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_a0_i_reg">
      <bits access="r" name="rxdp_notch2_a0_i_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_a0_i" pos="11:0" rst="0">
        <comment>
          Coefficient a for real part of Notch H 1st core
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_a0_q_reg">
      <bits access="r" name="rxdp_notch2_a0_q_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_a0_q" pos="11:0" rst="0">
        <comment>
          Coefficient a for image part of Notch H 1st core
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_a1_i_reg">
      <bits access="r" name="rxdp_notch2_a1_i_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_a1_i" pos="11:0" rst="0">
        <comment>
          Coefficient a for real part of Notch H 2nd core
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_a1_q_reg">
      <bits access="r" name="rxdp_notch2_a1_q_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_a1_q" pos="11:0" rst="0">
        <comment>
          Coefficient a for image part of Notch H 2nd core
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_k_reg">
      <bits access="r" name="rxdp_notch2_k_reg_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_k0" pos="7:4" rst="0">
        <comment>
          Coefficient k of Notch H 1st core
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_k1" pos="3:0" rst="0">
        <comment>
          Coefficient k of Notch H 2nd core
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef0_reg">
      <bits access="rw" name="rxdp_aci_fir_coef0" pos="15:0" rst="0">
        <comment>
          Coefficient COEF0 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef1_reg">
      <bits access="rw" name="rxdp_aci_fir_coef1" pos="15:0" rst="0">
        <comment>
          Coefficient COEF1 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef2_reg">
      <bits access="rw" name="rxdp_aci_fir_coef2" pos="15:0" rst="0">
        <comment>
          Coefficient COEF2 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef3_reg">
      <bits access="rw" name="rxdp_aci_fir_coef3" pos="15:0" rst="0">
        <comment>
          Coefficient COEF3 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef4_reg">
      <bits access="rw" name="rxdp_aci_fir_coef4" pos="15:0" rst="0">
        <comment>
          Coefficient COEF4 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef5_reg">
      <bits access="rw" name="rxdp_aci_fir_coef5" pos="15:0" rst="0">
        <comment>
          Coefficient COEF5 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef6_reg">
      <bits access="rw" name="rxdp_aci_fir_coef6" pos="15:0" rst="0">
        <comment>
          Coefficient COEF6 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef7_reg">
      <bits access="rw" name="rxdp_aci_fir_coef7" pos="15:0" rst="0">
        <comment>
          Coefficient COEF7 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef8_reg">
      <bits access="rw" name="rxdp_aci_fir_coef8" pos="15:0" rst="0">
        <comment>
          Coefficient COEF8 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef9_reg">
      <bits access="rw" name="rxdp_aci_fir_coef9" pos="15:0" rst="0">
        <comment>
          Coefficient COEF9 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef10_reg">
      <bits access="rw" name="rxdp_aci_fir_coef10" pos="15:0" rst="0">
        <comment>
          Coefficient COEF10 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef11_reg">
      <bits access="rw" name="rxdp_aci_fir_coef11" pos="15:0" rst="0">
        <comment>
          Coefficient COEF11 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef12_reg">
      <bits access="rw" name="rxdp_aci_fir_coef12" pos="15:0" rst="0">
        <comment>
          Coefficient COEF12 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef13_reg">
      <bits access="rw" name="rxdp_aci_fir_coef13" pos="15:0" rst="0">
        <comment>
          Coefficient COEF13 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef14_reg">
      <bits access="rw" name="rxdp_aci_fir_coef14" pos="15:0" rst="0">
        <comment>
          Coefficient COEF14 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef15_reg">
      <bits access="rw" name="rxdp_aci_fir_coef15" pos="15:0" rst="0">
        <comment>
          Coefficient COEF15 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef16_reg">
      <bits access="rw" name="rxdp_aci_fir_coef16" pos="15:0" rst="0">
        <comment>
          Coefficient COEF16 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef17_reg">
      <bits access="rw" name="rxdp_aci_fir_coef17" pos="15:0" rst="0">
        <comment>
          Coefficient COEF17 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef18_reg">
      <bits access="rw" name="rxdp_aci_fir_coef18" pos="15:0" rst="0">
        <comment>
          Coefficient COEF18 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef19_reg">
      <bits access="rw" name="rxdp_aci_fir_coef19" pos="15:0" rst="0">
        <comment>
          Coefficient COEF19 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef20_reg">
      <bits access="rw" name="rxdp_aci_fir_coef20" pos="15:0" rst="0">
        <comment>
          Coefficient COEF20 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef21_reg">
      <bits access="rw" name="rxdp_aci_fir_coef21" pos="15:0" rst="0">
        <comment>
          Coefficient COEF21 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef22_reg">
      <bits access="rw" name="rxdp_aci_fir_coef22" pos="15:0" rst="0">
        <comment>
          Coefficient COEF22 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef23_reg">
      <bits access="rw" name="rxdp_aci_fir_coef23" pos="15:0" rst="0">
        <comment>
          Coefficient COEF23 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_mixer_freq_in_reg0">
      <bits access="rw" name="rxdp_mixer_freq_p0" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of frequency offset for Mixer
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_mixer_freq_in_reg1">
      <bits access="r" name="rxdp_mixer_freq_in_reg1_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="rxdp_mixer_freq_p1" pos="7:0" rst="0">
        <comment>
          Bit [23:16] of frequency offset for Mixer
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_rssi_reg">
      <bits access="r" name="rxdp_rssi_reg_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_rssi_ob_enable" pos="7" rst="0">
        <comment>
          Outband RSSI enable
        </comment>
      </bits>
      <bits access="rw" name="rxdp_rssi_ib_enable" pos="6" rst="0">
        <comment>
          Inband RSSI enable
        </comment>
      </bits>
      <bits access="rw" name="rxdp_rssi_ob_ushift" pos="5:3" rst="0">
        <comment>
          Outband RSSI ushift value
        </comment>
      </bits>
      <bits access="rw" name="rxdp_rssi_ib_ushift" pos="2:0" rst="0">
        <comment>
          Inband RSSI ushift value
        </comment>
      </bits>
    </reg>
    <hole size="160"/>
    <reg protect="rw" name="rxdp_gain_ct_rf_reg">
      <bits access="r" name="rxdp_gain_ct_rf_reg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="rxdp_gain_ct_rf_load" pos="13" rst="0">
        <comment>
          load rxdp_gain_ct_rf to DFE. Write it to 1b'0 before assert it
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gain_ct_rf_load_bypass" pos="12" rst="1">
        <comment>
          bypass rxdp_gain_ct_rf_load
        </comment>
      </bits>
      <bits access="r" name="rxdp_gain_ct_rf_reg_reserved_1" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="rxdp_gain_ct_rf" pos="9:0" rst="0">
        <comment>
          Gain RF control. [-24db, 57.875db], step=0.125db
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="start_max_min_ib_rssi_reg">
      <bits access="r" name="start_max_min_ib_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="start_max_min_ib_rssi" pos="0" rst="0">
        <comment>
          start inband RSSI max and min measurement
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="count_16lsb_ib_rssi_reg">
      <bits access="rw" name="count_16lsb_ib_rssi" pos="15:0" rst="30720">
        <comment>
          timer count [15:0] for max and min measurement report after start
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="count_16msb_ib_rssi_reg">
      <bits access="rw" name="count_16msb_ib_rssi" pos="15:0" rst="0">
        <comment>
          timer count [31:16] for max and min measurement report after start
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="load_max_min_ib_rssi_reg">
      <bits access="r" name="load_max_min_ib_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="load_max_min_ib_rssi" pos="0" rst="0">
        <comment>
          start to load max and min measurement report. Before next load, set it low firstly
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_max_min_val_ib_rssi">
      <bits access="r" name="rssi_max_min_val_ib_rssi_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_max_min_val_reg_ib_rssi" pos="0" rst="0">
        <comment>
          valid indication of max and min measurement report after assert load_max_min_ib_rssi to avoid metastability. rssi_min_reg_ib_rssi and rssi_max_reg_ib_rssi are stable when this register is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_min_ib_rssi">
      <bits access="r" name="rssi_min_ib_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_min_reg_ib_rssi" pos="9:0" rst="0">
        <comment>
          inband RSSI min value, it is stable when rssi_max_min_val_reg_ib_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_max_ib_rssi">
      <bits access="r" name="rssi_max_ib_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_max_reg_ib_rssi" pos="9:0" rst="0">
        <comment>
          inband RSSI max value, it is stable when rssi_max_min_val_reg_ib_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="int_ib_rssi">
      <bits access="r" name="int_ib_rssi_reserved_0" pos="15:3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_int_ib_rssi" pos="2" rst="0">
        <comment>
          interrupt status to be able to start to load max and min measurement report
        </comment>
      </bits>
      <bits access="rw" name="int_mask_ib_rssi" pos="1" rst="0">
        <comment>
          interrupt mask
        </comment>
      </bits>
      <bits access="rw" name="int_clear_ib_rssi" pos="0" rst="0">
        <comment>
          interrupt clear
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="load_ib_rssi_reg">
      <bits access="r" name="load_ib_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="load_ib_rssi" pos="0" rst="0">
        <comment>
          start to load instant measurement report. Before next load, set it low firstly
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_val_ib_rssi">
      <bits access="r" name="rssi_val_ib_rssi_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_val_reg_ib_rssi" pos="0" rst="0">
        <comment>
          valid indication of instant measurement report after assert load_ib_rssi to avoid metastability. rssi_reg_ib_rssi is stable when this register is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_ib_rssi">
      <bits access="r" name="rssi_ib_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_reg_ib_rssi" pos="9:0" rst="0">
        <comment>
          inband RSSI instant value, it is stable when rssi_val_reg_ib_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="start_max_min_ob_rssi_reg">
      <bits access="r" name="start_max_min_ob_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="start_max_min_ob_rssi" pos="0" rst="0">
        <comment>
          start outband RSSI max and min measurement
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="count_16lsb_ob_rssi_reg">
      <bits access="rw" name="count_16lsb_ob_rssi" pos="15:0" rst="30720">
        <comment>
          timer count [15:0] for max and min measurement report after start
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="count_16msb_ob_rssi_reg">
      <bits access="rw" name="count_16msb_ob_rssi" pos="15:0" rst="0">
        <comment>
          timer count [31:16] for max and min measurement report after start
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="load_max_min_ob_rssi_reg">
      <bits access="r" name="load_max_min_ob_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="load_max_min_ob_rssi" pos="0" rst="0">
        <comment>
          start to load max and min measurement report. Before next load, set it low firstly
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_max_min_val_ob_rssi">
      <bits access="r" name="rssi_max_min_val_ob_rssi_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_max_min_val_reg_ob_rssi" pos="0" rst="0">
        <comment>
          valid indication of max and min measurement report after assert load_max_min_ob_rssi to avoid metastability. rssi_min_reg_ob_rssi and rssi_max_reg_ob_rssi are stable when this register is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_min_ob_rssi">
      <bits access="r" name="rssi_min_ob_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_min_reg_ob_rssi" pos="9:0" rst="0">
        <comment>
          outband RSSI min value, it is stable when rssi_max_min_val_reg_ob_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_max_ob_rssi">
      <bits access="r" name="rssi_max_ob_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_max_reg_ob_rssi" pos="9:0" rst="0">
        <comment>
          outband RSSI max value, it is stable when rssi_max_min_val_reg_ob_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="int_ob_rssi">
      <bits access="r" name="int_ob_rssi_reserved_0" pos="15:3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_int_ob_rssi" pos="2" rst="0">
        <comment>
          interrupt status to be able to start to load max and min measurement report
        </comment>
      </bits>
      <bits access="rw" name="int_mask_ob_rssi" pos="1" rst="0">
        <comment>
          interrupt mask
        </comment>
      </bits>
      <bits access="rw" name="int_clear_ob_rssi" pos="0" rst="0">
        <comment>
          interrupt clear
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="load_ob_rssi_reg">
      <bits access="r" name="load_ob_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="load_ob_rssi" pos="0" rst="0">
        <comment>
          start to load instant measurement report. Before next load, set it low firstly
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_val_ob_rssi">
      <bits access="r" name="rssi_val_ob_rssi_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_val_reg_ob_rssi" pos="0" rst="0">
        <comment>
          valid indication of instant measurement report after assert load_ob_rssi to avoid metastability
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_wd_ob_rssi">
      <bits access="r" name="rssi_wd_ob_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_reg_wd_ob_rssi" pos="9:0" rst="0">
        <comment>
          outband RSSI instant value for WB, it is stable when rssi_val_reg_ob_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_up_ob_rssi">
      <bits access="r" name="rssi_up_ob_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_reg_up_ob_rssi" pos="9:0" rst="0">
        <comment>
          outband RSSI instant value for UP, it is stable when rssi_val_reg_ob_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_dn_ob_rssi">
      <bits access="r" name="rssi_dn_ob_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_reg_dn_ob_rssi" pos="9:0" rst="0">
        <comment>
          outband RSSI instant value for DN, it is stable when rssi_val_reg_ob_rssi is high
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="rxdp_bypass_control_reg1">
      <bits access="r" name="rxdp_bypass_control_reg1_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_uphb1" pos="13" rst="0">
        <comment>
          Interp. HBF1
0: SW bypass disable
1: SW bypass enable
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_gainbb" pos="12" rst="0">
        <comment>
          Gain_BB
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_notch2_2" pos="11" rst="0">
        <comment>
          Notrch(H) 2nd core
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_notch2_1" pos="10" rst="0">
        <comment>
          Notrch(H) 1st core
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_dnbh1" pos="9" rst="0">
        <comment>
          Deci. HBF1
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_aci_lpf" pos="8" rst="0">
        <comment>
          ACI Filter
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_gainrf" pos="7" rst="0">
        <comment>
          Gain_RF
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_gdeq" pos="6" rst="0">
        <comment>
          Group Delay Equ
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_notch1_1" pos="5" rst="0">
        <comment>
          Notch(DC)
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mixer" pos="4" rst="0">
        <comment>
          Mixer
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_rc" pos="3" rst="0">
        <comment>
          RC
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_imbc" pos="2" rst="0">
        <comment>
          IMBC
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_dcc" pos="1" rst="0">
        <comment>
          DC Calib.&amp;Cancel
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_cic1" pos="0" rst="0">
        <comment>
          Deci.CIC1
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="rxdp_bypass_mode_control_reg1">
      <bits access="r" name="rxdp_bypass_mode_control_reg1_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_uphb1" pos="13" rst="0">
        <comment>
          Interp. HBF1
0: bypass controlled by HW. HW bypass module automaticlly based on algorithm requirement
1: bypass controlled by SW. When it is set, rxdp_bypass_uphb1 will be used
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_gainbb" pos="12" rst="0">
        <comment>
          Gain_BB
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_notch2_2" pos="11" rst="0">
        <comment>
          Notrch(H) 2nd core
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_notch2_1" pos="10" rst="0">
        <comment>
          Notrch(H) 1st core
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_dnbh1" pos="9" rst="0">
        <comment>
          Deci. HBF1
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_aci_lpf" pos="8" rst="0">
        <comment>
          ACI Filter
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_gainrf" pos="7" rst="0">
        <comment>
          Gain_RF
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_gdeq" pos="6" rst="0">
        <comment>
          Group Delay Equ
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_notch1_1" pos="5" rst="0">
        <comment>
          Notch(DC)
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_mixer" pos="4" rst="0">
        <comment>
          Mixer
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_rc" pos="3" rst="0">
        <comment>
          RC
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_imbc" pos="2" rst="0">
        <comment>
          IMBC
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_dcc" pos="1" rst="0">
        <comment>
          DC Calib.&amp;Cancel
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_cic1" pos="0" rst="0">
        <comment>
          Deci.CIC1
        </comment>
      </bits>
    </reg>
    <hole size="800"/>
    <reg protect="rw" name="txdp_gsm_a1">
      <bits access="r" name="txdp_gsm_a1_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_a1_rg" pos="11:0" rst="0">
        <comment>
          Coefficient a1 for PLL Equ.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_a2">
      <bits access="r" name="txdp_gsm_a2_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_a2_rg" pos="11:0" rst="0">
        <comment>
          Coefficient a2 for PLL Equ.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_b1">
      <bits access="r" name="txdp_gsm_b1_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_b1_rg" pos="11:0" rst="0">
        <comment>
          Coefficient b1 for PLL Equ.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_b2">
      <bits access="r" name="txdp_gsm_b2_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_b2_rg" pos="11:0" rst="0">
        <comment>
          Coefficient b2 for PLL Equ.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_g">
      <bits access="rw" name="txdp_gsm_g_rg" pos="15:0" rst="0">
        <comment>
          Bit [27:12] of gain for PLL Equ. It is valid when AFC adjustment is being enabled
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_equ_bypass_reg">
      <bits access="r" name="txdp_gsm_equ_bypass_reg_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="txdp_gsm_g_load_bypass" pos="1" rst="1">
        <comment>
          Bypass load_g:
0: disable bypass
1: enable bypass
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_equ_bypass" pos="0" rst="1">
        <comment>
          Bypass PLL Equ.
0: disable bypass
1: enable bypass
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_equ_tx_shift_ct">
      <bits access="r" name="txdp_gsm_equ_tx_shift_ct_reserved_0" pos="15:5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_form_lsb_acc_en" pos="4" rst="0">
        <comment>
          4 LSB control
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_equ_tx_shift_ct_rg" pos="3:0" rst="0">
        <comment>
          Former output shift control
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="txdp_gsm_offset_value0_reg">
      <bits access="r" name="txdp_gsm_offset_value0_reg_reserved_0" pos="15:0" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="txdp_gsm_offset_value1_reg">
      <bits access="r" name="txdp_gsm_offset_value1_reg_reserved_0" pos="15:0" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_tx_rx">
      <bits access="r" name="txdp_gsm_tx_rx_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_freq_rg2" pos="3:1" rst="0">
        <comment>
          Bit [34:32] for GSM TX frequency
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_tx_rx_rg" pos="0" rst="1">
        <comment>
          use former output or not
0: RX don't use
1: TX use
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_freq0">
      <bits access="rw" name="txdp_gsm_freq_rg0" pos="15:0" rst="25200">
        <comment>
          Bit [15:0] for GSM TX frequency
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_freq1">
      <bits access="rw" name="txdp_gsm_freq_rg1" pos="15:0" rst="37415">
        <comment>
          Bit [31:16] for GSM TX frequency
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_freq_tx_offset">
      <bits access="rw" name="txdp_gsm_freq_tx_offset_rg" pos="15:0" rst="0">
        <comment>
          Offset add to GSM TX frequency
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="txdp_gsm_sdmpre_ct">
      <bits access="r" name="txdp_gsm_sdmpre_ct_reserved_0" pos="15:1" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_form_bypass" pos="0" rst="0">
        <comment>
          GSM TX frequency control.
0: modulation signal act on GSM TX freqency
1: GSM TX freqency is fixed
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_misc_reg">
      <bits access="r" name="txdp_gsm_misc_reg_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_freq_load_bypass_rg" pos="3" rst="0">
        <comment>
          GSM TX frequency load is at the same time of AFC adjustment or not
0: at the same time
1: not at the same time
        </comment>
      </bits>
      <bits access="r" name="txdp_gsm_misc_reg_reserved_1" pos="2:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="txdp_gsm_g_ext_reg">
      <bits access="r" name="txdp_gsm_g_ext_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_g_ext" pos="11:0" rst="0">
        <comment>
          Bit [11:0] of gain for PLL Equ. It works with register txdp_gsm_g_rg
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_nb_ctrl_reg">
      <bits access="r" name="txdp_gsm_nb_ctrl_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_dly1_data_idx_rg" pos="9:5" rst="0">
        <comment>
          Delay1 index
        </comment>
      </bits>
      <bits access="rw" name="gsm_dly2_data_idx_rg" pos="4:0" rst="0">
        <comment>
          Delay2 index
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff1_reg_l">
      <bits access="rw" name="gsm_grp_dly_coff1_rg_l" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of gsm_grp_dly_coff1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff1_reg_m">
      <bits access="r" name="txdp_gsm_grp_dly_coff1_reg_m_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_grp_dly_coff1_rg_m" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of gsm_grp_dly_coff1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff2_reg_l">
      <bits access="rw" name="gsm_grp_dly_coff2_rg_l" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of gsm_grp_dly_coff2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff2_reg_m">
      <bits access="r" name="txdp_gsm_grp_dly_coff2_reg_m_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_grp_dly_coff2_rg_m" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of gsm_grp_dly_coff2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff3_reg_l">
      <bits access="rw" name="gsm_grp_dly_coff3_rg_l" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of gsm_grp_dly_coff3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff3_reg_m">
      <bits access="r" name="txdp_gsm_grp_dly_coff3_reg_m_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_grp_dly_coff3_rg_m" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of gsm_grp_dly_coff3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff4_reg_l">
      <bits access="rw" name="gsm_grp_dly_coff4_rg_l" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of gsm_grp_dly_coff4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff4_reg_m">
      <bits access="r" name="txdp_gsm_grp_dly_coff4_reg_m_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_grp_dly_coff4_rg_m" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of gsm_grp_dly_coff4
        </comment>
      </bits>
    </reg>
    <hole size="1152"/>
    <reg protect="rw" name="txdp_wedge_gain_ct_reg">
      <bits access="r" name="txdp_wedge_gain_ct_reg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="txdp_wedge_gain_ct_load" pos="13" rst="0">
        <comment>
          load txdp_wedge_gain_ct to DFE. Write it to 1b'0 before assert it
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_gain_ct_load_bypass" pos="12" rst="1">
        <comment>
          bypass txdp_wedge_gain_ct_load
        </comment>
      </bits>
      <bits access="r" name="txdp_wedge_gain_ct_reg_reserved_1" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="txdp_wedge_gain_ct" pos="9:0" rst="0">
        <comment>
          Gain control of NB/WT TX. [-24db, 57.875db], step=0.125db
        </comment>
      </bits>
    </reg>
    <hole size="640"/>
    <reg protect="rw" name="txdp_wedge_pm_split_mode_reg">
      <bits access="r" name="txdp_wedge_pm_split_mode_reg_reserved_0" pos="15:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_flow_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="txdp_wedge_split_mode" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_shrink_reg">
      <bits access="r" name="txdp_wedge_am_shrink_reg_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_shrink" pos="7:0" rst="0">
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="txdp_wedge_pm_shift_reg">
      <bits access="r" name="txdp_wedge_pm_shift_reg_reserved_0" pos="15:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_shift" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p0_reg">
      <bits access="r" name="txdp_wedge_am_p0_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p0" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p1_reg">
      <bits access="r" name="txdp_wedge_am_p1_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p1" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p2_reg">
      <bits access="r" name="txdp_wedge_am_p2_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p2" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p3_reg">
      <bits access="r" name="txdp_wedge_am_p3_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p3" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p4_reg">
      <bits access="r" name="txdp_wedge_am_p4_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p4" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p5_reg">
      <bits access="r" name="txdp_wedge_am_p5_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p5" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p6_reg">
      <bits access="r" name="txdp_wedge_am_p6_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p6" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p7_reg">
      <bits access="r" name="txdp_wedge_am_p7_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p7" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p8_reg">
      <bits access="r" name="txdp_wedge_am_p8_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p8" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p9_reg">
      <bits access="r" name="txdp_wedge_am_p9_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p9" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p10_reg">
      <bits access="r" name="txdp_wedge_am_p10_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p10" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p11_reg">
      <bits access="r" name="txdp_wedge_am_p11_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p11" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p12_reg">
      <bits access="r" name="txdp_wedge_am_p12_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p12" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p13_reg">
      <bits access="r" name="txdp_wedge_am_p13_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p13" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p14_reg">
      <bits access="r" name="txdp_wedge_am_p14_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p14" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p15_reg">
      <bits access="r" name="txdp_wedge_am_p15_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p15" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p16_reg">
      <bits access="r" name="txdp_wedge_am_p16_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p16" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p0_reg">
      <bits access="r" name="txdp_wedge_pm_p0_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p0" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p1_reg">
      <bits access="r" name="txdp_wedge_pm_p1_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p1" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p2_reg">
      <bits access="r" name="txdp_wedge_pm_p2_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p2" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p3_reg">
      <bits access="r" name="txdp_wedge_pm_p3_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p3" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p4_reg">
      <bits access="r" name="txdp_wedge_pm_p4_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p4" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p5_reg">
      <bits access="r" name="txdp_wedge_pm_p5_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p5" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p6_reg">
      <bits access="r" name="txdp_wedge_pm_p6_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p6" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p7_reg">
      <bits access="r" name="txdp_wedge_pm_p7_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p7" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p8_reg">
      <bits access="r" name="txdp_wedge_pm_p8_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p8" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p9_reg">
      <bits access="r" name="txdp_wedge_pm_p9_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p9" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p10_reg">
      <bits access="r" name="txdp_wedge_pm_p10_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p10" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p11_reg">
      <bits access="r" name="txdp_wedge_pm_p11_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p11" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p12_reg">
      <bits access="r" name="txdp_wedge_pm_p12_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p12" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p13_reg">
      <bits access="r" name="txdp_wedge_pm_p13_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p13" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p14_reg">
      <bits access="r" name="txdp_wedge_pm_p14_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p14" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p15_reg">
      <bits access="r" name="txdp_wedge_pm_p15_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p15" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p16_reg">
      <bits access="r" name="txdp_wedge_pm_p16_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p16" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <hole size="192"/>
    <reg protect="rw" name="clk_dac_ctrl">
      <bits access="r" name="clk_dac_ctrl_reserved_0" pos="15:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="clk_dac_test_mode" pos="6:4" rst="0">
        <comment>
          divide resource of clk_dac when test mode.
000: divide by 1
001: divide by 2
010: divide by 4
011: divide by 8
100: divide by 16
101: divide by 32
110: divide by 64
default: divide by 1
        </comment>
      </bits>
      <bits access="rw" name="clk_dac_test_sel" pos="3:2" rst="1">
        <comment>
          resource of clk_dac when test mode.
01: clk_61.44m
10: clk_26m_fbc
11: clk_adc_gge_nb
        </comment>
      </bits>
      <bits access="rw" name="clk_dac_test_en" pos="1" rst="0">
        <comment>
          enable clk_dac when test mode
        </comment>
      </bits>
      <bits access="rw" name="clk_dac_sel" pos="0" rst="0">
        <comment>
          0: clk_dac is from function mode
1: clk_dac is from test mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_delay_reg">
      <bits access="r" name="txdp_delay_reg_reserved_0" pos="15:11" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_amp_dly" pos="10:7" rst="12">
        <comment>
          Delay3 index
        </comment>
      </bits>
      <bits access="rw" name="delay4_rg" pos="6:4" rst="0">
        <comment>
          Delay4 index
        </comment>
      </bits>
      <bits access="rw" name="delay5_rg" pos="3" rst="0">
        <comment>
          Delay5 index
        </comment>
      </bits>
      <bits access="rw" name="delay6_rg" pos="2" rst="0">
        <comment>
          Delay6 index
        </comment>
      </bits>
      <bits access="rw" name="delay7_rg" pos="1:0" rst="0">
        <comment>
          Delay7 index
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef0">
      <bits access="r" name="aclr_coef0_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef00" pos="13:0" rst="0">
        <comment>
          Coefficient 0 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef1">
      <bits access="r" name="aclr_coef1_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef01" pos="13:0" rst="0">
        <comment>
          Coefficient 1 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef2">
      <bits access="r" name="aclr_coef2_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef02" pos="13:0" rst="0">
        <comment>
          Coefficient 2 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef3">
      <bits access="r" name="aclr_coef3_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef03" pos="13:0" rst="0">
        <comment>
          Coefficient 3 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef0_rg_1">
      <bits access="rw" name="txdp_gdeq_coef0_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of coefficient 0 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef0_rg_2">
      <bits access="r" name="txdp_gdeq_coef0_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gdeq_coef0_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of coefficient 0 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef1_rg_1">
      <bits access="rw" name="txdp_gdeq_coef1_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of coefficient 1 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef1_rg_2">
      <bits access="r" name="txdp_gdeq_coef1_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gdeq_coef1_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of coefficient 1 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef2_rg_1">
      <bits access="rw" name="txdp_gdeq_coef2_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of coefficient 2 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef2_rg_2">
      <bits access="r" name="txdp_gdeq_coef2_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gdeq_coef2_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of coefficient 2 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef3_rg_1">
      <bits access="rw" name="txdp_gdeq_coef3_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of coefficient 3 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef3_rg_2">
      <bits access="r" name="txdp_gdeq_coef3_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gdeq_coef3_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of coefficient 3 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef00">
      <bits access="r" name="txdp_polariq_fir_coef00_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef0" pos="11:0" rst="0">
        <comment>
          Coefficient 0 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef01">
      <bits access="r" name="txdp_polariq_fir_coef01_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef1" pos="11:0" rst="0">
        <comment>
          Coefficient 1 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef02">
      <bits access="r" name="txdp_polariq_fir_coef02_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef2" pos="11:0" rst="0">
        <comment>
          Coefficient 2 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef03">
      <bits access="r" name="txdp_polariq_fir_coef03_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef3" pos="11:0" rst="0">
        <comment>
          Coefficient 3 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef04">
      <bits access="r" name="txdp_polariq_fir_coef04_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef4" pos="11:0" rst="0">
        <comment>
          Coefficient 4 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef05">
      <bits access="r" name="txdp_polariq_fir_coef05_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef5" pos="11:0" rst="0">
        <comment>
          Coefficient 5 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef06">
      <bits access="r" name="txdp_polariq_fir_coef06_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef6" pos="11:0" rst="0">
        <comment>
          Coefficient 6 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef07">
      <bits access="r" name="txdp_polariq_fir_coef07_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef7" pos="11:0" rst="0">
        <comment>
          Coefficient 7 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef08">
      <bits access="r" name="txdp_polariq_fir_coef08_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef8" pos="11:0" rst="0">
        <comment>
          Coefficient 8 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef09">
      <bits access="r" name="txdp_polariq_fir_coef09_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef9" pos="11:0" rst="0">
        <comment>
          Coefficient 9 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef010">
      <bits access="r" name="txdp_polariq_fir_coef010_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef10" pos="11:0" rst="0">
        <comment>
          Coefficient 10 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef011">
      <bits access="r" name="txdp_polariq_fir_coef011_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef11" pos="11:0" rst="0">
        <comment>
          Coefficient 11 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <hole size="128"/>
    <reg protect="rw" name="data_format_ctrl">
      <bits access="r" name="data_format_ctrl_reserved_0" pos="15:9" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="nb_tx_rx_loop" pos="8" rst="0">
        <comment>
          BB TX data loopback to BB RX
        </comment>
      </bits>
      <bits access="rw" name="rx_iq_swap" pos="7" rst="0">
        <comment>
          BB RX IQ swap. 
0: normal
1: swap
        </comment>
      </bits>
      <bits access="rw" name="tx_iq_swap" pos="6" rst="0">
        <comment>
          BB TX IQ swap. 
0: normal
1: swap
        </comment>
      </bits>
      <bits access="rw" name="adc_iq_swap" pos="5" rst="0">
        <comment>
          ADC IQ swap. 
0: normal
1: swap
        </comment>
      </bits>
      <bits access="rw" name="dac_iq_swap" pos="4" rst="0">
        <comment>
          DAC IQ swap. 
0: normal
1: swap
        </comment>
      </bits>
      <bits access="rw" name="rx_off_bin_en" pos="3" rst="0">
        <comment>
          BB RX. 
0: two's complement
1: offset binary
        </comment>
      </bits>
      <bits access="rw" name="tx_off_bin_en" pos="2" rst="0">
        <comment>
          BB TX.
0: two's complement
1: offset binary
        </comment>
      </bits>
      <bits access="rw" name="adc_off_bin_en" pos="1" rst="0">
        <comment>
          RF ADC.
0: two's complement
1: offset binary
        </comment>
      </bits>
      <bits access="rw" name="dac_off_bin_en" pos="0" rst="1">
        <comment>
          RF DAC. 
0: two's complement
1: offset binary
        </comment>
      </bits>
    </reg>
    <hole size="736"/>
    <reg protect="r" name="txdp_pcom_zin_lo_rg">
      <bits access="r" name="txdp_pcom_zin_lo_rg_reserved_0" pos="15:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dfe_sw_clkgate_en_rg">
      <bits access="r" name="dfe_sw_clkgate_en_rg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dfe_sw_clkgate_en" pos="0" rst="0">
        <comment>
          Globle clock gating disable register
0: no use
1: enable clock on all clock gating cells
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="mon_ct">
      <bits access="r" name="mon_ct_reserved_0" pos="15:6" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dfe_monitor_en" pos="5" rst="0">
        <comment>
          enable dfe monitor 
        </comment>
      </bits>
      <bits access="rw" name="dfe_monitor_swap" pos="4" rst="0">
        <comment>
          swap of dfe_monitor[15:8] and dfe_monitor[7:0]
0: no swap
1: swap
        </comment>
      </bits>
      <bits access="rw" name="dfe_monitor_sel" pos="3:0" rst="0">
        <comment>
          Monitor output selection
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dac_offset_re_rg">
      <bits access="r" name="dac_offset_re_rg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dac_offset_re" pos="9:0" rst="0">
        <comment>
          The offset on DAC real part
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dac_offset_im_rg">
      <bits access="r" name="dac_offset_im_rg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dac_offset_im" pos="9:0" rst="0">
        <comment>
          The offset on DAC image part
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dac_tx_amp_re_rg">
      <bits access="r" name="dac_tx_amp_re_rg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dac_tx_amp_re" pos="9:0" rst="0">
        <comment>
          The DAC real part on test mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dac_tx_amp_im_rg">
      <bits access="r" name="dac_tx_amp_im_rg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dac_tx_amp_im" pos="9:0" rst="0">
        <comment>
          The DAC image part on test mode
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="data_dac_ctrl">
      <bits access="r" name="data_dac_ctrl_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="data_dac_sel" pos="13:12" rst="0">
        <comment>
          selection of function DAC data or test DAC data
00/01: select function DAC data including sine waveform
10: select test DAC data in RXDP path
11: select test DAC data in TXDP path
        </comment>
      </bits>
      <bits access="rw" name="sine_enable_rg" pos="11" rst="0">
        <comment>
          enable sine waveform generation module
        </comment>
      </bits>
      <bits access="rw" name="rxdp_test_dac_en_rg" pos="10" rst="0">
        <comment>
          enable test DAC data in RXDP path
        </comment>
      </bits>
      <bits access="rw" name="rxdp_test_dac_sel_rg" pos="9:5" rst="0">
        <comment>
          select test DAC data in RXDP path
        </comment>
      </bits>
      <bits access="rw" name="txdp_test_dac_en_rg" pos="4" rst="0">
        <comment>
          enable test DAC data in TXDP path
        </comment>
      </bits>
      <bits access="rw" name="txdp_test_dac_sel_rg" pos="3:0" rst="0">
        <comment>
          select test DAC data in TXDP path
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sincos_amp">
      <bits access="r" name="sincos_amp_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="sincos_amp_rg" pos="11:0" rst="511">
        <comment>
          sine waveform amplitude
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sincos_fre_lo">
      <bits access="rw" name="sincos_fre_rg_lo" pos="15:0" rst="54613">
        <comment>
          bit [15:0] of sine waveform frequence
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sincos_fre_hi">
      <bits access="r" name="sincos_fre_hi_reserved_0" pos="15:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="sincos_fre_rg_hi" pos="6:0" rst="0">
        <comment>
          bit [22:16] of sine waveform frequence
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_bypass_reg0">
      <bits access="rw" name="txdp_bypass_cic1" pos="15" rst="0">
        <comment>
          Interp. CIC1
0: SW bypass disable
1: SW bypass enable
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_gsm_gdeq" pos="14" rst="0">
        <comment>
          Group Delay Equ. when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_uphb5" pos="13" rst="0">
        <comment>
          Interp.HBF5
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_uphb4" pos="12" rst="0">
        <comment>
          Interp. HBF4
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_gdeq" pos="11" rst="0">
        <comment>
          Group Delay Equ.
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_polariq_lpf" pos="10" rst="0">
        <comment>
          LPF of DPD only when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_polariq_ampm" pos="9" rst="0">
        <comment>
          AMPM of DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_polariq_split" pos="8" rst="0">
        <comment>
          Split of DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_polariq" pos="7" rst="0">
        <comment>
          Whole DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_rc" pos="6" rst="0">
        <comment>
          RC
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_gain" pos="5" rst="0">
        <comment>
          Gain
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_uphb3" pos="4" rst="0">
        <comment>
          Interp.HBF3 when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_uphb2" pos="3" rst="0">
        <comment>
          Interp.HBF2 when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_uphb1" pos="2" rst="0">
        <comment>
          Interp.HBF1
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_aclr_lpf" pos="1" rst="0">
        <comment>
          ACLR LPF
        </comment>
      </bits>
      <bits access="r" name="txdp_bypass_reg0_reserved_0" pos="0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="txdp_bypass_mode_reg0">
      <bits access="rw" name="txdp_bypass_mode_cic1" pos="15" rst="0">
        <comment>
          Interp. CIC1
0: bypass controlled by HW. HW bypass module automaticlly based on algorithm requirement
1: bypass controlled by SW. When it is set, txdp_bypass_cic1 will be used
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_gsm_gdeq" pos="14" rst="0">
        <comment>
          Group Delay Equ. when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_uphb5" pos="13" rst="0">
        <comment>
          Interp.HBF5
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_uphb4" pos="12" rst="0">
        <comment>
          Interp.HBF4
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_gdeq" pos="11" rst="0">
        <comment>
          Group Delay Equ.
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_polariq_lpf" pos="10" rst="0">
        <comment>
          LPF of DPD only when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_polariq_ampm" pos="9" rst="0">
        <comment>
          AMPM of DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_polariq_split" pos="8" rst="0">
        <comment>
          Split of DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_polariq" pos="7" rst="0">
        <comment>
          Whole DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_rc" pos="6" rst="0">
        <comment>
          RC
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_gain" pos="5" rst="0">
        <comment>
          Gain
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_uphb3" pos="4" rst="0">
        <comment>
          Interp.HBF3 when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_uphb2" pos="3" rst="0">
        <comment>
          Interp.HBF2 when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_uphb1" pos="2" rst="0">
        <comment>
          Interp.HBF1
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_aclr_lpf" pos="1" rst="0">
        <comment>
          ACLR LPF
        </comment>
      </bits>
      <bits access="r" name="txdp_bypass_mode_reg0_reserved_0" pos="0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <hole size="256"/>
    <reg protect="rw" name="reserved_half_ones_reg">
      <bits access="rw" name="rsv_half_ones" pos="15:0" rst="65280">
        <comment>
          all one bits, reserved for ECO
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_clk_gate_enable_reg">
      <bits access="r" name="txdp_clk_gate_enable_reg_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="txdp_aclr_clkgate_en" pos="8" rst="0">
      </bits>
      <bits access="rw" name="txdp_dpd_clkgate_en" pos="7" rst="0">
      </bits>
      <bits access="rw" name="txdp_gsm_grp_dly_clkgate_en" pos="6" rst="0">
      </bits>
      <bits access="rw" name="txdp_uphb2_clkgate_en" pos="5" rst="0">
      </bits>
      <bits access="rw" name="txdp_uphb3_clkgate_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_clkgate_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="txdp_uphb5_clkgate_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="txdp_interp_cic1_clkgate_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="txdp_sine_clkgate_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_clk_gate_enable_reg1">
      <bits access="r" name="rxdp_clk_gate_enable_reg1_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="rxdp_notch1_clkgate_en" pos="9" rst="0">
      </bits>
      <bits access="rw" name="rxdp_dnsc1_clkgate_en" pos="8" rst="0">
      </bits>
      <bits access="rw" name="rxdp_mixer_clkgate_en" pos="7" rst="0">
      </bits>
      <bits access="rw" name="rxdp_ob_clkgate_en" pos="6" rst="0">
      </bits>
      <bits access="rw" name="rxdp_dnhb1_clkgate_en" pos="5" rst="0">
      </bits>
      <bits access="rw" name="rxdp_aci_clkgate_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="rxdp_notch2_clkgate_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="rxdp_gain2_clkgate_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rxdp_ib_clkgate_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rxdp_imbc_clkgate_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="share_clk_gate_enable_reg1">
      <bits access="r" name="share_clk_gate_enable_reg1_reserved_0" pos="15:5" rst="0">
      </bits>
      <bits access="rw" name="share_grp_dly_clkgate_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="share_gain_clkgate_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="share_rc_clkgate_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="share_uphb1_clkgate_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="share_uphb2_clkgate_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="test_dac_bits_sel_register">
      <bits access="r" name="test_dac_bits_sel_register_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rw" name="test_dac_bits_sel" pos="2:0" rst="0">
        <comment>
          0:[11:0], 1:[12:1], 2:[13:2], 3:[14:3], 4: [15:4]
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="r" name="fifo_status_reg">
      <bits access="r" name="fifo_status_reg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="r" name="fifo_txdp_rc_full_status" pos="13" rst="0">
        <comment>
          FIFO txdp_rc full
        </comment>
      </bits>
      <bits access="r" name="fifo_txdp_rc_empty_status" pos="12" rst="0">
        <comment>
          FIFO txdp_rc empty
        </comment>
      </bits>
      <bits access="r" name="fifo_rxdp_rc_full_status" pos="11" rst="0">
        <comment>
          FIFO rxdp_rc full
        </comment>
      </bits>
      <bits access="r" name="fifo_rxdp_rc_empty_status" pos="10" rst="0">
        <comment>
          FIFO rxdp_rc empty
        </comment>
      </bits>
      <bits access="r" name="fifo_adc_full_status" pos="9" rst="0">
        <comment>
          FIFO ADC full
        </comment>
      </bits>
      <bits access="r" name="fifo_adc_empty_status" pos="8" rst="0">
        <comment>
          FIFO ADC empty, this FIFO used between ADC and DFE
        </comment>
      </bits>
      <bits access="r" name="fifo_status_reg_reserved_1" pos="7:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_resetn_reg">
      <bits access="r" name="txdp_resetn_reg_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="sw_resetn_tx" pos="1" rst="1">
        <comment>
          SW controlled reset for TXDP when reset_mode is 0, active low.
0: reset
1: no reset
        </comment>
      </bits>
      <bits access="rw" name="reset_mode_tx" pos="0" rst="0">
        <comment>
          Reset source for TXDP.
0: reset from BB TCU event signal with precise timing control
1: reset from register resetn_txdp
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_dpd_gain_reg">
      <bits access="r" name="tx_dpd_gain_reg_reserved_0" pos="15:4" rst="0">
      </bits>
      <bits access="rw" name="iq2ap_cordic_gain_sel" pos="3:2" rst="1">
        <comment>
          0:0.5 1:0.609375 2:0.625
        </comment>
      </bits>
      <bits access="rw" name="ap2iq_cordic_gain_sel" pos="1:0" rst="1">
        <comment>
          0:0.5 1:0.609375 2:0.625
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_mixer_gain_reg">
      <bits access="r" name="rx_mixer_gain_reg_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="rx_mixer_gain_sel" pos="1:0" rst="1">
        <comment>
          0:0.5 1:0.609375 2:0.625
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef4">
      <bits access="r" name="aclr_coef4_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef04" pos="13:0" rst="0">
        <comment>
          Coefficient 4 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef5">
      <bits access="r" name="aclr_coef5_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef05" pos="13:0" rst="0">
        <comment>
          Coefficient 5 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef6">
      <bits access="r" name="aclr_coef6_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef06" pos="13:0" rst="0">
        <comment>
          Coefficient 6 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef7">
      <bits access="r" name="aclr_coef7_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef07" pos="13:0" rst="0">
        <comment>
          Coefficient 7 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef8">
      <bits access="r" name="aclr_coef8_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef08" pos="13:0" rst="0">
        <comment>
          Coefficient 8 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef9">
      <bits access="r" name="aclr_coef9_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef09" pos="13:0" rst="0">
        <comment>
          Coefficient 9 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef010">
      <bits access="r" name="aclr_coef010_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef10" pos="13:0" rst="0">
        <comment>
          Coefficient 10 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_imbc_wa_reg">
      <bits access="rw" name="rxdp_imbc_wa" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_imbc_wq_reg">
      <bits access="rw" name="rxdp_imbc_wq" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_imbc_misc_reg">
      <bits access="r" name="rxdp_imbc_misc_reg_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="rw" name="rxdp_imbc_bw_fast_ct" pos="10:7" rst="0">
      </bits>
      <bits access="rw" name="rxdp_imbc_bw_slow_ct" pos="6:3" rst="0">
      </bits>
      <bits access="rw" name="rxdp_imbc_hold_dr" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rxdp_imbc_calc_rels" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rxdp_imbc_load" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="rxdp_imbc_wa_out_reg">
      <bits access="r" name="rxdp_imbc_wa_out" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="rxdp_imbc_wq_out_reg">
      <bits access="r" name="rxdp_imbc_wq_out" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="rxdp_imbc_out_reg">
      <bits access="r" name="rxdp_imbc_out_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="r" name="rxdp_imbc_val_out" pos="0:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_loft_offset_i_reg">
      <bits access="r" name="txdp_loft_offset_i_reg_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_offset_i" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_loft_offset_reg">
      <bits access="r" name="txdp_loft_offset_reg_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_offset" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_loft_phase_err_reg">
      <bits access="r" name="txdp_loft_phase_err_reg_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_phase_err" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_loft_amp_err_reg">
      <bits access="r" name="txdp_loft_amp_err_reg_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_amp_err" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="txdp_loft_rssi_reg">
      <bits access="r" name="txdp_loft_rssi_err" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_loft_tone_amp_reg">
      <bits access="r" name="txdp_loft_tone_amp_reg_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_tone_amp" pos="11:0" rst="511">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_loft_tone_fre_reg0">
      <bits access="rw" name="txdp_loft_tone_fre0" pos="15:0" rst="54613">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_loft_tone_fre_reg1">
      <bits access="r" name="txdp_loft_tone_fre_reg1_reserved_0" pos="15:7" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_tone_fre1" pos="6:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_loft_misc0_reg">
      <bits access="rw" name="txdp_loft_sincos_en" pos="15:15" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_din_loft_sel" pos="14:14" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_cali_en" pos="13:13" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_cancel_bypass" pos="12:12" rst="0">
      </bits>
      <bits access="r" name="txdp_loft_misc0_reg_reserved_0" pos="11:11" rst="0">
      </bits>
      <bits access="r" name="txdp_loft_misc0_reg_reserved_1" pos="10:10" rst="0">
      </bits>
      <bits access="r" name="txdp_loft_misc0_reg_reserved_2" pos="9:9" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_flg_loft_calib" pos="8:8" rst="0">
      </bits>
      <bits access="r" name="txdp_loft_misc0_reg_reserved_3" pos="7:7" rst="0">
      </bits>
      <bits access="r" name="txdp_loft_misc0_reg_reserved_4" pos="6:6" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_rssi_ushift" pos="5:3" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_rssi_period_idx" pos="2:2" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_rssi_enable" pos="1:1" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_rssi_load" pos="0:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_loft_gain1_reg">
      <bits access="r" name="txdp_loft_gain1_reg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="r" name="txdp_loft_rssi_val" pos="13" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_gain1_ct" pos="12:7" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_gain1_ct_dyn" pos="6:1" rst="0">
      </bits>
      <bits access="rw" name="txdp_loft_gain1_ct_sel" pos="0:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p17_reg">
      <bits access="r" name="txdp_wedge_am_p17_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p17" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p18_reg">
      <bits access="r" name="txdp_wedge_am_p18_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p18" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p19_reg">
      <bits access="r" name="txdp_wedge_am_p19_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p19" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p20_reg">
      <bits access="r" name="txdp_wedge_am_p20_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p20" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p21_reg">
      <bits access="r" name="txdp_wedge_am_p21_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p21" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p22_reg">
      <bits access="r" name="txdp_wedge_am_p22_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p22" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p23_reg">
      <bits access="r" name="txdp_wedge_am_p23_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p23" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p24_reg">
      <bits access="r" name="txdp_wedge_am_p24_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p24" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p25_reg">
      <bits access="r" name="txdp_wedge_am_p25_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p25" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p26_reg">
      <bits access="r" name="txdp_wedge_am_p26_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p26" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p27_reg">
      <bits access="r" name="txdp_wedge_am_p27_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p27" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p28_reg">
      <bits access="r" name="txdp_wedge_am_p28_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p28" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p29_reg">
      <bits access="r" name="txdp_wedge_am_p29_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p29" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p30_reg">
      <bits access="r" name="txdp_wedge_am_p30_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p30" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p31_reg">
      <bits access="r" name="txdp_wedge_am_p31_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p31" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p32_reg">
      <bits access="r" name="txdp_wedge_am_p32_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p32" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p33_reg">
      <bits access="r" name="txdp_wedge_am_p33_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p33" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p34_reg">
      <bits access="r" name="txdp_wedge_am_p34_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p34" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p35_reg">
      <bits access="r" name="txdp_wedge_am_p35_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p35" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p36_reg">
      <bits access="r" name="txdp_wedge_am_p36_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p36" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p37_reg">
      <bits access="r" name="txdp_wedge_am_p37_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p37" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p38_reg">
      <bits access="r" name="txdp_wedge_am_p38_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p38" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p39_reg">
      <bits access="r" name="txdp_wedge_am_p39_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p39" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p40_reg">
      <bits access="r" name="txdp_wedge_am_p40_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p40" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p41_reg">
      <bits access="r" name="txdp_wedge_am_p41_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p41" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p42_reg">
      <bits access="r" name="txdp_wedge_am_p42_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p42" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p43_reg">
      <bits access="r" name="txdp_wedge_am_p43_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p43" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p44_reg">
      <bits access="r" name="txdp_wedge_am_p44_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p44" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p45_reg">
      <bits access="r" name="txdp_wedge_am_p45_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p45" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p46_reg">
      <bits access="r" name="txdp_wedge_am_p46_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p46" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p47_reg">
      <bits access="r" name="txdp_wedge_am_p47_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p47" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p48_reg">
      <bits access="r" name="txdp_wedge_am_p48_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p48" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p49_reg">
      <bits access="r" name="txdp_wedge_am_p49_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p49" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p50_reg">
      <bits access="r" name="txdp_wedge_am_p50_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p50" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p51_reg">
      <bits access="r" name="txdp_wedge_am_p51_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p51" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p52_reg">
      <bits access="r" name="txdp_wedge_am_p52_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p52" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p53_reg">
      <bits access="r" name="txdp_wedge_am_p53_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p53" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p54_reg">
      <bits access="r" name="txdp_wedge_am_p54_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p54" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p55_reg">
      <bits access="r" name="txdp_wedge_am_p55_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p55" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p56_reg">
      <bits access="r" name="txdp_wedge_am_p56_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p56" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p57_reg">
      <bits access="r" name="txdp_wedge_am_p57_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p57" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p58_reg">
      <bits access="r" name="txdp_wedge_am_p58_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p58" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p59_reg">
      <bits access="r" name="txdp_wedge_am_p59_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p59" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p60_reg">
      <bits access="r" name="txdp_wedge_am_p60_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p60" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p61_reg">
      <bits access="r" name="txdp_wedge_am_p61_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p61" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p62_reg">
      <bits access="r" name="txdp_wedge_am_p62_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p62" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p63_reg">
      <bits access="r" name="txdp_wedge_am_p63_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p63" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p64_reg">
      <bits access="r" name="txdp_wedge_am_p64_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p64" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p17_reg">
      <bits access="r" name="txdp_wedge_pm_p17_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p17" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p18_reg">
      <bits access="r" name="txdp_wedge_pm_p18_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p18" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p19_reg">
      <bits access="r" name="txdp_wedge_pm_p19_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p19" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p20_reg">
      <bits access="r" name="txdp_wedge_pm_p20_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p20" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p21_reg">
      <bits access="r" name="txdp_wedge_pm_p21_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p21" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p22_reg">
      <bits access="r" name="txdp_wedge_pm_p22_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p22" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p23_reg">
      <bits access="r" name="txdp_wedge_pm_p23_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p23" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p24_reg">
      <bits access="r" name="txdp_wedge_pm_p24_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p24" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p25_reg">
      <bits access="r" name="txdp_wedge_pm_p25_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p25" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p26_reg">
      <bits access="r" name="txdp_wedge_pm_p26_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p26" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p27_reg">
      <bits access="r" name="txdp_wedge_pm_p27_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p27" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p28_reg">
      <bits access="r" name="txdp_wedge_pm_p28_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p28" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p29_reg">
      <bits access="r" name="txdp_wedge_pm_p29_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p29" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p30_reg">
      <bits access="r" name="txdp_wedge_pm_p30_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p30" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p31_reg">
      <bits access="r" name="txdp_wedge_pm_p31_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p31" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p32_reg">
      <bits access="r" name="txdp_wedge_pm_p32_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p32" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p33_reg">
      <bits access="r" name="txdp_wedge_pm_p33_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p33" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p34_reg">
      <bits access="r" name="txdp_wedge_pm_p34_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p34" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p35_reg">
      <bits access="r" name="txdp_wedge_pm_p35_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p35" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p36_reg">
      <bits access="r" name="txdp_wedge_pm_p36_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p36" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p37_reg">
      <bits access="r" name="txdp_wedge_pm_p37_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p37" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p38_reg">
      <bits access="r" name="txdp_wedge_pm_p38_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p38" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p39_reg">
      <bits access="r" name="txdp_wedge_pm_p39_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p39" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p40_reg">
      <bits access="r" name="txdp_wedge_pm_p40_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p40" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p41_reg">
      <bits access="r" name="txdp_wedge_pm_p41_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p41" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p42_reg">
      <bits access="r" name="txdp_wedge_pm_p42_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p42" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p43_reg">
      <bits access="r" name="txdp_wedge_pm_p43_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p43" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p44_reg">
      <bits access="r" name="txdp_wedge_pm_p44_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p44" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p45_reg">
      <bits access="r" name="txdp_wedge_pm_p45_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p45" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p46_reg">
      <bits access="r" name="txdp_wedge_pm_p46_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p46" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p47_reg">
      <bits access="r" name="txdp_wedge_pm_p47_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p47" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p48_reg">
      <bits access="r" name="txdp_wedge_pm_p48_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p48" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p49_reg">
      <bits access="r" name="txdp_wedge_pm_p49_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p49" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p50_reg">
      <bits access="r" name="txdp_wedge_pm_p50_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p50" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p51_reg">
      <bits access="r" name="txdp_wedge_pm_p51_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p51" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p52_reg">
      <bits access="r" name="txdp_wedge_pm_p52_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p52" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p53_reg">
      <bits access="r" name="txdp_wedge_pm_p53_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p53" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p54_reg">
      <bits access="r" name="txdp_wedge_pm_p54_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p54" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p55_reg">
      <bits access="r" name="txdp_wedge_pm_p55_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p55" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p56_reg">
      <bits access="r" name="txdp_wedge_pm_p56_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p56" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p57_reg">
      <bits access="r" name="txdp_wedge_pm_p57_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p57" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p58_reg">
      <bits access="r" name="txdp_wedge_pm_p58_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p58" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p59_reg">
      <bits access="r" name="txdp_wedge_pm_p59_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p59" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p60_reg">
      <bits access="r" name="txdp_wedge_pm_p60_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p60" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p61_reg">
      <bits access="r" name="txdp_wedge_pm_p61_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p61" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p62_reg">
      <bits access="r" name="txdp_wedge_pm_p62_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p62" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p63_reg">
      <bits access="r" name="txdp_wedge_pm_p63_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p63" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p64_reg">
      <bits access="r" name="txdp_wedge_pm_p64_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p64" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pd_det_ctrl_reg">
      <bits access="r" name="pd_det_ctrl_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="cfg_ushift" pos="11:8" rst="0">
        <comment>
          power detect ushift
        </comment>
      </bits>
      <bits access="r" name="pd_det_ctrl_reg_reserved_1" pos="7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="cfg_pd_mode" pos="6:5" rst="0">
        <comment>
          adc clk mode for pd
00:30.72M
01:15.36M
10:7.68M
11:3.84M
        </comment>
      </bits>
      <bits access="rw" name="cfg_din_sel" pos="4" rst="0">
        <comment>
          source power detect 
1:real part of data
0:imag part of data
        </comment>
      </bits>
      <bits access="rw" name="cfg_rssi_clear" pos="3" rst="0">
        <comment>
          clear rssi value to 0 when txdp transmit finish
0: hold the last value
1: reset 
        </comment>
      </bits>
      <bits access="rw" name="cfg_pd_en" pos="2" rst="0">
        <comment>
          enable pd detect , active high.
0: disable
1: enable
        </comment>
      </bits>
      <bits access="rw" name="pd_clkgate_en" pos="1" rst="0">
        <comment>
          0: pd module clk gating enabled; 1: pd module clk always on
        </comment>
      </bits>
      <bits access="rw" name="pd_sw_resetn" pos="0" rst="0">
        <comment>
          Software reset for pd, active low.
0: reset
1: no reset
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pd_rssi_read_reg">
      <bits access="r" name="pd_rssi_reg" pos="15:4" rst="0">
        <comment>
          pd det value, it is stable when pd_rssi_reg_val is high
        </comment>
      </bits>
      <bits access="r" name="pd_rssi_read_reg_reserved_0" pos="3:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="pd_rssi_val_reg" pos="1" rst="0">
        <comment>
          valid indication of pd measurement report after assert pd_load to avoid metastability. 
        </comment>
      </bits>
      <bits access="rw" name="pd_load" pos="0" rst="0">
        <comment>
          start to load instant pd detect measurement report. Before next load, set it low firstly
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="cfg_pd_inval_num_reg">
      <bits access="rw" name="cfg_pd_inval_num" pos="15:0" rst="0">
        <comment>
          number of invalid data when calculate rssi
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="int_pd_det">
      <bits access="r" name="int_pd_det_reserved_0" pos="15:3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="pd_int" pos="2" rst="0">
        <comment>
          interrupt status to be able to start to load max and min measurement report
        </comment>
      </bits>
      <bits access="rw" name="pd_int_mask" pos="1" rst="0">
        <comment>
          interrupt mask
        </comment>
      </bits>
      <bits access="rw" name="pd_int_clear" pos="0" rst="0">
        <comment>
          interrupt clear
        </comment>
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "dma.xml">
<module name="dma" category="System">
  <reg protect="w" name="get_channel">
    <bits access="r" name="Get Channel" pos="0" rst="1">
      <comment>Returns 1 and locks the DMA channel for a transaction if it is
      available. Else returns 0. <br />Clear the transfer done interrupt
      status. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Enable" pos="0" rst="0">
      <comment>Status of the DMA: 1 if enabled, 0 if disabled. </comment>
    </bits>

    <bits access="r" name="Int Done Cause" pos="1" rst="0">
      <comment>Cause of the interrupt. This bit is set when the transfer is
      done and the interrupt mask bit is set. <br />Write one in the Int Clear
      or write 0 in Enable control bits to clear Int Done Cause bit.
      </comment>
    </bits>

    <bits access="r" name="Int Done Status" pos="2" rst="0">
      <comment>Status of the interrupt. Status of the transfer: 1 if the
      transfer is finished, 0 if it is not finished. <br />Write one in the
      Int Clear or write 0 in Enable control bits to clear Int Done Status
      bit. </comment>
    </bits>

    <bits access="r" name="Channel Lock" pos="4" rst="0">
      <comment>Actual status of channel lock. Channel is unlocked at the end
      of transaction or when the DMA is disabled. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="control">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <comment>Controls the DMA. Write 1 to enable the DMA, write 0 to disable
      it. When 0 is written in this register, the Int Done Status and Cause
      bits are reset. </comment>
    </bits>

    <bits access="rw" name="Int Done Mask" pos="1" rst="0">
      <comment>End of transfer interrupt generation. When 1, the DMA will send
      an interrupt at transaction completion. </comment>
      <options>
        <shift/>
      </options>  
    </bits>

    <bits access="rw" name="Int Done Clear" pos="2" rst="0">
      <comment>Clear the transfer done interruption (this will clear Int Done
      Status and Int Done Cause). <br />This bit is auto-clear. You will
      always read 0 here. </comment>
    </bits>

    <bits access="rw" name="Use Pattern" pos="4" rst="0">
      <comment>If this bit is set, the source address will be ignored and the
      memory will be fill with the value of the pattern register. </comment>
    </bits>

    <bits access="rw" name="max_burst_length" pos="6:5" rst="00">
      <comment>Set the MAX burst length. 
        <br/> The 2'b10 mean burst max 16, 2'b01 mean burst max 8, 00 mean burst max 4. 
      </comment>
    </bits>

    <bits access="rw" name="Stop Transfer" pos="8" rst="0">
      <comment>The DMA stop the current transfer and flush his FIFO (write
      only bit). When the FIFO is empty and last write performed, the DMA is
      disabled and available for a next transfer. The number of bytes copied
      is readable on DMA_XFER_SIZE register.</comment>
    </bits>

    <bits access="rw" name="GEA Enable" pos="12" rst="0">
      <options>
        <option name="DMA" value="0" />

        <option name="GEA" value="1" />

        <default />
      </options>

      <comment>Enable Gea process when 1.</comment>
    </bits>

    <bits access="rw" name="GEA Algorithm" pos="13" rst="1">
      <options>
        <option name="GEA1" value="0" />

        <option name="GEA2" value="1" />

        <default />
      </options>

      <comment>This field sets the type of GEA algorithm to process.</comment>
    </bits>

    <bits access="rw" name="GEA Direction" pos="14" rst="1">
      <options>
        <shift/>
      </options>
      <comment>This field selects the Direction in the GEA algorithm.
      </comment>
    </bits>

    <bits access="rw" name="FCS Enable" pos="16" rst="0">
      <options>
        <option name="NORMAL_DMA" value="0" />

        <option name="FCS_PROCESS" value="1" />

        <default />
      </options>

      <comment>Enable FCS process when 1.</comment>
    </bits>

    <bits access="rw" name="Dst Addr Mgt" pos="21:20" rst="0">
      <options>
        <option name="NORMAL_DMA" value="0" />

        <option name="CONST_ADDR" value="1" />

        <option name="ALTERN_ADDR" value="2" />

        <option name="RESERVED" value="3" />

        <default />
      </options>

      <comment>Destination address management.<br />00 : Normal DMA operation,
      DMA_DST_ADDR register define the destination address.<br /> 01 : DMA
      write address is constant (no incremented) and defined by the
      DMA_DST_ADDR register. All data write are in 16-bit.<br /> 10 : DMA
      write address is alternatively defined by DMA_DST_ADDR and
      DMA_SD_DST_ADDR registers. All data write are in 16-bit. <br />In this
      configuration, DMA write operation is alternatively: <br />DMA_DST_ADDR
      &lt;= DMA_PATTERN register <br />DMA_SD_DST_ADDR &lt;=
      Data[DMA_SRC_ADDR] <br />11 : reserved </comment>
    </bits>
  </reg>

  <reg protect="rw" name="src_addr">
    <bits access="rw" name="Src Address" pos="31:0" rst="0xFFFFFFF">
      <comment>Source start read byte address. When a transfer is stalled by
      the Stop_Transfer bit, this register give the next current source
      address, which is directly the value to re-program to complete the
      transfer stopped.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="dst_addr">
    <bits access="rw" name="Dst Address" pos="31:0" rst="0xFFFFFFF">
      <comment>Destination start read byte address. When a transfer is stalled
      by the Stop_Transfer bit, this register give the next current
      destination address, which is directly the value to re-program to
      complete the transfer stopped.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="sd_dst_addr">
    <bits access="rw" name="Sd Dst Address" pos="31:0" rst="0xFFFFFFF">
      <comment>Second destination address. This register is only used when
      Dst_Address_Mgt=10.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="xfer_size">
    <bits access="rw" name="Transfer Size" pos="17:0" rst="0x3FFFF">
      <comment>Transfer size in bytes. Maximum: 262144 bytes. When a transfer
      is stopped by the Stop_Transfer bit, this register give the number of
      remainder bytes to transfer.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="pattern">
    <bits access="rw" name="Pattern" pos="31:0" rst="0xFFFFFFFF">
      <comment>Value taken to fill the memory when the configuration bit Use
      Pattern is set. When the pattern mode is used the destination address
      must be 32-bit aligned and the transfer size multiple of 4. when
      Dst_Address_Mgt=10 Pattern is the data written at the address given by
      the Dst_Address register.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_kc_low">
    <bits access="rw" name="KC_LSB" pos="31:0" rst="0xFFFFFFFF">
      <comment>GEA key Kc, LSB bit [31:0]. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_kc_high">
    <bits access="rw" name="KC_MSB" pos="31:0" rst="0xFFFFFFFF">
      <comment>GEA key Kc, MSB bit [31:0]. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_messkey">
    <bits access="rw" name="MessKey" pos="31:0" rst="0xFFFFFFFF">
      <comment>MessKey (Input) register. </comment>
    </bits>
  </reg>

  <reg protect="r" name="fcs">
    <bits access="r" name="FCS" pos="23:0" rst="0">
      <comment>Frame Check Sequence.</comment>
    </bits>

    <bits access="r" name="FCS Correct" pos="31" rst="0">
      <comment>The FCS is correct in reception when the final remainder is
      equal to C(x)= x^22 + x^21 + x^19 + x^18 + x^16 + x^15 + x^11 + x^8 +
      x^5 + x^4</comment>
    </bits>

    
  </reg>
</module>
</archive>
<archive relative="efuse.xml">
  <module name="efuse" category="System">
    <hole size="64"/>
    <reg protect="rw" name="efuse_all0_index">
      <bits access="rw" name="efuse_all0_start_index" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="efuse_all0_end_index" pos="15:0" rst="127">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_mode_ctrl">
      <bits access="r" name="efuse_mode_ctrl_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="efuse_all0_check_start" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_cfg1">
      <bits access="r" name="efuse_cfg1_reserved_0" pos="31:25" rst="0">
      </bits>
      <bits access="rw" name="tpgm_time_cnt2" pos="24:16" rst="310">
      </bits>
      <bits access="r" name="efuse_cfg1_reserved_1" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="tpgm_time_cnt1" pos="8:0" rst="310">
      </bits>
    </reg>
    <reg protect="r" name="efuse_ip_ver">
      <bits access="r" name="efuse_ip_ver_reserved_0" pos="31:18" rst="0">
      </bits>
      <bits access="r" name="efuse_type" pos="17:16" rst="0">
      </bits>
      <bits access="r" name="efuse_ip_ver" pos="15:0" rst="2048">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_cfg0">
      <bits access="rw" name="clk_efs_div" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="efuse_strobe_low_width" pos="23:16" rst="0">
      </bits>
      <bits access="r" name="efuse_cfg0_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="tpgm_time_cnt" pos="8:0" rst="310">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_cfg2">
      <bits access="r" name="efuse_cfg2_reserved_0" pos="31:25" rst="0">
      </bits>
      <bits access="rw" name="tpgm_time_bist" pos="24:16" rst="310">
      </bits>
      <bits access="r" name="efuse_cfg2_reserved_1" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="tpgm_time_cnt3" pos="8:0" rst="310">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_ns_en">
      <bits access="r" name="efuse_ns_en_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="ns_lock_bit_wr_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="ns_margin_rd_enable" pos="3" rst="0">
      </bits>
      <bits access="rw" name="double_bit_en_ns" pos="2" rst="0">
      </bits>
      <bits access="rw" name="ns_auto_check_enable" pos="1" rst="0">
      </bits>
      <bits access="rw" name="ns_vdd_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse_ns_err_flag">
      <bits access="r" name="efuse_ns_err_flag_reserved_0" pos="31:14" rst="0">
      </bits>
      <bits access="r" name="ns_all0_check_flag" pos="13" rst="0">
      </bits>
      <bits access="r" name="ns_enk_err_flag" pos="12" rst="0">
      </bits>
      <bits access="r" name="ns_magnum_wr_flag" pos="11" rst="0">
      </bits>
      <bits access="r" name="ns_block0_rd_flag" pos="10" rst="0">
      </bits>
      <bits access="r" name="ns_vdd_on_rd_flag" pos="9" rst="0">
      </bits>
      <bits access="r" name="ns_pg_en_wr_flag" pos="8" rst="0">
      </bits>
      <bits access="r" name="efuse_ns_err_flag_reserved_1" pos="7:6" rst="0">
      </bits>
      <bits access="r" name="ns_word1_prot_flag" pos="5" rst="0">
      </bits>
      <bits access="r" name="ns_word0_prot_flag" pos="4" rst="0">
      </bits>
      <bits access="r" name="efuse_ns_err_flag_reserved_2" pos="3:2" rst="0">
      </bits>
      <bits access="r" name="ns_word1_err_flag" pos="1" rst="0">
      </bits>
      <bits access="r" name="ns_word0_err_flag" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_ns_flag_clr">
      <bits access="r" name="efuse_ns_flag_clr_reserved_0" pos="31:14" rst="0">
      </bits>
      <bits access="rw" name="ns_all0_check_clr" pos="13" rst="0">
      </bits>
      <bits access="rw" name="ns_enk_err_clr" pos="12" rst="0">
      </bits>
      <bits access="rw" name="ns_magnum_wr_clr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="ns_block0_rd_clr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="ns_vdd_on_rd_clr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="ns_pg_en_wr_clr" pos="8" rst="0">
      </bits>
      <bits access="r" name="efuse_ns_flag_clr_reserved_1" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="ns_word1_prot_clr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="ns_word0_prot_clr" pos="4" rst="0">
      </bits>
      <bits access="r" name="efuse_ns_flag_clr_reserved_2" pos="3:2" rst="0">
      </bits>
      <bits access="rw" name="ns_word1_err_clr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="ns_word0_err_clr" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_ns_magic_number">
      <bits access="r" name="efuse_ns_magic_number_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="ns_magic_nubmer" pos="15:0" rst="0">
      </bits>
    </reg>
    <hole size="128"/>
    <reg protect="rw" name="efuse_s_en">
      <bits access="r" name="efuse_s_en_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="s_lock_bit_wr_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="s_margin_rd_enable" pos="3" rst="0">
      </bits>
      <bits access="rw" name="double_bit_en_s" pos="2" rst="0">
      </bits>
      <bits access="rw" name="s_auto_check_enable" pos="1" rst="0">
      </bits>
      <bits access="rw" name="s_vdd_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse_s_err_flag">
      <bits access="r" name="efuse_s_err_flag_reserved_0" pos="31:14" rst="0">
      </bits>
      <bits access="r" name="s_all0_check_flag" pos="13" rst="0">
      </bits>
      <bits access="r" name="s_enk_err_flag" pos="12" rst="0">
      </bits>
      <bits access="r" name="s_magnum_wr_flag" pos="11" rst="0">
      </bits>
      <bits access="r" name="s_block0_rd_flag" pos="10" rst="0">
      </bits>
      <bits access="r" name="s_vdd_on_rd_flag" pos="9" rst="0">
      </bits>
      <bits access="r" name="s_pg_en_wr_flag" pos="8" rst="0">
      </bits>
      <bits access="r" name="efuse_s_err_flag_reserved_1" pos="7:6" rst="0">
      </bits>
      <bits access="r" name="s_word1_prot_flag" pos="5" rst="0">
      </bits>
      <bits access="r" name="s_word0_prot_flag" pos="4" rst="0">
      </bits>
      <bits access="r" name="efuse_s_err_flag_reserved_2" pos="3:2" rst="0">
      </bits>
      <bits access="r" name="s_word1_err_flag" pos="1" rst="0">
      </bits>
      <bits access="r" name="s_word0_err_flag" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_s_flag_clr">
      <bits access="r" name="efuse_s_flag_clr_reserved_0" pos="31:14" rst="0">
      </bits>
      <bits access="rw" name="s_all0_check_clr" pos="13" rst="0">
      </bits>
      <bits access="rw" name="s_enk_err_clr" pos="12" rst="0">
      </bits>
      <bits access="rw" name="s_magnum_wr_clr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="s_block0_rd_clr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="s_vdd_on_rd_clr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="s_pg_en_wr_clr" pos="8" rst="0">
      </bits>
      <bits access="r" name="efuse_s_flag_clr_reserved_1" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="s_word1_prot_clr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="s_word0_prot_clr" pos="4" rst="0">
      </bits>
      <bits access="r" name="efuse_s_flag_clr_reserved_2" pos="3:2" rst="0">
      </bits>
      <bits access="rw" name="s_word1_err_clr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="s_word0_err_clr" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_s_magic_number">
      <bits access="r" name="efuse_s_magic_number_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="s_magic_nubmer" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_fw_cfg">
      <bits access="r" name="efuse_fw_cfg_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="rw" name="access_prot" pos="1" rst="0">
      </bits>
      <bits access="rw" name="conf_prot" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_pw_swt">
      <bits access="r" name="efuse_pw_swt_reserved_0" pos="31:3" rst="0">
      </bits>
      <bits access="rw" name="ns_s_pg_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="efs_enk2_on" pos="1" rst="1">
      </bits>
      <bits access="rw" name="efs_enk1_on" pos="0" rst="0">
      </bits>
    </reg>
    <hole size="128"/>
    <reg protect="r" name="pw_on_rd_end_flag">
      <bits access="r" name="pw_on_rd_end_flag_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="pw_on_rd_end_flag" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="ns_s_flag">
      <bits access="r" name="ns_s_flag_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="ns_s_flag" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="r" name="por_read_data_sp">
      <bits access="r" name="por_read_data_sp" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="por_read_data_sp1">
      <bits access="r" name="por_read_data_sp1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="block1">
      <bits access="r" name="block1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="block24">
      <bits access="r" name="block24" pos="31:0" rst="0">
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "f8.xml">
<module name="cipher_f8" category="Baseband">
  
  <reg protect="rw" name="F8_CONF">
    <bits access="rw" name="F8_START" pos="0" rst="0">
      <comment>f8 start bit, 0: not start or finished ,  1: start</comment>
    </bits>
    
    <bits access="rw" name="F8_IRQ_EN" pos="1" rst="0">
      <comment> when all groups done , 0: no gen int 1: gen int </comment>
    </bits>
    
    <bits access="rw" name="F8_AR_SEL" pos="3:2" rst="0x0">
        <comment>function sel 00: only move data , no encrypt 
                              01:      move data , AES encrypt
                              10:      move data , snow3G encrypt
                              11:      move data , zuc encrypt
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="F8_GROUP_ADDR">
    <bits access="rw" name="GROUP_ADDR" pos="31:0" rst="0x0">
      <comment>group start address</comment>
    </bits>
  </reg>

  <reg protect="rw" name="F8_GROUP_CNT">
    <bits access="rw" name="GROUP_ADDR" pos="31:0" rst="0x0">
      <comment>total group cnt</comment>
    </bits>
  </reg>

  <reg protect="rw" name="F8_STATUS">
    <bits access="rw" name="F8_STAT" pos="0" rst="0">
      <comment>0: not started or no finished  1: finished</comment>
    </bits>

    <bits access="rw" name="F9_STAT" pos="1" rst="0">
      <comment>0: not started or no finished  1: finished</comment>
    </bits>
  </reg>

  <reg protect="rw" name="F9_CONF">
    <bits access="rw" name="F9_START" pos="0" rst="0">
      <comment>f9 start bit, 0: not start or finished ,  1: start</comment>
    </bits>
    
    <bits access="rw" name="F9_IRQ_EN" pos="1" rst="0">
      <comment> when all groups done , 0: no gen int 1: gen int </comment>
    </bits>
    
    <bits access="rw" name="F9_AR_SEL" pos="3:2" rst="0x0">
        <comment>function sel 00:  AES encrypt 
                              01:  AES encrypt
                              10:  snow3G encrypt
                              11:  zuc encrypt
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="F9_GROUP_ADDR">
    <bits access="rw" name="F9_ADDR" pos="31:0" rst="0x0">
      <comment>group start address</comment>
    </bits>
  </reg>

  <reg protect="r" name="F9_RESULT">
    <bits access="rw" name="F9_MAC" pos="31:0" rst="0x0">
      <comment>f9 result</comment>
    </bits>
  </reg>

</module>
</archive>

<archive relative = "gpio1.xml">

  <include file="gallite_generic_config.xml"/>

  <var name="NB_GPIO1" value="8" />

<module name="gpio1" category="Periph">

  

  <reg protect="rw" name="gpio_oen_val">
    <bits access="rw" name="oen_val" pos="NB_GPIO1-1:0" rst="0xffffffff" display="hex">
      <options>
        <option name="INPUT" value="1" />

        <option name="OUTPUT" value="0" />

        <default />
      </options>

      <comment>Set the direction of the GPIO n.<br />0 = output<br />1 =
      input</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_out">
    <bits access="rc" name="oen_set_out" pos="NB_GPIO1-1:0" rst="0">
      <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_in">
    <bits access="rs" name="oen_set_in" pos="NB_GPIO1-1:0" rst="0xffffffff" display="hex">
      <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpio_val">
    <bits access="rw" name="gpio_val" pos="NB_GPIO1-1:0" rst="0xffffffff" display="hex">
      <comment>When write, update the output value. When read, get the input
      value. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_set">
    <bits access="rs" name="gpio_set" pos="NB_GPIO1-1:0" rst="0">
      <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_clr">
    <bits access="rc" name="gpio_clr" pos="NB_GPIO1-1:0" rst="0">
      <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value. </comment>
    </bits>
  </reg>

  
  <reg protect="rw" name="gpint_ctrl_r">
    <bits access="rw" name="gpint_r" pos="NB_GPIO1-1:0" rst="0">
      <comment>'1',  for rising edge and level high. </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gpint_ctrl_f">
    <bits access="rw" name="gpint_f" pos="NB_GPIO1-1:0" rst="0">
      <comment>'1',  for falling edge and level low. </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gpint_ctrl_mode">
    <bits access="rw" name="gpint_mode" pos="NB_GPIO1-1:0" rst="0">
      <comment>'1',  for level mode. </comment>
    </bits>
  </reg>

  

  <reg protect="w" name="int_clr">
    <bits access="c" name="gpint_clr" pos="NB_GPIO1-1:0" rst="0">
      <comment>'Write '1' will clear GPIO interrupt.</comment>
    </bits>
  </reg>

  <reg protect="r" name="int_status">
    <bits access="r" name="gpint_status" pos="NB_GPIO1-1:0" rst="0">
      <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      <options>
        <default/>
        <mask/>
        <shift/>
      </options>
    </bits>
  </reg>

  

  <struct count="16" name="db_ctrl">
  <reg protect="rw" name="db_ctrl0">
    <bits access="rw" name="db_ctrl0" pos="2:0" rst="0x1" display="hex">
      <options>
        <option name="debounce_0ns"    value="0" />
        <option name="debounce_62.5ns" value="1" />
        <option name="debounce_125ns"  value="2" />
        <option name="debounce_250ns"  value="3" />
        <option name="debounce_500ns"  value="4" />
        <option name="debounce_1000ns" value="5" />
        <option name="debounce_2000ns" value="6" />
        <option name="debounce_4000ns" value="7" />
      </options>
      <comment>
      </comment>
    </bits>
  </reg>
  </struct>

  <reg protect="rw" name="gpint_ctrl">
    <bits access="rw" name="negedge_logic_en" pos="0" rst="0">
      <comment>'1',  open negedge logic. </comment>
    </bits>
  </reg>
</module>
</archive>

<archive relative = "gpio.xml">

  
  

  
  <var name="IDX_GPIO_DCON" value="0" />
  <var name="IDX_GPO_CHG"   value="0" />
  <var name="NB_GPIO"       value="64" />
  <var name="NB_GPIO_INT"   value="64" />
  <var name="NB_GPO"        value="10" />

<module name="gpio" category="Periph">

  
  
  <reg protect="rw" name="gpio_oen_val_l">
    <bits access="rw" name="oen_val_l" pos="31:0" rst="0xffffffff" display="hex">
      <options>
        <option name="INPUT" value="1" />

        <option name="OUTPUT" value="0" />

        <default />
      </options>

      <comment>Set the direction of the GPIO n.<br />0 = output<br />1 =
      input</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_out_l">
    <bits access="rc" name="oen_set_out_l" pos="31:0" rst="0xffffffff">
      <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_in_l">
    <bits access="rs" name="oen_set_in_l" pos="31:0" rst="0xffffffff" display="hex">
      <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpio_val_l">
    <bits access="rw" name="gpio_val_l" pos="31:0" rst="0xffffffff" display="hex">
      <comment>When write, update the output value. When read, get the input
      value. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_set_l">
    <bits access="rs" name="gpio_set_l" pos="31:0" rst="0xffffffff">
      <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_clr_l">
    <bits access="rc" name="gpio_clr_l" pos="31:0" rst="0xffffffff">
      <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value. </comment>
    </bits>
  </reg>


   <reg protect="rw" name="gpint_r_set_l">
     <bits access="rs" name="gpint_r_set_l" pos="31:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for rising edge and
       level high. When read, get the GPIO interrupt mask for rising edge and
       level high. </comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_r_set_h">
     <bits access="rs" name="gpint_r_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for rising edge and
       level high. When read, get the GPIO interrupt mask for rising edge and
       level high. </comment>
     </bits>
   </reg>

  <reg protect="w" name="int_clr_l">
    <bits access="c" name="gpint_clr_l" pos="31:0" rst="0">
      <comment>'Write '1' will clear GPIO interrupt.</comment>
    </bits>
  </reg>

  <reg protect="r" name="int_status_l">
    <bits access="r" name="gpint_status_l" pos="31:0" rst="0">
      <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      <options>
        <default/>
        <mask/>
        <shift/>
      </options>
    </bits>
  </reg>

  <reg protect="rw" name="chg_ctrl">
    <bits access="rw" name="out_time" pos="3:0" rst="0xf" display="hex">
        <comment>time for which GPIO0 is set to output mode, after a start read
            DCON command is issued.<br />The output time = (OUT_TIME+1)*30.5us.
        </comment>
    </bits>

    <bits access="rw" name="wait_time" pos="9:4" rst="0x3f" display="hex">
        <comment>time for which GPIO0 should wait before reading DC_ON, after
            a start read DCON command is issued.<br />The wait time = (WAIT_TIME+1)*30.5us.
            <br/>NOTE: wait_time must be strictly greater than out_time;
        </comment>
    </bits>

    <bits access="rw" name="int_mode" pos="17:16" rst="0x3" display="hex">
        <comment>interruption mode of GPIO0 in mode DC_ON detection.<br />
        </comment>
            <options>
                <option name="L2H" value="0">
                    <comment>
                        "00" = send IRQ if last read DCON is '0' and now is '1'. 
                    </comment>
                </option>
                <option name="H2L" value="1">
                    <comment>
                        "01" = send IRQ if last read DCON is '1' and now is '0'.
                    </comment>
                </option>
                <option name="RR" value="3">
                    <comment>
                        "11" = send IRQ every time read is ready.
                    </comment>
                </option>
            </options>
    </bits>
  </reg>

  <reg protect="w" name="chg_cmd">
    <bits access="s" name="dcon_mode_set" pos="0" rst="0">
      <comment>Write '1' to set GPIO0 to charger DCON detect mode.</comment>
    </bits>
      
    <bits access="s" name="chg_mode_set" pos="4" rst="0">
      <comment>Write '1' to set GPO0 to charger watchdog mode.</comment>
    </bits>

    <bits access="c" name="dcon_mode_clr" pos="8" rst="0">
      <comment>Write '1' to clear charger DCON detect mode of GPIO0.</comment>
    </bits>

    <bits access="c" name="chg_mode_clr" pos="12" rst="0">
      <comment>Write '1' to clear the charger watchdog mode of GPO0.</comment>
    </bits>

    <bits access="s" name="chg_down" pos="24" rst="0">
      <comment>Write '1' to generate a pulse of '0' on GPO0 for 16 CLK_OSC cycles.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpo_set">
    <bits access="rs" name="gpo_set" pos="NB_GPO-1:0" rst="0x2aa" display="hex">
      <comment>'Write '1' will set GPO output value. When read, get the GPO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpo_clr">
    <bits access="rc" name="gpo_clr" pos="NB_GPO-1:0" rst="0x2aa" display="hex">
      <comment>'Write '1' will clear GPO output value. When read, get the GPO
      output value.</comment>
    </bits>
  </reg>

  
  <reg protect="rw" name="gpio_oen_val_h">
    <bits access="rw" name="oen_val_h" pos="NB_GPIO-33:0" rst="0xffffffff" display="hex">
      <options>
        <option name="INPUT" value="1" />

        <option name="OUTPUT" value="0" />

        <default />
      </options>

      <comment>Set the direction of the GPIO n.<br />0 = output<br />1 =
      input</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_out_h">
    <bits access="rc" name="oen_set_out_h" pos="NB_GPIO-33:0" rst="0xffffffff">
      <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_in_h">
    <bits access="rs" name="oen_set_in_h" pos="NB_GPIO-33:0" rst="0xffffffff" display="hex">
      <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpio_val_h">
    <bits access="rw" name="gpio_val_h" pos="NB_GPIO-33:0" rst="0xffffffff" display="hex">
      <comment>When write, update the output value. When read, get the input
      value. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_set_h">
    <bits access="rs" name="gpio_set_h" pos="NB_GPIO-33:0" rst="0xffffffff">
      <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_clr_h">
    <bits access="rc" name="gpio_clr_h" pos="NB_GPIO-33:0" rst="0xffffffff">
      <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value. </comment>
    </bits>
  </reg>

  
  
   <reg protect="rw" name="gpint_r_clr_l">
     <bits access="rs" name="gpint_r_clr_l" pos="31:0" rst="0">
       <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
       level high.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_r_clr_h">
     <bits access="rs" name="gpint_r_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
       level high.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_f_set_l">
     <bits access="rs" name="gpint_f_set_l" pos="31:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for rising edge and
       level high. When read, get the GPIO interrupt mask for rising edge and
       level high. </comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_f_set_h">
     <bits access="rs" name="gpint_f_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for falling edge and
       level low. When read, get the GPIO interrupt mask for falling edge and
       level low.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_f_clr_l">
     <bits access="rs" name="gpint_f_clr_l" pos="31:0" rst="0">
       <comment>Write '1' will clear GPIO interrupt mask for falling edge and
       level low.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_f_clr_h">
     <bits access="rs" name="gpint_f_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will clear GPIO interrupt mask for falling edge and
       level low.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_dbn_en_set_l">
     <bits access="rs" name="dbn_en_set_l" pos="31:0" rst="0">
       <comment>Write '1' will enable debounce mechanism.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_dbn_en_set_h">
     <bits access="rs" name="dbn_en_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will enable debounce mechanism.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_dbn_en_clr_l">
     <bits access="rs" name="dbn_en_clr_l" pos="31:0" rst="0">
       <comment>Write '1' will disable debounce mechanism.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_dbn_en_clr_h">
     <bits access="rs" name="dbn_en_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will disable debounce mechanism.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_mode_set_l">
     <bits access="rs" name="gpint_mode_set_l" pos="31:0" rst="0">
       <comment>Write '1' will set interruption mode to level.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_mode_set_h">
     <bits access="rs" name="gpint_mode_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set interruption mode to level.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_mode_clr_l">
     <bits access="rs" name="gpint_mode_clr_l" pos="31:0" rst="0">
       <comment>Write '1' will set interruption mode to edge
       triggered.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_mode_clr_h">
     <bits access="rs" name="gpint_mode_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set interruption mode to edge
       triggered.</comment>
     </bits>
   </reg>

  <reg protect="r" name="int_status_h">
    <bits access="r" name="gpint_status_h" pos="NB_GPIO_INT-33:0" rst="0">
      <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      <options>
        <default/>
        <mask/>
        <shift/>
      </options>
    </bits>
  </reg>

  <reg protect="w" name="int_clr_h">
    <bits access="c" name="gpint_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
      <comment>'Write '1' will clear GPIO interrupt.</comment>
    </bits>
  </reg>


</module>


</archive>
<archive relative="gpt_lite.xml">
  <module name="gpt_lite" category="System">
    <reg protect="rw" name="cr">
      <bits access="rw" name="refclk_sel" pos="31" rst="1">
      </bits>
      <bits access="r" name="cr_reserved_0" pos="30:11" rst="0">
      </bits>
      <bits access="rw" name="tri_cnt_en" pos="10" rst="0">
        <comment>
          count input triger number enable
        </comment>
      </bits>
      <bits access="rw" name="tri" pos="9" rst="0">
        <comment>
          slave_mode trigger select
        </comment>
      </bits>
      <bits access="rw" name="arpe" pos="8" rst="1">
        <comment>
          auto preload value
        </comment>
      </bits>
      <bits access="rw" name="cms" pos="7:6" rst="0">
        <comment>
          Center-aligned mode select 00: disable , other:enable
        </comment>
      </bits>
      <bits access="rw" name="dir" pos="5" rst="0">
        <comment>
          counter dir , 0: cnt ++ , 1: cnt --
        </comment>
      </bits>
      <bits access="rw" name="opm" pos="4" rst="0">
        <comment>
          one pulse mode,  0:disable 1:enable
        </comment>
      </bits>
      <bits access="rw" name="udis" pos="3" rst="0">
        <comment>
          update disable, 0:disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="ckd" pos="2:1" rst="0">
        <comment>
          clock fdts didiver, 01: divided by 2 10:divided by 4, other:bypass
        </comment>
      </bits>
      <bits access="rw" name="cen" pos="0" rst="0">
        <comment>
          counter enable, 0: disbale, 1:enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="smcr">
      <bits access="r" name="smcr_reserved_0" pos="31:3" rst="0">
      </bits>
      <bits access="rw" name="sms" pos="2:0" rst="0">
        <comment>
          slave mode select: 100: slave mode, 101:gate mode, 110:trig mode, others disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="egr">
      <bits access="r" name="egr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="ug" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          user trigger gen
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccmr_oc">
      <bits access="r" name="ccmr_oc_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="oc2ce" pos="15" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc2m" pos="14:12" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc2pe" pos="11" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc2fe" pos="10" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc2s" pos="9:8" rst="1">
        <comment>
          channel source sel, bit[9] 0: output enable, 1 output disable bit[8] 0: use ti2, 1: use ti1
        </comment>
      </bits>
      <bits access="rw" name="oc1ce" pos="7" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc1m" pos="6:4" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc1pe" pos="3" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc1fe" pos="2" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc1s" pos="1:0" rst="1">
        <comment>
          channel source sel, bit[0] 0: output enable, 1 output disable bit[1] 0: use ti2, 1: use ti1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccmr_ic">
      <bits access="r" name="ccmr_ic_reserved_0" pos="31:14" rst="0">
      </bits>
      <bits access="rw" name="ic2f" pos="13:10" rst="0">
        <comment>
          ti2 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic2psc" pos="9:8" rst="0">
        <comment>
          ti2 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
      <bits access="r" name="ccmr_ic_reserved_1" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="ic1f" pos="5:2" rst="0">
        <comment>
          ti1 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic1psc" pos="1:0" rst="0">
        <comment>
          ti1 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccer">
      <bits access="r" name="ccer_reserved_0" pos="31:4" rst="0">
      </bits>
      <bits access="rw" name="cc2p" pos="3" rst="0">
        <comment>
          ti2 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc2e" pos="2" rst="0">
        <comment>
          ti2 enable
        </comment>
      </bits>
      <bits access="rw" name="cc1p" pos="1" rst="0">
        <comment>
          ti1 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc1e" pos="0" rst="0">
        <comment>
          ti1 enable
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="cnt">
      <bits access="r" name="cnt_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="cnt_value" pos="15:0" rst="0">
        <comment>
          cnt value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="psc">
      <bits access="r" name="psc_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="psc_value" pos="15:0" rst="0">
        <comment>
          cnt prescale value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="arr">
      <bits access="r" name="arr_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="arr_value" pos="15:0" rst="65535">
        <comment>
          cnt max value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr1_ic">
      <bits access="r" name="timer_ccr1_ic_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="timer_ccr1_capture" pos="15:0" rst="65535">
        <comment>
          ic1 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr2_ic">
      <bits access="r" name="timer_ccr2_ic_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="timer_ccr2_capture" pos="15:0" rst="65535">
        <comment>
          ic2 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr1_oc">
      <bits access="r" name="timer_ccr1_oc_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="timer_ccr1_compare" pos="15:0" rst="65535">
        <comment>
          ic1 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr2_oc">
      <bits access="r" name="timer_ccr2_oc_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="timer_ccr2_compare" pos="15:0" rst="65535">
        <comment>
          ic2 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="isr">
      <bits access="r" name="event_update" pos="31" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="r" name="slave_trig" pos="30" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="isr_reserved_0" pos="29:14" rst="0">
      </bits>
      <bits access="r" name="capture_int" pos="13:12" rst="0">
      </bits>
      <bits access="r" name="isr_reserved_1" pos="11:2" rst="0">
      </bits>
      <bits access="r" name="compare_int" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="irsr">
      <bits access="r" name="event_update" pos="31" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="r" name="slave_trig" pos="30" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="irsr_reserved_0" pos="29:14" rst="0">
      </bits>
      <bits access="r" name="capture_int" pos="13:12" rst="0">
      </bits>
      <bits access="r" name="irsr_reserved_1" pos="11:2" rst="0">
      </bits>
      <bits access="r" name="compare_int" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mask">
      <bits access="rw" name="event_update" pos="31" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="rw" name="slave_trig" pos="30" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="mask_reserved_0" pos="29:14" rst="0">
      </bits>
      <bits access="rw" name="capture_int" pos="13:12" rst="0">
      </bits>
      <bits access="r" name="mask_reserved_1" pos="11:2" rst="0">
      </bits>
      <bits access="rw" name="compare_int" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="clr">
      <bits access="rc" name="event_update" pos="31" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="rc" name="slave_trig" pos="30" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="clr_reserved_0" pos="29:14" rst="0">
      </bits>
      <bits access="rc" name="capture_int" pos="13:12" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="r" name="clr_reserved_1" pos="11:2" rst="0">
      </bits>
      <bits access="rc" name="compare_int" pos="1:0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="gpt.xml">
  <module name="gpt" category="System">
    <reg protect="rw" name="cr">
      <bits access="rw" name="refclk_sel" pos="31" rst="1">
      </bits>
      <bits access="r" name="cr_reserved_0" pos="30:13" rst="0">
      </bits>
      <bits access="rw" name="tri_cnt_en" pos="12" rst="0">
        <comment>
          Input triger number count enable
        </comment>
      </bits>
      <bits access="rw" name="tri" pos="11:9" rst="0">
        <comment>
          slave_mode trigger select
        </comment>
      </bits>
      <bits access="rw" name="arpe" pos="8" rst="1">
        <comment>
          auto preload value
        </comment>
      </bits>
      <bits access="rw" name="cms" pos="7:6" rst="0">
        <comment>
          Center-aligned mode select 00: disable , other:enable
        </comment>
      </bits>
      <bits access="rw" name="dir" pos="5" rst="0">
        <comment>
          counter dir , 0: cnt ++ , 1: cnt --
        </comment>
      </bits>
      <bits access="rw" name="opm" pos="4" rst="0">
        <comment>
          one pulse mode,  0:disable 1:enable
        </comment>
      </bits>
      <bits access="rw" name="udis" pos="3" rst="0">
        <comment>
          update disable, 0:disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="ckd" pos="2:1" rst="0">
        <comment>
          clock fdts didiver, 01: divided by 2 10:divided by 4, other:bypass
        </comment>
      </bits>
      <bits access="rw" name="cen" pos="0" rst="0">
        <comment>
          counter enable, 0: disbale, 1:enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="smcr">
      <bits access="r" name="smcr_reserved_0" pos="31:3" rst="0">
      </bits>
      <bits access="rw" name="sms" pos="2:0" rst="0">
        <comment>
          slave mode select: 100: slave mode, 101:gate mode, 110:trig mode, others disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="egr">
      <bits access="r" name="egr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="ug" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          user trigger gen
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccmr_oc1">
      <bits access="rw" name="oc4ce" pos="31" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc4m" pos="30:28" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc4pe" pos="27" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc4fe" pos="26" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc4s" pos="25:24" rst="1">
        <comment>
          channel source sel, bit[24] 0: output enable, 1 output disable bit[25] 0: use ti4, 1: use ti3
        </comment>
      </bits>
      <bits access="rw" name="oc3ce" pos="23" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc3m" pos="22:20" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc3pe" pos="19" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc3fe" pos="18" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc3s" pos="17:16" rst="1">
        <comment>
          channel source sel, bit[17] 0: output enable, 1 output disable bit[16] 0: use ti3, 1: use ti4
        </comment>
      </bits>
      <bits access="rw" name="oc2ce" pos="15" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc2m" pos="14:12" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc2pe" pos="11" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc2fe" pos="10" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc2s" pos="9:8" rst="1">
        <comment>
          channel source sel, bit[9] 0: output enable, 1 output disable bit[8] 0: use ti2, 1: use ti1
        </comment>
      </bits>
      <bits access="rw" name="oc1ce" pos="7" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc1m" pos="6:4" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc1pe" pos="3" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc1fe" pos="2" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc1s" pos="1:0" rst="1">
        <comment>
          channel source sel, bit[0] 0: output enable, 1 output disable bit[1] 0: use ti2, 1: use ti1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccmr_ic1">
      <bits access="r" name="ccmr_ic1_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="rw" name="ic4f" pos="29:26" rst="0">
        <comment>
          ti4 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic4psc" pos="25:24" rst="0">
        <comment>
          ti4 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
      <bits access="r" name="ccmr_ic1_reserved_1" pos="23:22" rst="0">
      </bits>
      <bits access="rw" name="ic3f" pos="21:18" rst="0">
        <comment>
          ti3 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic3psc" pos="17:16" rst="0">
        <comment>
          ti3 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
      <bits access="r" name="ccmr_ic1_reserved_2" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="ic2f" pos="13:10" rst="0">
        <comment>
          ti2 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic2psc" pos="9:8" rst="0">
        <comment>
          ti2 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
      <bits access="r" name="ccmr_ic1_reserved_3" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="ic1f" pos="5:2" rst="0">
        <comment>
          ti1 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic1psc" pos="1:0" rst="0">
        <comment>
          ti1 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccer">
      <bits access="r" name="ccer_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="cc4p" pos="7" rst="0">
        <comment>
          ti4 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc4e" pos="6" rst="0">
        <comment>
          ti4 enable
        </comment>
      </bits>
      <bits access="rw" name="cc3p" pos="5" rst="0">
        <comment>
          ti3 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc3e" pos="4" rst="0">
        <comment>
          ti3 enable
        </comment>
      </bits>
      <bits access="rw" name="cc2p" pos="3" rst="0">
        <comment>
          ti2 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc2e" pos="2" rst="0">
        <comment>
          ti2 enable
        </comment>
      </bits>
      <bits access="rw" name="cc1p" pos="1" rst="0">
        <comment>
          ti1 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc1e" pos="0" rst="0">
        <comment>
          ti1 enable
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="cnt">
      <bits access="r" name="cnt_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="cnt_value" pos="15:0" rst="0">
        <comment>
          cnt value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="psc">
      <bits access="r" name="psc_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="psc_value" pos="15:0" rst="0">
        <comment>
          cnt prescale value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="arr">
      <bits access="r" name="arr_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="arr_value" pos="15:0" rst="65535">
        <comment>
          cnt max value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr1_ic">
      <bits access="r" name="timer_ccr1_ic_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="timer_ccr1_capture" pos="15:0" rst="65535">
        <comment>
          ic1 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr2_ic">
      <bits access="r" name="timer_ccr2_ic_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="timer_ccr2_capture" pos="15:0" rst="65535">
        <comment>
          ic2 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr3_ic">
      <bits access="r" name="timer_ccr3_ic_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="timer_ccr3_capture" pos="15:0" rst="65535">
        <comment>
          ic3 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr4_ic">
      <bits access="r" name="timer_ccr4_ic_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="timer_ccr4_capture" pos="15:0" rst="65535">
        <comment>
          ic4 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr1_oc">
      <bits access="r" name="timer_ccr1_oc_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="timer_ccr1_compare" pos="15:0" rst="65535">
        <comment>
          ic1 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr2_oc">
      <bits access="r" name="timer_ccr2_oc_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="timer_ccr2_compare" pos="15:0" rst="65535">
        <comment>
          ic2 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr3_oc">
      <bits access="r" name="timer_ccr3_oc_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="timer_ccr3_compare" pos="15:0" rst="65535">
        <comment>
          ic3 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr4_oc">
      <bits access="r" name="timer_ccr4_oc_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="timer_ccr4_compare" pos="15:0" rst="65535">
        <comment>
          ic4 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="isr">
      <bits access="r" name="event_update" pos="31" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="r" name="slave_trig" pos="30" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="isr_reserved_0" pos="29:16" rst="0">
      </bits>
      <bits access="r" name="capture_int" pos="15:12" rst="0">
      </bits>
      <bits access="r" name="isr_reserved_1" pos="11:4" rst="0">
      </bits>
      <bits access="r" name="compare_int" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="irsr">
      <bits access="r" name="event_update" pos="31" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="r" name="slave_trig" pos="30" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="irsr_reserved_0" pos="29:16" rst="0">
      </bits>
      <bits access="r" name="capture_int" pos="15:12" rst="0">
      </bits>
      <bits access="r" name="irsr_reserved_1" pos="11:4" rst="0">
      </bits>
      <bits access="r" name="compare_int" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mask">
      <bits access="rw" name="event_update" pos="31" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="rw" name="slave_trig" pos="30" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="mask_reserved_0" pos="29:16" rst="0">
      </bits>
      <bits access="rw" name="capture_int" pos="15:12" rst="0">
      </bits>
      <bits access="r" name="mask_reserved_1" pos="11:4" rst="0">
      </bits>
      <bits access="rw" name="compare_int" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="clr">
      <bits access="rc" name="event_update" pos="31" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="rc" name="slave_trig" pos="30" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="clr_reserved_0" pos="29:16" rst="0">
      </bits>
      <bits access="rc" name="capture_int" pos="15:12" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="r" name="clr_reserved_1" pos="11:4" rst="0">
      </bits>
      <bits access="rc" name="compare_int" pos="3:0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "i2c_master.xml">

<module name="i2c_master" category="Periph">
    
    <reg protect="rw" name="CTRL">
        
 		<bits access="rw" name="EN" pos="0" rst="0">
			<comment> I2C master enable, high active. 
			</comment>
		</bits>
        
		<bits access="rw" name="IRQ_MASK" pos="8" rst="0">
			<comment> I2C master interrupt enable, high active. 
			</comment>
		</bits>
        
		<bits access="rw" name="Clock_Prescale" pos="31:16" rst="0xFFFF">
            <comment> This register is used to prescale the SCL clock line. Due to the structure of I2C interface, this module uses a 5*SCL clock frequency. Clock_Prescale must be programmed to this 5*SCL clock frequency (minus 1). Change the value of Clock_Prescale only when bit EN is cleared. <br /> <br /> Example:<br /> PCLK_MOD is 52 MHz, desired SCL is 100 KHz. <br /> Prescale = 52MHz / (5 * 100KHz) -1 = 103.
			</comment>
            <options><mask/></options>
		</bits>
	</reg>

    <reg protect="r" name="STATUS">
        
        <bits access="r" name="IRQ_Cause" pos="0" rst="0">
			<comment> IRQ Cause bit. This bit is set when one byte transfer has been completed or arbitration is lost, this bit is generated by bit IRQ_Status AND bit IRQ_MASK.
			</comment>
        </bits>
        
		<bits access="r" name="IRQ_Status" pos="4" rst="0">
			<comment> IRQ status bit. 
			</comment>
        </bits>
        
		<bits access="r" name="TIP" pos="8" rst="0">
			<comment> TIP, Transfer in progress.
				'1' when transferring data. '0' when transfer complete.
			</comment>
		</bits>
        
		<bits access="r" name="AL" pos="12" rst="0">
			<comment> AL,Arbitration lost.
				This bit is set when the I2C master lost arbitration.
			</comment>
		</bits>
        
		<bits access="r" name="Busy" pos="16" rst="0">
			<comment> Busy,I2C bus busy.
				'1' after START signal detected.
				'0' after STOP signal detected.
			</comment>
		</bits>
        
		<bits access="r" name="RxACK" pos="20" rst="0">
			<comment> RxACK, Received acknowledge from slave.
				'1'= "No ACK" received.
				'0'= ACK received.
			</comment>
		</bits>
        
		<bits access="r" name="writing" pos="24" rst="0">
			<comment> Register writing is in process.
				'1'= Register writing is in process.
				'0'= Register writing is done.
			</comment>
		</bits>
    </reg>
    
	<reg protect="rw" name="TXRX_BUFFER">
        
		<bits access="w" name="TX_DATA" pos="7:0" rst="-">
			<comment> Byte to transmit via I2C. <br /> for Bit 0, In case of a data transfer this bit represents the data's LSB. In case of a slave address transfer this bit represents the RW bit. <br /> '1' = reading from slave. <br /> '0' = writing to slave.   
			</comment>
		</bits>

 		<bits access="r" name="RX_DATA" pos="7:0" rst="-">
			<comment> Last byte received via I2C. 
			</comment>
		</bits>
        
	</reg>

	<reg protect="w" name="CMD">

		<bits access="w" name="ACK" pos="0" rst="0">
			<comment> ACK,when master works as a receiver,sent ACK(ACK='0') or NACK(ACK='1').
			</comment>
		</bits>

		<bits access="w" name="RD" pos="4" rst="0">
			<comment> RD,read from slave, this bit is auto cleared.
			</comment>
		</bits>

		<bits access="w" name="STO" pos="8" rst="0">
			<comment> STO,generate stop condition, this bit is auto cleared.
			</comment>
		</bits>
        
		<bits access="w" name="WR" pos="12" rst="0">
			<comment> WR,write to slave, this bit is auto cleared.
			</comment>
		</bits>

		<bits access="w" name="STA" pos="16" rst="0">
			<comment> STA,generate (repeated) start condition, this bit is auto cleared.
			</comment>
		</bits>
    </reg>

  	<reg protect="rw" name="IRQ_CLR">  
        
		<bits access="c" name="IRQ_Clr" pos="0" rst="0">
			<comment> When write '1', clears a pending I2C interrupt.
			</comment>
        </bits>
    </reg>
    

</module>
</archive>

<archive relative = "i2s.xml">
  <module name="i2s" category="Periph">
    <reg protect="rw" name="i2s_ctrl">
      <bits access="rw" name="rx_int_sel" pos="20:19" rst="0">
      </bits>
      <bits access="rw" name="tx_int_sel" pos="18:17" rst="0">
      </bits>
      <bits access="rw" name="rx_swap" pos="16" rst="0">
      </bits>
      <bits access="rw" name="tx_swap" pos="15" rst="0">
      </bits>
      <bits access="rw" name="bclk_lrck_ratio" pos="14:12" rst="0">
      </bits>
      <bits access="rw" name="bit_delay" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="word_length" pos="9:8" rst="0">
      </bits>
      <bits access="rw" name="audio_mode" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="lrck_pol" pos="5" rst="0">
      </bits>
      <bits access="rw" name="bclk_pol" pos="4" rst="0">
      </bits>
      <bits access="rw" name="ctrl_mode" pos="3" rst="0">
      </bits>
      <bits access="rw" name="dma_mode" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rx_enable" pos="1" rst="0">
      </bits>
      <bits access="rw" name="tx_enable" pos="0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:21" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="i2s_fifo_ctrl">
      <bits access="rw" name="rx_fifo_clr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="tx_fifo_clr" pos="0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:2" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="i2s_data">
      <bits access="rw" name="txrx_data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="i2s_status">
      <bits access="r" name="tx_active" pos="6" rst="0">
      </bits>
      <bits access="r" name="rx_fifo_level" pos="5:3" rst="0">
      </bits>
      <bits access="r" name="tx_fifo_level" pos="2:0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:7" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="i2s_int_en">
      <bits access="rw" name="slv_err_en" pos="6" rst="0">
      </bits>
      <bits access="rw" name="rx_fifo_almost_full_en" pos="5" rst="0">
      </bits>
      <bits access="rw" name="rx_fifo_full_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="tx_fifo_almost_empty_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="tx_fifo_empty_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="dma_rx_done_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="dma_tx_done_en" pos="0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:7" rst="0">
      </bits>
    </reg>                            
    <reg protect="r" name="i2s_int_status">
      <bits access="rw" name="slv_err" pos="6" rst="0">
      </bits>
      <bits access="r" name="rx_fifo_full" pos="5" rst="0">
      </bits>
      <bits access="r" name="tx_fifo_empty" pos="4" rst="1">
      </bits>
      <bits access="r" name="rx_fifo_nempty" pos="3" rst="0">
      </bits>
      <bits access="r" name="tx_fifo_nfull" pos="2" rst="1">
      </bits>
      <bits access="r" name="dma_rx_done" pos="1" rst="0">
      </bits>
      <bits access="r" name="dma_tx_done" pos="0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:7" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="i2s_int_cause">
      <bits access="rw" name="slv_err_int" pos="6" rst="0">
      </bits>
      <bits access="r" name="rx_fifo_almost_full_int" pos="5" rst="0">
      </bits>
      <bits access="r" name="rx_fifo_full_int" pos="4" rst="0">
      </bits>
      <bits access="r" name="tx_fifo_almost_empty_int" pos="3" rst="0">
      </bits>
      <bits access="r" name="tx_fifo_empty_int" pos="2" rst="0">
      </bits>
      <bits access="r" name="dma_rx_done_int" pos="1" rst="0">
      </bits>
      <bits access="r" name="dma_tx_done_int" pos="0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:7" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="i2s_int_clr">
      <bits access="rw" name="slv_err_clr" pos="6" rst="0">
      </bits>
      <bits access="rc" name="rx_fifo_almost_full_clr" pos="5" rst="0">
      </bits>
      <bits access="rc" name="rx_fifo_full_clr" pos="4" rst="0">
      </bits>
      <bits access="rc" name="tx_fifo_almost_empty_clr" pos="3" rst="0">
      </bits>
      <bits access="rc" name="tx_fifo_empty_clr" pos="2" rst="0">
      </bits>
      <bits access="rc" name="dma_rx_done_clr" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="dma_tx_done_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="reserved" pos="31:7" rst="0">
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "iomux1.xml">
<module name="iomux1" category="System">
  
 

  <reg name="pad_GPIO_0_cfg" protect="rw">
     <bits name="pad_GPIO_0_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_0 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_0_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_0 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_0_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_0 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_0_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_0_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_0 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_0_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_0 PUll up</comment>
     <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
     </options>
     </bits>
     <bits name="pad_GPIO_0_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_0_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_0 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_0 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_0 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_0 select</comment>
     <options>
            <option name="fun_GPIO_0_sel" value ="0"></option>
            <option name="fun_UART1_RXD_sel" value ="1"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_1_cfg" protect="rw">
     <bits name="pad_GPIO_1_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_1 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_1_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_1 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_1_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_1 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_1_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_1_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_1 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_1_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_1 PUll up</comment>
     <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
     </options>
     </bits>
     <bits name="pad_GPIO_1_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_1_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_1 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_1 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_1 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_1 select</comment>
     <options>
            <option name="fun_GPIO_1_sel" value ="0"></option>
            <option name="fun_UART1_TXD_sel" value ="1"></option>
            <option name="fun_GPT1_TI_0_sel" value ="3"></option>
            <option name="fun_GPT1_PWM_0_sel" value ="4"></option>
            <option name="fun_CLK_32K_sel" value ="6"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_2_cfg" protect="rw">
     <bits name="pad_GPIO_2_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_2 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_2_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_2 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_2_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_2 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_2_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_2 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_2_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_2 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_2_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_2 PUll up</comment>
     <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
     </options>
     </bits>
     <bits name="pad_GPIO_2_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_2 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_2_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_2 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_2_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_2 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_2_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_2 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_2 select</comment>
     <options>
            <option name="fun_GPIO_2_sel" value ="0"></option>
            <option name="fun_UART1_CTS_sel" value ="1"></option>
            <option name="fun_I2C3_SCL_sel" value ="2"></option>
            <option name="fun_GPT1_TI_0_sel" value ="3"></option>
            <option name="fun_GPT1_PWM_0_sel" value ="4"></option>
            <option name="fun_UART2_RXD_sel" value ="5"></option>
            <option name="fun_CLK_32K_sel" value ="6"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_3_cfg" protect="rw">
     <bits name="pad_GPIO_3_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_3 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_3_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_3 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_3_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_3 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_3_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_3 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_3_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_3 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_3_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_3 PUll up</comment>
     <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
     </options>
     </bits>
     <bits name="pad_GPIO_3_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_3 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_3_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_3 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_3_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_3 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_3_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_3 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_3 select</comment>
     <options>
            <option name="fun_GPIO_3_sel" value ="0"></option>
            <option name="fun_UART1_RTS_sel" value ="1"></option>
            <option name="fun_I2C3_SDA_sel" value ="2"></option>
            <option name="fun_GPT1_TI_1_sel" value ="3"></option>
            <option name="fun_GPT1_PWM_1_sel" value ="4"></option>
            <option name="fun_UART2_TXD_sel" value ="5"></option>
            <option name="fun_CLK_32K_sel" value ="6"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_4_cfg" protect="rw">
     <bits name="pad_GPIO_4_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_4 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_4_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_4 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_4_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_4 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_4_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_4 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_4_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_4 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_4_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_4 PUll up</comment>
     <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
     </options>
     </bits>
     <bits name="pad_GPIO_4_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_4 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_4_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_4 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_4_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_4 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_4_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_4 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_4_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_4 select</comment>
     <options>
            <option name="fun_GPIO_4_sel" value ="0"></option>
            <option name="fun_SPI2_CLK_sel" value ="1"></option>
            <option name="fun_GPT1_PWM_0_sel" value ="4"></option>
            <option name="fun_UART2_RXD_sel" value ="5"></option>
            <option name="fun_CLK_32K_sel" value ="6"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_5_cfg" protect="rw">
     <bits name="pad_GPIO_5_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_5 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_5_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_5 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_5_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_5 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_5_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_5 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_5_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_5 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_5_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_5 PUll up</comment>
     <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
     </options>
     </bits>
     <bits name="pad_GPIO_5_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_5 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_5_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_5 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_5_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_5 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_5_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_5 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_5_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_5 select</comment>
     <options>
            <option name="fun_GPIO_5_sel" value ="0"></option>
            <option name="fun_SPI2_CS_sel" value ="1"></option>
            <option name="fun_GPT1_PWM_1_sel" value ="4"></option>
            <option name="fun_UART2_TXD_sel" value ="5"></option>
            <option name="fun_CLK_32K_sel" value ="6"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_6_cfg" protect="rw">
     <bits name="pad_GPIO_6_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_6 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_6_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_6 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_6_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_6 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_6_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_6 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_6_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_6 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_6_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_6 PUll up</comment>
     <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
     </options>
     </bits>
     <bits name="pad_GPIO_6_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_6 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_6_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_6 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_6_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_6 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_6_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_6 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_6_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_6 select</comment>
     <options>
            <option name="fun_GPIO_6_sel" value ="0"></option>
            <option name="fun_SPI2_DI_0_sel" value ="1"></option>
            <option name="fun_I2C3_SCL_sel" value ="2"></option>
            <option name="fun_GPT1_TI_0_sel" value ="3"></option>
            <option name="fun_GPT1_PWM_0_sel" value ="4"></option>
            <option name="fun_UART2_CTS_sel" value ="5"></option>
            <option name="fun_CLK_32K_sel" value ="6"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_7_cfg" protect="rw">
     <bits name="pad_GPIO_7_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_7 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_7_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_7 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_7_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_7 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_7_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_7 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_7_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_7 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_7_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_7 PUll up</comment>
     <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
     </options>
     </bits>
     <bits name="pad_GPIO_7_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_7 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_7_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_7 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_7_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_7 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_7_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_7 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_7_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_7 select</comment>
     <options>
            <option name="fun_GPIO_7_sel" value ="0"></option>
            <option name="fun_SPI2_DI_1_sel" value ="1"></option>
            <option name="fun_I2C3_SDA_sel" value ="2"></option>
            <option name="fun_GPT1_TI_1_sel" value ="3"></option>
            <option name="fun_GPT1_PWM_1_sel" value ="4"></option>
            <option name="fun_UART2_RTS_sel" value ="5"></option>
            <option name="fun_CLK_32K_sel" value ="6"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
   </module>
</archive>
<archive relative = "iomux2.xml">
<module name="iomux2" category="System">
  
 

  <reg name="pad_M_DQ_0_cfg" protect="rw">
     <bits name="pad_M_DQ_0_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_DQ_0 shimit enable. </comment>
     </bits>
     <bits name="pad_M_DQ_0_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_DQ_0 input enable. </comment>
     </bits>
     <bits name="pad_M_DQ_0_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_DQ_0 driving strength. </comment>
     </bits>
     <bits name="pad_M_DQ_0_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_DQ_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_DQ_0_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_DQ_0 PUll down</comment>
     </bits>
     <bits name="pad_M_DQ_0_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_DQ_0 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_DQ_0_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_DQ_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_DQ_0_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_DQ_0 force outoen value. </comment>
     </bits>
     <bits name="pad_M_DQ_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_DQ_0 force output value for output. </comment>
     </bits>
     <bits name="pad_M_DQ_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_DQ_0 pin output value. </comment>
     </bits>
     <bits name="pad_M_DQ_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_0 select</comment>
     <options>
            <option name="fun_M_DQ_0_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_DQ_1_cfg" protect="rw">
     <bits name="pad_M_DQ_1_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_DQ_1 shimit enable. </comment>
     </bits>
     <bits name="pad_M_DQ_1_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_DQ_1 input enable. </comment>
     </bits>
     <bits name="pad_M_DQ_1_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_DQ_1 driving strength. </comment>
     </bits>
     <bits name="pad_M_DQ_1_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_DQ_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_DQ_1_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_DQ_1 PUll down</comment>
     </bits>
     <bits name="pad_M_DQ_1_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_DQ_1 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_DQ_1_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_DQ_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_DQ_1_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_DQ_1 force outoen value. </comment>
     </bits>
     <bits name="pad_M_DQ_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_DQ_1 force output value for output. </comment>
     </bits>
     <bits name="pad_M_DQ_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_DQ_1 pin output value. </comment>
     </bits>
     <bits name="pad_M_DQ_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_1 select</comment>
     <options>
            <option name="fun_M_DQ_1_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_DQ_2_cfg" protect="rw">
     <bits name="pad_M_DQ_2_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_DQ_2 shimit enable. </comment>
     </bits>
     <bits name="pad_M_DQ_2_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_DQ_2 input enable. </comment>
     </bits>
     <bits name="pad_M_DQ_2_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_DQ_2 driving strength. </comment>
     </bits>
     <bits name="pad_M_DQ_2_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_DQ_2 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_DQ_2_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_DQ_2 PUll down</comment>
     </bits>
     <bits name="pad_M_DQ_2_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_DQ_2 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_DQ_2_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_DQ_2 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_DQ_2_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_DQ_2 force outoen value. </comment>
     </bits>
     <bits name="pad_M_DQ_2_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_DQ_2 force output value for output. </comment>
     </bits>
     <bits name="pad_M_DQ_2_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_DQ_2 pin output value. </comment>
     </bits>
     <bits name="pad_M_DQ_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_2 select</comment>
     <options>
            <option name="fun_M_DQ_2_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_DQ_3_cfg" protect="rw">
     <bits name="pad_M_DQ_3_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_DQ_3 shimit enable. </comment>
     </bits>
     <bits name="pad_M_DQ_3_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_DQ_3 input enable. </comment>
     </bits>
     <bits name="pad_M_DQ_3_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_DQ_3 driving strength. </comment>
     </bits>
     <bits name="pad_M_DQ_3_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_DQ_3 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_DQ_3_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_DQ_3 PUll down</comment>
     </bits>
     <bits name="pad_M_DQ_3_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_DQ_3 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_DQ_3_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_DQ_3 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_DQ_3_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_DQ_3 force outoen value. </comment>
     </bits>
     <bits name="pad_M_DQ_3_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_DQ_3 force output value for output. </comment>
     </bits>
     <bits name="pad_M_DQ_3_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_DQ_3 pin output value. </comment>
     </bits>
     <bits name="pad_M_DQ_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_3 select</comment>
     <options>
            <option name="fun_M_DQ_3_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_DQ_4_cfg" protect="rw">
     <bits name="pad_M_DQ_4_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_DQ_4 shimit enable. </comment>
     </bits>
     <bits name="pad_M_DQ_4_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_DQ_4 input enable. </comment>
     </bits>
     <bits name="pad_M_DQ_4_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_DQ_4 driving strength. </comment>
     </bits>
     <bits name="pad_M_DQ_4_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_DQ_4 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_DQ_4_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_DQ_4 PUll down</comment>
     </bits>
     <bits name="pad_M_DQ_4_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_DQ_4 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_DQ_4_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_DQ_4 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_DQ_4_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_DQ_4 force outoen value. </comment>
     </bits>
     <bits name="pad_M_DQ_4_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_DQ_4 force output value for output. </comment>
     </bits>
     <bits name="pad_M_DQ_4_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_DQ_4 pin output value. </comment>
     </bits>
     <bits name="pad_M_DQ_4_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_4 select</comment>
     <options>
            <option name="fun_M_DQ_4_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_DQ_5_cfg" protect="rw">
     <bits name="pad_M_DQ_5_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_DQ_5 shimit enable. </comment>
     </bits>
     <bits name="pad_M_DQ_5_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_DQ_5 input enable. </comment>
     </bits>
     <bits name="pad_M_DQ_5_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_DQ_5 driving strength. </comment>
     </bits>
     <bits name="pad_M_DQ_5_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_DQ_5 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_DQ_5_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_DQ_5 PUll down</comment>
     </bits>
     <bits name="pad_M_DQ_5_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_DQ_5 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_DQ_5_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_DQ_5 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_DQ_5_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_DQ_5 force outoen value. </comment>
     </bits>
     <bits name="pad_M_DQ_5_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_DQ_5 force output value for output. </comment>
     </bits>
     <bits name="pad_M_DQ_5_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_DQ_5 pin output value. </comment>
     </bits>
     <bits name="pad_M_DQ_5_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_5 select</comment>
     <options>
            <option name="fun_M_DQ_5_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_DQ_6_cfg" protect="rw">
     <bits name="pad_M_DQ_6_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_DQ_6 shimit enable. </comment>
     </bits>
     <bits name="pad_M_DQ_6_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_DQ_6 input enable. </comment>
     </bits>
     <bits name="pad_M_DQ_6_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_DQ_6 driving strength. </comment>
     </bits>
     <bits name="pad_M_DQ_6_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_DQ_6 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_DQ_6_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_DQ_6 PUll down</comment>
     </bits>
     <bits name="pad_M_DQ_6_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_DQ_6 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_DQ_6_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_DQ_6 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_DQ_6_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_DQ_6 force outoen value. </comment>
     </bits>
     <bits name="pad_M_DQ_6_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_DQ_6 force output value for output. </comment>
     </bits>
     <bits name="pad_M_DQ_6_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_DQ_6 pin output value. </comment>
     </bits>
     <bits name="pad_M_DQ_6_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_6 select</comment>
     <options>
            <option name="fun_M_DQ_6_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_DQ_7_cfg" protect="rw">
     <bits name="pad_M_DQ_7_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_DQ_7 shimit enable. </comment>
     </bits>
     <bits name="pad_M_DQ_7_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_DQ_7 input enable. </comment>
     </bits>
     <bits name="pad_M_DQ_7_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_DQ_7 driving strength. </comment>
     </bits>
     <bits name="pad_M_DQ_7_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_DQ_7 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_DQ_7_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_DQ_7 PUll down</comment>
     </bits>
     <bits name="pad_M_DQ_7_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_DQ_7 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_DQ_7_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_DQ_7 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_DQ_7_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_DQ_7 force outoen value. </comment>
     </bits>
     <bits name="pad_M_DQ_7_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_DQ_7 force output value for output. </comment>
     </bits>
     <bits name="pad_M_DQ_7_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_DQ_7 pin output value. </comment>
     </bits>
     <bits name="pad_M_DQ_7_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_7 select</comment>
     <options>
            <option name="fun_M_DQ_7_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_CS_cfg" protect="rw">
     <bits name="pad_M_CS_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_CS shimit enable. </comment>
     </bits>
     <bits name="pad_M_CS_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_CS input enable. </comment>
     </bits>
     <bits name="pad_M_CS_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_CS driving strength. </comment>
     </bits>
     <bits name="pad_M_CS_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_CS force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_CS_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_CS PUll down</comment>
     </bits>
     <bits name="pad_M_CS_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_CS PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_CS_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_CS force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_CS_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_CS force outoen value. </comment>
     </bits>
     <bits name="pad_M_CS_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_CS force output value for output. </comment>
     </bits>
     <bits name="pad_M_CS_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_CS pin output value. </comment>
     </bits>
     <bits name="pad_M_CS_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_CS select</comment>
     <options>
            <option name="fun_M_CS_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_DM_cfg" protect="rw">
     <bits name="pad_M_DM_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_DM shimit enable. </comment>
     </bits>
     <bits name="pad_M_DM_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_DM input enable. </comment>
     </bits>
     <bits name="pad_M_DM_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_DM driving strength. </comment>
     </bits>
     <bits name="pad_M_DM_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_DM force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_DM_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_DM PUll down</comment>
     </bits>
     <bits name="pad_M_DM_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_DM PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_DM_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_DM force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_DM_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_DM force outoen value. </comment>
     </bits>
     <bits name="pad_M_DM_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_DM force output value for output. </comment>
     </bits>
     <bits name="pad_M_DM_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_DM pin output value. </comment>
     </bits>
     <bits name="pad_M_DM_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DM select</comment>
     <options>
            <option name="fun_M_DM_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_CLK_cfg" protect="rw">
     <bits name="pad_M_CLK_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_CLK shimit enable. </comment>
     </bits>
     <bits name="pad_M_CLK_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_CLK input enable. </comment>
     </bits>
     <bits name="pad_M_CLK_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_CLK driving strength. </comment>
     </bits>
     <bits name="pad_M_CLK_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_CLK force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_CLK_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_CLK PUll down</comment>
     </bits>
     <bits name="pad_M_CLK_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_CLK PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_CLK_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_CLK force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_CLK_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_CLK force outoen value. </comment>
     </bits>
     <bits name="pad_M_CLK_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_CLK force output value for output. </comment>
     </bits>
     <bits name="pad_M_CLK_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_CLK pin output value. </comment>
     </bits>
     <bits name="pad_M_CLK_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_CLK select</comment>
     <options>
            <option name="fun_M_CLK_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_CLKB_cfg" protect="rw">
     <bits name="pad_M_CLKB_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_CLKB shimit enable. </comment>
     </bits>
     <bits name="pad_M_CLKB_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_CLKB input enable. </comment>
     </bits>
     <bits name="pad_M_CLKB_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_CLKB driving strength. </comment>
     </bits>
     <bits name="pad_M_CLKB_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_CLKB force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_CLKB_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_CLKB PUll down</comment>
     </bits>
     <bits name="pad_M_CLKB_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_CLKB PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_CLKB_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_CLKB force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_CLKB_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_CLKB force outoen value. </comment>
     </bits>
     <bits name="pad_M_CLKB_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_CLKB force output value for output. </comment>
     </bits>
     <bits name="pad_M_CLKB_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_CLKB pin output value. </comment>
     </bits>
     <bits name="pad_M_CLKB_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_CLKB select</comment>
     <options>
            <option name="fun_M_CLKB_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_DQS_cfg" protect="rw">
     <bits name="pad_M_DQS_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_DQS shimit enable. </comment>
     </bits>
     <bits name="pad_M_DQS_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_DQS input enable. </comment>
     </bits>
     <bits name="pad_M_DQS_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_DQS driving strength. </comment>
     </bits>
     <bits name="pad_M_DQS_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_DQS force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_DQS_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_DQS PUll down</comment>
     </bits>
     <bits name="pad_M_DQS_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_DQS PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_DQS_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_DQS force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_DQS_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_DQS force outoen value. </comment>
     </bits>
     <bits name="pad_M_DQS_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_DQS force output value for output. </comment>
     </bits>
     <bits name="pad_M_DQS_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_DQS pin output value. </comment>
     </bits>
     <bits name="pad_M_DQS_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQS select</comment>
     <options>
            <option name="fun_M_DQS_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_SPI_CLK_cfg" protect="rw">
     <bits name="pad_M_SPI_CLK_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_SPI_CLK shimit enable. </comment>
     </bits>
     <bits name="pad_M_SPI_CLK_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_SPI_CLK input enable. </comment>
     </bits>
     <bits name="pad_M_SPI_CLK_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_SPI_CLK driving strength. </comment>
     </bits>
     <bits name="pad_M_SPI_CLK_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_SPI_CLK force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_SPI_CLK_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_SPI_CLK PUll down</comment>
     </bits>
     <bits name="pad_M_SPI_CLK_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_SPI_CLK PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_SPI_CLK_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_SPI_CLK force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_SPI_CLK_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_SPI_CLK force outoen value. </comment>
     </bits>
     <bits name="pad_M_SPI_CLK_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_SPI_CLK force output value for output. </comment>
     </bits>
     <bits name="pad_M_SPI_CLK_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_SPI_CLK pin output value. </comment>
     </bits>
     <bits name="pad_M_SPI_CLK_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_CLK select</comment>
     <options>
            <option name="fun_M_SPI_CLK_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_SPI_CS_cfg" protect="rw">
     <bits name="pad_M_SPI_CS_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_SPI_CS shimit enable. </comment>
     </bits>
     <bits name="pad_M_SPI_CS_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_SPI_CS input enable. </comment>
     </bits>
     <bits name="pad_M_SPI_CS_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_SPI_CS driving strength. </comment>
     </bits>
     <bits name="pad_M_SPI_CS_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_SPI_CS force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_SPI_CS_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_SPI_CS PUll down</comment>
     </bits>
     <bits name="pad_M_SPI_CS_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_SPI_CS PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_SPI_CS_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_SPI_CS force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_SPI_CS_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_SPI_CS force outoen value. </comment>
     </bits>
     <bits name="pad_M_SPI_CS_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_SPI_CS force output value for output. </comment>
     </bits>
     <bits name="pad_M_SPI_CS_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_SPI_CS pin output value. </comment>
     </bits>
     <bits name="pad_M_SPI_CS_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_CS select</comment>
     <options>
            <option name="fun_M_SPI_CS_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_SPI_D_0_cfg" protect="rw">
     <bits name="pad_M_SPI_D_0_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_SPI_D_0 shimit enable. </comment>
     </bits>
     <bits name="pad_M_SPI_D_0_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_SPI_D_0 input enable. </comment>
     </bits>
     <bits name="pad_M_SPI_D_0_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_SPI_D_0 driving strength. </comment>
     </bits>
     <bits name="pad_M_SPI_D_0_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_SPI_D_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_SPI_D_0_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_SPI_D_0 PUll down</comment>
     </bits>
     <bits name="pad_M_SPI_D_0_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_SPI_D_0 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_SPI_D_0_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_SPI_D_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_SPI_D_0_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_SPI_D_0 force outoen value. </comment>
     </bits>
     <bits name="pad_M_SPI_D_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_SPI_D_0 force output value for output. </comment>
     </bits>
     <bits name="pad_M_SPI_D_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_SPI_D_0 pin output value. </comment>
     </bits>
     <bits name="pad_M_SPI_D_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_D_0 select</comment>
     <options>
            <option name="fun_M_SPI_D_0_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_SPI_D_1_cfg" protect="rw">
     <bits name="pad_M_SPI_D_1_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_SPI_D_1 shimit enable. </comment>
     </bits>
     <bits name="pad_M_SPI_D_1_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_SPI_D_1 input enable. </comment>
     </bits>
     <bits name="pad_M_SPI_D_1_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_SPI_D_1 driving strength. </comment>
     </bits>
     <bits name="pad_M_SPI_D_1_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_SPI_D_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_SPI_D_1_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_SPI_D_1 PUll down</comment>
     </bits>
     <bits name="pad_M_SPI_D_1_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_SPI_D_1 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_SPI_D_1_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_SPI_D_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_SPI_D_1_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_SPI_D_1 force outoen value. </comment>
     </bits>
     <bits name="pad_M_SPI_D_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_SPI_D_1 force output value for output. </comment>
     </bits>
     <bits name="pad_M_SPI_D_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_SPI_D_1 pin output value. </comment>
     </bits>
     <bits name="pad_M_SPI_D_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_D_1 select</comment>
     <options>
            <option name="fun_M_SPI_D_1_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_SPI_D_2_cfg" protect="rw">
     <bits name="pad_M_SPI_D_2_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_SPI_D_2 shimit enable. </comment>
     </bits>
     <bits name="pad_M_SPI_D_2_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_SPI_D_2 input enable. </comment>
     </bits>
     <bits name="pad_M_SPI_D_2_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_SPI_D_2 driving strength. </comment>
     </bits>
     <bits name="pad_M_SPI_D_2_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_SPI_D_2 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_SPI_D_2_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_SPI_D_2 PUll down</comment>
     </bits>
     <bits name="pad_M_SPI_D_2_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_SPI_D_2 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_SPI_D_2_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_SPI_D_2 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_SPI_D_2_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_SPI_D_2 force outoen value. </comment>
     </bits>
     <bits name="pad_M_SPI_D_2_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_SPI_D_2 force output value for output. </comment>
     </bits>
     <bits name="pad_M_SPI_D_2_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_SPI_D_2 pin output value. </comment>
     </bits>
     <bits name="pad_M_SPI_D_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_D_2 select</comment>
     <options>
            <option name="fun_M_SPI_D_2_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_M_SPI_D_3_cfg" protect="rw">
     <bits name="pad_M_SPI_D_3_se" pos="18" access="rw" rst="0x1"> 
         <comment>M_SPI_D_3 shimit enable. </comment>
     </bits>
     <bits name="pad_M_SPI_D_3_ie" pos="17" access="rw" rst="0x1"> 
         <comment>M_SPI_D_3 input enable. </comment>
     </bits>
     <bits name="pad_M_SPI_D_3_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>M_SPI_D_3 driving strength. </comment>
     </bits>
     <bits name="pad_M_SPI_D_3_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>M_SPI_D_3 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_M_SPI_D_3_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>M_SPI_D_3 PUll down</comment>
     </bits>
     <bits name="pad_M_SPI_D_3_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>M_SPI_D_3 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_M_SPI_D_3_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>M_SPI_D_3 force enable for outoen. </comment>
     </bits>
     <bits name="pad_M_SPI_D_3_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>M_SPI_D_3 force outoen value. </comment>
     </bits>
     <bits name="pad_M_SPI_D_3_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>M_SPI_D_3 force output value for output. </comment>
     </bits>
     <bits name="pad_M_SPI_D_3_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>M_SPI_D_3 pin output value. </comment>
     </bits>
     <bits name="pad_M_SPI_D_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_D_3 select</comment>
     <options>
            <option name="fun_M_SPI_D_3_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_8_cfg" protect="rw">
     <bits name="pad_GPIO_8_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_8 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_8_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_8 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_8_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_8 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_8_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_8 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_8_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_8 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_8_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_8 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_8_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_8 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_8_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_8 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_8_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_8 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_8_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_8 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_8_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_8 select</comment>
     <options>
            <option name="fun_GPIO_8_sel" value ="0"></option>
            <option name="fun_UART3_RXD_sel" value ="1"></option>
            <option name="fun_SEGOUT_0_sel" value ="7"></option>
            <option name="fun_DBG_DO_0_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_9_cfg" protect="rw">
     <bits name="pad_GPIO_9_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_9 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_9_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_9 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_9_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_9 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_9_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_9 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_9_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_9 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_9_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_9 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_9_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_9 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_9_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_9 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_9_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_9 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_9_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_9 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_9_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_9 select</comment>
     <options>
            <option name="fun_GPIO_9_sel" value ="0"></option>
            <option name="fun_UART3_TXD_sel" value ="1"></option>
            <option name="fun_SEGOUT_1_sel" value ="7"></option>
            <option name="fun_DBG_DO_1_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_10_cfg" protect="rw">
     <bits name="pad_GPIO_10_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_10 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_10_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_10 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_10_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_10 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_10_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_10 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_10_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_10 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_10_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_10 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_10_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_10 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_10_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_10 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_10_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_10 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_10_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_10 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_10_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_10 select</comment>
     <options>
            <option name="fun_GPIO_10_sel" value ="0"></option>
            <option name="fun_UART3_CTS_sel" value ="1"></option>
            <option name="fun_TCO_0_sel" value ="2"></option>
            <option name="fun_GPT2_PWM_0_sel" value ="3"></option>
            <option name="fun_GPT2_TI_0_sel" value ="4"></option>
            <option name="fun_CLKO_0_sel" value ="5"></option>
            <option name="fun_UART1_CTS_sel" value ="6"></option>
            <option name="fun_SEGOUT_2_sel" value ="7"></option>
            <option name="fun_UART1_TXD_sel" value ="8"></option>
            <option name="fun_DBG_DO_2_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_11_cfg" protect="rw">
     <bits name="pad_GPIO_11_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_11 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_11_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_11 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_11_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_11 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_11_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_11 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_11_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_11 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_11_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_11 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_11_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_11 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_11_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_11 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_11_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_11 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_11_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_11 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_11_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_11 select</comment>
     <options>
            <option name="fun_GPIO_11_sel" value ="0"></option>
            <option name="fun_UART3_RTS_sel" value ="1"></option>
            <option name="fun_TCO_1_sel" value ="2"></option>
            <option name="fun_GPT2_PWM_1_sel" value ="3"></option>
            <option name="fun_GPT2_TI_1_sel" value ="4"></option>
            <option name="fun_CLKO_1_sel" value ="5"></option>
            <option name="fun_UART1_RTS_sel" value ="6"></option>
            <option name="fun_SEGOUT_3_sel" value ="7"></option>
            <option name="fun_UART2_TXD_sel" value ="8"></option>
            <option name="fun_GPADC_IN0_sel" value ="9"></option>
            <option name="fun_DBG_DO_3_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_12_cfg" protect="rw">
     <bits name="pad_GPIO_12_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_12 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_12_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_12 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_12_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_12 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_12_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_12 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_12_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_12 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_12_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_12 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_12_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_12 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_12_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_12 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_12_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_12 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_12_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_12 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_12_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_12 select</comment>
     <options>
            <option name="fun_GPIO_12_sel" value ="0"></option>
            <option name="fun_UART4_RXD_sel" value ="1"></option>
            <option name="fun_KEYIN_0_sel" value ="3"></option>
            <option name="fun_GPT2_TI_2_sel" value ="4"></option>
            <option name="fun_UART1_TXD_sel" value ="6"></option>
            <option name="fun_SEGOUT_4_sel" value ="7"></option>
            <option name="fun_UART1_CTS_sel" value ="8"></option>
            <option name="fun_DBG_DO_4_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_13_cfg" protect="rw">
     <bits name="pad_GPIO_13_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_13 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_13_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_13 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_13_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_13 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_13_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_13 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_13_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_13 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_13_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_13 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_13_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_13 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_13_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_13 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_13_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_13 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_13_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_13 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_13_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_13 select</comment>
     <options>
            <option name="fun_GPIO_13_sel" value ="0"></option>
            <option name="fun_UART4_TXD_sel" value ="1"></option>
            <option name="fun_KEYIN_1_sel" value ="3"></option>
            <option name="fun_GPT2_TI_3_sel" value ="4"></option>
            <option name="fun_UART2_TXD_sel" value ="6"></option>
            <option name="fun_SEGOUT_5_sel" value ="7"></option>
            <option name="fun_UART1_RTS_sel" value ="8"></option>
            <option name="fun_DBG_DO_5_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_14_cfg" protect="rw">
     <bits name="pad_GPIO_14_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_14 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_14_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_14 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_14_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_14 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_14_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_14 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_14_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_14 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_14_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_14 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_14_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_14 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_14_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_14 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_14_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_14 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_14_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_14 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_14_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_14 select</comment>
     <options>
            <option name="fun_GPIO_14_sel" value ="0"></option>
            <option name="fun_UART4_CTS_sel" value ="1"></option>
            <option name="fun_I2C2_SCL_sel" value ="2"></option>
            <option name="fun_KEYOUT_0_sel" value ="3"></option>
            <option name="fun_GPT2_PWM_0_sel" value ="4"></option>
            <option name="fun_GPT2_TI_0_sel" value ="5"></option>
            <option name="fun_SDMMC2_CLK_sel" value ="6"></option>
            <option name="fun_SEGOUT_6_sel" value ="7"></option>
            <option name="fun_UART2_CTS_sel" value ="8"></option>
            <option name="fun_DBG_DO_6_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_15_cfg" protect="rw">
     <bits name="pad_GPIO_15_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_15 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_15_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_15 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_15_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_15 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_15_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_15 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_15_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_15 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_15_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_15 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_15_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_15 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_15_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_15 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_15_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_15 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_15_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_15 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_15_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_15 select</comment>
     <options>
            <option name="fun_GPIO_15_sel" value ="0"></option>
            <option name="fun_UART4_RTS_sel" value ="1"></option>
            <option name="fun_I2C2_SDA_sel" value ="2"></option>
            <option name="fun_KEYOUT_1_sel" value ="3"></option>
            <option name="fun_GPT2_PWM_1_sel" value ="4"></option>
            <option name="fun_GPT2_TI_1_sel" value ="5"></option>
            <option name="fun_SDMMC2_CMD_sel" value ="6"></option>
            <option name="fun_SEGOUT_7_sel" value ="7"></option>
            <option name="fun_UART2_RTS_sel" value ="8"></option>
            <option name="fun_GPADC_IN1_sel" value ="9"></option>
            <option name="fun_DBG_DO_7_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_16_cfg" protect="rw">
     <bits name="pad_GPIO_16_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_16 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_16_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_16 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_16_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_16 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_16_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_16 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_16_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_16 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_16_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_16 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_16_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_16 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_16_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_16 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_16_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_16 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_16_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_16 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_16_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_16 select</comment>
     <options>
            <option name="fun_GPIO_16_sel" value ="0"></option>
            <option name="fun_UART5_RXD_sel" value ="1"></option>
            <option name="fun_CLKO_2_sel" value ="2"></option>
            <option name="fun_SPI1_CLK_sel" value ="3"></option>
            <option name="fun_GPT2_PWM_2_sel" value ="4"></option>
            <option name="fun_I2S_BCLK_sel" value ="5"></option>
            <option name="fun_SDMMC2_DAT_3_sel" value ="6"></option>
            <option name="fun_SEGOUT_8_sel" value ="7"></option>
            <option name="fun_DBG_DO_8_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_17_cfg" protect="rw">
     <bits name="pad_GPIO_17_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_17 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_17_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_17 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_17_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_17 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_17_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_17 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_17_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_17 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_17_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_17 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_17_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_17 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_17_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_17 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_17_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_17 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_17_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_17 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_17_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_17 select</comment>
     <options>
            <option name="fun_GPIO_17_sel" value ="0"></option>
            <option name="fun_UART5_TXD_sel" value ="1"></option>
            <option name="fun_CLKO_3_sel" value ="2"></option>
            <option name="fun_SPI1_CS_sel" value ="3"></option>
            <option name="fun_GPT2_PWM_3_sel" value ="4"></option>
            <option name="fun_I2S_LRCK_sel" value ="5"></option>
            <option name="fun_SDMMC2_DAT_2_sel" value ="6"></option>
            <option name="fun_SEGOUT_9_sel" value ="7"></option>
            <option name="fun_DBG_DO_9_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_18_cfg" protect="rw">
     <bits name="pad_GPIO_18_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_18 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_18_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_18 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_18_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_18 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_18_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_18 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_18_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_18 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_18_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_18 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_18_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_18 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_18_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_18 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_18_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_18 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_18_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_18 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_18_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_18 select</comment>
     <options>
            <option name="fun_GPIO_18_sel" value ="0"></option>
            <option name="fun_UART5_CTS_sel" value ="1"></option>
            <option name="fun_I2C2_SCL_sel" value ="2"></option>
            <option name="fun_SPI1_DI_0_sel" value ="3"></option>
            <option name="fun_GPT2_PWM_0_sel" value ="4"></option>
            <option name="fun_I2S_DI_sel" value ="5"></option>
            <option name="fun_SDMMC2_DAT_1_sel" value ="6"></option>
            <option name="fun_SEGOUT_10_sel" value ="7"></option>
            <option name="fun_DBG_DO_10_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_19_cfg" protect="rw">
     <bits name="pad_GPIO_19_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_19 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_19_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_19 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_19_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_19 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_19_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_19 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_19_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_19 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_19_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_19 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_19_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_19 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_19_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_19 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_19_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_19 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_19_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_19 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_19_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_19 select</comment>
     <options>
            <option name="fun_GPIO_19_sel" value ="0"></option>
            <option name="fun_UART5_RTS_sel" value ="1"></option>
            <option name="fun_I2C2_SDA_sel" value ="2"></option>
            <option name="fun_SPI1_DI_1_sel" value ="3"></option>
            <option name="fun_GPT2_PWM_1_sel" value ="4"></option>
            <option name="fun_I2S_DO_sel" value ="5"></option>
            <option name="fun_SDMMC2_DAT_0_sel" value ="6"></option>
            <option name="fun_SEGOUT_11_sel" value ="7"></option>
            <option name="fun_SWV_sel" value ="8"></option>
            <option name="fun_GPADC_IN2_sel" value ="9"></option>
            <option name="fun_DBG_DO_11_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_20_cfg" protect="rw">
     <bits name="pad_GPIO_20_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_20 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_20_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_20 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_20_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_20 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_20_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_20 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_20_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_20 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_20_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_20 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_20_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_20 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_20_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_20 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_20_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_20 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_20_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_20 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_20_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_20 select</comment>
     <options>
            <option name="fun_GPIO_20_sel" value ="0"></option>
            <option name="fun_SPI1_CLK_sel" value ="1"></option>
            <option name="fun_M2_SPI_CLK_sel" value ="2"></option>
            <option name="fun_KEYIN_0_sel" value ="3"></option>
            <option name="fun_CLKO_0_sel" value ="4"></option>
            <option name="fun_SDMMC2_DAT_3_sel" value ="6"></option>
            <option name="fun_SEGOUT_12_sel" value ="7"></option>
            <option name="fun_DBG_DO_12_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_21_cfg" protect="rw">
     <bits name="pad_GPIO_21_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_21 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_21_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_21 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_21_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_21 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_21_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_21 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_21_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_21 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_21_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_21 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_21_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_21 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_21_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_21 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_21_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_21 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_21_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_21 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_21_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_21 select</comment>
     <options>
            <option name="fun_GPIO_21_sel" value ="0"></option>
            <option name="fun_SPI1_CS_sel" value ="1"></option>
            <option name="fun_M2_SPI_CS_sel" value ="2"></option>
            <option name="fun_KEYIN_1_sel" value ="3"></option>
            <option name="fun_CLKO_1_sel" value ="4"></option>
            <option name="fun_SDMMC2_DAT_2_sel" value ="6"></option>
            <option name="fun_SEGOUT_13_sel" value ="7"></option>
            <option name="fun_DBG_DO_13_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_22_cfg" protect="rw">
     <bits name="pad_GPIO_22_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_22 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_22_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_22 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_22_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_22 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_22_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_22 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_22_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_22 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_22_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_22 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_22_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_22 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_22_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_22 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_22_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_22 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_22_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_22 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_22_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_22 select</comment>
     <options>
            <option name="fun_GPIO_22_sel" value ="0"></option>
            <option name="fun_SPI1_DI_0_sel" value ="1"></option>
            <option name="fun_M2_SPI_D_0_sel" value ="2"></option>
            <option name="fun_KEYOUT_0_sel" value ="3"></option>
            <option name="fun_CLKO_2_sel" value ="4"></option>
            <option name="fun_SDMMC2_DAT_1_sel" value ="6"></option>
            <option name="fun_SEGOUT_14_sel" value ="7"></option>
            <option name="fun_DBG_DO_14_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_23_cfg" protect="rw">
     <bits name="pad_GPIO_23_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_23 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_23_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_23 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_23_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_23 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_23_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_23 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_23_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_23 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_23_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_23 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_23_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_23 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_23_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_23 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_23_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_23 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_23_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_23 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_23_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_23 select</comment>
     <options>
            <option name="fun_GPIO_23_sel" value ="0"></option>
            <option name="fun_SPI1_DI_1_sel" value ="1"></option>
            <option name="fun_M2_SPI_D_1_sel" value ="2"></option>
            <option name="fun_KEYOUT_1_sel" value ="3"></option>
            <option name="fun_CLKO_3_sel" value ="4"></option>
            <option name="fun_TCO_0_sel" value ="5"></option>
            <option name="fun_SDMMC2_DAT_0_sel" value ="6"></option>
            <option name="fun_SEGOUT_15_sel" value ="7"></option>
            <option name="fun_SWV_sel" value ="8"></option>
            <option name="fun_GPADC_IN3_sel" value ="9"></option>
            <option name="fun_DBG_DO_15_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_24_cfg" protect="rw">
     <bits name="pad_GPIO_24_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_24 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_24_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_24 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_24_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_24 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_24_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_24 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_24_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_24 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_24_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_24 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_24_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_24 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_24_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_24 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_24_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_24 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_24_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_24 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_24_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_24 select</comment>
     <options>
            <option name="fun_GPIO_24_sel" value ="0"></option>
            <option name="fun_I2C1_SCL_sel" value ="1"></option>
            <option name="fun_M2_SPI_D_2_sel" value ="2"></option>
            <option name="fun_GPT2_PWM_0_sel" value ="3"></option>
            <option name="fun_GPT2_TI_2_sel" value ="4"></option>
            <option name="fun_TCO_1_sel" value ="5"></option>
            <option name="fun_SDMMC2_CLK_sel" value ="6"></option>
            <option name="fun_SEGOUT_16_sel" value ="7"></option>
            <option name="fun_DBG_TRIG_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_25_cfg" protect="rw">
     <bits name="pad_GPIO_25_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_25 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_25_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_25 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_25_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_25 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_25_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_25 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_25_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_25 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_25_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_25 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_25_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_25 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_25_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_25 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_25_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_25 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_25_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_25 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_25_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_25 select</comment>
     <options>
            <option name="fun_GPIO_25_sel" value ="0"></option>
            <option name="fun_I2C1_SDA_sel" value ="1"></option>
            <option name="fun_M2_SPI_D_3_sel" value ="2"></option>
            <option name="fun_GPT2_PWM_1_sel" value ="3"></option>
            <option name="fun_GPT2_TI_3_sel" value ="4"></option>
            <option name="fun_TCO_0_sel" value ="5"></option>
            <option name="fun_SDMMC2_CMD_sel" value ="6"></option>
            <option name="fun_SEGOUT_17_sel" value ="7"></option>
            <option name="fun_DBG_CLK_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_26_cfg" protect="rw">
     <bits name="pad_GPIO_26_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_26 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_26_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_26 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_26_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_26 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_26_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_26 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_26_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_26 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_26_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_26 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_26_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_26 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_26_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_26 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_26_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_26 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_26_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_26 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_26_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_26 select</comment>
     <options>
            <option name="fun_GPIO_26_sel" value ="0"></option>
            <option name="fun_SDMMC2_CLK_sel" value ="1"></option>
            <option name="fun_UART3_CTS_sel" value ="2"></option>
            <option name="fun_CLKO_2_sel" value ="3"></option>
            <option name="fun_GPT2_PWM_2_sel" value ="4"></option>
            <option name="fun_TCO_0_sel" value ="5"></option>
            <option name="fun_M2_SPI_CLK_sel" value ="6"></option>
            <option name="fun_UART4_CTS_sel" value ="7"></option>
            <option name="fun_adi_scl_m_sel" value ="8"></option>
            <option name="fun_SWV_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_27_cfg" protect="rw">
     <bits name="pad_GPIO_27_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_27 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_27_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_27 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_27_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_27 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_27_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_27 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_27_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_27 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_27_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_27 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_27_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_27 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_27_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_27 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_27_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_27 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_27_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_27 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_27_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_27 select</comment>
     <options>
            <option name="fun_GPIO_27_sel" value ="0"></option>
            <option name="fun_SDMMC2_CMD_sel" value ="1"></option>
            <option name="fun_UART3_RTS_sel" value ="2"></option>
            <option name="fun_CLKO_3_sel" value ="3"></option>
            <option name="fun_GPT2_PWM_3_sel" value ="4"></option>
            <option name="fun_TCO_1_sel" value ="5"></option>
            <option name="fun_M2_SPI_CS_sel" value ="6"></option>
            <option name="fun_UART4_RTS_sel" value ="7"></option>
            <option name="fun_adi_sdio_m_sel" value ="8"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_28_cfg" protect="rw">
     <bits name="pad_GPIO_28_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_28 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_28_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_28 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_28_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_28 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_28_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_28 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_28_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_28 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_28_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_28 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_28_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_28 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_28_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_28 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_28_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_28 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_28_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_28 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_28_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_28 select</comment>
     <options>
            <option name="fun_GPIO_28_sel" value ="0"></option>
            <option name="fun_SDMMC2_DAT_0_sel" value ="1"></option>
            <option name="fun_SPI1_CLK_sel" value ="2"></option>
            <option name="fun_KEYIN_2_sel" value ="3"></option>
            <option name="fun_CLKO_0_sel" value ="4"></option>
            <option name="fun_I2S_BCLK_sel" value ="5"></option>
            <option name="fun_M2_SPI_D_0_sel" value ="6"></option>
            <option name="fun_UART4_RXD_sel" value ="7"></option>
            <option name="fun_rf_spi_clk_m_sel" value ="8"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_29_cfg" protect="rw">
     <bits name="pad_GPIO_29_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_29 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_29_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_29 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_29_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_29 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_29_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_29 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_29_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_29 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_29_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_29 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_29_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_29 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_29_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_29 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_29_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_29 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_29_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_29 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_29_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_29 select</comment>
     <options>
            <option name="fun_GPIO_29_sel" value ="0"></option>
            <option name="fun_SDMMC2_DAT_1_sel" value ="1"></option>
            <option name="fun_SPI1_CS_sel" value ="2"></option>
            <option name="fun_KEYIN_3_sel" value ="3"></option>
            <option name="fun_CLKO_1_sel" value ="4"></option>
            <option name="fun_I2S_LRCK_sel" value ="5"></option>
            <option name="fun_M2_SPI_D_1_sel" value ="6"></option>
            <option name="fun_UART4_TXD_sel" value ="7"></option>
            <option name="fun_rf_spi_cs_m_sel" value ="8"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_30_cfg" protect="rw">
     <bits name="pad_GPIO_30_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_30 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_30_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_30 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_30_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_30 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_30_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_30 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_30_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_30 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_30_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_30 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_30_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_30 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_30_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_30 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_30_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_30 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_30_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_30 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_30_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_30 select</comment>
     <options>
            <option name="fun_GPIO_30_sel" value ="0"></option>
            <option name="fun_SDMMC2_DAT_2_sel" value ="1"></option>
            <option name="fun_SPI1_DI_0_sel" value ="2"></option>
            <option name="fun_KEYOUT_2_sel" value ="3"></option>
            <option name="fun_CLKO_2_sel" value ="4"></option>
            <option name="fun_I2S_DI_sel" value ="5"></option>
            <option name="fun_M2_SPI_D_2_sel" value ="6"></option>
            <option name="fun_UART3_CTS_sel" value ="7"></option>
            <option name="fun_rf_spi_dio_m_sel" value ="8"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_31_cfg" protect="rw">
     <bits name="pad_GPIO_31_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_31 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_31_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_31 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_31_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_31 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_31_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_31 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_31_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_31 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_31_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_31 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_31_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_31 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_31_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_31 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_31_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_31 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_31_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_31 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_31_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_31 select</comment>
     <options>
            <option name="fun_GPIO_31_sel" value ="0"></option>
            <option name="fun_SDMMC2_DAT_3_sel" value ="1"></option>
            <option name="fun_SPI1_DI_1_sel" value ="2"></option>
            <option name="fun_KEYOUT_3_sel" value ="3"></option>
            <option name="fun_CLKO_3_sel" value ="4"></option>
            <option name="fun_I2S_DO_sel" value ="5"></option>
            <option name="fun_M2_SPI_D_3_sel" value ="6"></option>
            <option name="fun_UART3_RTS_sel" value ="7"></option>
            <option name="fun_dfe_rx_en_m_sel" value ="8"></option>
            <option name="fun_SWV_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_32_cfg" protect="rw">
     <bits name="pad_GPIO_32_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_32 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_32_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_32 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_32_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_32 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_32_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_32 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_32_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_32 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_32_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_32 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_32_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_32 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_32_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_32 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_32_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_32 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_32_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_32 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_32_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_32 select</comment>
     <options>
            <option name="fun_GPIO_32_sel" value ="0"></option>
            <option name="fun_HST_RXD_sel" value ="1"></option>
            <option name="fun_SPI1_CLK_sel" value ="2"></option>
            <option name="fun_UART5_RXD_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_33_cfg" protect="rw">
     <bits name="pad_GPIO_33_se" pos="18" access="rw" rst="0x1"> 
         <comment>GPIO_33 shimit enable. </comment>
     </bits>
     <bits name="pad_GPIO_33_ie" pos="17" access="rw" rst="0x1"> 
         <comment>GPIO_33 input enable. </comment>
     </bits>
     <bits name="pad_GPIO_33_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>GPIO_33 driving strength. </comment>
     </bits>
     <bits name="pad_GPIO_33_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>GPIO_33 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_33_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>GPIO_33 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_33_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>GPIO_33 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_GPIO_33_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>GPIO_33 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_33_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>GPIO_33 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_33_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_33 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_33_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_33 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_33_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_33 select</comment>
     <options>
            <option name="fun_GPIO_33_sel" value ="0"></option>
            <option name="fun_HST_TXD_sel" value ="1"></option>
            <option name="fun_SPI1_CS_sel" value ="2"></option>
            <option name="fun_UART5_TXD_sel" value ="3"></option>
            <option name="fun_SWV_sel" value ="10"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SWCLK_cfg" protect="rw">
     <bits name="pad_SWCLK_se" pos="18" access="rw" rst="0x1"> 
         <comment>SWCLK shimit enable. </comment>
     </bits>
     <bits name="pad_SWCLK_ie" pos="17" access="rw" rst="0x1"> 
         <comment>SWCLK input enable. </comment>
     </bits>
     <bits name="pad_SWCLK_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>SWCLK driving strength. </comment>
     </bits>
     <bits name="pad_SWCLK_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>SWCLK force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SWCLK_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>SWCLK PUll down</comment>
     </bits>
     <bits name="pad_SWCLK_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>SWCLK PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_SWCLK_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>SWCLK force enable for outoen. </comment>
     </bits>
     <bits name="pad_SWCLK_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>SWCLK force outoen value. </comment>
     </bits>
     <bits name="pad_SWCLK_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SWCLK force output value for output. </comment>
     </bits>
     <bits name="pad_SWCLK_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SWCLK pin output value. </comment>
     </bits>
     <bits name="pad_SWCLK_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SWCLK select</comment>
     <options>
            <option name="fun_SWCLK_sel" value ="0"></option>
            <option name="fun_GPIO_34_sel" value ="1"></option>
            <option name="fun_SPI1_DI_0_sel" value ="2"></option>
            <option name="fun_UART5_CTS_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SWDIO_cfg" protect="rw">
     <bits name="pad_SWDIO_se" pos="18" access="rw" rst="0x1"> 
         <comment>SWDIO shimit enable. </comment>
     </bits>
     <bits name="pad_SWDIO_ie" pos="17" access="rw" rst="0x1"> 
         <comment>SWDIO input enable. </comment>
     </bits>
     <bits name="pad_SWDIO_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>SWDIO driving strength. </comment>
     </bits>
     <bits name="pad_SWDIO_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>SWDIO force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SWDIO_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>SWDIO PUll down</comment>
     </bits>
     <bits name="pad_SWDIO_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>SWDIO PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_SWDIO_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>SWDIO force enable for outoen. </comment>
     </bits>
     <bits name="pad_SWDIO_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>SWDIO force outoen value. </comment>
     </bits>
     <bits name="pad_SWDIO_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SWDIO force output value for output. </comment>
     </bits>
     <bits name="pad_SWDIO_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SWDIO pin output value. </comment>
     </bits>
     <bits name="pad_SWDIO_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SWDIO select</comment>
     <options>
            <option name="fun_SWDIO_sel" value ="0"></option>
            <option name="fun_GPIO_35_sel" value ="1"></option>
            <option name="fun_SPI1_DI_1_sel" value ="2"></option>
            <option name="fun_UART5_RTS_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_CLK_0_cfg" protect="rw">
     <bits name="pad_SIM_CLK_0_se" pos="18" access="rw" rst="0x1"> 
         <comment>SIM_CLK_0 shimit enable. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_ie" pos="17" access="rw" rst="0x1"> 
         <comment>SIM_CLK_0 input enable. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>SIM_CLK_0 driving strength. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 PUll down</comment>
     </bits>
     <bits name="pad_SIM_CLK_0_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_SIM_CLK_0_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_CLK_0 select</comment>
     <options>
            <option name="fun_SIM_CLK_0_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_RST_0_cfg" protect="rw">
     <bits name="pad_SIM_RST_0_se" pos="18" access="rw" rst="0x1"> 
         <comment>SIM_RST_0 shimit enable. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_ie" pos="17" access="rw" rst="0x1"> 
         <comment>SIM_RST_0 input enable. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>SIM_RST_0 driving strength. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_RST_0_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 PUll down</comment>
     </bits>
     <bits name="pad_SIM_RST_0_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_SIM_RST_0_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_RST_0 select</comment>
     <options>
            <option name="fun_SIM_RST_0_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_DIO_0_cfg" protect="rw">
     <bits name="pad_SIM_DIO_0_se" pos="18" access="rw" rst="0x1"> 
         <comment>SIM_DIO_0 shimit enable. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_ie" pos="17" access="rw" rst="0x1"> 
         <comment>SIM_DIO_0 input enable. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>SIM_DIO_0 driving strength. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 PUll down</comment>
     </bits>
     <bits name="pad_SIM_DIO_0_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_SIM_DIO_0_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_DIO_0 select</comment>
     <options>
            <option name="fun_SIM_DIO_0_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_CLK_1_cfg" protect="rw">
     <bits name="pad_SIM_CLK_1_se" pos="18" access="rw" rst="0x1"> 
         <comment>SIM_CLK_1 shimit enable. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_ie" pos="17" access="rw" rst="0x1"> 
         <comment>SIM_CLK_1 input enable. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>SIM_CLK_1 driving strength. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 PUll down</comment>
     </bits>
     <bits name="pad_SIM_CLK_1_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_SIM_CLK_1_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_CLK_1 select</comment>
     <options>
            <option name="fun_SIM_CLK_1_sel" value ="0"></option>
            <option name="fun_GPIO_36_sel" value ="1"></option>
            <option name="fun_TCO_0_sel" value ="2"></option>
            <option name="fun_GPT2_PWM_3_sel" value ="4"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_RST_1_cfg" protect="rw">
     <bits name="pad_SIM_RST_1_se" pos="18" access="rw" rst="0x1"> 
         <comment>SIM_RST_1 shimit enable. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_ie" pos="17" access="rw" rst="0x1"> 
         <comment>SIM_RST_1 input enable. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>SIM_RST_1 driving strength. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_RST_1_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 PUll down</comment>
     </bits>
     <bits name="pad_SIM_RST_1_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_SIM_RST_1_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_RST_1 select</comment>
     <options>
            <option name="fun_SIM_RST_1_sel" value ="0"></option>
            <option name="fun_GPIO_37_sel" value ="1"></option>
            <option name="fun_TCO_1_sel" value ="2"></option>
            <option name="fun_GPT2_PWM_0_sel" value ="4"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_DIO_1_cfg" protect="rw">
     <bits name="pad_SIM_DIO_1_se" pos="18" access="rw" rst="0x1"> 
         <comment>SIM_DIO_1 shimit enable. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_ie" pos="17" access="rw" rst="0x1"> 
         <comment>SIM_DIO_1 input enable. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_drv_strength" pos="15:14" access="rw" rst="0x2"> 
         <comment>SIM_DIO_1 driving strength. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_pull_frc" pos="11" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_pull_dn" pos="10" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 PUll down</comment>
     </bits>
     <bits name="pad_SIM_DIO_1_pull_up" pos="9:8" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 PUll up</comment>
         <options>
            <option name="pull up off" value ="0"></option>
            <option name="pull up 4.7k" value ="1"></option>
            <option name="pull up 20k" value ="2"></option>
            <option name="pull up 1.8k" value ="3"></option>
         </options>
     </bits>
     <bits name="pad_SIM_DIO_1_oen_frc" pos="7" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_oen_reg" pos="6" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_DIO_1 select</comment>
     <options>
            <option name="fun_SIM_DIO_1_sel" value ="0"></option>
            <option name="fun_GPIO_38_sel" value ="1"></option>
            <option name="fun_GPT2_TI_0_sel" value ="4"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
   </module>
</archive>

<archive relative = "keypad.xml">
<module name="keypad" category="Periph">
  <var name="KEY_NB" value="64">
    <comment> Number of key in the keypad
    </comment>
  </var>
  <var name="LOW_KEY_NB" value="32">
    <comment> Number of key in the low data register 
    </comment>
  </var>
  <var name="HIGH_KEY_NB" value="32">
    <comment> Number of key in the high data register
    </comment>
  </var>

  <reg protect="r" name="KP_DATA_L">
    <bits access="r" name="KP_DATA_L" pos="31:0" rst="0">
      <comment>For keys in column Idx_KeyOut(from 0 to 3) and in line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_L(Idx_KeyOut*8+Idx_KeyIn) :<br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
    </bits>

  </reg>

  <reg protect="r" name="KP_DATA_H">
    <bits access="r" name="KP_DATA_H" pos="31:0" rst="0">
      <comment>For keys in column Idx_KeyOut(from 4 to 7) and line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_H(Idx_KeyIn*8-32+Idx_KeyIn):<br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
    </bits>

  </reg>

  <reg protect="r" name="KP_STATUS">

    <bits access="r" name="KEYIN_STATUS" pos="7:0" rst="0x08">
      <comment>For keys in lines status <br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
  </bits>

    <bits access="r" name="KP_ON" pos="31" rst="0">
      <comment>Indicate Key ON pressing status :<br />0 = Release<br />1 = Pressed
      </comment>
      <options><default/><mask/><shift/></options>
    </bits>

  </reg>

  
  <reg protect="rw" name="KP_CTRL">
    <bits access="rw" name="KP_En" pos="0" rst="0">
        <comment>This bit enables key detection. If this bit is '0', the key detection function 
            is disabled. Key ON is an exception, it can be still detected and generate key interrupt
            even if KP_En = '0', however in this case, the debouncing time configuration in key
            control register is ignored and the key ON state is considerred to be stable if it keeps
            same in consecutive 2 cycles of 16KHz clock.<br />
        <br />0 = keypad disable<br />1 = keypad enable  
      </comment>
    </bits>
   
    <bits access="rw" name="KP_DBN_Time" pos="9:2" rst="0">
      <comment>De-bounce time = (KP_DBN_TIME + 1) * SCAN_TIME, SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_DBN_TIME = 7, KP_OUT_MASK = "111111", then De-bounce time = (7+1)*0.3125*6=15 ms. The maximum debounce time is 480 ms.
      </comment>
    </bits>

   <bits access="rw" name="KP_ITV_Time" pos="15:10" rst="0">
      <comment>Configure interval of generating an IRQ if one key or several keys are pressed long time. Interval of IRQ generation = (KP_ITV_Time + 1) * (KP_DBN_TIME + 1) * SCAN_TIME. SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_ITV_TIME = 7, KP_DBN_TIME = 7, KP_OUT_MASK = "111111", then De-bounce time = (7+1)*(7+1)*0.3125*6=120 ms. 
      </comment>
    </bits>
    
    <bits access="rw" name="KP_IN_MASK" pos="23:16" rst="0xff">
        <comment>each bit masks one input lines.<br />
            '1' = enabled <br /> '0' = disabled
            
            <br/>The Key In pins 0 to 5 are muxed with the boot mode pins, latched during Reset.
                <br/> Key_In 0: BOOT_MODE_NO_AUTO_PU.
                <br/> Key_In 1: BOOT_MODE_FORCE_MONITOR.
                <br/> Key_In 2: BOOT_MODE_UART_MONITOR_ENABLE.
                <br/> Key_In 3: BOOT_MODE_USB_MONITOR_DISABLE.
                <br/> Key_In 4: reserved

        </comment>
    </bits>

    <bits access="rw" name="KP_OUT_MASK" pos="31:24" rst="0xff">
        <comment>each bit masks one output lines.<br />
            '1' = enabled <br /> '0' = disabled </comment>
    </bits>

  </reg>

  <reg protect="rw" name="KP_IRQ_MASK">
    <bits access="rw" name="KP_EVT0_IRQ_MASK" pos="0" rst="0">
      <comment>This bit mask keypad irq generated by event0 (key press or key release event, not including all keys release event which is event1). 
        <br />0 = keypad event irq disable<br />1 = keypad event irq enable  
      </comment>
    </bits>
    
    <bits access="rw" name="KP_EVT1_IRQ_MASK" pos="1" rst="0">
      <comment>This bit mask keypad irq generated by event1 (all keys release event). 
        <br />0 = keypad event irq disable<br />1 = keypad event irq enable  
      </comment>
    </bits>
    
    <bits access="rw" name="KP_ITV_IRQ_MASK" pos="2" rst="0">
      <comment>This bit mask keypad irq generated by key pressed long time (generated each interval configured in KP_ITV_Time. 
        <br />0 = keypad interval irq disable<br />1 = keypad interval irq enable  
      </comment>
    </bits>

  </reg>

  <reg protect="r" name="KP_IRQ_CAUSE">
    <bits access="r" name="KP_EVT0_IRQ_CAUSE" pos="0" rst="0">
      <comment>keypad event0(key press or key release event, not including all keys release which is event1) IRQ cause. 
      </comment>
    </bits>

    <bits access="r" name="KP_EVT1_IRQ_CAUSE" pos="1" rst="0">
      <comment>keypad event1(all keys release event) IRQ cause. 
      </comment>
    </bits>

    <bits access="r" name="KP_ITV_IRQ_CAUSE" pos="2" rst="0">
      <comment>keypad interval irq cause. 
      </comment>
    </bits>
    
    <bits access="r" name="KP_EVT0_IRQ_STATUS" pos="16" rst="0">
      <comment>keypad event0(key press or key release event, not including all keys release which is event1) irq status. 
      </comment>
    </bits>

    <bits access="r" name="KP_EVT1_IRQ_STATUS" pos="17" rst="0">
      <comment>keypad event1(all keys release event) irq status. 
      </comment>
    </bits>
  
    <bits access="r" name="KP_ITV_IRQ_STATUS" pos="18" rst="0">
      <comment>keypad interval irq status. 
      </comment>
    </bits>

  </reg>
  
  <reg protect="rw" name="KP_IRQ_CLR">
    <bits access="c" name="KP_IRQ_CLR" pos="0" rst="0">
      <comment>Write '1' to this bit clears key IRQ. </comment>
    </bits>
  </reg>

</module>
</archive>
<archive relative = "lps.xml">

<module name="lps" category="Modem">

    
    
	<var name="LP_FRAC_NB_BITS" value="16"/>
	<var name="LP_COUNT_INT_NB_BITS" value="19"/>
	<var name="LP_COUNT_NB_BITS" value="LP_COUNT_INT_NB_BITS + LP_FRAC_NB_BITS"/>
	<var name="LP_RATE_INT_NB_BITS" value="12"/>
	<var name="LP_RATE_NB_BITS" value="LP_RATE_INT_NB_BITS + LP_FRAC_NB_BITS"/>
	<var name="SYS_COUNT_NB_BITS" value="29"/>
	<var name="FRAME_COUNT_NB_BITS" value="32"/>
    
	<var name="PU_COUNT_NB_BITS" value="12"/>
    
    
    <reg name="LPS_SF_Ctrl" protect="rw">
        <bits name="LPS_SF_Enable" pos="0" access="rw" rst="0">
            <comment>Lps Skip Frame Enable.
                <br/>When enabled the frame interrupt are masked until the programmed number of frames are elapsed.
                <br/>This is done by masking the frame interrupt line from the regular TCU counter, and counting the frames. Also when activating the LowPower SkipFrame the frame counter is tranfered to the low power counter that will update it based on the 32kHz Clock.
            </comment>
        </bits>
        <bits name="LPS_SF_LowPower" pos="5:4" access="rw" rst="0">
            <comment>Controls the Lps Low Power Counters (counters at 32kHz) usage.
            </comment>
            <options>
                <option name="Stop" value="0"><comment>Disable the Low Power Counters.</comment></option>
                <option name="SkipFrame" value="1"><comment>The Low Power Counters are started in Skip Frame Mode. In this mode the Low Power Counter are used to maintain the Time base, The Skip Frame Must be enabled as this is the Low Power extention of the Skip Frame feature.</comment></option>
                <option name="Calib" value="3"><comment>Start the calibration. The Low Power Counters are used to Calibrate the 32kHz clock against the System Clock, The Calibration is required to compensate from temperature variation. Note that the Skip Frame can also be enabled during calibration (but not with low power).</comment></option>
                <mask/>
                <shift/>
                <default/>
            </options>
        </bits>
        <bits name="LPS_SF_Wakeup0" pos="8" access="rw" rst="0">
            <comment>Enable fake Fint used with wakeupNumber=0. </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="LPS_SF_Wakeup0_cfg" pos="9" access="rw" rst="0">
            <comment>Enable fake Fint when sys_sf_frame_count>=cfg_sf_frame. 
                <br/>Default sys_sf_frame_count>cfg_sf_frame.
            </comment>
            <options>
                <option name="0" value="0"/>
                <option name="1" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="LPS_SF_Status" protect="rw">
        <bits name="LPS_SF_Ready" pos="0" access="r" rst="1">
            <comment>Lps Skip Frame Ready, status of the state machines to keep valid state between system clock and 32Khz clock.
                <br/>Must read as '1' before entering Low Power Skip Frame or Calibration mode.
            </comment>
        </bits>
        <bits name="LPS_SF_SlowRunning" pos="4" access="r" rst="0">
            <comment>'1' when Lps Skip Frame Low Power Counters are Running.
                <br/>When entering Low Power Skip Frame, the counters are not immediately started, they wait for the nextFrame interrupt. Reading this status allow to know if the counters are running, and the System Clock can be safely disabled.
            </comment>
        </bits>
        <bits name="LPS_SF_CalibrationDone" pos="8" access="r" rst="0">
            <comment>'1' when the Lps Skip Frame Calibration is Done.
            </comment>
        </bits>
        <bits name="LPS_SF_PU_Reached" pos="12" access="r" rst="0">
            <comment>'1' when the Lps Skip Frame Power-up sequence frame is reached.
            </comment>
        </bits>
        <bits name="LPS_SF_TCU_Restart" pos="16" access="r" rst="0">
            <comment>'1' when tcu counter is restarted.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Frames" protect="rw">
        <bits name="LPS_SF_Frame" pos="FRAME_COUNT_NB_BITS-1:0" access="rw" rst="0">
            <comment>Number of frames to Skip.
                <br/>If the power up sequence is enabled, frames are skipped until both this number is reached and the powerup sequence has finished.
                <br/>Note: The power up sequence must be <b>Done</b> before the the frame LPS_SF_Frame ends.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_PU_Frames" protect="rw">
        <bits name="LPS_SF_PU_Frame" pos="FRAME_COUNT_NB_BITS-1:0" access="rw" rst="0">
            <comment>Number of frames before activating the Power-up sequence.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Restart_Time" protect="rw">
        <bits name="LPS_SF_Restart_Time" pos="LP_COUNT_INT_NB_BITS-1:0" access="rw" rst="0">
            <comment>For LowPower SkipFrame mode: Value to restart TCU (and frame interrupt generation) on the system clock counter after a low power phase.
                <br/>For Calibration mode: number of 32k cycles for the calibration.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Frame_Period" protect="rw">
        <bits name="LPS_SF_Frame_Period" pos="LP_COUNT_INT_NB_BITS-1:0" access="rw" rst="0">
            <comment>Value of the frame period in system clock count.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Rate" protect="rw">
        <comment>The rate is the number of System Clocks per 32kHz Clocks.
        </comment>
        <bits name="LPS_SF_Rate_Int" pos="LP_RATE_NB_BITS-1:LP_FRAC_NB_BITS" access="rw" rst="0">
            <comment>Integer part of the rate.
            </comment>
        </bits>
        <bits name="LPS_SF_Rate_Frac" pos="LP_FRAC_NB_BITS-1:0" access="rw" rst="0">
            <comment>Fractional part of the rate.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Elapsed_Frames" protect="rw">
        <bits name="LPS_SF_Elapsed_Frames" pos="FRAME_COUNT_NB_BITS-1:0" access="r" rst="0">
            <comment>Current number of elapsed frames.
                <br/>Valid when Skip Frame is Enabled.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Sys_Count" protect="rw">
        <bits name="LPS_SF_Sys_Count" pos="SYS_COUNT_NB_BITS-1:0" access="r" rst="0">
            <comment>Value of the system clock counter at the end of calibration (when CalibrationDone is '1' in LPS_SF_Status register).
                <br/>The hardware behind it is reused during other operation, reading that register at any other time will return an undefined value.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_IRQ" protect="rw">
        <bits name="LPS_IRQ_Calibration_Done_Cause" pos="0" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the calibration is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Cause" pos="1" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Slow Counter started.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Cause" pos="2" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Power-Up frame was reached.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_TCU_Restart_Cause" pos="3" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the tcu counter was restarted.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_IRQ_Cause">
            <entry ref="LPS_IRQ_Calibration_Done_Cause"/>
            <entry ref="LPS_IRQ_Slow_Running_Cause"/>
            <entry ref="LPS_IRQ_PU_Reached_Cause"/>
            <entry ref="LPS_IRQ_TCU_Restart_Cause"/>
        </bitgroup>

        <bits name="LPS_IRQ_Calibration_Done_Status" pos="16" access="rc" rst="0">
            <comment>1 when the calibration is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Status" pos="17" access="rc" rst="0">
            <comment>1 when the Slow Counter started.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Status" pos="18" access="rc" rst="0">
            <comment>1 when the Power-Up frame was reached.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_TCU_Restart_Status" pos="19" access="rc" rst="0">
            <comment>1 when the tcu counter was restarted.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_IRQ_Status">
            <entry ref="LPS_IRQ_Calibration_Done_Status"/>
            <entry ref="LPS_IRQ_Slow_Running_Status"/>
            <entry ref="LPS_IRQ_PU_Reached_Status"/>
            <entry ref="LPS_IRQ_TCU_Restart_Status"/>
        </bitgroup>
    </reg>
    <reg name="LPS_IRQ_Mask" protect="rw">
        <bits name="LPS_IRQ_Calibration_Done_Mask" pos="0" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_Calibration_Done is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Mask" pos="1" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_Slow_Running is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Mask" pos="2" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_PU_Reached is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_TCU_Restart_Mask" pos="3" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_TCU_Restart is enabled.
            </comment>
        </bits>
        <bitgroup name="LPS_IRQ_Mask">
            <entry ref="LPS_IRQ_Calibration_Done_Mask"/>
            <entry ref="LPS_IRQ_Slow_Running_Mask"/>
            <entry ref="LPS_IRQ_PU_Reached_Mask"/>
            <entry ref="LPS_IRQ_TCU_Restart_Mask"/>
        </bitgroup>
    </reg>

</module>

</archive>
<archive relative="master_ctrl_top_rf.xml">
  <module name="master_ctrl_top_rf" category="firewall">
    <reg protect="rw" name="rd_sec_0">
      <bits access="r" name="rd_sec_0_reserved_0" pos="31:4" rst="0">
      </bits>
      <bits access="rw" name="cipher_f8_rd_sec" pos="3" rst="0">
      </bits>
      <bits access="rw" name="bb_nbiot_top_rd_sec" pos="2" rst="0">
      </bits>
      <bits access="rw" name="bb_rf_if_rd_sec" pos="1" rst="0">
      </bits>
      <bits access="rw" name="sys_dma_rd_sec" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="wr_sec_0">
      <bits access="r" name="wr_sec_0_reserved_0" pos="31:4" rst="0">
      </bits>
      <bits access="rw" name="cipher_f8_wr_sec" pos="3" rst="0">
      </bits>
      <bits access="rw" name="bb_nbiot_top_wr_sec" pos="2" rst="0">
      </bits>
      <bits access="rw" name="bb_rf_if_wr_sec" pos="1" rst="0">
      </bits>
      <bits access="rw" name="sys_dma_wr_sec" pos="0" rst="0">
      </bits>
    </reg>
  </module>
</archive>
<archive relative="med.xml">
  <module name="med" category="System">
    <reg protect="rw" name="med_ch0_work_cfg">
      <bits access="r" name="med_ch0_work_cfg_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="med_ch0_bypass_en" pos="4" rst="0">
        <comment>
          1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption
        </comment>
      </bits>
      <bits access="r" name="med_ch0_work_cfg_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="med_ch0_enable" pos="0" rst="0">
        <comment>
          1:enable ch0;     0:disable ch0;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="med_ch0_base_addr_cfg">
      <bits access="rw" name="med_ch0_base_addr" pos="31:5" rst="0">
        <comment>
          the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000
        </comment>
      </bits>
      <bits access="r" name="med_ch0_base_addr_cfg_reserved_0" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="med_ch0_addr_size_cfg">
      <bits access="r" name="med_ch0_addr_size_cfg_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="med_ch0_addr_size" pos="23:5" rst="0">
        <comment>
          the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF
        </comment>
      </bits>
      <bits access="r" name="med_ch0_addr_size_cfg_reserved_1" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="med_ch0_read_addr_remap">
      <bits access="rw" name="med_ch0_remap_read_addr" pos="31:5" rst="0">
        <comment>
          the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024
        </comment>
      </bits>
      <bits access="r" name="med_ch0_read_addr_remap_reserved_0" pos="4:0" rst="0">
      </bits>
    </reg>
    <hole size="128"/>
    <reg protect="rw" name="med_ch1_work_cfg">
      <bits access="r" name="med_ch1_work_cfg_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="med_ch1_bypass_en" pos="4" rst="0">
        <comment>
          1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption
        </comment>
      </bits>
      <bits access="r" name="med_ch1_work_cfg_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="med_ch1_enable" pos="0" rst="0">
        <comment>
          1:enable ch1;    0:disable ch1;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="med_ch1_base_addr_cfg">
      <bits access="rw" name="med_ch1_base_addr" pos="31:5" rst="0">
        <comment>
          the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000
        </comment>
      </bits>
      <bits access="r" name="med_ch1_base_addr_cfg_reserved_0" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="med_ch1_addr_size_cfg">
      <bits access="r" name="med_ch1_addr_size_cfg_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="med_ch1_addr_size" pos="23:5" rst="0">
        <comment>
          the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF
        </comment>
      </bits>
      <bits access="r" name="med_ch1_addr_size_cfg_reserved_1" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="med_ch1_read_addr_remap">
      <bits access="rw" name="med_ch1_remap_read_addr" pos="31:5" rst="0">
        <comment>
          the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024
        </comment>
      </bits>
      <bits access="r" name="med_ch1_read_addr_remap_reserved_0" pos="4:0" rst="0">
      </bits>
    </reg>
    <hole size="128"/>
    <reg protect="rw" name="med_ch2_work_cfg">
      <bits access="r" name="med_ch2_work_cfg_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="med_ch2_bypass_en" pos="4" rst="0">
        <comment>
          1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption
        </comment>
      </bits>
      <bits access="r" name="med_ch2_work_cfg_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="med_ch2_enable" pos="0" rst="0">
        <comment>
          1:enable ch2;    0:disable ch2;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="med_ch2_base_addr_cfg">
      <bits access="rw" name="med_ch2_base_addr" pos="31:5" rst="0">
        <comment>
          the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000
        </comment>
      </bits>
      <bits access="r" name="med_ch2_base_addr_cfg_reserved_0" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="med_ch2_addr_size_cfg">
      <bits access="r" name="med_ch2_addr_size_cfg_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="med_ch2_addr_size" pos="23:5" rst="0">
        <comment>
          the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF
        </comment>
      </bits>
      <bits access="r" name="med_ch2_addr_size_cfg_reserved_1" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="med_ch2_read_addr_remap">
      <bits access="rw" name="med_ch2_remap_read_addr" pos="31:5" rst="0">
        <comment>
          the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024
        </comment>
      </bits>
      <bits access="r" name="med_ch2_read_addr_remap_reserved_0" pos="4:0" rst="0">
      </bits>
    </reg>
    <hole size="128"/>
    <reg protect="rw" name="med_ch3_work_cfg">
      <bits access="r" name="med_ch3_work_cfg_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="med_ch3_bypass_en" pos="4" rst="0">
        <comment>
          1:bypass enable,don't encryption &amp; decryption 0:bypass disable,do encryption &amp; decryption
        </comment>
      </bits>
      <bits access="r" name="med_ch3_work_cfg_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="med_ch3_enable" pos="0" rst="0">
        <comment>
          1:enable ch3;    0:disable ch3;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="med_ch3_base_addr_cfg">
      <bits access="rw" name="med_ch3_base_addr" pos="31:5" rst="0">
        <comment>
          the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000
        </comment>
      </bits>
      <bits access="r" name="med_ch3_base_addr_cfg_reserved_0" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="med_ch3_addr_size_cfg">
      <bits access="r" name="med_ch3_addr_size_cfg_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="med_ch3_addr_size" pos="23:5" rst="0">
        <comment>
          the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF
        </comment>
      </bits>
      <bits access="r" name="med_ch3_addr_size_cfg_reserved_1" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="med_ch3_read_addr_remap">
      <bits access="rw" name="med_ch3_remap_read_addr" pos="31:5" rst="0">
        <comment>
          the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu read address is 0x1000_0024,then after med , then address is  is 0x2000_0024
        </comment>
      </bits>
      <bits access="r" name="med_ch3_read_addr_remap_reserved_0" pos="4:0" rst="0">
      </bits>
    </reg>
    <hole size="1024"/>
    <reg protect="rw" name="med_write_addr_remap">
      <bits access="rw" name="med_remap_write_addr" pos="31:5" rst="0">
        <comment>
          the address only config the  32byte align addr, the low 5bit addr come from the med accept martix addr; for example, the reg config is 0x100_000,cpu write address is 0x1000_0024,then after med , then address is  is 0x2000_0024
        </comment>
      </bits>
      <bits access="r" name="med_write_addr_remap_reserved_0" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="med_write_base_addr_cfg">
      <bits access="rw" name="med_write_base_addr" pos="31:5" rst="0">
        <comment>
          the base address must 32byte align, then the addr can delete the low 5bit; for example, base addr is 0x1000_0000, soft ware can config 0x80_0000
        </comment>
      </bits>
      <bits access="r" name="med_write_base_addr_cfg_reserved_0" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="med_write_addr_size_cfg">
      <bits access="r" name="med_write_addr_size_cfg_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="med_write_addr_size" pos="23:5" rst="0">
        <comment>
          the size only support max 16MB, and must 32byte align, then the size value can delete the low 5bit; for example, size is 1MB,0xFFFFF, then soft ware can config is 0x7FFF
        </comment>
      </bits>
      <bits access="r" name="med_write_addr_size_cfg_reserved_1" pos="4:0" rst="0">
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="med_clr">
      <bits access="r" name="med_clr_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rc" name="med_write_cnt_clr" pos="5" rst="0">
        <comment>
        bit type is changed from wc to rc.

          1:active,clear the 0x118 address bit31~bit12; 
        </comment>
      </bits>
      <bits access="rc" name="med_simon_clr" pos="4" rst="0">
        <comment>
        bit type is changed from wc to rc.

          1:active,clear the simon core
        </comment>
      </bits>
      <bits access="r" name="med_clr_reserved_1" pos="3:2" rst="0">
      </bits>
      <bits access="rc" name="med_write_ram_clr" pos="1" rst="0">
        <comment>
        bit type is changed from wc to rc.

          1:active,clear the med inner write ram
        </comment>
      </bits>
      <bits access="rc" name="med_read_ram_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          1:active,clear the med inner read ram
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="med_work_mode">
      <bits access="r" name="med_work_mode_reserved_0" pos="31:17" rst="0">
      </bits>
      <bits access="rw" name="med_clk_force_on" pos="16" rst="0">
        <comment>
          can force the med clk gate always on, then the clk  freerun
        </comment>
      </bits>
      <bits access="r" name="med_work_mode_reserved_1" pos="15:11" rst="0">
      </bits>
      <bits access="rw" name="med_write_bus_error_en" pos="10" rst="0">
        <comment>
          when the med send cmd to write flash data, and the slave happen bus error, then the med will back the slave bus error to master.
        </comment>
      </bits>
      <bits access="rw" name="med_read_bus_error_en" pos="9" rst="0">
        <comment>
          when the med send cmd to read flash data, and the slave happen bus error, then the med will back the slave bus error to master.
        </comment>
      </bits>
      <bits access="rw" name="med_bus_error_en" pos="8" rst="0">
        <comment>
          enable the med module ahb bus error,when the master access to med, and the access address is error, the med will generate the buss error to master.
        </comment>
      </bits>
      <bits access="r" name="med_work_mode_reserved_2" pos="7:1" rst="0">
      </bits>
      <bits access="rw" name="med_key_iv_sel" pos="0" rst="0">
        <comment>
          1:sel the key from efuse,                               0: key from soft ware
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="med_int_en">
      <bits access="r" name="med_int_en_reserved_0" pos="31:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="med_addr_err_int_en" pos="6" rst="0">
        <comment>
          enable med ahb addr out of range all channel
        </comment>
      </bits>
      <bits access="rw" name="med_err_resp_int_en" pos="5" rst="0">
        <comment>
          enable med error response int
        </comment>
      </bits>
      <bits access="rw" name="med_ch3_dis_addr_vld_int_en" pos="4" rst="0">
        <comment>
          enable med channel3 addr error int
        </comment>
      </bits>
      <bits access="rw" name="med_ch2_dis_addr_vld_int_en" pos="3" rst="0">
        <comment>
          enable med channel2 addr error int
        </comment>
      </bits>
      <bits access="rw" name="med_ch1_dis_addr_vld_int_en" pos="2" rst="0">
        <comment>
          enable med channel1 addr error int
        </comment>
      </bits>
      <bits access="rw" name="med_ch0_dis_addr_vld_int_en" pos="1" rst="0">
        <comment>
          enable med channel0 addr error int
        </comment>
      </bits>
      <bits access="rw" name="med_wr_done_int_en" pos="0" rst="0">
        <comment>
          enable med write done int
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="med_int_raw">
      <bits access="r" name="med_int_raw_reserved_0" pos="31:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="med_addr_err_int_raw" pos="6" rst="0">
        <comment>
          med ahb addr out of range all channel status
        </comment>
      </bits>
      <bits access="r" name="med_err_resp_int_raw" pos="5" rst="0">
        <comment>
          med error response int status
        </comment>
      </bits>
      <bits access="r" name="med_ch3_dis_addr_vld_int_raw" pos="4" rst="0">
        <comment>
          med channel3 addr error int status
        </comment>
      </bits>
      <bits access="r" name="med_ch2_dis_addr_vld_int_raw" pos="3" rst="0">
        <comment>
          med channel2 addr error int status
        </comment>
      </bits>
      <bits access="r" name="med_ch1_dis_addr_vld_int_raw" pos="2" rst="0">
        <comment>
          med channel1 addr error int status
        </comment>
      </bits>
      <bits access="r" name="med_ch0_dis_addr_vld_int_raw" pos="1" rst="0">
        <comment>
          med channel0 addr error int status
        </comment>
      </bits>
      <bits access="r" name="med_wr_done_int_raw" pos="0" rst="0">
        <comment>
          med write done int status
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="med_int_clear">
      <bits access="r" name="med_int_clear_reserved_0" pos="31:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rc" name="med_addr_err_int_clr" pos="6" rst="0">
        <comment>
        bit type is changed from wc to rc.

          clear med ahb addr out of range all channel status
        </comment>
      </bits>
      <bits access="rc" name="med_err_resp_int_clr" pos="5" rst="0">
        <comment>
        bit type is changed from wc to rc.

          clear med error response int
        </comment>
      </bits>
      <bits access="rc" name="med_ch3_dis_addr_vld_int_clr" pos="4" rst="0">
        <comment>
        bit type is changed from wc to rc.

          clear med channel3 addr error int
        </comment>
      </bits>
      <bits access="rc" name="med_ch2_dis_addr_vld_int_clr" pos="3" rst="0">
        <comment>
        bit type is changed from wc to rc.

          clear med channel2 addr error int
        </comment>
      </bits>
      <bits access="rc" name="med_ch1_dis_addr_vld_int_clr" pos="2" rst="0">
        <comment>
        bit type is changed from wc to rc.

          clear med channel1 addr error int
        </comment>
      </bits>
      <bits access="rc" name="med_ch0_dis_addr_vld_int_clr" pos="1" rst="0">
        <comment>
        bit type is changed from wc to rc.

          clear med channel0 addr error int
        </comment>
      </bits>
      <bits access="rc" name="med_wr_done_int_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          clear med  write done int
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="med_error_addr">
      <bits access="r" name="med_error_addr_store" pos="31:0" rst="0">
        <comment>
          when master send error address, the addr store in this reg 
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="med_status0">
      <bits access="r" name="med_write_word_cnt" pos="31:12" rst="0">
      </bits>
      <bits access="r" name="med_status0_reserved_0" pos="11:6" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="med_wr_busy" pos="5" rst="0">
      </bits>
      <bits access="r" name="med_rd_busy" pos="4" rst="0">
      </bits>
      <bits access="r" name="med_work_busy" pos="3" rst="0">
      </bits>
      <bits access="r" name="med_mster_ahb_hready" pos="2" rst="1">
      </bits>
      <bits access="r" name="med_mster_slv_hready" pos="1" rst="1">
      </bits>
      <bits access="r" name="med_simon_odata_ready" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="r" name="med_status1">
      <bits access="r" name="med_cipher_debug" pos="31:0" rst="4">
      </bits>
    </reg>
    <reg protect="r" name="med_status2">
      <bits access="r" name="med_ctrl_debug2" pos="31:0" rst="2625">
      </bits>
    </reg>
    <reg protect="r" name="med_status3">
      <bits access="r" name="med_ctrl_debug3" pos="31:0" rst="48">
      </bits>
    </reg>
    <reg protect="rw" name="med_soft_key">
      <bits access="rw" name="med_soft_cfg_key" pos="31:0" rst="0">
        <comment>
          software only config 32bit key, hardware copy four time,{med_soft_cfg_key,med_soft_cfg_key,med_soft_cfg_key,med_soft_cfg_key}=128bit,then send to simon
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="mem_fw_bb_nbiot_top_rf.xml">
  <module name="mem_fw_bb_nbiot_top_rf" category="firewall">
    <reg protect="rw" name="port0_default_r_addr_0">
      <bits access="r" name="port0_default_r_addr_0_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="port0_default_r_addr_0" pos="5:0" rst="63">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port0_default_w_addr_0">
      <bits access="r" name="port0_default_w_addr_0_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="port0_default_w_addr_0" pos="5:0" rst="63">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <hole size="1984"/>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
      <bits access="r" name="clk_gate_bypass_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <hole size="2016"/>
    <reg protect="rw" name="port_int_w_en">
      <bits access="r" name="port_int_w_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_w_clr">
      <bits access="r" name="port_int_w_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_raw">
      <bits access="r" name="port_int_w_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_fin">
      <bits access="r" name="port_int_w_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_en">
      <bits access="r" name="port_int_r_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_clr">
      <bits access="r" name="port_int_r_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_raw">
      <bits access="r" name="port_int_r_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_fin">
      <bits access="r" name="port_int_r_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="0" rst="0">
      </bits>
    </reg>
    <hole size="3840"/>
    <reg protect="r" name="port_0_w_debug_addr">
      <bits access="r" name="port_0_w_debug_addr_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="r" name="w_addr_0" pos="5:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_0_w_debug_id">
      <bits access="r" name="port_0_w_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_id_0" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_addr">
      <bits access="r" name="port_0_r_debug_addr_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="r" name="r_addr_0" pos="5:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_id">
      <bits access="r" name="port_0_r_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_id_0" pos="7:0" rst="0">
      </bits>
    </reg>
    <hole size="8064"/>
    <reg protect="rw" name="seg_default_first_addr">
      <bits access="r" name="seg_default_first_addr_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="5:0" rst="63">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_last_addr">
      <bits access="r" name="seg_default_last_addr_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="5:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <hole size="15808"/>
    <reg protect="rw" name="seg_0_first_addr">
      <bits access="r" name="seg_0_first_addr_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="5:0" rst="63">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_last_addr">
      <bits access="r" name="seg_0_last_addr_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="5:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_1_first_addr">
      <bits access="r" name="seg_1_first_addr_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="5:0" rst="63">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_last_addr">
      <bits access="r" name="seg_1_last_addr_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="5:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="mem_fw_flash1_rf.xml">
  <module name="mem_fw_flash1_rf" category="firewall">
    <reg protect="rw" name="port0_default_r_addr_0">
      <bits access="r" name="port0_default_r_addr_0_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="port0_default_r_addr_0" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port0_default_w_addr_0">
      <bits access="r" name="port0_default_w_addr_0_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="port0_default_w_addr_0" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <hole size="1984"/>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
      <bits access="r" name="clk_gate_bypass_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <hole size="2016"/>
    <reg protect="rw" name="port_int_w_en">
      <bits access="r" name="port_int_w_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_w_clr">
      <bits access="r" name="port_int_w_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_raw">
      <bits access="r" name="port_int_w_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_fin">
      <bits access="r" name="port_int_w_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_en">
      <bits access="r" name="port_int_r_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_clr">
      <bits access="r" name="port_int_r_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_raw">
      <bits access="r" name="port_int_r_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_fin">
      <bits access="r" name="port_int_r_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="0" rst="0">
      </bits>
    </reg>
    <hole size="3840"/>
    <reg protect="r" name="port_0_w_debug_addr">
      <bits access="r" name="port_0_w_debug_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="r" name="w_addr_0" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_0_w_debug_id">
      <bits access="r" name="port_0_w_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_id_0" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_addr">
      <bits access="r" name="port_0_r_debug_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="r" name="r_addr_0" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_id">
      <bits access="r" name="port_0_r_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_id_0" pos="7:0" rst="0">
      </bits>
    </reg>
    <hole size="8064"/>
    <reg protect="rw" name="seg_default_first_addr">
      <bits access="r" name="seg_default_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_last_addr">
      <bits access="r" name="seg_default_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <hole size="15808"/>
    <reg protect="rw" name="seg_0_first_addr">
      <bits access="r" name="seg_0_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_last_addr">
      <bits access="r" name="seg_0_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_1_first_addr">
      <bits access="r" name="seg_1_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_last_addr">
      <bits access="r" name="seg_1_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_2_first_addr">
      <bits access="r" name="seg_2_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_last_addr">
      <bits access="r" name="seg_2_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_3_first_addr">
      <bits access="r" name="seg_3_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_last_addr">
      <bits access="r" name="seg_3_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="mem_fw_flash2_rf.xml">
  <module name="mem_fw_flash2_rf" category="firewall">
    <reg protect="rw" name="port0_default_r_addr_0">
      <bits access="r" name="port0_default_r_addr_0_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="port0_default_r_addr_0" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

          default r address 0 register(4K-Byte address, bit 24 ~ bit 12).
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port0_default_w_addr_0">
      <bits access="r" name="port0_default_w_addr_0_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="port0_default_w_addr_0" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

          default w address 0 register(4K-Byte address, bit 24 ~ bit 12).
        </comment>
      </bits>
    </reg>
    <hole size="1984"/>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

          0: don&apos;t response error; 1: response error
        </comment>
      </bits>
      <bits access="r" name="clk_gate_bypass_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          clock gate bypass
        </comment>
      </bits>
    </reg>
    <hole size="2016"/>
    <reg protect="rw" name="port_int_w_en">
      <bits access="r" name="port_int_w_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 write address miss int enable&#10;1: Enable&#10;0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_w_clr">
      <bits access="r" name="port_int_w_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 write address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_raw">
      <bits access="r" name="port_int_w_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
        <comment>
          Port 0 write address miss original int&#10;1: Address Miss&#10;0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_fin">
      <bits access="r" name="port_int_w_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
        <comment>
          Port 0 write address miss final int&#10;1: Address Miss&#10;0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_en">
      <bits access="r" name="port_int_r_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 read address miss int enable&#10;1: Enable&#10;0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_clr">
      <bits access="r" name="port_int_r_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 read address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_raw">
      <bits access="r" name="port_int_r_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="0" rst="0">
        <comment>
          Port 0 read address miss original int&#10;1: Address Miss&#10;0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_fin">
      <bits access="r" name="port_int_r_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="0" rst="0">
        <comment>
          Port 0 read address miss final int&#10;1: Address Miss&#10;0: Normal
        </comment>
      </bits>
    </reg>
    <hole size="3840"/>
    <reg protect="r" name="port_0_w_debug_addr">
      <bits access="r" name="port_0_w_debug_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="r" name="w_addr_0" pos="14:0" rst="0">
        <comment>
          Port 0 write channel address, 4K-Byte
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_w_debug_id">
      <bits access="r" name="port_0_w_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_id_0" pos="7:0" rst="0">
        <comment>
          Port 0 write channel id, MSB is prot[1]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_addr">
      <bits access="r" name="port_0_r_debug_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="r" name="r_addr_0" pos="14:0" rst="0">
        <comment>
          Port 0 read channel address, 4K-Byte
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_id">
      <bits access="r" name="port_0_r_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_id_0" pos="7:0" rst="0">
        <comment>
          Port 0 read channel id, MSB is prot[1]
        </comment>
      </bits>
    </reg>
    <hole size="8064"/>
    <reg protect="rw" name="seg_default_first_addr">
      <bits access="r" name="seg_default_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

          Segment default first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_last_addr">
      <bits access="r" name="seg_default_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment default last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 0~31.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 32~63.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 64~95.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 96~127.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 128~159.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 160~191.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 192~223.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 224~255.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 0~31.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 32~63.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 64~95.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 96~127.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 128~159.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 160~191.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 192~223.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 224~255.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <hole size="15808"/>
    <reg protect="rw" name="seg_0_first_addr">
      <bits access="r" name="seg_0_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_last_addr">
      <bits access="r" name="seg_0_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 0~31.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 32~63.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 64~95.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 96~127.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 128~159.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 160~191.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 192~223.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 224~255.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 0~31.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 32~63.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 64~95.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 96~127.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 128~159.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 160~191.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 192~223.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 224~255.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_1_first_addr">
      <bits access="r" name="seg_1_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_last_addr">
      <bits access="r" name="seg_1_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 0~31.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 32~63.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 64~95.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 96~127.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 128~159.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 160~191.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 192~223.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 224~255.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 0~31.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 32~63.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 64~95.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 96~127.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 128~159.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 160~191.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 192~223.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 224~255.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_2_first_addr">
      <bits access="r" name="seg_2_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_last_addr">
      <bits access="r" name="seg_2_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 0~31.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 32~63.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 64~95.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 96~127.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 128~159.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 160~191.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 192~223.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 224~255.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 0~31.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 32~63.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 64~95.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 96~127.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 128~159.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 160~191.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 192~223.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 224~255.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_3_first_addr">
      <bits access="r" name="seg_3_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_last_addr">
      <bits access="r" name="seg_3_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Read Master ID select, one bit indicates a master ID, master ID from 0~31.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Read Master ID select, one bit indicates a master ID, master ID from 32~63.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Read Master ID select, one bit indicates a master ID, master ID from 64~95.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Read Master ID select, one bit indicates a master ID, master ID from 96~127.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Read Master ID select, one bit indicates a master ID, master ID from 128~159.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Read Master ID select, one bit indicates a master ID, master ID from 160~191.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Read Master ID select, one bit indicates a master ID, master ID from 192~223.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Read Master ID select, one bit indicates a master ID, master ID from 224~255.&#10;1: Master can read&#10;0: Master can&apos;t read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Write Master ID select, one bit indicates a master ID, master ID from 0~31.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Write Master ID select, one bit indicates a master ID, master ID from 32~63.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Write Master ID select, one bit indicates a master ID, master ID from 64~95.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Write Master ID select, one bit indicates a master ID, master ID from 96~127.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Write Master ID select, one bit indicates a master ID, master ID from 128~159.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Write Master ID select, one bit indicates a master ID, master ID from 160~191.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Write Master ID select, one bit indicates a master ID, master ID from 192~223.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 3 Write Master ID select, one bit indicates a master ID, master ID from 224~255.&#10;1: Master can write&#10;0: Master can&apos;t write
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="mem_fw_psram_rf.xml">
  <module name="mem_fw_psram_rf" category="firewall">
    <reg protect="rw" name="port0_default_r_addr_0">
      <bits access="r" name="port0_default_r_addr_0_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="port0_default_r_addr_0" pos="14:0" rst="32767">
      </bits>
    </reg>
    <reg protect="rw" name="port0_default_w_addr_0">
      <bits access="r" name="port0_default_w_addr_0_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="port0_default_w_addr_0" pos="14:0" rst="32767">
      </bits>
    </reg>
    <hole size="1984"/>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
      </bits>
      <bits access="r" name="clk_gate_bypass_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
      </bits>
    </reg>
    <hole size="2016"/>
    <reg protect="rw" name="port_int_w_en">
      <bits access="r" name="port_int_w_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="port_int_w_clr">
      <bits access="r" name="port_int_w_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_raw">
      <bits access="r" name="port_int_w_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_fin">
      <bits access="r" name="port_int_w_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_en">
      <bits access="r" name="port_int_r_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_clr">
      <bits access="r" name="port_int_r_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_raw">
      <bits access="r" name="port_int_r_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_fin">
      <bits access="r" name="port_int_r_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="0" rst="0">
      </bits>
    </reg>
    <hole size="3840"/>
    <reg protect="r" name="port_0_w_debug_addr">
      <bits access="r" name="port_0_w_debug_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="r" name="w_addr_0" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_0_w_debug_id">
      <bits access="r" name="port_0_w_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_id_0" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_addr">
      <bits access="r" name="port_0_r_debug_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="r" name="r_addr_0" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_id">
      <bits access="r" name="port_0_r_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_id_0" pos="7:0" rst="0">
      </bits>
    </reg>
    <hole size="8064"/>
    <reg protect="rw" name="seg_default_first_addr">
      <bits access="r" name="seg_default_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_last_addr">
      <bits access="r" name="seg_default_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id0">
      <bits access="rw" name="mr_r_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id1">
      <bits access="rw" name="mr_r_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id2">
      <bits access="rw" name="mr_r_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id3">
      <bits access="rw" name="mr_r_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id4">
      <bits access="rw" name="mr_r_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id5">
      <bits access="rw" name="mr_r_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id6">
      <bits access="rw" name="mr_r_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id7">
      <bits access="rw" name="mr_r_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id0">
      <bits access="rw" name="mr_w_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id1">
      <bits access="rw" name="mr_w_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id2">
      <bits access="rw" name="mr_w_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id3">
      <bits access="rw" name="mr_w_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id4">
      <bits access="rw" name="mr_w_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id5">
      <bits access="rw" name="mr_w_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id6">
      <bits access="rw" name="mr_w_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id7">
      <bits access="rw" name="mr_w_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <hole size="15808"/>
    <reg protect="rw" name="seg_0_first_addr">
      <bits access="r" name="seg_0_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_last_addr">
      <bits access="r" name="seg_0_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id0">
      <bits access="rw" name="mr_r_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id1">
      <bits access="rw" name="mr_r_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id2">
      <bits access="rw" name="mr_r_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id3">
      <bits access="rw" name="mr_r_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id4">
      <bits access="rw" name="mr_r_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id5">
      <bits access="rw" name="mr_r_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id6">
      <bits access="rw" name="mr_r_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id7">
      <bits access="rw" name="mr_r_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id0">
      <bits access="rw" name="mr_w_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id1">
      <bits access="rw" name="mr_w_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id2">
      <bits access="rw" name="mr_w_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id3">
      <bits access="rw" name="mr_w_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id4">
      <bits access="rw" name="mr_w_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id5">
      <bits access="rw" name="mr_w_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id6">
      <bits access="rw" name="mr_w_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id7">
      <bits access="rw" name="mr_w_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_1_first_addr">
      <bits access="r" name="seg_1_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_last_addr">
      <bits access="r" name="seg_1_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id0">
      <bits access="rw" name="mr_r_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id1">
      <bits access="rw" name="mr_r_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id2">
      <bits access="rw" name="mr_r_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id3">
      <bits access="rw" name="mr_r_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id4">
      <bits access="rw" name="mr_r_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id5">
      <bits access="rw" name="mr_r_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id6">
      <bits access="rw" name="mr_r_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id7">
      <bits access="rw" name="mr_r_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id0">
      <bits access="rw" name="mr_w_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id1">
      <bits access="rw" name="mr_w_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id2">
      <bits access="rw" name="mr_w_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id3">
      <bits access="rw" name="mr_w_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id4">
      <bits access="rw" name="mr_w_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id5">
      <bits access="rw" name="mr_w_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id6">
      <bits access="rw" name="mr_w_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id7">
      <bits access="rw" name="mr_w_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_2_first_addr">
      <bits access="r" name="seg_2_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_last_addr">
      <bits access="r" name="seg_2_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id0">
      <bits access="rw" name="mr_r_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id1">
      <bits access="rw" name="mr_r_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id2">
      <bits access="rw" name="mr_r_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id3">
      <bits access="rw" name="mr_r_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id4">
      <bits access="rw" name="mr_r_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id5">
      <bits access="rw" name="mr_r_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id6">
      <bits access="rw" name="mr_r_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id7">
      <bits access="rw" name="mr_r_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id0">
      <bits access="rw" name="mr_w_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id1">
      <bits access="rw" name="mr_w_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id2">
      <bits access="rw" name="mr_w_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id3">
      <bits access="rw" name="mr_w_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id4">
      <bits access="rw" name="mr_w_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id5">
      <bits access="rw" name="mr_w_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id6">
      <bits access="rw" name="mr_w_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id7">
      <bits access="rw" name="mr_w_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_3_first_addr">
      <bits access="r" name="seg_3_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_last_addr">
      <bits access="r" name="seg_3_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id0">
      <bits access="rw" name="mr_r_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id1">
      <bits access="rw" name="mr_r_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id2">
      <bits access="rw" name="mr_r_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id3">
      <bits access="rw" name="mr_r_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id4">
      <bits access="rw" name="mr_r_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id5">
      <bits access="rw" name="mr_r_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id6">
      <bits access="rw" name="mr_r_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_r_id7">
      <bits access="rw" name="mr_r_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id0">
      <bits access="rw" name="mr_w_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id1">
      <bits access="rw" name="mr_w_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id2">
      <bits access="rw" name="mr_w_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id3">
      <bits access="rw" name="mr_w_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id4">
      <bits access="rw" name="mr_w_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id5">
      <bits access="rw" name="mr_w_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id6">
      <bits access="rw" name="mr_w_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_3_mst_w_id7">
      <bits access="rw" name="mr_w_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_4_first_addr">
      <bits access="r" name="seg_4_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_last_addr">
      <bits access="r" name="seg_4_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_r_id0">
      <bits access="rw" name="mr_r_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_r_id1">
      <bits access="rw" name="mr_r_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_r_id2">
      <bits access="rw" name="mr_r_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_r_id3">
      <bits access="rw" name="mr_r_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_r_id4">
      <bits access="rw" name="mr_r_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_r_id5">
      <bits access="rw" name="mr_r_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_r_id6">
      <bits access="rw" name="mr_r_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_r_id7">
      <bits access="rw" name="mr_r_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_w_id0">
      <bits access="rw" name="mr_w_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_w_id1">
      <bits access="rw" name="mr_w_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_w_id2">
      <bits access="rw" name="mr_w_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_w_id3">
      <bits access="rw" name="mr_w_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_w_id4">
      <bits access="rw" name="mr_w_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_w_id5">
      <bits access="rw" name="mr_w_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_w_id6">
      <bits access="rw" name="mr_w_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_4_mst_w_id7">
      <bits access="rw" name="mr_w_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_5_first_addr">
      <bits access="r" name="seg_5_first_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="14:0" rst="32767">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_last_addr">
      <bits access="r" name="seg_5_last_addr_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_r_id0">
      <bits access="rw" name="mr_r_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_r_id1">
      <bits access="rw" name="mr_r_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_r_id2">
      <bits access="rw" name="mr_r_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_r_id3">
      <bits access="rw" name="mr_r_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_r_id4">
      <bits access="rw" name="mr_r_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_r_id5">
      <bits access="rw" name="mr_r_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_r_id6">
      <bits access="rw" name="mr_r_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_r_id7">
      <bits access="rw" name="mr_r_id7" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_w_id0">
      <bits access="rw" name="mr_w_id0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_w_id1">
      <bits access="rw" name="mr_w_id1" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_w_id2">
      <bits access="rw" name="mr_w_id2" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_w_id3">
      <bits access="rw" name="mr_w_id3" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_w_id4">
      <bits access="rw" name="mr_w_id4" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_w_id5">
      <bits access="rw" name="mr_w_id5" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_w_id6">
      <bits access="rw" name="mr_w_id6" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="seg_5_mst_w_id7">
      <bits access="rw" name="mr_w_id7" pos="31:0" rst="0">
      </bits>
    </reg>
  </module>
</archive>
<archive relative="mem_fw_sys_ram0_rf.xml">
  <module name="mem_fw_sys_ram0_rf" category="firewall">
    <reg protect="rw" name="port0_default_r_addr_0">
      <bits access="r" name="port0_default_r_addr_0_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="port0_default_r_addr_0" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          default r address 0 register(4K-Byte address, bit 17 ~ bit 12).
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port0_default_w_addr_0">
      <bits access="r" name="port0_default_w_addr_0_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="port0_default_w_addr_0" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          default w address 0 register(4K-Byte address, bit 17 ~ bit 12).
        </comment>
      </bits>
    </reg>
    <hole size="1984"/>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

          0: don't response error; 1: response error
        </comment>
      </bits>
      <bits access="r" name="clk_gate_bypass_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          clock gate bypass
        </comment>
      </bits>
    </reg>
    <hole size="2016"/>
    <reg protect="rw" name="port_int_w_en">
      <bits access="r" name="port_int_w_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 write address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_w_clr">
      <bits access="r" name="port_int_w_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 write address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_raw">
      <bits access="r" name="port_int_w_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
        <comment>
          Port 0 write address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_fin">
      <bits access="r" name="port_int_w_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
        <comment>
          Port 0 write address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_en">
      <bits access="r" name="port_int_r_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 read address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_clr">
      <bits access="r" name="port_int_r_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 read address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_raw">
      <bits access="r" name="port_int_r_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="0" rst="0">
        <comment>
          Port 0 read address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_fin">
      <bits access="r" name="port_int_r_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="0" rst="0">
        <comment>
          Port 0 read address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <hole size="3840"/>
    <reg protect="r" name="port_0_w_debug_addr">
      <bits access="r" name="port_0_w_debug_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_addr_0" pos="7:0" rst="0">
        <comment>
          Port 0 write channel address, 4K-Byte
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_w_debug_id">
      <bits access="r" name="port_0_w_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_id_0" pos="7:0" rst="0">
        <comment>
          Port 0 write channel id, MSB is prot[1]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_addr">
      <bits access="r" name="port_0_r_debug_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_addr_0" pos="7:0" rst="0">
        <comment>
          Port 0 read channel address, 4K-Byte
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_id">
      <bits access="r" name="port_0_r_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_id_0" pos="7:0" rst="0">
        <comment>
          Port 0 read channel id, MSB is prot[1]
        </comment>
      </bits>
    </reg>
    <hole size="8064"/>
    <reg protect="rw" name="seg_default_first_addr">
      <bits access="r" name="seg_default_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment default first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_last_addr">
      <bits access="r" name="seg_default_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment default last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="15808"/>
    <reg protect="rw" name="seg_0_first_addr">
      <bits access="r" name="seg_0_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_last_addr">
      <bits access="r" name="seg_0_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_1_first_addr">
      <bits access="r" name="seg_1_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_last_addr">
      <bits access="r" name="seg_1_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_2_first_addr">
      <bits access="r" name="seg_2_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_last_addr">
      <bits access="r" name="seg_2_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="mem_fw_sys_ram1_rf.xml">
  <module name="mem_fw_sys_ram1_rf" category="firewall">
    <reg protect="rw" name="port0_default_r_addr_0">
      <bits access="r" name="port0_default_r_addr_0_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="port0_default_r_addr_0" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          default r address 0 register(4K-Byte address, bit 17 ~ bit 12).
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port0_default_w_addr_0">
      <bits access="r" name="port0_default_w_addr_0_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="port0_default_w_addr_0" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          default w address 0 register(4K-Byte address, bit 17 ~ bit 12).
        </comment>
      </bits>
    </reg>
    <hole size="1984"/>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

          0: don't response error; 1: response error
        </comment>
      </bits>
      <bits access="r" name="clk_gate_bypass_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          clock gate bypass
        </comment>
      </bits>
    </reg>
    <hole size="2016"/>
    <reg protect="rw" name="port_int_w_en">
      <bits access="r" name="port_int_w_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 write address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_w_clr">
      <bits access="r" name="port_int_w_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 write address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_raw">
      <bits access="r" name="port_int_w_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
        <comment>
          Port 0 write address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_fin">
      <bits access="r" name="port_int_w_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
        <comment>
          Port 0 write address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_en">
      <bits access="r" name="port_int_r_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 read address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_clr">
      <bits access="r" name="port_int_r_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 read address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_raw">
      <bits access="r" name="port_int_r_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="0" rst="0">
        <comment>
          Port 0 read address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_fin">
      <bits access="r" name="port_int_r_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="0" rst="0">
        <comment>
          Port 0 read address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <hole size="3840"/>
    <reg protect="r" name="port_0_w_debug_addr">
      <bits access="r" name="port_0_w_debug_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_addr_0" pos="7:0" rst="0">
        <comment>
          Port 0 write channel address, 4K-Byte
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_w_debug_id">
      <bits access="r" name="port_0_w_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_id_0" pos="7:0" rst="0">
        <comment>
          Port 0 write channel id, MSB is prot[1]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_addr">
      <bits access="r" name="port_0_r_debug_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_addr_0" pos="7:0" rst="0">
        <comment>
          Port 0 read channel address, 4K-Byte
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_id">
      <bits access="r" name="port_0_r_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_id_0" pos="7:0" rst="0">
        <comment>
          Port 0 read channel id, MSB is prot[1]
        </comment>
      </bits>
    </reg>
    <hole size="8064"/>
    <reg protect="rw" name="seg_default_first_addr">
      <bits access="r" name="seg_default_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment default first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_last_addr">
      <bits access="r" name="seg_default_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment default last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="15808"/>
    <reg protect="rw" name="seg_0_first_addr">
      <bits access="r" name="seg_0_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_last_addr">
      <bits access="r" name="seg_0_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_1_first_addr">
      <bits access="r" name="seg_1_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_last_addr">
      <bits access="r" name="seg_1_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_2_first_addr">
      <bits access="r" name="seg_2_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_last_addr">
      <bits access="r" name="seg_2_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="mem_fw_sys_ram2_rf.xml">
  <module name="mem_fw_sys_ram2_rf" category="firewall">
    <reg protect="rw" name="port0_default_r_addr_0">
      <bits access="r" name="port0_default_r_addr_0_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="port0_default_r_addr_0" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          default r address 0 register(4K-Byte address, bit 17 ~ bit 12).
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port0_default_w_addr_0">
      <bits access="r" name="port0_default_w_addr_0_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="port0_default_w_addr_0" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          default w address 0 register(4K-Byte address, bit 17 ~ bit 12).
        </comment>
      </bits>
    </reg>
    <hole size="1984"/>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

          0: don't response error; 1: response error
        </comment>
      </bits>
      <bits access="r" name="clk_gate_bypass_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          clock gate bypass
        </comment>
      </bits>
    </reg>
    <hole size="2016"/>
    <reg protect="rw" name="port_int_w_en">
      <bits access="r" name="port_int_w_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 write address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_w_clr">
      <bits access="r" name="port_int_w_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 write address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_raw">
      <bits access="r" name="port_int_w_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
        <comment>
          Port 0 write address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_fin">
      <bits access="r" name="port_int_w_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
        <comment>
          Port 0 write address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_en">
      <bits access="r" name="port_int_r_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 read address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_clr">
      <bits access="r" name="port_int_r_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 read address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_raw">
      <bits access="r" name="port_int_r_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="0" rst="0">
        <comment>
          Port 0 read address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_fin">
      <bits access="r" name="port_int_r_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="0" rst="0">
        <comment>
          Port 0 read address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <hole size="3840"/>
    <reg protect="r" name="port_0_w_debug_addr">
      <bits access="r" name="port_0_w_debug_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_addr_0" pos="7:0" rst="0">
        <comment>
          Port 0 write channel address, 4K-Byte
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_w_debug_id">
      <bits access="r" name="port_0_w_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_id_0" pos="7:0" rst="0">
        <comment>
          Port 0 write channel id, MSB is prot[1]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_addr">
      <bits access="r" name="port_0_r_debug_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_addr_0" pos="7:0" rst="0">
        <comment>
          Port 0 read channel address, 4K-Byte
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_id">
      <bits access="r" name="port_0_r_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_id_0" pos="7:0" rst="0">
        <comment>
          Port 0 read channel id, MSB is prot[1]
        </comment>
      </bits>
    </reg>
    <hole size="8064"/>
    <reg protect="rw" name="seg_default_first_addr">
      <bits access="r" name="seg_default_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment default first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_last_addr">
      <bits access="r" name="seg_default_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment default last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="15808"/>
    <reg protect="rw" name="seg_0_first_addr">
      <bits access="r" name="seg_0_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_last_addr">
      <bits access="r" name="seg_0_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_1_first_addr">
      <bits access="r" name="seg_1_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_last_addr">
      <bits access="r" name="seg_1_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_2_first_addr">
      <bits access="r" name="seg_2_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_last_addr">
      <bits access="r" name="seg_2_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="mem_fw_sys_ram3_rf.xml">
  <module name="mem_fw_sys_ram3_rf" category="firewall">
    <reg protect="rw" name="port0_default_r_addr_0">
      <bits access="r" name="port0_default_r_addr_0_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="port0_default_r_addr_0" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          default r address 0 register(4K-Byte address, bit 17 ~ bit 12).
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port0_default_w_addr_0">
      <bits access="r" name="port0_default_w_addr_0_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="port0_default_w_addr_0" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          default w address 0 register(4K-Byte address, bit 17 ~ bit 12).
        </comment>
      </bits>
    </reg>
    <hole size="1984"/>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

          0: don't response error; 1: response error
        </comment>
      </bits>
      <bits access="r" name="clk_gate_bypass_reserved_1" pos="3:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          clock gate bypass
        </comment>
      </bits>
    </reg>
    <hole size="2016"/>
    <reg protect="rw" name="port_int_w_en">
      <bits access="r" name="port_int_w_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 write address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_w_clr">
      <bits access="r" name="port_int_w_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 write address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_raw">
      <bits access="r" name="port_int_w_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
        <comment>
          Port 0 write address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_w_fin">
      <bits access="r" name="port_int_w_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
        <comment>
          Port 0 write address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_en">
      <bits access="r" name="port_int_r_en_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 read address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_r_clr">
      <bits access="r" name="port_int_r_clr_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 read address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_raw">
      <bits access="r" name="port_int_r_raw_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="0" rst="0">
        <comment>
          Port 0 read address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_r_fin">
      <bits access="r" name="port_int_r_fin_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="0" rst="0">
        <comment>
          Port 0 read address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <hole size="3840"/>
    <reg protect="r" name="port_0_w_debug_addr">
      <bits access="r" name="port_0_w_debug_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_addr_0" pos="7:0" rst="0">
        <comment>
          Port 0 write channel address, 4K-Byte
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_w_debug_id">
      <bits access="r" name="port_0_w_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="w_id_0" pos="7:0" rst="0">
        <comment>
          Port 0 write channel id, MSB is prot[1]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_addr">
      <bits access="r" name="port_0_r_debug_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_addr_0" pos="7:0" rst="0">
        <comment>
          Port 0 read channel address, 4K-Byte
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_0_r_debug_id">
      <bits access="r" name="port_0_r_debug_id_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="r_id_0" pos="7:0" rst="0">
        <comment>
          Port 0 read channel id, MSB is prot[1]
        </comment>
      </bits>
    </reg>
    <hole size="8064"/>
    <reg protect="rw" name="seg_default_first_addr">
      <bits access="r" name="seg_default_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment default first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_last_addr">
      <bits access="r" name="seg_default_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment default last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_default_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Default Segment write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="15808"/>
    <reg protect="rw" name="seg_0_first_addr">
      <bits access="r" name="seg_0_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_last_addr">
      <bits access="r" name="seg_0_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_0_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 0 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_1_first_addr">
      <bits access="r" name="seg_1_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_last_addr">
      <bits access="r" name="seg_1_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_1_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 1 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="rw" name="seg_2_first_addr">
      <bits access="r" name="seg_2_first_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="first_addr" pos="7:0" rst="255">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 first address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_last_addr">
      <bits access="r" name="seg_2_last_addr_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="last_addr" pos="7:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 last address, the actual address should right shift 10-bit (1K-Byte)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id0">
      <bits access="rw" name="mst_r_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id1">
      <bits access="rw" name="mst_r_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id2">
      <bits access="rw" name="mst_r_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id3">
      <bits access="rw" name="mst_r_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id4">
      <bits access="rw" name="mst_r_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id5">
      <bits access="rw" name="mst_r_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id6">
      <bits access="rw" name="mst_r_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_r_id7">
      <bits access="rw" name="mst_r_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Read Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can read
0: Master can't read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id0">
      <bits access="rw" name="mst_w_id0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 0~31.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id1">
      <bits access="rw" name="mst_w_id1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 32~63.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id2">
      <bits access="rw" name="mst_w_id2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 64~95.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id3">
      <bits access="rw" name="mst_w_id3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 96~127.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id4">
      <bits access="rw" name="mst_w_id4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 128~159.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id5">
      <bits access="rw" name="mst_w_id5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 160~191.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id6">
      <bits access="rw" name="mst_w_id6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 192~223.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="seg_2_mst_w_id7">
      <bits access="rw" name="mst_w_id7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Segment 2 Write Master ID select, one bit indicates a master ID, master ID from 224~255.
1: Master can write
0: Master can't write
        </comment>
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "nb_acc.xml">
  <module name="nb_acc" category="NBIOT_PHY">
    <reg32 name="rNB_ACC_EN" protect="w">
      <bits name="rNB_ACC_EN" pos="0" access="w" rst="0">
        <comment>NB accelerator Enable
        when enable is low, it would wait to the last DMA transfer to go back to idle status.
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_ACC_CTRL" protect="rw">
      <bits name="rCMD_LEN" pos="11:8" access="rw" rst="0">
        <comment>Command Length (unit DW)</comment>
      </bits>
      <bits name="rCMD_NUM" pos="7:0" access="rw" rst="0">
        <comment>Number of Command</comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_CMD_START_ADDR" protect="rw">
      <bits name="rNB_ACC_CMD_START_ADDR" pos="31:2" access="rw" rst="0">
        <comment>Command start address(unit: byte in DW aligned)</comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_DMA_TO_VAL" protect="rw">
      <bits name="rNB_ACC_DMA_TO_VAL" pos="31:0" access="rw" rst="0">
        <comment>Maximum time out value in AHB clock unit
        Default:(0) Disable
        Unit in AHB clock
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_START_ADDR_LIMIT0" protect="rw">
      <bits name="rNB_ACC_START_ADDR_LIMIT0" pos="31:2" access="rw" rst="0">
        <comment>Start address limit0:
        Valid DMA Output address must be not less than Start address limit
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_END_ADDR_LIMIT0" protect="rw">
      <bits name="rNB_ACC_END_ADDR_LIMIT0" pos="31:2" access="rw" rst="0x3FFFFFFF">
        <comment>End address limit0:
        Valid DMA Output address must be less than End start address limit
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_TO_VAL" protect="rw">
      <bits name="rNB_ACC_TO_VAL" pos="31:0" access="rw" rst="0">
        <comment>Maximum time out value in AHB clock unit:
        Default:(0) Disable
        Unit in AHB clock
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_START_ADDR_LIMIT1" protect="rw">
      <bits name="rNB_ACC_START_ADDR_LIMIT1" pos="31:2" access="rw" rst="1">
        <comment>Start address limit1:
        Valid DMA Output address must be not less than Start address limit
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_END_ADDR_LIMIT1" protect="rw">
      <bits name="rNB_ACC_END_ADDR_LIMIT1" pos="31:2" access="rw" rst="0x3FFFFFFF">
        <comment>End address limit1:
        Valid DMA Output address must be less than End start address limit
        </comment>
      </bits>
    </reg32>
    <hole size="3*32" />
    <reg32 name="rNB_ACC_STATUS" protect="rw">
      <bits name="rOAddr_Status" pos="14" access="ro" rst="0">
        <comment>Output address Status
        0: Normal
        1: Error
        </comment>
      </bits>
      <bits name="rHeader_Status" pos="13" access="ro" rst="0">
        <comment>Header Status
        0: Normal
        1: Error
        </comment>
      </bits>
      <bits name="rTimeout" pos="12:10" access="ro" rst="0">
        <comment>Timeout Error
        0: DMA Normal
        1: DMA Error
        Bit 0: Read DMA Error
        Bit 1: Write DMA Error
        Bit 2: Top Error
        </comment>
      </bits>
      <bits name="rCmd_Cnt" pos="9:2" access="ro" rst="0">
        <comment>Current Command Count</comment>
      </bits>
      <bits name="rStatus" pos="1" access="ro" rst="0">
        <comment>
        0: Idle
        1: On-going
        </comment>
      </bits>
      <bits name="rDone" pos="0" access="w1c" rst="0">
        <comment>This bit is read write 1 clear
        0: No Done
        1: Done
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_DMA_STATUS" protect="rw">
      <bits name="rNB_ACC_WDMA_STATUS" pos="25:16" access="ro" rst="0">
        <comment>Write DMA control status report
        </comment>
      </bits>
      <bits name="rNB_ACC_RDMA_STATUS" pos="9:0" access="ro" rst="60">
        <comment>Read DMA control status report
        </comment>
      </bits>
    </reg32>
    <hole size="2*32" />
    <reg32 name="rNB_ACC_RPT0" protect="ro">
      <bits name="rNB_ACC_RPT0" pos="31:0" access="ro" rst="0">
        <comment>MODE0~3: NA
        MODE 4: report Max value of small window
        MODE 5: bit[0]: timeout status for wait HW done
                        1: timeout  0: normal
        MODE 7: Maximum value of all square sums in data window
        MODE 9: Maximum value
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_RPT1" protect="ro">
      <bits name="rNB_ACC_RPT1" pos="31:0" access="ro" rst="0">
        <comment>MODE0~3: NA
        MODE 4: report Max value index of small window
        MODE 5: NA
        MODE 7: Maximum value's index of all square sums in data window
        MODE 9: Maximum value index
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_RPT2" protect="ro">
      <bits name="rNB_ACC_RPT2" pos="31:0" access="ro" rst="0">
        <comment>MODE0~3: NA
        MODE 4: report Max value of large window
        MODE 5: NA
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_RPT3" protect="ro">
      <bits name="rNB_ACC_RPT3" pos="31:0" access="ro" rst="0">
        <comment>MODE0~3: NA
        MODE 4: report Max value index of large window
        MODE 5: NA
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_RPT4" protect="ro">
      <bits name="rNB_ACC_RPT4" pos="31:0" access="ro" rst="0">
        <comment>MODE0~3: NA
        MODE 4: report Max value value of small window
        MODE 5: bit[0]: timeout status for wait HW done
                        1: timeout  0: normal
        MODE 7: Maximum value of all square sums in data window
        MODE 9: Maximum value
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_RPT5" protect="ro">
      <bits name="rNB_ACC_RPT5" pos="31:0" access="ro" rst="0">
        <comment>MODE0~3: NA
        MODE 4: report Max value index of small window
        MODE 5: NA
        MODE 7: Maximum value's index of all square sums in data window
        MODE 9: Maximum value index
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_RPT6" protect="ro">
      <bits name="rNB_ACC_RPT6" pos="31:0" access="ro" rst="0">
        <comment>MODE0~3: NA
        MODE 4: report Max value of large window
        MODE 5: NA
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_RPT7" protect="ro">
      <bits name="rNB_ACC_RPT7" pos="31:0" access="ro" rst="0">
        <comment>MODE0~3: NA
        MODE 4: report Max value index of large window
        MODE 5: NA
        </comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_ca_rx_dump.xml">
  <module name="nb_ca_rx_dump" category="NBIOT_PHY">
    <reg32 name="rCA_RX_DUMP_EN" protect="rw">
      <bits name="rCA_RX_DUMP_EN" pos="0" access="rw" rst="0">
        <comment>RX dump enable
(Auto clear when the RX dump done asserted)</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_START_POS" protect="rw">
      <bits name="rCA_RX_DUMP_START_SF_POS" pos="14:11" access="rw" rst="0">
        <comment>Start offset of subframe. Range is 0 to 9.</comment>
      </bits>
      <bits name="rCA_RX_DUMP_SAMPLE_START_POS" pos="10:0" access="rw" rst="0">
        <comment>Start offset of sample. Range is from 0 to 1919.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_CTRL" protect="rw">
      <bits name="rCA_RX_DUMP_SUBSAMPLE_OS_DLY" pos="24:16" access="rw" rst="0">
        <comment>Number of CA = 1-16</comment>
      </bits>
      <bits name="rDOWNSAMPLE_IDX" pos="9:8" access="rw" rst="0">
        <comment>Downsample index
0: No Downsample
1: Downsample x 2
2: Downsample x 4
3: Downsample x 8</comment>
      </bits>
      <bits name="rCA_NUM" pos="5:0" access="rw" rst="0">
        <comment>Number of CA = 1-16</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_DM_TIMEOUT_VAL" protect="rw">
      <bits name="rCA_RX_DUMP_DM_TIMEOUT_VAL" pos="31:0" access="rw" rst="0xffffffff">
        <comment>DMA timeout value
Default : 0xFFFF_FFFF
0: Disable</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_MEM_BADDR_BYTE" protect="rw">
      <bits name="rCA_RX_DUMP_MEM_BADDR_BYTE" pos="31:0" access="rw" rst="0">
        <comment>CA RX dump Memory base Address in byte (with DW alignment)</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_DEPTH_DW" protect="rw">
      <bits name="rCA_RX_DUMP_DEPTH_DW" pos="17:0" access="rw" rst="0">
        <comment>Each CA RX memory depth (with 16 IQ data alignment only) in DW</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_LEN_DW" protect="rw">
      <bits name="rCA_RX_DUMP_LEN_DW" pos="17:0" access="rw" rst="0">
        <comment>Each CA RX memory length (with 16 IQ data alignment only) in DW
If Length = 0, length = infinite until disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_OS_BYTE" protect="rw">
      <bits name="rCA_RX_DUMP_OS_BYTE" pos="17:0" access="rw" rst="0">
        <comment>Each CA RX memory offset (with 16 IQ data alignment only) in byte</comment>
      </bits>
    </reg32>
    <hole size="2*32"></hole>
    <reg32 name="rCA_RX_DUMP_TRANS_ADDR" protect="r">
      <bits name="rCA_RX_DUMP_TRANS_ADDR" pos="31:0" access="r" rst="0">
        <comment>RX memory dump transfer current memory address</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_TRANS_CNT" protect="r">
      <bits name="rCA_RX_DUMP_TRANS_CNT" pos="31:0" access="rw" rst="0">
        <comment>RX memory dump transfer current count</comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="rCA_RX_DUMP_STATUS" protect="r">
      <bits name="rDMA_DATA_CNT" pos="18:15" access="r" rst="0">
        <comment>Indicate how many data are transferred in a AHB burst cycle
        </comment>
    </bits>
      <bits name="rDMA_DONE_STATUS" pos="14:13" access="r" rst="0">
        <comment>Indicate the cause of DMA done
0: DMA transfer success done
1: DMA done caused by i_dma_stop
2: DMA done caused by timeout
</comment>
      </bits>
      <bits name="rDMA_CTRL_STATUS" pos="12:5" access="r" rst="80">
        <comment>For DMA debug:
[4:0] dma controller state machine
[5] dma_rfifo0_rdy
[6] dma_rfifo1_rdy
[7] dma_wfifo_rdy
</comment>
      </bits>
      <bits name="rCAPTURE_FIFO_OVERFLOW" pos="3" access="r" rst="0">
        <comment>Capture FIFO Overflow
0: Normal
1: Error
</comment>
      </bits>
      <bits name="rDMA_TIMEOUT" pos="2" access="r" rst="0">
        <comment>DMA Timeout Error
0: Normal
1: Error

</comment>
      </bits>
      <bits name="rSTATUS" pos="1" access="r" rst="0">
        <comment>0: Idle
1: Process
</comment>
      </bits>
      <bits name="rDONE" pos="0" access="w1c" rst="0">
        <comment>(This bit is read write 1 clear)
0: No Done
1: Done
</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_ca_tx_dump.xml">
  <module name="nb_ca_tx_dump" category="NBIOT_PHY">
    <reg32 name="rCA_TX_DUMP_TIMER_CTRL0" protect="rw">
      <bits name="rMAX_SAMPLE_NUM0" pos="7:0" access="rw" rst="0">
        <comment>Timer status control 0. It can control frame structure for MCA IFFT process.
Maximum Sample number 0 </comment>
      </bits>
      <bits name="rMAX_SAMPLE_NUM1" pos="23:16" access="rw" rst="0">
        <comment>Timer status control 0. It can control frame structure for MCA IFFT process.
Maximum Sample number 1</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_TIMER_CTRL1" protect="rw">
      <bits name="rMAX_SYM_IDX" pos="28:24" access="rw" rst="0">
        <comment>Timer status control 1. It can control frame structure for MCA IFFT process.
Maximum symbol Index
Valid:0 to 31 for 0 is maximum symbol = 1
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_TIMER_CTRL2" protect="rw">
      <bits name="rMAX_SYM_BMP" pos="31:0" access="rw" rst="0">
        <comment>Symbol bitmap for maximum sample number

For Bit i:
0: Maximum Sample number  0 (rMAX_SAMPLE_NUM0)
1: Maximum Sample number  1 (rMAX_SAMPLE_NUM1)
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_TIMER_STATUS" protect="r">
      <bits name="rCA_TX_SAMPLE_CNT" pos="7:0" access="rw" rst="0">
        <comment>DMA Transferred TX sample counter</comment>
      </bits>
      <bits name="rCA_TX_SYM_CNT" pos="19:16" access="rw" rst="0">
        <comment>DMA Transferred TX symbol counter</comment>
      </bits>
      <bits name="rCA_TX_SF_CNT" pos="27:24" access="rw" rst="0">
        <comment>DMA Transferred TX subframe counter</comment>
      </bits>
    </reg32>
    <hole size="60*32"></hole>
    <reg32 name="rCA_TX_DUMP_EN" protect="rw">
      <bits name="rCA_TX_DUMP_EN" pos="0" access="rw" rst="0">
        <comment>TX dump enable
(Auto clear when the TX dump done asserted)
0: Disable
1: Enable
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_START_POS_CTRL" protect="rw">
      <bits name="rCA_TX_DUMP_START_PREFETCH_SF_POS" pos="30:27" access="rw" rst="0">
        <comment>Prefetch Start offset of subframe. Range is 0 to 9.</comment>
      </bits>
      <bits name="rCA_TX_DUMP_SAMPLE_PREFETCH_START_POS" pos="26:16" access="rw" rst="0">
        <comment>Prefetch Start offset of sample. Range is from 0 to 1919.</comment>
      </bits>
      <bits name="rCA_TX_DUMP_START_SF_POS" pos="14:11" access="rw" rst="0">
        <comment>Start offset of subframe. Range is 0 to 9.</comment>
      </bits>
      <bits name="rCA_TX_DUMP_SAMPLE_START_POS" pos="10:0" access="rw" rst="0">
        <comment>Start offset of sample. Range is from 0 to 1919.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_CTRL" protect="rw">
      <bits name="rSUBSAMPLE_OS_DLY" pos="24:16" access="rw" rst="0">
        <comment>Subsample Offset Delay for TX transmission
Range: 0 - 511 (NB clock unit)
</comment>
      </bits>
      <bits name="rUPSAMPLE_IDX" pos="9:8" access="rw" rst="0">
        <comment>Upsample index with zero insertion
0: No Upsample
1: Upsample x 2
2: Upsample x 4
3: Not support
</comment>
      </bits>
      <bits name="rCA_NUM" pos="5:0" access="rw" rst="0">
        <comment>Number of CA = 1-16</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_INS_ZERO_NUM" protect="rw">
      <bits name="rINS_ZERO_NUM" pos="8:0" access="rw" rst="0">
        <comment>Control the number of zero inserted at the end of the TX transmission.  Remark: stop or disable command would not insert zero at the end.
Valid: 0-511
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_DM_TIMEOUT_VAL" protect="rw">
      <bits name="rDMA_TIMEOUT_VAL" pos="31:0" access="rw" rst="0xffffffff">
        <comment>DMA timeout value
Default : 0xFFFF_FFFF
0: Disable</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_MEM_BADDR_BYTE" protect="rw">
      <bits name="rCA_TX_DUMP_MEM_BADDR_BYTE" pos="31:0" access="rw" rst="0">
        <comment>CA TX dump Memory base Address in byte (with DW alignment)</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_DEPTH_DW" protect="rw">
      <bits name="rCA_TX_DUMP_DEPTH_DW" pos="17:0" access="rw" rst="0">
        <comment>Each CA TX memory depth (with 16 IQ data alignment only) in DW</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_LEN_DW" protect="rw">
      <bits name="rCA_TX_DUMP_LEN_DW" pos="17:0" access="rw" rst="0">
        <comment>Each CA TX memory length (with 16 IQ data alignment only) in DW
If Length = 0, length = infinite until disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_LEN_OS_BYTE" protect="rw">
      <bits name="rCA_TX_DUMP_LEN_OS_BYTE" pos="17:0" access="rw" rst="0">
        <comment>Each CA TX memory offset  address (with 8 IQ data DW alignment only) in byte</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_STOP_POS" protect="rw">
      <bits name="rCA_TX_DUMP_SAMPLE_STOP_POS" pos="10:0" access="rw" rst="0">
        <comment>Stop offset of sample. Range is from 0 to 1919.</comment>
      </bits>
      <bits name="rCA_TX_DUMP_SF_STOP_POS" pos="14:11" access="rw" rst="0">
        <comment>Stop offset of subframe. Range is 0 to 9.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_STOP_POS_EN" protect="rw">
      <bits name="rCA_TX_DUMP_STOP_POS_EN" pos="0" access="rw" rst="0">
        <comment>CA TX dump stop position enable. Auto clear when the ca_tx_dump_done is asserted
0: Disable
1: Enable

</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_CHKSUM_CTRL" protect="rw">
      <bits name="rCA_TX_DUMP_CHKSUM_EN" pos="31" access="rw" rst="0">
        <comment>TX output data checksum enable
1: enable
0: disable
</comment>
      </bits>
      <bits name="rCA_TX_DUMP_CHKSUM_BMP" pos="23:0" access="rw" rst="0">
        <comment>RX memory dump transfer current count</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_CHKSUM_CNT" protect="r">
      <bits name="rCA_TX_DUMP_CHKSUM_CNT" pos="31:0" access="r" rst="0">
        <comment>TX output data checksum counter</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_TRANS_ADDR" protect="r">
      <bits name="rCA_TX_DUMP_ADDR" pos="31:0" access="r" rst="0">
        <comment>TX memory dump transfer current memory address</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_TRNAS_CNT" protect="r">
      <bits name="rCA_TX_DUMP_CNT" pos="31:0" access="r" rst="0">
        <comment>TX memory dump transfer current count</comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="rCA_TX_DUMP_STATUS" protect="r">
      <bits name="rDMA_DATA_CNT" pos="18:15" access="r" rst="0">
-        <comment>Indicate how many data are transferred in a AHB burst cycle
-        </comment>
-    </bits>
-      <bits name="rDMA_DONE_STATUS" pos="14:13" access="r" rst="0">
        <comment>Indicate the cause of DMA done
0: DMA transfer success done
1: DMA done caused by i_dma_stop
2: DMA done caused by timeout
</comment>
      </bits>
      <bits name="rDMA_CTRL_STATUS" pos="12:5" access="r" rst="0">
-        <comment>For DMA debug:
-[4:0] dma controller state machine
-[5] dma_rfifo0_rdy
-[6] dma_rfifo1_rdy
-[7] dma_wfifo_rdy
-</comment>
-      </bits>
-      <bits name="rPREFETCH_ERR" pos="4" access="r" rst="0">
-        <comment>IFFT ready signal is not high before TX dump prefetch timing</comment>
-      </bits>
-      <bits name="rREAD_FIFO_UNDERFLOW" pos="3" access="r" rst="0">
-        <comment>Read FIFO Underflow
-0: Normal
-1: Error
-</comment>
-      </bits>
-      <bits name="rDMA_TIMEOUT" pos="2" access="r" rst="0">
-        <comment>DMA Timeout Error
</comment>
      </bits>
      <bits name="rSTATUS" pos="1" access="r" rst="0">
        <comment>0: Idle
1: Process
</comment>
      </bits>
      <bits name="rDONE" pos="0" access="w1c" rst="0">
        <comment>(This bit is read write 1 clear)
0: No Done
1: Done
</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_cell_search.xml">
  <module name="nb_cell_search" category="NBIOT_PHY">
    <reg32 name="rPSS_CTRL" protect="rw">
      <bits name="rPSS_EN" pos="0" access="rw" rst="0">
        <comment>PSS Enable
1'b0: Stop PSS calculation
1'b1: Start PSS calculation
</comment>
      </bits>
      <bits name="rPSS_HYPO_NUM" pos="3:1" access="rw" rst="0">
        <comment>PSS hypothesis number</comment>
      </bits>
      <bits name="rPSS_OUT_BUF_CFG" pos="4" access="rw" rst="0">
        <comment>PSS output ping-pong buffer selection
1'b1:Select the pong buffer as the first output buffer
1'b0: Select the ping buffer as the first output buffer
</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_START_OS" protect="rw">
      <bits name="rPSS_START_SAMPLE_OS" pos="10:0" access="rw" rst="0">
        <comment>PSS start offset of sample within a sbuframe. Based on 1.92MHz. Range is from 0 to 1920.</comment>
      </bits>
      <bits name="rPSS_START_SF_OS" pos="14:11" access="rw" rst="0">
        <comment>PSS start offset of subframe. Range is from 0 to 9.</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_SF_CNT" protect="r">
      <bits name="rPSS_SF_CNT" pos="3:0" access="r" rst="0">
        <comment>PSS internal sub frame counter(from 0 to 9)</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_OUT_STATUS" protect="r">
      <bits name="rPSS_OBUF_SEL" pos="0" access="r" rst="0">
        <comment>Indicate the buffer selection on current interrupt
1'b0: buffer0 is selection
1'b1: buffer1 is selection</comment>
      </bits>
      <bits name="rPSS_OBUF0_STATUS_0" pos="1" access="w1c" rst="0">
        <comment>PSS output buffer 0 status. Clear by DSP or MCU
1'b1: buffer 0 is ready.
1'b0:buffer0 is idle</comment>
      </bits>
      <bits name="rPSS_OBUF0_STATUS_1" pos="2" access="r" rst="0">
        <comment>PSS output buffer 0 status. 
1'b1: buffer 0 is over written. 
1'b0: buffer 0 is normal
</comment>
      </bits>
      <bits name="rPSS_OBUF1_STATUS_0" pos="3" access="w1c" rst="0">
        <comment>PSS output buffer 1 status. Clear by DSP or MCU
1'b1: buffer 1 is ready.
1'b0:buffer 1 is idle</comment>
      </bits>
      <bits name="rPSS_OBUF1_STATUS_1" pos="4" access="r" rst="0">
        <comment>PSS output buffer 1 status. 
1'b1: buffer 1 is over written. 
1'b0: buffer 1 is normal
</comment>
      </bits>
      <bits name="rPSS_DONE_STATUS" pos="5" access="w1c" rst="0">
        <comment>PSS calculation done status. Update very 1ms and clear by DSP or MCU.
1'b1: PSS calculation done 
1'b0: PSS is idle or under calculating</comment>
      </bits>
      <bits name="rPSS_MEM_ARB_STATUS" pos="7:6" access="r" rst="0">
        <comment>PSS write memory arbitration error status.
1'b1: the memory has conflict
1'b0: the memory is normal</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_NON_ZERO_STATUS" protect="r">
      <bits name="rPSS_NON_ZERO_STATUS" pos="8:0" access="r" rst="0">
        <comment>bit8: pss final output data non-zero status
bit7: pss 148x40 memory out data non-zero status
bit6: pss 148x40 memory in data non-zero status
bit5: pss power non-zero status
bit4: pss 1312x24 memory out data non-zero status
bit3: pss 1312x24 memory in data non-zero status
bit2: pss in local sequence non-zero status
bit1: pss_corr_calc in data non-zero status
bit0: pss_deci in data non-zero status</comment>
      </bits>
    </reg32>
    <hole size="3*32" />
    <reg32 name="rPSS_SAMPLE_POS_PU0" protect="rw">
      <bits name="rPSS_SAMPLE_POS_PU_0" pos="4:0" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 0</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PU_1" pos="12:8" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 1</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PU_2" pos="20:16" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 2</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PU_3" pos="28:24" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 3</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_SAMPLE_POS_PU1" protect="rw">
      <bits name="rPSS_SAMPLE_POS_PU_4" pos="4:0" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 0</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PU_5" pos="12:8" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 1</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PU_6" pos="20:16" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 2</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_SAMPLE_POS_PL0" protect="rw">
      <bits name="rPSS_SAMPLE_POS_PL_0" pos="4:0" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 0</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PL_1" pos="12:8" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 1</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PL_2" pos="20:16" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 2</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PL_3" pos="28:24" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 3</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_SAMPLE_POS_PL1" protect="rw">
      <bits name="rPSS_SAMPLE_POS_PL_4" pos="4:0" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 4</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PL_5" pos="12:8" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 5</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PL_6" pos="20:16" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 6</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_COEFF00" protect="rw">
      <bits name="rPSS_COEF_SET0_0" pos="7:0" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 0</comment>
      </bits>
      <bits name="rPSS_COEF_SET0_1" pos="15:8" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 1</comment>
      </bits>
      <bits name="rPSS_COEF_SET0_2" pos="23:16" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 2</comment>
      </bits>
      <bits name="rPSS_COEF_SET0_3" pos="31:24" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 3</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_COEFF01" protect="rw">
      <bits name="rPSS_COEF_SET0_4" pos="7:0" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 4</comment>
      </bits>
      <bits name="rPSS_COEF_SET0_5" pos="15:8" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 5</comment>
      </bits>
      <bits name="rPSS_COEF_SET0_6" pos="23:16" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 7</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_COEFF10" protect="rw">
      <bits name="rPSS_COEF_SET1_0" pos="7:0" access="rw" rst="0">
        <comment>PSS set 1 coefficient for hypothesis 0</comment>
      </bits>
      <bits name="rPSS_COEF_SET1_1" pos="15:8" access="rw" rst="0">
        <comment>PSS set 1 coefficient for hypothesis 1</comment>
      </bits>
      <bits name="rPSS_COEF_SET1_2" pos="23:16" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 2</comment>
      </bits>
      <bits name="rPSS_COEF_SET1_3" pos="31:24" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 3</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_COEFF11" protect="rw">
      <bits name="rPSS_COEF_SET1_4" pos="7:0" access="rw" rst="0">
        <comment>PSS set 1 coefficient for hypothesis 4</comment>
      </bits>
      <bits name="rPSS_COEF_SET1_5" pos="15:8" access="rw" rst="0">
        <comment>PSS set 1 coefficient for hypothesis 5</comment>
      </bits>
      <bits name="rPSS_COEF_SET1_6" pos="23:16" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 6</comment>
      </bits>
    </reg32>
    <hole size="8*32"></hole>
    <struct count="17" name="PSS_SEQ0_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ0" protect="w">
        <bits name="rPSS_LOCAL_SEQ0_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 0</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ0_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 0</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ1_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ1" protect="w">
        <bits name="rPSS_LOCAL_SEQ1_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 1</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ1_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 1</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ2_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ2" protect="w">
        <bits name="rPSS_LOCAL_SEQ2_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 2</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ2_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 2</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ3_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ3" protect="w">
        <bits name="rPSS_LOCAL_SEQ3_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 3</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ3_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 3</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ4_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ4" protect="w">
        <bits name="rPSS_LOCAL_SEQ4_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 4</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ4_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 4</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ5_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ5" protect="w">
        <bits name="rPSS_LOCAL_SEQ5_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 5</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ5_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 5</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ6_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ6" protect="w">
        <bits name="rPSS_LOCAL_SEQ6_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 6</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ6_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 6</comment>
        </bits>
      </reg32>
    </struct>
    <hole size="369*32" />
    <reg32 name="rCFO_START" protect="w">
      <bits name="rCFO_START" pos="0" access="w" rst="0">
        <comment>Start trigger of one CFO calculation process by writing "1" to this register</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_START_OS" protect="rw">
      <bits name="rCFO_START_SAMPLE_OS" pos="10:0" access="rw" rst="0">
        <comment>CFO data capture start offset of samples within a sub-frame. Based on 1.92MHz. Range is from 0 to 1920.</comment>
      </bits>
      <bits name="rCFO_START_SF_OS" pos="14:11" access="rw" rst="0">
        <comment>CFO data capture start offset of sub-frame. Range is from 0 to 13.</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CALC_OS" protect="rw">
      <bits name="rCFO_CALC_SAMPLE_OS" pos="10:0" access="rw" rst="0">
        <comment>CFO calculation start offset of samples within a sub-frame. Based on 1.92MHz. Range is from 0 to 1920.</comment>
      </bits>
      <bits name="rCFO_CALC_SF_OS" pos="14:11" access="rw" rst="0">
        <comment>CFO calculation start offset of sub-frame. Range is from 0 to 13.</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CTRL" protect="rw">
      <bits name="rCFO_FN_NUM" pos="2:0" access="rw" rst="0">
        <comment>Rotated frequency bin number when 'rCFO_MODE=0'.</comment>
      </bits>
      <bits name="rCFO_MODE" pos="3" access="rw" rst="0">
        <comment>1: Normal mode. CFO module only deal with 1 frequency bin(f0) and 9 sampling positions(Tau). 147 correlation results are reported to corresponding ram at most.
0: Searching mode. CFO module deal with 1~7 frequency bins(f0~6) and 21 sampling positions(Tau). 9 correlation results are reported to corresponding registers.
</comment>
      </bits>
      <bits name="rCFO_RPT_ADDR" pos="13:4" access="rw" rst="0">
        <comment>Start write address of CFO correlation results' reporting ram</comment>
      </bits>
      <bits name="rCFO_GAIN" pos="16:14" access="rw" rst="0">
        <comment>Correlation results truncation (32bits to 16bits).
0:&gt;&gt;8    1:&gt;&gt;7    2:&gt;&gt;6    3:&gt;&gt;5 
4:&gt;&gt;4    5:&gt;&gt;3    6:&gt;&gt;2    7:&gt;&gt;1</comment>
      </bits>
      <bits name="rCFO_TAU_NUM" pos="21:17" access="rw" rst="0">
        <comment>Tau number of CFO correlation when rCFO_MODE=0. </comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_OS_F0TO3" protect="rw">
      <bits name="rCFO_OS_F0" pos="7:0" access="rw" rst="0">
        <comment>Sampling position start offset for bin f0</comment>
      </bits>
      <bits name="rCFO_OS_F1" pos="15:8" access="rw" rst="0">
        <comment>Sampling position start offset for bin f1</comment>
      </bits>
      <bits name="rCFO_OS_F2" pos="23:16" access="rw" rst="0">
        <comment>Sampling position start offset for bin f2</comment>
      </bits>
      <bits name="rCFO_OS_F3" pos="31:24" access="rw" rst="0">
        <comment>Sampling position start offset for bin f3</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_OS_F4TO6" protect="rw">
      <bits name="rCFO_OS_F4" pos="7:0" access="rw" rst="0">
        <comment>Sampling position start offset for bin f4</comment>
      </bits>
      <bits name="rCFO_OS_F5" pos="15:8" access="rw" rst="0">
        <comment>Sampling position start offset for bin f5</comment>
      </bits>
      <bits name="rCFO_OS_F6" pos="23:16" access="rw" rst="0">
        <comment>Sampling position start offset for bin f6</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F0" protect="rw">
      <bits name="rCFO_A_F0" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F1" protect="rw">
      <bits name="rCFO_A_F1" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F2" protect="rw">
      <bits name="rCFO_A_F2" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F3" protect="rw">
      <bits name="rCFO_A_F3" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F4" protect="rw">
      <bits name="rCFO_A_F4" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F5" protect="rw">
      <bits name="rCFO_A_F5" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F6" protect="rw">
      <bits name="rCFO_A_F6" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F0" protect="rw">
      <bits name="rCFO_B_F0" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F1" protect="rw">
      <bits name="rCFO_B_F1" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F2" protect="rw">
      <bits name="rCFO_B_F2" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F3" protect="rw">
      <bits name="rCFO_B_F3" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F4" protect="rw">
      <bits name="rCFO_B_F4" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F5" protect="rw">
      <bits name="rCFO_B_F5" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F6" protect="rw">
      <bits name="rCFO_B_F6" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <hole size="4*32" />
    <reg32 name="rCFO_STATUS" protect="r">
      <bits name="rCFO_DONE_STATUS" pos="0" access="w1c" rst="0">
        <comment>CFO calculation done status. Clear by DSP or MCU.
1'b1: CFO calculation done 
1'b0: CFO is idle or under calculating</comment>
      </bits>
      <bits name="rCFO_WRAM_ERR" pos="2:1" access="r" rst="0">
        <comment>Memory request error for writing of CFO reporting ram when 'rCFO_MOED=0'
0: Normal
1: Error
Bit 2: DSP control bus error
Bit 1: accelerator memory access collusion</comment>
      </bits>
    </reg32>
    <hole size="39*32" />
    <reg32 name="rSSS_EN" protect="rw">
      <bits name="rSSS_EN" pos="0" access="rw" rst="0">
        <comment>SSS Enable
1'b0:Stop SSS calculation
1'b1: Start SSS calculation</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_START_OS" protect="rw">
      <bits name="rSSS_START_SAMPLE_OS" pos="10:0" access="rw" rst="0">
        <comment>SSS start offset of sample within a sbuframe. Based on 1.92MHz. Range is from 0 to 1920.</comment>
      </bits>
      <bits name="rSSS_START_SF_OS" pos="14:11" access="rw" rst="0">
        <comment>SSS start offset of subframe. Range is from 0 to 9.</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_START_CALC_OS" protect="rw">
      <bits name="rSSS_START_CALC_SAMPLE_OS" pos="10:0" access="rw" rst="0">
        <comment>SSS start calculation offset of sample within a subframe. Based on 1.92MHz. Range is from 0 to 1920.</comment>
      </bits>
      <bits name="rSSS_START_CALC_SF_OS" pos="14:11" access="rw" rst="0">
        <comment>SSS start calculation offset of subframe. Range is from 0 to 9.</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT0" protect="rw">
      <bits name="rSSS_PHASE_SHIFT0_RE" pos="11:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT0_IM" pos="27:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT1" protect="rw">
      <bits name="rSSS_PHASE_SHIFT1_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 1</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT1_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 1</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT2" protect="rw">
      <bits name="rSSS_PHASE_SHIFT2_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 2</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT2_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 2</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT3" protect="rw">
      <bits name="rSSS_PHASE_SHIFT3_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 3</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT3_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 3</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT4" protect="rw">
      <bits name="rSSS_PHASE_SHIFT4_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 4</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT4_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 4</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT5" protect="rw">
      <bits name="rSSS_PHASE_SHIFT5_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 5</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT5_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 5</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT6" protect="rw">
      <bits name="rSSS_PHASE_SHIFT6_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 6</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT6_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 6</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT7" protect="rw">
      <bits name="rSSS_PHASE_SHIFT7_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 7</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT7_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 7</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT8" protect="rw">
      <bits name="rSSS_PHASE_SHIFT8_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 8</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT8_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 8</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT9" protect="rw">
      <bits name="rSSS_PHASE_SHIFT9_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 9</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT9_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 9</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT10" protect="rw">
      <bits name="rSSS_PHASE_SHIFT10_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 10</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT10_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 10</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_SF_CNT" protect="r">
      <bits name="rSSS_SF_CNT" pos="3:0" access="r" rst="0">
        <comment>SSS internal sub frame counter(from 0 to 9)</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_GLB_CNT" protect="r">
      <bits name="rSSS_GLB_SAMPLE_CNT" pos="10:0" access="r" rst="0">
        <comment>global sample count value at SSS subframe start</comment>
      </bits>
      <bits name="rSSS_GLB_SF_CNT" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at SSS subframe start</comment>
      </bits>
      <bits name="rSSS_GLB_RF_CNT" pos="17:15" access="r" rst="0">
        <comment>Global radio frame count value at SSS subframe start</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_OUT_STATUS" protect="r">
      <bits name="rSSS_OBUF_SEL" pos="0" access="r" rst="0">
        <comment>Indicate the buffer selection on current interrupt
1'b0: MEM0 is selection
1'b1: MEM1 is selection</comment>
      </bits>
      <bits name="RESERVED" pos="1" access="rw" rst="0">
        <comment>RESERVED</comment>
      </bits>
      <bits name="rSSS_OBUF0_STATUS_0" pos="2" access="w1c" rst="0">
        <comment>SSS output buffer 0 status. Clear by DSP or MCU
bit 2: 1'b1: MEM2 or MEM0  is ready.1'b0:buffer0 is idle</comment>
      </bits>
      <bits name="rSSS_OBUF0_STATUS_1" pos="3" access="r" rst="0">
        <comment>SSS output buffer 0 status. 
bit 3: 1'b1: MEM2 or MEM0  is over written. 1'b0: buffer 0 is normal</comment>
      </bits>
      <bits name="rSSS_OBUF1_STATUS_0" pos="4" access="w1c" rst="0">
        <comment>SSS output buffer 1 status. Clear by DSP or MCU
bit 4: 1'b1: MEM3 or MEM1  is ready.1'b0:buffer1 is idle</comment>
      </bits>
      <bits name="rSSS_OBUF1_STATUS_1" pos="5" access="r" rst="0">
        <comment>SSS output buffer 1 status.
bit 5: 1'b1: MEM3 or MEM1  is over written. 1'b0: buffer 1 is normal</comment>
      </bits>
      <bits name="rSSS_DONE_STATUS" pos="6" access="w1c" rst="0">
        <comment>SSS calculation done status. Update very 1ms and clear by DSP or MCU.
1'b1: SSS calculation done 
1'b0: SSS is idle or under calculating</comment>
      </bits>
      <bits name="rSSS_MEM_ARB_STATUS" pos="8:7" access="r" rst="0">
        <comment>SSS write memory arbitration error status.
0: Normal
1: Error
Bit 7: DSP control bus error
Bit 8: accelerator memory access collusion</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_FFT_CTRL" protect="rw">
      <bits name="rSSS_FFT_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset which use to locate the FFT windows start position for serving cell.
Value:[0:9]</comment>
      </bits>
      <bits name="rSSS_FFT_SCALE" pos="6:4" access="rw" rst="0">
        <comment>FFT result scaling
3'd0: 2^-3
3'd1: 2^-2
3'd2: 2^-1
3'd3: 2^0
3'd4: 2^1
3'd5: 2^2</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_CORR_CTRL" protect="rw">
      <bits name="rSSS_CORR_SCAL" pos="2:0" access="rw" rst="5">
        <comment>Correlation result sScaling for both power and correlation
3'd0: 20
3'd1: 2-1
3'd2: 2-2
3'd3: 2-3
3'd4: 2-4
3'd5: 2-5(Default)
3'd6: 2-6
3'd7: 2-7</comment>
      </bits>
      <bits name="rSSS_CYCLIC_SHIFT" pos="4:3" access="rw" rst="0">
        <comment>Cyclic shift value 
It is used when rSSS_CYCLIC_SHIFT_FIX_EN = 1'b1.Rang is from 0 to 2.</comment>
      </bits>
      <bits name="rSSS_CYCLIC_SHIFT_FIX_EN" pos="5" access="rw" rst="0">
        <comment>Fix cyclic shift enable</comment>
      </bits>
      <bits name="rSSS_PCI_ID" pos="14:6" access="rw" rst="0">
        <comment>PCI ID 
It is used when rSSS_PCI_ID_FIX_RN = 1'b1 or rSSS_SIC_EN = 1'b1. Range is from 0 to 503.</comment>
      </bits>
      <bits name="rSSS_PCI_ID_FIX_EN" pos="15" access="rw" rst="0">
        <comment>Fix PCI ID Enable.</comment>
      </bits>
      <bits name="RESERVED" pos="16" access="rw" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rSSS_SIC_EN" pos="17" access="rw" rst="0">
        <comment>SIC Enable
Used for succesive interference cancellation.</comment>
      </bits>
      <bits name="rSSS_OUT_BUF_CFG" pos="18" access="rw" rst="0">
        <comment>SSS output ping-pong buffer selection
1'b1:Select the pong buffer as the first output buffer
1'b0: Select the ping buffer as the first output buffer</comment>
      </bits>
      <bits name="rSSS_CORR_SCAL2" pos="21:19" access="rw" rst="4">
        <comment>Scaling for correlation only
3'd0: 2-4
3'd1: 2-3
3'd2: 2-2
3'd3: 2-1
3'd4: 20(Default)
3'd5: 21
3'd6: 22
3'd7: 23</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PWR" protect="rw">
      <bits name="rSSS_PWR" pos="15:0" access="rw" rst="0x0">
        <comment>SSS total power</comment>
      </bits>
    </reg32>
    <hole size="44*32" />
    <reg32 name="rS16PEAK_EN" protect="rw">
      <bits name="rS16PEAK_EN" pos="0" access="rw" rst="0x0">
        <comment>"Search 16peak" accelerator enable
When enable is low, it would wait to the last DMA transfer to go back to idle status
1: enable
0: disable</comment>
      </bits>
    </reg32>
    <reg32 name="rS16PEAK_TAB_CTRL" protect="rw">
      <bits name="rS16PEAK_TAB_CTRL" pos="1:0" access="rw" rst="0x0">
        <comment>2'b00: continue mode(keep last table then do peaks searching)
2'b01: reset mode(reset table then do peaks searching)
2'b10: load mode(load a table from memory then do peaks searching)
2'b11: NA</comment>
      </bits>
    </reg32>
    <reg32 name="rS16PEAK_LDTAB_START_ADDR" protect="rw">
      <bits name="rS16PEAK_LDTAB_START_ADDR" pos="31:0" access="rw" rst="0x0">
        <comment>Start AHB address for loading a peak value table. It is used only when "rS16PEAK_TAB_CTRL=2'b10"</comment>
      </bits>
    </reg32>
    <reg32 name="rS16PEAK_WIN_CTRL" protect="rw">
      <bits name="rS16PEAK_WIN_IDX" pos="31:16" access="rw" rst="0x0">
        <comment>Searching window start index</comment>
      </bits>
      <bits name="rS16PEAK_WIN_SIZE" pos="15:0" access="rw" rst="0x0">
        <comment>Searching window size</comment>
      </bits>
    </reg32>
    <reg32 name="rS16PEAK_START_RADDR" protect="rw">
      <bits name="rS16PEAK_START_RADDR" pos="31:0" access="rw" rst="0x0">
        <comment>Start AHB address for reading searching window data</comment>
      </bits>
    </reg32>
    <reg32 name="rS16PEAK_START_WADDR" protect="rw">
      <bits name="rS16PEAK_START_WADDR" pos="31:0" access="rw" rst="0x0">
        <comment>Start AHB address for writing 16 max values and their indexes</comment>
      </bits>
    </reg32>
    <reg32 name="rS16PEAK_DMA_TO_VAL" protect="rw">
      <bits name="rS16PEAK_DMA_TO_VAL" pos="31:0" access="rw" rst="0x0">
        <comment>Up limit value for DMA timeout counter
When this register is set to 0, function of timeout is disabled</comment>
      </bits>
    </reg32>
    <reg32 name="rS16PEAK_TO_VAL" protect="rw">
      <bits name="rS16PEAK_TO_VAL" pos="31:0" access="rw" rst="0x0">
        <comment>Up limit value for "search 16peak" module's timeout counter
When this register is set to 0, function of timeout is disabled</comment>
      </bits>
    </reg32>
    <hole size="4*32" />
    <reg32 name="rS16PEAK_STATUS" protect="ro">
      <bits name="rS16PEAK_WIN_FIFO_STATUS" pos="21:18" access="ro" rst="0x0">
        <comment>Status reporting register for FIFO part in "search 16peak"</comment>
      </bits>
      <bits name="rS16PEAK_DMA_STATUS" pos="17:8" access="ro" rst="0x0">
        <comment>Status reporting register for AHB controlling part in "search 16peak"</comment>
      </bits>
      <bits name="Reserved" pos="7:4" access="ro" rst="0x0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rS16PEAK_ONGOING" pos="3" access="ro" rst="0x0">
        <comment>Indicating whether accelerator is on or not
1: ongoing
0: idle</comment>
      </bits>
      <bits name="rS16PEAK_TIMEOUT" pos="2" access="ro" rst="0x0">
        <comment>Indicating whether accelerator is timeout or not
1: timeout
0: normal</comment>
      </bits>
      <bits name="rS16PEAK_OBUF_UPDATE" pos="1" access="ro" rst="0x0">
        <comment>Indicating whether output table buffer is updated
1: updated
0: not updated</comment>
      </bits>
      <bits name="rS16PEAK_DONE_STATUS" pos="0" access="ro" rst="0x0">
        <comment>Reprot "serch 16peak" done status, write '1' to clear this status.
1: done
0: not done</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_common.xml">
  <module name="nb_common" category="NBIOT_PHY">
    <reg32 name="rRX_INT_DSP_SYM_BMP_MSK" protect="rw">
      <bits name="rRX_INT_DSP_SYM_BMP_MSK" pos="13:0" access="rw" rst="0x1">
        <comment>RX interrupt DSP bitmap mask from 0 to 13. LSB is symbol 0.</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_MCU_SYM_BMP_MSK" protect="rw">
      <bits name="rRX_INT_MCU_SYM_BMP_MSK" pos="13:0" access="rw" rst="0x1">
        <comment>RX interrupt DSP bitmap mask from 0 to 13. LSB is symbol 0.</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_OS" protect="rw">
      <bits name="rRX_INT_OS" pos="6:0" access="rw" rst="0x40">
        <comment>RX interrupt output OS 0 - 127</comment>
      </bits>
    </reg32>
    <reg32 name="rNB_TIMER_MODE" protect="rw">
      <bits name="rGLB_SAMPLE_RATE_CTRL" pos="2:0" access="rw" rst="0">
        <comment>Global timer sample rate per input clock source
0: 32 NB clock for 1 sample in global counter (Legacy Mode)
1: 64 NB clock for 1 sample in global counter (L230 Mode)
2: 128 clock for 1 sample in global counter
3: 256 clock for 1 sample in global counter
4: 512 clock for 1 sample in global counter
</comment>
      </bits>
      <bits name="rRX_SAMPLE_CTRL" pos="10:8" access="rw" rst="0">
        <comment>Rx data input sample rate in global sample unit
0: 1 Global Counter Sample (1.92MHz - Legacy Mode)
1: 2 Global Counter Sample (960 Khz)
2: 4 Global Counter Sample (480 Khz)
3: 8 Global Counter Sample (240 Khz - L230 Mode) 
4: 16 Global Counter Sample (120 Khz)
5: 32 Global Counter Sample (60 Khz)
</comment>
      </bits>
      <bits name="rTX_SAMPLE_CTRL" pos="18:16" access="rw" rst="0">
        <comment>Tx data output sample rate in global sample unit
0: 1 Global Counter Sample (1.92MHz - Legacy Mode)
1: 2 Global Counter Sample (960 Khz)
2: 4 Global Counter Sample (480 Khz)
3: 8 Global Counter Sample (240 Khz - L230 Mode) 
4: 16 Global Counter Sample (120 Khz)
5: 32 Global Counter Sample (60 Khz)
</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_DSP_SF_BMP_MSK" protect="rw">
      <bits name="rRX_INT_DSP_SF_BMP_MSK" pos="9:0" access="rw" rst="0x00003fff">
        <comment>RX interrupt DSP bitmap subframe mask from 0 to 9. LSB is subframe 0.
</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_MCU_SF_BMP_MSK" protect="rw">
      <bits name="rRX_INT_MCU_SF_BMP_MSK" pos="9:0" access="rw" rst="0x00003fff">
        <comment>RX interrupt MCU bitmap subframe mask from 0 to 9. LSB is subframe 0.
</comment>
      </bits>
    </reg32>
    <hole size="2*32"></hole>
    <reg32 name="rRX_ADJ_CCTRL" protect="rw">
      <bits name="rRX_ADJ_SF_CNT" pos="3:0" access="rw" rst="0">
        <comment>RX adjustment subframe count from 0 - 9 (auto clear in next subframe)</comment>
      </bits>
      <bits name="rRX_ADJ_SYM_CNT" pos="7:4" access="rw" rst="0">
        <comment>RX adjustment symbol count from 0 - 13 (auto clear in next subframe)</comment>
      </bits>
      <bits name="rRX_ADJ_SYM_DIR" pos="8" access="rw" rst="0">
        <comment>RX adjustment symbol direction (auto clear in next subframe)
0: advance
1: postpone</comment>
      </bits>
      <bits name="rRX_ADJ_CSAMPLE_CNT" pos="23:16" access="rw" rst="0">
        <comment>RX coarse adjustment sample count from 0 - 138 in (chip unit) - (auto clear in next subframe)</comment>
      </bits>
      <bits name="rRX_ADJ_CSAMPLE_DIR" pos="24" access="rw" rst="0">
        <comment>RX coarse adjustment sample direction (auto clear in next subframe)
0: advance
1: postpone</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_ADJ_FCTRL" protect="rw">
      <bits name="rRX_ADJ_FSAMPLE_CNT" pos="7:0" access="rw" rst="0">
        <comment>NB mode: RX fine adjustment sample count from 0 - 9 in (chip unit)
230 mode: RX fine adjustment sample count from 0 - 128 in (chip unit)
</comment>
      </bits>
      <bits name="rRX_ADJ_FSAMPLE_DIR" pos="8" access="rw" rst="0">
        <comment>RX fine adjustment sample direction (auto clear in next subframe)
0: advance
1: postpone</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_POS_STATUS_DSP" protect="r">
      <bits name="rRX_INT_SYM_DSP" pos="3:0" access="r" rst="0">
        <comment>RX interrupt symbol number 0-13</comment>
      </bits>
      <bits name="rRX_INT_SF_DSP" pos="7:4" access="r" rst="0">
        <comment>RX interrupt symbol number 0-13</comment>
      </bits>
      <bits name="rRX_INT_BUF_IDX_DSP" pos="8" access="r" rst="0">
        <comment>RX interrupt buffer index
Mirror rRX_INT_BUF_IDX_MCU register</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_POS_STATUS_MCU" protect="r">
      <bits name="rRX_INT_SYM_MCU" pos="3:0" access="r" rst="0">
        <comment>RX interrupt symbol number 0-13</comment>
      </bits>
      <bits name="rRX_INT_SF_MCU" pos="7:4" access="r" rst="0">
        <comment>RX interrupt symbol number 0-13</comment>
      </bits>
      <bits name="rRX_INT_BUF_IDX_MCU" pos="8" access="r" rst="0">
        <comment>RX interrupt buffer index</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_SFN" protect="rw">
      <bits name="rRX_SFN" pos="9:0" access="rw" rst="0">
        <comment>RX SFN number 0-1023</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_GLB_CNT_SF" protect="r">
      <bits name="rRX_GLB_SAMPLE_CNT_SF" pos="10:0" access="r" rst="0">
        <comment>global sample count value at RX subframe start</comment>
      </bits>
      <bits name="rRX_GLB_SF_CNT_SF" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at RX subframe start</comment>
      </bits>
      <bits name="rRX_GLB_RF_CNT_SF" pos="21:15" access="r" rst="0">
        <comment>global sample count value at RX subframe start</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_GLB_CNT_RF" protect="r">
      <bits name="rRX_GLB_SAMPLE_CNT_RF" pos="10:0" access="r" rst="0">
        <comment>global sample count value at RX radio frame start</comment>
      </bits>
      <bits name="rRX_GLB_SF_CNT_RF" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at RX radio frame start</comment>
      </bits>
      <bits name="rRX_GLB_RF_CNT_RF" pos="21:15" access="r" rst="0">
        <comment>global sample count value at RX radio frame start</comment>
      </bits>
    </reg32>
    <reg32 name="rTCU_GLB_CNT" protect="r">
      <bits name="rTCU_GLB_SAMPLE_CNT" pos="10:0" access="r" rst="0">
        <comment>global sample count value at TCU subframe start</comment>
      </bits>
      <bits name="rTCU_GLB_SF_CNT" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at TCU subframe start</comment>
      </bits>
      <bits name="rTCU_GLB_RF_CNT" pos="21:15" access="r" rst="0">
        <comment>global sample count value at TCU subframe start</comment>
      </bits>
    </reg32>
    <reg32 name="rTCU_GLB_CNT_RF" protect="r">
      <bits name="rTCU_GLB_SAMPLE_CNT_RF" pos="10:0" access="r" rst="0">
        <comment>global sample count value at TCU radio frame start</comment>
      </bits>
      <bits name="rTCU_GLB_SF_CNT_RF" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at TCU radio frame start</comment>
      </bits>
      <bits name="rTCU_GLB_RF_CNT_RF" pos="21:15" access="r" rst="0">
        <comment>global sample count value at TCU radio frame start</comment>
      </bits>
    </reg32>
    <hole size="3*32" />
    <reg32 name="rTX_ADJ_CCTRL" protect="rw">
      <bits name="rTX_ADJ_CSAMPLE_CNT" pos="10:0" access="rw" rst="0">
        <comment>TX coarse adjustment sample count from 0 - 1919 in (chip unit) - (auto clear in next subframe)</comment>
      </bits>
      <bits name="rTX_ADJ_CSAMPLE_DIR" pos="11" access="rw" rst="0">
        <comment>TX coarse adjustment sample direction - (auto clear in next subframe)
0: advance
1: postpone</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_ADJ_FCTRL" protect="rw">
      <bits name="rTX_ADJ_FSAMPLE_CNT" pos="5:0" access="rw" rst="0">
        <comment>15KHz: TX fine adjustment sample count from 0 - 9 in (chip unit)
3.75Hz: TX fine adjustment sample count from (0 - 9) x 4 in (chip unit) 
Remark: SW should configure the sample boundary which is aligned to 3.75Hz sample if the timing adjustment between TX transmission.
(auto clear in next subframe)</comment>
      </bits>
      <bits name="rTX_ADJ_CSAMPLE_DIR" pos="6" access="rw" rst="0">
        <comment>TX fine adjustment sample direction -  (auto clear in next subframe)
0: advance
1: postpone</comment>
      </bits>
      <bits name="rTX_ADJ_FMODE" pos="8" access="rw" rst="0">
        <comment>TX fine adjustment mode control:
0: adjust the boundary at the end of the current subframe
1: adjust the CP at the first symbol of the next TX </comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="rTX_GLB_CNT_SF" protect="r">
      <bits name="rTX_GLB_SAMPLE_CNT_SF" pos="10:0" access="r" rst="0">
        <comment>global sample count value at TX subframe start</comment>
      </bits>
      <bits name="rTX_GLB_SF_CNT_SF" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at TX subframe start</comment>
      </bits>
      <bits name="rTX_GLB_RF_CNT_SF" pos="21:15" access="r" rst="0">
        <comment>global radio frame count value at TX subframe start</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_SUBSAMPLE_CTRL" protect="rw">
      <bits name="rTX_SUBSAMPLE_CTRL" pos="0" access="rw" rst="0">
        <comment>TX subsample control
0: sync with global subsample counter
1: only sync with RX subsample counter when TX is not on transmission</comment>
      </bits>
    </reg32>
    <reg32 name="rCTRL_STATUS" protect="rw">
      <bits name="rCTRL_RX_CADJ_STATUS" pos="0" access="w1c" rst="0">
        <comment>Control RX coarse adjustment status</comment>
      </bits>
      <bits name="rCTRL_RX_FADJ_STATUS" pos="1" access="w1c" rst="0">
        <comment>Control RX fine adjustment status</comment>
      </bits>
      <bits name="rCTRL_TX_CADJ_STATUS" pos="2" access="w1c" rst="0">
        <comment>Control TX coarse adjustment status</comment>
      </bits>
      <bits name="rCTRL_TX_FADJ_STATUS" pos="3" access="w1c" rst="0">
        <comment>Control TX fine adjustment status</comment>
      </bits>
    </reg32>
    <reg32 name="rCTRL_ADJ_EN" protect="rw">
      <bits name="rCTRL_ADJ_EN" pos="0" access="rw" rst="0">
        <comment>Control adjustment enable
1: enable
0: disable</comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="rCAPTURE1_GLB_CNT_TRIG" protect="w">
      <bits name="rCAPTURE1_GLB_CNT_TRIG" pos="0" access="w" rst="0">
        <comment>Trigger to sample global counter position for DSP debegging</comment>
      </bits>
    </reg32>
    <reg32 name="rCAPTURE1_GLB_CNT" protect="r">
      <bits name="rCAPTURE1_GLB_CNT" pos="10:0" access="r" rst="0">
        <comment>global counter sample position when CAPTURE1_GLB_CNT is accessed</comment>
      </bits>
      <bits name="rCAPTURE1_GLB_SF_CNT" pos="14:11" access="r" rst="0">
        <comment>global counter subframe position when CAPTURE1_GLB_CNT is accessed</comment>
      </bits>
      <bits name="rCAPTURE1_GLB_RF_CNT" pos="21:15" access="r" rst="0">
        <comment>global counter radio frame position when CAPTURE1_GLB_CNT is accessed</comment>
      </bits>
    </reg32>
    <reg32 name="rCAPTURE2_GLB_CNT_TRIG" protect="w">
      <bits name="rCAPTURE2_GLB_CNT_TRIG" pos="0" access="w" rst="0">
        <comment>Trigger to sample global counter position for MCU debegging</comment>
      </bits>
    </reg32>
    <reg32 name="rCAPTURE2_GLB_CNT" protect="r">
      <bits name="rCAPTURE2_GLB_SAMPLE_CNT" pos="10:0" access="r" rst="0">
        <comment>global counter sample position when CAPTURE2_GLB_CNT is accessed</comment>
      </bits>
      <bits name="rCAPTURE2_GLB_SF_CNT" pos="14:11" access="r" rst="0">
        <comment>global counter subframe position when CAPTURE2_GLB_CNT is accessed</comment>
      </bits>
      <bits name="rCAPTURE2_GLB_RF_CNT" pos="21:15" access="r" rst="0">
        <comment>global counter radio frame position when CAPTURE2_GLB_CNT is accessed</comment>
      </bits>
    </reg32>
    <reg32 name="SLEEP_W" protect="w">
      <bits name="SLEEP_W" pos="0" access="w" rst="0">
        <comment>For sleep operation
When SLEEP_W is accessed, the start values needed for wake-up are loaded. Then values have to be written before the SLEEP_W is accessed</comment>
      </bits>
    </reg32>
    <reg32 name="rSLEEP_GLB_CNT" protect="rw">
      <bits name="rGLB_SUB_SAMPLE_CNT" pos="4:0" access="r" rst="0">
        <comment>Sample clock/32 (TX/RX sub-sample is always aligned with Global sub-sample) : this would use for alignment of the DFE input valid.
0-31</comment>
      </bits>
      <bits name="rGLB_SAMPLE_CNT" pos="15:5" access="rw" rst="0">
        <comment>global counter sample position in sleep mode (in chip unit)</comment>
      </bits>
      <bits name="rGLB_SF_CNT" pos="19:16" access="rw" rst="0">
        <comment>global counter subframe position </comment>
      </bits>
      <bits name="rGLB_RF_CNT" pos="26:20" access="rw" rst="0">
        <comment>global counter radio frame position</comment>
      </bits>
      <bits name="rGLB_SUB_SAMPLE_CNT_MSB" pos="31:28" access="r" rst="0">
        <comment>Global counter subsample MSB bit [8:5].</comment>
      </bits>
    </reg32>
    <reg32 name="rSLEEP_RX_TX_CNT" protect="rw">
      <bits name="rTX_SAMPLE_CNT" pos="10:0" access="rw" rst="0">
        <comment>Sample clock/32 (TX/RX sub-sample is always aligned with Global sub-sample) : this would use for align the DFE input valid.
0-31</comment>
      </bits>
      <bits name="rRX_SAMPLE_CNT" pos="23:16" access="rw" rst="0">
        <comment>RX sample count value</comment>
      </bits>
      <bits name="rRX_SYM_CNT" pos="27:24" access="rw" rst="0">
        <comment>RX OFDM symbol count value</comment>
      </bits>
      <bits name="rRX_SF_CNT" pos="31:28" access="rw" rst="0">
        <comment>RX subframe count value</comment>
      </bits>
    </reg32>
    <reg32 name="rSLEEP_ELAPSED_CNT" protect="ro">
      <bits name="rSLEEP_ELAPSED_SUBSAMPLE_CNT" pos="9:0" access="ro" rst="0">
        <comment>Sleep Elapsed Subsample counter
Range: 0-511</comment>
      </bits>
      <bits name="rSLEEP_ELAPSED_SAMPLE_CNT" pos="26:16" access="ro" rst="0">
        <comment>Sleep Elapsed Subsample counter
Range: 0-1919</comment>
      </bits>
    </reg32>
    <reg32 name="rSLEEP_ELAPSED_SF_CNT" protect="ro">
      <bits name="rSLEEP_ELAPSED_SF_CNT" pos="31:0" access="ro" rst="0">
        <comment>Sleep Elapsed SF counter
Range: 0-2^32-1</comment>
      </bits>
    </reg32>
    <reg32 name="rR_GLB_CNT" protect="rw">
      <bits name="rR_GLB_SAMPLE_CNT" pos="10:0" access="ro" rst="0">
        <comment>Read global counter sample position</comment>
      </bits>
      <bits name="rR_GLB_SF_CNT" pos="14:11" access="ro" rst="0">
        <comment>Read global counter subframe position </comment>
      </bits>
      <bits name="rR_GLB_RF_CNT" pos="21:15" access="ro" rst="0">
        <comment>Read global counter radio frame position </comment>
      </bits>
    </reg32>
    <reg32 name="rTX_START_GLB_CNT" protect="rw">
      <bits name="rTX_START_GLB_SUB_SAMPLE_CNT" pos="4:0" access="ro" rst="0">
        <comment>global subsample count value at TX transmission start 0-31 LSB[4:0]</comment>
      </bits>
      <bits name="rTX_START_GLB_SAMPLE_CNT" pos="15:5" access="ro" rst="0">
        <comment>global sample count value at TX transmission start </comment>
      </bits>
      <bits name="rTX_START_GLB_SF_CNT" pos="19:16" access="ro" rst="0">
        <comment>global subframe count value at TX transmission start </comment>
      </bits>
      <bits name="rTX_START_GLB_RF_CNT" pos="19:16" access="ro" rst="0">
        <comment>global radio frame count value at TX transmission start </comment>
      </bits>
      <bits name="rTX_START_GLB_SUB_SAMPLE_CNT_MSB" pos="31:28" access="ro" rst="0">
        <comment>global subsample count value at TX transmission start MSB bit[8:5](Not abailable in NB mode)</comment>
      </bits>
    </reg32>
    <hole size="25*32" />
    <reg32 name="rTCU_EVENT_TRIG" protect="rw">
      <bits name="rTCU_EVENT_SAMPLE_TIME" pos="15:5" access="rw" rst="0">
        <comment>TCU event subsample time</comment>
      </bits>
      <bits name="rTCU_EVENT_SF_TIME" pos="19:16" access="rw" rst="0">
        <comment>TCU event subframe time</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_SYNC_MODE" protect="rw">
      <bits name="rRX_SYNC_MODE" pos="1:0" access="rw" rst="0">
        <comment>RX synchronization method mode
0: normal mode
1: sync counter will synchronize with input i_rx_sync_start pulse in DUMP mode only (For testing only)
2: sync counter will synchronize first ca_rx data valid signal in DUMP mode only (For testing only)
3: sync counter will synchronize first rx data valid signal in DUMP mode only (For testing only)
</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_SYNC_INIT_1" protect="rw">
      <bits name="rRX_SF_SYNC_INIT_1" pos="3:0" access="rw" rst="0x9">
        <comment>RX subframe count sync initialization value - 1</comment>
      </bits>
      <bits name="rGLB_SF_SYNC_INIT_1" pos="11:8" access="rw" rst="0x9">
        <comment>Global subframe count sync initialization value - 1</comment>
      </bits>
      <bits name="rGLB_RF_SYNC_INIT_1" pos="18:12" access="rw" rst="0x7">
        <comment>Global radio frame count sync initialization value - 1</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_CAPTURE_EVENT_TRIG" protect="rw">
      <bits name="rRX_CAPTURE_SAMPLE_TIME" pos="15:5" access="rw" rst="0">
        <comment>RX Capture event sample time</comment>
      </bits>
      <bits name="rRX_CAPTURE_SF_TIME" pos="19:16" access="rw" rst="0">
        <comment>RX Capture event subframe time</comment>
      </bits>
    </reg32>
    <hole size="60*32" />
    <reg32 name="rDSP_MEM0_CTRL" protect="rw">
      <bits name="rDSP_MEM0_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 0 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM0_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 0 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM1_CTRL" protect="rw">
      <bits name="rDSP_MEM1_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 1 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM1_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 1 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM2_CTRL" protect="rw">
      <bits name="rDSP_MEM2_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 2 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM2_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 2 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM3_CTRL" protect="rw">
      <bits name="rDSP_MEM3_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 3 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM3_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 3 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM4_CTRL" protect="rw">
      <bits name="rDSP_MEM4_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 4 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM4_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 4 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM5_CTRL" protect="rw">
      <bits name="rDSP_MEM5_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 5 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM5_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 5 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <hole size="1*32" />
    <reg32 name="rDSP_MEM7_CTRL" protect="rw">
      <bits name="rDSP_MEM7_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 7 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM7_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 7 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM8_CTRL" protect="rw">
      <bits name="rDSP_MEM8_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 8 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM8_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 8 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_ctrl.xml">
  <module name="nb_ctrl" category="NBIOT_PHY">
    <reg32 name="rNBIOT_SW_RST" protect="w">
      <bits name="rRX_FFT_SW_RST" pos="0" access="w" rst="0">
        <comment>RX FFT sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rRX_PSS_SW_RST" pos="1" access="w" rst="0">
        <comment>RX Cell Search PSS sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rRX_SSS_SW_RST" pos="2" access="w" rst="0">
        <comment>RX Cell Search SSS sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rRX_CFO_SW_RST" pos="3" access="w" rst="0">
        <comment>RX CFO sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rRX_VIT_SW_RST" pos="4" access="w" rst="0">
        <comment>RX Viterbi sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rRX_AGC_SW_RST" pos="5" access="w" rst="0">
        <comment>RX AGC sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rDS_BSEL_SW_RST" pos="6" access="w" rst="0">
        <comment>RX DS_BSEL sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rTX_FRONTEND_SW_RST" pos="7" access="w" rst="0">
        <comment>TX frontend sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rPUSCH_ENC_SW_RST" pos="8" access="w" rst="0">
        <comment>PUSCH encoder sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rTX_CHSC_SW_RST" pos="9" access="w" rst="0">
        <comment>TX CHSC sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rFFT_512_SW_RST" pos="10" access="w" rst="0">
        <comment>FFT 512 sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rNPRS_ACC1_SW_RST" pos="11" access="w" rst="0">
        <comment>NPRS acc1 sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rFINE_IFFT_SW_RST" pos="12" access="w" rst="0">
        <comment>FINE_IFFT sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rNBIOT_SW_RST" pos="13" access="w" rst="0">
        <comment>rNBIOT general part reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rNBIOT_SW_RST_RSRP" pos="14" access="w" rst="0">
        <comment>RX RSRP sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rCA_RX_DUMP_SW_RST" pos="15" access="w" rst="0">
        <comment>CA RX dump sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rCA_TX_DUMP_SW_RST" pos="16" access="w" rst="0">
        <comment>CA TX dump sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rNB_ACC_SW_RST" pos="19" access="w" rst="0">
        <comment>NB ACC sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rS16PEAK_SW_RST" pos="21" access="w" rst="0">
        <comment>S16Peak sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rSP_SW_RST" pos="22" access="w" rst="0">
        <comment>SP sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rMDD_SW_RST" pos="23" access="w" rst="0">
        <comment>S16Peak sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rLOCSEQ_SW_RST" pos="24" access="w" rst="0">
        <comment>S16Peak sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_CLK_EN" protect="rw">
      <bits name="rRX_FFT_CLK_EN" pos="0" access="rw" rst="0">
        <comment>Enable/disable the clock for RX FFT/RSRP module 
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rRX_PSS_CLK_EN" pos="1" access="rw" rst="0">
        <comment>Enable/disable the clock for RX Cell Search module PSS
0: clock disabled
1: clock enabled.
</comment>
      </bits>
      <bits name="rRX_SSS_CLK_EN" pos="2" access="rw" rst="0">
        <comment>Enable/disable the clock for RX Cell Search module SSS
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rRX_CFO_CLK_EN" pos="3" access="rw" rst="0">
        <comment>Enable/disable the clock for RX CFO module 
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rRX_VIT_CLK_EN" pos="4" access="rw" rst="0">
        <comment>Enable/disable the clock for RX Viterbi module 
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rRX_AGC_CLK_EN" pos="5" access="rw" rst="0">
        <comment>Enable/disable the clock for RX AGC module 
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rDS_BSEL_CLK_EN" pos="6" access="rw" rst="0">
        <comment>Enable/disable the clock for DS_BSEL module 
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rTX_FRONTEND_CLK_EN" pos="7" access="rw" rst="0">
        <comment>Enable/disable the clock for TX Frontend module.
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rPUSCH_ENC_CLK_EN" pos="8" access="rw" rst="0">
        <comment>Enable/disable the clock for PUSCH encoder module.
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rTX_CHSC_CLK_EN" pos="9" access="rw" rst="0">
        <comment>Enable/disable the clock for TX TX channel-interleaver and scrambling module.
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rFFT_512_CLK_EN" pos="10" access="rw" rst="0">
        <comment>Enable/disable the clock for FFT 512 module.
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rNPRS_ACC1_CLK_EN" pos="11" access="rw" rst="0">
        <comment>Enable/disable the clock for NPRS ACC1 module.
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rFINE_FFT_CLK_EN" pos="12" access="rw" rst="0">
        <comment>Enable/disable the clock for FINE ifft module
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rNBIOT_CLK_EN" pos="13" access="rw" rst="0">
        <comment>Enable/disable the clock for NBIOT module
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rCA_RX_DUMP_EN" pos="14" access="rw" rst="0">
        <comment>Enable/disable the clock for CA Rx Dump module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rCA_TX_DUMP_EN" pos="15" access="rw" rst="0">
        <comment>Enable/disable the clock for CA Tx Dump module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rNB_ACC_EN" pos="18" access="rw" rst="0">
        <comment>Enable/disable the clock for NBIOT module
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rS16PEAK_EN" pos="20" access="rw" rst="0">
        <comment>Enable/disable the clock for Search_16peak module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rSP_EN" pos="21" access="rw" rst="0">
        <comment>Enable/disable the clock for SP module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rTX_MDD_EN" pos="22" access="rw" rst="0">
        <comment>Enable/disable the clock for Tx MDD module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rLOCSEQ_EN" pos="23" access="rw" rst="0">
        <comment>Enable/disable the clock for LOCSEQ module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rTX_REG_EN" pos="29" access="rw" rst="0">
        <comment>Enable/disable the clock for TX_REG module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rRX_REG_EN" pos="30" access="rw" rst="0">
        <comment>Enable/disable the clock for RX_REG module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rCS_REG_EN" pos="31" access="rw" rst="0">
        <comment>Enable/disable the clock for CS_REG module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_MONITOR" protect="rw">
      <bits name="rNBIOT_MONITOR_SEL" pos="8:0" access="rw" rst="0">
        <comment>Debug signal selection</comment>
      </bits>
      <bits name="rNBIOT_MONITOR_EN" pos="9" access="rw" rst="0">
        <comment>Debug signal output enable</comment>
      </bits>
      <bits name="Reserved" pos="31:10" access="rw" rst="0">
        <comment>Reserved for debug only</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_RFIN_SW_RST" protect="w">
      <bits name="rNBIOT_RFIN_SW_RST" pos="0" access="w" rst="0">
        <comment>RFIN reset by DSP, it is used to re-timing the global timer to balance the timing of IQ data input from DFE in sample boundary. Write 1 and auto-clear by HW.
0: default value
1: reset to re-timing the sample boundary in global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_RFIN_STATUS" protect="r">
      <bits name="rNBIOT_RFIN_SUBSMAPLE_CNT" pos="16:8" access="r" rst="0">
        <comment>Sample the glb_subsample_cnt with input rx_data_vld to check the phase change of the input</comment>
      </bits>
      <bits name="rNBIOT_RFIN_STATUS_ERR" pos="0" access="r" rst="0">
        <comment>Keep track the RFIN data strobe in valid window.
0: Normal
1: Error</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_COARSE_CLK_GATING" protect="rw">
      <bits name="rPSS_COS_CLK_GATING" pos="1" access="rw" rst="1">
        <comment>PSS Correlator coarse clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module PSS Correlator.</comment>
      </bits>
      <bits name="rSSS_COS_CLK_GATING" pos="2" access="rw" rst="1">
        <comment>SSS Correlator coarse clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module SSS Correlator.</comment>
      </bits>
      <bits name="Reserved" pos="12:3" access="rw" rst="3ff">
        <comment></comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_FINE_CLK_GATING" protect="rw">
      <bits name="rFFT_RSRP_FT_CLK_GATING" pos="0" access="rw" rst="1">
        <comment>FFT_RSRP fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module FFT_RSRP.
</comment>
      </bits>
      <bits name="rPSS_FT_CLK_GATING" pos="1" access="rw" rst="1">
        <comment>PSS Correlator fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module PSS Correlator.</comment>
      </bits>
      <bits name="rSSS_FT_CLK_GATING" pos="2" access="rw" rst="1">
        <comment>SSS Correlator fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module SSS Correlator.</comment>
      </bits>
      <bits name="rCFO_FT_CLK_GATING" pos="3" access="rw" rst="1">
        <comment>CFO Correlator fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module CFO Correlator.</comment>
      </bits>
      <bits name="rVIT_FT_CLK_GATING" pos="4" access="rw" rst="1">
        <comment>Viterbi fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module Viterbi.</comment>
      </bits>
      <bits name="rAGC_FT_CLK_GATING" pos="5" access="rw" rst="1">
        <comment>AGC fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module AGC.</comment>
      </bits>
      <bits name="rDS_BSEL_FT_CLK_GATING" pos="6" access="rw" rst="1">
        <comment>DS_BSEL fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module DS_BSEL.
</comment>
      </bits>
      <bits name="rTX_FRONTEND_FT_CLK_GATING" pos="7" access="rw" rst="1">
        <comment>TX_FRONTEND fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module TX_FRONTEND.
</comment>
      </bits>
      <bits name="rPUSCH_ENC_CLK_GATING" pos="8" access="rw" rst="1">
        <comment>PUSCH_ENC fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module PUSCH_ENC.</comment>
      </bits>
      <bits name="rTX_CHSC_CLK_GATING" pos="9" access="rw" rst="1">
        <comment>TX_CHSC fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module TX_CHSC.</comment>
      </bits>
      <bits name="rFFT_512_CLK_GATING" pos="10" access="rw" rst="1">
        <comment>FFT 512 fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module FFT 512.</comment>
      </bits>
      <bits name="rNPRS_ACC1_CLK_GATING" pos="11" access="rw" rst="1">
        <comment>NPRS ACC1 fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module NPRS ACC1.</comment>
      </bits>
      <bits name="rFINE_IFFT_CLK_GATING" pos="12" access="rw" rst="1">
        <comment>FIne IFFT fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module FINE_IFFT.</comment>
      </bits>
      <bits name="rRSRP_CLK_GATING" pos="13" access="rw" rst="1">
        <comment>RSRP fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module FFT_RSRP
</comment>
      </bits>
      <bits name="rCA_RX_DUMP_CLK_GATING" pos="14" access="rw" rst="1">
        <comment>CA RX dump fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module CA RX dump
</comment>
      </bits>
      <bits name="rCA_TX_DUMP_CLK_GATING" pos="15" access="rw" rst="1">
        <comment>CA TX dump fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module CA TX dump
</comment>
      </bits>
      <bits name="rMCA_FFT128_CLK_GATING" pos="16" access="rw" rst="1">
        <comment>MCA FFT128 dump fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module Multi CA FFT 128
</comment>
      </bits>
      <bits name="rMCA_IFFT128_CLK_GATING" pos="17" access="rw" rst="1">
        <comment>MCA IFFT128 dump fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module Multi CA IFFT 128
</comment>
      </bits>
      <bits name="rNB_ACC_CLK_GATING" pos="18" access="rw" rst="1">
        <comment>NB ACC fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module NB ACC
</comment>
      </bits>
      <bits name="rS16PEAK_CLK_GATING" pos="20" access="rw" rst="1">
        <comment>Search16peak fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module Search16peak
</comment>
      </bits>
      <bits name="rSP_CLK_GATING" pos="21" access="rw" rst="1">
        <comment>SP fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module SP
</comment>
      </bits>
      <bits name="rNB_MATRIX_CLK_GATING" pos="22" access="rw" rst="1">
        <comment>NB matrix fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module NB matrix
</comment>
      </bits>
      <bits name="rTX_MDD_CLK_GATING" pos="23" access="rw" rst="1">
        <comment>TX MDD fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module TX MDD
</comment>
      </bits>
      <bits name="rLOCSEQ_CLK_GATING" pos="24" access="rw" rst="1">
        <comment>LOCSEQ fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module LOCSEQ
</comment>
      </bits>
      <bits name="rSS_CLK_GATING" pos="25" access="rw" rst="1">
        <comment>SS fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module SS
</comment>
      </bits>
    </reg32>
    <reg32 name="rAPB_SW_RST" protect="w">
      <bits name="rAPB_SW_RST" pos="0" access="w" rst="0">
        <comment>NBIOT CORE APB domain reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_DEBUG_GPO" protect="rw">
      <bits name="rNBIOT_DEBUF_GPO" pos="3:0" access="rw" rst="0">
        <comment>Debug General Purpose Output 
Remark: need to set rNBIOT_MONITOR to 0x1a3</comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="rNBIOT_RX_ICTRL" protect="rw">
      <bits name="rNBIOT_RX_ICTRL" pos="9:0" access="rw" rst="0">
        <comment>RX data input control: Please refer to diagram below in detail
CA RX input data right shift control
bit 9-7:
0: No left shift
1: Right shift 1 bit
2: Right shift 2 bit
3: Right shift 3 bit
4: Right shift 4 bit
5~7: Reserved
bit 6-3: Reserved
bit 2:
Select the source to CA RX dump CA data 0
0: CA RX source input stage 0
1: DFE RX input
bit 1:
Select the CA RX source input stage 0 data path
0: LVDS CA RX input
1: NB CA TX output
bit 0:
Select the source to RX input data stream path
0: DFE RX input 
1: LVDS CA RX input
</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_TX_OCTRL" protect="rw">
      <bits name="rNBIOT_TX_OCTRL" pos="1:0" access="rw" rst="0">
        <comment>TX data output control: Please refer to diagram below in detail:
bit 1:
Select the source to LVDSTX data path
0: CA TX dump CA Tx data 0 output 
1: TX frontend output
bit 0:
Select the source to DFE TX data path
0: TX frontend output
1: CA TX dump CA Tx data 0 output
</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_CA_STATUS" protect="w1c">
      <bits name="rNBIOT_CA_STATUS" pos="0" access="w1c" rst="0">
        <comment>CA data valid status (Write 1 clear status)
0: no CA data valid occur
1: CA data valid occur
</comment>
      </bits>
    </reg32>    
    <hole size="51*32"></hole>
    <reg32 name="rNBIOT_REVISION" protect="r">
      <bits name="rMINOR_REV" pos="7:0" access="r" rst="0">
        <comment>Minor Revision</comment>
      </bits>
      <bits name="rMAJOR_REV" pos="15:8" access="r" rst="0">
        <comment>MAJOR Revision</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_ds_bsel.xml">
  <module name="nb_ds_bsel" category="NBIOT_PHY">
    <reg32 name="rDS_BSEL_START" protect="w1c">
      <bits name="rDS_BSEL_START" pos="0" access="w1c" rst="0x0">
        <comment>DS_BSEL accelerator start</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_BSEL_CTRL" protect="rw">
      <bits name="rTIMEOUT_VAL" pos="15:0" access="rw" rst="0x7fff">
        <comment>Maximum time out value for TX bit level processing in 61.44Mhz unit</comment>
      </bits>
      <bits name="rNUM_CANDIDATE" pos="17:16" access="rw" rst="0">
        <comment>Number of Candidate
0: 1 candidate
1: 2 candidate
2: 3 candidate
3: 4 candidate</comment>
      </bits>
      <bits name="rDBSP_EN" pos="18" access="rw" rst="0">
        <comment>Bit de-selection and combining
0: Disable
1: enable
Remark: When this bit is disabled, the output data number is equal to rDESCR_SIZE0 and it only support 1 candidate.</comment>
      </bits>
      <bits name="rDESCR_EN" pos="19" access="rw" rst="0">
        <comment>Descramble enable
0: Disable
1: enable</comment>
      </bits>
      <bits name="rNCB_MINUS_SIZE" pos="27:20" access="rw" rst="0">
        <comment>NCB minus:  NCB - 3ND</comment>
      </bits>
      <bits name="rDS_BSEL_START_CTRL" pos="30" access="rw" rst="0">
        <comment>Start control
0:Trigger by SW start
1:Trigger by HW start by SP done signal</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X1_0" protect="rw">
      <bits name="rDS_X1_0" pos="30:0" access="rw" rst="0">
        <comment>Descramble X1 value for candidate 0</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X1_1" protect="rw">
      <bits name="rDS_X1_1" pos="30:0" access="rw" rst="0">
        <comment>Descramble X1 value for candidate 1</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X1_2" protect="rw">
      <bits name="rDS_X1_2" pos="30:0" access="rw" rst="0">
        <comment>Descramble X1 value for candidate 2</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X1_3" protect="rw">
      <bits name="rDS_X1_3" pos="30:0" access="rw" rst="0x40">
        <comment>Descramble X1 value for candidate 3</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X2_0" protect="rw">
      <bits name="rDS_X2_0" pos="30:0" access="rw" rst="0">
        <comment>Descramble X2 value for candidate 0</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X2_1" protect="rw">
      <bits name="rDS_X2_1" pos="30:0" access="rw" rst="0">
        <comment>Descramble X2 value for candidate 1</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X2_2" protect="rw">
      <bits name="rDS_X2_2" pos="30:0" access="rw" rst="0">
        <comment>Descramble X2 value for candidate 2</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X2_3" protect="rw">
      <bits name="rDS_X2_3" pos="30:0" access="rw" rst="0x40">
        <comment>Descramble X2 value for candidate 3</comment>
      </bits>
    </reg32>
    <reg32 name="rDESCR_CFG1" protect="rw">
      <bits name="rIDATA_SIZE0" pos="8:0" access="rw" rst="0">
        <comment>Descramble size 0</comment>
      </bits>
      <bits name="rIDATA_SIZE1" pos="24:16" access="rw" rst="0">
        <comment>Descramble size 1</comment>
      </bits>
    </reg32>
    <reg32 name="rDESCR_CFG2" protect="rw">
      <bits name="rIDATA_SIZE3" pos="8:0" access="rw" rst="0">
        <comment>Descramble size 3</comment>
      </bits>
      <bits name="rIDATA_SIZE2" pos="24:16" access="rw" rst="0">
        <comment>Descramble size 2</comment>
      </bits>
    </reg32>
    <reg32 name="rDESCR_CFG3" protect="rw">
      <bits name="rDATA_IBUF_START_ADDR_0" pos="9:0" access="rw" rst="0">
        <comment>Descramble input buffer start address 0</comment>
      </bits>
      <bits name="rDATA_IBUF_START_ADDR_1" pos="25:16" access="rw" rst="0">
        <comment>Descramble input buffer start address 1</comment>
      </bits>
    </reg32>
    <reg32 name="rDESCR_CFG4" protect="rw">
      <bits name="rDATA_IBUF_START_ADDR_3" pos="9:0" access="rw" rst="0">
        <comment>Descramble input buffer start address 3</comment>
      </bits>
      <bits name="rDATA_IBUF_START_ADDR_2" pos="25:16" access="rw" rst="0">
        <comment>Descramble input buffer start address 4</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_BSEL_OMEM_START_ADDR" protect="rw">
      <bits name="rDS_BSEL_OMEM_START_SADDR" pos="25:16" access="rw" rst="0">
        <comment>DS_BSEL output memory start address for last X1/X2 state value</comment>
      </bits>
      <bits name="rDS_BSEL_OMEM_START_ADDR" pos="9:0" access="rw" rst="0">
        <comment>DS_BSEL output memory start address</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_BSEL_DS_X1" protect="r">
      <bits name="rDS_BSEL_DS_X1" pos="30:0" access="r" rst="0">
        <comment>The last candidate Descramble X2 state value</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_BSEL_DS_X2" protect="r">
      <bits name="rDS_BSEL_DS_X2" pos="30:0" access="r" rst="0">
        <comment>The last candidate Descramble X2 state value</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_BSEL_STATUS" protect="r">
      <bits name="rDone" pos="0" access="wc" rst="0">
        <comment>(This bit is write 1 clear)
0: No Done
1: Done</comment>
      </bits>
      <bits name="rOverwritten" pos="1" access="r" rst="0">
        <comment>If Done bit would not clear before this engine re-engine would indicate overwritten output buffer
0: Normal
1: Error</comment>
      </bits>
      <bits name="rBUS_Error" pos="3:2" access="r" rst="0">
        <comment>0: Normal
1: Error
Bit 0: DSP control bus error
Bit 1: accelerator memory access collusion</comment>
      </bits>
      <bits name="rTimeout" pos="4" access="r" rst="0">
        <comment>0: Normal
1: Error</comment>
      </bits>
      <bits name="rStatus" pos="5" access="r" rst="0">
        <comment>0: Idle
1: On-going</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_fft_rsrp.xml">
  <module name="nb_fft_rsrp" category="NBIOT_PHY">
    <reg32 name="rFFT_CTRL" protect="rw">
      <bits name="rFFT_EN" pos="0" access="rw" rst="0x0">
        <comment>FFT calculation enable</comment>
      </bits>
      <bits name="rFFT_DONE_INT_PERIOD" pos="1" access="rw" rst="0x0">
        <comment>the period of FFT done interrupt, 0: one time per-subframe; 1: twice per-subframe.</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_RSRP_CFG" protect="rw">
      <bits name="rFFT_RSRP_EN" pos="0:0" access="rw" rst="0x0">
        <comment>FFT/RSRP enable</comment>
      </bits>
      <bits name="rSCALING_ALPHA" pos="3:1" access="rw" rst="0x3">
        <comment>FFT result scaling</comment>
      </bits>
      <bits name="rFFT_RSRP_MODE" pos="4" access="rw" rst="0x0">
        <comment>0: FFT disabled, 5 RSRP CELLs calculation mode; 1:  FFT + 2 RSRP Cell calculation mode.</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_OFDM_CP_OS" protect="rw">
      <bits name="rFFT_OFDM_CP_OS" pos="3:0" access="rw" rst="0x0">
        <comment>FFT OFDM symbol CP offset</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL_EN" protect="rw">
      <bits name="rRSRP_CELL0_EN" pos="0" access="rw" rst="0">
        <comment>RSRP Cell0 Enabled.</comment>
      </bits>
      <bits name="rRSRP_CELL1_EN" pos="1" access="rw" rst="0">
        <comment>RSRP Cell1 Enabled.</comment>
      </bits>
      <bits name="rRSRP_CELL2_EN" pos="2" access="rw" rst="0">
        <comment>RSRP Cell2 Enabled.</comment>
      </bits>
      <bits name="rRSRP_CELL3_EN" pos="3" access="rw" rst="0">
        <comment>RSRP Cell3 Enabled.</comment>
      </bits>
      <bits name="rRSRP_CELL4_EN" pos="4" access="rw" rst="0">
        <comment>RSRP Cell4 Enabled.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL0_START_POS" protect="rw">
      <bits name="rRSRP_CELL0_START_POS" pos="14:0" access="rw" rst="0">
        <comment>Frame start position of RSRP Cell0 based on global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL1_START_POS" protect="rw">
      <bits name="rRSRP_CELL1_START_POS" pos="14:0" access="rw" rst="0">
        <comment>Frame start position of RSRP Cell1 based on global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL2_START_POS" protect="rw">
      <bits name="rRSRP_CELL2_START_POS" pos="14:0" access="rw" rst="0">
        <comment>Frame start position of RSRP Cell2 based on global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL3_START_POS" protect="rw">
      <bits name="rRSRP_CELL3_START_POS" pos="14:0" access="rw" rst="0">
        <comment>Frame start position of RSRP Cell3 based on global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL4_START_POS" protect="rw">
      <bits name="rRSRP_CELL4_START_POS" pos="14:0" access="rw" rst="0">
        <comment>Frame start position of RSRP Cell4 based on global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rCELL0_OFDM_CP_OS" protect="rw">
      <bits name="rCELL0_OFDM_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset for NCELL0.</comment>
      </bits>
    </reg32>
    <reg32 name="rCELL1_OFDM_CP_OS" protect="rw">
      <bits name="rCELL1_OFDM_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset for NCELL1.</comment>
      </bits>
    </reg32>
    <reg32 name="rCELL2_OFDM_CP_OS" protect="rw">
      <bits name="rCELL2_OFDM_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset for NCELL2.</comment>
      </bits>
    </reg32>
    <reg32 name="rCELL3_OFDM_CP_OS" protect="rw">
      <bits name="rCELL3_OFDM_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset for NCELL3.</comment>
      </bits>
    </reg32>
    <reg32 name="rCELL4_OFDM_CP_OS" protect="rw">
      <bits name="rCELL4_OFDM_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset for NCELL4.</comment>
      </bits>
    </reg32>
    <reg32 name="rNCELL_V_SHIFT" protect="rw">
      <bits name="rNCELL0_V_SHIFT" pos="2:0" access="rw" rst="0">
        <comment>vshift of NCELL0.</comment>
      </bits>
      <bits name="rNCELL1_V_SHIFT" pos="5:3" access="rw" rst="0">
        <comment>vshift of NCELL1.</comment>
      </bits>
      <bits name="rNCELL2_V_SHIFT" pos="8:6" access="rw" rst="0">
        <comment>vshift of NCELL2.</comment>
      </bits>
      <bits name="rNCELL3_V_SHIFT" pos="11:9" access="rw" rst="0">
        <comment>vshift of NCELL3.</comment>
      </bits>
      <bits name="rNCELL4_V_SHIFT" pos="14:12" access="rw" rst="0">
        <comment>vshift of NCELL4.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_SUBF_IDX" protect="rw">
      <bits name="rNCELL0_CFG_SUBF_IDX" pos="3:0" access="rw" rst="0">
        <comment>confiugred subframe idx when RSRX cell enabled.</comment>
      </bits>
      <bits name="rNCELL1_CFG_SUBF_IDX" pos="7:4" access="rw" rst="0">
        <comment>confiugred subframe idx when RSRX cell enabled.</comment>
      </bits>
      <bits name="rNCELL2_CFG_SUBF_IDX" pos="11:8" access="rw" rst="0">
        <comment>confiugred subframe idx when RSRX cell enabled.</comment>
      </bits>
      <bits name="rNCELL3_CFG_SUBF_IDX" pos="15:12" access="rw" rst="0">
        <comment>confiugred subframe idx when RSRX cell enabled.</comment>
      </bits>
      <bits name="rNCELL4_CFG_SUBF_IDX" pos="19:16" access="rw" rst="0">
        <comment>confiugred subframe idx when RSRX cell enabled.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_MEM_BADDR" protect="rw">
      <bits name="rRSRP_MEM_BADDR" pos="8:0" access="rw" rst="0">
        <comment>Offset address for RSRP write memory buffer.</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_RSRP_STATUS" protect="r">
      <bits name="RESERVED" pos="0" access="rw" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rFFT_BUF_STATUS" pos="2:1" access="w1c" rst="0">
        <comment>Indicated whether the data in ping-pong buffer is updated.</comment>
      </bits>
      <bits name="rFFT_BUF_SWITCH_STATUS" pos="3" access="r" rst="0">
        <comment>FFT buffer ping-pong flag</comment>
      </bits>
      <bits name="rNCELL0_TRIPLE_BUF_STATUS" pos="6:4" access="w1c" rst="0">
        <comment>Indicated which triple buffer is UPDATED</comment>
      </bits>
      <bits name="rNCELL0_TRIPLE_BUF_SWITCH_FLAG" pos="8:7" access="r" rst="3">
        <comment>Indicated which buffer is just updated when interrupt asserted.</comment>
      </bits>
      <bits name="rNCELL1_TRIPLE_BUF_STATUS" pos="11:9" access="w1c" rst="0">
        <comment>Indicated which triple buffer is UPDATED</comment>
      </bits>
      <bits name="rNCELL1_TRIPLE_BUF_SWITCH_FLAG" pos="13:12" access="r" rst="3">
        <comment>Indicated which buffer is just updated when interrupt asserted.</comment>
      </bits>
      <bits name="rNCELL2_TRIPLE_BUF_STATUS" pos="16:14" access="w1c" rst="0">
        <comment>Indicated which triple buffer is UPDATED</comment>
      </bits>
      <bits name="rNCELL2_TRIPLE_BUF_SWITCH_FLAG" pos="18:17" access="r" rst="3">
        <comment>Indicated which buffer is just updated when interrupt asserted.</comment>
      </bits>
      <bits name="rNCELL3_TRIPLE_BUF_STATUS" pos="21:19" access="w1c" rst="0">
        <comment>Indicated which triple buffer is UPDATED</comment>
      </bits>
      <bits name="rNCELL3_TRIPLE_BUF_SWITCH_FLAG" pos="23:22" access="r" rst="3">
        <comment>Indicated which buffer is just updated when interrupt asserted.</comment>
      </bits>
      <bits name="rNCELL4_TRIPLE_BUF_STATUS" pos="26:24" access="w1c" rst="0">
        <comment>Indicated which triple buffer is UPDATED</comment>
      </bits>
      <bits name="rNCELL4_TRIPLE_BUF_SWITCH_FLAG" pos="28:27" access="r" rst="3">
        <comment>Indicated which buffer is just updated when interrupt asserted.</comment>
      </bits>
    </reg32>
    <reg32 name="rSV_CELL_SUBF_IDX" protect="r">
      <bits name="rSV_CELL_SUBF_IDX" pos="3:0" access="r" rst="0">
        <comment>subframe index of serving cell</comment>
      </bits>
    </reg32>
    <reg32 name="rNCELL_SUBF_IDX" protect="r">
      <bits name="rNCELL0_SUBF_IDX" pos="3:0" access="r" rst="0">
        <comment>subframe idx of NCELL0</comment>
      </bits>
      <bits name="rNCELL1_SUBF_IDX" pos="7:4" access="r" rst="0">
        <comment>subframe idx of NCELL1</comment>
      </bits>
      <bits name="rNCELL2_SUBF_IDX" pos="11:8" access="r" rst="0">
        <comment>subframe idx of NCELL2</comment>
      </bits>
      <bits name="rNCELL3_SUBF_IDX" pos="15:12" access="r" rst="0">
        <comment>subframe idx of NCELL3</comment>
      </bits>
      <bits name="rNCELL4_SUBF_IDX" pos="19:16" access="r" rst="0">
        <comment>subframe idx of NCELL4</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_RSRP_BUF_OVWR" protect="r">
      <bits name="rFFT_BUF_OVWR" pos="1:0" access="r" rst="0">
        <comment>FFT pingpong buffer overwritten status</comment>
      </bits>
      <bits name="rRSRP_CELL0_BUF_OVWR" pos="4:2" access="r" rst="0">
        <comment>RSRP Cell0 triple buffer over-written status.</comment>
      </bits>
      <bits name="rRSRP_CELL1_BUF_OVWR" pos="7:5" access="r" rst="0">
        <comment>RSRP Cell1 triple buffer over-written status.</comment>
      </bits>
      <bits name="rRSRP_CELL2_BUF_OVWR" pos="10:8" access="r" rst="0">
        <comment>RSRP Cell2 triple buffer over-written status.</comment>
      </bits>
      <bits name="rRSRP_CELL3_BUF_OVWR" pos="13:11" access="r" rst="0">
        <comment>RSRP Cell3 triple buffer over-written status.</comment>
      </bits>
      <bits name="rRSRP_CELL4_BUF_OVWR" pos="16:14" access="r" rst="0">
        <comment>RSRP Cell4 triple buffer over-written status.</comment>
      </bits>
      <bits name="rFFT_MEM_WR_ERR" pos="18:17" access="r" rst="0">
        <comment>FFT write buffer bus error</comment>
      </bits>
      <bits name="rRSRP0_MEM_WR_ERR" pos="20:19" access="r" rst="0">
        <comment>RSRP CELL0 write buffer bus error</comment>
      </bits>
      <bits name="rRSRP1_MEM_WR_ERR" pos="22:21" access="r" rst="0">
        <comment>RSRP CELL1 write buffer bus error</comment>
      </bits>
      <bits name="rRSRP2_MEM_WR_ERR" pos="24:23" access="r" rst="0">
        <comment>RSRP CELL2 write buffer bus error</comment>
      </bits>
      <bits name="rRSRP3_MEM_WR_ERR" pos="26:25" access="r" rst="0">
        <comment>RSRP CELL3 write buffer bus error</comment>
      </bits>
      <bits name="rRSRP4_MEM_WR_ERR" pos="28:27" access="r" rst="0">
        <comment>RSRP CELL4 write buffer bus error</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_RSRP_BUF_IDX" protect="r">
      <bits name="rFFT_PINGPONG_BUF_IDX" pos="0" access="r" rst="0">
        <comment>FFT pingpong buf idx</comment>
      </bits>
      <bits name="rRSRP0_TRI_BUF_IDX" pos="2:1" access="r" rst="0">
        <comment>RSRP0 Triple buffer idx</comment>
      </bits>
      <bits name="rRSRP1_TRI_BUF_IDX" pos="4:3" access="r" rst="0">
        <comment>RSRP1 Triple buffer idx</comment>
      </bits>
      <bits name="rRSRP2_TRI_BUF_IDX" pos="6:5" access="r" rst="0">
        <comment>RSRP2 Triple buffer idx</comment>
      </bits>
      <bits name="rRSRP3_TRI_BUF_IDX" pos="8:7" access="r" rst="0">
        <comment>RSRP3 Triple buffer idx</comment>
      </bits>
      <bits name="rRSRP4_TRI_BUF_IDX" pos="10:9" access="r" rst="0">
        <comment>RSRP4 Triple buffer idx</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_RSRP_SUBF_IDX" protect="r">
      <bits name="rFFT_SUBF_IDX" pos="3:0" access="r" rst="0">
        <comment>FFT subframe idx</comment>
      </bits>
      <bits name="rRSRP0_SUBF_IDX" pos="7:4" access="r" rst="0">
        <comment>RSRP Cell0 subframe idx</comment>
      </bits>
      <bits name="rRSRP1_SUBF_IDX" pos="11:8" access="r" rst="0">
        <comment>RSRP Cell1 subframe idx</comment>
      </bits>
      <bits name="rRSRP2_SUBF_IDX" pos="15:12" access="r" rst="0">
        <comment>RSRP Cell2 subframe idx</comment>
      </bits>
      <bits name="rRSRP3_SUBF_IDX" pos="19:16" access="r" rst="0">
        <comment>RSRP Cell3 subframe idx</comment>
      </bits>
      <bits name="rRSRP4_SUBF_IDX" pos="23:20" access="r" rst="0">
        <comment>RSRP Cell4 subframe idx</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_OUT_MASK_VALUE" protect="r">
      <bits name="rFFT_OUT_MASK_VALUE" pos="0:0" access="rw" rst="0">
        <comment>The configurable value for FFT output saturation.
                 1'b0:FFT output is S16:10;make sure the output value range from[0x8001,0x7fff]
                 1'b1:FFT output is S16:9;one bit shift and make sure the output value range from[0xc001,0x3fff]</comment>
      </bits>
      <bits name="rFFT_OUT_MASK_EN" pos="31:31" access="r" rst="0">
        <comment>Enable/Disable to limit the value of FFT result according to rFFT_OUT_MASK_VALUE
                 1'b0:Disable
                 1'b1:Enable(Defalut)</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_intc.xml">
  <module name="nb_intc" category="NBIOT_PHY">
    <reg32 name="rRX_INT_DSP_MASKING" protect="rw">
      <bits name="rRX_INT_DSP_MASKING" pos="0:0" access="rw" rst="0x0">
        <comment>Interrupt Masking bit for RX_INT_DSP</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_MCU_MASKING" protect="rw">
      <bits name="rRX_INT_MCU_MASKING" pos="0:0" access="rw" rst="0x0">
        <comment>Interrupt Masking bit for RX_INT_MCU</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_INT_DSP_MASKING" protect="rw">
      <bits name="rTX_INT_DSP_MASKING" pos="0:0" access="rw" rst="0x0">
        <comment>Interrupt Masking bit for TX_INT_DSP</comment>
      </bits>
    </reg32>
    <reg32 name="rACC_INT_MASKING" protect="rw">
      <bits name="rFFT_DONE_INT_MASKING" pos="0:0" access="rw" rst="0">
        <comment>Interrupt masking bit from the interrupt of fft_done_int</comment>
      </bits>
      <bits name="rNCELL0_RSRP_DEC_DONE_INT_MASKING" pos="1:1" access="rw" rst="0">
        <comment>Interrupt masking bit of NCELL0 decode done intterupt</comment>
      </bits>
      <bits name="rNCELL1_RSRP_DEC_DONE_INT_MASKING" pos="2:2" access="rw" rst="0">
        <comment>Interrupt masking bit of NCELL1 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL2_RSRP_DEC_DONE_INT_MASKING" pos="3:3" access="rw" rst="0">
        <comment>Interrupt masking bit of NCELL2 decode done interrpt</comment>
      </bits>
      <bits name="rNCELL3_RSRP_DEC_DONE_INT_MASKING" pos="4:4" access="rw" rst="0">
        <comment>Interrupt masking bit of NCELL3 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL4_RSRP_DEC_DONE_INT_MASKING" pos="5:5" access="rw" rst="0">
        <comment>Interrupt masking bit of NCELL4 decode done interrupt</comment>
      </bits>
      <bits name="rPSS_SF_DONE_INT_MASKING" pos="6:6" access="rw" rst="0">
        <comment>Interrupt masking bit of PSS SF done interrupt</comment>
      </bits>
      <bits name="rSSS_SF_DONE_INT_MASKING" pos="7:7" access="rw" rst="0">
        <comment>Interrupt masking bit of SSS SF done interrupt</comment>
      </bits>
      <bits name="rCFO_SF_DONE_INT_MASKING" pos="8:8" access="rw" rst="0">
        <comment>Interrupt masking bit of CFO SF done interrupt</comment>
      </bits>
      <bits name="rVIT_DEC_DONE_INT_MASKING" pos="9:9" access="rw" rst="0">
        <comment>Interrupt masking bit of Viterbi decode done interrupt</comment>
      </bits>
      <bits name="rAGC_PWR_INT_MASKING" pos="10:10" access="rw" rst="0">
        <comment>Interrupt masking bit of AGC interrupt masking</comment>
      </bits>
      <bits name="rDS_BSEL_INT_MASKING" pos="11:11" access="rw" rst="0">
        <comment>Interrupt masking bit of DS_BSEL interrupt</comment>
      </bits>
      <bits name="rPUSCH_ENC_INT_MASKING" pos="12:12" access="rw" rst="0">
        <comment>Interrupt masking bit of PUSCH encoder interrupt</comment>
      </bits>
      <bits name="rTX_CHSC_INT_MASKING" pos="13:13" access="rw" rst="0">
        <comment>Interrupt masking bit of TX_CHSC interrupt</comment>
      </bits>
      <bits name="rFFT_512_DONE_INT_MASKING" pos="14:14" access="rw" rst="0">
        <comment>Interrupt masking bit of FFT_512 done interrupt</comment>
      </bits>
      <bits name="rNPRS_ACC1_DONE_INT_MASKING" pos="15:15" access="rw" rst="0">
        <comment>Interrupt masking bit of NPRS_ACC1 done interrupt</comment>
      </bits>
      <bits name="rFINE_IFFT_DONE_INT_MASKING" pos="16:16" access="rw" rst="0">
        <comment>Interrupt masking bit of FINE_IFFT done interrupt</comment>
      </bits>
      <bits name="rCA_RX_DUMP_DONE_INT_MASK" pos="18:18" access="rw" rst="0">
        <comment>Interrupt masking bit of CA RX Dump done interrupt</comment>
      </bits>
      <bits name="rCA_TX_DUMP_DONE_INT_MASK" pos="19:19" access="rw" rst="0">
        <comment>Interrupt masking bit of CA TX dump done interrupt</comment>
      </bits>
      <bits name="rNB_ACC_DONE_INT_MASK" pos="22:22" access="rw" rst="0">
        <comment>Interrupt masking bit of NB ACC done interrupt</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_DSP_STATUS" protect="w1c">
      <bits name="rRX_INT_DSP_STATUS" pos="0" access="w1c" rst="0">
        <comment>interrupt status of RX_INT_DSP, write 1 clear.</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_MCU_STATUS" protect="w1c">
      <bits name="rRX_INT_MCU_STATUS" pos="0:0" access="w1c" rst="0">
        <comment>Interrupt status of RX_INT_MCU, write 1 clear.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_INT_DSP_STATUS" protect="w1c">
      <bits name="rTX_INT_DSP_STATUS" pos="0:0" access="w1c" rst="0">
        <comment>Interrupt status of TX_INT_DSP, write 1 clear.</comment>
      </bits>
    </reg32>
    <reg32 name="rACC_INT_STATUS" protect="w1c">
      <bits name="rFFT_INT_STATUS" pos="0:0" access="w1c" rst="0">
        <comment>Interrupt status of fft_sf_done_int</comment>
      </bits>
      <bits name="rNCELL0_RSRP_DEC_DONE_INT_STATUS" pos="1:1" access="w1c" rst="0">
        <comment>Interrupt status of RSRP Cell0 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL1_RSRP_DEC_DONE_INT_STATUS" pos="2" access="w1c" rst="0">
        <comment>Interrupt status of RSRP Cell1 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL2_RSRP_DEC_DONE_INT_STATUS" pos="3" access="w1c" rst="0">
        <comment>Interrupt status of RSRP Cell20 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL3_RSRP_DEC_DONE_INT_STATUS" pos="4" access="w1c" rst="0">
        <comment>Interrupt status of RSRP Cell3 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL4_RSRP_DEC_DONE_INT_STATUS" pos="5" access="w1c" rst="0">
        <comment>Interrupt status of RSRP Cell4 decode done interrupt</comment>
      </bits>
      <bits name="rPSS_SF_DONE_INT_STATUS" pos="6" access="w1c" rst="0">
        <comment>Interrupt status of PSS SF done interrupt</comment>
      </bits>
      <bits name="rSSS_SF_DONE_INT_STATUS" pos="7" access="w1c" rst="0">
        <comment>Interrupt status of SSS SF done interrupt</comment>
      </bits>
      <bits name="rCFO_SF_DONE_INT_STATUS" pos="8" access="w1c" rst="0">
        <comment>Interrupt status of CFO SF done interrupt</comment>
      </bits>
      <bits name="rVIT_DEC_DONE_INT_STATUS" pos="9" access="w1c" rst="0">
        <comment>Interrupt status of Viterbi decode done</comment>
      </bits>
      <bits name="rAGC_INT_STATUS" pos="10" access="w1c" rst="0">
        <comment>Interrupt status of AGC interrupt</comment>
      </bits>
      <bits name="rDS_BSEL_INT_STATUS" pos="11" access="w1c" rst="0">
        <comment>Interrupt status of DS_BSEL interrupt</comment>
      </bits>
      <bits name="rPUSCH_ENC_INT_STATUS" pos="12" access="w1c" rst="0">
        <comment>Interrupt status of PUSCH Encoder interrupt</comment>
      </bits>
      <bits name="rTX_CHSC_INT_STATUS" pos="13" access="w1c" rst="0">
        <comment>Interrupt status of TX_CHSC interrupt</comment>
      </bits>
      <bits name="rFFT_512_DONE_INT_STATUS" pos="14" access="w1c" rst="0">
        <comment>Interrupt status of FFT_512 done interrupt</comment>
      </bits>
      <bits name="rNPRS_ACC1_DONE_INT_STATUS" pos="15" access="w1c" rst="0">
        <comment>Interrupt status of NPRS_ACC1 done interrupt</comment>
      </bits>
      <bits name="rFINT_IFFT_DONE_INT_STATUS" pos="16" access="w1c" rst="0">
        <comment>Interrupt status of FINE IFFT done interrupt</comment>
      </bits>
      <bits name="rCA_RX_DUMP_DONE_INT_STATUS" pos="18" access="w1c" rst="0">
        <comment>Interrupt status of CA RX dump done interrupt</comment>
      </bits>
      <bits name="rCA_TX_DUMP_DONE_INT_STATUS" pos="19" access="w1c" rst="0">
        <comment>Interrupt status of CA TX dump done interrupt</comment>
      </bits>
      <bits name="rNB_ACC_DONE_INT_STATUS" pos="22" access="w1c" rst="0">
        <comment>Interrupt status of NB ACC done interrupt</comment>
      </bits>
    </reg32>
    <reg32 name="rTXEV_DSP_MASKING" protect="rw">
      <bits name="rNB_ACC_MASKING" pos="0" access="rw" rst="0">
        <comment>Masking nb acc done for TXEV</comment>
      </bits>
      <bits name="rS16PEAK_MASKING" pos="1" access="rw" rst="0">
        <comment>Masking S16PEAK done for TXEV</comment>
      </bits>
      <bits name="rFFT_512_MASKING" pos="2" access="rw" rst="0">
        <comment>Masking FFT_512 done for TXEV</comment>
      </bits>
      <bits name="rNPRS_ACC1_MASKING" pos="3" access="rw" rst="0">
        <comment>Masking NPRS_ACC1 done for TXEV</comment>
      </bits>
      <bits name="rFINE_IFFT_MASKING" pos="4" access="rw" rst="0">
        <comment>Masking FINE_IFFT done for TXEV</comment>
      </bits>
      <bits name="rLOCSEQ_GEN_MASKING" pos="5" access="rw" rst="0">
        <comment>Masking LOCSEQ_GEN done for TXEV</comment>
      </bits>
      <bits name="rSS_MASKING" pos="6" access="rw" rst="0">
        <comment>Masking SmartScheduler done for TXEV</comment>
      </bits>
    </reg32>
  </module>
</archive>


<archive relative = "nb_locseq_gen.xml">

<module name="nb_locseq_gen" category="NBIOT_PHY">
 
  <reg32 name="rLOCSEQ_GEN_START" protect="wo">
    <bits access="rw" name="rLOCSEQ_GEN_START" pos="0:0" rst="0x0">
      <comment>The start of LOCSEQ_GEN accelerator. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_GEN_CTRL" protect="rw">
    <bits access="rw" name="rLOCSEQ_TYPE" pos="1:0" rst="0x0">
      <comment>Locseq type, 2'b00: No sequence; 2'b01: PBCH; 2'b10: NSSS; 2'b11: NWUS. </comment>
    </bits>
    <bits access="rw" name="rBSEQ_SEL" pos="3:2" rst="0x0">
      <comment>Index of Binary sequence selection when NSSS. </comment>
    </bits>
    <bits access="rw" name="RSV" pos="7:4" rst="0x0">
      <comment>Reserved bits. </comment>
    </bits>
    <bits access="rw" name="rIFFT_BIT_SHIFT" pos="10:8" rst="0x0">
      <comment>Ifft output bit fixed point selection. </comment>
    </bits>
    <bits access="rw" name="rZC_U_IDX" pos="18:11" rst="0x0">
      <comment>u index of Zadoff-Chu sequence, whihch equal to Ncell_IDmod126+3. </comment>
    </bits>
    <bits access="rw" name="rNRS_VSHIFT" pos="21:19" rst="0x0">
      <comment>Vshift for NRS. </comment>
    </bits>
    <bits access="rw" name="rNB_ANTE_NUM" pos="23:22" rst="0x0">
      <comment>NBIoT Tx antenna number. 
2'd0: no NRS;
2'd1: 1 antenna port; 
2'd2: 2 antenna port; 
2'd3: Reserved; 
      </comment>
    </bits>
    <bits access="rw" name="rCRS_VSHIFT" pos="26:24" rst="0x0">
      <comment>Vshift for CRS. </comment>
    </bits>
    <bits access="rw" name="rLTE_ANTE_NUM" pos="28:27" rst="0x0">
      <comment>LTE antenna number, 
2'd0: no CRS;
2'd1: 1 antenna port; 
2'd2: 2 antenna port; 
2'd3: 3 antenna port; 
      </comment>
    </bits>
    <bits access="rw" name="rNSSS_CSHIFT" pos="30:29" rst="0x0">
      <comment>The cyclic shift in the frame number nf which is given by (nf/2)mod4. </comment>
    </bits>
    <bits access="rw" name="RSV0" pos="31:31" rst="0x0">
      <comment>Reserved bit. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_BKD_EN" protect="rw">
    <bits access="rw" name="rLOCSEQ_BKD_EN" pos="0:0" rst="0x0">
      <comment>Locseq gen backdoor enabled. 
1'b0: Normal mode, locseq sequence backdoor is disabled.
1'b1: locseq sequence backdoor enabled.
      </comment>
    </bits>
    <bits access="rw" name="rSCRAMBLE_EN" pos="1:1" rst="0x0">
      <comment>The NWUS Scramble enabled.
1'b0: Scramble disabled.
1'b1: Scramble enabled. 
      </comment>
    </bits>
    <bits access="rw" name="rRAW_ZC_SEQ_EN" pos="2:2" rst="0x0">
      <comment>Enabled Raw zad-off CHU sequence output.
1'b0: Disabled.
1'b1: Enabled. 
      </comment>
  </bits>
   <bits access="rw" name="rLOCSEQ_SYMB_BMP" pos="16:3" rst="0x0">
      <comment>Symbol bitmap for NWUS and PBCH.
bit0=1'b0: symbol0 disabled.
bit0=1'b1: symbol0 enabled.
bit1=1'b0: symbol1 disabled.
bit1=1'b1: symbol1 enabled.
...
bit13=1'b0: symbol13 disabled.
bit13=1'b1: symbol13 enabled.
      </comment>
  </bits>
   <bits access="rw" name="rLOCSEQ_NWUS_PHASE_SHIFT_EN" pos="17:17" rst="0x0">
       <comment>NWUS phase shift enabled/disabled.
1'b0: Disabled.
1'b1: Enabled. 
      </comment>
  </bits>
   <bits access="rw" name="rLOCSEQ_NWUS_G_VALUE" pos="25:18" rst="0x0">
      <comment>for R16 NWUS phase shift, g value is equal to 14*(u_id+1),u_id is from 0 to 7
      </comment>
  </bits>
  </reg32>

  <reg32 name="rLOCSEQ_SC_X1" protect="rw">
    <bits access="rw" name="rSC_X1" pos="30:0" rst="0x0">
      <comment>Initial value of X1 golden sequence for each subframe, used for scramble for NWUS. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_SC_X2" protect="rw">
    <bits access="rw" name="rSC_X2" pos="30:0" rst="0x0">
      <comment>Initial value of X2 golden sequence for each subframe, used for scramble for NWUS. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_PBCH_MEM_ADDR" protect="rw">
    <bits access="rw" name="rPBCH_MEM_ADDR" pos="31:0" rst="0x0">
      <comment>Memory address where store teh resource element result of PBCH. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_IFFT_MEM_ADDR" protect="rw">
    <bits access="rw" name="rIFFT_MEM_ADDR" pos="31:0" rst="0x0">
      <comment>Memory address where store the local sequence result. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_GEN_TIMER" protect="rw">
    <bits access="rw" name="rLOCSEQ_GEN_TIMER" pos="31:0" rst="0x0">
      <comment>Timer to limit the processing time of locseq gen. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_GEN_DMA_TIMER" protect="rw">
    <bits access="rw" name="rLOCSEQ_GEN_DMA_TIMER" pos="31:0" rst="0x0">
      <comment>DMA Timer, which used to limit the time of one time of DMA transfer. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_MEM_SPACE_START" protect="rw">
    <bits access="rw" name="rLOCSEQ_MEM_SPACE_START" pos="31:0" rst="0x0">
      <comment>The start address of the external memory space used for store the result of IFFT. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_MEM_SPACE_END" protect="rw">
    <bits access="rw" name="rLOCSEQ_MEM_SPACE_END" pos="31:0" rst="0x0">
      <comment>The end address of the external memory space used for store the result of IFFT. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_RPT_SC_X1" protect="ro">
    <bits access="ro" name="rRPT_SC_X1" pos="30:0" rst="0x0">
      <comment>Reported X1 scramble sequence value when locseq generated done for one sub-frame. </comment>
    </bits>
  </reg32>
 
  <reg32 name="rLOCSEQ_RPT_SC_X2" protect="ro">
    <bits access="ro" name="rRPT_SC_X2" pos="30:0" rst="0x0">
      <comment>Reported X2 scramble sequence value when locseq generated done for one sub-frame. </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_GEN_DMA_STATUS" protect="ro">
    <bits access="ro" name="rLOCSEQ_GEN_DMA_STATUS" pos="13:0" rst="0x0">
      <comment>Locseq gen DMA engine status,
[9:8]: DMA done status
        2'd0: DMA success done;
        2'd1: DMA done by DMA stop;
        2'd2: DMA done by DMA timerout;
        2'd3: reserved.
[7]: dma write FIFO ready status, for debug
[6]: dma read FIFO1 ready status, for debug
[5]: dma read FIFO0 ready status, for debug
[4:0]: dma controller state machine, for debug
      </comment>
    </bits>
    <bits access="ro" name="rLOCSEQ_GEN_DMA_BUSY" pos="14:14" rst="0x0">
      <comment>
1'b0: DMA IDLE;
1'b1: DMA Busy.
      </comment>
    </bits>
    <bits access="ro" name="rLOCSEQ_GEN_DMA_TIMEOUT" pos="15:15" rst="0x0">
      <comment>
1'b0: DMA timeout;
1'b1: DMA finish in a setting time normally.
      </comment>
    </bits>
    <bits access="ro" name="rLOCSEQ_GEN_FIFO_STATUS" pos="19:16" rst="0x0">
      <comment>
bit0: FIFO empty status;
bit1: FIFO half empty status;
bit2: FIFO full status;
bit3: FIFO half full status;
      </comment>
    </bits>
  </reg32>

  <reg32 name="rLOCSEQ_GEN_STATUS" protect="w1c">
    <bits access="w1c" name="rLOCSEQ_GEN_DONE" pos="0:0" rst="0x0">
      <comment>
1'b0: LOCSEQ_GEN busy or idle;
1'b1: LOCSEQ_GEN done;
write one to clear.
      </comment>
    </bits>
    <bits access="ro" name="rLOCSEQ_GEN_STATUS" pos="1:1" rst="0x0">
      <comment>
1'b0: LOCSEQ_GEN idle;
1'b1: LOCSEQ_GEN busy;
      </comment>
    </bits>
    <bits access="ro" name="rLOCSEQ_GEN_TIMEOUT" pos="2:2" rst="0x0">
      <comment>LOCSEQ_GEN time out. </comment>
    </bits>
    <bits access="ro" name="rLOCSEQ_ERR_STATUS" pos="4:3" rst="0x0">
      <comment>
2'b0: no error;
2'b1: locseq type configured error;
2'b2: locseq AHB write memory space over-range;
2'b3: reserved.
      </comment>
    </bits>
    <bits access="ro" name="rPBCH_CALC_CNT" pos="6:5" rst="0x0">
      <comment>The count of LOCSEQ is called for PBCH calculation, the count hold 3 if it is more than 3. 
DSP can write 2'b11 to clear;
      </comment>
    </bits>
    <bits access="ro" name="rNSSS_CALC_CNT" pos="8:7" rst="0x0">
      <comment>The count of LOCSEQ is called for NSSS calculation, the count hold 3 if it is more than 3. 
DSP can write 2'b11 to clear;
      </comment>
    </bits>
    <bits access="ro" name="rNWUS_CALC_CNT" pos="10:9" rst="0x0">
      <comment>The count of LOCSEQ is called for NWUS calculation, the count hold 3 if it is more than 3. 
DSP can write 2'b11 to clear;
      </comment>
    </bits>
  </reg32>
</module>

</archive>


<archive relative = "nb_meas.xml">
  <module name="nb_meas" category="NBIOT_PHY">
    <reg32 name="rASP_ON" protect="w">
      <bits name="rASP_ON" pos="0" access="w" rst="0">
        <comment>Symbol power accumulation enable/disable signal and effective at subframe boundary.
      1 : enable
      0 : disable</comment>
      </bits>
    </reg32>
    <reg32 name="rASP_CTRL" protect="rw">
      <bits name="rASP_INPUT_MODE" pos="13" access="rw" rst="0">
        <comment>Switching register to choose input source data for symbol power calculation
0: normal rx data
1: rx data without dc offset</comment>
      </bits>
      <bits name="rASP_GAIN" pos="12:9" access="rw" rst="0">
        <comment>Gain used in shift and saturation of accumulation power value.
Bit[3:0]	Gain
0000	        2^-24 (default)
0001	        2^-23 
0010	        2^-22
0011	        2^-21</comment>
      </bits>
      <bits name="rASP_LENGTH" pos="8:7" access="rw" rst="0">
        <comment>Accumulation length of samples in every symbol.
    0: 128   
    1: 64
    2: 32
    3: 16</comment>
      </bits>
      <bits name="rASP_OFFSET" pos="6:0" access="rw" rst="0">
        <comment>Offset of samples from symbols' boundaries which is the start boundary of agc symbol power calculation.</comment>
      </bits>
    </reg32>
    <reg32 name="rASP_RD_ADDR" protect="rw">
      <bits name="rASP_RD_ADDR" pos="5:0" access="rw" rst="0">
        <comment>Reading address for DSP to read asp response ram, and this register would auto-increment whenever access the 'rASP_RD_DATA' register
PING buffer address: 0~20
PONG buffer address: 21~41
</comment>
      </bits>
    </reg32>
    <reg32 name="rDC_CANCEL_OFFSET" protect="rw">
      <bits name="rDC_CANCEL_OFFSET_I" pos="27:16" access="rw" rst="0">
        <comment>Bit[27:16]: Q DC offset configuration
</comment>
      </bits>
      <bits name="rDC_CANCEL_OFFSET_Q" pos="11:0" access="rw" rst="0">
        <comment>Bit[11:0]:   I DC offset configuration
</comment>
      </bits>
    </reg32>
    <hole size="7*32"></hole>
    <reg32 name="rASP_STATUS" protect="r">
      <bits name="rASP_DONE_STATUS" pos="0" access="w1c" rst="0">
        <comment>Report agc symbol power and DCC done status, write '1' to clear this status</comment>
      </bits>
      <bits name="rASP_BUF_PING_PONG_IDX" pos="1" access="r" rst="0">
        <comment>Index bit to indicate which buffer is updated of PING-PONG   
1: PONG buffer data is updated
0: PING buffer data is updated</comment>
      </bits>
    </reg32>
    <reg32 name="rASP_RD_DATA" protect="r">
      <bits name="rASP_RD_DATA" pos="31:0" access="r" rst="0">
        <comment>Data = mem[rASP_RD_ADDR] which is the ASP response memory data content. The ASP_RD_ADDR would auto increase whenever access this register. 
ASP response Memory address range is 0-41
Address(0~6,21~27): symbol power, bit[15:0] for symbol 0,2,4,6,8,10,12 and bit[31:16] for symbol 1,3,5,7,9,11,13
Address(7~20,28~41):dc_offset value, bit[15:0] for I and bit[31:16] for Q
</comment>
      </bits>
    </reg32>
    <hole size="51*32"></hole>
    <reg32 name="rFFT_512_CTRL" protect="rw">
      <bits name="rFFT_FWD_INV" pos="0" access="rw" rst="0">
        <comment>Forward/Inverse FFT transform computing selection</comment>
      </bits>
      <bits name="rFFT_BUF_IDX" pos="1" access="rw" rst="0">
        <comment>PING-PONG memory selection
1'b0: Memory0;
1'b1: Memory1.</comment>
      </bits>
      <bits name="rFFT_SCALING_FACTOR" pos="4:2" access="rw" rst="0">
        <comment>alphaFFT scaling, it can be implemented by bit shift,
3'd0: 2^-3
3'd1: 2^-2
3'd2: 2^-1
3'd3: 2^0  (default)
3'd4: 2^1
3'd5: 2^2
3'd6: 2^3
3'd7: 2^4
</comment>
      </bits>
      <bits name="rFFT_AMP_SCALING_FACTOR" pos="7:5" access="rw" rst="0">
        <comment>alphaFFT_amp_out scaling for amplitude square output, it can be implemented by bit shift,
3'd0: 2^-3
3'd1: 2^-2
3'd2: 2^-1
3'd3: 2^0  (default)
3'd4: 2^1
3'd5: 2^2
3'd6: 2^3
3'd7: 2^4 
</comment>
      </bits>
      <bits name="rFFT_AMP_CAL_EN" pos="8" access="rw" rst="0">
        <comment>IFFT Output amptitude data
1'b0: IFFT output normal data(I+j*Q);
1'b1: IFFT output amptitude data(I^2+Q^2).</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_512_START" protect="w">
      <bits name="rFFT_512_START" pos="0" access="w" rst="0">
        <comment>FFT start indication, when write 1 to this register, a high active pulse will be generated and input to FFT engine to start FFT calculation.</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_512_STATUS" protect="r">
      <bits name="rFFT_DONE" pos="0" access="w1c" rst="0">
        <comment>FFT done status, write 1 clear.</comment>
      </bits>
      <bits name="rMEM_BUS_ERR" pos="2:1" access="r" rst="0">
        <comment>An error grant is received when FFT request memory write bus to store FFT result. 
Bit1: DSP control error;
Bit0: Accelerator memory access error.</comment>
      </bits>
      <bits name="rFFT_IN_UNDERFLOW" pos="3" access="r" rst="0">
        <comment>This register is used to check the range of FFT/IFFT input,  
1'b1: absolute maximum FFT/IFFT input less than 32, in this case, the resolution of FFT/IFFT output will loss 1bit;
1'b0: normally.
</comment>
      </bits>
    </reg32>
    <hole size="61*32"></hole>
    <reg32 name="rNPRS_ACC1_START" protect="w">
      <bits name="rNPRS_ACC1_START" pos="0" access="w" rst="0">
        <comment>NPRS accelerator 1 Start</comment>
      </bits>
    </reg32>
    <reg32 name="rNPRS_ACC1_CTRL" protect="rw">
      <bits name="rTIMEOUT_VAL" pos="15:0" access="rw" rst="0x7ff">
        <comment>Maximum time out value in 61.44Mhz unit</comment>
      </bits>
      <bits name="rMODE" pos="17:16" access="rw" rst="0">
        <comment>Mode selection:
2'b00: copy + dot product
2'b01: dot product 
2'b10: copy</comment>
      </bits>
      <bits name="rCP_SRC_MEM" pos="18" access="rw" rst="0">
        <comment>Copy Source memory before sequence dot product
0: Memory 0
1: Memory 1</comment>
      </bits>
      <bits name="rCP_BR_ADDR_EN" pos="19" access="rw" rst="0">
        <comment>Copy memory with bit-reversed address write location enable
0: Disable
1: Enable</comment>
      </bits>
      <bits name="rDP_DST_MEM" pos="20" access="rw" rst="0">
        <comment>Destination memory after sequence dot product
0: Memory 0
1: Memory 1</comment>
      </bits>
      <bits name="rDP_BR_ADDR_EN" pos="21" access="rw" rst="0">
        <comment>Dot Product from memory 5 to memory 0/1 with bit-reversed address write location enable
0: Disable
1: Enable</comment>
      </bits>
      <bits name="rCONJ_SEQ_EN" pos="22" access="rw" rst="0">
        <comment>Conjugate Sequence data Enable
0: Disable
1: Enable</comment>
      </bits>
      <bits name="rCONJ_FFT_EN" pos="23" access="rw" rst="0">
        <comment>Conjugate FFT data Enable
0: Disable
1: Enable</comment>
      </bits>
      <bits name="rDP_BIT_SHIFT" pos="26:24" access="rw" rst="0">
        <comment>Dot Product output bit shift (default:3)
0: s16.13
1: s16.12
2: s16.11
3: s16.10
4: s16.9
5: s16.8
6: s16.7
7: s16.6</comment>
      </bits>
      <bits name="rCP_DST_MEM" pos="28:27" access="rw" rst="0">
        <comment>Destination memory after CP
0: Memory 5
1: Memory 4
2: Memory 7
3: Not available</comment>
      </bits>
    </reg32>
    <reg32 name="rNPRS_ACC1_LEN" protect="rw">
      <bits name="rNPRS_ACC1_LEN" pos="8:0" access="rw" rst="0x1ff">
        <comment>Operation length -1 
Default : (511)</comment>
      </bits>
    </reg32>
    <reg32 name="rSEQ_START_OFS_ADDR" protect="rw">
      <bits name="rSEQ_START_OFS_DP_ADDR" pos="10:0" access="rw" rst="0">
        <comment>Sequence Memory Start Offset Address</comment>
      </bits>
      <bits name="rSEQ_START_OFS_CP_ADDR" pos="26:16" access="rw" rst="0">
        <comment>Sequence Memory Start Offset Address</comment>
      </bits>
    </reg32>
    <reg32 name="rNPRS_ACC1_STATUS" protect="r">
      <bits name="rDone" pos="0" access="w1c" rst="0">
        <comment>(This bit is read write 1 clear)
0: No Done
1: Done</comment>
      </bits>
      <bits name="rOverwritten" pos="1" access="r" rst="0">
        <comment>If Done bit would not clear before this engine re-engine would indicate overwritten output buffer
0: Normal
1: Error</comment>
      </bits>
      <bits name="rBUS Error 0" pos="3:2" access="r" rst="0">
        <comment>Read/Write process in Memory 0/1 (FFT/IFFT input/output memory)
0: Normal
1: Error
Bit 0: DSP control bus error
Bit 1: accelerator memory access collusion</comment>
      </bits>
      <bits name="rBUS Error 1" pos="5:4" access="r" rst="0">
        <comment>Read/Write process in Memory 5 (Copied FFT memory)</comment>
      </bits>
      <bits name="rBUS Error 2" pos="7:6" access="r" rst="0">
        <comment>Read process in Memory 4 (Sequence memory)</comment>
      </bits>
      <bits name="rBUS Error 3" pos="9:8" access="r" rst="0">
        <comment>Read/Write process in Memory 7 (Copied FFT memory)</comment>
      </bits>
      <bits name="rTimeout" pos="10" access="r" rst="0">
        <comment>0: Normal
1: Error</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_OFS_ADDR" protect="rw">
      <bits name="rFINE_OFS_ADDR" pos="10:0" access="rw" rst="0">
        <comment>Fine IFFT Start Offset Address for copy memory 7</comment>
      </bits>
    </reg32>
    <hole size="58*32"></hole>
    <reg32 name="rFINE_IFFT_START" protect="w">
      <bits name="rFINE_IFFT_START" pos="0" access="w" rst="0">
        <comment>Fine IFFT START
A pulse to grigger the Fine IFFT</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_IFFT_CALC_CTRL" protect="rw">
      <bits name="rFINE_IFFT_T" pos="8:0" access="rw" rst="0">
        <comment>NPRS Coarse Timing Result  
Range is from 0 to 272</comment>
      </bits>
      <bits name="rFINE_IFFT_CALC_OS" pos="22:16" access="rw" rst="0">
        <comment>Fine IFFT calculation offset. Range is from 0 to 95.</comment>
      </bits>
      <bits name="rFINE_IFFT_CALC_LEN" pos="30:24" access="rw" rst="0">
        <comment>Fine IFFT calculation length. Range is from 1 to 96.</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_IFFT_IOOUT_CTRL" protect="rw">
      <bits name="rFINE_IFFT_OUT_IQ_SCALE" pos="2:0" access="rw" rst="0">
        <comment>Fine IFFT output a+bj scaling
3'd0:x2^0(default)
3'd1:x2^-1
3'd2:x2^-2
3'd3:x2^-3
3'd4:x2^-4
3'd5:x2^-5
3'd6:x2^-6
3'd7:x2^-7
</comment>
      </bits>
      <bits name="rFINE_IFFT_OUT_PWR_SCALE" pos="10:8" access="rw" rst="0">
        <comment>Fine IFFT output power scaling
3'd0:x2^-3
3'd1:x2^-2
3'd2:x2^-1
3'd3:x2^0 (default)
3'd4:x2^1
3'd5:x2^2
3'd6:x2^3
3'd7:x2^4</comment>
      </bits>
      <bits name="rFINE_IFFT_OUT_SEL" pos="16" access="rw" rst="0">
        <comment>Fine IFFT output selection
1'b0: Output IFFT result: a+bj
1'b1: Output power result: a^2+b^2</comment>
      </bits>
      <bits name="rFINE_IFFT_IN_CTRL" pos="17" access="rw" rst="0">
        <comment>Fine IFFT input data control
1'b0: Input data in inverse order 
1'b1: Input data in inverse order and swap bit0~bit255 with bit256~bit511</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_IFFT_INPUT_ADDR" protect="rw">
      <bits name="rFINE_IFFT_INPUT_ADDR" pos="10:0" access="rw" rst="0">
        <comment>Fine IFFT input data start address</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_IFFT_OUTPUT_ADDR" protect="rw">
      <bits name="rFINE_IFFT_OUTPUT_ADDR" pos="10:0" access="rw" rst="0">
        <comment>Fine IFFT output data start address</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_IFFT_STATUS" protect="r">
      <bits name="rFINE_IFFT_DONE_STATUS" pos="0" access="w1c" rst="0">
        <comment>Fine IFFT calculation done status.
1'b1: Fine IFFT calculation done
1'b0: Fine IFFT is idle or under calculating</comment>
      </bits>
      <bits name="rFINE_IFFT_OW_STATUS" pos="1" access="w1c" rst="0">
        <comment>Fine IFFT output buffer status
1'b1: Fine IFFT output buffer is over written
1'b0: Fine IFFT output buffer is normal</comment>
      </bits>
      <bits name="rFINE_IFFT_ERR_STATUS" pos="3:2" access="r" rst="0">
        <comment>Fine IFFT calculation done status.
1'b1: Fine IFFT calculation done
1'b0: Fine IFFT is idle or under calculating</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_multi_ca_fft.xml">
  <module name="NBIOT_MULTI_CA_FFT" category="NBIOT_PHY">
    <reg32 name="rFFT_CMD_START_ADDR" protect="rw">
      <bits name="rFFT_CMD_START_ADDR" pos="31:0" access="rw" rst="0x0">
        <comment>The start address of memory where FFT command stored.
Figure 5.4 2 shows the FFT command format.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_START" protect="wo">
      <bits name="rCA_FFT_START" pos="0:0" access="wo" rst="0x0">
        <comment>Pulse that high asserted which start CA FFT calculation. Once start, HW will perform FFT calculation </comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_STOP" protect="wo">
      <bits name="rCA_FFT_STOP" pos="0:0" access="wo" rst="0x0">
        <comment>High active pulse, when asserted, HW accelerator continue to finish FFT calculation based on current FFT command, then stop.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_CTRL" protect="rw">
      <bits name="rCA_FFT_CMD_FMT" pos="0:0" access="rw" rst="0">
        <comment>0: FFT command format0, whose length is 9 DWs.
1: FFT command format1, whose length is 10 DWs which include the information of DC offset cancellation and calculation.</comment>
      </bits>
    </reg32>
    <reg32 name="rDMA_TIMER" protect="rw">
      <bits name="rDMA_TIMER" pos="31:0" access="rw" rst="0">
        <comment>DMA timer, maximum DMA time limited.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_TIMER" protect="rw">
      <bits name="rCA_FFT_TIMER" pos="31:0" access="rw" rst="0">
        <comment>CA FFT timer, limited the time from DSP program CA FFT start to HW finish all of FFT calculation in FFT commands</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_MEM_SPACE_START" protect="rw">
      <bits name="rCA_FFT_MEM_SPACE_START" pos="31:0" access="rw" rst="0">
        <comment>The start address in share memory used for CA_FFT, co-use with i_ ca_fft_mem_space_end, all of AHB access cycle whose address is out of the range will be rejected.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_MEM_SPACE_END" protect="rw">
      <bits name="rCA_FFT_MEM_SPACE_END" pos="31:0" access="rw" rst="0">
        <comment>The end address in share memory used for CA_FFT, co-use with i_ ca_fft_mem_space_start, all of AHB access cycle whose address is out of the range will be rejected.</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_DMA_STATUS" protect="ro">
      <bits name="rFFT_DMA_STATUS" pos="9:0" access="ro" rst="0">
        <comment>[9:8]: DMA done status
0: DMA success done;
1: DMA done by DMA stop;
2: DMA done by DMA timeout;
3: Reserved. 
[7]: dma write FIFO ready status, for debug
[6]: dma read FIFO1 ready ststus, for debug
[5]: dma read FIFO0 ready status, for debug
[4:0]: dma controller state machine, for debug</comment>
      </bits>
      <bits name="rCA_FFT_DMA_BUSY" pos="10:10" access="ro" rst="0">
        <comment>1: DMA busy;
0: DMA IDLE.</comment>
      </bits>
      <bits name="rCA_FFT_DMA_TIMEOUT" pos="11:11" access="ro" rst="0">
        <comment>1: DMA timer out
0: DMA finish in a setting time normally.</comment>
      </bits>
      <bits name="rCA_FFT_FIFO_STATUS" pos="15:12" access="ro" rst="0">
        <comment>FFT FIFO status
Bit0: FIFO empty
Bit1: FIFO half empty
Bit2: FIFO full
Bit3: FIFO half full</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_STATUS" protect="rw">
      <bits name="rCA_FFT_STATUS" pos="0:0" access="ro" rst="0">
        <comment>0: CA FFT idle;
1: CA FFT busy.</comment>
      </bits>
      <bits name="rCA_FFT_DONE" pos="1:1" access="w1c" rst="0">
        <comment>1: CA FFT done
0: CA FFT ongoing or idle.</comment>
      </bits>
      <bits name="rCA_FFT_TIMEOUT" pos="2:2" access="ro" rst="0">
        <comment>When SW start CA FFT, CA FFT timer begin to count, and stop when CA FFT done, during this time, if timer count reach to rDMA_TIMER, it reports time out.
0: no time out.
1: CA FFT calculation does not finish in a setting time, and time out.</comment>
      </bits>
      <bits name="rCA_FFT_CMD_ERR" pos="4:3" access="w1c" rst="0">
        <comment>FFT command error, asserted when FFT command format error, write 1 clear
0: FFT command valid;
1: FFT command invalid;
2: DMA address out of range which set by [rCA_FFT_MEM_SPACE_START, rCA_FFT_MEM_SPACE_END].
3: Reserved.</comment>
      </bits>
      <bits name="rONGOING_FFT_CMD_IDX" pos="20:5" access="ro" rst="0">
        <comment>Indicated which the ongoing FFT is triggered by which FFT Command.</comment>
      </bits>
      <bits name="rONGOING_FFT_CMD_LOOP_CNT" pos="24:21" access="ro" rst="0">
        <comment>Indicated which loop counter is a FFT command is served.</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_multi_ca_ifft.xml">
  <module name="NBIOT_MULTI_CA_IFFT" category="NBIOT_PHY">
    <reg32 name="rCA_IFFT_CMD_START_ADDR" protect="rw">
      <bits name="rFFT_CMD_START_ADDR" pos="31:0" access="rw" rst="0x0">
        <comment>The start address of memory where FFT command stored.
Figure 5.4 2 shows the FFT command format.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_CMD_MEM_DEPTH" protect="rw">
      <bits name="rCA_IFFT_CMD_MEM_DEPTH" pos="15:0" access="rw" rst="0x0">
        <comment>A circular buffer is provided for DSP to program IFFT command data, the register defines the depth of this memory. The depth of command in memory is programmed in unit of byte, each IFFT command occupy 4 DWs, which is 16 bytes, so the programmed number always is times of 16. </comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_CTRL" protect="rw">
      <bits name="rCA_IFFT_HW_MODE" pos="0:0" access="rw" rst="0x0">
        <comment>0: Software mode. Hardware accelerator performs FFT calculation according to FFT command. DSP need to make sure the data is transmitted before start next IFFT calculation.
1: Hardware mode. Hardware accelerator automatically performs FFT calculation by monitoring the data dump number form TX_DUMP module. </comment>
      </bits>
      <bits name="rDSP_CFG_ZC_TW_RAM" pos="1:1" access="rw" rst="0x0">
        <comment>0: DSP can not write ZC twiddle RAM;
1: DSP can write ZC twiddle RAM.</comment>
      </bits>
      <bits name="rZC_SEQ_LEN" pos="8:2" access="rw" rst="0x0">
        <comment>Zadoff-CHU sequence length, prime number, default value 43.</comment>
      </bits>
      <bits name="rRACH_SC_OS" pos="16:9" access="rw" rst="0x0">
        <comment>RACH sub-carrier offset, default value is equal to 42. 
Conifigured value = rZC_SEQ_LEN -1;</comment>
      </bits>
      <bits name="rRACH_IFFT_PI_ROTATE_MODE" pos="17" access="rw" rst="0x0">
        <comment>0: PRACH symbol generation without pi rotate at odd symbol;
1: PRACH symbol generateion with pi rotate at odd symbol.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_START" protect="wo">
      <bits name="rCA_IFFT_START" pos="0:0" access="wo" rst="0x0">
        <comment>Pulse that high asserted which start CA IFFT calculation. Once start, HW will perform DFT/IFFT calculation </comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_STOP" protect="wo">
      <bits name="rCA_IFFT_STOP" pos="0:0" access="wo" rst="0x0">
        <comment>High active pulse, when asserted, HW accelerator continue to finish IFFT calculation based on current FFT command, then stop.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_DMA_TIMER" protect="rw">
      <bits name="rCA_IFFT_DMA_TIMER" pos="31:0" access="rw" rst="0">
        <comment>DMA timer, maximum DMA time limited.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_TIMER" protect="rw">
      <bits name="rCA_IFFT_TIMER" pos="31:0" access="rw" rst="0">
        <comment>CA IFFT timer, limited the time from DSP program CA IFFT start to HW finish all of IFFT calculation in IFFT commands</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_MEM_SPACE_START" protect="rw">
      <bits name="rCA_IFFT_MEM_SPACE_START" pos="31:0" access="rw" rst="0">
        <comment>The start address in share memory used for CA_IFFT, co-use with rCA_FFT_MEM_SPACE_END, all of AHB access cycle whose address is out of the range will be rejected.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_MEM_SPACE_END" protect="rw">
      <bits name="rCA_IFFT_MEM_SPACE_START" pos="31:0" access="rw" rst="0">
        <comment>The end address in share memory used for CA_IFFT, co-use with rCA_IFFT_MEM_SPACE_START, all of AHB access cycle whose address is out of the range will be rejected.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_DMA_STATUS" protect="ro">
      <bits name="rCA_IFFT_DMA_STATUS" pos="9:0" access="ro" rst="0">
        <comment>[9:8]: DMA done status
0: DMA success done;
1: DMA done by DMA stop;
2: DMA done by DMA timeout;
3: Reserved. 
[7]: dma write FIFO ready status, for debug
[6]: dma read FIFO1 ready ststus, for debug
[5]: dma read FIFO0 ready status, for debug
[4:0]: dma controller state machine, for debug</comment>
      </bits>
      <bits name="rCA_IFFT_DMA_BUSY" pos="10:10" access="ro" rst="0">
        <comment>1: DMA busy;
0: DMA IDLE.</comment>
      </bits>
      <bits name="rCA_IFFT_DMA_TIMEOUT" pos="11:11" access="ro" rst="0">
        <comment>1: DMA timer out
0: DMA finish in a setting time normally.</comment>
      </bits>
      <bits name="rCA_IFFT_FIFO_STATUS" pos="15:12" access="ro" rst="0">
        <comment>FFT FIFO status
Bit0: FIFO empty
Bit1: FIFO half empty
Bit2: FIFO full
Bit3: FIFO half full</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_STATUS" protect="rw">
      <bits name="rCA_IFFT_STATUS" pos="0:0" access="ro" rst="0">
        <comment>0: CA IFFT idle;
1: CA IFFT busy.</comment>
      </bits>
      <bits name="rCA_IFFT_DONE" pos="1:1" access="w1c" rst="0">
        <comment>1: CA FFT done
0: CA FFT ongoing or idle.</comment>
      </bits>
      <bits name="rCA_IFFT_TIMEOUT" pos="2:2" access="ro" rst="0">
        <comment>When SW start CA IFFT, CA IFFT timer begin to count, and stop when CA IFFT done, during this time, if timer count reach to rDMA_TIMER, it reports time out.
0: no time out.
1: CA IFFT calculation does not finish in a setting time, and time out.</comment>
      </bits>
      <bits name="rCA_IFFT_CMD_ERR" pos="4:3" access="w1c" rst="0">
        <comment>Asserted which IFFT command format error.
0: no error
1: current IFFT command invalid
2: next IFFT command invalid
3: DMA address out of range.</comment>
      </bits>
      <bits name="rONGOING_IFFT_CMD_IDX" pos="20:5" access="ro" rst="0">
        <comment>Indicated which the ongoing IFFT is triggered by which IFFT Command.</comment>
      </bits>
      <bits name="rONGOING_IFFT_CMD_LOOP_CNT" pos="24:21" access="ro" rst="0">
        <comment>Indicated which loop counter is a IFFT command is served.</comment>
      </bits>
      <bits name="rCA_DUMP_UD" pos="25:25" access="w1c" rst="0">
        <comment>CA DUMP underflow, asserted when CA DUMP symbol cnt is more than IFFT finished symbol cnt, which means no data for tx dump to transmit.
When asserted, it need DSP write 1 to clear.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA0" protect="rw">
      <bits name="rTX_GAIN_CA0" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA0.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA1" protect="rw">
      <bits name="rTX_GAIN_CA1" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA1.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA2" protect="rw">
      <bits name="rTX_GAIN_CA2" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA2.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA3" protect="rw">
      <bits name="rTX_GAIN_CA3" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA3.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA4" protect="rw">
      <bits name="rTX_GAIN_CA4" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA4.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA5" protect="rw">
      <bits name="rTX_GAIN_CA5" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA6.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA6" protect="rw">
      <bits name="rTX_GAIN_CA6" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA6.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA7" protect="rw">
      <bits name="rTX_GAIN_CA7" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA7.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA8" protect="rw">
      <bits name="rTX_GAIN_CA8" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA8.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA9" protect="rw">
      <bits name="rTX_GAIN_CA9" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA9.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA10" protect="rw">
      <bits name="rTX_GAIN_CA10" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA10.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA11" protect="rw">
      <bits name="rTX_GAIN_CA11" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA11.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA12" protect="rw">
      <bits name="rTX_GAIN_CA12" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA12.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA13" protect="rw">
      <bits name="rTX_GAIN_CA13" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA13.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA14" protect="rw">
      <bits name="rTX_GAIN_CA14" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA14.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA15" protect="rw">
      <bits name="rTX_GAIN_CA15" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA15.</comment>
      </bits>
    </reg32>
  </module>
</archive>


<archive relative = "nb_smartscheduler.xml">

<module name="nb_smartscheduler" category="NBIOT_PHY">
 
  <reg32 name="rSS_START" protect="wo">
    <bits access="wo" name="rSS_START" pos="0:0" rst="0x0">
      <comment>Pulse, which start the engine of SS. </comment>
    </bits>
  </reg32>
  
  <reg32 name="rSS_CMD_BADDR" protect="rw">
    <bits access="rw" name="rSS_CMD_BADDR" pos="31:0" rst="0x0">
      <comment>Base address of memroy where store the command of smartscheduler. </comment>
    </bits>
  </reg32>

  <reg32 name="rSS_CTRL_CFG" protect="rw">
    <bits access="rw" name="rSS_CMD_LEN" pos="15:0" rst="0x0">
      <comment>The length of command. </comment>
    </bits>
    <bits access="rw" name="rCMD_END_MODE" pos="16:16" rst="0x0">
      <comment>Mode select for finish fetching smartscheduler command.
1'b0: Command length mode.
1'b1: Instruction mode. 
      </comment>
    </bits>
  </reg32>

  <reg32 name="rSS_APB_BADDR" protect="rw">
    <bits access="rw" name="rSS_APB_BADDR" pos="31:0" rst="0x0">
      <comment>The base address of NB APB bus, for register programing
      </comment>
    </bits>
</reg32>

  <reg32 name="rSS_AHB_BADDR" protect="rw">
    <bits access="rw" name="rSS_AHB_BADDR" pos="31:0" rst="0x0">
      <comment>The base address of NB AHB bus, for memory programming. 
      </comment>
    </bits>
  </reg32>

  <reg32 name="rSS_TIMER" protect="rw">
    <bits access="rw" name="rSS_TIMER" pos="31:0" rst="0x0">
      <comment>Timer which is set to limit the time of smartscheduler processing. </comment>
    </bits>
  </reg32>

  <reg32 name="rSS_DMA_STATUS" protect="ro">
    <bits access="ro" name="rSS_DMA_STATUS" pos="13:0" rst="0x0">
      <comment>The status of DMA Engine. </comment>
    </bits>
    <bits access="ro" name="rSS_DMA_BUSY" pos="14:14" rst="0x0">
      <comment>DMA busy status.
1'b0: DMA idle;
1'b1: DMA busy 
      </comment>
    </bits>
    <bits access="ro" name="rSS_DMA_TIMEOUT" pos="15:15" rst="0x0">
      <comment>Indicated whether DMA timeout, unused.</comment>
    </bits>
    <bits access="ro" name="rSS_DMA_FIFO_STATUS" pos="19:16" rst="0x0">
      <comment>DMA FIFO STATUS.
[0]: FIFO empty;
[1]: FIFO half empty;
[2]: FIFO full;
[3]: FIFO half full.
      </comment>
    </bits>
  </reg32>
  
  <reg32 name="rSS_CTRL_STATUS" protect="ro">
    <bits access="ro" name="rSS_CUR_CMD_IDX" pos="15:0" rst="0x0">
      <comment>Current command index. </comment>
    </bits>
    <bits access="ro" name="rSS_CUR_STATUS" pos="19:16" rst="0x0">
      <comment>The current state of smartscheder control state machine. </comment>
    </bits>
    <bits access="ro" name="rSS_WAIT_ACC_DONE" pos="24:20" rst="0x0">
      <comment>whether smartscheduler is in waiting NB accelerator done.
1'b1: smartscheduler is in waiting NB accelerator done.
1'b0: smartscheduler is not in waiting NB accelerator done. 
      </comment>
    </bits>
  </reg32>

  <reg32 name="rSS_CUR_CMD_WORD" protect="ro">
    <bits access="ro" name="rSS_CUR_CMD_WORD" pos="31:0" rst="0x0">
      <comment>The command word which is executing. </comment>
    </bits>
  </reg32>

  <reg32 name="rSS_STATUS" protect="ro">
    <bits access="ro" name="rSS_DONE" pos="0:0" rst="0x0">
      <comment>
1'b0: Smartscheduler busy if it is started, otherwise, it is in idle
1'b1: Smartscheduler processing done;
      </comment>
    </bits>
    <bits access="ro" name="rSS_STATUS" pos="1:1" rst="0x0">
      <comment>
1'b0: Smartscheduler idle;
1'b1: Smartscheduler busy. 
      </comment>
   </bits>
     <bits access="ro" name="rSS_CMD_ERR_STATUS" pos="2:2" rst="0x0">
      <comment>
2'b00: No error;
2'b1: SS command configured error.
      </comment>
    </bits>
   <bits access="ro" name="rSS_TIMEOUT" pos="3:3" rst="0x0">
      <comment>
1'b0: no time out;
1'b1: Smartscheduler does not finish in a setting time.  
      </comment>
    </bits>
   <bits access="ro" name="rSS_CUR_CMD_IDX" pos="19:4" rst="0x0">
      <comment>Indicated the number of command is excuted when smartscheduler done. </comment>
   </bits>
   <bits access="ro" name="rSS_RESTART_ERR_STATUS" pos="20:20" rst="0x0">
      <comment>Smartscheduler is restarted when it is busy;
      </comment>
    </bits>
  </reg32>

</module>

</archive>


<archive relative = "nb_sp.xml">
  <module name="SP" category="NBIOT_PHY">
    <reg32 name="rSP_START" protect="w1c">
      <bits name="rSP_START" pos="0" access="w1c" rst="0x0">
        <comment>SP accelerator start</comment>
      </bits>
    </reg32>
    <reg32 name="rSP_CTRL" protect="rw">
      <bits name="rTIMEOUT_VAL" pos="15:0" access="rw" rst="0x7fff">
        <comment>Maximum time out value for TX bit level processing in 61.44Mhz unit</comment>
      </bits>
      <bits name="rNUM_CANDIDATE" pos="17:16" access="rw" rst="0">
        <comment>Number of Candidate
0: 1 candidate
1: 2 candidate
2: 3 candidate
3: 4 candidate</comment>
      </bits>
      <bits name="rDESCR_EN" pos="19" access="rw" rst="0">
        <comment>Descramble enable
0: Disable
1: enable</comment>
      </bits>
      <bits name="rDEROT_EN" pos="20" access="rw" rst="0">
        <comment>De-rotation Enable
0: Disable
1: Enable
</comment>
      </bits>
      <bits name="rDEMAP_LLR_FMT" pos="23:21" access="rw" rst="0">
        <comment>Demapping LLR format selection
0: 8.0x2^-5
1: 8.0x2^-4
2: 8.0x2^-3
3: 8.0x2^-2
4: 8.0x2^-1
5: 8.0x2^0
6: 8.0x2^1
7: 8.0x2^2

</comment>
      </bits>
      <bits name="rPDCCH_AL1_EN" pos="24" access="rw" rst="0">
        <comment>PDCCH AL1 enable
0: disable
1: enable

</comment>
      </bits>
    </reg32>
    <reg32 name="rSP_CFG1" protect="rw">
      <bits name="rIDATA_SIZE0" pos="9:0" access="rw" rst="0">
        <comment>Demap size 0</comment>
      </bits>
      <bits name="rIDATA_SIZE1" pos="25:16" access="rw" rst="0">
        <comment>Demap size 1</comment>
      </bits>
    </reg32>
    <reg32 name="rSP_CFG2" protect="rw">
      <bits name="rIDATA_SIZE3" pos="9:0" access="rw" rst="0">
        <comment>Demap size 3</comment>
      </bits>
      <bits name="rIDATA_SIZE2" pos="25:16" access="rw" rst="0">
        <comment>Demap size 2</comment>
      </bits>
    </reg32>
    <reg32 name="rSP_CFG3" protect="rw">
      <bits name="rCFG_IBUF_START_ADDR" pos="9:0" access="rw" rst="0">
        <comment>Configuration input buffer start address 0</comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="rSP_OMEM_START_ADDR" protect="rw">
      <bits name="rSP_OMEM_START_ADDR" pos="9:0" access="rw" rst="0">
        <comment>SP output memory start address</comment>
      </bits>
      <bits name="rSP_OMEM_START_SADDR" pos="25:16" access="rw" rst="0">
        <comment>SP output memory start address for last X1/X2 state value</comment>
      </bits>
    </reg32>
    <hole size="5*32"></hole>
    <reg32 name="rSP_STATUS" protect="r">
      <bits name="rDone" pos="0" access="wc" rst="0">
        <comment>(This bit is write 1 clear)
0: No Done
1: Done</comment>
      </bits>
      <bits name="rOverwritten" pos="1" access="r" rst="0">
        <comment>If Done bit would not clear before this engine re-engine would indicate overwritten output buffer
0: Normal
1: Error</comment>
      </bits>
      <bits name="rBUS_Error" pos="3:2" access="r" rst="0">
        <comment>0: Normal
1: Error
Bit 0: DSP control bus error
Bit 1: accelerator memory access collusion</comment>
      </bits>
      <bits name="rTimeout" pos="4" access="r" rst="0">
        <comment>0: Normal
1: Error</comment>
      </bits>
      <bits name="BMP Err" pos="5" access="r" rst="0">
        <comment>0: Normal
1: Error</comment>
      </bits>
      <bits name="rStatus" pos="6" access="r" rst="0">
        <comment>0: Idle
1: On-going</comment>
      </bits>
    </reg32>
  </module>
</archive>


<archive relative = "nb_tx_chsc.xml">

<module name="nb_tx_chsc" category="NBIOT_PHY">
 
  <reg32 name="rTX_CHSC_CTRL" protect="rw">
    <bits access="rw" name="rTIMEOUT_VAL" pos="15:0" rst="0x0">
      <comment>Maximum time out value for  TX channel-interleaver and scrambling in 61.44Mhz unit. </comment>
    </bits>
    <bits access="rw" name="rTX_CHSC_START_CTRL" pos="16" rst="0x0">
      <comment>Start control:
                     0: Trigger by SW start
                     1: Trigger by HW start.
      </comment>
    </bits>
    <bits access="rw" name="rCH_INTRLVR_EN" pos="17" rst="0x0">
      <comment>Channel interleaver enable
                     0: Disable
                     1: Enable.
      </comment>
    </bits>
    <bits access="rw" name="rSCR_EN" pos="18" rst="0x0">
      <comment>Scramble enable
                    0: Disable
                    1: Enable.
      </comment>
    </bits>
  </reg32>

  <reg32 name="rTX_CHSC_START" protect="w1c">
    <bits access="w1c" name="rTX_CHSC_START" pos="0" rst="0x0">
        <comment>TX channel-interleaver and scrambling accelerator 2 start. </comment>
    </bits>
  </reg32>
  
  <reg32 name="rMEM_START_ADDR" protect="rw">
    <bits access="rw" name="rBSEL_MEM_START_ADDR" pos="9:0" rst="0x0">
        <comment>Bit selection memory start address. </comment>
    </bits>
    <bits access="rw" name="rSCR_MEM_START_ADDR" pos="25:16" rst="0x0">
        <comment>Scramble memory start output address. </comment>
    </bits>
  </reg32>
  
  <reg32 name="rBSEL_CFG" protect="rw">
    <bits access="rw" name="NCB Minus" pos="14:0" rst="0x0">
        <comment>Ncb minus NCB - 3ND. </comment>
    </bits>
    <bits access="rw" name="rK0_MINUS" pos="30:16" rst="0x0">
        <comment>K0 minus: K0 position without dummy bit.. </comment>
    </bits>
  </reg32>
  
 <reg32 name="rCH_INTRLVR_CFG" protect="rw">
    <bits access="rw" name="rROW_SZ" pos="7:4" rst="0x0">
        <comment>Row size for ch-interleaver. </comment>
    </bits>
    <bits access="rw" name="rMOD_TYPE" pos="8" rst="0x0">
        <comment>Modulation type
                        0: BPSK
                        1: QPSK. 
        </comment>
    </bits>
    <bits access="rw" name="rCOL_SZ_PRE_RSE_UNIT" pos="22:16" rst="0x0">
        <comment>Column size in each resource unit:
                 (NUL_sym-1)* Nul_slot. 
        </comment>
    </bits>
  </reg32>
  
  <reg32 name="rSCR_SIZE" protect="rw">
    <bits access="rw" name="rSCR_SIZE" pos="7:0" rst="0x0">
        <comment>scrambling size in current subframe. </comment>
    </bits>
  </reg32>  
  
  <reg32 name="rSCR_X1" protect="rw">
    <bits access="rw" name="rSCR_X1" pos="30:0" rst="0x0">
        <comment>scrambling X1. </comment>
    </bits>
  </reg32>  

  <reg32 name="rSCR_X2" protect="rw">
    <bits access="rw" name="rSCR_X2" pos="30:0" rst="0x0">
        <comment>scrambling X2. </comment>
    </bits>
  </reg32> 

 <reg32 name="rLAST_SCR_X1" protect="rw">
    <bits access="rw" name="rLAST_SCR_X1" pos="30:0" rst="0x0">
        <comment>Last scrambling state in X1. </comment>
    </bits>
  </reg32> 

 <reg32 name="rLAST_SCR_X2" protect="rw">
    <bits access="rw" name="rLAST_SCR_X2" pos="30:0" rst="0x0">
        <comment>Last scrambling state in X2. </comment>
    </bits>
  </reg32>

 <reg32 name="rTX_CHSC_STATUS" protect="ro">
    <bits access="rw1c" name="Done" pos="0" rst="0x0">
        <comment>(This bit is read write 1 clear)
                   0: No Done
                   1: Done.
        </comment>
    </bits>
    <bits access="ro" name="Overwritten" pos="1" rst="0x0">
        <comment>If Done bit would not clear before this engine re-engine would indicate overwritten output buffer
                              0: Normal
                              1: Error
        </comment>
    </bits>
    <bits access="ro" name="BUS Error" pos="3:2" rst="0x0">
        <comment>0: Normal
                 1: Error
                 Bit 0: DSP control bus error
                 Bit 1: accelerator memory access collusion
        </comment>
    </bits>
    <bits access="ro" name="Timeout " pos="4" rst="0x0">
        <comment>0: Normal
                 1: Error
        </comment>
    </bits>
  </reg32>  
  

</module>

</archive>


<archive relative = "nb_tx_frontend.xml">
  <module name="nb_tx_frontend" category="NBIOT_PHY">
    <reg32 name="rTX_OS" protect="rw">
      <bits name="rPUSCH_OS1" pos="7:0" access="rw" rst="0x0">
        <comment>PUSCH offset1 for 3.75K process delay</comment>
      </bits>
      <bits name="rPUSCH_OS0" pos="15:8" access="rw" rst="0xb9">
        <comment>PUSCH offset0 for 15K process delay</comment>
      </bits>
      <bits name="rPRACH_OS01" pos="23:16" access="rw" rst="0x0">
        <comment>PRACH format0,1 offset for process delay</comment>
      </bits>
      <bits name="rPRACH_OS2" pos="31:24" access="rw" rst="0x0">
        <comment>PRACH format2 offset for process delay</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_TA_VALUE" protect="rw">
      <bits name="rTX_TA_VALUE" pos="10:0" access="rw" rst="0x0">
        <comment>TA Value</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_RACH_PARA_CFG" protect="rw">
      <bits name="rTX_RACH_START_ADJ" pos="10:0" access="rw" rst="0x0">
        <comment>the advance time of PRACH start adjustment</comment>
      </bits>
      <bits name="rPRACH_CP_LEN" pos="23:16" access="rw" rst="0x0">
        <comment>When PRACH_USER_DEFINE_EN = 1'b1, SW is able to set CP length by configured, which length is from 0 to 128</comment>
      </bits>
      <bits name="rPRACH_SEQ_NUM" pos="27:24" access="rw" rst="0x0">
        <comment>When PRACH_USER_DEFINE_EN = 1'b1, SW is able to change the transmit sequence number</comment>
      </bits>
      <bits name="rPRACH_USER_DEFINE_EN" pos="28" access="rw" rst="0x0">
        <comment>1'b1:DSP configure to change the CP length and repetition number of sequence
                 1'b0:PRACH CP length and repetition number is based on definition in 36.211
        </comment>
      </bits>
    </reg32>
   <reg32 name="rTX_RF_DELAY" protect="rw">
      <bits name="rTX_RF_DELAY" pos="15:0" access="rw" rst="0x0">
        <comment>RF delay from NBIOT_CORE to chip output</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_EN" protect="rw">
      <bits name="rPUSCH_EN" pos="0" access="rw" rst="0">
        <comment>PUSCH Enable</comment>
      </bits>
      <bits name="rPRACH_EN" pos="1" access="rw" rst="0">
        <comment>PRACH Enable</comment>
      </bits>
    </reg32>
    <reg32 name="rDELTA_CP_ADJ" protect="rw">
      <bits name="rDELTA_CP_ADJ" pos="5:0" access="rw" rst="0">
        <comment>Delta CP adjustment</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_CFG" protect="rw">
      <bits name="rTX_FRM_MODE" pos="0" access="rw" rst="0">
        <comment>TX frame mode for PUSCH</comment>
      </bits>
      <bits name="rMOD_TYPE" pos="1" access="rw" rst="0">
        <comment>Module type</comment>
      </bits>
      <bits name="rTX_BUF_IDX" pos="3:2" access="rw" rst="0">
        <comment>TX Buffer idx</comment>
      </bits>
      <bits name="rTONE_MODE" pos="4" access="rw" rst="0">
        <comment>PUSCH Tone mode</comment>
      </bits>
      <bits name="rSHORTEN_PUSCH_EN" pos="5" access="rw" rst="0">
        <comment>Shorten PUSCH Enable</comment>
      </bits>
      <bits name="rPUSCH_SC_IDX" pos="11:6" access="rw" rst="0">
        <comment>PUSCH Subcarrier POsition</comment>
      </bits>
      <bits name="rPRACH_CFG" pos="13:12" access="rw" rst="0">
        <comment>Type of prach
                 0: format 0 (cp length 66.7us)
                 1: format 1 (cp length 266.7us)
                 2: format 2 (cp length 800us)
                 3: reserved 
        </comment>
      </bits>
      <bits name="PAPR_MODE" pos="17:16" access="rw" rst="0">
        <comment>PAPR reduction enable
                 0: Normal
                 1: Tone 6 lower PAPR enable
                 2: Tone 6 upper PAPR enable
                 3: Tone 12 PAPR enable
        </comment>
      </bits>      
    </reg32>
    <reg32 name="rTX_GAIN" protect="rw">
      <bits name="rTX_GAIN" pos="11:0" access="rw" rst="0">
        <comment>TX Gain</comment>
      </bits>
      <bits name="rTX_BITSEL" pos="17:16" access="rw" rst="0">
        <comment>Bit selection for final tx doout
                 0: S14.11   
                 1: S14.10
                 2: S14.9
                 3: S14.8
        </comment>
      </bits>
    </reg32>
    <reg32 name="rPUSCH_CFG" protect="rw">
      <bits name="rTHETAL_SYMB_INCR" pos="7:0" access="rw" rst="0">
        <comment>thetal symbol incremental step value</comment>
      </bits>
      <bits name="rSYMB_NUM_MOD2" pos="8" access="rw" rst="0">
        <comment>symbol number modulo 2</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_FE_STATUS" protect="rw">
      <bits name="rMEM_BUS_ERR" pos="1:0" access="r" rst="0">
        <comment>memory bus access error</comment>
      </bits>
      <bits name="rTX_STATUS" pos="3:2" access="r" rst="0">
        <comment>TX Status, 2'b00: IDLE; 2'b01: PRACH; 2'b10: PUSCH 3.75K; 2'b11: PUSCH 15K</comment>
      </bits>
      <bits name="rTX_START_SF_IDX" pos="7:4" access="r" rst="0">
        <comment>Subframe index of NPRACH or NPUSCH transmitted</comment>
      </bits>
      <bits name="rTX_BUF_RDY_ERR" pos="10:8" access="r" rst="0">
        <comment>Bit[0]:Indicator Error 0:Normal 1:Error
                 Bit[2:1]: TX buffer index for corresponding ready error
                 (For checking TX_MDD data buffer ready or not)
        </comment>
      </bits>
      <bits name="rTX_CLR_BUF_RDY" pos="31" access="w" rst="0">
        <comment>TX Clear HW buffer ready
                 Write 1 Clear
                 Remark: It should program before the first subframe of TX_MDD start
        </comment>
      </bits>
    </reg32>
    <hole size="2*32" />
    <reg32 name="rPRACH_CMD_FIFO0" protect="rw">
      <bits name="rPRACH_SC_IDX" pos="7:0" access="rw" rst="0">
        <comment>PRACH sub-carrier index 0~147</comment>
      </bits>
      <bits name="RSV" pos="29:8" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPRACH_CFG_STATUS" pos="30" access="rw" rst="0">
        <comment>PRACH CFG Status</comment>
      </bits>
      <bits name="rPRACH_NXT_EN" pos="31" access="rw" rst="0">
        <comment>Next PRACH symbol group enabled</comment>
      </bits>
    </reg32>
    <reg32 name="rPRACH_CMD_FIFO1" protect="rw">
      <bits name="rPRACH_SC_IDX" pos="7:0" access="rw" rst="0">
        <comment>PRACH sub-carrier index 0~47</comment>
      </bits>
      <bits name="RSV" pos="29:6" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPRACH_CFG_STATUS" pos="30" access="rw" rst="0">
        <comment>PRACH CFG Status</comment>
      </bits>
      <bits name="rPRACH_NXT_EN" pos="31" access="rw" rst="0">
        <comment>Next PRACH symbol group enabled</comment>
      </bits>
    </reg32>
    <reg32 name="rPRACH_CMD_FIFO2" protect="rw">
      <bits name="rPRACH_SC_IDX" pos="7:0" access="rw" rst="0">
        <comment>PRACH sub-carrier index 0~47</comment>
      </bits>
      <bits name="RSV" pos="29:6" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPRACH_CFG_STATUS" pos="30" access="rw" rst="0">
        <comment>PRACH CFG Status</comment>
      </bits>
      <bits name="rPRACH_NXT_EN" pos="31" access="rw" rst="0">
        <comment>Next PRACH symbol group enabled</comment>
      </bits>
    </reg32>
    <reg32 name="rPRACH_CMD_FIFO3" protect="rw">
      <bits name="rPRACH_SC_IDX" pos="7:0" access="rw" rst="0">
        <comment>PRACH sub-carrier index 0~47</comment>
      </bits>
      <bits name="RSV" pos="29:6" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPRACH_CFG_STATUS" pos="30" access="rw" rst="0">
        <comment>PRACH CFG Status</comment>
      </bits>
      <bits name="rPRACH_NXT_EN" pos="31" access="rw" rst="0">
        <comment>Next PRACH symbol group enabled</comment>
      </bits>
    </reg32>
    <reg32 name="rPRACH_NXT_CMD_RD_PTR" protect="r">
      <bits name="rPRACH_NXT_CMD_RD_PTR" pos="1:0" access="r" rst="0">
        <comment>PRACH Nxt Command Read Pointer</comment>
      </bits>
      <bits name="RSV" pos="31:2" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <hole size="4*32" />
    <reg32 name="rTX_DOUT_CHECKSUM" protect="r">
      <bits name="rTX_DOUT_CHECKSUM" pos="30:0" access="r" rst="0">
        <comment>TX dout checksum</comment>
      </bits>
      <bits name="rTX_DOUT_CHECKSUM_EN" pos="31" access="rw" rst="0">
        <comment>TX dout Checksum Enable</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_FLT_TAIL_BIT_NUM" protect="rw">
      <bits name="rTX_FLT_TAIL_BIT_NUM" pos="7:0" access="rw" rst="0x80">
        <comment>Configurable Number of zero data padded at the end of TX transmission</comment>
      </bits>
    </reg32>
    <hole size="5*32" />
    <reg32 name="rLPF1_COEF0" protect="rw">
      <bits name="rLPF1_COEF0" pos="11:0" access="rw" rst="0">
        <comment>LPF1 coefficient0</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF1_COEF1" pos="27:16" access="rw" rst="0">
        <comment>LPF1 coefficient1</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF1_COEF1" protect="rw">
      <bits name="rLPF1_COEF2" pos="11:0" access="rw" rst="0">
        <comment>LPF1 coefficient2</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF1_COEF3" pos="27:16" access="rw" rst="0">
        <comment>LPF1 coefficient3</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF1_COEF2" protect="rw">
      <bits name="rLPF1_COEF4" pos="11:0" access="rw" rst="0">
        <comment>LPF1 coefficient4</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF1_COEF5" pos="27:16" access="rw" rst="0">
        <comment>LPF1 coefficient5</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <hole size="1*32" />
    <reg32 name="rLPF2_COEF0" protect="rw">
      <bits name="rLPF2_COEF0" pos="11:0" access="rw" rst="0">
        <comment>LPF2 coefficient0</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF2_COEF1" pos="27:16" access="rw" rst="0">
        <comment>LPF2 coefficient1</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF2_COEF1" protect="rw">
      <bits name="rLPF2_COEF2" pos="11:0" access="rw" rst="0">
        <comment>LPF2 coefficient2</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF2_COEF3" pos="27:16" access="rw" rst="0">
        <comment>LPF2 coefficient3</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF2_COEF2" protect="rw">
      <bits name="rLPF2_COEF4" pos="11:0" access="rw" rst="0">
        <comment>LPF2 coefficient4</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF2_COEF5" pos="27:16" access="rw" rst="0">
        <comment>LPF2 coefficient5</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <hole size="5*32" />
    <reg32 name="rPAPR_T12_COEF0" protect="rw">
      <bits name="rPAPR_T12_COEF0" pos="11:0" access="rw" rst="0">
        <comment>PAPR T12 coefficient0</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPAPR_T12_COEF1" pos="27:16" access="rw" rst="0">
        <comment>PAPR T12 coefficient1</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rPAPR_T12_COEF1" protect="rw">
      <bits name="rPAPR_T12_COEF3" pos="11:0" access="rw" rst="0">
        <comment>PAPR T12 coefficient3</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPAPR_T12_COEF2" pos="27:16" access="rw" rst="0">
        <comment>PAPR T12 coefficient2</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rPAPR_T12_COEF2" protect="rw">
      <bits name="rPAPR_T12_COEF5" pos="11:0" access="rw" rst="0">
        <comment>PAPR T12 coefficient5</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPAPR_T12_COEF4" pos="27:16" access="rw" rst="0">
        <comment>PAPR T12 coefficient4</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rPAPR_T12_COEF3" protect="rw">
      <bits name="rPAPR_T12_COEF7" pos="11:0" access="rw" rst="0">
        <comment>PAPR T12 coefficient7</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPAPR_T12_COEF6" pos="27:16" access="rw" rst="0">
        <comment>PAPR T12 coefficient6</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rPAPR_T12_COEF4" protect="rw">
      <bits name="rPAPR_T12_COEF9" pos="11:0" access="rw" rst="0">
        <comment>PAPR T12 coefficient10</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPAPR_T12_COEF8" pos="27:16" access="rw" rst="0">
        <comment>PAPR T12 coefficient8</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rPAPR_T12_COEF5" protect="rw">
      <bits name="rPAPR_T12_COEF11" pos="11:0" access="rw" rst="0">
        <comment>PAPR T12 coefficient11</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPAPR_T12_COEF10" pos="27:16" access="rw" rst="0">
        <comment>PAPR T12 coefficient10</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rPAPR_T06_COEF0" protect="rw">
      <bits name="rPAPR_T06_COEF0" pos="11:0" access="rw" rst="0">
        <comment>PAPR T06 coefficient0</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPAPR_T06_COEF1" pos="27:16" access="rw" rst="0">
        <comment>PAPR T06 coefficient1</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rPAPR_T06_COEF1" protect="rw">
      <bits name="rPAPR_T06_COEF3" pos="11:0" access="rw" rst="0">
        <comment>PAPR T06 coefficient3</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPAPR_T06_COEF2" pos="27:16" access="rw" rst="0">
        <comment>PAPR T06 coefficient2</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rPAPR_T06_COEF2" protect="rw">
      <bits name="rPAPR_T06_COEF5" pos="11:0" access="rw" rst="0">
        <comment>PAPR T06 coefficient5</comment>
      </bits>
      <bits name="RESERVED0" pos="15:12" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPAPR_T06_COEF4" pos="27:16" access="rw" rst="0">
        <comment>PAPR T06 coefficient4</comment>
      </bits>
      <bits name="RESERVED1" pos="31:28" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>

  </module>
</archive>


<archive relative = "nb_tx_mdd.xml">

<module name="nb_tx_mdd" category="NBIOT_PHY">
 
  <reg32 name="rTX_MDD_START" protect="wo">
    <bits access="wo" name="rTX_MDD_START" pos="0:0" rst="0x0">
      <comment>Pulse, which start the engine of TX_MDD. </comment>
    </bits>
  </reg32>

  <reg32 name="rTX_MDD_CTRL" protect="rw">
    <bits access="rw" name="rHW_MODE" pos="0:0" rst="0x0">
      <comment>Work Mode of TX_MDD.
1'b0: Software mode;
1'b1: Hardware mode. 
      </comment>
    </bits>
    <bits access="rw" name="rMDFT_EN" pos="1:1" rst="0x0">
      <comment>Enable of Modulation/DFT.
1'b0: Modulation/DFT diabled.
1'b1: Modulation/DFT enabled. 
      </comment>
    </bits>
    <bits access="rw" name="rMODULATION_EN" pos="2:2" rst="0x0">
      <comment>Enable of modulation.
1'b0: Modulation disabled;
1'b1: Modulation enabled. 
      </comment>
    </bits>
    <bits access="rw" name="rDMRS_EN" pos="3:3" rst="0x0">
      <comment>Enable of DMRS.
1'b0: DMRS generation disabled. 
1'b1: DMRS generation enabled. 
      </comment>
    </bits>
  </reg32>

  <reg32 name="rTX_MDD_CCFG" protect="rw">
    <bits access="rw" name="rPUSCH_FMT" pos="0:0" rst="0x0">
      <comment>PUSCH Format.
1'b0: PUSCH format1;
1'b1: PUSCH format2. 
      </comment>
    </bits>
    <bits access="rw" name="rSLOT_NUM" pos="2:1" rst="0x0">
      <comment>Slot number in a subframe.
set slot number to 1 when 3.75KHz.
set slot number to 2 when 15KHz. 
      </comment>
    </bits>
    <bits access="rw" name="rMOD_TYPE" pos="3:3" rst="0x0">
      <comment>Modulation Type.
1'b0: BPSK;
1'b1: QPSK. 
      </comment>
    </bits>
    <bits access="rw" name="rTONE_NUM" pos="7:4" rst="0x0">
      <comment>Sub-carrier number,which is 1, 3, 6, 12. </comment>
    </bits>
    <bits access="rw" name="rDMRS_SYMB_BMP" pos="14:8" rst="0x0">
      <comment>Symbol bit map for DMRS.
rDMRS_SYMB_BMP[n]==1'b0: this symbol is for PUSCH or NULL;
rDMRS_SYMB_BMP[n]==1'b1: this symbol is for DMRS;
n=0,1,2,...6. 
      </comment>
    </bits>
    <bits access="rw" name="rDFT_SYMB_BMP" pos="21:15" rst="0x0">
      <comment>Symbol bit map for DFT.
rDFT_SYMB_BMP[n]==1'b0: this symbol is for DMRS or NULL;
rDFT_SYMB_BMP[n]==1'b1: this symbol is for PUSCH.
n=0,1,2,...6. 
      </comment>
    </bits>
    <bits access="rw" name="rSR_EN" pos="22:22" rst="0x0">
      <comment>Scheduling request. 
1'b0: scheduling request disabled.
1'b1: scheduling request enabled..
      </comment>
    </bits>
  </reg32>

  <reg32 name="rTX_MDFT_CTRL" protect="rw">
    <bits access="rw" name="rRSE_MEM_IDX" pos="1:0" rst="0x0">
      <comment>Triple memory index for Resource mapping. </comment>
    </bits>
    <bits access="rw" name="rC_SR" pos="9:2" rst="0x0">
      <comment>For positive scheduling request, which be transmitted use NPUSCH format2, configured each SF. 
      </comment>
    </bits>
    <bits access="rw" name="rRSE_START_CARRIER_IDX" pos="13:10" rst="0x0">
      <comment>Allocated carrier index for PUSCH transmission. </comment>
    </bits>
  </reg32>

  <reg32 name="rTX_MOD_MEM_START_ADDR" protect="rw">
    <bits access="rw" name="rMOD_MEM_START_ADDR" pos="9:0" rst="0x0">
      <comment>The start address of memory5 which store the result of accelerator tx_chsc. </comment>
    </bits>
  </reg32>

  <reg32 name="rTX_DMRS_CFG" protect="rw">
    <bits access="rw" name="rCYCLIC_SHIFT" pos="1:0" rst="0x0">
      <comment>DMRS cyclic shift index, it came from high level configuration. 
3-tone: threeToneCyclicShift=0,1,2.
6-tone: sixToneCyclicShift=0,1,2,3.
12-tone: twelveToneCyclicShift=0.
used for multi-tone.
      </comment>
    </bits>
    <bits access="rw" name="rORTH_SEQ_IDX" pos="5:2" rst="0x0">
      <comment>TS36211, Table 5.5.2.2.1-2, sequence index.
rORTH_SEQ_IDX[1:0]: for slot0;
rORTH_SEQ_IDX[3:2]: for slot1. 
      </comment>
    </bits>
    <bits access="rw" name="rSLOT_NUM_MOD16" pos="9:6" rst="0x0">
      <comment>Sequence index of DMRS, we also can treat is as slot index as it increased slot by slot. </comment>
    </bits>
    <bits access="rw" name="rBASE_SEQ_IDX" pos="19:10" rst="0x0">
      <comment>Sequence group number, u.
rBASE_SEQ_IDX[4:0]: u for slot0;
rBASE_SEQ_IDX[9:5]: u for slot1, slot 1 is not same as slot0 when group hopping enabled. 
      </comment>
    </bits>
    <bits access="rw" name="rSEQ_C_N" pos="21:20" rst="0x0">
      <comment>Binary sequence c(n) for slot n and slot n+1, for single tone of PUSCH. </comment>
    </bits>
  </reg32>

  <reg32 name="rTX_MDD_TIMER" protect="rw">
    <bits access="rw" name="rTX_MDD_TIMER" pos="31:0" rst="0x0">
      <comment>Timer which is set to limit the time of tx_mdd processing. </comment>
    </bits>
  </reg32>

  <reg32 name="rTX_MDD_STATUS" protect="ro">
    <bits access="w1c" name="rMDD_DONE_STATUS" pos="0:0" rst="0x0">
      <comment>Tx MDD done status.
1'b0: TX MDD ongoing/IDLE;
1'b1: TX MDD done. 
      </comment>
    </bits>
    <bits access="w1c" name="rTRIP_MEM0_STATUS" pos="1:1" rst="0x0">
      <comment>
1'b0: the data in memory are invalid or has been read by SW;
1'b1: the data in memory are valid.
after HW write data to this memory, this bit will be set by HW;
after SW read data from this memory, this bit will be clear by SW.
      </comment>
    </bits>
    <bits access="w1c" name="rTRIP_MEM1_STATUS" pos="2:2" rst="0x0">
      <comment>
1'b0: the data in memory are invalid or has been read by SW;
1'b1: the data in memory are valid.
after HW write data to this memory, this bit will be set by HW;
after SW read data from this memory, this bit will be clear by SW.
      </comment>
    </bits>
    <bits access="w1c" name="rTRIP_MEM2_STATUS" pos="3:3" rst="0x0">
      <comment>
1'b0: the data in memory are invalid or has been read by SW;
1'b1: the data in memory are valid.
after HW write data to this memory, this bit will be set by HW;
after SW read data from this memory, this bit will be clear by SW.
      </comment>
    </bits>
    <bits access="ro" name="rTRIP_MEM0_OVWR" pos="4:4" rst="0x0">
      <comment>
1'b0: This memory never over-wrote;
1'b1: This memory had beed over-wrote, which means HW write memory, but the data in memory has not been read.
      </comment>
    </bits>
    <bits access="ro" name="rTRIP_MEM1_OVWR" pos="5:5" rst="0x0">
      <comment>
1'b0: This memory never over-wrote;
1'b1: This memory had beed over-wrote, which means HW write memory, but the data in memory has not been read.
      </comment>
    </bits>
    <bits access="ro" name="rTRIP_MEM2_OVWR" pos="6:6" rst="0x0">
      <comment>
1'b0: This memory never over-wrote;
1'b1: This memory had beed over-wrote, which means HW write memory, but the data in memory has not been read.
      </comment>
    </bits>
    <bits access="ro" name="rMDD_STATUS" pos="7:7" rst="0x0">
      <comment>
1'b0: TX MDD idle;
1'b1: TX MDD busy.
      </comment>
    </bits>
    <bits access="ro" name="rMOD_STATUS" pos="8:8" rst="0x0">
      <comment>
1'b0: TX MDD modulation idle;
1'b1: TX MDD modulation busy.
      </comment>
    </bits>
    <bits access="ro" name="rDFT_STATUS" pos="9:9" rst="0x0">
      <comment>
1'b0: TX MDD DFT idle;
1'b1: TX MDD DFT busy.
      </comment>
    </bits>
    <bits access="ro" name="rDMRS_STATUS" pos="10:10" rst="0x0">
      <comment>
1'b0: TX MDD DMRS generation idle;
1'b1: TX MDD DMRS generation busy.
      </comment>
    </bits>
    <bits access="ro" name="rTX_MDD_MEM_BUS_ERR" pos="14:11" rst="0x0">
      <comment>
            [3:2]: Modulation memory bus error;
            [1:0]: RSE memory bus error.
      </comment>
    </bits>
    <bits access="ro" name="rTX_MDD_TIMEOUT" pos="15:15" rst="0x0">
      <comment>
        1'b0: TX MDD does not timeout;
        1'b1: TX MDD timeout.
      </comment>
    </bits>
  </reg32>
</module>

</archive>



<archive relative = "nb_tx_pusch_encoder.xml">
<module name="nb_tx_pusch_encoder" category="NBIOT_PHY">

  <reg32 name="PUSCH_ENC_CTRL" protect="rw">
    <bits access="rw" name="rTIMEOUT_VAL" pos="15:0" rst="0x0">
      <comment>Maximum time out value for pusch encoder in 61.44Mhz unit. </comment>
  </bits>    
  <bits access="rw" name="Swap" pos="18:16" rst="0x0">
      <comment>Endian SWAP control for bit, byte and word. </comment>
  </bits>             
  </reg32>

  <reg32 name="PUSCH_ENC_START" protect="wo">
    <bits access="wo" name="PUSCH_ENC_START" pos="0" rst="0x0">
      <comment> Write this register will trigger pusch encoder start </comment>
  </bits>              
  </reg32> 

  <reg32 name="TBS" protect="rw">
    <bits access="rw" name="TBS" pos="12:0" rst="0x0">
      <comment>TB Size for PUSCH. </comment>
  </bits>              
  </reg32>                 

  <reg32 name="ALPHA_INI" protect="rw">
    <bits access="rw" name="Alpha_ini" pos="12:0" rst="0x0">
      <comment>Alpha init value for QPP interleaver. </comment>
  </bits>              
  </reg32> 

  <reg32 name="ALPHA_STEP" protect="rw">
    <bits access="rw" name="Alpha_step" pos="12:0" rst="0x0">
      <comment>Alpha Step value for QPP interleaver. </comment>
  </bits>              
  </reg32> 

  <reg32 name="PUSCH_ENC_RD_ADDR" protect="rw">
    <bits access="rw" name="PUSCH_ENC_RD_ADDR" pos="9:0" rst="0x0">
      <comment>Rd address to DSP memory for pusch encoder. </comment>
  </bits>              
  </reg32>

  <reg32 name="PUSCH_ENC_WR_ADDR" protect="rw">
    <bits access="rw" name="PUSCH_ENC_WR_ADDR" pos="9:0" rst="0x0">
      <comment>WR address to DSP memory for pusch encoder. </comment>
  </bits>              
  </reg32>     

  <reg32 name="PUSCH_ENC_STATUS" protect="ro">
    <bits access="rw1c" name="Done" pos="0" rst="0x0">
        <comment>(This bit is read write 1 clear)
                   0: No Done
                   1: Done.
        </comment>
    </bits>
    <bits access="ro" name="Overwritten" pos="1" rst="0x0">
        <comment>Indicate overwritten happen for pusch encoder
                  0: Normal
                  1: Error
        </comment>
    </bits>
    <bits access="ro" name="BUS Error" pos="3:2" rst="0x0">
        <comment>Bit 0: DSP control bus error, 0-Normal, 1-Error
                 Bit 1: accelerator memory access collusion, 0-Normal, 1-Error
        </comment>
    </bits>
    <bits access="ro" name="Timeout " pos="4" rst="0x0">
        <comment>0: Normal
                 1: Error
        </comment>
    </bits>                                                    
  </reg32>     

</module>

</archive>


<archive relative = "nb_viterbi.xml">
  <module name="nb_viterbi" category="NBIOT_PHY">
    <reg32 name="rVD_DEC_START" protect="w">
      <bits name="rVD_DEC_START" pos="0" access="w" rst="0">
        <comment>Start trigger of one sequential decoding of viterbi decoder which is generated by writing '1' to this register</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CTRL" protect="rw">
      <bits name="rVD_PL_SIZE" pos="27:16" access="rw" rst="0">
        <comment>Payload size of CBs to be decoded in one sequential decoding</comment>
      </bits>
      <bits name="rVD_DEC_NUM" pos="15:13" access="rw" rst="0">
        <comment>Indicate the number(1~4) of coded blocks to be decoded in one sequential decoding process</comment>
      </bits>
      <bits name="rVD_DEINT_EN" pos="12" access="rw" rst="1">
        <comment>Function of de-interleaving in hardware enable/disable
        1: Enable
        0: Disable
        </comment>
      </bits>
      <bits name="rVD_CRCMASK_EN" pos="11" access="rw" rst="0">
        <comment>CRC mask checking enable/disable(for RNTI and antenna port number)
        1: Enable
        0: Disable
        </comment>
      </bits>
      <bits name="rVD_CRC_TYPE" pos="10" access="rw" rst="0">
        <comment>Indicate the CRC type of  sequential decoding
        1:24
        0:16
        </comment>
      </bits>
      <bits name="Reserved" pos="9:1" access="rw" rst="0">
        <comment>Reserved bits</comment>
      </bits>
      <bits name="rVD_LVA_EN" pos="0" access="rw" rst="0">
        <comment>List viterbi mode enable/disable
        1: Enable
        0: Disable
        </comment>
      </bits>
    </reg32>
    <reg32 name="rVD_ADDR_CTRL" protect="rw">
      <bits name="rVD_VOR_ADDR_O" pos="29:21" access="rw" rst="0">
        <comment>This register indicates the start address of viterbi output odd buffer for payload.</comment>
      </bits>
      <bits name="rVD_VOR_ADDR_E" pos="20:12" access="rw" rst="0">
        <comment>This register indicates the start address of viterbi output even buffer for payload.</comment>
      </bits>
      <bits name="rVD_VIR_ADDR" pos="11:0" access="rw" rst="0">
        <comment>This register indicates the start address of data in viterbi input ram.</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CRC_MASK01" protect="rw">
      <bits name="rVD_CRC_MASK1" pos="31:16" access="rw" rst="0">
        <comment>Indicate CRC mask1(for RNTI and antenna port number)</comment>
      </bits>
      <bits name="rVD_CRC_MASK0" pos="15:0" access="rw" rst="0">
        <comment>Indicate CRC mask0(for RNTI and antenna port number)</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CRC_MASK23" protect="rw">
      <bits name="rVD_CRC_MASK3" pos="31:16" access="rw" rst="0">
        <comment>Indicate CRC mask1(for RNTI and antenna port number)</comment>
      </bits>
      <bits name="rVD_CRC_MASK2" pos="15:0" access="rw" rst="0">
        <comment>Indicate CRC mask0(for RNTI and antenna port number)</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_LONG_CFG" protect="rw">
      <bits name="rVD_PL_SWAP" pos="26:24" access="rw" rst="0">
        <comment>Reorder the 32bit data written to viterbi output buffer
    2:Reverse the word sequence in the Dword(1Dword)
    1: Reverse the byte sequence in every word(2words).
    0: Reverse the bit sequence in every byte(4bytes).</comment>
      </bits>
      <bits name="rVD_TIMECNT_LIMIT" pos="23:0" access="rw" rst="0xFFFFFF">
        <comment>In a sequential decoding process, if the corresponding time counter exceeds this set value of rVD_TIMECNT_LIMIT, bit4 of rVD_DEC_SATUS will be set to 1 and sent to high layer.</comment>
      </bits>
    </reg32>
    <hole size="2*32" />
    <reg32 name="rVD_VOR_EO" protect="rw">
      <bits name="rVD_VOR_EO" pos="0" access="rw" rst="0">
        <comment>Indicate even/odd viterbi output buffer to be written by decoder:
1: odd output buffer
0: even output buffer</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_DEC_CTRL" protect="rw">
      <bits name="rVD_SCALING_BW_Y" pos="31:28" access="rw" rst="0">
        <comment>Bit width of output scaling data's fractional part(S8.y)</comment>
      </bits>
      <bits name="rVD_SCALING_BW_X" pos="27:24" access="rw" rst="0">
        <comment>Bit width of input scaling data's fractional part(S16.x)</comment>
      </bits>
      <bits name="rVD_SCALING_FACTOR" pos="23:16" access="rw" rst="0">
        <comment>This register(U8.7) is multiplied by scaling input data(S16.x)</comment>
      </bits>
      <bits name="rVD_CRCMASK_BITMAP3" pos="15:12" access="rw" rst="0">
        <comment>Bitmap of CRC masks(0~3) used in blind decoding for the CB3 to be decoded</comment>
      </bits>
      <bits name="rVD_CRCMASK_BITMAP2" pos="11:8" access="rw" rst="0">
        <comment>Bitmap of CRC masks(0~3) used in blind decoding for the CB2 to be decoded</comment>
      </bits>
      <bits name="rVD_CRCMASK_BITMAP1" pos="7:4" access="rw" rst="0">
        <comment>Bitmap of CRC masks(0~3) used in blind decoding for the CB1 to be decoded</comment>
      </bits>
      <bits name="rVD_CRCMASK_BITMAP0" pos="3:0" access="rw" rst="0">
        <comment>Bitmap of CRC masks(0~3) used in blind decoding for the CB0 to be decoded</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CANDI_CFG" protect="rw">
      <bits name="rVD_SF_IDX" pos="19:16" access="rw" rst="0">
        <comment>Subframe index of current subframe on which DSP configure the decoding start siganl 'rVD_DEC_START'
        </comment>
      </bits>
      <bits name="rVD_CANDI_CFG_CB3" pos="15:12" access="rw" rst="0">
        <comment>15: Antenna number for candidate CB3(0: 1 antenna 1: 2 antennas)
14:12: 80ms SFN for candidate CB3
</comment>
      </bits>
      <bits name="rVD_CANDI_CFG_CB2" pos="11:8" access="rw" rst="0">
        <comment>15: Antenna number for candidate CB2(0: 1 antenna 1: 2 antennas)
14:12: 80ms SFN for candidate CB2
</comment>
      </bits>
      <bits name="rVD_CANDI_CFG_CB1" pos="7:4" access="rw" rst="0">
        <comment>15: Antenna number for candidate CB1(0: 1 antenna 1: 2 antennas)
14:12: 80ms SFN for candidate CB1
</comment>
      </bits>
      <bits name="rVD_CANDI_CFG_CB0" pos="3:0" access="rw" rst="0">
        <comment>15: Antenna number for candidate CB0(0: 1 antenna 1: 2 antennas)
14:12: 80ms SFN for candidate CB0
</comment>
      </bits>
    </reg32>
    <hole size="1*32" />
    <reg32 name="rVD_CRCREAD" protect="r">
      <bits name="rVD_CRCRESULT_O" pos="31:16" access="r" rst="0">
        <comment>CRC checking result of the corresponding code block for output buffer odd, and CRC results from CB0 to CB3 have to be written sequentially to bit[0]~bit[15] of this register. 
1: good    0: fail
If rVD_CRCMASK_EN =1, 4 bits mask checking result is reported for every candidate CB
    [31:28] for CB3(28:MASK0, 29:MASK1, 30:MASK2, 31:MASK3)
    [27:24] for CB2(24:MASK0, 25: MASK1, 26: MASK2, 27: MASK3)
    [23:20] for CB1(20: MASK0, 21: MASK1, 22: MASK2, 23: MASK3)
    [19:16] for CB0(16: MASK0, 17: MASK1, 18: MASK2, 19: MASK3)
And if rVD_CRCMASK_EN =0, 1 bit crc checking result is reported for every candidate CB
    [28] for CB3
    [24] for CB2
    [20] for CB1
    [16] for CB0</comment>
      </bits>
      <bits name="rVD_CRCRESULT_E" pos="15:0" access="r" rst="0">
        <comment>CRC check result of the corresponding code block for output buffer even, and CRC results from CB0 to CB3 have to be written sequentially to bit[0]~bit[15] of this register. 
1: good    0: fail
If rVD_CRCMASK_EN =1, 4 bits mask checking result is reported for every candidate CB
    [15:12] for CB3(12: MASK0, 13: MASK1, 14: MASK2, 15: MASK3)
    [11:8] for CB2(8: MASK0, 9: MASK1, 10: MASK2, 11: MASK3)
    [7:4] for CB1(4: MASK0, 5: MASK1, 6: MASK2, 7: MASK3)
    [3:0] for CB0(0: MASK0, 1: MASK1, 2: MASK2, 3: MASK3)
And if rVD_CRCMASK_EN =0, 1 bit crc checking result is reported for every candidate CB
    [12] for CB3
    [8] for CB2
    [4] for CB1
    [0] for CB0</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_SERREAD01_E" protect="r">
      <bits name="rVD_SER_1" pos="27:16" access="r" rst="0">
        <comment>Symbol error number of the candidate CB1</comment>
      </bits>
      <bits name="Reserved" pos="15:12" access="r" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_SER_0" pos="11:0" access="r" rst="0">
        <comment>Symbol error number of the candidate CB0</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_SERREAD01_O" protect="r">
      <bits name="rVD_SER_1" pos="27:16" access="r" rst="0">
        <comment>Symbol error number of the candidate CB1</comment>
      </bits>
      <bits name="Reserved" pos="15:12" access="r" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_SER_0" pos="11:0" access="r" rst="0">
        <comment>Symbol error number of the candidate CB0</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_SERREAD23_E" protect="r">
      <bits name="rVD_SER_3" pos="27:16" access="r" rst="0">
        <comment>Symbol error number of the candidate CB1</comment>
      </bits>
      <bits name="Reserved" pos="15:12" access="r" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_SER_2" pos="11:0" access="r" rst="0">
        <comment>Symbol error number of the candidate CB0</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_SERREAD23_O" protect="r">
      <bits name="rVD_SER_3" pos="27:16" access="r" rst="0">
        <comment>Symbol error number of the candidate CB1</comment>
      </bits>
      <bits name="Reserved" pos="15:12" access="r" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_SER_2" pos="11:0" access="r" rst="0">
        <comment>Symbol error number of the candidate CB0</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CANDI_RPT_E" protect="r">
      <bits name="rVD_CANDI_RPT_E" pos="31:0" access="r" rst="0">
        <comment>Report some configurations to MCU for output buffer even
    [31:20] Report payload size
    [19:0]  Report configuration of register 'rVD_CANDI_CFG'</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CANDI_RPT_O" protect="r">
      <bits name="rVD_CANDI_RPT_O" pos="31:0" access="r" rst="0">
        <comment>Report some configurations to MCU for output buffer even
    [31:20] Report payload size
    [19:0]  Report configuration of register 'rVD_CANDI_CFG'</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_DEC_STATUS" protect="rw">
      <bits name="rVD_ZERO_IND" pos="31:16" access="ro" rst="0">
        <comment>Result of checking in case that the decoded data is all zero 
    1:  All zero
    0 : Not zero data.
    Bit[23:16] for output even buffer:
    [17:16] for CB0, bit16 indicates list Viterbi 1st path, bit17 indicates list Viterbi 2nd path(if 2nd path is needed )
    [19:18] for CB1, bit18 indicates list Viterbi 1st path, bit19 indicates list Viterbi 2nd path(if 2nd path is needed )
    [21:20] for CB2, bit20 indicates list Viterbi 1st path, bit21 indicates list Viterbi 2nd path(if 2nd path is needed )
    [23:22] for CB3, bit22 indicates list Viterbi 1st path, bit23 indicates list Viterbi 2nd path(if 2nd path is needed )
    Bit[31:24]for output odd buffer;
    [25:24] for CB0, bit24 indicates list Viterbi 1st path, bit25 indicates list Viterbi 2nd path(if 2nd path is needed )
    [27:26] for CB1, bit26 indicates list Viterbi 1st path, bit27 indicates list Viterbi 2nd path(if 2nd path is needed )
    [29:28] for CB2, bit28 indicates list Viterbi 1st path, bit29 indicates list Viterbi 2nd path(if 2nd path is needed )
    [31:30] for CB3, bit30 indicates list Viterbi 1st path, bit31 indicates list Viterbi 2nd path(if 2nd path is needed )
    For NPDSCH, only bit[17:16] and bit[25:24] are used for CB0.</comment>
      </bits>
      <bits name="Reserved" pos="15:9" access="ro" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_VOR_REQ_FAIL" pos="8:7" access="ro" rst="0">
        <comment>Viterbi-in ram reading error</comment>
      </bits>
      <bits name="rVD_VIR_REQ_FAIL" pos="6:5" access="ro" rst="0">
        <comment>Viterbi output buffer writing error</comment>
      </bits>
      <bits name="rVD_TIMECNT_OUT" pos="4" access="w1c" rst="0">
        <comment>This bit indicate that the time counter is exceed the limit of set value</comment>
      </bits>
      <bits name="rVD_VOR_OVERWRITE" pos="3:2" access="w1c" rst="0">
        <comment>3: This bit is to indicate that the odd memory is overwritten or not before 'UPDATED' is cleared.
2: This bit is to indicate that the even memory is overwritten or not before 'UPDATED' is cleared.</comment>
      </bits>
      <bits name="rVD_VOR_UPDATED" pos="1:0" access="w1c" rst="0">
        <comment>1: This bit is to indicate that the odd memory is updated or not.
0: This bit is to indicate that the even memory is updated or not.</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_DEC_L1C_STATUS" protect="rw">
      <bits name="rVD_ZERO_IND" pos="31:16" access="ro" rst="0">
        <comment>Result of checking in case that the decoded data is all zero 
    1:  All zero
    0 : Not zero data.
    Bit[23:16] for output even buffer:
    [17:16] for CB0, bit16 indicates list Viterbi 1st path, bit17 indicates list Viterbi 2nd path(if 2nd path is needed )
    [19:18] for CB1, bit18 indicates list Viterbi 1st path, bit19 indicates list Viterbi 2nd path(if 2nd path is needed )
    [21:20] for CB2, bit20 indicates list Viterbi 1st path, bit21 indicates list Viterbi 2nd path(if 2nd path is needed )
    [23:22] for CB3, bit22 indicates list Viterbi 1st path, bit23 indicates list Viterbi 2nd path(if 2nd path is needed )
    Bit[31:24]for output odd buffer;
    [25:24] for CB0, bit24 indicates list Viterbi 1st path, bit25 indicates list Viterbi 2nd path(if 2nd path is needed )
    [27:26] for CB1, bit26 indicates list Viterbi 1st path, bit27 indicates list Viterbi 2nd path(if 2nd path is needed )
    [29:28] for CB2, bit28 indicates list Viterbi 1st path, bit29 indicates list Viterbi 2nd path(if 2nd path is needed )
    [31:30] for CB3, bit30 indicates list Viterbi 1st path, bit31 indicates list Viterbi 2nd path(if 2nd path is needed )
    For NPDSCH, only bit[17:16] and bit[25:24] are used for CB0.</comment>
      </bits>
      <bits name="Reserved" pos="15:9" access="ro" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_VOR_REQ_FAIL" pos="8:7" access="ro" rst="0">
        <comment>Viterbi-in ram reading error</comment>
      </bits>
      <bits name="rVD_VIR_REQ_FAIL" pos="6:5" access="ro" rst="0">
        <comment>Viterbi output buffer writing error</comment>
      </bits>
      <bits name="rVD_TIMECNT_OUT" pos="4" access="w1c" rst="0">
        <comment>This bit indicate that the time counter is exceed the limit of set value</comment>
      </bits>
      <bits name="rVD_VOR_OVERWRITE" pos="3:2" access="w1c" rst="0">
        <comment>3: This bit is to indicate that the odd memory is overwritten or not before 'UPDATED' is cleared.
2: This bit is to indicate that the even memory is overwritten or not before 'UPDATED' is cleared.</comment>
      </bits>
      <bits name="rVD_VOR_UPDATED" pos="1:0" access="w1c" rst="0">
        <comment>1: This bit is to indicate that the odd memory is updated or not.
0: This bit is to indicate that the even memory is updated or not.</comment>
      </bits>
    </reg32>

  </module>
</archive>


<archive relative="pmuc.xml">
  <module name="pmuc" category="System">
    <reg protect="rw" name="clock_select">
      <bits access="r" name="clock_select_reserved_0" pos="31:7" rst="0">
      </bits>
      <bits access="rw" name="sel_pclk_gpt" pos="6:5" rst="0">
        <comment>
          0/1: gclk 2: rc_26m_div 3: xtal26m 
        </comment>
      </bits>
      <bits access="rw" name="pm2_sel_pclk_lptop" pos="4:3" rst="0">
      </bits>
      <bits access="rw" name="sel_pclk_lptop" pos="2:1" rst="0">
        <comment>
          pclk_lptop source select: 0: rc26m 1: rc26m_div 2: xtal52m_div 3: clk_32k_root
        </comment>
      </bits>
      <bits access="rw" name="sel_32k_src" pos="0" rst="0">
        <comment>
          clk_32k_root source select: 0: clk_32k from pmic 1: clk_32k_div
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="xtal26m_to_32k_divider_ctrl">
      <bits access="r" name="xtal26m_to_32k_divider_ctrl_reserved_0" pos="31" rst="0">
      </bits>
      <bits access="r" name="div_lp_mode_h" pos="30" rst="0">
        <comment>
          32k divider work mode. 0: normal mode, 1: low power mode.
        </comment>
      </bits>
      <bits access="rw" name="xtal_clk6m5_en" pos="29" rst="0">
        <comment>
          clk_xtal6p5m gen 32k enable
        </comment>
      </bits>
      <bits access="rw" name="step_offset_nor" pos="28:16" rst="0">
        <comment>
          32k divider normal mode step
        </comment>
      </bits>
      <bits access="rw" name="step_offset_lp" pos="15:3" rst="0">
        <comment>
          32k divider lp mode step
        </comment>
      </bits>
      <bits access="rw" name="div_lp_mode_h_reg" pos="2" rst="0">
        <comment>
          Lp mode value
        </comment>
      </bits>
      <bits access="rw" name="div_lp_mode_h_dr" pos="1" rst="0">
        <comment>
          Lp mode direct control
        </comment>
      </bits>
      <bits access="rw" name="step_offset_update" pos="0" rst="0">
        <comment>
          Update the Step Offset Value for 32k divider
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_uart1_cfg">
      <bits access="r" name="clk_uart1_cfg_reserved_0" pos="31:29" rst="0">
      </bits>
      <bits access="rw" name="ip_clk_disable_uart1" pos="28" rst="0">
        <comment>
          disable uart1 clock
        </comment>
      </bits>
      <bits access="rw" name="dbg_disable_acg_clk_uart1" pos="27" rst="0">
      </bits>
      <bits access="rw" name="sel_clk_uart1" pos="26:25" rst="0">
        <comment>
          uart1 clock source select: 0: clk_32k_root 1: clk_xtal6p5m 2: clk_xtal52m 3: clk_rc26m_div
        </comment>
      </bits>
      <bits access="rc" name="uart1_div_update" pos="24" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          uart1 clock divider update
        </comment>
      </bits>
      <bits access="rw" name="uart1_div_denom" pos="23:10" rst="14">
        <comment>
          uart1 clock divider denom
        </comment>
      </bits>
      <bits access="rw" name="uart1_div_num" pos="9:0" rst="1">
        <comment>
          uart1 clock divider num
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_uart2_cfg">
      <bits access="r" name="clk_uart2_cfg_reserved_0" pos="31:29" rst="0">
      </bits>
      <bits access="rw" name="ip_clk_disable_uart2" pos="28" rst="0">
        <comment>
          disable uart2 clock
        </comment>
      </bits>
      <bits access="rw" name="dbg_disable_acg_clk_uart2" pos="27" rst="0">
      </bits>
      <bits access="rw" name="sel_clk_uart2" pos="26:25" rst="0">
        <comment>
          uart2 clock source select: 0: clk_32k_root 1: clk_xtal6p5m 2: clk_xtal52m 3: clk_rc26m_div
        </comment>
      </bits>
      <bits access="rc" name="uart2_div_update" pos="24" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          uart2 clock divider update
        </comment>
      </bits>
      <bits access="rw" name="uart2_div_denom" pos="23:10" rst="14">
        <comment>
          uart2 clock divider denom
        </comment>
      </bits>
      <bits access="rw" name="uart2_div_num" pos="9:0" rst="1">
        <comment>
          uart2 clock divider num
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rc26m_div_cfg">
      <bits access="r" name="rc26m_div_cfg_reserved_0" pos="31:25" rst="0">
      </bits>
      <bits access="rc" name="rc26m_div_update" pos="24" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          rc26m clock divider update
        </comment>
      </bits>
      <bits access="rw" name="rc26m_div_denom" pos="23:10" rst="2">
        <comment>
          rc26m clock divider denom
        </comment>
      </bits>
      <bits access="rw" name="rc26m_div_num" pos="9:0" rst="1">
        <comment>
          rc26m clock divider num
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ip_clk_disable_ctrl">
      <bits access="r" name="ip_clk_disable_ctrl_reserved_0" pos="31:14" rst="0">
      </bits>
      <bits access="rw" name="dbg_disable_acg_pclk" pos="13:7" rst="0">
      </bits>
      <bits access="rw" name="iomux_clk_disable" pos="6" rst="0">
      </bits>
      <bits access="rw" name="gpio_clk_disable" pos="5" rst="0">
      </bits>
      <bits access="rw" name="gpt1_clk_disable" pos="4" rst="0">
      </bits>
      <bits access="rw" name="uart2_clk_disable" pos="3" rst="0">
      </bits>
      <bits access="rw" name="uart1_clk_disable" pos="2" rst="0">
      </bits>
      <bits access="rw" name="lps_clk_disable" pos="1" rst="0">
      </bits>
      <bits access="rw" name="timer_clk_disable" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ip_soft_rst_ctrl">
      <bits access="r" name="ip_soft_rst_ctrl_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="pmu_reg_soft_rst" pos="7" rst="1">
      </bits>
      <bits access="rw" name="iomux_soft_rst" pos="6" rst="1">
      </bits>
      <bits access="rw" name="gpio_soft_rst" pos="5" rst="1">
      </bits>
      <bits access="rw" name="gpt1_soft_rst" pos="4" rst="1">
      </bits>
      <bits access="rw" name="uart2_soft_rst" pos="3" rst="1">
      </bits>
      <bits access="rw" name="uart1_soft_rst" pos="2" rst="1">
      </bits>
      <bits access="rw" name="lps_soft_rst" pos="1" rst="1">
      </bits>
      <bits access="rw" name="timer_soft_rst" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="rc26m_ctrl">
      <bits access="r" name="rc26m_ctrl_reserved_0" pos="31:14" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_rc_osc_rsvd" pos="13:10" rst="0">
      </bits>
      <bits access="rw" name="pu_rc26m_dr" pos="9" rst="0">
        <comment>
          rc26m power on direct control
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rc_osc_pu" pos="8" rst="1">
        <comment>
          0x1: enable  0x1: disable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_ibias_ctrl" pos="7" rst="0">
        <comment>
          0x0: low current bias 0x1: high current bias
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rc_osc_res_ctrl" pos="6:3" rst="6">
        <comment>
          osc tuning res: 0x0 min res 0x1 min+res1  0x15 max res
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rc_osc_cap_tune" pos="2:0" rst="3">
        <comment>
          osc tuning cap: 0x0 min cap 0x1 min+cap1  0x7 max cap
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pmu_wakeup_mask">
      <bits access="r" name="pmu_wakeup_mask_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="bypass_ana_wakeup" pos="7" rst="0">
      </bits>
      <bits access="rw" name="bypass_dbg_wakeup" pos="6" rst="0">
      </bits>
      <bits access="rw" name="bypass_lps_wakeup" pos="5" rst="0">
      </bits>
      <bits access="rw" name="bypass_gpt_wakeup" pos="4" rst="0">
      </bits>
      <bits access="rw" name="bypass_timer_wakeup" pos="3" rst="0">
      </bits>
      <bits access="rw" name="bypass_uart2_wakeup" pos="2" rst="0">
      </bits>
      <bits access="rw" name="bypass_uart1_wakeup" pos="1" rst="0">
      </bits>
      <bits access="rw" name="bypass_gpio_wakeup" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_wakeup_clr">
      <bits access="r" name="pmu_wakeup_clr_reserved_0" pos="31:9" rst="0">
      </bits>
      <bits access="rc" name="ext_rst_wakeup_clr" pos="8" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="ana_wakeup_clr" pos="7" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="dbg_wakeup_clr" pos="6" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="lps_wakeup_clr" pos="5" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="gpt_wakeup_clr" pos="4" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="timer_wakeup_clr" pos="3" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="uart2_wakeup_clr" pos="2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="uart1_wakeup_clr" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="gpio_wakeup_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="pmu_wakeup_status">
      <bits access="r" name="pmu_wakeup_status_reserved_0" pos="31:9" rst="0">
      </bits>
      <bits access="r" name="ext_rst_wakeup_status" pos="8" rst="0">
      </bits>
      <bits access="r" name="ana_wakeup_status" pos="7" rst="0">
      </bits>
      <bits access="r" name="dbg_wakeup_status" pos="6" rst="0">
      </bits>
      <bits access="r" name="lps_wakeup_status" pos="5" rst="0">
      </bits>
      <bits access="r" name="gpt_wakeup_status" pos="4" rst="0">
      </bits>
      <bits access="r" name="timer_wakeup_status" pos="3" rst="0">
      </bits>
      <bits access="r" name="uart2_wakeup_status" pos="2" rst="0">
      </bits>
      <bits access="r" name="uart1_wakeup_status" pos="1" rst="0">
      </bits>
      <bits access="r" name="gpio_wakeup_status" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmuc_int_mask">
      <bits access="r" name="pmuc_int_mask_reserved_0" pos="31:3" rst="0">
      </bits>
      <bits access="rw" name="bua_det_int_mask" pos="2" rst="0">
      </bits>
      <bits access="rw" name="pmu_pu_ready_int_mask" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pmu_pu_done_int_mask" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmuc_int_clr">
      <bits access="r" name="pmuc_int_clr_reserved_0" pos="31:3" rst="0">
      </bits>
      <bits access="rc" name="bua_det_int_clr" pos="2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="pmu_pu_ready_int_clr" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="pmu_pu_done_int_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="pmuc_int_status">
      <bits access="r" name="pmuc_int_status_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="r" name="bua_det_int_cause" pos="5" rst="0">
      </bits>
      <bits access="r" name="pmu_pu_ready_int_cause" pos="4" rst="0">
      </bits>
      <bits access="r" name="pmu_pu_done_int_cause" pos="3" rst="0">
      </bits>
      <bits access="r" name="bua_det_int_status" pos="2" rst="0">
      </bits>
      <bits access="r" name="pmu_pu_ready_int_status" pos="1" rst="0">
      </bits>
      <bits access="r" name="pmu_pu_done_int_status" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="power_status">
      <bits access="r" name="power_status_reserved_0" pos="31:25" rst="0">
      </bits>
      <bits access="r" name="pu_dbb" pos="24" rst="0">
      </bits>
      <bits access="r" name="iso_lptop" pos="23" rst="0">
      </bits>
      <bits access="r" name="resetb_dbb" pos="22" rst="0">
      </bits>
      <bits access="r" name="iso_bb_top" pos="21" rst="0">
      </bits>
      <bits access="r" name="resetb_bb_top" pos="20" rst="0">
      </bits>
      <bits access="r" name="pu_bb_top" pos="19" rst="0">
      </bits>
      <bits access="r" name="pu_rf_ana" pos="18" rst="0">
      </bits>
      <bits access="r" name="pu_rc26m" pos="17" rst="0">
      </bits>
      <bits access="r" name="xtal26m_lp_mode" pos="16" rst="0">
      </bits>
      <bits access="r" name="pu_xtal26m" pos="15" rst="0">
      </bits>
      <bits access="r" name="chip_sleep" pos="14" rst="0">
      </bits>
      <bits access="r" name="pmu_pu_done" pos="13" rst="0">
      </bits>
      <bits access="r" name="pmu_pu_ready" pos="12" rst="0">
      </bits>
      <bits access="r" name="pmu_wakeup_exist" pos="11" rst="0">
      </bits>
      <bits access="r" name="pmu_pm02_sw_state" pos="10:6" rst="0">
      </bits>
      <bits access="r" name="first_pwron_state" pos="5:3" rst="0">
      </bits>
      <bits access="r" name="pmu_pm_state" pos="2:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="mem_power_status_0">
      <bits access="r" name="mem_power_status_0_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="r" name="ram_ret2n" pos="29:15" rst="0">
      </bits>
      <bits access="r" name="ram_ret1n" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="mem_power_status_1">
      <bits access="r" name="mem_power_status_1_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="r" name="ram_pgen" pos="29:15" rst="0">
      </bits>
      <bits access="r" name="ram_vce_pu" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="power_mode_ctrl_0">
      <bits access="r" name="power_mode_ctrl_0_reserved_0" pos="31:23" rst="0">
      </bits>
      <bits access="rw" name="pm2_skip_wait_xtal_before_dbb" pos="22" rst="0">
      </bits>
      <bits access="r" name="bua_det_latch" pos="21" rst="0">
      </bits>
      <bits access="rw" name="bua_det_normal_func_enable" pos="20" rst="0">
      </bits>
      <bits access="rw" name="efuse_read_disable" pos="19" rst="0">
      </bits>
      <bits access="rw" name="mem_ret_mode" pos="18" rst="0">
        <comment>
          0: mode1 1: mode2
        </comment>
      </bits>
      <bits access="rw" name="reg_pu_done" pos="17" rst="0">
        <comment>
          soft confirm pu_done
        </comment>
      </bits>
      <bits access="rc" name="reg_pd_bb_top" pos="16" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="reg_pu_bb_top" pos="15" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="reg_pd_rf_ana" pos="14" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="reg_pu_rf_ana" pos="13" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="reg_pu_xtal26m" pos="12" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="reg_pd_xtal26m" pos="11" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="reg_lp_xtal26m" pos="10" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="reg_pu_rc26m" pos="9" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="reg_pd_rc26m" pos="8" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="pm2_wakeup_pu_bb" pos="7" rst="1">
      </bits>
      <bits access="rw" name="pm2_wakeup_pu_rf" pos="6" rst="1">
      </bits>
      <bits access="rw" name="pm2_wakeup_xtal26m_mode" pos="5:4" rst="1">
        <comment>
          0: pd 1: pu 2: lp
        </comment>
      </bits>
      <bits access="rw" name="pm2_xtal26m_lp_mode" pos="3" rst="0">
        <comment>
          0: pd 1: lp
        </comment>
      </bits>
      <bits access="rw" name="pm2_pd_rc26m" pos="2" rst="1">
      </bits>
      <bits access="rw" name="power_mode" pos="1:0" rst="0">
        <comment>
          0: active 2: sleep 3: psm
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="power_mode_ctrl_1">
      <bits access="r" name="power_mode_ctrl_1_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="pm2_pd_ram" pos="14:0" rst="0">
        <comment>
          1: pm2 power down ram
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="delay_time_ctrl">
      <bits access="r" name="delay_time_ctrl_reserved_0" pos="31:26" rst="0">
      </bits>
      <bits access="rw" name="vrf_pd_time" pos="25:22" rst="15">
        <comment>
          vrf_pd_time
        </comment>
      </bits>
      <bits access="rw" name="adie_pu_time" pos="21:14" rst="63">
        <comment>
          pm2 wakeup wait adie pu time, default is 2ms
        </comment>
      </bits>
      <bits access="rw" name="dbb_rst_rls_time" pos="13:7" rst="127">
        <comment>
          time delay before dbb reset release, reg value * 30us, default is 4ms
        </comment>
      </bits>
      <bits access="rw" name="xtal_rdy_time" pos="6:0" rst="80">
        <comment>
          default is 2.5ms
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pmu_power_dr_ctrl">
      <bits access="r" name="pmu_power_dr_ctrl_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="rw" name="sim_io_ret" pos="29:28" rst="0">
      </bits>
      <bits access="rw" name="psram_io_ret" pos="27" rst="0">
      </bits>
      <bits access="rw" name="pclk_sw_dr" pos="26" rst="0">
      </bits>
      <bits access="rw" name="reg_resetb_efs" pos="25" rst="0">
      </bits>
      <bits access="rw" name="resetb_efs_dr" pos="24" rst="0">
      </bits>
      <bits access="rw" name="pu_dbb_dr" pos="23" rst="0">
      </bits>
      <bits access="rw" name="reg_pu_dbb" pos="22" rst="0">
      </bits>
      <bits access="rw" name="iso_lptop_dr" pos="21" rst="0">
      </bits>
      <bits access="rw" name="reg_iso_lptop" pos="20" rst="0">
      </bits>
      <bits access="rw" name="resetb_dbb_dr" pos="19" rst="0">
      </bits>
      <bits access="rw" name="reg_resetb_dbb" pos="18" rst="1">
      </bits>
      <bits access="rw" name="pu_rf_ana_dr" pos="17" rst="0">
      </bits>
      <bits access="rw" name="reg_pu_rf_ana" pos="16" rst="0">
      </bits>
      <bits access="rw" name="reg_resetb_bb_top" pos="15" rst="1">
      </bits>
      <bits access="rw" name="resetb_bb_top_dr" pos="14" rst="0">
      </bits>
      <bits access="rw" name="reg_iso_bb_top" pos="13" rst="0">
      </bits>
      <bits access="rw" name="iso_bb_top_dr" pos="12" rst="0">
      </bits>
      <bits access="rw" name="reg_pu_bb_top" pos="11" rst="0">
      </bits>
      <bits access="rw" name="pu_bb_top_dr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="xtal26m_lp_mode_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="reg_xtal26m_lp_mode_en" pos="8" rst="0">
      </bits>
      <bits access="rw" name="pu_xtal26m_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="reg_pu_xtal26m" pos="6" rst="0">
      </bits>
      <bits access="rw" name="pmu_pu_ready_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="reg_pmu_pu_ready" pos="4" rst="0">
      </bits>
      <bits access="rw" name="pmu_pu_done_dr" pos="3" rst="0">
      </bits>
      <bits access="rw" name="reg_pmu_pu_done" pos="2" rst="0">
      </bits>
      <bits access="rw" name="chip_sleep_dr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="reg_chip_sleep" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mem_power_ctrl_0">
      <bits access="r" name="mem_power_ctrl_0_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="rw" name="ram_vce_pu_dr" pos="29:15" rst="0">
        <comment>
          ram vce power down direct control
        </comment>
      </bits>
      <bits access="rw" name="reg_ram_vce_pu" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mem_power_ctrl_1">
      <bits access="r" name="mem_power_ctrl_1_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="rw" name="ram_pgen_dr" pos="29:15" rst="0">
        <comment>
          ram pgen direct control
        </comment>
      </bits>
      <bits access="rw" name="reg_ram_pgen" pos="14:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mem_power_ctrl_2">
      <bits access="r" name="mem_power_ctrl_2_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="rw" name="ram_ret_dr" pos="29:15" rst="0">
        <comment>
          ram retention direct control
        </comment>
      </bits>
      <bits access="rw" name="reg_ram_ret1n" pos="14:0" rst="32767">
      </bits>
    </reg>
    <reg protect="rw" name="mem_power_ctrl_3">
      <bits access="r" name="mem_power_ctrl_3_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="reg_ram_ret2n" pos="14:0" rst="32767">
      </bits>
    </reg>
    <reg protect="rw" name="dcxo_ctrl_0">
      <bits access="rw" name="xtal_reg_bit" pos="31:28" rst="8">
      </bits>
      <bits access="rw" name="xtal_vamp_ibit" pos="27:24" rst="4">
      </bits>
      <bits access="rw" name="xtal_fix_ibit" pos="23:19" rst="24">
      </bits>
      <bits access="rw" name="xtal_capbank" pos="18:11" rst="128">
      </bits>
      <bits access="rw" name="xtal_clk11_en" pos="10" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk10_en" pos="9" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk9_en" pos="8" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk8_en" pos="7" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk7_en" pos="6" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk6_en" pos="5" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk5_en" pos="4" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk4_en" pos="3" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk3_en" pos="2" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk2_en" pos="1" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk1_en" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="dcxo_ctrl_1">
      <bits access="rw" name="xtal_din" pos="31:18" rst="8192">
      </bits>
      <bits access="rw" name="xtal_rda_hlsel" pos="17:16" rst="3">
      </bits>
      <bits access="rw" name="xtal_ck6m5_en" pos="15" rst="0">
      </bits>
      <bits access="rw" name="xtal_ck26m_en" pos="14" rst="1">
      </bits>
      <bits access="rw" name="xtal_rsvd" pos="13:10" rst="3">
      </bits>
      <bits access="rw" name="xdrv_pu" pos="9" rst="0">
      </bits>
      <bits access="rw" name="xdrv_reg_bit" pos="8:5" rst="8">
      </bits>
      <bits access="rw" name="xdrv_pu_gps" pos="4" rst="0">
      </bits>
      <bits access="rw" name="xdrv_drv_en" pos="3:0" rst="15">
      </bits>
    </reg>
    <reg protect="rw" name="dcxo_lp_ctrl_0">
      <bits access="r" name="dcxo_lp_ctrl_0_reserved_0" pos="31:14" rst="0">
      </bits>
      <bits access="rw" name="xtal_din" pos="13:0" rst="8192">
      </bits>
    </reg>
    <reg protect="rw" name="dcxo_lp_ctrl_1">
      <bits access="r" name="dcxo_lp_ctrl_1_reserved_0" pos="31:19" rst="0">
      </bits>
      <bits access="rw" name="xtal_vamp_ibit" pos="18:15" rst="0">
      </bits>
      <bits access="rw" name="xtal_fix_ibit" pos="14:10" rst="3">
      </bits>
      <bits access="rw" name="xtal_capbank" pos="9:2" rst="128">
      </bits>
      <bits access="rw" name="xtal_rda_hlsel" pos="1:0" rst="3">
      </bits>
    </reg>
    <reg protect="rw" name="pad_ctrl">
      <bits access="r" name="pad_ctrl_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="ibit_adie_if" pos="15:14" rst="2">
      </bits>
      <bits access="rw" name="clk_26m_wpu" pos="13:12" rst="0">
      </bits>
      <bits access="rw" name="clk_26m_wpd" pos="11" rst="0">
      </bits>
      <bits access="rw" name="sleep_wpu" pos="10:9" rst="0">
      </bits>
      <bits access="rw" name="sleep_wpd" pos="8" rst="0">
      </bits>
      <bits access="rw" name="adi_sda_pu" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="adi_sda_pd" pos="5" rst="0">
      </bits>
      <bits access="rw" name="adi_sda_ie" pos="4" rst="1">
      </bits>
      <bits access="rw" name="adi_sda_se" pos="3" rst="1">
      </bits>
      <bits access="rw" name="adi_scl_pu" pos="2:1" rst="0">
      </bits>
      <bits access="rw" name="adi_scl_pd" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="clk_26m_pmic_cfg">
      <bits access="r" name="clk_26m_pmic_cfg_reserved_0" pos="31:26" rst="0">
      </bits>
      <bits access="rw" name="src_sel" pos="25" rst="0">
        <comment>
          0: rc26m 1: xtal26m
        </comment>
      </bits>
      <bits access="rc" name="div_update" pos="24" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="div_num" pos="23:14" rst="1">
      </bits>
      <bits access="rw" name="div_denom" pos="13:0" rst="4">
      </bits>
    </reg>
    <reg protect="rw" name="boundary_test_ctrl">
      <bits access="r" name="boundary_test_ctrl_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="r" name="clk_32k_ext" pos="5" rst="0">
      </bits>
      <bits access="r" name="resetb_ext" pos="4" rst="0">
      </bits>
      <bits access="r" name="ana_int" pos="3" rst="0">
      </bits>
      <bits access="r" name="bua_det" pos="2" rst="0">
      </bits>
      <bits access="rw" name="clk_26m_pmic" pos="1" rst="0">
      </bits>
      <bits access="rw" name="enable" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_rsvd_reg_0">
      <bits access="rw" name="data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_rsvd_reg_1">
      <bits access="rw" name="data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_rsvd_reg_2">
      <bits access="rw" name="data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_rsvd_reg_3">
      <bits access="rw" name="data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_rsvd_reg_4">
      <bits access="rw" name="data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_rsvd_reg_5">
      <bits access="rw" name="data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_rsvd_reg_6">
      <bits access="rw" name="data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_rsvd_reg_7">
      <bits access="rw" name="data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_rsvd_reg_8">
      <bits access="rw" name="data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rsvd_ports">
      <bits access="r" name="rsvd_ports_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="in" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="out" pos="7:0" rst="3">
      </bits>
    </reg>
    <reg protect="rw" name="otp_reg">
      <bits access="r" name="otp_reg_reserved_0" pos="31:13" rst="0">
      </bits>
      <bits access="rw" name="otp_reg_rsvd" pos="12:7" rst="0">
      </bits>
      <bits access="rw" name="force_enable_dbghost" pos="6" rst="0">
      </bits>
      <bits access="rw" name="force_enable_snidbg" pos="5" rst="0">
      </bits>
      <bits access="rw" name="force_enable_sidbg" pos="4" rst="0">
      </bits>
      <bits access="rw" name="force_enable_nidbg" pos="3" rst="0">
      </bits>
      <bits access="rw" name="force_enable_idbg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="force_enable_swd" pos="1" rst="0">
      </bits>
      <bits access="rw" name="otp_programmed" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="clk_xtal52m_div_cfg">
      <bits access="r" name="clk_xtal52m_div_cfg_reserved_0" pos="31:25" rst="0">
      </bits>
      <bits access="rc" name="update" pos="24" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="num" pos="23:14" rst="1">
      </bits>
      <bits access="rw" name="denom" pos="13:0" rst="4">
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "psram8_ctrl.xml">

<module name="psram8_ctrl" category="System">

  <reg name="ctrl_time" protect="rw">
    <bits access="rw" name="rl_type" pos="31:31" rst="0x0">
    </bits>
    <bits access="rw" name="rl" pos="29:24" rst="0x3">
    </bits>
    <bits access="rw" name="wl" pos="21:16" rst="0x0">
    </bits>
    <bits access="rw" name="w_tcph" pos="13:8" rst="0x7">
    </bits>
    <bits access="rw" name="r_tcph" pos="5:0" rst="0x3">
    </bits>
  </reg>

  <reg name="read_ctrl" protect="rw">
    <bits access="rw" name="fifo_rst_time" pos="17:12" rst="0x1">
    </bits>
    <bits access="rw" name="rd_start_mode" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw" name="opt_length" pos="7:4" rst="0x3">
    </bits>
    <bits access="rw" name="rd_start_num" pos="3:0" rst="0x7">
    </bits>
  </reg>

  <reg name="delay_final_add" protect="rw">
    <bits access="rw" name="delay_final_add_clk" pos="20:16" rst="0x1">
    </bits>
    <bits access="rw" name="delay_final_add_dqs_o" pos="12:8" rst="0x1">
    </bits>
    <bits access="rw" name="delay_final_add_dqs_i" pos="4:0" rst="0x1">
    </bits>
  </reg>

  <reg name="dqs_ctrl" protect="rw">
    <bits access="rw" name="o_dqs_u_delay" pos="31:24" rst="0x0">
    </bits>
    <bits access="rw" name="o_dqs_l_delay" pos="23:16" rst="0x0">
    </bits>
    <bits access="rw" name="i_dqs_u_delay" pos="15:8" rst="0x0">
    </bits>
    <bits access="rw" name="i_dqs_l_delay" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_ctrl" protect="rw">
    <bits access="rw" name="o_clk_delay" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="power_up" protect="rw">
    <bits access="rw" name="wake_up_trig" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw" name="wake_up_time" pos="19:12" rst="0xf">
    </bits>
      <bits access="r" name="init_done_state" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw" name="hw_power_pulse" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="sw_init_done" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="sw_power_level" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="power_time" protect="rw">
    <bits access="rw" name="rst_wait_time" pos="25:16" rst="0x3ff">
    </bits>
    <bits access="rw" name="rst_tcph_time" pos="13:8" rst="0x7">
    </bits>
    <bits access="rw" name="rst_acc_time" pos="5:0" rst="0x5">
    </bits>
  </reg>

  <reg name="reg_time" protect="rw">
    <bits access="rw" name="nop_time" pos="21:16" rst="0xf">
    </bits>
    <bits access="rw" name="send_reg_time" pos="13:8" rst="0x3">
    </bits>
    <bits access="rw" name="read_reg_time" pos="5:0" rst="0xf">
    </bits>
  </reg>

  <reg name="irsr" protect="r">
    <bits access="r" name="wrong_delay" pos="7:7" rst="0x0">
    </bits>
    <bits access="r" name="delay_updt" pos="6:6" rst="0x0">
    </bits>
    <bits access="r" name="rd_timeout" pos="5:5" rst="0x0">
    </bits>
    <bits access="r" name="init_done"  pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_d" pos="3:3" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_c" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_b" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_a" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="imr" protect="rw">
    <bits access="rw" name="wrong_delay" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw" name="delay_updt" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw" name="rd_timeout" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw" name="init_done"  pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_d" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_c" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_b" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_a" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="isr" protect="r">
    <bits access="r" name="wrong_delay" pos="7:7" rst="0x0">
    </bits>
    <bits access="r" name="delay_updt" pos="6:6" rst="0x0">
    </bits>
    <bits access="r" name="rd_timeout" pos="5:5" rst="0x0">
    </bits>
    <bits access="r" name="init_done"  pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_d" pos="3:3" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_c" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_b" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_a" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="icr" protect="rw">
    <bits access="rw" name="wrong_delay" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw" name="delay_updt" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw" name="rd_timeout" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw" name="init_done"  pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_d" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_c" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_b" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_a" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="debug_sel" protect="rw">
    <bits access="rw" name="debug_sel" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="timeout_val" protect="rw">
    <bits access="rw" name="timeout_value" pos="19:0" rst="0x7ff">
    </bits>
  </reg>

  <reg name="psram_free" protect="rw">
    <bits access="r" name="psram_free" pos="31:31" rst="0x1">
    </bits>
    <bits access="r" name="phy_state" pos="4:0" rst="0x0">
    </bits>
  </reg>

  <reg name="psram_version" protect="rw">
    <bits access="rw" name="psram_density" pos="31:30" rst="0x0">
    </bits>
    <bits access="r" name="psram_version" pos="3:0" rst="0x1">
    </bits>
  </reg>
  
  <reg name="delay_train" protect="rw">
    <bits access="rw" name="auto_cfg" pos="31:31" rst="0x0">
    </bits>
    <bits access="rw" name="delay_final_add" pos="30:28" rst="0x1">
    </bits>
    <bits access="rw" name="delay_threshold" pos="27:24" rst="0x4">
    </bits>
    <bits access="rw" name="wait_dll_value" pos="19:16" rst="0xf">
    </bits>
    <bits access="rw" name="init_trim" pos="14:12" rst="0x7">
    </bits>
    <bits access="rw" name="init_delay" pos="11:4" rst="0x0">
    </bits>
    <bits access="rw" name="delay_step" pos="3:2" rst="0x1">
    </bits>
    <bits access="rw" name="training_en" pos="1" rst="0x0">
    </bits>
  </reg>

  <reg name="dll_state" protect="rw">
    <bits access="rw" name="dll_locked" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw" name="real_path_delay" pos="15:8" rst="0x0">
    </bits>
    <bits access="rw" name="train_delay" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="delay_maxmin" protect="rw">
    <bits access="rw" name="train_delay_max" pos="15:8" rst="0x0">
    </bits>
    <bits access="rw" name="train_delay_min" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="arbi_ctrl" protect="rw">
    <bits access="rw" name="arbi_alg" pos="31:31" rst="0x1">
    </bits>
    <bits access="rw" name="cur_ahb" pos="9:8" rst="0x0">
    </bits>
    <bits access="rw" name="cmd_priority" pos="7:0" rst="0x1e">
    </bits>
  </reg>

  <reg name="cnt_trans_a" protect="r">
    <bits access="r" name="cnt_trans_a" pos="31:0" rst="0x0">
    </bits>
  </reg>
  
  <reg name="cnt_trans_b" protect="r">
    <bits access="r" name="cnt_trans_b" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cnt_trans_c" protect="r">
    <bits access="r" name="cnt_trans_c" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cnt_trans_d" protect="r">
    <bits access="r" name="cnt_trans_d" pos="31:0" rst="0x0">
    </bits>
  </reg>
  
  <reg name="cnt_wait_a" protect="r">
    <bits access="r" name="cnt_wait_a" pos="31:0" rst="0x0">
    </bits>
  </reg>
  
  <reg name="cnt_wait_b" protect="r">
    <bits access="r" name="cnt_wait_b" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cnt_wait_c" protect="r">
    <bits access="r" name="cnt_wait_c" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cnt_wait_d" protect="r">
    <bits access="r" name="cnt_wait_d" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cnt_ctrl" protect="rw">
    <bits access="rw" name="cnt_stop_d" pos="7" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_start_d" pos="6" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_stop_c" pos="5" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_start_c" pos="4" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_stop_b" pos="3" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_start_b" pos="2" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_stop_a" pos="1" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_start_a" pos="0" rst="0x0">
    </bits>
  </reg>

  <reg name="burst_length" protect="rw">
    <bits access="rw" name="qpi_en" pos="31:31" rst="0x0">
    </bits>
    <bits access="rw" name="wrap512_en" pos="3" rst="0x0">
    </bits>
    <bits access="rw" name="wrap64_en" pos="2" rst="0x0">
    </bits>
    <bits access="rw" name="wrap32_en" pos="1" rst="0x0">
    </bits>
    <bits access="rw" name="wrap16_en" pos="0" rst="0x0">
    </bits>
  </reg>

  <reg name="data_pinmux" protect="rw">
    <bits access="rw" name="psram_data7_sel" pos="30:28" rst="0x7">
    </bits>
    <bits access="rw" name="psram_data6_sel" pos="26:24" rst="0x6">
    </bits>
    <bits access="rw" name="psram_data5_sel" pos="22:20" rst="0x5">
    </bits>
    <bits access="rw" name="psram_data4_sel" pos="18:16" rst="0x4">
    </bits>
    <bits access="rw" name="psram_data3_sel" pos="14:12" rst="0x3">
    </bits>
    <bits access="rw" name="psram_data2_sel" pos="10:8" rst="0x2">
    </bits>
    <bits access="rw" name="psram_data1_sel" pos="6:4" rst="0x1">
    </bits>
    <bits access="rw" name="psram_data0_sel" pos="2:0" rst="0x0">
    </bits>
  </reg>

  <hole size="32"/>

  <reg name="mr0" protect="rw">
    <bits access="rw" name="mr0" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mr1" protect="r">
    <bits access="r" name="mr1" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mr2" protect="r">
    <bits access="r" name="mr2" pos="31:0" rst="0x0">
    </bits>
  </reg>
  
  <reg name="mr3" protect="rw">
    <bits access="rw" name="mr3" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mr4" protect="rw">
    <bits access="rw" name="mr4" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <hole size="32"/>

  <reg name="mr6" protect="rw">
    <bits access="rw" name="mr6" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <hole size="32"/>

  <reg name="mr8" protect="rw">
    <bits access="rw" name="mr8" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <hole size="704"/>

  <reg name="cre" protect="rw">
    <bits access="rw" name="cre" pos="0:0" rst="0x0">
    </bits>
  </reg>

</module>
</archive>
<archive relative="rffe_reg.xml">
  <module name="rffe_reg" category="System">
    <reg protect="rw" name="cmd_mipi0">
      <bits access="rw" name="cmd_mipi_low" pos="15:0" rst="0">
        <comment>
          cmd_mipi_sr[15:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="cmd_mipi1">
      <bits access="rw" name="cmd_mipi_high" pos="15:0" rst="0">
        <comment>
          cmd_mipi_sr[31:16]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="data_mipi0">
      <bits access="rw" name="data_mipi_low" pos="15:0" rst="0">
        <comment>
          data_mipi_sr[15:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="data_mipi1">
      <bits access="rw" name="data_mipi_high" pos="15:0" rst="0">
        <comment>
          data_mipi_sr[31:16]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="data_out0">
      <bits access="r" name="data_out_low" pos="15:0" rst="0">
        <comment>
          data_out[15:0]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="data_out1">
      <bits access="r" name="data_out_high" pos="15:0" rst="0">
        <comment>
          data_out[31:16]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="data_valid">
      <bits access="r" name="reversed" pos="15:4" rst="0">
        <comment>
          REVERSED
        </comment>
      </bits>
      <bits access="r" name="data_valid" pos="3:0" rst="0">
        <comment>
          data_valid_byte[3:0]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="mipi_busy">
      <bits access="r" name="reversed" pos="15:3" rst="0">
        <comment>
          REVERSED
        </comment>
      </bits>
      <bits access="r" name="master_busy_mipi" pos="2" rst="0">
      </bits>
      <bits access="r" name="master_busy_mipi_sync_pclk" pos="1" rst="0">
      </bits>
      <bits access="r" name="master_busy_mipi_sync_spi" pos="0" rst="0">
        <comment>
          mipi_master_busy
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "rf_if.xml">
<module name="rf_if" category="Baseband">
  
   
   <reg protect="rw" name="Buffer">
    <bits access="rw" name="Rx_Tx data" pos="31:0" rst="no">
      <comment>In read mode this register contains the sample received on the Rx chain. I component is located on bit[15:0] and Q component is located on bit[31:16].
      <br />This register accesses to the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data sample arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overflow error will also occur.
      <br />The data written[29:0] into this register is the data transmitted. Any attempt to write data when the FIFO is full results in the write data being lost.
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="Ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="Disable" value="0" />
        <option name="Enable" value="1" />
      </options>
      <comment>Turn on/off the rf_if interface</comment>
    </bits>
    
    <bits access="rw" name="DigRF Enable" pos="1" rst="0">
      <options>
        <option name="Disable" value="0"><comment>Analog more selected</comment></option>
        <option name="Enable" value="1"><comment>DigRF mode selected</comment></option>
      </options>
      <comment>Turn on/off the DigRF mode</comment>
    </bits>
    
    <bits access="rw" name="Rx overflow Enable" pos="4" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Rx fifo overflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Rx fifo overflow interrupt</comment></option>
      </options>
      <comment>Rx Fifo Overflow interrupt Enable</comment>
    </bits>
    
    <bits access="rw" name="Rx Cal Bypass" pos="5" rst="1">
      <options>
        <option name="Enabled" value="0" />
        <option name="Bypassed" value="1" />
      </options>
      <comment>Calibration bypass</comment>
    </bits>
    
    <bits access="rw" name="Rx Swap I_Q" pos="6" rst="0">
      <options>
        <option name="NO" value="0"><comment>No Swap</comment></option>
        <option name="YES" value="1"><comment>Swap I/Q</comment></option>
      </options>
      <comment>Rx swap I/Q</comment>
    </bits>
    
    <bits access="rw" name="Rx Force ADC On" pos="7" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Rx_On output controlled by TCO_RX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced ADC on;Rx_On output always high</comment></option>
      </options>
      <comment>Force Rx On. This bit is used only with the analog option.</comment>
    </bits>

    <bits access="rw" name="Rx Force Dec On" pos="8" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, decimator controlled by Rx_dec_on signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; decimator always on</comment></option>
      </options>
      <comment>Force Decimator On</comment>
    </bits>
    
    <bits access="w" name="Rx Force SOC" pos="9" rst="no">
      <comment>Force start of calibation in receive mode
        <br />Writing a 1 to this bit launch the calibration phase. Write only bit, this bit doesn't need to be cleared.
      </comment>
    </bits>
    
    <bits access="w" name="Rx Fifo Reset" pos="10" rst="no">
      <comment>Writing a 1 to this bit resets and flush the receive Fifo. 
        <br />Write only bit, this bit doesn't need to be cleared.
      </comment>
    </bits>
    
  
    <bits access="rw" name="Tx overflow Enable" pos="16" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Tx fifo overflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Tx fifo overflow interrupt</comment></option>
      </options>
      <comment>Tx Fifo Overflow interrupt Enable</comment>
    </bits>
    
    <bits access="rw" name="Tx underflow Enable" pos="17" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Tx fifo undeflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Tx fifo underflow interrupt</comment></option>
      </options>
      <comment>Tx Fifo Underflow interrupt Enable:</comment>
    </bits>
    
    <bits access="rw" name="Tx Force DAC On" pos="18" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_On output controlled by TCO_TX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced DAC on; Tx_On output always high</comment></option>
      </options>
      <comment>Force DAC On. This bit is used only with the analog option.</comment>
    </bits>
    
    <bits access="rw" name="Tx Force DAC Off" pos="19" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_On output controlled by TCO_TX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced DAC Off; Tx_On output always low</comment></option>
      </options>
      <comment>Force DAC Off. This bit is used only with the analog option.</comment>
    </bits>


    <bits access="rw" name="Tx Force oen" pos="20" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_Oen controlled by TCO_TX_OEN signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; Tx_Oen always high, Low pass output in HZ</comment></option>
      </options>
      <comment>Force Tx Oen. This bit is used only with the analog option.</comment>
    </bits>
  
    <bits access="rw" name="Tx Force GMSK On" pos="21" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, transmit serial interface controlled by TCO_GMSK_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; serializer always enabled</comment></option>
      </options>
      <comment>Force GMSK On.</comment>
    </bits>
    <bits access="rw" name="Tx Swap I_Q" pos="22" rst="0">
      <options>
        <option name="NO" value="0"><comment>No Swap</comment></option>
        <option name="YES" value="1"><comment>Swap I/Q</comment></option>
      </options>
      <comment>Tx swap I/Q. This bit is used only with the analog option.</comment>
    </bits>
 
    <bits access="w" name="Tx Fifo Reset" pos="23" rst="no">
      <comment>Writing a 1 to this bit resets and flush the transmit Fifo. 
        <br />Write only bit, this bit doesn.t need to be cleared.
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Rx Rate" pos="24" rst="1">
      <options>
        <option name="ONE" value="0"><comment>One sample per symbol</comment></option>
        <option name="TWO" value="1"><comment>Two samples per symbol</comment></option>
      </options>
      <comment>Rx rate for DigRF interface. This bit is used only when DigRF is enabled (DigRF Enabled)
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Rx Clk Pol" pos="25" rst="1">
      <comment>Change the polarity of the DigRF Rx clock. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br />0 = No inversion
        <br />1 = Invert clock polarity
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Tx mode" pos="26" rst="1">
      <options>
        <option name="Stream" value="0"></option>
        <option name="Block" value="1"></option>
      </options>
      <comment>Tx mode for the DigRF interface. This bit is used only when DigRF is enabled (DigRF Enabled)
      </comment>
    </bits>

    <bits access="rw" name="DigRF Tx Clk Pol" pos="27" rst="1">
      <comment>Change the polarity of the DigRF Rx clock. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br />0 = No inversion
        <br />1 = Invert clock polarity
      </comment>
    </bits>

    <bits access="rw" name="DigRF Sample Size" pos="30:28" rst="all1" display="hex">
      <comment>Shift input sample in DigRF mode only. 
        <br />The Rx sample are on 16-bit, this field select a variable of bit among 16.
        <br />000 = 16-bit selected
        <br />001 = 15-bit selected 
        <br />010 = 14-bit selected
        <br />011 = 13-bit selected
        <br />100 = 12-bit selected
      </comment>
    </bits>
    <bits access="rw" name="DigRF Alignement Select" pos="31" rst="1" display="hex">
      <comment>Select the sample alignement in DigRF mode only.. 
        <br />0 = MSB aligned sample
        <br />1 = LSB aligned sample 
      </comment>
    </bits>
  </reg>
  

    <reg protect="r" name="Status">
      <bits access="r" name="Rx Fifo level" pos="4:0" rst="0">
        <comment>Those bits indicate the number of data available in the Rx Fifo.</comment>
      </bits>
      <bits access="r" name="Tx Fifo level" pos="6:5" rst="0">
        <comment>Those bits indicate the number of data available in the Tx Fifo. Those data will be sent.
        </comment>
      </bits>
      <bits access="r" name="Rx Overflow Cause" pos="8" rst="0">
        <comment>Rx overflow cause register
        <br />This bit indicates that an interruption was generated when the Rx fifo is overflow. 
        <br />This bit is cleared when the Rx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Tx Overflow Cause" pos="9" rst="0">
        <comment>Tx overflow cause register
        <br />This bit indicates that an interruption was generated when the Tx fifo is overflow. 
        <br />This bit is cleared when the Tx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Tx Underflow Cause" pos="10" rst="0">
        <comment>Tx underflow cause register
        <br />This bit indicates that an interruption was generated when the Tx fifo is underflow. 
        <br />This bit is cleared when the Tx_underflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Rx Overflow Status" pos="16" rst="0">
        <comment>This bit indicates that the receiver received a new sample when the FIFO was already full. 
        <br />The new sample is discarded. This bit is cleared when the Rx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
      <bits access="r" name="Tx Overflow Status" pos="17" rst="0">
        <comment>This bit indicates that the user tried to write on the FIFO while it was already full. 
        <br />This bit is cleared when the Tx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
      <bits access="r" name="Tx Underflow Status" pos="18" rst="0">
        <comment>This bit indicates that the modulator tried to read on the FIFO while it was empty. 
        <br />This bit is cleared when the Tx_Underflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
    </reg>

    <reg protect="w" name="Interruption_clear">
      <bits access="w" name="Rx Overflow" pos="0" rst="no">
        <comment>Clear Rx Interrupt Overflow interrupt.
        </comment>
      </bits>
      <bits access="w" name="Tx Overflow" pos="1" rst="no">
        <comment>Clear Tx Interrupt Overflow interrupt.
        </comment>
      </bits>
      <bits access="w" name="Tx Underflow" pos="2" rst="no">
        <comment>Clear Tx Interrupt Underflow interrupt.
        </comment>
      </bits>
    </reg>
    <reg count="4" name="Tx Burst descriptor" protect="rw">
        <bits name="NB symbols" pos="7:0" access="rw" rst="0">
            <comment>Number of symbol to transmit
            </comment>
        </bits>
        <bits name="Modulation" pos="16" access="rw" rst="0">
            <comment>0 for GMSK, 1 for 8PSK 
            </comment>
        </bits>
        <bits name="End Burst" pos="24" access="rw" rst="0">
            <comment>Indicate an end of the transmit for this current burst
            </comment>
        </bits>
    </reg>

    <reg protect="r" name="Rx Offset">
      <bits access="r" name="Rx_Offset_I" pos="15:0" rst="all0" display="hex">
        <comment>Rx offset measured after calibration for I channel
        </comment>
      </bits>
      <bits access="r" name="Rx_Offset_Q" pos="31:16" rst="all0" display="hex">
        <comment>Rx offset measured after calibratio for Q channel
        </comment>
      </bits>
  </reg>

    <reg protect="rw" name="Rx Gain">
      <bits access="rw" name="Rx_Gain_dig" pos="9:0" rst="all0" display="hex">
        <comment>Rx Gain digital
        </comment>
      </bits>
      <bits access="rw" name="Rx_Gain_ana" pos="12:10" rst="all0" display="hex">
        <comment>Rx Gain analog
        </comment>
      </bits>
      <bits access="rw" name="Rx_Gain_en" pos="13" rst="all0" display="hex">
        <comment>Rx Gain  enable
        </comment>
      </bits>
  </reg>

    <hole size="192"/>

   
    
   <reg protect="w" name="rx_control">
     <bits access="w" name="enable_ctrl" pos="0" rst="no">
       <comment>Channel Enable, write one in this bit enable the channel.
       <br />When the channel is enabled, for a peripheral to memory transfer
       the DMA wait request from peripheral to start transfer. </comment>
     </bits>
 
     <bits access="w" name="disable_ctrl" pos="1" rst="no">
       <comment>Channel Disable, write one in this bit disable the channel.
       <br />When writing one in this bit, the current AHB transfer and current
       APB transfer (if one in progress) is completed and the channel is then
       disabled.</comment>
     </bits>

     <bits access="rw" name="burst_size" pos="16" rst="1">
      <comment>Burst size on AHB bus 
        <br />0 = Single access 
        <br />1 = burst Access (4 words). 
      </comment>
    </bits>

    <bits access="rw" name="fifo_mode" pos="17" rst="1">
      <comment>Set FIFO mode . <br />0 = no fifo mode, transfer stop when the
      current transfer counter reaches zero. Channel must be re-enabled for
      future transfer. <br />1 = Fifo mode, when the current AHB address
      counter reaches the end address of the FIFO. AHB address counter is
      reloaded with the initial value. In FIFO mode channel is not disabled at
      the end of the transfer.</comment>
    </bits>
   </reg>

   <reg protect="r" name="rx_status">
     <bits access="r" name="enable_ctrl" pos="0" rst="0">
       <options>
         <option name="DISABLE" value="0" />
 
         <option name="ENABLE" value="1" />
 
         <default />
       </options>
 
       <comment>In no fifo mode the channel is automatically disabled at the
       end of the transfer. In fifo mode the channel is disabled only when
       disabled write is performed in the control register. </comment>
     </bits>
 
     <bits access="r" name="fifo_empty" pos="1" rst="1">
       <comment>When 1 the fifo is empty </comment>
     </bits>
     
     <bits access="r" name="cause_nb_htc" pos="2" rst="0">
      <comment>Cause interrupt half tc  when fifo mode is enable.</comment>
    </bits>

     <bits access="r" name="nb_htc" pos="3" rst="0">
       <comment> Half of TC interrupt when fifo mode is enable status bit. </comment>
     </bits>

     <bits access="r" name="cause_itc" pos="4" rst="0">
      <comment>Cause interrupt End of TC.</comment>
    </bits>

    <bits access="r" name="cause_ief" pos="5" rst="0">
      <comment>Cause interrupt End of FIFO. </comment>
    </bits>

    <bits access="r" name="cause_ihtc" pos="6" rst="0">
      <comment>Cause interrupt Half Transfer Count (This interruption is
      generated when the IFC has transferred 96 word).</comment>
    </bits>
 
     <bits access="r" name="itc" pos="7" rst="0">
       <comment>End of TC interrupt status bit. </comment>
     </bits>

    <bits access="r" name="ief" pos="8" rst="0">
      <comment>End of FIFO interrupt status bit. </comment>
    </bits>

    <bits access="r" name="ihtc" pos="9" rst="0">
      <comment>Half TC interrupt status bit.</comment>
    </bits>

     <bits access="r" name="cur_tc" pos="31:10" rst="0x3fffff">
       <comment>Current value of transfer counter.</comment>
     </bits>
   </reg>
 
   <reg protect="rw" name="rx_start_addr">
     <bits access="rw" name="start_addr" pos="31:2" rst="0x3FFFFFFF" display="hex">
       <comment>AHB Start Address.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="rx_end_addr">
     <bits access="rw" name="end_addr"   pos="31:2" rst="0x3FFFFFFF" display="hex">
      <comment>The last page address of the FIFO, it is the first address not
      used for the FIFO. The start address of the FIFO is specified by the
      register AHB_ADDR and the last page address of the FIFO is specified by
      this field. The size of the fifo (END_ADDR - START_ADDR) must be a
      multiple of burst of 4x32-bits. </comment>
    </bits>
  </reg>


   <reg protect="rw" name="rx_tc_reg">
     <bits access="r" name="tc_reg" pos="21:0" rst="0x3FFFFF" display="hex">
     <comment>Transfer Count <br/>In no FIFO mode, this bit indicated
      the transfer size in 32-bits word to perform. Up to 2^18 32-bits word per
      transfer. <br/>In FIFO mode this field define, after how many
      transfer an interrupt in generated.</comment>
     </bits>
   </reg>

    <reg protect="rw" name="rx_int_mask">
    <bits access="rw" name="end_tc" pos="0" rst="0">
      <comment>End TC Mask interrupt. When one this interrupt is
      enabled.</comment>
    </bits>

    <bits access="rw" name="end_fifo" pos="1" rst="0">
      <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
      </comment>
    </bits>

    <bits access="rw" name="half_tc" pos="2" rst="0">
      <comment>Half TC Mask interrupt. When one this interrupt is
      enabled</comment>
    </bits>

    <bits access="rw" name="nb_half_tc" pos="3" rst="0">
      <comment>NB Half TC Mask interrupt. only fifo mode is enabled, When one this interrupt is
      enabled</comment>
    </bits>


</reg>

  <reg protect="rw" name="rx_int_clear">
    <bits access="c" name="end_tc" pos="0" rst="0">
      <comment>Write one to clear end of TC interrupt.</comment>
    </bits>

    <bits access="c" name="end_fifo" pos="1" rst="0">
      <comment>Write one to clear end of FIFO interrupt.</comment>
    </bits>

    <bits access="c" name="half_fifo" pos="2" rst="0">
      <comment>Write one to clear end of Half TC interrupt.</comment>
    </bits>

    <bits access="c" name="nb_half_fifo" pos="3" rst="0">
      <comment>Write one to clear end of Half TC (the real one) interrupt.</comment>
    </bits>
</reg>

   <reg protect="r" name="rx_cur_ahb_addr">
     <bits access="r" name="cur_ahb_addr" pos="31:0" rst="0x3ffe000">
       <comment>Current AHB address value.
       </comment>
     </bits>
   </reg>

   
   <reg protect="w" name="tx_control">
     <bits access="w" name="enable_ctrl" pos="0" rst="no">
       <comment>Channel Enable, write one in this bit enable the channel.
       <br />When the channel is enabled, for a peripheral to memory transfer
       the DMA wait request from peripheral to start transfer. </comment>
     </bits>
 
     <bits access="w" name="disable_ctrl" pos="1" rst="no">
       <comment>Channel Disable, write one in this bit disable the channel.
       <br />When writing one in this bit, the current AHB transfer and current
       APB transfer (if one in progress) is completed and the channel is then
       disabled.</comment>
     </bits>

     <bits access="rw" name="burst_size" pos="16" rst="1">
      <comment>Burst size on AHB bus 
        <br />0 = Single access 
        <br />1 = burst Access (4 words). 
      </comment>
    </bits>

    <bits access="rw" name="fifo_mode" pos="17" rst="1">
      <comment>Set FIFO mode . <br />0 = no fifo mode, transfer stop when the
      current transfer counter reaches zero. Channel must be re-enabled for
      future transfer. <br />1 = Fifo mode, when the current AHB address
      counter reaches the end address of the FIFO. AHB address counter is
      reloaded with the initial value. In FIFO mode channel is not disabled at
      the end of the transfer.</comment>
    </bits>
   </reg>

   <reg protect="r" name="tx_status">
     <bits access="r" name="enable_ctrl" pos="0" rst="0">
       <options>
         <option name="DISABLE" value="0" />
 
         <option name="ENABLE" value="1" />
 
         <default />
       </options>
 
       <comment>In no fifo mode the channel is automatically disabled at the
       end of the transfer. In fifo mode the channel is disabled only when
       disabled write is performed in the control register. </comment>
     </bits>
 
     <bits access="r" name="fifo_empty" pos="1" rst="1">
       <comment>When 1 the fifo is empty </comment>
     </bits>
     
     <bits access="r" name="cause_nb_htc" pos="2" rst="0">
      <comment>Cause interrupt half tc  when fifo mode is enable.</comment>
    </bits>

     <bits access="r" name="nb_htc" pos="3" rst="0">
       <comment> Half of TC interrupt when fifo mode is enable status bit. </comment>
     </bits>

     <bits access="r" name="cause_itc" pos="4" rst="0">
      <comment>Cause interrupt End of TC.</comment>
    </bits>

    <bits access="r" name="cause_ief" pos="5" rst="0">
      <comment>Cause interrupt End of FIFO. </comment>
    </bits>

    <bits access="r" name="cause_ihtc" pos="6" rst="0">
      <comment>Cause interrupt Half Transfer Count (This interruption is
      generated when the IFC has transferred 96 word).</comment>
    </bits>
 
     <bits access="r" name="itc" pos="7" rst="0">
       <comment>End of TC interrupt status bit. </comment>
     </bits>

    <bits access="r" name="ief" pos="8" rst="0">
      <comment>End of FIFO interrupt status bit. </comment>
    </bits>

    <bits access="r" name="ihtc" pos="9" rst="0">
      <comment>Half TC interrupt status bit.</comment>
    </bits>

     <bits access="r" name="cur_tc" pos="31:10" rst="0x3fffff">
       <comment>Current value of transfer counter.</comment>
     </bits>
   </reg>
 
   <reg protect="rw" name="tx_start_addr">
     <bits access="rw" name="start_addr" pos="31:2" rst="0x3FFFFFFF" display="hex">
       <comment>AHB Start Address.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="tx_end_addr">
     <bits access="rw" name="end_addr"   pos="31:2" rst="0x3FFFFFFF" display="hex">
      <comment>The last page address of the FIFO, it is the first address not
      used for the FIFO. The start address of the FIFO is specified by the
      register AHB_ADDR and the last page address of the FIFO is specified by
      this field. The size of the fifo (END_ADDR - START_ADDR) must be a
      multiple of burst of 4x32-bits. </comment>
    </bits>
  </reg>


   <reg protect="rw" name="tx_tc_reg">
     <bits access="r" name="tc_reg" pos="21:0" rst="0x3FFFFF" display="hex">
     <comment>Transfer Count <br/>In no FIFO mode, this bit indicated
      the transfer size in 32-bits word to perform. Up to 2^18 32-bits word per
      transfer. <br/>In FIFO mode this field define, after how many
      transfer an interrupt in generated.</comment>
     </bits>
   </reg>

    <reg protect="rw" name="tx_int_mask">
    <bits access="rw" name="end_tc" pos="0" rst="0">
      <comment>End TC Mask interrupt. When one this interrupt is
      enabled.</comment>
    </bits>

    <bits access="rw" name="end_fifo" pos="1" rst="0">
      <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
      </comment>
    </bits>

    <bits access="rw" name="half_tc" pos="2" rst="0">
      <comment>Half TC Mask interrupt. When one this interrupt is
      enabled</comment>
    </bits>

    <bits access="rw" name="nb_half_tc" pos="3" rst="0">
      <comment>NB Half TC Mask interrupt. only fifo mode is enabled, When one this interrupt is
      enabled</comment>
    </bits>


</reg>

  <reg protect="rw" name="tx_int_clear">
    <bits access="c" name="end_tc" pos="0" rst="0">
      <comment>Write one to clear end of TC interrupt.</comment>
    </bits>

    <bits access="c" name="end_fifo" pos="1" rst="0">
      <comment>Write one to clear end of FIFO interrupt.</comment>
    </bits>

    <bits access="c" name="half_fifo" pos="2" rst="0">
      <comment>Write one to clear end of Half TC interrupt.</comment>
    </bits>

    <bits access="c" name="nb_half_fifo" pos="3" rst="0">
      <comment>Write one to clear end of Half TC (the real one) interrupt.</comment>
    </bits>
</reg>

   <reg protect="r" name="tx_cur_ahb_addr">
     <bits access="r" name="cur_ahb_addr" pos="31:0" rst="0x3ffe000">
       <comment>Current AHB address value.
       </comment>
     </bits>
   </reg>

   
   <reg protect="rw" name="rfif_ctrl">
     <bits access="rw" name="dump_en" pos="0" rst="0x0" display="hex">
       <comment> dump the 'data from dfe to nb core' to mem</comment>
     </bits>
     
     <bits access="rw" name="dump_mode" pos="1" rst="0x0" display="hex">
         <comment> when the bit is 1, dump only when nb-core comes an pulse ,capture the set data numbers ,then stop
                   when the bit is 0, dump all bit normal dump mode </comment>
     </bits>

     <bits access="rw" name="dump_downsample" pos="2" rst="0x0" display="hex">
         <comment> when the bit is 1, downsample enable 
                   when the bit is 0, disable </comment>
     </bits>
 
     <bits access="rw" name="feed_dl" pos="4" rst="0x0" display="hex">
       <comment> get data from mem, simu the data format from dfe to nb core</comment>
     </bits>

     <bits access="rw" name="feed_ul" pos="5" rst="0x0" display="hex">
       <comment> get data from mem, simu the data format from nbcore to dfe</comment>
     </bits>

     <bits access="rw" name="feed_speed_div" pos="23:8" rst="0x20" display="hex">
         <comment> feed data rate  1.92MHz=0x20 192KHz=0x140, 96KHz=0x280, 38.4KHz=0x640, 32KHz=0x780  </comment>
     </bits>

     <bits access="r" name="feed_fifo_empty" pos="24" rst="0x1" display="hex">
       <comment> fifo empty siganl </comment>
     </bits>

     <bits access="r" name="dump_fifo_empty" pos="25" rst="0x1" display="hex">
       <comment> fifo empty signal</comment>
    </bits>

      <bits access="rw" name="feed_fifo_clr" pos="26" rst="0x0" display="hex">
        <comment> clr feed fifo point 
                </comment>
     </bits>

     <bits access="rw" name="dump_fifo_clr" pos="27" rst="0x0" display="hex">
         <comment> clr dump fifo point 
                    </comment>
     </bits>

     <bits access="rw" name="nb_debug" pos="31" rst="0x0" display="hex">
         <comment> when the bit is 1, nb use the rf_dma 
                   when the bit is 0, 2g use the rf_dma </comment>
     </bits>
   </reg>

   <hole size="224"/>
  
   <reg protect="rw" name="nb_if_irsr">
     <bits access="rw" name="dump_ovfl" pos="0" rst="0x0" display="hex">
       <comment> dump_ovfl irq </comment>
     </bits>

     <bits access="rw" name="dump_udfl" pos="1" rst="0x0" display="hex">
       <comment> dump_udfl irq </comment>
     </bits>

     <bits access="rw" name="feed_ovfl" pos="2" rst="0x0" display="hex">
       <comment> feed_ovfl irq </comment>
     </bits>

     <bits access="rw" name="feed_udfl" pos="3" rst="0x0" display="hex">
       <comment> feed_udfl irq </comment>
     </bits>
 
     <bits access="rw" name="dump_ovfl_real" pos="4" rst="0x0" display="hex">
       <comment> dump_ovfl  when  ifc is still working irq </comment>
     </bits>

     <bits access="rw" name="dump_udfl_real" pos="5" rst="0x0" display="hex">
       <comment> dump_udfl  when  ifc is still working irq </comment>
     </bits>
 </reg>

   <reg protect="rw" name="nb_if_imr">
     <bits access="rw" name="dump_ovfl" pos="0" rst="0x0" display="hex">
       <comment> dump_ovfl mask </comment>
     </bits>

     <bits access="rw" name="dump_udfl" pos="1" rst="0x0" display="hex">
       <comment> dump_udfl mask </comment>
     </bits>

     <bits access="rw" name="feed_ovfl" pos="2" rst="0x0" display="hex">
       <comment> feed_ovfl mask </comment>
     </bits>

     <bits access="rw" name="feed_udfl" pos="3" rst="0x0" display="hex">
       <comment> feed_udfl mask </comment>
     </bits>

     <bits access="rw" name="dump_ovfl_real" pos="4" rst="0x0" display="hex">
       <comment> dump_ovfl  when  ifc is still working  mask </comment>
     </bits>

     <bits access="rw" name="dump_udfl_real" pos="5" rst="0x0" display="hex">
       <comment> dump_udfl  when  ifc is still working  mask </comment>
     </bits>
 </reg>

   <reg protect="rw" name="nb_if_isr">
     <bits access="rw" name="dump_ovfl" pos="0" rst="0x0" display="hex">
       <comment> dump_ovfl  before mask irq source </comment>
     </bits>

     <bits access="rw" name="dump_udfl" pos="1" rst="0x0" display="hex">
       <comment> dump_udfl  before mask irq source </comment>
     </bits>

     <bits access="rw" name="feed_ovfl" pos="2" rst="0x0" display="hex">
       <comment> feed_ovfl  before mask irq source </comment>
     </bits>

     <bits access="rw" name="feed_udfl" pos="3" rst="0x0" display="hex">
       <comment> feed_udfl  before mask irq source </comment>
     </bits>

     <bits access="rw" name="dump_ovfl_real" pos="4" rst="0x0" display="hex">
       <comment> dump_ovfl  when  ifc is still working irq  source </comment>
     </bits>

     <bits access="rw" name="dump_udfl_real" pos="5" rst="0x0" display="hex">
       <comment> dump_udfl  when  ifc is still working irq source </comment>
     </bits>
 </reg>

   <reg protect="rw" name="nb_if_icr">
     <bits access="rw" name="dump_ovfl" pos="0" rst="0x0" display="hex">
       <comment> dump_ovfl clr irq </comment>
     </bits>

     <bits access="rw" name="dump_udfl" pos="1" rst="0x0" display="hex">
       <comment> dump_udfl clr irq </comment>
     </bits>

     <bits access="rw" name="feed_ovfl" pos="2" rst="0x0" display="hex">
       <comment> feed_ovfl clr irq </comment>
     </bits>

     <bits access="rw" name="feed_udfl" pos="3" rst="0x0" display="hex">
       <comment> feed_udfl clr irq </comment>
     </bits>

     <bits access="rw" name="dump_ovfl_real" pos="4" rst="0x0" display="hex">
       <comment> dump_ovfl  when  ifc is still working clr irq </comment>
     </bits>

     <bits access="rw" name="dump_udfl_real" pos="5" rst="0x0" display="hex">
       <comment> dump_udfl  when  ifc is still working clr irq </comment>
     </bits>
 </reg>

</module>
</archive>
<archive relative="rf_dig.xml">
  <module name="rf_dig" category="System">
    <hole size="4096"/>
    <reg protect="rw" name="reset_ctrl_reg">
      <bits access="r" name="reset_ctrl_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="resetn_reg" pos="0" rst="1">
        <comment>
          Interface reset , expect apb/ spi reg, active low
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="xcvsdm_reg0">
      <bits access="rw" name="freq_xcvsdm0" pos="15:0" rst="15124">
        <comment>
          bit [15:0] of RFPLL SDM frequency for GSM RX and NB RX/TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="xcvsdm_reg1">
      <bits access="rw" name="freq_xcvsdm1" pos="15:0" rst="13233">
        <comment>
          bit [31:16] of RFPLL SDM frequency for GSM RX and NB RX/TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="xcvsdm_reg2">
      <bits access="r" name="xcvsdm_reg2_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rw" name="freq_xcvsdm2" pos="2:0" rst="1">
        <comment>
          bit [34:32] of RFPLL SDM frequency for GSM RX and NB RX/TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_freq_enable">
      <bits access="r" name="reg_freq_enable_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_enable" pos="0" rst="0">
        <comment>
          load SDM frequency of all PLLs(RFPLL, mcupll, NPLL) to RTL at the same time, write 0 before assert it
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="xcvsdm_reg3">
      <bits access="r" name="xcvsdm_reg3_reserved_0" pos="15:5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_bypass_xcvsdm" pos="4" rst="0">
        <comment>
          bypass freq_enable, i.e., SDM frequency of RFPLL takes effect immidiately when it is loaded into regsiter
        </comment>
      </bits>
      <bits access="rw" name="dither_bypass_xcvsdm" pos="3" rst="0">
        <comment>
          sdm rfpll dither_bypass_xcvsdm
        </comment>
      </bits>
      <bits access="rw" name="dll_mode_xcvsdm" pos="2:0" rst="1">
        <comment>
          dividing ratio of RFPLL feedback clock to generate 26MHz clock used by GSM TX logic of DFE:
0b000: 182M divided by 7
0b001: 208M divided by 8
0b010: 234M divided by 9
0b011: 260M divided by 10
0b100: 26M with no division
0b101: 52M divided by 2
others: 208M divided by 8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="xcvsdm_reg4">
      <bits access="r" name="xcvsdm_reg4_reserved_0" pos="15:6" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_rx_sel_xcvsdm" pos="5" rst="0">
        <comment>
          select for TX using RFPLL SDM:
0b0: GSM RX or NB RX or NB TX without PolarIQ. SDM frequency is from registers that are xcvsdm_reg2/1/0
0b1: GSM TX or NB TX with PolarIQ. SDM frequency is from DFE GSM former and PolarIQ split
        </comment>
      </bits>
      <bits access="rw" name="resetn_xcvsdm" pos="4" rst="0">
        <comment>
          reset of RFPLL SDM, active low
        </comment>
      </bits>
      <bits access="rw" name="int_dec_sel_xcvsdm" pos="3:1" rst="2">
        <comment>
          decimal bit width selection of RFPLL SDM output. It should be fixed to 3'h2 in 8809nez.
0b000: int divide
0b001: 1 bit decimal divide
0b010: 2 bits decimal divide
0b011: 3 bit decimal divide
others: bypass SDM
        </comment>
      </bits>
      <bits access="rw" name="fbc_inv_xcvsdm" pos="0" rst="0">
        <comment>
          feedback clock inverse used by RFPLL SDM
0b0: no inverse
0b1: inverse
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="bbpll1_reg2">
      <bits access="r" name="bbpll1_reg2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pu_npll_dr1" pos="3" rst="0">
        <comment>
          direct conrol of analog pu_npll
        </comment>
      </bits>
      <bits access="rw" name="pu_npll_reg1" pos="2" rst="0">
        <comment>
          value of analog pu_npll. It takes affect when pu_npll_dr1 is 0b1
        </comment>
      </bits>
      <bits access="rw" name="pu_npll_dr" pos="1" rst="0">
        <comment>
          direct conrol of baseband pu_npll
        </comment>
      </bits>
      <bits access="rw" name="pu_npll_reg" pos="0" rst="0">
        <comment>
          value of baseband pu_npll. It takes affect when pu_npll_dr is 0b1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_reg5">
      <bits access="rw" name="npll_sdm_freq1" pos="15:0" rst="29037">
        <comment>
          bit [31:16] of NPLL SDM frequency
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_reg6">
      <bits access="rw" name="npll_sdm_freq0" pos="15:0" rst="32062">
        <comment>
          bit [15:0] of NPLL SDM frequency
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_reg7">
      <bits access="r" name="bbpll1_reg7_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="npll_freq_bypass" pos="7" rst="0">
        <comment>
          bypass freq_enable, i.e., SDM frequency of NPLL takes effect immidiately when it is loaded into regsiter
0b0: no bypass
0b1: bypass
        </comment>
      </bits>
      <bits access="rw" name="npll_int_dec_sel" pos="6:4" rst="3">
        <comment>
          decimal bit width selection of NPLL SDM output. It should be fixed to 3'b011 in 8809nez.
0b000: int divide
0b001: 1 bit decimal divide
0b010: 2 bits decimal divide
0b011: 3 bit decimal divide
others: bypass SDM
        </comment>
      </bits>
      <bits access="rw" name="npll_dither_bypass" pos="3" rst="1">
        <comment>
          dither bypass of NPLL SDM
0b0: no bypass
0b1: bypass
        </comment>
      </bits>
      <bits access="rw" name="npll_fbc_inv" pos="2" rst="0">
        <comment>
          feedback clock inverse used by NPLL SDM
0b0: no inverse
0b1: inverse
        </comment>
      </bits>
      <bits access="rw" name="npll_sdm_resetn_dr" pos="1" rst="0">
        <comment>
          direct conrol of NPLL SDM reset
        </comment>
      </bits>
      <bits access="rw" name="npll_sdm_resetn_reg" pos="0" rst="0">
        <comment>
          reset of NPLL SDM, active low. It takes affect when npll_sdm_resetn_dr is 0b1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_rega">
      <bits access="rw" name="npll_sdm_reset_time_sel" pos="15:14" rst="1">
        <comment>
          the time to release reset of NPLL SDM after pu_npll assert.
0b00: 10us
0b01: 12us
0b10: 15us
0b11: 40us
        </comment>
      </bits>
      <bits access="rw" name="npll_sdmclk_sel_time_sel" pos="13:12" rst="1">
        <comment>
          no use
        </comment>
      </bits>
      <bits access="r" name="bbpll1_rega_reserved_0" pos="11:5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_sel_reg" pos="4" rst="1">
        <comment>
          select of 30.72MHz clock of NPLL to ADC
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_en_reg" pos="3" rst="1">
        <comment>
          enable of 30.72MHz clock of NPLL to ADC
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_dfe_en_reg" pos="2" rst="1">
        <comment>
          enable of 61.44MHz clock of NPLL to DFE
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_dfe_sel_reg" pos="1" rst="1">
        <comment>
          select of 61.44MHz clock of NPLL to DFE
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_gen_en_reg" pos="0" rst="1">
        <comment>
          enable pu_npll from baseband
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="bbpll1_regb">
      <bits access="r" name="npll_pu" pos="15" rst="0">
        <comment>
          NPLL pu status
        </comment>
      </bits>
      <bits access="r" name="npll_lock" pos="14" rst="0">
        <comment>
          NPLL lock status
        </comment>
      </bits>
      <bits access="r" name="npll_sdm_resetn" pos="13" rst="0">
        <comment>
          NPLL SDM reset status
        </comment>
      </bits>
      <bits access="r" name="npll_sdm_clk_sel" pos="12" rst="0">
        <comment>
          NPLL sdm_clk_sel status
        </comment>
      </bits>
      <bits access="r" name="npll_clk_ready" pos="11" rst="0">
        <comment>
          NPLL clock status
        </comment>
      </bits>
      <bits access="r" name="npll_lock_steady" pos="10" rst="0">
        <comment>
          NPLL locked status
        </comment>
      </bits>
      <bits access="r" name="bbpll1_regb_reserved_0" pos="9:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_regd">
      <bits access="r" name="bbpll1_regd_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_thm_sel_reg" pos="11" rst="1">
      </bits>
      <bits access="rw" name="npll_clk2dig_thm_en_reg" pos="10" rst="1">
      </bits>
      <bits access="rw" name="npll_clk2dig_thm_sel_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="npll_clk2dig_thm_en_dr" pos="8" rst="0">
      </bits>
      <bits access="rw" name="npll_clk2dig_thm_sel_drreg" pos="7" rst="0">
      </bits>
      <bits access="rw" name="npll_clk2dig_thm_en_drreg" pos="6" rst="0">
      </bits>
      <bits access="rw" name="resetn_npll" pos="5" rst="1">
        <comment>
          software reset of logics to control NPLL pu and pd, active low
        </comment>
      </bits>
      <bits access="rw" name="npll_clkout_en_counter_sel" pos="4:2" rst="2">
        <comment>
          the time to open NPLL clocks after pu_npll assert.
0b000: 10us+50us+1us
0b000: 10us+60us+1us
0b000: 10us+70us+1us
0b000: 10us+80us+1us
0b000: 10us+90us+1us
0b000: 10us+100us+1us
        </comment>
      </bits>
      <bits access="rw" name="npll_lock_counter_sel" pos="1:0" rst="1">
        <comment>
          NPLL locked time.
0b00: 1us
0b01: 2us
0b10: 3us
0b11: 4us
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_regf">
      <bits access="r" name="bbpll1_regf_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_dfe_en_drreg" pos="11" rst="0">
        <comment>
          direct value of npll_clk2dig_en
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_en_drreg" pos="10" rst="0">
        <comment>
          direct value of npll_clk_adc_en
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_dfe_sel_drreg" pos="9" rst="0">
        <comment>
          direct value of npll_clk2dig_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_sel_drreg" pos="8" rst="0">
        <comment>
          direct value of npll_clk_adc_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_dfe_en_dr" pos="7" rst="0">
        <comment>
          direct control of npll_clk2dig_en
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_en_dr" pos="6" rst="0">
        <comment>
          direct control of npll_clk_adc_en
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_dfe_sel_dr" pos="5" rst="0">
        <comment>
          direct control of npll_clk2dig_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_sel_dr" pos="4" rst="0">
        <comment>
          direct control of npll_clk_adc_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_rstb_reg" pos="3" rst="0">
        <comment>
          direct value of npll_clk_rstb
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_rstb_dr" pos="2" rst="0">
        <comment>
          direct control of npll_clk_rstb
        </comment>
      </bits>
      <bits access="rw" name="npll_sdm_clk_sel_reg" pos="1" rst="0">
        <comment>
          direct value of npll_sdm_clk_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_sdm_clk_sel_dr" pos="0" rst="0">
        <comment>
          direct control of npll_sdm_clk_sel
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_cal_reg1">
      <bits access="rw" name="reg_90_bit1" pos="15:8" rst="0">
        <comment>
          rfpll_cal: target freq[15:8]
        </comment>
      </bits>
      <bits access="rw" name="reg_90_bit0" pos="7:0" rst="0">
        <comment>
          rfpll_cal: target freq[7:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_cal_reg2">
      <bits access="rw" name="reg_91_bit15to8" pos="15:8" rst="0">
        <comment>
          rfpll_cal:
[12:8]: xcvpll_vco_bits[12:8] in software
[13]: reserved
[14]: xcvpll_cnt_enable in software
[15]: xcvpll_cal_enable in software
        </comment>
      </bits>
      <bits access="rw" name="reg_91_bit70" pos="7" rst="0">
        <comment>
          rfpll_cal: reset, active low
        </comment>
      </bits>
      <bits access="rw" name="reg_91_bit6to0" pos="6:0" rst="0">
        <comment>
          rfpll_cal:
[0]: pll_cal_hd, select haredare(1) or software(0)
[1]: xcvpll_cal_opt  
[3:2]: xcvpll_cnt_delay_sel 
[6:4]: xcvpll_init_delay
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_cal_reg3">
      <bits access="rw" name="reg_92_bit1" pos="15:8" rst="0">
        <comment>
          rfpll_cal: reserved
        </comment>
      </bits>
      <bits access="rw" name="reg_92_bit0" pos="7:0" rst="0">
        <comment>
          rfpll_cal: xcvpll_vco_bits[7:0] in software
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rfpll_cal_reg4">
      <bits access="r" name="xcvpll_cal_enable" pos="15" rst="0">
        <comment>
          rfpll_cal xcv_pll_cal_en
        </comment>
      </bits>
      <bits access="r" name="xcvpll_cnt_enable" pos="14" rst="0">
        <comment>
          rfpll_cal xcv_pll_cnt_en
        </comment>
      </bits>
      <bits access="r" name="xcvpll_cal_ready" pos="13" rst="0">
        <comment>
          rfpll_cal xcvpll_cal_ready
        </comment>
      </bits>
      <bits access="r" name="xcvpll_vco_bits" pos="12:0" rst="0">
        <comment>
          rfpll_cal xcvpll_vco_bits
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg1">
      <bits access="r" name="adda_ctrl_reg1_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="resetn_adda_ctrl" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg2">
      <bits access="r" name="adda_ctrl_reg2_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="rw" name="pu_dac_dr_reg" pos="5" rst="0">
      </bits>
      <bits access="rw" name="pu_dac_dr" pos="4" rst="0">
      </bits>
      <bits access="rw" name="pu_adc_dr_reg" pos="3" rst="0">
      </bits>
      <bits access="rw" name="pu_adc_dr" pos="2" rst="0">
      </bits>
      <bits access="rw" name="pu_dac_reg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pu_adc_reg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg3">
      <bits access="r" name="adda_ctrl_reg3_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="rw" name="pu_dac_up_counter_sel" pos="5:3" rst="0">
      </bits>
      <bits access="rw" name="pu_adc_up_counter_sel" pos="2:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg4">
      <bits access="rw" name="bt_adda_ldo_bias_en_dr" pos="15" rst="0">
      </bits>
      <bits access="rw" name="bt_adda_ldo_en_dr" pos="14" rst="0">
      </bits>
      <bits access="rw" name="bt_adc_bias_en_dr" pos="13" rst="0">
      </bits>
      <bits access="rw" name="bt_daad_iq_ref_en_dr" pos="12" rst="0">
      </bits>
      <bits access="rw" name="bt_iqadc_en_dr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="bt_dac_clk_en_dr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="bt_dac_en_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="bt_dac_rstn_dr" pos="8" rst="0">
      </bits>
      <bits access="rw" name="bt_adc_bias_en_drreg" pos="7" rst="0">
      </bits>
      <bits access="rw" name="bt_adda_ldo_en_drreg" pos="6" rst="0">
      </bits>
      <bits access="rw" name="bt_adda_iq_bias_en_drreg" pos="5" rst="0">
      </bits>
      <bits access="rw" name="bt_daad_iq_ref_en_drreg" pos="4" rst="0">
      </bits>
      <bits access="rw" name="bt_iqadc_en_drreg" pos="3" rst="0">
      </bits>
      <bits access="rw" name="bt_dac_clk_en_drreg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="bt_dac_en_drreg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="bt_dac_rstn_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg5">
      <bits access="r" name="adda_ctrl_reg5_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="nb_adc_pu_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="nb_adc_pu_reg" pos="8" rst="0">
      </bits>
      <bits access="rw" name="nb_dac_pu_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="nb_dac_pu_reg" pos="6" rst="0">
      </bits>
      <bits access="rw" name="nb_daad_pu_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="nb_daad_pu_reg" pos="4" rst="0">
      </bits>
      <bits access="rw" name="bt_adc_bt_nb_adc_rstn_dr" pos="3" rst="0">
      </bits>
      <bits access="rw" name="bt_adc_bt_nb_adc_rstn_drreg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="bt_nb_dac_ldo_en_dr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="bt_nb_dac_ldo_en_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg6">
      <bits access="r" name="adda_ctrl_reg6_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_adc_ldo_in_trim" pos="10:7" rst="7">
        <comment>
          ADC LDO input ref calibration:                                                    0: 659mV  7:750mV  15:851mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_ldo_cp_trim" pos="6:4" rst="3">
        <comment>
          ADC CP LDO output calibration:                                                    000:0.923V  001:0.947V  010:0.973V 011:1.000V  100:1.028V  101:1.059V  110:1.091V
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_ldo_out_trim" pos="3:2" rst="1">
        <comment>
          ADC  LDO output calibration:                                              00: 910mV  01: 950mV   10: 982mV    11: 1.017V
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_res_adjust" pos="1:0" rst="1">
        <comment>
          ADC power ripple adjust
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg7">
      <bits access="r" name="adda_ctrl_reg7_reserved_0" pos="15:7" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_adc_atb_ctrl" pos="6:4" rst="0">
        <comment>
          NB IQADC test bus ctrl signal:                                            011: 0000001   010: 0000010   001: 0000100   000: 0001000   100: 0010000   101: 0100000   110: 1000000
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_test_enh" pos="3" rst="0">
        <comment>
          NB ADC test enable high
0x1:enable;
0x0:disable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_clkout_polarity" pos="2" rst="1">
        <comment>
          NB ADC CLK Polarity 
0x0:falling edge align data 
0x1:rising edge align data
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_clk_rst_ctrl" pos="1:0" rst="1">
        <comment>
          NB IQADC Delay adjust, mux:  00: I0    01: I1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg8">
      <bits access="rw" name="rg_nb_adc_dft_ctrl" pos="15:0" rst="1">
        <comment>
          NB IQ ADC reserved bits
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg9">
      <bits access="r" name="adda_ctrl_reg9_reserved_0" pos="15:13" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_adc_loop_delay_ctrl" pos="12:9" rst="4">
        <comment>
          NB IQ ADC Loop time ctrl signal
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_msb_delay_ctrl" pos="8:7" rst="1">
        <comment>
          NB IQ ADC MSB time ctrl signal:                                           00: 30ps   01: 45ps   10,11: 58ps
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_step_ctrl_i" pos="6" rst="1">
        <comment>
          NB ADC Conversion step control
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_step_ctrl_q" pos="5" rst="1">
        <comment>
          NB ADC Conversion step control
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_vcm_ctrl" pos="4:2" rst="3">
        <comment>
          NB ADC Common mode voltage control:                                       011: 0000001   010: 0000010   001: 0000100   000: 0001000   100: 0010000   101: 0100000   110: 1000000. 0001000:700mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_vin_delay_ctrl" pos="1:0" rst="1">
        <comment>
          Adjust the delay time of adc vin signal:                                  00: delay 27ps  01: delay 54ps  10: delay 81ps  11: 108ps
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg10">
      <bits access="r" name="adda_ctrl_reg10_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_adc_vrp_ctrl" pos="5:2" rst="0">
        <comment>
          Adjust the adc reference voltage
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_adc_vrp_i_trim" pos="1:0" rst="0">
        <comment>
          Adjust the adc reference voltage driving strength 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adda_ctrl_reg11">
      <bits access="r" name="adda_ctrl_reg11_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_dac_res_adjust" pos="8:7" rst="1">
        <comment>
          NB TX DAC Power resistor adjust signal
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_dac_current_mode" pos="6:4" rst="0">
        <comment>
          NB TX DAC bias current control
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_dac_clk_sel" pos="3" rst="1">
      </bits>
      <bits access="rw" name="rg_nb_dac_data_format" pos="2" rst="0">
        <comment>
          DAC Adapt DATA format selection ,low normal operation
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_dac_iq_swap" pos="1" rst="0">
        <comment>
          DAC Adapt iq swap control
 0x0:disable
 0x1:enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_dac_reseved" pos="0" rst="0">
        <comment>
          NB TX DAC reserved bit
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="clk_gen_reg0">
      <bits access="r" name="clk_gen_reg0_reserved_0" pos="15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_4" pos="14:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_3" pos="11:9" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_2" pos="8:6" rst="3">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_1" pos="5:3" rst="3">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_0" pos="2:0" rst="3">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_gen_reg1">
      <bits access="r" name="clk_gen_reg1_reserved_0" pos="15:9" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_7" pos="8:6" rst="0">
        <comment>
          clock selection of xcv_cal_clk[2]
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_6" pos="5:3" rst="0">
        <comment>
          clock selection of xcv_cal_clk[1]
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_5" pos="2:0" rst="0">
        <comment>
          clock selection of xcv_cal_clk[0].
0b000: 26MHz/1024
0b001: 26MHz/512
0b010: 26MHz/256
0b011: 26MHz/128
0b100: 26MHz/64
0b101: 26MHz/32
0b110: 26MHz/16
0b111: 26MHz/8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_gen_reg2">
      <bits access="rw" name="inv_clk_div" pos="15:8" rst="0">
        <comment>
          clock inverse of xcv_cal_clk and inernal clocks
        </comment>
      </bits>
      <bits access="rw" name="enable_clk_div" pos="7:0" rst="0">
        <comment>
          clock enable of xcv_cal_clk and inernal clocks
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="r" name="chip_id_reg0">
      <bits access="r" name="chip_id0" pos="15:0" rst="34833">
        <comment>
          chip id0
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="chip_id_reg1">
      <bits access="r" name="chip_id_reg1_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="chip_id1" pos="7:0" rst="0">
        <comment>
          chip id1
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="chip_id_reg2">
      <bits access="r" name="revision_id" pos="15:0" rst="34833">
        <comment>
          revision_id
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="revid_reg">
      <bits access="r" name="revid_reg_reserved_0" pos="15:8" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="r" name="revid_tx" pos="7:4" rst="0">
        <comment>
          mcupll
        </comment>
      </bits>
      <bits access="r" name="revid_rx" pos="3:0" rst="0">
        <comment>
          NPLL
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sys_ctrl_reg_20">
      <bits access="rw" name="sys_ctrl2_0" pos="15:0" rst="65535">
        <comment>
          for eco
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sys_ctrl_reg_22">
      <bits access="rw" name="sys_ctrl2_2" pos="15:0" rst="65535">
        <comment>
          for eco
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sys_ctrl_reg_24">
      <bits access="rw" name="sys_ctrl2_4" pos="15:0" rst="0">
        <comment>
          for eco
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sys_ctrl_reg_26">
      <bits access="rw" name="sys_ctrl2_6" pos="15:0" rst="0">
        <comment>
          for eco
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="gpio_reg1">
      <bits access="rw" name="gpio_ibit0" pos="15:0" rst="2">
      </bits>
    </reg>
    <reg protect="rw" name="gpio_reg2">
      <bits access="r" name="gpio_reg2_reserved_0" pos="15:5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="gpio_ibit1" pos="4:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="gpio_reg3">
      <bits access="r" name="gpio_reg3_reserved_0" pos="15:11" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="gpio_wpd" pos="10:4" rst="127">
      </bits>
      <bits access="rw" name="gpio_dsel" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="gpio_reg4">
      <bits access="r" name="gpio_reg4_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="gpio_wpu" pos="13:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="gpio_reg5">
      <bits access="r" name="gpio_reg5_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="gpio_oen" pos="13:7" rst="127">
      </bits>
      <bits access="rw" name="gpio_pdn" pos="6:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="gpio_reg6">
      <bits access="r" name="gpio_reg6_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="femio_mipi_sel" pos="7" rst="0">
      </bits>
      <bits access="rw" name="gpio_out" pos="6:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="gpio_reg7">
      <bits access="r" name="gpio_reg7_reserved_0" pos="15:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="gpio_in" pos="6:0" rst="0">
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="mdll_ctrl_reg1">
      <bits access="r" name="mdll_ctrl_reg1_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="rg_mdll_pd_clk_drreg" pos="9" rst="0">
      </bits>
      <bits access="rw" name="rg_mdll_startup_drreg" pos="8" rst="0">
      </bits>
      <bits access="rw" name="rg_mdll_pu_hv_drreg" pos="7" rst="0">
      </bits>
      <bits access="rw" name="rg_mdll_pd_clk_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="rg_mdll_startup_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="rg_mdll_pu_hv_dr" pos="4" rst="0">
      </bits>
      <bits access="rw" name="pu_mdll_dr_reg" pos="3" rst="0">
      </bits>
      <bits access="rw" name="pu_mdll_dr" pos="2" rst="0">
      </bits>
      <bits access="rw" name="pu_mdll_reg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="resetn_mdll_ctrl" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="mdll_ctrl_reg2">
      <bits access="rw" name="rg_nb_mdll_pd_clk2" pos="15" rst="1">
        <comment>
          clk2 output pull down, 
0x1 pull down to avss,
0x0 output enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_mdll_vctrl_test_en" pos="14" rst="0">
        <comment>
          vctrl test enable, 
0x1 enable, 
0x0 disable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_mdll_regu_vosel" pos="13:11" rst="4">
        <comment>
          regulator output voltage selction
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_mdll_band_sel" pos="10" rst="0">
        <comment>
          frequency band selction, 
0x0: low band;
0x1:high band
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_mdll_band" pos="9:7" rst="5">
        <comment>
          frequency band selction,
000:min low band; 
111:max high band
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_mdll_cp_ibit" pos="6:4" rst="4">
        <comment>
          cp current selction, 
000:min current;
 111:max current
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_mdll_div_n" pos="3:0" rst="8">
        <comment>
          divider ratio
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="mdll_ctrl_reg3">
      <bits access="r" name="mdll_ctrl_reg3_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_mdll_dither_bit" pos="5:3" rst="4">
      </bits>
      <bits access="rw" name="rg_nb_mdll_dither_en" pos="2" rst="0">
        <comment>
          vcdl dither enable, 1 enable, 0 disable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_mdll_dither_mode" pos="1" rst="0">
        <comment>
          vcdl dither mode selction
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_mdll_refclk_test_en" pos="0" rst="0">
        <comment>
          mdll refclk test enable
0x1: enable;0x0:disable
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="nb_pll_reg11">
      <bits access="rw" name="rg_sx_nbpll_digreg_range" pos="15:12" rst="12">
        <comment>
          adjust digreg output voltageGray Code
0xC0.8V
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_digreg_res" pos="11:9" rst="4">
        <comment>
          adjust number of resistors connected to vcore:
0x4:100 
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_refmulti2_en" pos="8" rst="0">
        <comment>
          refclk doubler enable
0x0:26MHz
0x1:52MHz
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_resed_reg1" pos="7:0" rst="0">
        <comment>
          reserved registers 1:
r&lt;0&gt;:cp current x2 enable
0:disable
1:enable
r&lt;1&gt;:ck to test driver enable
0:disable
1:enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="nb_pll_reg12">
      <bits access="rw" name="rg_sx_nbpll_resed_reg2" pos="15:8" rst="0">
        <comment>
          reserved registers 2
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_int_mode" pos="7" rst="0">
        <comment>
          source of din/pcon
0x0:din/pcon from sdm
0x1:din=8*(1+refmulti2_en),pcon=0
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_sdmclk_disable" pos="6" rst="0">
        <comment>
          sdmclk sent to SDM in dfe enable:
0x0:enable sdmclk
0x1:disable sdmclk
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_pcon_mode" pos="5" rst="0">
        <comment>
          select sdm clk or fbc as fbc,always 0
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_cp_ibit" pos="4:2" rst="4">
        <comment>
          charge pump output current control:
current=(1.67+0.835*control_bits_decimal)uA
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_band_sel" pos="1:0" rst="0">
        <comment>
          vco freq range:
00:270~410M 11:300~520M
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="nb_pll_reg13">
      <bits access="rw" name="rg_sx_nbpll_vco_low_test" pos="15" rst="0">
        <comment>
          0x0:normal vcont
0x1:pull vcont of vco to high(avdd)
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_vco_high_test" pos="14" rst="0">
        <comment>
          0x0:normal vcont
0x1:pull vcont of vco to low(avss)
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_clkbuf_div" pos="13:11" rst="1">
        <comment>
          output buffer div ratio:
0x1:6/12(CLKDFE/CLKADC)
0x4:8/16(CLKDFE/CLKADC)
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_testsig_sel" pos="10:9" rst="0">
        <comment>
          select signal to be tested:
0x0:clk test
0x1:dvddrc
0x2:vcont
0x3:vcovdd
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_digreg_adj" pos="8:4" rst="0">
        <comment>
          software calibrates digreg output voltage:
bit&lt;2:0&gt;: ref volatege0x4 0.8V
bit&lt;3&gt;:toggle signal
bit&lt;4&gt;:calibration enable
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_cp_offset" pos="3:2" rst="0">
        <comment>
          charge pump offset current:
offset current=(0.625*control_bits_decimal)uA
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_cp_offset_en" pos="1" rst="0">
        <comment>
          charge pump offset current enable:
0x0:disable offset current
0x1:enable offset current
        </comment>
      </bits>
      <bits access="rw" name="rg_sx_nbpll_sdmclk_test_en" pos="0" rst="0">
        <comment>
          select clock to be test:
0x0:vco clk
0x1:sdm_clk
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="nb_pll_reg14">
      <bits access="r" name="nb_pll_reg14_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="rg_sx_nbpll_test_en" pos="0" rst="0">
        <comment>
          pll test output enable: 
0x0:enable
0x1:disable
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="nb_pll_reg15">
      <bits access="r" name="nb_pll_reg15_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="r" name="ad_sx_nbpll_digreg_sign" pos="0" rst="0">
        <comment>
          digreg calibration indicator:
0x0:smaller than ref voltage
0x1:bigger than ref voltage
        </comment>
      </bits>
    </reg>
    <hole size="96"/>
    <reg protect="rw" name="txrf_reg_reg1">
      <bits access="r" name="txrf_reg_reg1_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="resetn_txrf_ctrl" pos="13" rst="1">
      </bits>
      <bits access="rw" name="txrf_pu_reg" pos="12" rst="0">
      </bits>
      <bits access="rw" name="da_nb_tx_tmx_pu_dr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="da_nb_tx_tmx_pu_reg" pos="10" rst="0">
        <comment>
          modulator enable
0x1:enable;
0x0:disable
        </comment>
      </bits>
      <bits access="rw" name="da_nb_tx_padrv_pu_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="da_nb_tx_padrv_pu_reg" pos="8" rst="0">
        <comment>
          da enable
gate voltage control
0x0:  disable
0x1:  enable
        </comment>
      </bits>
      <bits access="rw" name="da_nb_tx_tia_pu_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="da_nb_tx_tia_pu_reg" pos="6" rst="0">
        <comment>
          supply on
        </comment>
      </bits>
      <bits access="rw" name="da_nb_tx_flt_pu_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="da_nb_tx_flt_pu_reg" pos="4" rst="0">
        <comment>
          supply on
        </comment>
      </bits>
      <bits access="rw" name="da_nb_tx_tia_rstn_dr" pos="3" rst="0">
      </bits>
      <bits access="rw" name="da_nb_tx_tia_rstn_reg" pos="2" rst="0">
        <comment>
          reset
        </comment>
      </bits>
      <bits access="rw" name="da_nb_tx_flt_rstn_dr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_tx_flt_rstn_reg" pos="0" rst="0">
        <comment>
          reset
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txrf_reg_reg2">
      <bits access="r" name="txrf_reg_reg2_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_tx_tmx_vcom_sel" pos="13" rst="0">
        <comment>
          modulator bias based on filter or self
 0x1:filter
0x0:self
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_tmx_lobias_bit" pos="12:10" rst="0">
        <comment>
          modulator output voltage control
0x0 n:0.73V  p:0.53V
0x1 n:1V     p:0.22V
0x3 n:1.1V   p:0.05V
0x7 n:1.13V  p:0.03
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_tmx_gain_bit" pos="9:7" rst="0">
        <comment>
          modulator lsb gain control (dB)
0x7:-33;
0x6:-34.7;
0x5:-37.14;
0x4:-39.55;
0x3:-41.94;
0x2:-44.32;
0x1:-44.32;
0x0:-44.32;
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_cpl_cal" pos="6" rst="0">
        <comment>
          det path enable
0x0:disable;
0x1:enable;
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_tmx_vcom_nbit" pos="5:0" rst="31">
        <comment>
          self nbias control
0x0:0.48V;
...
0x3F:1.18V
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txrf_reg_reg3">
      <bits access="r" name="txrf_reg_reg3_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_tx_tmx_vcom_pbit" pos="13:8" rst="31">
        <comment>
          self pbias control
0x0:0V;
...
0x3F:0.75V
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_padrv_gain_bit" pos="7:4" rst="15">
        <comment>
          da gain control(dB)
0x0: -----;
0x1: -----;
0x2: -60.7;
0x3: -54.7;
0x4: -48.7;
0x5: -42.6;
0x6: -36.6;
0x7: -30.5;
0x8: ------;
0x9: -28.5;
0xA: -22.5;
0xB: -16.5;
0xC: -10.5;
0xD: -4.5;
0xE: 1.5;
0xF: 7.5;
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_padrv_cap_bit" pos="3:0" rst="3">
        <comment>
          band cap tune
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txrf_reg_reg4">
      <bits access="r" name="txrf_reg_reg4_reserved_0" pos="15:7" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_tx_padrv_bias_ibit" pos="6:2" rst="16">
        <comment>
          da bias tune
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_padrv_hp_mode" pos="1" rst="1">
        <comment>
          high power mode(PA on) / low power mode(PA off)
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_loft_mode" pos="0" rst="0">
        <comment>
          loft mode on(1) / off(0)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txrf_reg_reg5">
      <bits access="r" name="txrf_reg_reg5_reserved_0" pos="15:3" rst="0">
        <comment>
          rg_nb_lo_ldo_cal   
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_padrv_sw_bias_bit" pos="2:0" rst="0">
        <comment>
          pmos power switch bias from 0.9V to 1.05V
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txrf_reg_reg6">
      <bits access="r" name="txrf_reg_reg6_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_tx_tia_vcmi" pos="14:12" rst="3">
        <comment>
          tia input_cm control                              0x0:  vcmi=205mV
0x1:  vcmi=220mV
0x2:  vcmi=235mV
0x3:  vcmi=250mV(default)
0x4:  vcmi=265mV
0x5:  vcmi=280mV
0x6:  vcmi=295mV
0x7:  vcmi=310mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_tia_vcm0" pos="11:9" rst="3">
        <comment>
          tia_output_cm control;                          0x0:  vcmo=400mV
0x1:  vcmo=450mV
0x2:  vcmo=500mV
0x3:  vcmo=550mV(default)
0x4:  vcmo=600mV
0x5:  vcmo=650mV
0x6:  vcmo=700mV
0x7:  vcmo=750mV                        
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_tia_range_bit" pos="8:7" rst="1">
        <comment>
          tia output swing tuning;
        Rf       diff vpp
0x1:   0.86k       0.4v
0x2:   1.75k       0.8v(default)
0x3:    3.5k       1.6v
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_aux_filter_out_en" pos="6" rst="0">
        <comment>
          choose RX path signals
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_tia_mux_en" pos="5" rst="0">
        <comment>
          choose tia output signals
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_tia_ib_sel_op" pos="4:2" rst="0">
        <comment>
          tia_op bias tuning;
0x0:  IBP10u=5u(default)
0x1:  IBP10u=6.25u
0x2:  IBP10u=7.5u
0x3:  IBP10u=8.75u
0x4:  IBP10u=10u
0x5:  IBP10u=11.25u
0x6:  IBP10u=12.5u
0x7:  IBP10u=13.75u

        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_tia_vtrl_sel" pos="1" rst="1">
        <comment>
          select ibg or ic_vtr
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_dac_iout_enable" pos="0" rst="0">
        <comment>
          bypass tia_input
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txrf_reg_reg7">
      <bits access="r" name="txrf_reg_reg7_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_tx_flt_ibit_op" pos="14:13" rst="2">
        <comment>
          filter_op bias tuning;
0x0:  IC5U=3u
0x1:  IC5U=3.6u
0x2:  IC5U=5u(default)
0x3:  IC5U=7.5u
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_flt_cap_tunning" pos="12:9" rst="7">
        <comment>
          filter_tia Cf tuning;
0x0: 1.27p
0x1: 1.27p+45f
0x2: 1.27p+90f

0x15:1.27+45f15=1.945p
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_flt_gain_ctrl" pos="8:5" rst="10">
        <comment>
          filter gain ctrl
0x0: 0dB
0x1: 1dB
0x2: 2dB

0x10:10dB(default)
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_flt_lp_mode" pos="4" rst="1">
        <comment>
          class AB output stage enhance
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_flt_txflt_mode_bit" pos="3:2" rst="2">
        <comment>
          filter orders or bypass
0x0: bypass
0x1: 1st_order
0x2: 3st_order(default)
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_flt_clk1_en" pos="1" rst="0">
        <comment>
          signal in phase or inverting transmission
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_tx_flt_clk2_en" pos="0" rst="0">
        <comment>
          signal in phase or inverting transmission
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txrf_reg_reg8">
      <bits access="r" name="txrf_reg_reg8_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_tx_flt_cal_clk_edge" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="vcolo_reg_reg1">
      <bits access="rw" name="resetn_vcolo_ctrl" pos="15" rst="1">
      </bits>
      <bits access="rw" name="pu_vcolo_reg" pos="14" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_pu_dr" pos="13" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_ldo_en_dr" pos="12" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_ldo_fc_en_dr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_bias_en_dr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_bias_fc_en_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_pu_dr" pos="8" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_ldo_en_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_ldo_fc_en_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_trx_pu_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_trx_ldo_en_dr" pos="4" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_trx_ldo_fc_en_dr" pos="3" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_buf_div_en_dr" pos="2" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_buf_txlo_en_dr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_buf_rxlo_en_dr" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="vcolo_reg_reg2">
      <bits access="rw" name="da_nb_lo_rx_en_dr" pos="15" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_tx_en_dr" pos="14" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_pu_drreg" pos="13" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_ldo_en_drreg" pos="12" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_ldo_fc_en_drreg" pos="11" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_bias_en_drreg" pos="10" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_bias_fc_en_drreg" pos="9" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_pu_drreg" pos="8" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_ldo_en_drreg" pos="7" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_ldo_fc_en_drreg" pos="6" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_trx_pu_drreg" pos="5" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_trx_ldo_en_drreg" pos="4" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_trx_ldo_fc_en_drreg" pos="3" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_buf_div_en_drreg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_buf_txlo_en_drreg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_vco_buf_rxlo_en_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="vcolo_reg_reg3">
      <bits access="r" name="vcolo_reg_reg3_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_rx_en_drreg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_lo_tx_en_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="vcolo_reg_reg4">
      <bits access="r" name="vcolo_reg_reg4_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_sx_vco_ldo_cal" pos="8:5" rst="7">
        <comment>
          vco ldo reference voltage control signal 
0000 650mV 
0111 750mV 
1111 850mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_vco_ldo_out" pos="4:2" rst="4">
        <comment>
          vco ldo output voltage control signal 
000 900mV 
001 925mV 
010 950mV 
011 975mV 
100 1V 
101 1.025V 
110 1.05V 
111 1.1V
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_vco_bias_rc_sel" pos="1:0" rst="1">
        <comment>
          vco bias RC control signal 
00 5M 
01 10M 
10 15M 
11 20M
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="vcolo_reg_reg6">
      <bits access="rw" name="rg_nb_sx_vco_tank_sca_aux" pos="15:12" rst="7">
        <comment>
          vco cbank aux control signal 
0 40f 
15 200f
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_vco_lp_mode" pos="11" rst="0">
        <comment>
          vco control signal for HP/LP mode,1 for LP mode,0 for HP mode.
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_lo_ldo_cal" pos="10:7" rst="7">
        <comment>
          lo ldo reference voltage control signal 
0000 650mV 
0111 750mV 
1111 850mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_lo_ldo_out" pos="6:4" rst="4">
        <comment>
          lo ldo output voltage control signal 
000 850mV 
100 900mV 
111 950mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_lo_tx_div_mode" pos="3:2" rst="0">
        <comment>
          lo div mode control signal,
00 for div8,
01 for div6,
10 for div4,
11 for div2
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_lo_rx_div_mode" pos="1:0" rst="0">
        <comment>
          lo div mode control signal,
00 for div8,
01 for div6,
10 for div4,
11 for div2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="vcolo_reg_reg7">
      <bits access="r" name="vcolo_reg_reg7_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_lo_trx_ldo_cal" pos="8:5" rst="7">
        <comment>
          lo trx ldo reference voltage control signal 
0000 650mV 
0111 750mV 
1111 850mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_lo_trx_ldo_out" pos="4:2" rst="4">
        <comment>
          lo trx ldo output voltage control signal 
000 850mV 
100 900mV 
111 950mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_lo_trx_div_mode" pos="1:0" rst="0">
        <comment>
          lo trx div mode control signal,
00 for div8,
01 for div6,
10 for div4,
11 for div2
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="det_path_reg1">
      <bits access="r" name="det_path_reg1_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_det_path_cap_ctrl" pos="11:8" rst="3">
        <comment>
          DET PATH att tune
Ox0:min att= -8 dB
...
Ox7:max att= -17 Db
0x8~0xf: reserved
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_det_path_res_ctrl" pos="7:4" rst="3">
        <comment>
          Res ATT gain control
0x0: -36dB
0x1: -30dB

0x6: 0dB
0x7~0xf: reserved
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_det_path_resed" pos="3:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ana_test_reg1">
      <bits access="r" name="ana_test_reg1_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_gpio_test" pos="9:5" rst="0">
        <comment>
          use gpio pad to do tx/rx chain test
0x0  close the test switch
0x15 open the test swtich
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_testdriver_sel" pos="4:3" rst="0">
        <comment>
          VCO test buffer selection
0x0:  mdll
0x1:  tx lo
0x2:  rx lo
0x3: none
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_testdriver_driver" pos="2:1" rst="0">
        <comment>
          VCO test buffer strength
0x0:  weak
0x1:  medium
0x2:  strong
0x3:  strongest
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_testdriver_en" pos="0" rst="0">
        <comment>
          VCO test buffer enable
0x0:enable
0x1:disable
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="rx_filter_reg1">
      <bits access="rw" name="resetn_rxrf_ctrl" pos="15" rst="1">
      </bits>
      <bits access="rw" name="pu_rxrf_reg" pos="14" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_lna_pu_dr" pos="13" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_lna_ldo_en_dr" pos="12" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_mixer_pu_dr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_mixer_en_dr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_pga_pu_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_pga_en_dr" pos="8" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_filter_pu_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_lna_ldo_fc_en_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_lna_en_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_dcoc_en_dr" pos="4" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_filter_rst_dr" pos="3" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_filter_cal_en_dr" pos="2" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_lna_pu_drreg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_lna_ldo_en_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rx_filter_reg2">
      <bits access="r" name="rx_filter_reg2_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_mixer_pu_drreg" pos="9" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_mixer_en_drreg" pos="8" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_pga_pu_drreg" pos="7" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_pga_en_drreg" pos="6" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_filter_pu_drreg" pos="5" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_lna_ldo_fc_en_drreg" pos="4" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_lna_en_drreg" pos="3" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_dcoc_en_drreg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_filter_rst_drreg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_rx_filter_cal_en_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rx_filter_reg3">
      <bits access="rw" name="rg_nb_rx_lna_ldo_out" pos="15:13" rst="3">
        <comment>
          LNA LDO output voltage control
0x0 0.91V;
0x1 0.93V;
0x2 0.95V;
0x3 0.97V;
0x4 0.99V;
0x5 1.01V;
0x6 1.03V;
0x7 1.05V
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_lna_ibias" pos="12:11" rst="1">
        <comment>
          LNA bias current control
0x0:4mA;
0x1:4.5mA;
0x2:5mA;
0x3:5.5mA
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_lna_bandsel" pos="10" rst="0">
        <comment>
          LNA band select
0x0: LB;
0x1: HB
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_lna_gain" pos="9:7" rst="0">
        <comment>
          LNA gain control;
0x5:61db;
0x4:55db;
0x3:49db;
0x2:40db;
0x1:31db;
0x0:22db
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_lna_res_fb" pos="6:4" rst="3">
        <comment>
          reserved bit
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_lna_vbcg" pos="3:1" rst="3">
        <comment>
          LNA cascode transistor
gate voltage control
0x0:  nbias 0.65 pbias 0.35
0x1:  nbias 0.68 pbias 0.38
0x2:  nbias 0.71 pbias 0.41
0x3:  nbias 0.74 pbias 0.46
0x4:  nbias 0.77 pbias 0.49
0x5:  nbias 0.8 pbias 0.52
0x6:  nbias 0.83 pbias 0.55
0x7:  nbias 0.86 pbias 0.758
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_lna_res_vb" pos="0" rst="0">
        <comment>
          LNA input VBIS resistor control
0x0:60k;
ox1:30k
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_filter_reg4">
      <bits access="r" name="rx_filter_reg4_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_rx_lna_att_adj" pos="13:11" rst="3">
        <comment>
          LNA low gain ATT network tune;
to fine tune the gain step(9dB)
between gaincode=3 and gaincode=2;
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_mixer_bias" pos="10:8" rst="3">
        <comment>
          RX MIXER LO Vbias control;
0x0:0.85v;
;
0x7:1.05v
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_pga_op_ibias" pos="7:6" rst="1">
        <comment>
          RX PGA ibias control;
0x0:1.4mA;
0x1:1.6mA;
0x2:1.8mA;
0x3:2mA
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_pga_input_res" pos="5:3" rst="1">
        <comment>
          RX PGA input resistor control;
0x0:0

0x7:200
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_pga_bw_res" pos="2:0" rst="3">
        <comment>
          RX bandwidth res control;
0x0:min ;
0x1:min+6dB;
0x2:min+12dB;
0x3:min+18dB:0x4:min+24dB
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_filter_reg5">
      <bits access="r" name="rx_filter_reg5_reserved_0" pos="15:7" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_rx_pga_bw_cap" pos="6:4" rst="3">
        <comment>
          RX bandwidth cap control;
0x0:min gain;
0x1:min+6dB;
0x2:min+12dB;
0x3:min+18dB
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_pga_gain_res" pos="3:1" rst="3">
        <comment>
          RX PGA gain control;
0x0:min ;
0x1:min+6dB;
0x2:min+12dB;
0x3:min+18dB;0x4:min+24dB
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_pga_bypass" pos="0" rst="0">
        <comment>
          RX PGA bypass enable;
0x0:disable;
0x1:enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_filter_reg6">
      <bits access="rw" name="rg_nb_rx_dcoc_cal_i" pos="15:8" rst="128">
        <comment>
          RX DCOC I path current control;
0x0:minimun output current;

0xFF:maximum output current
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_dcoc_cal_q" pos="7:0" rst="128">
        <comment>
          RX DCOC Q path current control;
0x0:minimun output current;
.
0xFF:maximum output current
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_filter_reg7">
      <bits access="r" name="rx_filter_reg7_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_rx_dcoc_cal_resolv" pos="1:0" rst="0">
        <comment>
          RX DCOC current resolution control;
0x0:10uA/bit;
0x1:20uA/bit;
0x2:40uA/bit;
0x3:80uA/bit
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="rx_filter_reg8">
      <bits access="r" name="rx_filter_reg8_reserved_0" pos="15:13" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_op_ibit" pos="12:11" rst="2">
        <comment>
          Opamp bias control
  0x0: 3u
  0x1: 3.6u
  0x2: 5u
  0x3: 7.5u
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_lp_mode" pos="10:8" rst="7">
        <comment>
          Opamp drive strength
  [0]: the 1th opamp //1, LP enable
  [1]: the 2th opamp //1, LP enable
  [2]: the 3th opamp //1, LP enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_gain1" pos="7:4" rst="9">
        <comment>
          frist stage gain :default 15dB
  0x0:  6dB
  0x1:  7dB
  0x2:  8dB
  0x3:  9dB
  0x4: 10dB
  0x5: 11dB
  0x6: 12dB
  0x7: 13dB
  0x8: 14dB
  0x9: 15dB
  other:   6dB
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_gain2" pos="3:2" rst="3">
        <comment>
          second stage gain: defalut 18dB
  0x0:  0dB
  0x1:  6dB
  0x2: 12dB
  0x3: 18dB
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_if_ctrl" pos="1:0" rst="1">
        <comment>
          IF ctrl
  0x0: 0
  0x1: 100KHz
  0x2: 200KHz
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_filter_reg9">
      <bits access="r" name="rx_filter_reg9_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_bw_ctrl" pos="8:5" rst="7">
        <comment>
          filter BW ctrl
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_iqswap" pos="4" rst="0">
        <comment>
          Filter I path &amp; Q Path swap
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_auxin_en" pos="3" rst="0">
        <comment>
          Filter aux_path(calibration path) enable 
  0x0: disable
  0x1: enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_clk_edge_sel" pos="2" rst="0">
        <comment>
          Filter clk edge selection
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_cal_mode" pos="1" rst="0">
        <comment>
          Filter calibration mode
  0x0: lowpass mode
  0x1: bandpass mode
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_bw_cal_en" pos="0" rst="0">
        <comment>
          Filter BW calibration enable
  0x0: disable
  0x1: enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_filter_reg10">
      <bits access="r" name="rx_filter_reg10_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_rx_filter_rsv" pos="7:0" rst="0">
        <comment>
          reserved bit
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="rx_pll_ctrl_reg1">
      <bits access="r" name="rx_pll_ctrl_reg1_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="resetn_rxpll_ctrl" pos="9" rst="1">
      </bits>
      <bits access="rw" name="pu_rxpll_reg" pos="8" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_peri_pu_fc_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_peri_pu_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_presc_pu_fc_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_presc_pu_dr" pos="4" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_peri_pu_fc_drreg" pos="3" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_peri_pu_drreg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_presc_pu_fc_drreg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_sx_presc_pu_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rx_pll_ctrl_reg2">
      <bits access="rw" name="rg_rfpll_resed" pos="15:0" rst="65280">
        <comment>
          RFPLL reserved bit
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_pll_ctrl_reg3">
      <bits access="rw" name="rg_nb_sx_sinc_pwr_res" pos="15:12" rst="8">
        <comment>
          Power switch for Sinc Filter
1111 POWER OFF/HighZ
1000 default
0000 LowZ
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_ref_pwr_res" pos="11:8" rst="8">
        <comment>
          Power switch for REF generation, 208M/26M/52M
1111 POWER OFF/HighZ
1000 default
0000 LowZ
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_pfd1_pwr_res" pos="7:4" rst="8">
        <comment>
          Power switch for PFD div&amp;ref seperated dvdd
1111 POWER OFF/HighZ
1000 default
0000 LowZ
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_pfd2_pwr_res" pos="3:0" rst="8">
        <comment>
          Power switch for pfd out
1111 POWER OFF/HighZ
1000 default
0000 LowZ
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_pll_ctrl_reg4">
      <bits access="r" name="rx_pll_ctrl_reg4_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_sx_reg_dig_bit" pos="14:11" rst="8">
        <comment>
          PLL regulator1
vout ctrl:0.9+15mV*BIN2DEC(REG_Vctrl-1000)
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_reg_flt_bit" pos="10:7" rst="8">
        <comment>
          PLL regulator2
vout ctrl:0.9+15mV*BIN2DEC(REG_Vctrl-1000)
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_reg_div2_bit" pos="6:4" rst="4">
        <comment>
          PLL regulator div2
vout ctrl:0.9+15mV*BIN2DEC(REG_Vctrl-1000)
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_reg_presc_bit" pos="3:0" rst="8">
        <comment>
          PLL regulator prescaler
vout ctrl:0.9+15mV*BIN2DEC(REG_Vctrl-1000)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_pll_ctrl_reg5">
      <bits access="r" name="rx_pll_ctrl_reg5_reserved_0" pos="15:5" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_sx_refmulti2_en" pos="4" rst="1">
        <comment>
          PLL ref x2
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_ref_sel" pos="3" rst="0">
        <comment>
          PLL ref source: 0 for MDLL, 1 for 26M
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_sdm_clk_sel" pos="2" rst="0">
        <comment>
          sdm clk source: 0 for fbc, 1 for fref
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_cal_clk_sel" pos="1" rst="0">
        <comment>
          afc clk source: 0 for ref, 1 for refb
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_fdiv_sel" pos="0" rst="0">
        <comment>
          div modulus sync clk sel
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_pll_ctrl_reg6">
      <bits access="r" name="rx_pll_ctrl_reg6_reserved_0" pos="15:13" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_sx_pfd_res_bit" pos="12:7" rst="15">
        <comment>
          pfd output res
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_cal_bit" pos="6:5" rst="1">
        <comment>
          afc initial cbank setting:&lt; *6&gt;(cal_bit&lt;1:0&gt;),&lt; *6&gt;(cal_bit&lt;0:1&gt;)
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_cal_en" pos="4" rst="0">
        <comment>
          afc enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_cnt_en" pos="3" rst="0">
        <comment>
          afc counter enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_open_en" pos="2" rst="0">
        <comment>
          open loop enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_xfer_aux_en" pos="1" rst="0">
        <comment>
          sinc filter switch aux sel
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_bypass_notch" pos="0" rst="1">
        <comment>
          notch bypass enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_pll_ctrl_reg7">
      <bits access="r" name="rx_pll_ctrl_reg7_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_sx_vco_gain_bit" pos="13:10" rst="7">
        <comment>
          sinc filter path number/ KVCO
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_cp_bit" pos="9:6" rst="8">
        <comment>
          cp current bit
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_r_bit" pos="5:4" rst="2">
        <comment>
          lpf r1, 
00 7k
10 1.2k//7k
01 0.8k//7k
11 1.2k//0.8k//7k
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_lpf_gain" pos="3:0" rst="8">
        <comment>
          lpf r1 aux
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_pll_ctrl_reg8">
      <bits access="r" name="rx_pll_ctrl_reg8_reserved_0" pos="15:4" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_sx_sinc_mode" pos="3:1" rst="1">
        <comment>
          sinc mode sel
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_lp_mode" pos="0" rst="0">
        <comment>
          low power mode, 1 for iot
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_pll_ctrl_reg9">
      <bits access="r" name="rx_pll_ctrl_reg9_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_sx_bulk_sel" pos="7" rst="1">
      </bits>
      <bits access="rw" name="rg_nb_sx_cp_temp_track_spi" pos="6:3" rst="8">
        <comment>
          charge pump current temperature tracking code from spi
1111 -40  680 ohm
1000 40  540 ohm
0001 120 330 ohm
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_cp_temp_track_autoen" pos="2" rst="1">
        <comment>
          charge pump current temperature tracking code from THM DET block, enable signal
1 code from THM DET
0 code from software
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_ref_208m_pulser_on" pos="1" rst="1">
        <comment>
          rfpll reference 208M clock pulser generation, pulse width ~ 400 ps
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_sx_reg_stb_on" pos="0" rst="0">
        <comment>
          LDO 2nd stage output current enable signal
0 only ON when FC==1
1 always ON
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rx_pll_ctrl_reg10">
      <bits access="r" name="rx_pll_ctrl_reg10_reserved_0" pos="15:4" rst="0">
      </bits>
      <bits access="r" name="ad_nb_sx_cp_ctrl" pos="3:0" rst="0">
        <comment>
          charge pump current temperature tracking code. Read from CP control word.
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="bandgap_reg1">
      <bits access="r" name="bandgap_reg1_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_bg_pu" pos="14" rst="0">
        <comment>
          bandgap power up
0x0:disable 
0x1:enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_bg_en" pos="13" rst="0">
        <comment>
          bandgap enable
0x0:enable
0x1:disable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_bg_cur_cal" pos="12:9" rst="7">
        <comment>
          bg current calibration @different process corner
TT ,FS,SF: 0x7;
FF:0xe;
SS:0x2
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_bg_thm_bias_en" pos="8" rst="0">
        <comment>
          thermal bias switch
0x0:disable
0x1:enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_bg_rsv" pos="7:0" rst="0">
        <comment>
          reserved bit
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="thm_ctrl_reg1">
      <bits access="rw" name="resetn_thm_ctrl" pos="15" rst="1">
      </bits>
      <bits access="rw" name="pu_thm" pos="14" rst="0">
      </bits>
      <bits access="rw" name="pu_thm_dr" pos="13" rst="0">
      </bits>
      <bits access="rw" name="pu_thm_drreg" pos="12" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_pu_dr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_en_dr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_run_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_ldo_en_dr" pos="8" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_cmp_en_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_ldo_charge_en_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_rst_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_pu_drreg" pos="4" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_en_drreg" pos="3" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_run_drreg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_ldo_en_drreg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_cmp_en_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="thm_ctrl_reg2">
      <bits access="r" name="thm_ctrl_reg2_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rw" name="rf_thm_interrupt_reg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_ldo_charge_en_drreg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_thm_rst_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="thm_ctrl_reg3">
      <bits access="rw" name="rg_nb_thm_ls_pd" pos="15" rst="0">
        <comment>
          themal top chip enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_thm_ldo" pos="14:12" rst="2">
        <comment>
          LDO output voltage control
Ox0: 0.91V
0x1: 0.93V
0x2: 0.95V
0x3: 0.97V
Ox4: 0.99V
0x5: 1.01V
0x6: 1.03V
0x7: 1.05V
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_thm_calib_en" pos="11" rst="0">
        <comment>
          reserved bit
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_thm_bp_mode" pos="10" rst="1">
        <comment>
          choose thm DAC input
0x0:DAC input=RG_NB_THM_DAC_TEST[7:0];
0x1:DAC input from digital
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_thm_dac_test" pos="9:2" rst="0">
        <comment>
          for thm calibraiton
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_thm_dac_range" pos="1" rst="0">
        <comment>
          0x0:dac range: 331mV~754mV 0x1: dac_range:377m V~804mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_test_mode" pos="0" rst="0">
        <comment>
          Themal det test mode en
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="thm_ctrl_reg4">
      <bits access="r" name="thm_ctrl_reg4_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_thm_test_mode" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_test_out_sel" pos="0" rst="0">
        <comment>
          themal test signal choose: 0x0:vbe out 0x1:vdac out 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="thm_ctrl_reg5">
      <bits access="rw" name="rg_nb_thm_resed" pos="15:0" rst="0">
        <comment>
          RG_NB_THM_RESERVED[15]:RG_NB_THM_DIV_SET,set thm digital clk div ratio: 0x0 div   ratio=64, 0x1 div ratio=512;
RG_NB_THM_RESERVED[14:12]:RG_NB_THM_HYS_SET,set temperature change for interrupt signal out;
RG_NB_THM_RESERVED[11:8]:RG_NB_THM_DET_SET,set auto test time interval;
RG_NB_THM_RESERVED[7]:RG_NB_THM_INT_RESET,reset AD_TS_INT;                                               RG_NB_THM_RESERVED[6:0]:reserved;
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="thm_ctrl_reg6">
      <bits access="r" name="thm_ctrl_reg6_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="r" name="ad_thm_clk_out" pos="11" rst="0">
        <comment>
          themal div CLK output
        </comment>
      </bits>
      <bits access="r" name="ad_thm_interrupt" pos="10" rst="0">
        <comment>
          interrupt signal
        </comment>
      </bits>
      <bits access="r" name="ad_thm_data_valid" pos="9" rst="0">
        <comment>
          testing result valid signal 
        </comment>
      </bits>
      <bits access="r" name="ad_thm_data" pos="8:1" rst="0">
        <comment>
          themal data output,valid on the clock rising edge
        </comment>
      </bits>
      <bits access="r" name="ad_thm_iest" pos="0" rst="0">
        <comment>
          themal test data output
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="pd_ctrl_reg1">
      <bits access="rw" name="rg_nb_pd_vcm1_ctrl" pos="15:13" rst="6">
        <comment>
          power detector tuning vcm1(VDD=0.9V)
Ox0:VDD*7/39
Ox1:VDD*8/39
Ox2:VDD*9/39
Ox3:VDD*10/39
Ox4:VDD*11/39
Ox5:VDD*12/39
Ox6:VDD*13/39=300 mV
Ox7:VDD*14/39
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_vcm2_ctrl" pos="12:10" rst="3">
        <comment>
          power detector tuning vcm2(VDD=0.9V)
Ox0:VDD*15/44=306.8 mV
Ox1:VDD*16/44=327.3 mV
Ox2:VDD*17/44=347.7 mV
Ox3:VDD*18/44=368.2 mV
Ox4:VDD*19/44=388.6 mV
Ox5:VDD*20/44=409.1 mV
Ox6:VDD*21/44=429.5 mV
Ox7:VDD*22/44=450.0 mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_att_tune" pos="9:7" rst="3">
        <comment>
          pd att tune
Ox0:min att= -8 dB
...
Ox7:max att= -17 dB
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_gc" pos="6:5" rst="1">
        <comment>
          tia gain control
Ox0:min tia gain
0x1:min+2dB
0x2:min+4dB
0x3:min+6dB
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_ibc" pos="4:2" rst="3">
        <comment>
          square circuit bias current control
Ox0: 12uA
0x1: 15uA
0x2: 18uA
0x3: 21uA
Ox4: 24uA
0x5: 27uA
0x6: 30uA
0x7: 33uA
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_ib2" pos="1:0" rst="2">
        <comment>
          diff to single opa bias current control
Ox0: 3uA
0x1: 3.75uA
0x2: 5uA
0x3: 7.5uA
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pd_ctrl_reg2">
      <bits access="rw" name="rg_nb_pd_ivc" pos="15:14" rst="2">
        <comment>
          output cm voltage control
Ox0: 367.5mV
0x1: 400mV
0x2: 435mV
0x3: 469mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_mode" pos="13" rst="0">
        <comment>
          0 bypass
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_en" pos="12" rst="0">
        <comment>
          1 enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_lp_mode" pos="11" rst="1">
        <comment>
          diff to single opa ab output current
0:90uA;1:30uA
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_pu" pos="10" rst="0">
        <comment>
          0x1 enable
0x0 disable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_resed1" pos="9:6" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_ls_pd" pos="5" rst="0">
        <comment>
          themal top chip enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_ldo" pos="4:2" rst="2">
        <comment>
          LDO output voltage control
Ox0: 0.91V
0x1: 0.93V
0x2: 0.95V
0x3: 0.97V
Ox4: 0.99V
0x5: 1.01V
0x6: 1.03V
0x7: 1.05V
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_calib_en" pos="1" rst="0">
        <comment>
          reserved bit
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_bp_mode" pos="0" rst="1">
        <comment>
          choose thm DAC input
0x0:DAC input=RG_NB_THM_DAC_TEST[7:0];
0x1:DAC input from digital
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pd_ctrl_reg3">
      <bits access="r" name="pd_ctrl_reg3_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_pd_dac_test" pos="10:3" rst="0">
        <comment>
          for thm calibraiton
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_dac_range" pos="2" rst="0">
        <comment>
          0x0:dac range: 331mV~754mV 0x1: dac_range:377m V~804mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_test_mode" pos="1" rst="0">
        <comment>
          Themal det test mode en
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_pd_test_out_sel" pos="0" rst="0">
        <comment>
          themal test signal choose: 0x0:vbe out 0x1:vdac out 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pd_ctrl_reg4">
      <bits access="rw" name="rg_nb_pd_resed" pos="15:0" rst="0">
        <comment>
          RG_NB_THM_RESERVED[15]:RG_NB_THM_DIV_SET,set thm digital clk div ratio: 0x0 div   ratio=64, 0x1 div ratio=512;
RG_NB_THM_RESERVED[14:12]:RG_NB_THM_HYS_SET,set temperature change for interrupt signal out;
RG_NB_THM_RESERVED[11:8]:RG_NB_THM_DET_SET,set auto test time interval;
RG_NB_THM_RESERVED[7]:RG_NB_THM_INT_RESET,reset AD_TS_INT;                                               RG_NB_THM_RESERVED[6:0]:reserved;
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="pd_ctrl_reg5">
      <bits access="r" name="pd_ctrl_reg5_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="r" name="ad_nb_pd_clk_out" pos="11" rst="0">
        <comment>
          themal div CLK output
        </comment>
      </bits>
      <bits access="r" name="ad_nb_pd_interrupt" pos="10" rst="0">
        <comment>
          interrupt signal
        </comment>
      </bits>
      <bits access="r" name="ad_nb_pd_data_valid" pos="9" rst="0">
        <comment>
          testing result valid signal 
        </comment>
      </bits>
      <bits access="r" name="ad_nb_pd_data" pos="8:1" rst="0">
        <comment>
          themal data output,valid on the clock rising edge
        </comment>
      </bits>
      <bits access="r" name="ad_nb_pd_iest" pos="0" rst="0">
        <comment>
          themal test data output
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pd_ctrl_reg6">
      <bits access="rw" name="resetn_pd_ctrl" pos="15" rst="1">
      </bits>
      <bits access="rw" name="pu_pd" pos="14" rst="0">
      </bits>
      <bits access="rw" name="pu_pd_dr" pos="13" rst="0">
      </bits>
      <bits access="rw" name="pu_pd_drreg" pos="12" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_pu_dr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_en_dr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_run_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_ldo_en_dr" pos="8" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_cmp_en_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_ldo_charge_en_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_rst_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_pu_drreg" pos="4" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_en_drreg" pos="3" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_run_drreg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_ldo_en_drreg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_cmp_en_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pd_ctrl_reg7">
      <bits access="r" name="pd_ctrl_reg7_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_ldo_charge_en_drreg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="da_nb_pd_rst_drreg" pos="0" rst="0">
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="interface_reg_add">
      <bits access="r" name="interface_reg_add_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="rg_digital_interface_pu" pos="0" rst="0">
      </bits>
    </reg>
    <hole size="96"/>
    <reg protect="rw" name="loft_reg1">
      <bits access="rw" name="rg_nb_loft_vcm_ctrl" pos="15:13" rst="6">
        <comment>
          power detector tuning vcm1(VDD=0.9V)
Ox0:VDD*7/39
Ox1:VDD*8/39
Ox2:VDD*9/39
Ox3:VDD*10/39
Ox4:VDD*11/39
Ox5:VDD*12/39
Ox6:VDD*13/39=300 mV
Ox7:VDD*14/39
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_loft_att_tune" pos="12:10" rst="3">
        <comment>
          pd att tune
Ox0:min att
...
Ox7:max att
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_loft_gc" pos="9:8" rst="1">
        <comment>
          tia gain control
Ox0:min tia gain
0x1:min+2dB
0x2:min+4dB
0x3:min+6dB
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_loft_ibc" pos="7:5" rst="3">
        <comment>
          square circuit bias current control
Ox0: 12uA
0x1: 15uA
0x2: 18uA
0x3: 21uA
Ox4: 24uA
0x5: 27uA
0x6: 30uA
0x7: 33uA
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_loft_ivc" pos="4:3" rst="2">
        <comment>
          output cm voltage control
Ox0: 367.5mV
0x1: 400mV
0x2: 435mV
0x3: 469mV
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_loft_mode" pos="2" rst="0">
        <comment>
          0 bypass
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_loft_en" pos="1" rst="0">
        <comment>
          1 enable
        </comment>
      </bits>
      <bits access="rw" name="rg_nb_loft_pu" pos="0" rst="0">
        <comment>
          0x1 enable
0x0 disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="loft_reg2">
      <bits access="r" name="loft_reg2_reserved_0" pos="15:4" rst="0">
      </bits>
      <bits access="rw" name="rg_nb_loft_resd" pos="3:0" rst="0">
      </bits>
    </reg>
    <hole size="576"/>
    <reg protect="r" name="filter_r_data_1">
      <bits access="r" name="filter_r_data_1_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="r" name="ad_nb_rx_filter_dcoc_cal_out_i_apb_d2" pos="13" rst="0">
      </bits>
      <bits access="r" name="ad_nb_rx_filter_dcoc_cal_out_q_apb_d2" pos="12" rst="0">
      </bits>
      <bits access="r" name="ad_nb_tx_filter_dcoc_cal_out_i_apb_d2" pos="11" rst="0">
      </bits>
      <bits access="r" name="ad_nb_tx_filter_dcoc_cal_out_q_apb_d2" pos="10" rst="0">
      </bits>
      <bits access="r" name="ad_sx_nbpll_digreg_sign_apb_d2" pos="9" rst="0">
      </bits>
      <bits access="r" name="ad_nb_rx_filter_dcoc_cal_out_i" pos="8" rst="0">
      </bits>
      <bits access="r" name="ad_nb_rx_filter_dcoc_cal_out_q" pos="7" rst="0">
      </bits>
      <bits access="r" name="ad_nb_rx_filter_dcoc_cal_out_i_d2" pos="6" rst="0">
      </bits>
      <bits access="r" name="ad_nb_rx_filter_dcoc_cal_out_q_d2" pos="5" rst="0">
      </bits>
      <bits access="r" name="ad_nb_tx_filter_dcoc_cal_out_i" pos="4" rst="0">
      </bits>
      <bits access="r" name="ad_nb_tx_filter_dcoc_cal_out_q" pos="3" rst="0">
      </bits>
      <bits access="r" name="ad_nb_tx_filter_dcoc_cal_out_i_d2" pos="2" rst="0">
      </bits>
      <bits access="r" name="ad_nb_tx_filter_dcoc_cal_out_q_d2" pos="1" rst="0">
      </bits>
      <bits access="r" name="ad_sx_nbpll_digreg_sign_d2" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="thm_syn_output">
      <bits access="r" name="thm_syn_output_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="r" name="ad_thm_data_valid_d2" pos="10" rst="0">
      </bits>
      <bits access="r" name="ad_thm_iest_d2" pos="9" rst="0">
      </bits>
      <bits access="r" name="ad_thm_data_val_reg" pos="8" rst="0">
      </bits>
      <bits access="r" name="ad_thm_data_reg" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="pd_syn_output">
      <bits access="r" name="pd_syn_output_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="r" name="ad_nb_sx_lock_d2" pos="11" rst="0">
      </bits>
      <bits access="r" name="ad_nb_pd_data_valid_d2" pos="10" rst="0">
      </bits>
      <bits access="r" name="ad_nb_pd_iest_d2" pos="9" rst="0">
      </bits>
      <bits access="r" name="ad_nb_pd_data_val_reg" pos="8" rst="0">
      </bits>
      <bits access="r" name="ad_nb_pd_data_reg" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="thm_pd_read_flagt">
      <bits access="r" name="thm_pd_read_flagt_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="load_rg_pd" pos="1" rst="0">
      </bits>
      <bits access="rw" name="load_rg_thm" pos="0" rst="0">
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "rf_spi.xml">

    <var    name="CMD_FIFO_LEN_BITS" value="5"/>
    <var    name="CMD_FIFO_LEN" value="20"/> 
    <var    name="CMD_SIZE_BITS" value="8"/>
    
    <var    name="CMD_DATA_FIFO_LEN_BITS" value="4"/>
    <var    name="CMD_DATA_FIFO_LEN" value="exp2(CMD_DATA_FIFO_LEN_BITS)"/>
    
    <var    name="GAIN_TABLE_LEN_BITS" value="4"/>
    <var    name="GAIN_TABLE_LEN" value="15"/>  
    <var    name="GAIN_SIZE_BITS" value="4"/>

    <var    name="RX_DATA_FIFO_LEN_BITS" value="2"/>
    <var    name="RX_DATA_FIFO_LEN" value="exp2(RX_DATA_FIFO_LEN_BITS)"/>
    

<module name="rf_spi" category="Modem">

    <reg name="Ctrl" protect="rw">
        <bits name="Enable"         pos="0"     access="rw" rst="0">
            <comment>Enable the rf spi
                <br/>1 = Enable
                <br/>0 = Disable (will finish current command anyway)
            </comment>
        </bits>
        <bits name="CS_Polarity"    pos="1"     access="rw" rst="1">
            <comment>Chip select polarity
                <br/>1 = the chip select is active low
                <br/>0 = the chip select is active high
            </comment>
        </bits>
        <bits name="DigRF_Read"     pos="2"     access="rw" rst="1">
            <comment>DigRF Read style mode
                <br/>1 = DigRF Read style mode (read after CS disabled)
                <br/>0 = SPI Read mode (read during write)
            </comment>
        </bits>
        <bits name="Clocked_Back2Back"  pos="3" access="rw" rst="1">
            <comment>DigRF style clocked back to back mode
                <br/>1 = clocked back to back transfers using turnarround timing only when more data are present in the FIFO.
                <br/>0 = stop the clock between each access according to CS_End_Hold and CS_Pulse_Min timings
            </comment>
        </bits>
        <bits name="Input_Mode"     pos="4"     access="rw" rst="1">
            <comment>Input mode
                <br/>1 = Record input data to input FIFO
                <br/>0 = No input data
            </comment>
        </bits>
        <bits name="Clock_Polarity" pos="5"     access="rw" rst="0">
            <comment>SPI Clock polarity
                <br/>1 = the clock disabled level is high, and the first edge is a falling edge.
                <br/>0 = the clock disabled level is low, and the first edge is a rising edge.
            </comment>
        </bits>
        <bits name="Clock_Delay"    pos="7:6"   access="rw" rst="3">
            <comment>Transfer start to first edge delay
                <br/> value from 0 to 2 is the number of spi clock half period between the Transfer start and the first clock edge.
            </comment>
        </bits>
        <bits name="DO_Delay"       pos="9:8"   access="rw" rst="3">
            <comment>Transfer start to first data out delay
                <br/> value from 0 to 2 is the number of spi clock half period between the Transfer start and the first data out.
            </comment>
        </bits>
        <bits name="DI_Delay"       pos="11:10" access="rw" rst="3">
            <comment>Transfer start to first data in sampled delay
                <br/> value from 0 to 3 is the number of spi clock half period between the Transfer start and the first data sampled in.
                <br/> The DI_Delay only specify the sampling time, for frame size, the counter is based on the DO_Delay even in DigRF read mode.
            </comment>
        </bits>
        <bits name="CS_Delay"       pos="13:12" access="rw" rst="3">
            <comment>Transfer start to CS activation delay
                <br/> value from 0 to 3 is the number of spi clock half period between the Transfer start and the CS activation edge.
            </comment>
        </bits>
        <bits name="CS_End_Hold"    pos="15:14" access="rw" rst="3">
            <comment>Transfer end to chip select deactivation delay
                <br/> value from 0 to 3 is the number of spi clock half period between the end of transfer (DO) and the CS deactivation edge.
                <br/> <Strong>Not used for Clocked_Back2Back mode</Strong>
            </comment>
        </bits>
        <bits name="Frame_Size"     pos="20:16" access="rw" rst="31">
            <comment>Number of data in the frame, or number of out data in DigRF read mode.
                <br/>The actual frame size is the value of this register + 1; valid value are 3 to 31 (frame size 4 to 32bits)
                <br/>The frame size is given for the number of data, the actual number of clock pulses might be greater. First if Clock_Delay &lt; DO_Delay an extra clock pulse is generated, second in case of DigRF read or back2back, some more clock pulses will be generated.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="CS_End_Pulse"   pos="23:22" access="rw" rst="3">
            <comment>Chip select deactivation to new start of transfer minimum delay
                <br/>value from 0 to 3 is the number of spi clock half period between the CS deactivation and a new transfer start (transfer will start only if more data are available in the transmit FIFO)
                <br/> <Strong>Not used for Clocked_Back2Back mode</Strong>
            </comment>
        </bits>
        <bits name="Input_Frame_Size"   pos="28:24" access="rw" rst="31">
            <comment>When DigRF input mode: The actual frame size is the value of this register + 1; valid value are 3 to 31 (frame size 4 to 32bits)
                <br/>When Normal SPI input mode: When 0: regular mode, SPI_DO pin as output only; Other: Value from 1 to 31 is the number of data out to transfert before the SPI_DO pin switch to input;
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="TurnAround_Time"    pos="31:30" access="rw" rst="3">
            <comment>TurnAround time: end of write frame to start of read frame delay (in cycles)
                <br/>value from 0 to 3 is the number of spi clock period between the end of the output frame (without the DO_Delay) and the Input Frame start.
                <br/>Also used for Clocked_Back2Back mode, when Clocked_Back2Back=1 and there is more data available in the transmit FIFO:
                <br/>value from 0 to 3 is the number of spi clock period between the end of the frame (without the DO_Delay) and the start of the new frame.
                (It can also be seen as the number of spi clock period between the end of the last data bit and the start of the new data bit.)
            </comment>
        </bits>
    </reg>
    <reg name="Status" protect="rw">
        <bits name="Active_Status"      pos="0"     access="r" rst="0">
            <comment>The SPI activity status
                <br/>1 = A transfer is in progress
                <br/>0 = The transfer is done
            </comment>
        </bits>
        <bits name="Error_Cmd"          pos="1"     access="rc" rst="0">
            <comment>Error status
                <br/>1 = a new command (or gain) has been requested while a command was in progress.
                <br/>0 = No error
                <br/>Write 1 to clear.
            </comment>
        </bits>
        <bits name="Table_Ovf"          pos="6"     access="rc" rst="0">
            <comment>The Gain Table overflow status.
                <br/>1 = Too many data has been written in the table
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Table_Udf"          pos="7"     access="rc" rst="0">
            <comment>The Gain Table underflow status.
                <br/> 1 = a next gain request has been received while the read pointer was already at the top of the table.
                <br/> Writing a '1' clear the underflow status.
            </comment>
        </bits>
        <bits name="Cmd_Level"          pos="CMD_FIFO_LEN_BITS+7:8" access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Command FIFO level, number of command in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Ovf"            pos="14"    access="rc" rst="0">
            <comment>The command FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Cmd_Udf"            pos="15"    access="rc" rst="0">
            <comment>The command FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
        <bits name="Cmd_Data_Level"     pos="CMD_DATA_FIFO_LEN_BITS+16:16"  access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Command FIFO level, number of bytes in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Data_Ovf"       pos="22"    access="rc" rst="0">
            <comment>The command data FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Cmd_Data_Udf"       pos="23"    access="rc" rst="0">
            <comment>The command data FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
        <bits name="Rx_Level"           pos="RX_DATA_FIFO_LEN_BITS+24:24"   access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Receive FIFO level, number of bytes in the FIFO
            </comment>
        </bits>
        <bits name="Rx_Ovf"             pos="30"    access="rc" rst="0">
            <comment>The receive FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Rx_Udf"             pos="31"    access="rc" rst="0">
            <comment>The receive FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
    </reg>
    <reg name="Rx_Data" protect="">
        <bits name="Rx_Data"    pos="7:0"   access="rw"  rst="no">
            <comment>Read in the receive FIFO
                <br/>Writing this register will write to Cmd_Data fifo (same as Cmd_Data register). This is because this address is used by the IFC channels to access the fifos.
            </comment>
        </bits>
    </reg>
    <reg name="Command" protect="w">
        <bits name="Send_Cmd"           pos="0"     access="w" rst="0">
            <comment> Writing 1 send the next command in the Cmd FIFO (This replace the TCU next cmd signal)
            </comment>
        </bits>
        <bits name="Flush_Cmd_FIFO"     pos="8"     access="w" rst="0">
            <comment>Writing 1 flush both Cmd, and cmd_data FIFO, <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Flush_Rx_FIFO"      pos="16"    access="w" rst="0">
            <comment>Writing 1 flush the receive data FIFO, <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Restart_Gain"       pos="24"    access="w" rst="0">
            <comment>Writing 1 place the read pointer at the beginning of the gain table. <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Reload_Gain"        pos="28"    access="w" rst="0">
            <comment>Writing 1 place the write pointer at the beginning of the gain table allowing to fill the table.
            </comment>
        </bits>
        <bits name="Drive_Zero"         pos="31"    access="rw" rst="0">
            <comment>Writing 1 change all the ouputs of the SPI interface to drive a logical '0'. This mode stops when a new command is requested to be send (by TCU) or when writting 0 to this register. This mode is useful when powering off the tranciever chip connected to the RF_SPI.
            </comment>
        </bits>
    </reg>
    <reg name="Cmd_Size" protect="w">
        <bits name="Cmd_Size"    pos="CMD_SIZE_BITS-1:0"   access="w"  rst="no">
            <comment>Write the size in bytes of the next command in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Mark"   pos="31"    access="w"  rst="no">
            <comment>Write 1 to mark the command.
                <br/>Marked commands are discarded if Enable_Rf_Spi_Marked_Cmd is low in the tcu register.
            </comment>
        </bits>
    </reg>
    <reg name="Cmd_Data" protect="w">
        <bits name="Cmd_Data"    pos="7:0"   access="w"  rst="no">
            <comment>Write in the Command data FIFO
            </comment>
        </bits>
    </reg>
    <reg name="Gain_Size" protect="rw">
        <bits name="Gain_Size"   pos="GAIN_SIZE_BITS-1:0"   access="rw"  rst="0">
            <comment>Size of a Gain command in bytes.
            </comment>
        </bits>
    </reg>
    <reg name="Gain_Data" protect="w">
        <bits name="Gain_Data"   pos="7:0"   access="w"  rst="no">
            <comment>Write in the Gain Table (the pointer auto increments)
            </comment>
        </bits>
    </reg>
    <reg name="IRQ" protect="rw">
        <bits name="Cmd_Data_DMA_Done_Cause"    pos="0" access="rc" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Cause bit
                <br/> 1 = the IRQ was triggered by the end of the DMA transfer to the cmd FIFO.
                <br/> To clear it write 1 in this bit or Cmd_Data_DMA_Done_Status bit.
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Cause"       pos="2" access="r" rst="0">
            <comment>Cmd_FIFO_empty IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Cmd_FIFO is empty.
                <br/> To clear it, fill the FIFO.
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Cause"        pos="3" access="r" rst="0">
            <comment>Cmd_Threshold IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Cmd_FIFO level is below the Cmd_Threshold.
                <br/> To clear it, fill the FIFO.
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Cause"         pos="4" access="r" rst="0">
            <comment>Rx_FIFO_full IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Rx_Data_FIFO is full.
                <br/> To clear it, read from the FIFO.
            </comment>
        </bits>
        <bits name="Rx_Threshold_Cause"         pos="5" access="r" rst="0">
            <comment>Rx_Threshold IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Rx_Data_FIFO level is over the Rx_Threshold.
                <br/> To clear it, read from the FIFO.
            </comment>
        </bits>
        <bits name="Error_Cause"                pos="6" access="r" rst="0">
            <comment>Error IRQ Cause bit
                <br/> 1 = the IRQ was triggered because an error occured. Read the Status register to check the kind of error.
                <br/> To clear it, clear it in the Status register.
            </comment>
        </bits>
        <bitgroup name="All_Cause">
            <entry ref="Cmd_Data_DMA_Done_Cause"/>
            <entry ref="Cmd_FIFO_empty_Cause"/>
            <entry ref="Cmd_Threshold_Cause"/>
            <entry ref="Rx_FIFO_full_Cause"/>
            <entry ref="Rx_Threshold_Cause"/>
            <entry ref="Error_Cause"/>
        </bitgroup>
        <bits name="Cmd_Data_DMA_Done_Status"   pos="16"    access="rc" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Status bit
                <br/> 1 = the end of the DMA transfer to the cmd FIFO occured.
                <br/> To clear it write 1 in this bit or Cmd_Data_DMA_Done_Cause bit.
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Status"      pos="18"    access="r" rst="1">
            <comment>Cmd_FIFO_empty IRQ Status bit
                <br/> 1 = the Cmd_FIFO is empty.
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Status"       pos="19"    access="r" rst="1">
            <comment>Cmd_Threshold IRQ Status bit
                <br/> 1 = the Cmd_FIFO level is bellow the Cmd_Threshold.
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Status"        pos="20"    access="r" rst="0">
            <comment>Rx_FIFO_full IRQ Status bit
                <br/> 1 = the Rx_Data_FIFO is full.
            </comment>
        </bits>
        <bits name="Rx_Threshold_Status"        pos="21"    access="r" rst="0">
            <comment>Rx_Threshold IRQ Status bit
                <br/> 1 = the Rx_Data_FIFO level is over the Rx_Threshold.
            </comment>
        </bits>
        <bits name="Error_Status"               pos="22"    access="r" rst="0">
            <comment>Error IRQ Status bit
                <br/> 1 = an error occured. Read the Status register to check the kind of error.
            </comment>
        </bits>
        <bitgroup name="All_Status">
            <entry ref="Cmd_Data_DMA_Done_Status"/>
            <entry ref="Cmd_FIFO_empty_Status"/>
            <entry ref="Cmd_Threshold_Status"/>
            <entry ref="Rx_FIFO_full_Status"/>
            <entry ref="Rx_Threshold_Status"/>
            <entry ref="Error_Status"/>
        </bitgroup>
    </reg>
    <reg name="IRQ_Mask" protect="rw">
        <bits name="Cmd_Data_DMA_Done_Mask"     pos="0" access="rw" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Mask bit
                <br/> 1 = the Cmd_Data_DMA_Done IRQ is enabled
                <br/> 0 = the Cmd_Data_DMA_Done IRQ is disabled
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Mask"        pos="2" access="rw" rst="0">
            <comment>Cmd_FIFO_empty IRQ Mask bit
                <br/> 1 = the Cmd_FIFO_empty IRQ is enabled
                <br/> 0 = the Cmd_FIFO_empty IRQ is disabled
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Mask"         pos="3" access="rw" rst="0">
            <comment>Cmd_Threshold IRQ Mask bit
                <br/> 1 = the Cmd_Threshold IRQ is enabled
                <br/> 0 = the Cmd_Threshold IRQ is disabled
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Mask"          pos="4" access="rw" rst="0">
            <comment>Rx_FIFO_full IRQ Mask bit
                <br/> 1 = the Rx_FIFO_full IRQ is enabled
                <br/> 0 = the Rx_FIFO_full IRQ is disabled
            </comment>
        </bits>
        <bits name="Rx_Threshold_Mask"          pos="5" access="rw" rst="0">
            <comment>Rx_Threshold IRQ Mask bit
                <br/> 1 = the Rx_Threshold IRQ is enabled
                <br/> 0 = the Rx_Threshold IRQ is disabled
            </comment>
        </bits>
        <bits name="Error_Mask"                 pos="6" access="rw" rst="0">
            <comment>Error IRQ Mask bit
                <br/> 1 = the Error IRQ is enabled
                <br/> 0 = the Error IRQ is disabled
            </comment>
        </bits>
        <bitgroup name="All_Mask">
            <entry ref="Cmd_Data_DMA_Done_Mask"/>
            <entry ref="Cmd_FIFO_empty_Mask"/>
            <entry ref="Cmd_Threshold_Mask"/>
            <entry ref="Rx_FIFO_full_Mask"/>
            <entry ref="Rx_Threshold_Mask"/>
            <entry ref="Error_Mask"/>
        </bitgroup>
    </reg>
    <reg name="IRQ_Threshold" protect="rw">
        <bits name="Cmd_Threshold"      pos="CMD_FIFO_LEN_BITS+7:8" access="r" rst="all1">
            <comment>Command FIFO Threshold, number of command in the FIFO bellow which the Cmd_Threshold_IRQ is triggered.
            </comment>
        </bits>
        <bits name="Rx_Threshold"       pos="RX_DATA_FIFO_LEN_BITS+23:24"   access="r" rst="all1">
            <comment>Receive FIFO Threshold, number of bytes in the FIFO above which the Rx_Threshold_IRQ is triggered.
            </comment>
        </bits>
    </reg>
    <reg name="Divider" protect="rw">
        <bits name="Divider"    pos="6:1"   access="rw" rst="0">
            <comment>Clock Divider
                <br/>The state machine clock is generated by dividing the system clock by the value of this register + 1. So the output clock is divided by (register + 1)*2
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Clock_Limiter" pos="28" access="rw" rst="0">
            <comment>When enabled the clock input to the divider is not the system clock, but a limited version of it: It cannot be above 52MHz, so the output clock will never be above 26MHz.
                <br/> for system clock of 104Mhz the clock input to the divider is 52Mhz, for system clock of 78Mhz the clock input to the divider is 39Mhz, for lower system clock value, the input to the divider is the system clock.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative = "rom_patch.xml">
  <var name="NB_ROM_PATCH"   value="16" />               
  <var name="ROM_PATCH_SIZE" value="NB_ROM_PATCH*4" />   

  
  <module name="rom_patch" category="System">
    
    <reg name="rom_patch" count="NB_ROM_PATCH" protect="rw">
        <bits name="block_addr" pos="17:4" access="rw" rst = "0">
            <comment>Base address of block in int_Rom patched (corresponding data are read from int_SRam)
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="patch_en"  pos="31"    access="rw" rst="0">
            <options>
                <option name="Enable" value="1"/>
                <option name="Disable" value="0"/>
            </options>
        </bits>
    </reg>
    
    <hole size="1536"/>
      
    <reg name="ram_array" count="ROM_PATCH_SIZE" protect="wo">
      <comment>Rom patch Ram Space
        <br/> Used for store the patch instead of rom, when patch is valid
      </comment>
    </reg>
  </module>

</archive>
<archive relative = "sci.xml">
<module name="sci" category="Modem">
    <reg name="Config" protect="rw">
        <bits name="Enable" pos="0" access="rw" rst="0">
            <comment>Enables the SIM Card IF module
            </comment>
        </bits>
        <bits name="Parity" pos="1" access="rw" rst="0">
            <comment>Selects the parity generation/detection
            </comment>
            <options>
                <option value="0" name="Even_parity"/>
                <option value="1" name="Odd_parity"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="PERF" pos="2" access="rw" rst="0">
            <comment>Parity Error Receive Feed-through
                <br/>0 = Don't store bytes with detected parity errors
                <br/>1 = Feed-through bytes with detected parity errors
            </comment>
        </bits>
        <bits name="Filter_Disable" pos="3" access="rw" rst="0">
            <comment>Enable or disable NULL (0x60) character filtering when SIM card sends NULL to reset WWT timer.
                <br/>0 = Enable NULL character filtering, NULL characters are not reported if not data.
                <br/>1 = Disable NULL character filtering.  NULL characters (0x60) are transferred to the SCI data buffer.
            </comment>
        </bits>
        <bits name="ClockStop" pos="4" access="rw" rst="1">
            <comment>Manual SCI Clock Stop control.  Manually starts and stops the SCI clock.  This bit must be set to '1' when Autostop mode is enabled.
                <br/>0 = Enable the SCI clock
                <br/>1 = Disable SCI clock
            </comment>
        </bits>
        <bits name="AutoStop_En_H" pos="5" access="rw" rst="0">
            <comment>Enables automatic clock shutdown when command is complete.  Enabling this will generate the necessary startup and shutdown delays required by the SIM protocol.
                <br/>0 = Auto clock control not enabled.  SCI clock controlled by SCI_Clockstop bit
                <br/>1 = Auto clock control enabled.
            </comment>
        </bits>
        <bits name="MSBH_LSBL" pos="6" access="rw" rst="1">
            <comment>Sets the transmission and reception bit order:
                <br/>0 = LSB is sent/recieved first (Direct convention)
                <br/>1 = MSB is sent/received first (Inverse convention)
            </comment>
        </bits>
        <bits name="LLI" pos="7" access="rw" rst="1">
            <comment>Logic Level Invert:
                <br/>0 = Logic level 0 data is sent/received as '0' or 'A' which is the same as the start bit.  (Direct convention)
                <br/>1 = Logic level 0 data is sent/received as '1' or 'Z' which is the opposite of the start bit.  (Inverse convention)
            </comment>
        </bits>
        <bits name="PEGen_Len" pos="8" access="rw" rst="0">
            <comment>Parity Error signal length.  This configuration bit can be used to extend the duration of the parity error signal generation from 1 ETU to 1.5 ETU
                <br/>0 = Parity Error signal duration is 1 ETU starting at 10.5 ETU
                <br/>1 = Parity Error signal duration is 1.5 ETU starting at 10.5 ETU
            </comment>
        </bits>
        <bits name="Parity_En" pos="9" access="rw" rst="0">
            <comment>Enable or disable parity error checking on the receive data
                <br/>0 = Disable parity error checking
                <br/>1 = Enable parity error checking
            </comment>
        </bits>
        <bits name="Stop_Level" pos="10" access="rw" rst="1">
            <comment>Logical value of the clock signal when SCI clock is stopped (either due to automatic shutdown or manual shutdown)
                <br/>0 = Stop clock at low level
                <br/>1 = Stop clock at high level
            </comment>
        </bits>
        <bits name="Rx_Clk_Cnt_Sample " pos="15:11" access="rw" rst="1">
            <comment> tunning the sample local.
            </comment>
        </bits>
        <bits name="ARG_H" pos="16" access="rw" rst="0">
            <comment>Automatic Reset Generator.  Write a '1' to this bit to initiate an automatic reset procedure on the SIM.  Write '0' to switch back to SCI_Reset control (bit 20).  An ARG interrupt will be generated if the ARG process succeeded or failed.  The ARG status bit (ARG_Det) must be read to determine if a reset response from the card was detected.  This bit needs to be cleared between ARG attempts.
            </comment>
        </bits>
        <bits name="AFD_En_H" pos="17" access="rw" rst="0">
            <comment>Automatic format detection.  This bit is generally set in conjunction with the ARG_H bit to enable automatic detection of the data convention.
                <br/>1 = Enable TS detection and automatic convention settings programming
                <br/>0 = disable automatic settings and use the register bits (MSBH_LSBL and LLI) to control the convention
            </comment>
        </bits>
        <bits name="Tx_Resend_En_H" pos="18" access="rw" rst="1">
            <comment>1 = Enable automatic resend of characters when Tx parity error is detected
                <br/>0 = Disable automatic resend
            </comment>
        </bits>
        <bits name="IO_data_l" pos="19" access="rw" rst="0">
            <comment>1 = pulldown
                <br/>0 = pullup
            </comment>
        </bits>
        <bits name="Reset" pos="20" access="rw" rst="0">
            <comment>Direct connection to the SIM card reset pin.  This is overridden when ARG_H is enabled
                <br/>0 = SCI_Reset low voltage
                <br/>1 = SCI Reset high voltage
            </comment>
        </bits>
        <bits name="Dly_Sel" pos="21" access="rw" rst="0">
            <comment>This selects between two delay times for the automatic clock stop startup and shutdown:
                <br/>0 = short delay
                <br/>Startup/Shutdown : 744 SCI clocks / 1860 SCI clocks
                <br/>1 = long delay
                <br/>Startup/Shutdown : (2 x 744) SCI clocks / (2 x 1860) SCI clocks
            </comment>
        </bits>
        <bits name="In_avg_en" pos="22" access="rw" rst="1">
            <comment>Input data average enable.
                <br/>0 = Disable
                <br/>1 = Enable
            </comment>
        </bits>
        <bits name="Int_sw" pos="23" access="rw" rst="0">
            <comment>auto clear.
            </comment>
        </bits>
        <bits name="Par_Chk_Offset" pos="29:24" access="rw" rst="0xe">
            <comment>Allows fine control of the parity check position during the parity error time period.
            </comment>
        </bits>
        <bits name="Sci_Mode" pos="31:30" access="rw" rst="0">
            <comment>These bits are reserved and must be written as '00' for the SCI module to work properly:
                <br/>"11" = Ser In &lt;- Ser Out loopback
                <br/>"10" = Ser In &lt;- Ser In (unmasked)
                <br/>others = Ser In &lt;- Ser In masked with Txing_H (normal mode)
            </comment>
        </bits>
    </reg>
    <reg name="Status" protect="r">
        <bits name="RxData_Rdy" pos="0" access="r" rst="0">
            <comment>Returns the status of the Rx FIFO:
                <br/>0 = Rx FIFO empty
                <br/>1 = There is at least 1 character in the Rx FIFO
            </comment>
        </bits>
        <bits name="Tx_FIFO_Rdy" pos="1" access="r" rst="1">
            <comment>Returns the status of the Tx FIFO:
                <br/>0 = Tx FIFO is full
                <br/>1 = There is at least 1 free spot in the Tx FIFO
            </comment>
        </bits>
        <bits name="Format_Det" pos="2" access="r" rst="0">
            <comment>Returns the status of the automatic format detection after reset:
                <br/>0 = TS character has not been detected in the ATR
                <br/>1 = TS character has been detected and SCI module is using the automatic convention settings
                <br/>
                <br/>This bit is cleared when the AFD_En bit is cleared
            </comment>
        </bits>
        <bits name="ARG_Det" pos="3" access="r" rst="0">
            <comment>Returns the status of the automatic reset procedure:
                <br/>0 = ARG detection has failed
                <br/>1 = ARG detection has detected that the SIM has responded to the reset
                <br/>
                <br/>This bit is used in conjunction with the ARG interrupt.  The ARG interrupt will be generated at the successful or unsuccessful termination of the ARG process.  This bit can be used to determine the success or failure.
            </comment>
        </bits>
        <bits name="Reset_Det" pos="4" access="r" rst="0">
            <comment>This is the status of the Reset pin when automatic reset generation is enabled.  This bit can be used to discover whether the SIM card that has successfully responded to an ARG procedure has an active high or active low reset. (Det means 'Detection')
            </comment>
        </bits>
        <bits name="Clk_Rdy_H" pos="5" access="r" rst="0">
            <comment>Status of the control signal to the clock control module.  This bit respects the startup and shutdown phases, so during these times, the clock may actually be on, but it is not considered to be 'ready'
                <br/>0 = SCI clock may be on or off but is not ready for use
                <br/>1 = SCI clock is on and ready for use
            </comment>
        </bits>
        <bits name="Clk_Off" pos="6" access="r" rst="1">
            <comment>Status bit of the Sci clock. 
                <br/>0 = Sci clock is ON
                <br/>1 = Sci clock is OFF
            </comment>
        </bits>
        <bits name="Rx_Err" pos="8" access="r" rst="0">
            <comment>A receive parity error was detected. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="Tx_Err" pos="9" access="r" rst="0">
            <comment>A transmit parity error was detected. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="RxOverflow" pos="10" access="r" rst="0">
            <comment>The internal receive FIFO has reached an overflow condition. Reading this register clears the bit.
            </comment>
        </bits> 
        <bits name="TxOverflow" pos="11" access="r" rst="0">
            <comment>The internal transmit FIFO has reached an overflow condition. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="AutoStop_State" pos="31:30" access="r" rst="0">
            <comment>Returns the state of the clock management state machine when AutoStop mode is enabled.  This value is '00' when manual mode is selected.
            </comment>
            <options>
                <option value="0" name="Startup_phase"><comment>Clock is on, but not ready to be used.</comment></option>
                <option value="1" name="Auto_on"><comment>Clock is on and ready to be used</comment></option>
                <option value="2" name="Shutdown_phase"><comment>Clock is still on, but should not be used.</comment></option>
                <option value="3" name="Clock_off"><comment>Clock is off.</comment></option>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name="Data" protect="--">
        <bits name="Data_IN" pos="7:0" access="w" rst="0">
            <comment>Writing to this register will send the data to the SIM card. If automatic clock shutdown is enabled, the appropriate delay will be applied before the data is actually sent. 
            </comment>
        </bits>
        <bits name="Data_OUT" pos="7:0" access="r" rst="0">
            <comment>Reading this register will read from the receive data FIFO.
            </comment>
        </bits>
    </reg>
    <reg name="ClkDiv" protect="rw">
        <bits name="ClkDiv" pos="8:0" access="rw" rst="0x174">
            <comment>Clock divider for generating the baud clock from the SCI clock.  This value must match the value used by the SIM card whose default value is 0x174.
            </comment>
        </bits>
        <bits name="Baud_x8_En" pos="9" access="rw" rst="0">
            <comment>Speed mode enable.
                <br/>0 = Low speed mode
                <br/>1 = High speed mode(372/32, 372/64, 512/64)
            </comment>
        </bits>
        <bits name="Rx_Clk_Cnt_Limit" pos="14:10" access="rw" rst="0x10">
            <comment>Rx_clk_cnt wrap value.
            </comment>
         </bits>
        <bits name="Clk_Tst" pos="15" access="rw" rst="0">
          </bits>
        <bits name="ClkDiv_16" pos="23:16" access="rw" rst="0x18">
            <comment>Secondary clock divider for generating 16x baud clock.
            </comment>
        </bits>
        <bits name="MainDiv" pos="29:24" access="rw" rst="0x4">
            <comment>Main clock divider to generate the SCI clock.  This value should be calculated as follows:
                <br/>MainDiv = Clk_Sys/(2xSCI_Clk) - 1
                <br/>where SCI_Clk is in the range of 3-5 MHz as specified in the SIM specification.
            </comment>
            <options><mask/><default/></options>
        </bits>
        <bits name="Clk_Out_Inv" pos="30" access="rw" rst="0">
            <comment>Inverts the polarity of the SCI clock to the SIM card only.
                <br/>0 = No inversion
                <br/>1 = Invert external SCI clock
            </comment>
        </bits>
        <bits name="Clk_Inv" pos="31" access="rw" rst="0">
            <comment>Inverts  SCI clock to the SIM card .
                <br/>0 = No inversion
                <br/>1 = Invert external SCI clock
            </comment>
        </bits>
    </reg>
    <reg name="RxCnt" protect="rw">
        <bits name="RxCnt" pos="9:0" access="rw" rst="0">
            <comment>This value should be programmed with the number of expected characters to receive.  It will be decremented each time a character is <strong>actually</strong> received and should be 0 when the transfer is complete.  If a character is sent after the RxCnt reaches zero, the extra character flag will be set but this value will stay at zero.
            </comment>
        </bits>
        <bits name="Clk_Persist" pos="31" access="rw" rst="0">
            <comment>When in automatic clock shutdown mode, this bit can prevent the clock from entering shutdown mode when the transfer is complete.  This should be used for multi-transfer commands where the clock must not be shut down until the command is complete.  This bit must be programmed for each transfer.
                <br/>1 = Keep clock on
                <br/>0 = Allow clock shutdown when transfer is complete
            </comment>
        </bits>
    </reg>
    <reg name="Times" protect="rw">
        <bits name="ChGuard" pos="7:0" access="rw" rst="1">
            <comment>This is the extra guard time that can be added to the 2 ETU minimum (and default) guard time between successive transmitted characters.  This should be programmed depending on the SIM's ATR.  The total ETU guard time will be ChGuard + 1.
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="TurnaroundGuard" pos="11:8" access="rw" rst="0x6">
            <comment>Turnaround guard time configuration.  This value can be used to adjust the delay between the leading edge of a received character and the leading edge of the next transmitted character.  The minimum time specified in the SIM recommendation is 16 ETU.  The number of ETUs can be calculated using the following formula:
                <br/>Total Turnaround Time (in ETUs) = 11 + TurnaroundGuard
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="WI" pos="23:16" access="rw" rst="0x0A">
            <comment>Work Waiting Time factor.  A timeout will be generated when the WWT is exceeded.  The WWT is calculated by:
                <br/>       WWT = 960 x WI x (F/Fi)
                <br/>where Fi is the main SCI clock frequency (3-5 MHz) and F is 372 before an enhanced PPS and 512 after an enhanced PPS.
                <br/>The SCI_WI value must be calculated as follows:
                <br/>       SCI_WI = WI * D
                <br/>Thus, by default (WI = 10) this value needs to be set to 10 before an EPPS, but needs to be scaled to WI*D=80 after the EPPS procedure.
            
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="Tx_PERT" pos="31:24" access="rw" rst="0xFF">
            <comment>Number of times to try resending character when the SIM indicates a parity error.
            </comment>
        </bits>
    </reg>  
    <reg name="Ch_Filt" protect="rw">
        <bits name="Ch_Filt" pos="7:0" access="rw" rst="0x60">
            <comment>Value of the character to be filtered.  0x60 is the NULL character in the SIM protocol.  If character filtering is enabled, the <strong>first</strong> 0x60 character that is received by the SIM during a transfer will <strong>not</strong> be recorded.  The purpose of this character is to enable the SIM to reset the WWT counter when the SIM is not ready to send the data.  This filter has no effect on characters within the datastream.
            </comment>
        </bits>
    </reg>  
    
    <reg name="dbg" protect="w">
        <bits name="FIFO_RX_Clr" pos="0" access="w" rst="0">
            <comment>Clear RX FIFO.
            </comment>
        </bits>     
        <bits name="FIFO_TX_Clr" pos="1" access="w" rst="0">
            <comment>Clear TX FIFO.
            </comment>
        </bits>     
        <comment>UNDOCUMENTED FEATURE</comment>
    </reg>  
    <reg name="Int_Cause" protect="r">
        <bits name="Rx_Done" pos="0" access="r" rst="0">
            <comment>Number of expected Rx characters, as programmed in the RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="r" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="r" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="r" rst="0">
            <comment>An extra character has been received after the number of characters in RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="r" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="r" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Tx_Done" pos="6" access="r" rst="0">
            <comment>DMA tx done.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Rx_Done" pos="7" access="r" rst="0">
            <comment>DMA rx done.
            </comment>
        </bits>     
        <bits name="Int_Status_Rx_Done" pos="16" access="r" rst="0">
            <comment>Number of expected Rx characters, as programmed in the RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Int_Status_Rx_Half" pos="17" access="r" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="Int_Status_WWT_Timeout" pos="18" access="r" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Int_Status_Extra_Rx" pos="19" access="r" rst="0">
            <comment>An extra character has been received after the number of characters in RxCnt has been received.
            </comment>
        </bits>
        <bits name="Int_Status_Resend_Ovfl" pos="20" access="r" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the Tx_PERT field.
            </comment>
        </bits>     
        <bits name="Int_Status_ARG_End" pos="21" access="r" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <bits name="Int_Status_Sci_DMA_Tx_Done" pos="22" access="r" rst="0">
            <comment>DMA tx done.
            </comment>
        </bits>     
        <bits name="Int_Status_Sci_DMA_Rx_Done" pos="23" access="r" rst="0">
            <comment>DMA rx done.
            </comment>
        </bits>     
        <comment>
            This register is a <b>READ ONLY</b> register that returns the logical <b>and</b> of the SCI_INT_STATUS register and the SCI_INT_MASK. If any of these bits is '1', the SCI module will generate an interrupt.  Bits 21:16 return the <u>status</u> of the interrupt which is the interrupt state before the mask is applied.  These bits should only be used for debugging.
        </comment>
    </reg>  
    <reg name="Int_Clr" protect="rw">
        <bits name="Rx_Done" pos="0" access="c" rst="0">
            <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="c" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="c" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="c" rst="0">
            <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="c" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="c" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Tx_Done" pos="6" access="c">
            <comment>DMA tx done.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Rx_Done" pos="7" access="c">
            <comment>DMA rx done.
            </comment>
        </bits>     
        <comment>
            This is a WRITE ONLY register that is used to clear an SCI interrupt. Write a '1' to the interrupt that is to be cleared. Writing '0' has no effect.
        </comment>
    </reg>  
    <reg name="Int_Mask" protect="rw">
        <bits name="Rx_Done" pos="0" access="rw" rst="0">
            <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="rw" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="rw" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="rw" rst="0">
            <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="rw" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="rw" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>  
        <bits name="Sci_DMA_Tx_Done" pos="6" access="rw" rst="0">
            <comment>DMA tx done.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Rx_Done" pos="7" access="rw" rst="0">
            <comment>DMA rx done.
            </comment>
        </bits>     
        <comment>
            This register is READ/WRITE register that enables the desired interrupt. A '1' in a bit position indicates that the corresponding interrupt is enabled and if the interrupt occurs, the SCI will generate a hardware interrupt.
        </comment>
    </reg>  
    <reg name="PA_CLK_STOP_EN" protect="rw">
        <bits name="PA_CLK_STOP_EN" pos="0" access="rw" rst="0">
            <comment>Set this bit to 1'b0, then when pa_en = 1,sci stops work.
            </comment>
        </bits>
    </reg>
    <reg name="PA_STATUS" protect="r">
        <bits name="PA_STATUS" pos="0" access="r" rst="0">
            <comment>Status of pa_en.
            </comment>
        </bits>
    </reg>
    <reg name="WR_REG_ONGOING" protect="r">
        <bits name="CFG_REG_WR_ONGOING" pos="0" access="r" rst="0">
            <comment>Status of write operation.
            </comment>
        </bits>
        <bits name="CLKDIV_REG_WR_ONGOING" pos="1" access="r" rst="0">
            <comment>Status of write operation.
            </comment>
        </bits>
        <bits name="RXCNT_REG_WR_ONGOING" pos="2" access="r" rst="0">
            <comment>Status of write operation.
            </comment>
        </bits>
        <bits name="TIMES_REG_WR_ONGOING" pos="3" access="r" rst="0">
            <comment>Status of write operation.
            </comment>
        </bits>
        <bits name="CH_FILT_REG_WR_ONGOING" pos="4" access="r" rst="0">
            <comment>Status of write operation.
            </comment>
        </bits>
    </reg>
    <reg name="SCI_PWR_PROT" protect="rw">
        <bits name="Thold0" pos="7:0" access="rw" rst="0xff">
            <comment>after thold0, pull down rst
            </comment>
        </bits>
        <bits name="Thold1" pos="15:8" access="rw" rst="0xff">
            <comment>after thold1, pull down clk and io
            </comment>
        </bits>
        <bits name="Thold2" pos="23:16" access="rw" rst="0xff">
            <comment>after thold2, fsm into ST3. (unused)
            </comment>
        </bits>
        <bits name="En_Low_Pwr" pos="24" access="rw" rst="0">
            <comment> 
            </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative = "sdmmc2.xml">

<module name="sdmmc2" category="Periph">


    <reg name="apbi_ctrl_sdmmc" protect="rw">
       <bits name="L_Endian"  pos="2:0" access="rw" rst="000">
          <comment>Controls the big endian or little endian of the FIFO data.
              <br/>Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
              <br/>"000": the order is not changed.
                <br/>Byte3="0A",Byte2="0B",Byte1="0C",Byte0="0D".
              <br/>"001": reversed on byte.
                <br/>Byte3="0D",Byte2="0C,Byte1="0B",Byte0="0A".
              <br/>"010": reversed on half word.
                <br/>Byte3="0C",Byte2="0D,Byte1="0A",Byte0="0B".
              <br/>"010": reversed on bit.
                <br/>Byte3="B0",Byte2="30,Byte1="D0",Byte0="50".
              <br/>"100": reversed on bit.
                <br/>Byte3="0A",Byte2="0X,Byte1="0D",Byte0="0C".
          </comment>
       </bits> 
       <bits name="Soft_rst_L" pos="3" access="rw" rst="1">
          <comment>For the software to clear FIFO in case there is an error in communication with SD controller and some data are left behind.
              <br/>Active Low.
          </comment>
       </bits>
     </reg>

     <hole size="32"/>

     <reg name="APBI_FIFO_TxRx"  protect="--">   
         <bits name="DATA_IN" pos="31:0" access="w" rst="0">
           <comment>Write to the transmit FIFO
           </comment>
         </bits>
         <bits name="DATA_OUT" pos="31:0" access="r" rst="0">
           <comment>Read in the receive FIFO
           </comment>
         </bits>
     </reg>



<hole size="16288"/>

<reg protect="rw" name="SDMMC_CONFIG">

	<bits access="rw" name="SDMMC_SENDCMD" pos="0" rst="0">
		<comment>SD/MMC operation begin register, active high.<br /> 
		When '1', the controller finishes the last command and goes into suspend status. At suspend status, the controller will not execute the next command until the bit is set '0'.
		</comment>
	</bits>
	
	<bits access="rw" name="SDMMC_SUSPEND" pos="1" rst="1">
		<comment>SD/MMC operation suspend register, active high.
		</comment>
	</bits>
	
	<bits access="rw" name="RSP_EN" pos="4" rst="0">
		<comment>'1'indicates having a response,'0'indicates no response.
		</comment>
	</bits>
	
    <bits access="rw" name="RSP_SEL" pos="6:5" rst="0">
        <options>
            <default/>
            <option name="R2" value="0b10"/>
            <option name="R3" value="0b01"/>
            <option name="OTHER" value="0b00"/>
        </options>
		<comment>Response select register,"10" means R2 response, "01" means R3 response, "00" means others response, "11" is reserved.
		</comment> 
	</bits>
	
    <bits access="rw" name="RD_WT_EN" pos="8" rst="0">
		<comment>'1' indicates data operation, which includes read and write.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_WT_SEL" pos="9" rst="0">
        <options>
            <default/>
            <option name="READ" value="0"/>
            <option name="WRITE" value="1"/>
        </options>
		<comment>'1' means write operation,'0' means read operation.
		</comment>
	</bits>
	
	<bits access="rw" name="S_M_SEL" pos="10" rst="0">
        <options>
            <default/>
            <option name="SIMPLE"   value="0"/>
            <option name="MULTIPLE" value="1"/>
        </options>
		<comment>'1'means multiple block data operation.
		</comment>
	</bits>
	<bits access="rw" name="AUTO_FLAG_EN" pos="16" rst="1">
	</bits>
	
</reg>
	
<reg protect="r" name="SDMMC_STATUS">

	<bits access="r" name="Not_SDMMC_OVER" pos="0" rst="0">
		<comment>'1' means the SD/MMC operation is not over.
		</comment>
	</bits>
		
	<bits access="r" name="BUSY" pos="1" rst="0">
		<comment>'1' means SD/MMC is busy.
		</comment>
	</bits>	

	<bits access="r" name="DL_BUSY" pos="2" rst="0">
		<comment>'1' means the data line is busy.
		</comment>
	</bits>
	
	<bits access="r" name="SUSPEND" pos="3" rst="1">
		<comment>'1' means the controller will not perform the new command when SDMMC_SENDCMD= '1'.
		</comment>
	</bits>

	
	
		

	<bits access="r" name="RSP_ERROR" pos="8" rst="0">
		<comment>Response CRC checks error register '1' means response CRC check error.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_ERROR" pos="9" rst="0">
		<comment>'1' means the card has no response to command. 
		</comment>
	</bits>
	
	<bits access="r" name="CRC_STATUS" pos="14:12" rst="0">
		<comment>CRC check for SD/MMC write operation <br /> 
		"101" transmission error<br />
		"010" transmission right<br />
		"111" flash programming error
		</comment>
	</bits>
	
	<bits access="r" name="DATA_ERROR" pos="23:16" rst="0">
		<comment>8 bits data CRC check, "00000000" means no data error, "00000001" means DATA0 CRC check error, "10000000" means DATA7 CRC check error, each bit match one data line.
		</comment>
	</bits>

	<bits access="r" name="DAT3_VAL" pos="24" rst="-">
		<comment>SDMMC DATA 3 value.
		</comment>
	</bits>
	
</reg>

<reg protect="rw" name="SDMMC_CMD_INDEX">

	<bits access="rw" name="COMMAND" pos="5:0" rst="0">
		<comment>SD/MMC command register.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_CMD_ARG">

	<bits access="rw" name="ARGUMENT" pos="31:0" rst="0">
		<comment>SD/MMC command argument register, write data to the SD/MMC card.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_INDEX">

	<bits access="r" name="RESPONSE" pos="5:0" rst="0">
		<comment>SD/MMC response index register.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG3">

	<bits access="r" name="ARGUMENT3" pos="31:0" rst="0">
		<comment>Response argument of R1, R3 and R6, or 127 to 96 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG2">

	<bits access="r" name="ARGUMENT2" pos="31:0" rst="0">
		<comment>95 to 64 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG1">

	<bits access="r" name="ARGUMENT1" pos="31:0" rst="0">
		<comment>63 to 32 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG0">

	<bits access="r" name="ARGUMENT0" pos="31:0" rst="0">
		<comment>31 to 0 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_DATA_WIDTH">

	<bits access="rw" name="SDMMC_DATA_WIDTH" pos="3:0" rst="0">
		<comment>SD/MMC data width:<br />
		0x1: 1 data line<br />
		0x2: 2 reserved<br />
		0x4: 4 data lines<br />
		0x8: 8 data lines
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_SIZE">

	<bits access="rw" name="SDMMC_BLOCK_SIZE" pos="3:0" rst="0">
		<comment>SD/MMC size of one block:<br />
		0-1:reserved<br />
		2: 1 word<br />
		3: 2 words<br />
		4: 4 words<br />
		5: 8 words<br />
		6: 16 words<br />
 		       <br />
		11: 512 words<br />
		12-15 reserved
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_CNT">

	<bits access="rw" name="SDMMC_BLOCK_CNT" pos="15:0" rst="0">
		<comment>Block number that wants to transfer.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_INT_STATUS">

	<bits access="r" name="NO_RSP_INT" pos="0" rst="0">
		<comment>'1' means no response.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_INT" pos="1" rst="0">
		<comment>'1' means CRC error of response.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_INT" pos="2" rst="0">
		<comment>'1' means CRC error of reading data.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_INT" pos="3" rst="0">
		<comment>'1' means CRC error of writing data.
		</comment>
	</bits>

	<bits access="r" name="DAT_OVER_INT" pos="4" rst="0">
		<comment>'1' means data transmission is over.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_INT" pos="5" rst="0">
		<comment>'1' means tx dma done.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_INT" pos="6" rst="0">
		<comment>'1' means rx dma done.
		</comment>
	</bits>
	
	<bits access="r" name="DAT1_IN_INT" pos="7" rst="0">
		<comment>'1' means DAT1_IN is low when not DL_busy.
		</comment>
	</bits>

	<bits access="r" name="DAT0_IN_INT" pos="8" rst="0">
		<comment>'1' means DAT0_IN is low when not DL_busy.
		</comment>
	</bits>

	<bits access="r" name="NO_RSP_SC" pos="9" rst="0">
		<comment>'1' means no response is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_SC" pos="10" rst="0">
		<comment>'1' means CRC error of response is the source of interrupt.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_SC" pos="11" rst="0">
		<comment>'1' means CRC error of reading data is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_SC" pos="12" rst="0">
		<comment>'1' means CRC error of writing data is the source of interrupt.
		</comment>
	</bits>
	 
	<bits access="r" name="DAT_OVER_SC" pos="13" rst="0">
		<comment>'1' means the end of data transmission is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_SC" pos="14" rst="0">
		<comment>'1' means tx dma done is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_SC" pos="15" rst="0">
		<comment>'1' means rx dma done is the source of interrupt.
		</comment>
	</bits>    
	
	<bits access="r" name="DAT1_IN_SC" pos="16" rst="0">
		<comment>'1' means DAT1_IN is the source of interrupt.
		</comment>
	</bits>    
	
	<bits access="r" name="DAT0_IN_SC" pos="17" rst="0">
		<comment>'1' means DAT0_IN is the source of interrupt.
		</comment>
	</bits>    
	
</reg>



<reg protect="rw" name="SDMMC_INT_MASK">

	<bits access="rw" name="NO_RSP_MK" pos="0" rst="0">
		<comment>When no response, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="RSP_ERR_MK" pos="1" rst="0">
		<comment>When CRC error of response, '1' means INT is disable.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_ERR_MK" pos="2" rst="0">
		<comment>When CRC error of reading data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="WR_ERR_MK" pos="3" rst="0">
		<comment>When CRC error of writing data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="DAT_OVER_MK" pos="4" rst="0">
		<comment>When data transmission is over, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="TXDMA_DONE_MK" pos="5" rst="0">
		<comment>when tx dma done, '1' means INT is disabled.
		</comment>
	</bits>

	<bits access="rw" name="RXDMA_DONE_MK" pos="6" rst="0">
		<comment>'1' means rx dma done, '1' means INT is disabled.
		</comment>
	</bits>    

	<bits access="rw" name="DAT1_IN_MK" pos="7" rst="0">
		<comment>'1' means DAT1 is low when not DL_busy, '1' means INT is disabled.
		</comment>
	</bits>    

	<bits access="rw" name="DAT0_IN_MK" pos="8" rst="0">
		<comment>'1' means DAT0 is low when not DL_busy, '1' means INT is disabled.
		</comment>
	</bits>    
</reg>


<reg protect="w" name="SDMMC_INT_CLEAR">

	<bits access="w" name="NO_RSP_CL" pos="0" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in NO_RSP_SC.
		</comment>
	</bits>

	<bits access="w" name="RSP_ERR_CL" pos="1" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RSP_ERR_SC.
		</comment>
	</bits>
	
	<bits access="w" name="RD_ERR_CL" pos="2" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RD_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="WR_ERR_CL" pos="3" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in WR_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="DAT_OVER_CL" pos="4" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in DAT_OVER_SC.
		</comment>
	</bits>

 	<bits access="w" name="TXDMA_DONE_CL" pos="5" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in TXDMA_DONE_SC.
		</comment>
	</bits>

	<bits access="w" name="RXDMA_DONE_CL" pos="6" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RXDMA_DONE_SC.
		</comment>
	</bits>   
</reg>

<reg protect="rw" name="SDMMC_TRANS_SPEED">

	<bits access="rw" name="SDMMC_TRANS_SPEED" pos="7:0" rst="0">
		<comment>Mclk = Pclk/(2*(SDMMC_TRANS_SPEED +1)).
		</comment>
	</bits>
</reg>

<reg protect="rw" name="SDMMC_MCLK_ADJUST">

	<bits access="rw" name="SDMMC_MCLK_ADJUST" pos="3:0" rst="0">
		<comment>This register may delay the mclk output. 
			 When MCLK_ADJUSTER = n, Mclk is outputted with  n Pclk.	
		</comment>
	</bits>

	<bits access="rw" name="CLK_INV" pos="4" rst="0">
		<comment>Invert Mclk.	
		</comment>
	</bits>

</reg>

</module>
</archive>
<archive relative = "sdmmc.xml">

<module name="sdmmc" category="Periph">


    <reg name="apbi_ctrl_sdmmc" protect="rw">
       <bits name="L_Endian"  pos="2:0" access="rw" rst="000">
          <comment>Controls the big endian or little endian of the FIFO data.
              <br/>Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
              <br/>"000": the order is not changed.
                <br/>Byte3="0A",Byte2="0B",Byte1="0C",Byte0="0D".
              <br/>"001": reversed on byte.
                <br/>Byte3="0D",Byte2="0C,Byte1="0B",Byte0="0A".
              <br/>"010": reversed on half word.
                <br/>Byte3="0C",Byte2="0D,Byte1="0A",Byte0="0B".
              <br/>"010": reversed on bit.
                <br/>Byte3="B0",Byte2="30,Byte1="D0",Byte0="50".
              <br/>"100": reversed on bit.
                <br/>Byte3="0A",Byte2="0X,Byte1="0D",Byte0="0C".
          </comment>
       </bits> 
       <bits name="Soft_rst_L" pos="3" access="rw" rst="1">
          <comment>For the software to clear FIFO in case there is an error in communication with SD controller and some data are left behind.
              <br/>Active Low.
          </comment>
       </bits>
     </reg>

     <hole size="32"/>

     <reg name="APBI_FIFO_TxRx"  protect="--">   
         <bits name="DATA_IN" pos="31:0" access="w" rst="0">
           <comment>Write to the transmit FIFO
           </comment>
         </bits>
         <bits name="DATA_OUT" pos="31:0" access="r" rst="0">
           <comment>Read in the receive FIFO
           </comment>
         </bits>
     </reg>



<hole size="16288"/>

<reg protect="rw" name="SDMMC_CONFIG">

	<bits access="rw" name="SDMMC_SENDCMD" pos="0" rst="0">
		<comment>SD/MMC operation begin register, active high.<br /> 
		When '1', the controller finishes the last command and goes into suspend status. At suspend status, the controller will not execute the next command until the bit is set '0'.
		</comment>
	</bits>
	
	<bits access="rw" name="SDMMC_SUSPEND" pos="1" rst="1">
		<comment>SD/MMC operation suspend register, active high.
		</comment>
	</bits>
	
	<bits access="rw" name="RSP_EN" pos="4" rst="0">
		<comment>'1'indicates having a response,'0'indicates no response.
		</comment>
	</bits>
	
    <bits access="rw" name="RSP_SEL" pos="6:5" rst="0">
        <options>
            <default/>
            <option name="R2" value="0b10"/>
            <option name="R3" value="0b01"/>
            <option name="OTHER" value="0b00"/>
        </options>
		<comment>Response select register,"10" means R2 response, "01" means R3 response, "00" means others response, "11" is reserved.
		</comment> 
	</bits>
	
    <bits access="rw" name="RD_WT_EN" pos="8" rst="0">
		<comment>'1' indicates data operation, which includes read and write.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_WT_SEL" pos="9" rst="0">
        <options>
            <default/>
            <option name="READ" value="0"/>
            <option name="WRITE" value="1"/>
        </options>
		<comment>'1' means write operation,'0' means read operation.
		</comment>
	</bits>
	
	<bits access="rw" name="S_M_SEL" pos="10" rst="0">
        <options>
            <default/>
            <option name="SIMPLE"   value="0"/>
            <option name="MULTIPLE" value="1"/>
        </options>
		<comment>'1'means multiple block data operation.
		</comment>
	</bits>
	<bits access="rw" name="AUTO_FLAG_EN" pos="16" rst="1">
	</bits>
	
</reg>
	
<reg protect="r" name="SDMMC_STATUS">

	<bits access="r" name="Not_SDMMC_OVER" pos="0" rst="0">
		<comment>'1' means the SD/MMC operation is not over.
		</comment>
	</bits>
		
	<bits access="r" name="BUSY" pos="1" rst="0">
		<comment>'1' means SD/MMC is busy.
		</comment>
	</bits>	

	<bits access="r" name="DL_BUSY" pos="2" rst="0">
		<comment>'1' means the data line is busy.
		</comment>
	</bits>
	
	<bits access="r" name="SUSPEND" pos="3" rst="1">
		<comment>'1' means the controller will not perform the new command when SDMMC_SENDCMD= '1'.
		</comment>
	</bits>

	
	
		

	<bits access="r" name="RSP_ERROR" pos="8" rst="0">
		<comment>Response CRC checks error register '1' means response CRC check error.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_ERROR" pos="9" rst="0">
		<comment>'1' means the card has no response to command. 
		</comment>
	</bits>
	
	<bits access="r" name="CRC_STATUS" pos="14:12" rst="0">
		<comment>CRC check for SD/MMC write operation <br /> 
		"101" transmission error<br />
		"010" transmission right<br />
		"111" flash programming error
		</comment>
	</bits>
	
	<bits access="r" name="DATA_ERROR" pos="23:16" rst="0">
		<comment>8 bits data CRC check, "00000000" means no data error, "00000001" means DATA0 CRC check error, "10000000" means DATA7 CRC check error, each bit match one data line.
		</comment>
	</bits>

	<bits access="r" name="DAT3_VAL" pos="24" rst="-">
		<comment>SDMMC DATA 3 value.
		</comment>
	</bits>
	
</reg>

<reg protect="rw" name="SDMMC_CMD_INDEX">

	<bits access="rw" name="COMMAND" pos="5:0" rst="0">
		<comment>SD/MMC command register.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_CMD_ARG">

	<bits access="rw" name="ARGUMENT" pos="31:0" rst="0">
		<comment>SD/MMC command argument register, write data to the SD/MMC card.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_INDEX">

	<bits access="r" name="RESPONSE" pos="5:0" rst="0">
		<comment>SD/MMC response index register.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG3">

	<bits access="r" name="ARGUMENT3" pos="31:0" rst="0">
		<comment>Response argument of R1, R3 and R6, or 127 to 96 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG2">

	<bits access="r" name="ARGUMENT2" pos="31:0" rst="0">
		<comment>95 to 64 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG1">

	<bits access="r" name="ARGUMENT1" pos="31:0" rst="0">
		<comment>63 to 32 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG0">

	<bits access="r" name="ARGUMENT0" pos="31:0" rst="0">
		<comment>31 to 0 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_DATA_WIDTH">

	<bits access="rw" name="SDMMC_DATA_WIDTH" pos="3:0" rst="0">
		<comment>SD/MMC data width:<br />
		0x1: 1 data line<br />
		0x2: 2 reserved<br />
		0x4: 4 data lines<br />
		0x8: 8 data lines
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_SIZE">

	<bits access="rw" name="SDMMC_BLOCK_SIZE" pos="3:0" rst="0">
		<comment>SD/MMC size of one block:<br />
		0-1:reserved<br />
		2: 1 word<br />
		3: 2 words<br />
		4: 4 words<br />
		5: 8 words<br />
		6: 16 words<br />
 		       <br />
		11: 512 words<br />
		12-15 reserved
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_CNT">

	<bits access="rw" name="SDMMC_BLOCK_CNT" pos="15:0" rst="0">
		<comment>Block number that wants to transfer.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_INT_STATUS">

	<bits access="r" name="NO_RSP_INT" pos="0" rst="0">
		<comment>'1' means no response.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_INT" pos="1" rst="0">
		<comment>'1' means CRC error of response.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_INT" pos="2" rst="0">
		<comment>'1' means CRC error of reading data.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_INT" pos="3" rst="0">
		<comment>'1' means CRC error of writing data.
		</comment>
	</bits>

	<bits access="r" name="DAT_OVER_INT" pos="4" rst="0">
		<comment>'1' means data transmission is over.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_INT" pos="5" rst="0">
		<comment>'1' means tx dma done.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_INT" pos="6" rst="0">
		<comment>'1' means rx dma done.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_SC" pos="8" rst="0">
		<comment>'1' means no response is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_SC" pos="9" rst="0">
		<comment>'1' means CRC error of response is the source of interrupt.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_SC" pos="10" rst="0">
		<comment>'1' means CRC error of reading data is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_SC" pos="11" rst="0">
		<comment>'1' means CRC error of writing data is the source of interrupt.
		</comment>
	</bits>
	 
	<bits access="r" name="DAT_OVER_SC" pos="12" rst="0">
		<comment>'1' means the end of data transmission is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_SC" pos="13" rst="0">
		<comment>'1' means tx dma done is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_SC" pos="14" rst="0">
		<comment>'1' means rx dma done is the source of interrupt.
		</comment>
	</bits>    
	
</reg>



<reg protect="rw" name="SDMMC_INT_MASK">

	<bits access="rw" name="NO_RSP_MK" pos="0" rst="0">
		<comment>When no response, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="RSP_ERR_MK" pos="1" rst="0">
		<comment>When CRC error of response, '1' means INT is disable.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_ERR_MK" pos="2" rst="0">
		<comment>When CRC error of reading data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="WR_ERR_MK" pos="3" rst="0">
		<comment>When CRC error of writing data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="DAT_OVER_MK" pos="4" rst="0">
		<comment>When data transmission is over, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="TXDMA_DONE_MK" pos="5" rst="0">
		<comment>when tx dma done, '1' means INT is disabled.
		</comment>
	</bits>

	<bits access="rw" name="RXDMA_DONE_MK" pos="6" rst="0">
		<comment>'1' means rx dma done, '1' means INT is disabled.
		</comment>
	</bits>    
</reg>


<reg protect="w" name="SDMMC_INT_CLEAR">

	<bits access="w" name="NO_RSP_CL" pos="0" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in NO_RSP_SC.
		</comment>
	</bits>

	<bits access="w" name="RSP_ERR_CL" pos="1" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RSP_ERR_SC.
		</comment>
	</bits>
	
	<bits access="w" name="RD_ERR_CL" pos="2" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RD_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="WR_ERR_CL" pos="3" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in WR_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="DAT_OVER_CL" pos="4" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in DAT_OVER_SC.
		</comment>
	</bits>

 	<bits access="w" name="TXDMA_DONE_CL" pos="5" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in TXDMA_DONE_SC.
		</comment>
	</bits>

	<bits access="w" name="RXDMA_DONE_CL" pos="6" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RXDMA_DONE_SC.
		</comment>
	</bits>   
</reg>

<reg protect="rw" name="SDMMC_TRANS_SPEED">

	<bits access="rw" name="SDMMC_TRANS_SPEED" pos="7:0" rst="0">
		<comment>Mclk = Pclk/(2*(SDMMC_TRANS_SPEED +1)).
		</comment>
	</bits>
</reg>

<reg protect="rw" name="SDMMC_MCLK_ADJUST">

	<bits access="rw" name="SDMMC_MCLK_ADJUST" pos="3:0" rst="0">
		<comment>This register may delay the mclk output. 
			 When MCLK_ADJUSTER = n, Mclk is outputted with  n Pclk.	
		</comment>
	</bits>

	<bits access="rw" name="CLK_INV" pos="4" rst="0">
		<comment>Invert Mclk.	
		</comment>
	</bits>

</reg>

</module>
</archive>
<archive relative = "seg_lcd.xml">

<module name="seg_lcd" category="Periph">

    <reg name="code_num_reg" protect="rw">
        <bits name="code_num"   pos="4:0"   access="rw" rst="5'h7">
            <comment> configure  the range (1-18) of code number  registers
            </comment>
        </bits>
    </reg>

    <reg name="refresh_cycle_reg" protect="rw"  >
        <bits name="refresh_cycle"   pos="31:0" access="rw" rst="32'hffff">
            <comment>configure the refreshed cycle in pclk domain when change output data from another code number register.
            </comment>
        </bits>
    </reg>

    <reg name="ctrl" protect="rw">
        <bits name="start"    pos="0"     access="rw" rst="0">
            <comment>this is a pulse signal
            </comment>
        </bits>
        <bits name="stop"    pos="1"     access="rw" rst="0">
            <comment>this is a pulse signal
            </comment>
        </bits>
        <bits name="load_en"   pos="2"     access="rw" rst="0">
            <comment>hardware enable and software clear.
            </comment>
        </bits>
    </reg>

    <reg name="code0_reg" protect="rw"  >
        <bits name="code0" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 0 output.
            </comment>
        </bits>
    </reg>

    <reg name="code1_reg" protect="rw"  >
        <bits name="code1" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 1 output.
            </comment>
        </bits>
    </reg>

    <reg name="code2_reg" protect="rw"  >
        <bits name="code2" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 2 output.
            </comment>
        </bits>
    </reg>

    <reg name="code3_reg" protect="rw"  >
        <bits name="code3" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 3 output.
            </comment>
        </bits>
    </reg>

    <reg name="code4_reg" protect="rw"  >
        <bits name="code4" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 4 output.
            </comment>
        </bits>
    </reg>

    <reg name="code5_reg" protect="rw"  >
        <bits name="code5" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 5 output.
            </comment>
        </bits>
    </reg>

    <reg name="code6_reg" protect="rw"  >
        <bits name="code6" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 6 output.
            </comment>
        </bits>
    </reg>

    <reg name="code7_reg" protect="rw"  >
        <bits name="code7" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 7 output.
            </comment>
        </bits>
    </reg>

    <reg name="code8_reg" protect="rw"  >
        <bits name="code8" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 8 output.
            </comment>
        </bits>
    </reg>

    <reg name="code9_reg" protect="rw"  >
        <bits name="code9" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 9 output.
            </comment>
        </bits>
    </reg>

    <reg name="code10_reg" protect="rw"  >
        <bits name="code10" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 10 output.
            </comment>
        </bits>
    </reg>

    <reg name="code11_reg" protect="rw"  >
        <bits name="code11" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 11 output.
            </comment>
        </bits>
    </reg>

    <reg name="code12_reg" protect="rw"  >
        <bits name="code12" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 12 output.
            </comment>
        </bits>
    </reg>

    <reg name="code13_reg" protect="rw"  >
        <bits name="code13" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 13 output.
            </comment>
        </bits>
    </reg>

    <reg name="code14_reg" protect="rw"  >
        <bits name="code14" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 14 output.
            </comment>
        </bits>
    </reg>

    <reg name="code15_reg" protect="rw"  >
        <bits name="code15" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 15 output.
            </comment>
        </bits>
    </reg>

    <reg name="code16_reg" protect="rw"  >
        <bits name="code16" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 16 output.
            </comment>
        </bits>
    </reg>

    <reg name="code17_reg" protect="rw"  >
        <bits name="code17" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 17 output.
            </comment>
        </bits>
    </reg>


    <reg name="pin_oen0_reg" protect="rw" > 
        <bits name="pin_oen0" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 0 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen1_reg" protect="rw"  >
        <bits name="pin_oen1" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 1 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen2_reg" protect="rw"  >
        <bits name="pin_oen2" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 2 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen3_reg" protect="rw"  >
        <bits name="pin_oen3" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 3 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen4_reg" protect="rw"  >
        <bits name="pin_oen4" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 4 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen5_reg" protect="rw"  >
        <bits name="pin_oen5" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 5 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen6_reg" protect="rw"  >
        <bits name="pin_oen6" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 6 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen7_reg" protect="rw"  >
        <bits name="pin_oen7" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 7 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen8_reg" protect="rw"  >
        <bits name="pin_oen8" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 8 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen9_reg" protect="rw"  >
        <bits name="pin_oen9" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 9 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen10_reg" protect="rw"  >
        <bits name="pin_oen10" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 10 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen11_reg" protect="rw"  >
        <bits name="pin_oen11" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 11 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen12_reg" protect="rw"  >
        <bits name="pin_oen12" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 12 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen13_reg" protect="rw"  >
        <bits name="pin_oen13" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 13 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen14_reg" protect="rw"  >
        <bits name="pin_oen14" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 14 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen15_reg" protect="rw"  >
        <bits name="pin_oen15" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 15 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen16_reg" protect="rw"  >
        <bits name="pin_oen16" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 16 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen17_reg" protect="rw"  >
        <bits name="pin_oen17" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 17 of pin_oen.
            </comment>
        </bits>
    </reg>


</module>
</archive>
<archive relative="slv_fw_bbifc_ahb_rf.xml">
  <module name="slv_fw_bbifc_ahb_rf" category="firewall">
    <reg protect="rw" name="port0_default_address_0">
      <bits access="r" name="port0_default_address_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="port0_default_address_0" pos="27:0" rst="26472448">
      </bits>
    </reg>
    <reg protect="rw" name="port_int_en">
      <bits access="r" name="port_int_en_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

          0: don't response error; 1: response error
        </comment>
      </bits>
      <bits access="r" name="port_int_en_reserved_1" pos="3:2" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="1" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 read channel address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 write channel address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_clr">
      <bits access="r" name="port_int_clr_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="1" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 read channel address miss int write-clear
        </comment>
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 write channel address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_raw">
      <bits access="r" name="port_int_raw_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="1" rst="0">
        <comment>
          Port 0 read channel address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
        <comment>
          Port 0 write channel address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_fin">
      <bits access="r" name="port_int_fin_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="1" rst="0">
        <comment>
          Port 0 read channel address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
        <comment>
          Port 0 write channel address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rd_sec_0">
      <bits access="r" name="rd_sec_0_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="bb_ctrl_rd_sec" pos="5:4" rst="3">
        <comment>
          control bb_ctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="nbiot_ctrl_rd_sec" pos="3:2" rst="3">
        <comment>
          control nbiot_ctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="cipher_f8_rd_sec" pos="1:0" rst="3">
        <comment>
          control cipher_f8_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wr_sec_0">
      <bits access="r" name="wr_sec_0_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="bb_ctrl_wr_sec" pos="5:4" rst="3">
        <comment>
          control bb_ctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="nbiot_ctrl_wr_sec" pos="3:2" rst="3">
        <comment>
          control nbiot_ctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="cipher_f8_wr_sec" pos="1:0" rst="3">
        <comment>
          control cipher_f8_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_first_addr_0">
      <bits access="r" name="id0_first_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="27:0" rst="268435455">
      </bits>
    </reg>
    <reg protect="rw" name="id0_last_addr_0">
      <bits access="r" name="id0_last_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="27:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_first_addr_0">
      <bits access="r" name="id1_first_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="27:0" rst="268435455">
      </bits>
    </reg>
    <reg protect="rw" name="id1_last_addr_0">
      <bits access="r" name="id1_last_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="27:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          clk_gate_bypass
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="slv_fw_bbifc_apb_rf.xml">
  <module name="slv_fw_bbifc_apb_rf" category="firewall">
    <reg protect="rw" name="port0_default_address_0">
      <bits access="r" name="port0_default_address_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="port0_default_address_0" pos="15:0" rst="61440">
      </bits>
    </reg>
    <reg protect="rw" name="port_int_en">
      <bits access="r" name="port_int_en_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

          0: don&apos;t response error; 1: response error
        </comment>
      </bits>
      <bits access="r" name="port_int_en_reserved_1" pos="3:2" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="1" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 read channel address miss int enable&#10;1: Enable&#10;0: Disable
        </comment>
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 write channel address miss int enable&#10;1: Enable&#10;0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_clr">
      <bits access="r" name="port_int_clr_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="1" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 read channel address miss int write-clear
        </comment>
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 write channel address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_raw">
      <bits access="r" name="port_int_raw_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="1" rst="0">
        <comment>
          Port 0 read channel address miss original int&#10;1: Address Miss&#10;0: Normal
        </comment>
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
        <comment>
          Port 0 write channel address miss original int&#10;1: Address Miss&#10;0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_fin">
      <bits access="r" name="port_int_fin_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="1" rst="0">
        <comment>
          Port 0 read channel address miss final int&#10;1: Address Miss&#10;0: Normal
        </comment>
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
        <comment>
          Port 0 write channel address miss final int&#10;1: Address Miss&#10;0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rd_sec_0">
      <bits access="r" name="rd_sec_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="sci1_rd_sec" pos="15:14" rst="3">
        <comment>
          control sci1_rd_sec rd security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="nb_rf_spi_rd_sec" pos="13:12" rst="3">
        <comment>
          control nb_rf_spi_rd_sec rd security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="nb_tcu_rd_sec" pos="11:10" rst="3">
        <comment>
          control nb_tcu_rd_sec rd security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="rf_if_rd_sec" pos="9:8" rst="3">
        <comment>
          control rf_if_rd_sec rd security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="rf_interface_rd_sec" pos="7:6" rst="3">
        <comment>
          control rf_interface_rd_sec rd security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="dfe_rd_sec" pos="5:4" rst="3">
        <comment>
          control dfe_rd_sec rd security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="rffe_rd_sec" pos="3:2" rst="3">
        <comment>
          control rffe_rd_sec rd security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="bb_ifc_rd_sec" pos="1:0" rst="3">
        <comment>
          control bb_ifc_rd_sec rd security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wr_sec_0">
      <bits access="r" name="wr_sec_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="sci1_wr_sec" pos="15:14" rst="3">
        <comment>
          control sci1_wr_sec wr security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="nb_rf_spi_wr_sec" pos="13:12" rst="3">
        <comment>
          control nb_rf_spi_wr_sec wr security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="nb_tcu_wr_sec" pos="11:10" rst="3">
        <comment>
          control nb_tcu_wr_sec wr security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="rf_if_wr_sec" pos="9:8" rst="3">
        <comment>
          control rf_if_wr_sec wr security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="rf_interface_wr_sec" pos="7:6" rst="3">
        <comment>
          control rf_interface_wr_sec wr security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="dfe_wr_sec" pos="5:4" rst="3">
        <comment>
          control dfe_wr_sec wr security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="rffe_wr_sec" pos="3:2" rst="3">
        <comment>
          control rffe_wr_sec wr security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
      <bits access="rw" name="bb_ifc_wr_sec" pos="1:0" rst="3">
        <comment>
          control bb_ifc_wr_sec wr security attribute:&#10;2&apos;b00: security/non-security can&apos;t access&#10;2&apos;b01: security access only&#10;2&apos;b10: non-security access ony&#10;2&apos;b11: security/non-security access&#10;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_first_addr_0">
      <bits access="r" name="id0_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id0_last_addr_0">
      <bits access="r" name="id0_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_first_addr_0">
      <bits access="r" name="id1_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id1_last_addr_0">
      <bits access="r" name="id1_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_first_addr_0">
      <bits access="r" name="id2_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id2_last_addr_0">
      <bits access="r" name="id2_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_first_addr_0">
      <bits access="r" name="id3_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id3_last_addr_0">
      <bits access="r" name="id3_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          clk_gate_bypass
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="slv_fw_sysifc1_apb_rf.xml">
  <module name="slv_fw_sysifc1_apb_rf" category="firewall">
    <reg protect="rw" name="port0_default_address_0">
      <bits access="r" name="port0_default_address_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="port0_default_address_0" pos="15:0" rst="61440">
      </bits>
    </reg>
    <reg protect="rw" name="port_int_en">
      <bits access="r" name="port_int_en_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

          0: don't response error; 1: response error
        </comment>
      </bits>
      <bits access="r" name="port_int_en_reserved_1" pos="3:2" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="1" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 read channel address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 write channel address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_clr">
      <bits access="r" name="port_int_clr_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="1" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 read channel address miss int write-clear
        </comment>
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 write channel address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_raw">
      <bits access="r" name="port_int_raw_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="1" rst="0">
        <comment>
          Port 0 read channel address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
        <comment>
          Port 0 write channel address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_fin">
      <bits access="r" name="port_int_fin_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="1" rst="0">
        <comment>
          Port 0 read channel address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
        <comment>
          Port 0 write channel address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rd_sec_0">
      <bits access="r" name="rd_sec_0_reserved_0" pos="31:22" rst="0">
      </bits>
      <bits access="rw" name="uart1_rd_sec" pos="21:20" rst="3">
        <comment>
          control uart1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="uart2_rd_sec" pos="19:18" rst="3">
        <comment>
          control uart2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="gpio1_rd_sec" pos="17:16" rst="3">
        <comment>
          control gpio1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="gpt1_rd_sec" pos="15:14" rst="3">
        <comment>
          control gpt1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="pwr_ctrl_rd_sec" pos="13:12" rst="3">
        <comment>
          control pwr_ctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="nb_lps_rd_sec" pos="11:10" rst="3">
        <comment>
          control nb_lps_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="timer1_rd_sec" pos="9:8" rst="3">
        <comment>
          control timer1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="iomux1_rd_sec" pos="7:6" rst="3">
        <comment>
          control iomux1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="iomux2_rd_sec" pos="5:4" rst="3">
        <comment>
          control iomux2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sys_wdt_rd_sec" pos="3:2" rst="3">
        <comment>
          control sys_wdt_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sys_ifc1_rd_sec" pos="1:0" rst="3">
        <comment>
          control sys_ifc1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wr_sec_0">
      <bits access="r" name="wr_sec_0_reserved_0" pos="31:22" rst="0">
      </bits>
      <bits access="rw" name="uart1_wr_sec" pos="21:20" rst="3">
        <comment>
          control uart1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="uart2_wr_sec" pos="19:18" rst="3">
        <comment>
          control uart2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="gpio1_wr_sec" pos="17:16" rst="3">
        <comment>
          control gpio1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="gpt1_wr_sec" pos="15:14" rst="3">
        <comment>
          control gpt1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="pwr_ctrl_wr_sec" pos="13:12" rst="3">
        <comment>
          control pwr_ctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="nb_lps_wr_sec" pos="11:10" rst="3">
        <comment>
          control nb_lps_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="timer1_wr_sec" pos="9:8" rst="3">
        <comment>
          control timer1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="iomux1_wr_sec" pos="7:6" rst="3">
        <comment>
          control iomux1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="iomux2_wr_sec" pos="5:4" rst="3">
        <comment>
          control iomux2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sys_wdt_wr_sec" pos="3:2" rst="3">
        <comment>
          control sys_wdt_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sys_ifc1_wr_sec" pos="1:0" rst="3">
        <comment>
          control sys_ifc1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_first_addr_0">
      <bits access="r" name="id0_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id0_last_addr_0">
      <bits access="r" name="id0_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_first_addr_0">
      <bits access="r" name="id1_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id1_last_addr_0">
      <bits access="r" name="id1_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_first_addr_0">
      <bits access="r" name="id2_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id2_last_addr_0">
      <bits access="r" name="id2_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_first_addr_0">
      <bits access="r" name="id3_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id3_last_addr_0">
      <bits access="r" name="id3_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          clk_gate_bypass
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="slv_fw_sysifc2_ahb_rf.xml">
  <module name="slv_fw_sysifc2_ahb_rf" category="firewall">
    <reg protect="rw" name="port0_default_address_0">
      <bits access="r" name="port0_default_address_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="port0_default_address_0" pos="27:0" rst="27512832">
        <comment>
          port0 default address, bit 0 ~ 27.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_en">
      <bits access="r" name="port_int_en_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

          0: don't response error; 1: response error
        </comment>
      </bits>
      <bits access="r" name="port_int_en_reserved_1" pos="3:2" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="1" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 read channel address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 write channel address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_clr">
      <bits access="r" name="port_int_clr_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="1" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 read channel address miss int write-clear
        </comment>
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 write channel address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_raw">
      <bits access="r" name="port_int_raw_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="1" rst="0">
        <comment>
          Port 0 read channel address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
        <comment>
          Port 0 write channel address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_fin">
      <bits access="r" name="port_int_fin_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="1" rst="0">
        <comment>
          Port 0 read channel address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
        <comment>
          Port 0 write channel address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rd_sec_0">
      <bits access="r" name="reserved_3" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="28" rst="0">
      </bits>
      <bits access="rw" name="i2c2_rd_sec" pos="27:26" rst="3">
        <comment>
          control i2c2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="i2c3_rd_sec" pos="25:24" rst="3">
        <comment>
          control i2c3_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="timer2_rd_sec" pos="23:22" rst="3">
        <comment>
          control timer2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sys_dma_rd_sec" pos="21:20" rst="3">
        <comment>
          control sys_dma_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sys_ctrl_rd_sec" pos="19:18" rst="3">
        <comment>
          control sys_ctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="rom_patch_rd_sec" pos="17:16" rst="3">
        <comment>
          control rom_patch_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="psram_ctrl_rd_sec" pos="15:14" rst="3">
        <comment>
          control psram_ctrl_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="med_rd_sec" pos="13:12" rst="3">
        <comment>
          control med_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="ce_sec_rd_sec" pos="11:10" rst="3">
        <comment>
          control ce_sec_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="ce_pub_rd_sec" pos="9:8" rst="3">
        <comment>
          control ce_pub_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="efuse_rd_sec" pos="7:6" rst="3">
        <comment>
          control efuse_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="spi_flash_rd_sec" pos="5:4" rst="3">
        <comment>
          control spi_flash_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="spiflash_ext_rd_sec" pos="3:2" rst="3">
        <comment>
          control spiflash_ext_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="adi_if_rd_sec" pos="1:0" rst="3">
        <comment>
          control adi_if_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rd_sec_1">
      <bits access="r" name="rd_sec_1_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="rw" name="gpio2_rd_sec" pos="9:8" rst="3">
        <comment>
          control gpio2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="gpt2_rd_sec" pos="7:6" rst="3">
        <comment>
          control gpt2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="keypad_rd_sec" pos="5:4" rst="3">
        <comment>
          control keypad_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="seg_lcd_rd_sec" pos="3:2" rst="3">
        <comment>
          control seg_lcd_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="i2c1_rd_sec" pos="1:0" rst="3">
        <comment>
          control i2c1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wr_sec_0">
      <bits access="r" name="reserved_3" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="28" rst="0">
      </bits>
      <bits access="rw" name="i2c2_wr_sec" pos="27:26" rst="3">
        <comment>
          control i2c2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="i2c3_wr_sec" pos="25:24" rst="3">
        <comment>
          control i2c3_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="timer2_wr_sec" pos="23:22" rst="3">
        <comment>
          control timer2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sys_dma_wr_sec" pos="21:20" rst="3">
        <comment>
          control sys_dma_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sys_ctrl_wr_sec" pos="19:18" rst="3">
        <comment>
          control sys_ctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="rom_patch_wr_sec" pos="17:16" rst="3">
        <comment>
          control rom_patch_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="psram_ctrl_wr_sec" pos="15:14" rst="3">
        <comment>
          control psram_ctrl_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="med_wr_sec" pos="13:12" rst="3">
        <comment>
          control med_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="ce_sec_wr_sec" pos="11:10" rst="3">
        <comment>
          control ce_sec_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="ce_pub_wr_sec" pos="9:8" rst="3">
        <comment>
          control ce_pub_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="efuse_wr_sec" pos="7:6" rst="3">
        <comment>
          control efuse_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="spi_flash_wr_sec" pos="5:4" rst="3">
        <comment>
          control spi_flash_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="spiflash_ext_wr_sec" pos="3:2" rst="3">
        <comment>
          control spiflash_ext_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="adi_if_wr_sec" pos="1:0" rst="3">
        <comment>
          control adi_if_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wr_sec_1">
      <bits access="r" name="wr_sec_1_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="rw" name="gpio2_wr_sec" pos="9:8" rst="3">
        <comment>
          control gpio2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="gpt2_wr_sec" pos="7:6" rst="3">
        <comment>
          control gpt2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="keypad_wr_sec" pos="5:4" rst="3">
        <comment>
          control keypad_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="seg_lcd_wr_sec" pos="3:2" rst="3">
        <comment>
          control seg_lcd_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="i2c1_wr_sec" pos="1:0" rst="3">
        <comment>
          control i2c1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_first_addr_0">
      <bits access="r" name="id0_first_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="27:0" rst="268435455">
      </bits>
    </reg>
    <reg protect="rw" name="id0_last_addr_0">
      <bits access="r" name="id0_last_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="27:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_first_addr_0">
      <bits access="r" name="id1_first_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="27:0" rst="268435455">
      </bits>
    </reg>
    <reg protect="rw" name="id1_last_addr_0">
      <bits access="r" name="id1_last_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="27:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_first_addr_0">
      <bits access="r" name="id2_first_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="27:0" rst="268435455">
      </bits>
    </reg>
    <reg protect="rw" name="id2_last_addr_0">
      <bits access="r" name="id2_last_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="27:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_first_addr_0">
      <bits access="r" name="id3_first_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="27:0" rst="268435455">
      </bits>
    </reg>
    <reg protect="rw" name="id3_last_addr_0">
      <bits access="r" name="id3_last_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="27:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id4_first_addr_0">
      <bits access="r" name="id4_first_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="27:0" rst="268435455">
      </bits>
    </reg>
    <reg protect="rw" name="id4_last_addr_0">
      <bits access="r" name="id4_last_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="27:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id4_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id4 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id4_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id4 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id4_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id4 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id4_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id4 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id4_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id4 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id4_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id4 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id4_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id4 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id4_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id4 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id5_first_addr_0">
      <bits access="r" name="id5_first_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="27:0" rst="268435455">
      </bits>
    </reg>
    <reg protect="rw" name="id5_last_addr_0">
      <bits access="r" name="id5_last_addr_0_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="27:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id5_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id5 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id5_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id5 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id5_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id5 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id5_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id5 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id5_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id5 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id5_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id5 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id5_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id5 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id5_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id5 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          clk_gate_bypass
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="slv_fw_sysifc2_apb_rf.xml">
  <module name="slv_fw_sysifc2_apb_rf" category="firewall">
    <reg protect="rw" name="port0_default_address_0">
      <bits access="r" name="port0_default_address_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="port0_default_address_0" pos="15:0" rst="53248">
      </bits>
    </reg>
    <reg protect="rw" name="port_int_en">
      <bits access="r" name="port_int_en_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="fw_resp_en" pos="4" rst="0">
        <comment>
        bit type is changed from wr to rw.

          0: don't response error; 1: response error
        </comment>
      </bits>
      <bits access="r" name="port_int_en_reserved_1" pos="3:2" rst="0">
      </bits>
      <bits access="rw" name="port_0_r_en" pos="1" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 read channel address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
      <bits access="rw" name="port_0_w_en" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          Port 0 write channel address miss int enable
1: Enable
0: Disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="port_int_clr">
      <bits access="r" name="port_int_clr_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="rc" name="port_0_r_clr" pos="1" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 read channel address miss int write-clear
        </comment>
      </bits>
      <bits access="rc" name="port_0_w_clr" pos="0" rst="0">
        <comment>
        bit type is changed from wc to rc.

          Port 0 write channel address miss int write-clear
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_raw">
      <bits access="r" name="port_int_raw_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="port_0_r_raw" pos="1" rst="0">
        <comment>
          Port 0 read channel address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
      <bits access="r" name="port_0_w_raw" pos="0" rst="0">
        <comment>
          Port 0 write channel address miss original int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="port_int_fin">
      <bits access="r" name="port_int_fin_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="port_0_r_fin" pos="1" rst="0">
        <comment>
          Port 0 read channel address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
      <bits access="r" name="port_0_w_fin" pos="0" rst="0">
        <comment>
          Port 0 write channel address miss final int
1: Address Miss
0: Normal
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rd_sec_0">
      <bits access="r" name="rd_sec_0_reserved_0" pos="31:22" rst="0">
      </bits>
      <bits access="rw" name="sci2_rd_sec" pos="21:20" rst="3">
        <comment>
          control sci2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="spi1_rd_sec" pos="19:18" rst="3">
        <comment>
          control spi1_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="spi2_rd_sec" pos="17:16" rst="3">
        <comment>
          control spi2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="debug_uart_rd_sec" pos="15:14" rst="3">
        <comment>
          control debug_uart_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="uart3_rd_sec" pos="13:12" rst="3">
        <comment>
          control uart3_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="uart4_rd_sec" pos="11:10" rst="3">
        <comment>
          control uart4_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="uart5_rd_sec" pos="9:8" rst="3">
        <comment>
          control uart5_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sdmmc2_rd_sec" pos="7:6" rst="3">
        <comment>
          control sdmmc2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="i2s_rd_sec" pos="5:4" rst="3">
        <comment>
          control i2s_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sys_ifc2_rd_sec" pos="3:2" rst="3">
        <comment>
          control sys_ifc2_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="debug_host_rd_sec" pos="1:0" rst="3">
        <comment>
          control debug_host_rd_sec rd security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wr_sec_0">
      <bits access="r" name="wr_sec_0_reserved_0" pos="31:22" rst="0">
      </bits>
      <bits access="rw" name="sci2_wr_sec" pos="21:20" rst="3">
        <comment>
          control sci2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="spi1_wr_sec" pos="19:18" rst="3">
        <comment>
          control spi1_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="spi2_wr_sec" pos="17:16" rst="3">
        <comment>
          control spi2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="debug_uart_wr_sec" pos="15:14" rst="3">
        <comment>
          control debug_uart_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="uart3_wr_sec" pos="13:12" rst="3">
        <comment>
          control uart3_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="uart4_wr_sec" pos="11:10" rst="3">
        <comment>
          control uart4_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="uart5_wr_sec" pos="9:8" rst="3">
        <comment>
          control uart5_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sdmmc2_wr_sec" pos="7:6" rst="3">
        <comment>
          control sdmmc2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="i2s_wr_sec" pos="5:4" rst="3">
        <comment>
          control i2s_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="sys_ifc2_wr_sec" pos="3:2" rst="3">
        <comment>
          control sys_ifc2_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
      <bits access="rw" name="debug_host_wr_sec" pos="1:0" rst="3">
        <comment>
          control debug_host_wr_sec wr security attribute:
2'b00: security/non-security can't access
2'b01: security access only
2'b10: non-security access ony
2'b11: security/non-security access

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_first_addr_0">
      <bits access="r" name="id0_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id0_last_addr_0">
      <bits access="r" name="id0_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id0_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id0 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_first_addr_0">
      <bits access="r" name="id1_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id1_last_addr_0">
      <bits access="r" name="id1_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id1_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id1 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_first_addr_0">
      <bits access="r" name="id2_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id2_last_addr_0">
      <bits access="r" name="id2_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id2_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id2 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_first_addr_0">
      <bits access="r" name="id3_first_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="first_addr_0" pos="15:0" rst="65535">
      </bits>
    </reg>
    <reg protect="rw" name="id3_last_addr_0">
      <bits access="r" name="id3_last_addr_0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="last_addr_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_0">
      <bits access="rw" name="mstid_0" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_0 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_1">
      <bits access="rw" name="mstid_1" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_1 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_2">
      <bits access="rw" name="mstid_2" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_2 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_3">
      <bits access="rw" name="mstid_3" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_3 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_4">
      <bits access="rw" name="mstid_4" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_4 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_5">
      <bits access="rw" name="mstid_5" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_5 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_6">
      <bits access="rw" name="mstid_6" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_6 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="id3_mstid_7">
      <bits access="rw" name="mstid_7" pos="31:0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          id3 mstid_7 master id control
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_gate_bypass">
      <bits access="r" name="clk_gate_bypass_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="rw" name="clk_gate_bypass" pos="0" rst="0">
        <comment>
        bit type is changed from wr to rw.

          clk_gate_bypass
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "spi_flash.xml">
<module name="spi_flash" category="System">

    <reg name="spi_cmd_addr" protect="rw">
		<bits access="rw" name="spi_tx_cmd" pos="7:0" rst="all0">           
			<comment> spi flash command to send. 
			</comment>
		</bits>
		<bits access="rw" name="spi_address" pos="31:8" rst="all0">           
			<comment> spi flash address to send. 
			</comment>
		</bits>
     </reg>
	 <reg name="spi_block_size" protect="rw">
		<bits access="rw" name="spi_modebit" pos="7:0" rst="all0">           
			<comment> spi flash modebit,set 0xA0 to enable continuous read. 
			</comment>
		</bits>
		<bits access="rw" name="spi_rw_blk_size" pos="16:8" rst="0x1">           
			<comment> spi flash spi read/write block size. 
			</comment>
        </bits>
		<bits access="rw" name="continuous enable" pos="24" rst="0x0">           
        </bits>
     </reg>
     <reg name="spi_data_fifo" protect="w">
		<bits access="w" name="spi_tx_data" pos="7:0" rst="all0">           
			<comment> spi flash data to send. 
			</comment>
		</bits>
		<bits access="w" name="spi_send_type" pos="8" rst="0x0">           
			<comment> spi send byte, 1: quad send 0: spi send. 
			</comment>
		</bits>
     </reg>

     <reg name="spi_fifo_status" protect="r">
		<bits access="r" name="spi_flash_busy" pos="0" rst="0x0">           
			<comment> spi flash busy. 
			</comment>
		</bits>
		<bits access="r" name="tx_fifo_empty" pos="1" rst="0x1">           
			<comment> tx fifo empty. 
			</comment>
		</bits>
		<bits access="r" name="tx_fifo_full" pos="2" rst="0x0">           
			<comment> tx fifo full. 
			</comment>
		</bits>
		<bits access="r" name="rx_fifo_empty" pos="3" rst="0x1">           
			<comment> rx fifo empty. 
			</comment>
		</bits>
		<bits access="r" name="rx_fifo_count" pos="8:4" rst="all0">           
			<comment> rx fifo data count. 
			</comment>
		</bits>
		<bits access="r" name="read_state_busy" pos="9" rst="0">           
		</bits>
		<bits access="r" name="main_fsm_idle" pos="10" rst="0">           
		</bits>
     </reg>

     <reg name="spi_read_back" protect="r">
		<bits access="r" name="spi_read_back_reg" pos="31:0" rst="all0">           
			<comment> spi flash read back data. 
			</comment>
		</bits>
     </reg>

     <reg name="spi_config" protect="rw">
		<bits access="rw" name="quad_mode" pos="0" rst="0x0">           
			<comment> spi flash read mode from AHB. 
			</comment>
			<options>
            <option name="spi_read"  value ="0"></option>
            <option name="quad_read" value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="spi_wprotect_pin" pos="1" rst="0x0">           
			<comment> spi flash wprotect pin. 
			</comment>
		</bits>
		<bits access="rw" name="spi_hold_pin" pos="2" rst="0x0">           
			<comment> spi flash hold pin. 
			</comment>
		</bits>
		<bits access="rw" name="winbond_xm_chip" pos="3" rst="0x0">           
			<comment> device is winbond or xm chip. 
			</comment>
		</bits>
		<bits access="rw" name="sample_delay" pos="6:4" rst="0x2">           
			<comment> spi flash read sample delay cycles. 
			</comment>
		</bits>
		<bits access="rw" name="bypass_start_read" pos="7" rst="0x0">           
		</bits>
		<bits access="rw" name="clk_divider" pos="15:8" rst="0x8">           
			<comment> spi flash clock divider. 
			</comment>
		</bits>
		<bits access="rw" name="cmd_quad" pos="16" rst="0x0">           
			<comment> spi flash send command using quad lines. 
			</comment>
        </bits>
		<bits access="rw" name="tx_rx_size" pos="18:17" rst="0x0">           
        </bits>
     </reg>

     <reg name="spi_fifo_control" protect="w">
		<bits access="w" name="rx_fifo_clr" pos="0" rst="0x0">           
			<comment> rx fifo_clr,self clear. 
			</comment>
		</bits>
		<bits access="w" name="tx_fifo_clr" pos="1" rst="0x0">           
			<comment> tx fifo_clr,self clear. 
			</comment>
		</bits>
     </reg>

     <reg name="spi_cs_size" protect="rw">
		<bits access="rw" name="spi_cs_num" pos="0" rst="0x0">           
			<comment> spi flash cs num. 
			</comment>
			<options>
            <option name="1 spiflash"  value ="0"></option>
            <option name="2 spiflash"  value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="spi size" pos="2:1" rst="all0">           
			<comment> single chip spi flash size. 
			</comment>
			<options>
            <option name="32m"  value ="0"></option>
            <option name="64m"  value ="1"></option>
            <option name="16m"  value ="2"></option>
            <option name="8m"   value ="3"></option>
        	</options>
		</bits>
		<bits access="rw" name="spi_128m" pos="3" rst="0x0">           
			<comment> spi flash is 128m flash. 
			</comment>
			<options>
            <option name="other spiflash"  value ="0"></option>
            <option name="128m  spiflash"  value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="SEL_FLASH_1_SEL" pos="5" rst="0x0">           
		<options>
            <option name="flash 0"  value ="0"></option>
            <option name="flash 1" value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="spi_cs1_sel1" pos="6" rst="0x0">           
		</bits>
		<bits access="rw" name="diff_128m_diff_cmd_en" pos="7" rst="0x0">           
		</bits>
    </reg>

    <reg name="spi_read_cmd" protect="rw">
		<bits access="rw" name="qread_cmd" pos="7:0" rst="8'heb">           
			<comment> quad read command. 
			</comment>
		</bits>
		<bits access="rw" name="fread_cmd" pos="15:8" rst="8'h0b">           
			<comment> fast read command. 
			</comment>
		</bits>
		<bits access="rw" name="read_cmd" pos="23:16" rst="8'h03">           
			<comment> read command. 
			</comment>
		</bits>
		<bits access="w" name="protect_byte" pos="31:24" rst="all0">           
			<comment> protect_byte, must be 0x55 when program this register. 
			</comment>
		</bits>
    </reg>
    
    <reg name="spi_flash_24" protect="rw">
		<bits access="rw" name="nand_sel" pos="0" rst="all0">           
		</bits>
		<bits access="rw" name="nand_addr" pos="2:1" rst="all0">           
		</bits>
		<bits access="rw" name="page_read_cmd" pos="15:8" rst="8'h13">           
        </bits>
		<bits access="rw" name="get_sts_cmd" pos="23:16" rst="8'h0f">           
        </bits>
		<bits access="rw" name="ram_read_cmd" pos="31:24" rst="8'h03">           
        </bits>
    </reg>

    <reg name="spi_flash_28" protect="rw">
		<bits access="rw" name="get_sts_addr" pos="7:0" rst="8'hc0">           
		</bits>
		<bits access="rw" name="program_exe_cmd" pos="15:8" rst="8'h10">           
        </bits>
		<bits access="rw" name="sts_qip" pos="23:16" rst="8'h01">           
        </bits>
    </reg>

    <reg name="spi_flash_2c" protect="rw">
		<bits access="rw" name="four_byte_addr" pos="0" rst="all0">           
		</bits>
		<bits access="rw" name="dummy_cycle_en" pos="1" rst="all0">           
		</bits>
		<bits access="rw" name="dummy_cycle" pos="11:8" rst="8'h08">           
        </bits>
    </reg>

    <reg name="spi_flash_30" protect="rw">
		<bits access="rw" name="first_128m_cmd" pos="7:0" rst="0x8c">           
		</bits>
		<bits access="rw" name="second_128m_cmd" pos="15:8" rst="0x8d">           
        </bits>
		<bits access="rw" name="third_128m_cmd" pos="23:16" rst="8'h0">           
        </bits>
		<bits access="rw" name="fourth_128m_cmd" pos="31:24" rst="8'h0">           
        </bits>
    </reg>
     
    <reg name="timeout_value" protect="rw">
		<bits access="rw" name="timeout_value" pos="31:0" rst="32'h4000">           
		</bits>
    </reg>

    <reg name="ahb_flash_ctrl" protect="rw">
        <bits access="rw" name="ahb_read" pos="0" rst="0x0">           
			<comment> disable read from ahb. 
			</comment>
			<options>
            <option name="enable"  value ="0"></option>
            <option name="disable" value ="1"></option>
        	</options>
        </bits>
    </reg>

    <reg name="sus_time_ctrl" protect="rw">
        <bits access="rw" name="tsus_value" pos="15:0" rst="1000">
        </bits>
        <bits access="rw" name="tres_value" pos="31:16" rst="10">
        </bits>
    </reg>

    <reg name="flash_irq" protect="rw">
        <bits access="rc" name="pr_er_done_cause" pos="0" rst="0">
        </bits>
        <bits access="rc" name="pr_er_done_status" pos="16" rst="0">
        </bits>
    </reg>

    <reg name="flash_irq_mask" protect="rw">
        <bits access="rw" name="pr_er_done_mask" pos="0" rst="0">
        </bits>
    </reg>

     
</module>


</archive>
<archive relative = "spi.xml">
<var name = "SPI_TX_FIFO_SIZE" value="16"/>
<var name = "SPI_RX_FIFO_SIZE" value="16"/>

<module name="spi" category="Periph">
    <reg name="ctrl" protect="rw">
        <bits name="Enable"  pos="0" access="rw" rst="0">
            <comment>Enable the module and activate the chip select selected by CS_sel field.
            </comment>
        </bits>
        <bits name="CS_sel" pos="2:1" access="rw" rst="0">
            <comment>Selects the active CS.
            </comment>
            <options>
                <option name="CS0" value="0"/>
                <option name="CS1" value="1"/>
                <option name="CS2" value="2"/>
                <option name="CS3" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="Input_mode" pos="4" access="rw"  rst="1">
            <comment>When set to 1 the inputs are activated, else only the output is driven and no data are stored in the receive FIFO.
                <br/>Notes: The Input_mode bit status is also readable onto the bit rxtx_buffer[31].
            </comment>
        </bits>
        <bits name="Clock_Polarity" pos="5" access="rw" rst="1">
            <comment>The spi clock polarity
                <br/>when '0' the clock disabled level is low, and the first edge is a rising edge.
                <br/>When '1' the clock disabled level is high, and the first edge is a falling edge.
            </comment>
        </bits>
        <bits name="Clock_Delay" pos="7:6" access="rw" rst="3">
            <comment>Transfer start to first edge delay value from 0 to 2 is the number of spi clock half period between the CS activation and the first clock edge.
            </comment>
        </bits>
        <bits name="DO_Delay" pos="9:8" access="rw" rst="3">
            <comment>Transfer start to first data out delay value from 0 to 2 is the number of spi clock half period between the CS activation and the first data out
            </comment>
        </bits>
        <bits name="DI_Delay" pos="11:10" access="rw" rst="3">
            <comment>Transfer start to first data in sample delay value from 0 to 3 is the number of spi clock half period between the CS activation and the first data in sampled.
                <br/>NOTE: DI_Delay must be less or equal to DO_Delay + CS_Delay + 2.
                <br/>In other words DI_Delay can be 3 only if DO_Delay and CS_Delay are not both equal to 0.
            </comment>
        </bits>
        <bits name="CS_Delay" pos="13:12" access="rw" rst="3">
            <comment>Transfer end to chip select deactivation delay value from 0 to 3 is the number of spi clock half period between the end of transfer and CS deactivation
            </comment>
        </bits>
        <bits name="CS_Pulse" pos="15:14" access="rw" rst="3">
            <comment>Chip select deactivation to reactivation minimum delay value from 0 to 3 is the number of spi clock half period between the CS deactivation and a new CS activation (CS will activate only if more data are available in the transmit FIFO)
            </comment>
        </bits>
        <bits name="Frame_Size" pos="21:16" access="rw" rst="63">
            <comment>Frame Size
                <br/>The frame size is the binary value of this register + 1 valid value are 3 to 63 (frame size 4 to 64bits)
            </comment>
        </bits>
        <bits name="OE_delay" pos="28:23" access="rw" rst="63">
            <comment>OE delay
                <br/>When 0: regular mode, SPI_DO pin as output only.
                <br/>Value from 1 to 63 is the number of data out to transfert before the SPI_DO pin switch to input.
            </comment>
        </bits>
        <bits name="ctrl_data_mux_sel" pos="29" access="rw" rst="0">
            <comment>Selects the active CS and Input_reg either from the ctrl or rxtx_buffer register.
                <br/>If SPI FIFO 8b or 32b, when set to "0": CS from CS_sel and INPUT from Input_mode in the register ctrl.
                <br/>Only if SPI FIFO 32b, when set to "1": CS and INPUT from SPI DATA.(Do not work for FIFO8b)
            </comment>
            <options>
                <option name="Ctrl_reg_sel"  value="0"/>
                <option name="Data_reg_sel"  value="1"/>
                <default/><shift/><mask/>
            </options>            
        </bits>
        
        <bits name="Input_sel" pos="31:30" access="rw" rst="0">
            <comment>Selects the input line to be used as SPI data in.(Not used for SPI3)
                <br/>when "00" the SPI_DI_0 is used.
                <br/>When "01" the SPI_DI_1 is used.
                <br/>When "10" the SPI_DI_2 is used. 
                <br/>When "11" reserved.
            </comment>
        </bits>
        
    </reg>
        
    <reg name="status" protect="rw">

        <bits name="Active_Status" pos="0" access="r" rst="0">
            <comment>'1' when a transfer is in progress.
            </comment>
        </bits>
        <bits name="Cause_Rx_Ovf_Irq" pos="3" access="rw" rst="0">
            <comment>The receive FIFO overflow irq cause.
                <br/>Writing a '1' clear the receive overflow status and cause.
            </comment>
        </bits>
        <bits name="Cause_Tx_Th_Irq" pos="4" access="r" rst="0">
            <comment>The transmit FIFO threshold irq cause.
            </comment>
        </bits>
        <bits name="Cause_Tx_Dma_Irq" pos="5" access="rw" rst="0">
            <comment>The transmit Dma Done irq cause.
                <br/>Writing a '1' clear the transmit Dma Done status and cause.
            </comment>
        </bits>
        <bits name="Cause_Rx_Th_Irq" pos="6" access="r" rst="0">
            <comment>The receive FIFO threshold irq cause.
            </comment>
        </bits>
        <bits name="Cause_Rx_Dma_Irq" pos="7" access="rw" rst="0">
            <comment>The receive Dma Done irq cause.
                <br/>Writing a '1' clear the receive Dma Done status and cause.
            </comment>
        </bits>
        <bitgroup name="Irq_Cause">
            <entry ref="Cause_Rx_Ovf_Irq"/>
            <entry ref="Cause_Tx_Th_Irq"/>
            <entry ref="Cause_Tx_Dma_Irq"/>
            <entry ref="Cause_Rx_Th_Irq"/>
            <entry ref="Cause_Rx_Dma_Irq"/>
        </bitgroup>
        <bits name="Tx_Ovf" pos="9" access="rw" rst="0">
            <comment>The transmit FIFO overflow status.
                <br/>Writing a '1' clear the transmit overflow status and cause.
            </comment>
        </bits>
        <bits name="Rx_Udf" pos="10" access="rw" rst="0">
            <comment>The receive FIFO underflow status.
                <br/>Writing a '1' clear the receive underflow status and cause.
            </comment>
        </bits>
        <bits name="Rx_Ovf" pos="11" access="rw" rst="0">
            <comment>The receive FIFO overflow status.
                <br/>Writing a '1' clear the receive overflow status and cause.
            </comment>
        </bits> 
        <bits name="Tx_Th" pos="12" access="r" rst="0">
            <comment>The transmit FIFO threshold status.
            </comment>
        </bits> 
        <bits name="Tx_Dma_Done" pos="13" access="rw" rst="0">
            <comment>The transmit Dma Done status.
                <br/>Writing a '1' clear the transmit Dma Done status and cause.
            </comment>
        </bits> 
        <bits name="Rx_Th" pos="14" access="r" rst="0">
            <comment>The receive FIFO threshold status.
            </comment>
        </bits> 
        <bits name="Rx_Dma_Done" pos="15" access="rw" rst="0">
            <comment>The receive Dma Done status.
                <br/>Writing a '1' clear the receive Dma Done status and cause.
            </comment>
        </bits> 
        <bits name="Tx_Space" pos="20:16" access="r" rst="16" >
            <comment>Transmit FIFO Space
                <br/>Number of empty spot in the FIFO
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits> 
        <bits name="Rx_Level" pos="28:24" access="r" rst="0">
            <comment>Receive FIFO level
                <br/>Number of DATA in the FIFO
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits> 
        <bits name="FIFO_Flush" pos="30" access="w" rst="0">
            <comment>Writing '1' flush both FIFO, don't do it when SPI is active (transfer in progress)
            </comment>
        </bits>
    </reg>
    <reg name="rxtx_buffer" protect="--">
        <comment>Spi1 fifo size (rxtx_buffer): 8bits.<br/>
                 Spi2 fifo size (rxtx_buffer): 8bits.<br/>
                 Spi3 fifo size (rxtx_buffer): 32bits.<br/>

        </comment>
        <bits name="DATA_IN_OUT" pos="28:0" access="rw" rst="0">
            <comment>Write to the transmit FIFO
	    Read in the receive FIFO.
            </comment>
        </bits>
        
        <bits name="CS" pos="30:29" access="rw" rst="0">
            <comment>
                Chip Select on which write the data written in the
                Fifo. 
		Data in bit [30:29]
		Data out bit [30:29]
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

        <bits name="READ_ENA" pos="31" access="rw" rst="0">
            <comment>
                Set this bit to one when the data received while sending
                this peculiar data are expected to be kept in the FIFO,
                otherwise no data is recorded in the FIFO.
		Data in bit [31]
		Data out bit [31]
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>
    <reg name="cfg" protect="rw">
        <bits name="CS_Polarity" pos="2:0" access="rw" rst="all1" cut="1" cutprefix="CS_Polarity">
            <comment>Chip select polarity
            </comment>
            <options>
                <option name="active high" value="0"><comment>chip select is active high</comment></option>
                <option name="active low" value="1"><comment>chip select is active low</comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="Clock_Divider" pos="25:16" access="rw" rst="0x3ff">
            <comment>Clock Divider
                <br/>The state machine clock is generated by dividing the system clock by the value of this register + 1.
                <br/>So the output clock is divided by (register + 1)*2
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Clock_Limiter" pos="28" access="rw" rst="1">
            <comment>When enabled the clock input to the divider is not the system clock, but a limited version of it: It cannot be above 52MHz, so the output clock will never be above 26MHz.
                <br/> for system clock of 104Mhz the clock input to the divider is 52Mhz, for system clock of 78Mhz the clock input to the divider is 39Mhz, for lower system clock value, the input to the divider is the system clock.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>

    <reg name="pattern" protect="rw">
        <bits name="pattern" pos="7:0" access="rw" rst="0">
            <comment>MMC Pattern value for RX pattern match mode.
            </comment>
        </bits>
        <bits name="pattern_mode" pos="8" access="rw" rst="0">
            <comment> Enable the pattern mode.
            </comment>
            <options>
                <option name="disabled" value="0"><comment>Spi Behaviour.</comment></option>
                <option name="enabled" value="1"><comment>Pattern matching.</comment></option>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="pattern_selector" pos="9" access="rw" rst="0">
            <comment> Select the RX pattern matching mode when the pattern_mode is enabled( set 1). Used for SD/MMC SPI mode.</comment>
            <options>
                <option name="UNTIL" value="0"><comment>No datas are written into the RX FIFO UNTIL the received data is equal to the pattern.</comment></option>
                <option name="WHILE" value="1"><comment>No datas are written into the RX FIFO WHILE the received data is equal to the pattern.</comment></option>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    
    <reg name="stream" protect="rw">
        <bits name="tx_stream_bit" pos="0" access="rw" rst="0">
            <comment>When TX stream mode is enabled, once the TX fifo is empty, all new bits send have the value of this bit.
            </comment>
            <options>
                <option name="zero" value="0"/>
                <option name="one" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="tx_stream_mode" pos="8" access="rw" rst="0">
            <comment>Enable the TX stream mode. Used for SD/MMC SPI mode.
                <br/>When enabled, this mode provide infinite bit stream for sending, after fifo is empty the extra bits generated all have the same value. The value is in tx_stream_bit.
            </comment>    
            <options>
                <option name="disabled" value="0"/>
                <option name="enabled" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="tx_stream_stop_with_rx_dma_done" pos="16" access="rw" rst="0">
            <comment>Allow to automatically clear the tx_stream_mode when Rx_Dma_Done is set.
            </comment>    
            <options>
                <option name="disabled" value="0"/>
                <option name="enabled" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    <reg name="pin_control" protect="rw">
        <bits name="clk_ctrl" pos="1:0" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_Clk pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_Clk pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_Clk pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_Clk pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="do_ctrl" pos="3:2" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_DO pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_DO pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_DO pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_DO pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>            
        </bits>
        <bits name="cs0_ctrl" pos="5:4" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CSO pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CSO pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CSO pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CSO pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>               
        </bits>        
        <bits name="cs1_ctrl" pos="7:6" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CS1 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CS1 pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CS1 pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CS1 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits>
        <bits name="cs2_ctrl" pos="9:8" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CS2 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CS2 pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CS2 pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CS2 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits> 
         
    </reg>
    <reg name="irq" protect="rw">
        <bits name="Mask_Rx_ovf_Irq" pos="0" access="rw" rst="0">
            <comment>Mask the receive FIFO overflow irq
            </comment>
        </bits>
        <bits name="Mask_Tx_Th_Irq" pos="1" access="rw" rst="0">
            <comment>Mask the transmit FIFO threshold irq
            </comment>
        </bits>
        <bits name="Mask_Tx_Dma_Irq" pos="2" access="rw" rst="0">
            <comment>Mask the transmit Dma Done irq
            </comment>
        </bits>
        <bits name="Mask_Rx_Th_Irq" pos="3" access="rw" rst="0">
            <comment>Mask the receive FIFO threshold irq
            </comment>
        </bits>
        <bits name="Mask_Rx_Dma_Irq" pos="4" access="rw" rst="0">
            <comment>Mask the receive DMA Done irq
            </comment>
        </bits>
        <bitgroup name="Irq_Mask">
            <entry ref="Mask_Rx_ovf_Irq"/>
            <entry ref="Mask_Tx_Th_Irq"/>
            <entry ref="Mask_Tx_Dma_Irq"/>
            <entry ref="Mask_Rx_Th_Irq"/>
            <entry ref="Mask_Rx_Dma_Irq"/>
        </bitgroup>
        <bits name="Tx_Threshold" pos="6:5" access="rw" rst="3">
            <comment>Transmit FIFO threshold this threshold is used to generate the irq.
            </comment>
            <options>
                <option name="1 Empty Slot" value="0"/>
                <option name="4 Empty Slots" value="1"/>
                <option name="8 Empty Slots" value="2"/>
                <option name="12 Empty Slots" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="Rx_Threshold" pos="8:7" access="rw" rst="3">
            <comment>Receive FIFO threshold this threshold is used to generate the irq.
            </comment>
            <options>
                <option name="1 Valid Data" value="0"/>
                <option name="4 Valid Data" value="1"/>
                <option name="8 Valid Data" value="2"/>
                <option name="12 Valid Data" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>

</module>
</archive>
<archive relative = "sys_ctrl.xml">

<module name="sys_ctrl" category="System">

  <reg name="chip_id" protect="r">
    <bits access="r" name="major_id" pos="31:18" rst="0x226B">
    </bits>
    <bits access="r" name="minor_id" pos="17:13" rst="0x1">
    </bits>
    <bits access="r" name="bond_id" pos="12:12" rst="0x0">
    </bits>
    <bits access="r" name="metal_id" pos="11:0" rst="0x0">
    </bits>
  </reg>

  <reg name="reg_dbg" protect="rw">
    <bits access="rw" name="scratch" pos="15:0" rst="0x0">
    </bits>
  </reg>

  <reg name="sys_rst_set0" protect="rw">
    <bits access="w1s" name="set_rst_global" pos="31:31" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_page_spy" pos="20:20" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_i2s" pos="19:19" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_keypad" pos="18:18" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_seg_lcd" pos="17:17" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sdmmc" pos="16:16" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_i2c3" pos="15:15" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_i2c2" pos="14:14" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_i2c1" pos="13:13" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_gpt2" pos="12:12" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_gpio2" pos="11:11" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_spi2" pos="10:10" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_spi1" pos="9:9" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_uart5" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_uart4" pos="7:7" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_uart3" pos="6:6" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_wdt" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_timer2" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sys_dec2" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sys_dec1" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sys_dma" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_starmcu" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="sys_rst_clr0" protect="rw">
    <bits access="rw1c" name="clr_rst_page_spy" pos="20:20" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_i2s" pos="19:19" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_keypad" pos="18:18" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_seg_lcd" pos="17:17" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sdmmc" pos="16:16" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_i2c3" pos="15:15" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_i2c2" pos="14:14" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_i2c1" pos="13:13" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_gpt2" pos="12:12" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_gpio2" pos="11:11" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_spi2" pos="10:10" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_spi1" pos="9:9" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_uart5" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_uart4" pos="7:7" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_uart3" pos="6:6" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_wdt" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_timer2" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sys_dec2" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sys_dec1" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sys_dma" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_starmcu" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="sys_rst_set1" protect="rw">
    <bits access="rw1s" name="set_rst_med" pos="9:9" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_ce_top" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_psram" pos="7:7" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_dbg" pos="6:6" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sci2" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_adi_if" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_flash_ext" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_flash" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_iomux2" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_efuse" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="sys_rst_clr1" protect="rw">
    <bits access="rw1c" name="clr_rst_med" pos="9:9" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_ce_top" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_psram" pos="7:7" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_dbg" pos="6:6" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sci2" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_adi_if" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_flash_ext" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_flash" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_iomux2" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_efuse" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="clk_sys_enable0" protect="rw">
    <bits access="rw1s" name="enable_page_spy" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_i2s" pos="19:19" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_keypad" pos="18:18" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_seg_lcd" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sdmmc" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_i2c3" pos="15:15" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_i2c2" pos="14:14" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_i2c1" pos="13:13" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_gpt2" pos="12:12" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_gpio2" pos="11:11" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_spi2" pos="10:10" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_spi1" pos="9:9" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_uart5" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_uart4" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_uart3" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_wdt" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_timer2" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sys_dec2" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sys_dec1" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sys_dma" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_starmcu" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_sys_disable0" protect="rw">
    <bits access="rw1c" name="disable_page_spy" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_i2s" pos="19:19" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_keypad" pos="18:18" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_seg_lcd" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sdmmc" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_i2c3" pos="15:15" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_i2c2" pos="14:14" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_i2c1" pos="13:13" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_gpt2" pos="12:12" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_gpio2" pos="11:11" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_spi2" pos="10:10" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_spi1" pos="9:9" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_uart5" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_uart4" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_uart3" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_wdt" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_timer2" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sys_dec2" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sys_dec1" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sys_dma" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_starmcu" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_sys_enable1" protect="rw">
    <bits access="rw1s" name="enable_med" pos="9:9" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_ce_top" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_psram" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_dbg" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sci2" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_adi_if" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_flash_ext" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_flash" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_iomux2" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_efuse" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_sys_disable1" protect="rw">
    <bits access="rw1c" name="disable_med" pos="9:9" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_ce_top" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_psram" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_dbg" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sci2" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_adi_if" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_flash_ext" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_flash" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_iomux2" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_efuse" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="pll_ctrl" protect="rw">
    <bits access="r" name="nb_pll_locked" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1c" name="nb_pll_pd" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1s" name="nb_pll_pu" pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="mcu_pll_locked" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="mcu_pll_pd" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="mcu_pll_pu" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="sel_clock_sys" protect="rw">
    <bits access="rw" name="sel_timer2_clk" pos="29:28" rst="0x0">
    </bits>
    <bits access="rw" name="sel_st_clk" pos="27:26" rst="0x0">
    </bits>
    <bits access="rw" name="sel_sst_clk" pos="25:24" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_efuse" pos="23:22" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_xtal52m_bak" pos="21:21" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_i2s" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_psram" pos="16:16" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_rfspi" pos="15:15" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_spi2" pos="14:14" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_spi1" pos="13:13" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_dbg" pos="12:11" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_uart5" pos="10:9" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_uart4" pos="8:7" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_uart3" pos="6:5" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_flash_ext" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_flash" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_sys" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_slow" pos="1:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cfg_clk_sys" protect="rw">
    <bits access="rw" name="sys_pclken_denom" pos="29:24" rst="0x4">
    </bits>
    <bits access="rw" name="sys_pclken_num" pos="23:18" rst="0x1">
    </bits>
    <bits access="rw" name="sys_div_denom" pos="17:9" rst="0x4">
    </bits>
    <bits access="rw" name="sys_div_num" pos="8:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_spiflash" protect="rw">
    <bits access="rw" name="spiflash_freq" pos="3:0" rst="0x9">
    </bits>
  </reg>

  <reg name="cfg_clk_spiflash_ext" protect="rw">
    <bits access="rw" name="spiflash_ext_freq" pos="3:0" rst="0x9">
    </bits>
  </reg>

  <reg name="cfg_clk_dbg" protect="rw">
    <bits access="rw" name="dbg_div_denom" pos="23:10" rst="0xE">
    </bits>
    <bits access="rw" name="dbg_div_num" pos="9:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_uart3" protect="rw">
    <bits access="rw" name="uart3_div_denom" pos="23:10" rst="0xE">
    </bits>
    <bits access="rw" name="uart3_div_num" pos="9:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_uart4" protect="rw">
    <bits access="rw" name="uart4_div_denom" pos="23:10" rst="0xE">
    </bits>
    <bits access="rw" name="uart4_div_num" pos="9:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_uart5" protect="rw">
    <bits access="rw" name="uart5_div_denom" pos="23:10" rst="0xE">
    </bits>
    <bits access="rw" name="uart5_div_num" pos="9:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_psram" protect="rw">
    <bits access="rw" name="psram_freq" pos="3:0" rst="0x9">
    </bits>
  </reg>

  <reg name="cfg_clk_dblr" protect="rw">
    <bits access="rw" name="dblr_rsd" pos="30:27" rst="0x0">
    </bits>
    <bits access="rw" name="pu_clkdblr" pos="26:26" rst="0x1">
    </bits>
    <bits access="rw" name="clkdblr_clk_en" pos="25:25" rst="0x1">
    </bits>
    <bits access="rw" name="clkdblr_r_ctrl" pos="24:22" rst="0x3">
    </bits>
    <bits access="rw" name="clkdblr_vbias_ctrl" pos="21:20" rst="0x1">
    </bits>
    <bits access="rw" name="clkdblr_ibias_ctrl" pos="19:18" rst="0x1">
    </bits>
    <bits access="rw" name="mpll_clk_en" pos="12:12" rst="0x1">
    </bits>
    <bits access="rw" name="sys_dblr_div_denom2" pos="11:6" rst="0x1">
    </bits>
    <bits access="rw" name="sys_dblr_div_denom" pos="5:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_i2s" protect="rw">
    <bits access="rw" name="i2s_mclk_div_denom" pos="31:16" rst="0x196">
    </bits>
    <bits access="rw" name="i2s_div_denom" pos="15:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_out" protect="rw">
    <bits access="rw" name="clkout3_en" pos="31:31" rst="0x0">
    </bits>
    <bits access="rw" name="clkout2_en" pos="30:30" rst="0x0">
    </bits>
    <bits access="rw" name="clkout1_en" pos="29:29" rst="0x0">
    </bits>
    <bits access="rw" name="clkout0_en" pos="28:28" rst="0x0">
    </bits>
    <bits access="rw" name="clkout3_sel" pos="11:9" rst="0x0">
    </bits>
    <bits access="rw" name="clkout2_sel" pos="8:6" rst="0x0">
    </bits>
    <bits access="rw" name="clkout1_sel" pos="5:3" rst="0x0">
    </bits>
    <bits access="rw" name="clkout0_sel" pos="2:0" rst="0x0">
    </bits>
  </reg>

  <reg name="reset_cause" protect="rw">
    <bits access="rw" name="sw_boot_mode" pos="23:20" rst="0x0">
    </bits>
    <bits access="rw" name="boot_mode" pos="19:16" rst="0x0">
        <options><mask/><shift/></options>
    </bits>
    <bits access="rw1c" name="clk_monitor_26m_reset" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1c" name="clk_monitor_32k_reset" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1c" name="wdt_reset" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1c" name="mcu_lockup_reset" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1c" name="mcu_sysresetreq_reset" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="debughost_reset" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1c" name="globalsoft_reset" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="sys_wakeup_cause" protect="r">
    <bits access="r" name="mcu_ext_rst_wakeup" pos="8:8" rst="0x0">
    </bits>
    <bits access="r" name="mcu_ana_wakeup" pos="7:7" rst="0x0">
    </bits>
    <bits access="r" name="mcu_dbg_wakeup" pos="6:6" rst="0x0">
    </bits>
    <bits access="r" name="mcu_gpio1_wakeup" pos="5:5" rst="0x0">
    </bits>
    <bits access="r" name="mcu_timer1_wakeup" pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="mcu_uart2_wakeup" pos="3:3" rst="0x0">
    </bits>
    <bits access="r" name="mcu_uart1_wakeup" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="mcu_gpt1_wakeup" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="mcu_lps_wakeup" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="misc_ctrl" protect="rw">
    <bits access="rw" name="locksvtaircr" pos="31:31" rst="0x0">
    </bits>
    <bits access="rw" name="locknsvtor" pos="30:30" rst="0x0">
    </bits>
    <bits access="rw" name="locksmpu" pos="29:29" rst="0x0">
    </bits>
    <bits access="rw" name="locknsmpu" pos="28:28" rst="0x0">
    </bits>
    <bits access="rw" name="locksau" pos="27:27" rst="0x0">
    </bits>
    <bits access="rw" name="boot_mode_wpd" pos="26:25" rst="0x3">
    </bits>
    <bits access="rw" name="tst_h_wpd" pos="24:24" rst="0x1">
    </bits>
    <bits access="rw" name="adi_sel_pad" pos="23:23" rst="0x0">
    </bits>
    <bits access="rw" name="hresp_err_mask_sysifc2" pos="22:22" rst="0x1">
    </bits>
    <bits access="rw" name="hresp_err_mask_sysifc1" pos="21:21" rst="0x1">
    </bits>
    <bits access="rw" name="dbg_clk_en" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_clk_sel" pos="19:16" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_trig_sel" pos="15:12" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_out_sel" pos="11:8" rst="0x0">
    </bits>
    <bits access="rw" name="mem_retention" pos="7:7" rst="0x1">
    </bits>
    <bits access="rw" name="psram_eco_en" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw" name="force_xcpu_reset_l_en" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw" name="host_reset_l_en" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="clk_monitor_26m_rstn_en" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="clk_monitor_32k_rstn_en" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="wdt_rstn_en" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="lockup_rst_en" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="pad_ctrl" protect="rw">
    <bits access="rw" name="ibit_a_die_if" pos="7:6" rst="0x0">
    </bits>
    <bits access="rw" name="ibit_psram" pos="5:3" rst="0x4">
    </bits>
    <bits access="rw" name="ibit_flash" pos="2:0" rst="0x4">
    </bits>
  </reg>

  <reg name="cpu_ctrl" protect="rw">
    <bits access="rw1c" name="soft_cpu_sleep" pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="starmcu_wicenack" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="starmcu_wicenreq" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="starmcu_sleepdeep" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="starmcu_sleeping" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="otp_reg" protect="rw">
    <bits access="rw" name="otp_reg_rsvd" pos="11:6" rst="0x0">
    </bits>
    <bits access="rw" name="force_enable_dbghost" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw" name="force_enable_snidbg" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="force_enable_sidbg" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="force_enable_nidbg" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="force_enable_idbg" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="force_enable_swd" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mpll_setting0" protect="rw">
    <bits access="r" name="mpll_clktest_out" pos="25:25" rst="0x0">
    </bits>
    <bits access="r" name="mpll_lock" pos="24:24" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_band_sel" pos="23:22" rst="0x1">
    </bits>
    <bits access="rw" name="mpll_ready_timer" pos="21:20" rst="0x1">
    </bits>
    <bits access="rw" name="mpll_rstb_dr" pos="19:19" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_rstb_reg" pos="18:18" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sel_dr" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sel_reg" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_en_dr" pos="15:15" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_en_reg" pos="14:14" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdmclk_disable" pos="11:11" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_cp_offset" pos="10:9" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_cpbias_ibit" pos="8:6" rst="0x4">
    </bits>
    <bits access="rw" name="mpll_cp_offset_en" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_test_en" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_pcon_mode" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_refmulti2_en" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw" name="mpll_sdm_clk_sel_reg" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_clk_sel_dr" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mpll_setting1" protect="rw">
    <bits access="rw" name="mpll_rsvd_reg" pos="29:22" rst="0x1">
    </bits>
    <bits access="rw" name="mpll_testsig_sel" pos="21:20" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_int_mode" pos="19:19" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_vco_low_test" pos="18:18" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_vco_high_test" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_clk_test_en" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_clk_inv" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_resetn_dr" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_resetn_reg" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_int_dec_sel" pos="3:1" rst="0x3">
    </bits>
    <bits access="rw" name="mpll_sdm_dither_bypass" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="mpll_sdm_freq" protect="rw">
    <bits access="rw" name="mpll_sdm_freq" pos="31:0" rst="0x60000000">
    </bits>
  </reg>

  <reg name="dbg_disable_acg0" protect="rw">
    <bits access="rw" name="disable_acg0" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg1" protect="rw">
    <bits access="rw" name="disable_acg1" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg2" protect="rw">
    <bits access="rw" name="disable_acg2" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg3" protect="rw">
    <bits access="rw" name="disable_acg3" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cfg_clk_nbiot_fast" protect="rw">
    <bits access="rw" name="nbiot_fast_div_denom" pos="15:8" rst="0x3">
    </bits>
    <bits access="rw" name="nbiot_fast_div_num" pos="7:0" rst="0x1">
    </bits>
  </reg>

  <reg name="calib_th_32k" protect="rw">
    <bits access="rw" name="calib_th_32k" pos="31:0" rst="0xFFF">
    </bits>
  </reg>

  <reg name="calib_th_rc26m" protect="rw">
    <bits access="rw" name="calib_th_rc26m" pos="31:0" rst="0xFFF">
    </bits>
  </reg>

  <reg name="ctrl_of_32k_calib" protect="rw">
    <bits access="w1s" name="calib_int_clr_32k" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="calib_int_en_32k" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="calib_en_32k" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="ctrl_of_rc26m_calib" protect="rw">
    <bits access="w1s" name="calib_int_clr_rc26m" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="calib_int_en_rc26m" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="calib_en_rc26m" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="num_of_clk1_32k" protect="r">
    <bits access="r" name="num_of_clk1_32k" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="num_of_clk1_rc26m" protect="r">
    <bits access="r" name="num_of_clk1_rc26m" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="star_cfg_nsst" protect="rw">
    <bits access="rw" name="star_nsstcalib" pos="25:0" rst="0x270f">
    </bits>
  </reg>

  <reg name="star_cfg_sst" protect="rw">
    <bits access="rw" name="star_sstcalib" pos="25:0" rst="0x270f">
    </bits>
  </reg>

  <reg name="mem_cfg1" protect="rw">
    <bits access="rw" name="mem_config_1p" pos="31:0" rst="0x8441004b">
    </bits>
  </reg>

  <reg name="timer2_divider" protect="rw">
    <bits access="rw" name="timer2_div_num" pos="15:8" rst="0x1">
    </bits>
    <bits access="rw" name="timer2_div_denom" pos="7:0" rst="0x2">
    </bits>
  </reg>

  <reg name="st_divider" protect="rw">
    <bits access="rw" name="st_div_num" pos="15:8" rst="0x1">
    </bits>
    <bits access="rw" name="st_div_denom" pos="7:0" rst="0x2">
    </bits>
  </reg>

  <reg name="sst_divider" protect="rw">
    <bits access="rw" name="sst_div_num" pos="15:8" rst="0x1">
    </bits>
    <bits access="rw" name="sst_div_denom" pos="7:0" rst="0x2">
    </bits>
  </reg>

  <reg name="sys_ctrl_rsd0" protect="rw">
    <bits access="rw" name="sys_ctrl_rsd0" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="sys_ctrl_rsd1" protect="rw">
    <bits access="rw" name="sys_ctrl_rsd1" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="sys_ctrl_rsd2" protect="rw">
    <bits access="rw" name="sys_ctrl_rsd2" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="sys_ctrl_rsd3" protect="rw">
    <bits access="rw" name="sys_ctrl_rsd3" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mem_cfg2" protect="rw">
    <bits access="rw" name="mem_config_2p" pos="31:0" rst="0x80000011">
    </bits>
  </reg>

  <reg name="clk_mnt26m_th0" protect="rw">
    <bits access="rw" name="clk_mnt26m_th0" pos="7:0" rst="0x40">
    </bits>
  </reg>

  <reg name="clk_mnt26m_th1" protect="rw">
    <bits access="rw" name="clk_mnt26m_th1" pos="15:0" rst="0x3E8">
    </bits>
  </reg>

  <reg name="clk_mnt26m_th2" protect="rw">
    <bits access="rw" name="clk_mnt26m_th2" pos="6:0" rst="0x20">
    </bits>
  </reg>

  <reg name="clk_mnt26m_th3" protect="rw">
    <bits access="rw" name="clk_mnt26m_th3" pos="8:0" rst="0x80">
    </bits>
  </reg>

  <reg name="clk_mnt32k_th0" protect="rw">
    <bits access="rw" name="clk_mnt32k_th0" pos="11:0" rst="0x190">
    </bits>
  </reg>

  <reg name="clk_mnt32k_th1" protect="rw">
    <bits access="rw" name="clk_mnt32k_th1" pos="11:0" rst="0x6A4">
    </bits>
  </reg>

  <reg name="clk_mnt_ctrl" protect="rw">
    <bits access="r" name="st_clk_mnt26m" pos="5:5" rst="0x0">
    </bits>
    <bits access="r" name="st_clk_mnt32k" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="en_int_clk_mnt26m" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="en_int_clk_mnt32k" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="clk_mnt26m_en" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="clk_mnt32k_en" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_mnt26m_st" protect="rw">
    <bits access="w1s" name="clr_int_clk_mnt26m" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_mnt32k_st" protect="rw">
    <bits access="w1s" name="clr_int_clk_mnt32k" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_ctrl" protect="rw">
    <bits access="rw" name="med_debug_bus_sel" pos="12:8" rst="0x0">
    </bits>
    <bits access="rw" name="cfg_clkout_sel" pos="4:1" rst="0x0">
    </bits>
    <bits access="rw" name="cfg_clkout_en" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="lp_irq" protect="r">
    <bits access="r" name="uart1_irq" pos="7:7" rst="0x0">
    </bits>
    <bits access="r" name="uart2_irq" pos="6:6" rst="0x0">
    </bits>
    <bits access="r" name="gpio1_irq" pos="5:5" rst="0x0">
    </bits>
    <bits access="r" name="gpt1_irq" pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="pwr_ctrl_irq" pos="3:3" rst="0x0">
    </bits>
    <bits access="r" name="lps_irq" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="timer1_irq" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="timer1_os_irq" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="adi_if_evt" protect="rw">
    <bits access="rw" name="adi_if_evt1" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="adi_if_evt0" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cfg_clk_efuse" protect="rw">
    <bits access="rw" name="efuse_div_denom" pos="2:0" rst="0x4">
    </bits>
  </reg>

  <reg name="rfspi_apb_sel" protect="rw">
    <bits access="rw" name="rfspi_apb_sel_dr" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="rfspi_apb_sel_sw" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cfg_clk_sram" protect="rw">
    <bits access="rw" name="sram_div_denom" pos="3:0" rst="0x2">
    </bits>
  </reg>

  <reg name="sram_h2h_config" protect="rw">
    <bits access="rw" name="sram_h2h_acg_en" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw" name="sram_h2h_nobuf_early_resp_en" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="sram_h2h_incr_pre_read" pos="0:0" rst="0x0">
    </bits>
  </reg>

</module>
</archive>

<archive relative = "sys_ifc1.xml">

<include file="globals.xml"/>



<var name="SYS_IFC1_ADDR_ALIGN" value="0" />

<var name="SYS_IFC1_TC_LEN" value="23" />

<var name="SYS_IFC1_STD_CHAN_NB" value="SYS_IFC1_NB_STD_CHANNEL" /> 

<var name="SYS_IFC1_RFSPI_CHAN" value="0" />

<var name="SYS_IFC1_DBG_CHAN" value="0" />

<module name="sys_ifc1" category="System">
  

  <reg protect="--" name="get_ch">
    <bits access="r" name="ch_to_use" pos="4:0" rst="0">
      <comment>This field indicates which standard channel to use.
      <br /> Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
      <br /> After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
      <br />Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
      <br />Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
      <br />When non-secure cpu read this register, the return value will automatic exlude the secure channel.
      <br />00000 = use Channel0
      <br />00001 = use Channel1
      <br />00010 = use Channel2 
      <br /> ...
      <br />01111 = use Channel15
      <br />11111 = all channels are busy</comment>
      <options><mask/><shift/><default/></options>
    </bits>
  </reg>

  <reg protect="r" name="dma_status">
    <bits access="r" name="ch_enable" pos="SYS_IFC1_STD_CHAN_NB+SYS_IFC1_RFSPI_CHAN-1:0" rst="0">
      <comment>This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
      <br />0000_0000 = All channels disabled 
      <br />0000_0001 = Ch0 enabled 
      <br />0000_0010 = Ch1 enabled 
      <br />0000_0100 = Ch2 enabled 
      <br />0000_0101 = Ch0 and Ch2 enabled 
      <br />0000_0111 = Ch0, Ch1 and Ch2 enabled 
      <br />all 1     = all channels enabled</comment>
    </bits>

    <bits access="r" name="ch_busy" pos="SYS_IFC1_STD_CHAN_NB-1+16:16" rst="0">
      <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
    </bits>
  </reg>

  <reg protect="r" name="debug_status">
    <bits access="r" name="dbg_status" pos="0" rst="1">
      <comment>Debug Channel Status .<br />0= The debug channel is running
      (not idle) <br />1= The debug channel is in idle mode</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ifc_sec">
    <bits access="rw" name="std_ch_reg_sec" pos="SYS_IFC1_STD_CHAN_NB-1:0" rst="0">
      <comment>This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
      <br />0000_0000 = All channels registers can be accessed by secure master or non-secure master.
      <br />0000_0001 = Ch0 registers can only be accessed by secure master.
      <br />0000_0010 = Ch1 registers can only be accessed by secure master.
      <br />0000_0100 = Ch2 registers can only be accessed by secure master.
      <br />0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
      <br />0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
      <br /> ......
      <br />all 1 = all channels registers can only be accessed by secure master.</comment>
    </bits>
    
    <bits access="rw" name="std_ch_dma_sec" pos="SYS_IFC1_STD_CHAN_NB-1+16:16" rst="all1">
      <comment>This register indicates which channel dma is secure master. One bit per
      channel, for example:
      <br />0000_0000 = All channels dma are non-secure master.
      <br />0000_0001 = Ch0 dma is secure master.
      <br />0000_0010 = Ch1 dma is secure master.
      <br />0000_0100 = Ch2 dma is secure master.
      <br />0000_0101 = Ch0 and Ch2 dma are secure master.
      <br />0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
      <br /> ......
      <br />all 1 = all channels dma are secure master.</comment>
    </bits>
    
  </reg>

  

  

  <struct count="SYS_IFC1_STD_CHAN_NB" name="std_ch">
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>


      <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
        <comment>Exchange the read data from fifo halfword MSB or LSB
        <br />
    </comment>
      </bits>

      <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
        <comment>Exchange the write data to fifo  halfword MSB or LSB
        <br />
    </comment>
      </bits>


      <bits access="rw" name="autodisable" pos="4" rst="1">
        <comment>Set Auto-disable mode<br /> 0 = when TC reach zero the
        channel is not automatically released.<br /> 1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.</comment>
      </bits>
      
      <bits access="rw" name="Size" pos="5" rst="0">
        <comment>Peripheral Size
            <br /> 0= 8-bit peripheral
            <br /> 1= 32-bit peripheral
        </comment>
      </bits>

      <bits access="rw" name="req_src" pos="12:8" rst="0x1F" display="hex">
        <options linkenum="SYS_Ifc1_Request_IDs"> 
          
          <shift/><mask/><default/>
        </options>

        <comment>Select DMA Request source</comment>
      </bits>

        <bits access="rw" name="flush" pos="16" rst="0">
        <comment>When one, flush the internal FIFO channel. 
        <br />This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel. 
        <br /> Before writting back this bit to zero the internal fifo must empty.
        </comment>
      </bits>

        <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
        <comment>Set the MAX burst length for channel 0,1. 
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.  
        <br /> The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4. 
        <br /> .
        </comment>



        
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="NB_BITS_ADDR-1:SYS_IFC1_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB Address. This field represent the start address of the
        transfer.
        <br />For a 32-bit peripheral, this address must be aligned 32-bit.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc">
      <bits access="rw" name="tc" pos="SYS_IFC1_TC_LEN-1:0" rst="0xFFFFFF" display="hex">
        <comment>Transfer Count, this field indicated the transfer size in bytes to perform.
        <br />During a transfer a write in this register add the new value to the current TC. 
        <br />A read of this register return the current current transfer count.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc_threshold">
      <bits access="rw" name="tc_threshold" pos="SYS_IFC1_TC_LEN-1:0" rst="0x0" display="hex">
        <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.
        </comment>
      </bits>
    </reg>
  </struct>
  
  

  
</module>

</archive>

<archive relative = "sys_ifc2.xml">

<include file="globals.xml"/>



<var name="SYS_IFC2_ADDR_ALIGN" value="0" />

<var name="SYS_IFC2_TC_LEN" value="23" />

<var name="SYS_IFC2_STD_CHAN_NB" value="SYS_IFC2_NB_STD_CHANNEL" /> 

<var name="SYS_IFC2_RFSPI_CHAN" value="0" />

<var name="SYS_IFC2_DBG_CHAN" value="1" />

<module name="sys_ifc2" category="System">
  

  <reg protect="--" name="get_ch">
    <bits access="r" name="ch_to_use" pos="4:0" rst="0">
      <comment>This field indicates which standard channel to use.
      <br /> Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
      <br /> After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
      <br />Secure cpu can use all channels, but non-secure cpu only can use non-secure channel.
      <br />Non-secure channel means std_ch_reg_sec is 1'b0, don't care about the value of std_ch_dma_sec.
      <br />When non-secure cpu read this register, the return value will automatic exlude the secure channel.
      <br />00000 = use Channel0
      <br />00001 = use Channel1
      <br />00010 = use Channel2 
      <br /> ...
      <br />01111 = use Channel15
      <br />11111 = all channels are busy</comment>
      <options><mask/><shift/><default/></options>
    </bits>
  </reg>

  <reg protect="r" name="dma_status">
    <bits access="r" name="ch_enable" pos="SYS_IFC2_STD_CHAN_NB+SYS_IFC2_RFSPI_CHAN-1:0" rst="0">
      <comment>This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
      <br />0000_0000 = All channels disabled 
      <br />0000_0001 = Ch0 enabled 
      <br />0000_0010 = Ch1 enabled 
      <br />0000_0100 = Ch2 enabled 
      <br />0000_0101 = Ch0 and Ch2 enabled 
      <br />0000_0111 = Ch0, Ch1 and Ch2 enabled 
      <br />all 1     = all channels enabled</comment>
    </bits>

    <bits access="r" name="ch_busy" pos="SYS_IFC2_STD_CHAN_NB-1+16:16" rst="0">
      <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
    </bits>
  </reg>

  <reg protect="r" name="debug_status">
    <bits access="r" name="dbg_status" pos="0" rst="1">
      <comment>Debug Channel Status .<br />0= The debug channel is running
      (not idle) <br />1= The debug channel is in idle mode</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ifc_sec">
    <bits access="rw" name="std_ch_reg_sec" pos="SYS_IFC2_STD_CHAN_NB-1:0" rst="0">
      <comment>This register indicates which channel register can only be accessed by secure master. One bit per
      channel, for example:
      <br />0000_0000 = All channels registers can be accessed by secure master or non-secure master.
      <br />0000_0001 = Ch0 registers can only be accessed by secure master.
      <br />0000_0010 = Ch1 registers can only be accessed by secure master.
      <br />0000_0100 = Ch2 registers can only be accessed by secure master.
      <br />0000_0101 = Ch0 and Ch2 registers can only be accessed by secure master.
      <br />0000_0111 = Ch0, Ch1 and Ch2 registers can only be accessed by secure master.
      <br /> ......
      <br />all 1 = all channels registers can only be accessed by secure master.</comment>
    </bits>
    
    <bits access="rw" name="std_ch_dma_sec" pos="SYS_IFC2_STD_CHAN_NB-1+16:16" rst="all1">
      <comment>This register indicates which channel dma is secure master. One bit per
      channel, for example:
      <br />0000_0000 = All channels dma are non-secure master.
      <br />0000_0001 = Ch0 dma is secure master.
      <br />0000_0010 = Ch1 dma is secure master.
      <br />0000_0100 = Ch2 dma is secure master.
      <br />0000_0101 = Ch0 and Ch2 dma are secure master.
      <br />0000_0111 = Ch0, Ch1 and Ch2 dma are secure master.
      <br /> ......
      <br />all 1 = all channels dma are secure master.</comment>
    </bits>
    
    <bits access="rw" name="dbg_ch_dma_sec" pos="SYS_IFC2_STD_CHAN_NB+SYS_IFC2_RFSPI_CHAN+SYS_IFC2_DBG_CHAN-1+16:SYS_IFC2_STD_CHAN_NB+SYS_IFC2_RFSPI_CHAN+16" rst="1">
      <comment>This register indicates dbghost channel dma is secure master.</comment>
    </bits>
  </reg>

  

  

  <struct count="SYS_IFC2_STD_CHAN_NB" name="std_ch">
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>


      <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
        <comment>Exchange the read data from fifo halfword MSB or LSB
        <br />
    </comment>
      </bits>

      <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
        <comment>Exchange the write data to fifo  halfword MSB or LSB
        <br />
    </comment>
      </bits>


      <bits access="rw" name="autodisable" pos="4" rst="1">
        <comment>Set Auto-disable mode<br /> 0 = when TC reach zero the
        channel is not automatically released.<br /> 1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.</comment>
      </bits>
      
      <bits access="rw" name="Size" pos="5" rst="0">
        <comment>Peripheral Size
            <br /> 0= 8-bit peripheral
            <br /> 1= 32-bit peripheral
        </comment>
      </bits>

      <bits access="rw" name="req_src" pos="12:8" rst="0x1F" display="hex">
        <options linkenum="SYS_Ifc2_Request_IDs"> 
          
          <shift/><mask/><default/>
        </options>

        <comment>Select DMA Request source</comment>
      </bits>

        <bits access="rw" name="flush" pos="16" rst="0">
        <comment>When one, flush the internal FIFO channel. 
        <br />This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel. 
        <br /> Before writting back this bit to zero the internal fifo must empty.
        </comment>
      </bits>

        <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
        <comment>Set the MAX burst length for channel 0,1. 
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.  
        <br /> The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4. 
        <br /> .
        </comment>



        
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="NB_BITS_ADDR-1:SYS_IFC2_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB Address. This field represent the start address of the
        transfer.
        <br />For a 32-bit peripheral, this address must be aligned 32-bit.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc">
      <bits access="rw" name="tc" pos="SYS_IFC2_TC_LEN-1:0" rst="0xFFFFFF" display="hex">
        <comment>Transfer Count, this field indicated the transfer size in bytes to perform.
        <br />During a transfer a write in this register add the new value to the current TC. 
        <br />A read of this register return the current current transfer count.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc_threshold">
      <bits access="rw" name="tc_threshold" pos="SYS_IFC2_TC_LEN-1:0" rst="0x0" display="hex">
        <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.
        </comment>
      </bits>
    </reg>
  </struct>
  
  

  
</module>

</archive>
<archive relative = "sys_mem.xml">
  <var name="SYS_IROM_SIZE"  value="128*1024" />      
  <var name="SYS_DROM_SIZE"  value="24*1024" />       
  <var name="SYS_RAM0_SIZE"  value="192*1024" />      
  <var name="SYS_RAM1_SIZE"  value="256*1024" />      
  <var name="NB_RAM_SIZE"    value="64*1024" />       
  <var name="PSRAM_SIZE"     value="4*1024*1024" />   
  <var name="FLASH_SIZE"     value="4*1024*1024" />   

  
  <module name="sys_irom" category="System">
    <memory name="rom_array" size="SYS_IROM_SIZE">
      <comment>System Rom Space
        <br/>This rom is used for XCPU boot code.
      </comment>
    </memory>
  </module>

  <module name="sys_drom" category="System">
    <memory name="rom_array" size="SYS_DROM_SIZE">
      <comment>System Rom Space
        <br/>This rom is used for XCPU boot code.
      </comment>
    </memory>
  </module>

  
  <module name="sys_ram0" category="System">
    <memory name="ram_array" size="SYS_RAM0_SIZE">
      <comment>System Ram Space
        <br/>
      </comment>
    </memory>
  </module>

  <module name="sys_ram1" category="System">
    <memory name="ram_array" size="SYS_RAM1_SIZE">
      <comment>System Ram Space
        <br/>
      </comment>
    </memory>
  </module>

  
  <module name="nb_ram" category="System">
    <memory name="ram_array" size="NB_RAM_SIZE">
      <comment>Nb Ram Space
        <br/>
      </comment>
    </memory>
  </module>

  
  <module name="psram" category="System">            
    <memory name="ram_array" size="PSRAM_SIZE">   
      <comment>PSRAM Space                        
        <br/> In-package PSRAM                    
      </comment>                                  
    </memory>                                     
  </module>                                       

  
  <module name="flash" category="System">
    <memory name="ram_array" size="FLASH_SIZE">
      <comment>FLASH Space
        <br/> In-package FLASH
      </comment>
    </memory>
  </module>




</archive>
<archive relative = "tcu.xml">

<module name="tcu" category="Modem">

    
    <var name="NB_TCO" value="12"/> 
    <var name="NB_TCU_PROG_EVENTS" value="60"/>

    <enum name="Internal_TCO_mapping">
        <entry name="TCO_GMSK_ON" value="6"><comment>Internal TCO mapping</comment></entry>
        <entry name="TCO_TX_OEN"/>
        <entry name="TCO_TX_ON"/>
        <entry name="TCO_RX_ON"/>
        <entry name="TCO_RX_DEC_ON"/>
        <entry name="TCO_PDN"/>
    </enum>

    <enum name="TCU_Event">
        
        <entry name="Clr_TCO_0" value="0"><comment>Clear TCO 0 : set the TCO 0 to the inactive state<br/>To clear TCO n, use event 2*n</comment></entry>
        <entry name="Set_TCO_0" value="1"><comment>Set TCO 0 : set the TCO 0 to the active state<br/>To set TCO n, use event 2*n+1</comment></entry>
        <entry name="Clr_TCO_1"><comment>...</comment></entry>
        <entry name="Set_TCO_1"/>
        <entry name="Clr_TCO_2"/>
        <entry name="Set_TCO_2"/>
        <entry name="Clr_TCO_3"/>
        <entry name="Set_TCO_3"/>
        <entry name="Clr_TCO_4"/>
        <entry name="Set_TCO_4"/>
        <entry name="Clr_TCO_5"/>
        <entry name="Set_TCO_5"/>
        
        
        <entry name="Stop_GMSK" value="TCO_GMSK_ON*2"><comment>stop modulation</comment></entry>
        <entry name="Start_GMSK" value="TCO_GMSK_ON*2+1"><comment>starts modulation and output on IQ DAC</comment></entry>
        <entry name="HighZ_IQ_DAC" value="TCO_TX_OEN*2"/>
        <entry name="Drive_IQ_DAC" value="TCO_TX_OEN*2+1"/>
        <entry name="disable_IQ_DAC" value="TCO_TX_ON*2"/>
        <entry name="enable_IQ_DAC" value="TCO_TX_ON*2+1"/>
        <entry name="disable_IQ_ADC" value="TCO_RX_ON*2"><comment>disable IQ ADC</comment></entry>
        <entry name="enable_IQ_ADC" value="TCO_RX_ON*2+1"><comment>enable IQ ADC</comment></entry>
        <entry name="stop_RFin_record" value="TCO_RX_DEC_ON*2"><comment>stop recording IQ samples</comment></entry>
        <entry name="start_RFin_record" value="TCO_RX_DEC_ON*2+1"><comment>start recording IQ samples</comment></entry>
        <entry name="Clr_PDN" value="TCO_PDN*2"><comment>Clear RF_PDN</comment></entry>
        <entry name="Set_PDN" value="TCO_PDN*2+1"><comment>Set RF_PDN</comment></entry>
        
        <entry name="SEND_SPI_CMD" value="NB_TCO*2"><comment>Send RF spi command</comment></entry>
        <entry name="NEXT_GAIN"/>
        <entry name="FIRST_GAIN"/>
        
        <entry name="NEXT_FC"/>
        
        <entry name="PA_RAMP0"><comment>Start Ramp 0</comment></entry>
        <entry name="PA_RAMP1"><comment>Start Ramp 1</comment></entry>
        <entry name="PA_RAMP2"><comment>Start Ramp 2</comment></entry>
        <entry name="PA_RAMP3"><comment>Start Ramp 3</comment></entry>
        <entry name="PA_RAMP4"><comment>Start Ramp 4</comment></entry>
        <entry name="RX_SOC"/>
        <entry name="DIGRF_STB"/>
        
        <entry name="WAKEUP_DONE"><comment>End of the WakeUp Mode</comment></entry>
        
        <entry name="RFSPI_START"><comment>Start of Rf_spi Transfer</comment></entry>
        <entry name="RFSPI_END"><comment>End of Rf_spi Transfer</comment></entry>
        
        <entry name="BCPU_TCU_IRQ0"><comment>Trigger BCPU TCU irq 0</comment></entry>
        <entry name="BCPU_TCU_IRQ1"><comment>Trigger BCPU TCU irq 1</comment></entry>
        
        <entry name="XCPU_TCU_IRQ0"><comment>Trigger XCPU TCU irq 0</comment></entry>
        <entry name="XCPU_TCU_IRQ1"><comment>Trigger XCPU TCU irq 1</comment></entry>
        <entry name="XCPU_TCU_IRQ2"><comment>Trigger XCPU TCU irq 2</comment></entry>
        <entry name="XCPU_TCU_IRQ3"><comment>Trigger XCPU TCU irq 3</comment></entry>
        <entry name="XCPU_TCU_IRQ4"><comment>Trigger XCPU TCU irq 4</comment></entry>
        <entry name="XCPU_TCU_IRQ5"><comment>Trigger XCPU TCU irq 5</comment></entry>
        <entry name="XCPU_TCU_IRQ6"><comment>Trigger XCPU TCU irq 6</comment></entry>
        <entry name="XCPU_TCU_IRQ7"><comment>Trigger XCPU TCU irq 7</comment></entry>
        <entry name="XCPU_TCU_IRQ8"><comment>Trigger XCPU TCU irq 8</comment></entry>
        <entry name="XCPU_TCU_IRQ9"><comment>Trigger XCPU TCU irq 9</comment></entry>
        <entry name="XCPU_TCU_IRQ10"><comment>Trigger XCPU TCU irq 10</comment></entry>
        <entry name="XCPU_TCU_IRQ11"><comment>Trigger XCPU TCU irq 11</comment></entry>
        <entry name="XCPU_TCU_IRQ12"><comment>Trigger XCPU TCU irq 12</comment></entry>
        <entry name="XCPU_TCU_IRQ13"><comment>Trigger XCPU TCU irq 13</comment></entry>
        <entry name="XCPU_TCU_IRQ14"><comment>Trigger XCPU TCU irq 14</comment></entry>
        <entry name="XCPU_TCU_IRQ15"><comment>Trigger XCPU TCU irq 15</comment></entry>
        
        <entry name="NO_EVENT" value="63"/> 
    </enum>

    
    <reg name="Ctrl" protect="rw">
        <bits name="Load_Val" pos="14:0" access="rw" rst="all1" display="hex">
            <comment>Value loaded into the TCU counter when the Load bit is set to 1
            </comment>
        </bits>
        <bits name="Load_Sf" pos="19:16" access="rw" rst="0" display="hex">
            <comment>Subframe alue loaded into the TCU counter when the Load bit is set to 1
            </comment>
        </bits>
        <bits name="Enable" pos="20" access="rw" rst="0">
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Load" pos="24" access="w" rst="0">
            <comment>Writing a 1 to this bit will load the TCU with the TCU loadval value
                <br/>Writing a 0 has no effect
            </comment>
        </bits>
        <bits name="NoLatch" pos="28" access="rw" rst="0">
            <options>
                <option name="Normal" value="0"><comment>Normal Behavior, The programmation area is copied to the active area when the tcu wraps</comment></option>
                <option name="Force_Only" value="1"><comment>The programmation area is copied into the active area only when force latch is used</comment></option>
            </options>
        </bits>
        <bits name="Wakeup_En" pos="30" access="rw" rst="0">
            <comment>Writing a 1 to enable run tcu wakeup function in lowpower skip frame
                <br/>Writing a 0 to disable 
            </comment>
        </bits>
    </reg>
    <reg name="Wrap_Val" protect="rw">
        <bits name="Wrap_Val" pos="14:0" access="rw" rst="all1" display="hex">
            <comment>TCU counter wrap value.
                <br/>The TCU counter returns to 0 when this value is reached
            </comment>
        </bits>
        <bits name="Sf_Wrap_Val" pos="18:15" access="rw" rst="all1" display="hex">
            <comment>TCU subframe counter wrap value.
                <br/>The TCU subframe counter returns to 0 when this value is reached
            </comment>
        </bits>
    </reg>
    <reg name="Cur_Val" protect="rw">
        <bits name="Cur_Val" pos="14:0" access="r" display="hex" rst="0">
            <comment>TCU counter current value
            </comment>
        </bits>
        <bits name="Cur_Sf" pos="19:16" access="r" display="hex" rst="0">
            <comment>TCU counter current sf value
            </comment>
        </bits>
    </reg>
    <reg name="Latch" protect="rw">
        <bits name="ForceLatch" pos="9:0" access="w" cut="1" cutprefix="ForceLatch_Area" rst="0">
            <comment>Writing 1 transfer the programmed events to the active area.
            </comment>
        </bits>
        <bits name="Force_NoEvent" pos="16" access="w" rst="0">
            <comment>Writing 1 to this bit with one of the ForceLatch bit will force the corresponding Active Area to receive no events (i.e. clear it) instead of transfering the programmed area.
            </comment>
        </bits>
        <bits name="ForceClear" pos="29:20" access="w" cut="1" cutprefix="ForceClear_Area" rst="0">
            <comment>writing 1 to clear the corresponding programmed area.
            </comment>
        </bits>
        <bits name="ClearProgArea" pos="31" access="w" rst="0">
            <comment>Writing 1 clears the Program Area
            </comment>
        </bits>
    </reg>
    <reg name="Setup" protect="rw">
        <bits name="TCO_Polarity" pos="NB_TCO-1:0" access="rw" rst="0" cut="1" cutprefix="POL_TCO">
            <comment>Configure the TCO polarity
            </comment>
            <options>
                <option name="Active High" value="0"/>
                <option name="Active Low" value="1"/>
            </options>
        </bits>
        <bits name="Write_Error" pos="28" access="rc" rst="0">
            <comment>Error Status: become 1 when writing to Program Area while the TCU is coping the Program Area to the Active Area. In this case the write is ignored.
                <br/>Write 1 to clear it.
            </comment>
        </bits>
        <bits name="Debug_Active" pos="31" access="rw" rst="0">
            <comment>This bit allows to access directly the active area for debug purposes
            </comment>
            <options>
                <option name="Normal" value="0"/>
                <option name="Debug" value="1"><comment>the active area is directly mapped instead of the program area.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Disable_Event" protect="rw">
        <bits name="Disable_TCO" pos="5:0" access="rw" rst="all1" cut='1' cutprefix="Disable_TCO">
            <comment>Writing 1 disable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Internal_TCO" pos="11:6" access="rw" rst="all1" cut='1' cutprefix="Disable" cutenum="Internal_TCO_mapping">
            <comment>Writing 1 disable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Send_Spi_Cmd" pos="12" access="rw" rst="1">
            <comment>Writing 1 disable the events SEND_SPI_CMD.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Next_Gain" pos="13" access="rw" rst="1">
            <comment>Writing 1 disable the events NEXT_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_First_Gain" pos="14" access="rw" rst="1">
            <comment>Writing 1 disable the events FIRST_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Next_Fc" pos="15" access="rw" rst="1">
            <comment>Writing 1 disable the events NEXT_FC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Ramp" pos="20:16" access="rw" rst="all1" cut='1' cutprefix="Disable_Ramp">
            <comment>Writing 1 disable the corresponding Ramp event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Rx_SOC" pos="21" access="rw" rst="1">
            <comment>Writing 1 disable the events RX_SOC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_DigRF_Strobe" pos="22" access="rw" rst="1">
            <comment>Writing 1 disable the events DIGRF_STB.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_RfSpi_Start" pos="24" access="rw" rst="1">
            <comment>Writing 1 disable the events RFSPI_START.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_RfSpi_End" pos="25" access="rw" rst="1">
            <comment>Writing 1 disable the events RFSPI_END.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Rf_Spi_Marked_Cmd" pos="31" access="rw" rst="1">
            <comment>Writing 1 disable the marked rf spi commands (cf RF SPI).
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>

    <reg name="Disable_Event_ext" protect="rw">
        <bits name="Disable_Bcpu_Irq" pos="1:0" access="rw" rst="all1" cut='1' cutprefix="Disable_Bcpu_Irq">
            <comment>Writing 1 disable the corresponding BCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Xcpu_Irq" pos="17:2" access="rw" rst="all1" cut='1' cutprefix="Disable_Xcpu_Irq">
            <comment>Writing 1 disable the corresponding XCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>
    
    <reg name="Enable_Event" protect="rw">
        <bits name="Enable_TCO" pos="5:0" access="rs" rst="all1" cut='1' cutprefix="Enable_TCO">
            <comment>Writing 1 enable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Internal_TCO" pos="11:6" access="rs" rst="all1" cut='1' cutprefix="Enable" cutenum="Internal_TCO_mapping">
            <comment>Writing 1 enable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Send_Spi_Cmd" pos="12" access="rs" rst="1">
            <comment>Writing 1 enable the events SEND_SPI_CMD.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Next_Gain" pos="13" access="rs" rst="1">
            <comment>Writing 1 enable the events NEXT_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_First_Gain" pos="14" access="rs" rst="1">
            <comment>Writing 1 enable the events FIRST_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Next_Fc" pos="15" access="rs" rst="1">
            <comment>Writing 1 enable the events NEXT_FC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Ramp" pos="20:16" access="rs" rst="all1" cut='1' cutprefix="Enable_Ramp">
            <comment>Writing 1 enable the corresponding Ramp event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Rx_SOC" pos="21" access="rs" rst="1">
            <comment>Writing 1 enable the events RX_SOC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_DigRF_Strobe" pos="22" access="rs" rst="1">
            <comment>Writing 1 enable the events DIGRF_STB.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_RfSpi_Start" pos="24" access="rw" rst="1">
            <comment>Writing 1 enable the events RFSPI_START.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_RfSpi_End" pos="25" access="rw" rst="1">
            <comment>Writing 1 enable the events RFSPI_END.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Rf_Spi_Marked_Cmd" pos="31" access="rs" rst="1">
            <comment>Writing 1 enable the marked rf spi commands (cf RF SPI).
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>

    <reg name="Enable_Event_ext" protect="rw">
        <bits name="Enable_Bcpu_Irq" pos="1:0" access="rs" rst="all1" cut='1' cutprefix="Enable_Bcpu_Irq">
            <comment>Writing 1 enable the corresponding BCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Xcpu_Irq" pos="17:2" access="rs" rst="all1" cut='1' cutprefix="Enable_Xcpu_Irq">
            <comment>Writing 1 enable the corresponding XCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>

    <reg name="Set_TCO" protect="rw">
        <bits name="Set_TCO" pos="NB_TCO-1:0" access="s" cut='1' cutprefix="Set_TCO" rst="0">
            <comment>Writing 1 set corresponding TCO to the active state (The actual line state also depends on TCO_Polarity).
                <br/>Reading returns the actual state of all TCOs.
            </comment>
        </bits>
    </reg>
    <reg name="Clr_TCO" protect="rw">
        <bits name="Clr_TCO" pos="NB_TCO-1:0" access="c" cut='1' cutprefix="Clr_TCO" rst="0">
            <comment>Writing 1 set corresponding TCO to the inactive state (The actual line state also depends on TCO_Polarity).
                <br/>Reading returns the actual state of all TCOs.
            </comment>
        </bits>
    </reg>

    <reg name="Cfg_Clk_Div" protect="rw">
        <bits name="Qbit_Div" pos="5:0" access="rw" rst="31">
            <comment>qbit divider, qbit freq is clk_tcu divided by (Qbit_Div + 1).
            </comment>
        </bits>
        <bits name="TCU_Clk_Same_Sys" pos="29" access="rw" rst="0">
            <comment>Enable Clk_TCU same with Clk_Sys.
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Enable_DAI_Simple_208K" pos="30" access="rw" rst="0">
            <comment>Enable the 208kHz pulse generation for DAI Simple. (!) When enabling the clock field Enable_Qbit should also be enabled.
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Enable_Qbit" pos="31" access="rw" rst="0">
            <comment>Enable the Quarter bit generation (required for normal TCU operation)
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="TCU_IRQ" protect="rw">
        <bits name="TCU_Sync_Done_Cause" pos="0" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the tcu counter synchronization is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="TCU_IRQ_Cause">
            <entry ref="TCU_Sync_Done_Cause"/>
        </bitgroup>

        <bits name="TCU_Sync_Done_Status" pos="16" access="rc" rst="0">
            <comment>1 when the tcu counter synchronization is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="TCU_IRQ_Status">
            <entry ref="TCU_Sync_Done_Status"/>
        </bitgroup>
    </reg>
    <reg name="TCU_IRQ_Mask" protect="rw">
        <bits name="TCU_Sync_Done_Mask" pos="0" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_TCU_Sync_Done is enabled.
            </comment>
        </bits>
        <bitgroup name="TCU_IRQ_Mask">
            <entry ref="TCU_Sync_Done_Mask"/>
        </bitgroup>
    </reg>
    <reg name="GLOBAL_SYNC_CTRL" protect="rw">
        <bits name="TCU_Sync_Enable" pos="0" access="rw" rst="0">
            <comment>enable sync tcu counter to global counter function.
            </comment>
        </bits>
        <bits name="TCU_Sync_Value" pos="16:2" access="rw" rst="0">
            <comment>tcu counter load value when synchronized.
            </comment>
        </bits>
        <bits name="TCU_Sync_Sf" pos="20:17" access="rw" rst="0">
            <comment>tcu counter load subframe value when synchronized.
            </comment>
        </bits>
    </reg> 
    <reg name="TCO_DBG_SEL" protect="rw">
        <bits name="tco_dbg0_sel" pos="3:0" access="rw" rst="0">
        </bits>
        <bits name="tco_dbg1_sel" pos="7:4" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="Rfspi_Conflict_Val" protect="rw">
        <bits name="Rfspi_Conflict_Val" pos="13:0" access="r" display="hex" rst="0">
            <comment>TCU counter value when rfspi conflict happen
            </comment>
        </bits>
    </reg>
    <reg name="Snapshot" protect="r">
        <bits name="Snapshot_X" pos="1:0" access="r" rst="0">
            <comment>Value of snapshots, snapshot value is automatically incremented at frame interrupt. This snapshot counter wrap at the value given by Snapshot_Cfg.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Snapshot_B" pos="3:2" access="r" rst="0">
            <comment>Value of snapshots, snapshot value is automatically incremented at frame interrupt. This snapshot counter wrap at the value given by Snapshot_Cfg.
            </comment>
            <options><mask/><shift/></options>
        </bits>
    </reg>
    <reg name="Snapshot_Cfg" protect="rw">
        <bits name="Snapshot_Cfg"  pos="0" access="rw" rst="0">
            <comment>Number of snapshot.
            </comment>
          </bits>
    </reg>
    <reg name="Subframe_Mask" protect="rw">
        <bits name="mask_auto_clr_en" pos="31" access="rw" rst="0">
            <comment>enable subframe mask bits auto clear.
            </comment>
        </bits>
        <bits name="subframe_mask_clr" pos="29:20" access="w" cut="1" cutprefix="clr_subframe_mask" rst="all0">
            <comment>write 1 to clear the corresponding subframe mask bit.
            </comment>
        </bits>
        <bits name="subframe_mask_set" pos="19:10" access="w" cut="1" cutprefix="set_subframe_mask" rst="all0">
            <comment>write 1 to set the corresponding subframe mask bit.
            </comment>
        </bits>
        <bits name="subframe_mask" pos="9:0" access="r" cut="1" cutprefix="subframe_mask" rst="0">
            <comment>subframe mask value.
            </comment>
        </bits>
    </reg>
    <hole size="1408"/>
    <reg name="Event" protect="rw" count="NB_TCU_PROG_EVENTS">
        <bits name="Event_Time" pos="14:0" access="rw" rst="all1">
            <comment>The event Id will be executed when the TCU counter reaches the value programmed in Event time field of this register.
            </comment>
        </bits>
        <bits name="Event_Id" pos="21:16" access="rw" rst="all1">
            <comment>Event to be executed when the TCU counter reaches the programmed event time.
                <br/>
            </comment>
            <options linkenum="TCU_Event">
                <default />
            </options>
        </bits>
    </reg>

</module>

</archive>
<archive relative = "timer.xml">

<module name="timer" category="System">
    <var name = "NB_INTERVAL" value="1"/>
    <var name = "INT_TIMER_NB_BITS" value="24"/>
    <var name = "WD_TIMER_NB_BITS" value="24"/>
    <var name = "HW_TIMER_NB_BITS" value="32"/>
    <var name = "TIM_MAXVAL" value="0xffffff"/>

    <reg name="OSTimer_Ctrl" protect="rw">
        <bits name="LoadVal" pos="23:0" access="rw" rst="0">
            <comment>Value loaded to OS timer.
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="Enable" pos="24" access="rw" rst="0">
            <comment>Write '1' to this bit will enable OS timer.
                <br/>When read, the value is what we have written to this bit, it changes immediately  after been written.
            </comment>
        </bits>
        <bits name="Enabled" pos="25" access="r" rst="0">
            <comment>Read this bit will get the information if OS timer is really enabled or not. This bit will change only after the next front of 16 KHz system clock.
                <br/>
                <br/>'1' indicates OS timer enabled.
                <br/>'0' indicates OS timer not enabled.
            </comment>
        </bits>
        <bits name="Cleared" pos="26" access="r" rst="0">
            <comment>Read this bit will get the information if OS timer interruption clear operation is finished or not.
                <br/>
                <br/>'1' indicates OS timer interruption clear operation is on going.
                <br/>'0' indicates no OS timer interruption clear operation is on going.
            </comment>
        </bits>
        <bits name="Repeat" pos="28" access="rw" rst="0">
            <comment>Write '1' to this bit will set OS timer to repeat mode.
                <br/>When read, get the information if OS timer is in repeat mode.
                <br/>
                <br/>'1' indicates OS timer in repeat mode.
                <br/>'0' indicates OS timer not in repeat mode.
            </comment>
        </bits>
        <bits name="Wrap" pos="29" access="rw" rst="0">
            <comment>Write '1' to this bit will set OS timer to wrap mode.
                <br/>When read, get the information if OS timer is in wrap mode.
                <br/>
                <br/>'1' indicates OS timer in wrap mode.
                <br/>'0' indicates OS timer not in wrap mode.
            </comment>
        </bits>
        <bits name="Load" pos="30" access="rw" rst="0">
            <comment>Write '1' to this bit will load the initial value to OS timer.
            </comment>
        </bits>
    </reg>
    <reg name="OSTimer_CurVal" protect="rw">
        <bits name="CurVal" pos="31:0" access="r" rst="-">
            <comment>Current value of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.
            </comment>
        </bits>
    </reg>
    
    <hole size="2*32" />
    <reg name="HWTimer_Ctrl" protect="rw">
        <bits name="Interval_En" pos="8" access="rw" rst="0">
            <comment>This bit enables interval IRQ mode.
                <br/>
                <br/>'0': hw delay timer does not generate interval IRQ.
                <br/>'1': hw delay timer generate an IRQ each interval.
            </comment>
        </bits>
        <bits name="Interval" pos="1:0" access="rw" rst="00">
            <comment> interval of generating an HwTimer IRQ. 
                <br/>
                <br/>"00": interval of 1/8 second.
                <br/>"01": interval of 1/4 second.
                <br/>"10": interval of 1/2 second.
                <br/>"11": interval of 1 second.
            </comment>
        </bits>
    </reg>
    <reg name="HWTimer_CurVal_L" protect="rw">
        <bits name="CurVal_L" pos="31:0" access="r" rst="0">
            <comment>Current value of the hardware delay timer. The value is incremented every 61 us. This timer is running all the time and wrap at value 0xFFFFFFFF_FFFFFFFF.
            </comment>
        </bits>
    </reg>
    <reg name="HWTimer_CurVal_H" protect="rw">
        <bits name="CurVal_H" pos="31:0" access="r" rst="0">
            <comment>Current value of the hardware delay timer. The value is incremented every 61 us. This timer is running all the time and wrap at value 0xFFFFFFFF_FFFFFFFF.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Mask_Set" protect="rw">
        <bits name="OSTimer_Mask" pos="0" access="rs" rst="0">
            <comment>Set mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Mask" pos="1" access="rs" rst="0">
            <comment>Set mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Mask" pos="2" access="rs" rst="0">
            <comment>Set mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Mask_Clr" protect="rw">
        <bits name="OSTimer_Mask" pos="0" access="rc" rst="0">
            <comment>Clear mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Mask" pos="1" access="rc" rst="0">
            <comment>Clear mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Mask" pos="2" access="rc" rst="0">
            <comment>Clear mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Clr" protect="rw">
        <bits name="OSTimer_Clr" pos="0" access="c" rst="0">
            <comment>Clear OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Clr" pos="1" access="c" rst="0">
            <comment>Clear hardware delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Clr" pos="2" access="c" rst="0">
            <comment>Clear hardware delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Cause" protect="rw">
        <bits name="OSTimer_Cause" pos="0" access="r" rst="0">
            <comment>OS timer IRQ cause.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Cause" pos="1" access="r" rst="0">
            <comment>hardware delay timer wrap IRQ cause.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Cause" pos="2" access="r" rst="0">
            <comment>hardware delay timer interval IRQ cause.
            </comment>
        </bits>
        <bits name="OSTimer_Status" pos="16" access="r" rst="0">
            <comment>OS timer IRQ status.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Status" pos="17" access="r" rst="0">
            <comment>hardware delay timer wrap IRQ status.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Status" pos="18" access="r" rst="0">
            <comment>hardware delay timer interval IRQ status.
            </comment>
        </bits>
        <bitgroup name="Other_Tims_irq">
            <entry ref="HWTimer_Wrap_Cause"/>
            <entry ref="HWTimer_Itv_Cause"/>
        </bitgroup>
    </reg>
</module>

</archive>

<archive relative = "uart.xml">
<module name="uart" category="Periph">
  <var  name="UART_RX_FIFO_SIZE"    value="128"  />
  <var  name="UART_TX_FIFO_SIZE"    value="16"  />
  <var  name="NB_RX_FIFO_BITS"      value="7"   />
  <var  name="NB_TX_FIFO_BITS"      value="4"   />

  
  <reg protect="rw" name="ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Allows to turn off the UART:<br />0 = Disable<br />1 = Enable
      </comment>
    </bits>

    <bits access="rw" name="Data Bits" pos="1" rst="0">
        <comment>Number of data bits per character (least significant bit first), 
          if {Data_Bits_56, Data_Bits} is 00, the number of data bits is 7;
          if {Data_Bits_56, Data_Bits} is 01, the number of data bits is 8;
          if {Data_Bits_56, Data_Bits} is 10, the number of data bits is 5;
          if {Data_Bits_56, Data_Bits} is 11, the number of data bits is 6;
      </comment>
    </bits>

    <bits access="rw" name="Tx Stop Bits" pos="2" rst="0">
      <options>
        <option name="1_BIT" value="0" />

        <option name="2_BITS" value="1" />

        <default />
      </options>

      <comment>Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).<br />0 = one stop bit is
      transmitted in the serial data.<br />1 = two stop bits are generated and
      transmitted in the serial data out. </comment>
    </bits>

    <bits access="rw" name="Parity Enable" pos="3" rst="0">
      <options>
        <option name="NO" value="0" />

        <option name="YES" value="1" />

        <default />
      </options>

      <comment> Parity is enabled when this bit is set. </comment>
    </bits>

    <bits access="rw" name="Parity Select" pos="5:4" rst="0">
      <options>
        <option name="ODD" value="0" />

        <option name="EVEN" value="1" />

        <option name="SPACE" value="2" />

        <option name="MARK" value="3" />

        <default />
      </options>

      <comment> Controls the parity format when parity is enabled:<br />00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).<br />01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).<br />10 = a space is
      generated and received as parity bit.<br />11 = a mark is generated and
      received as parity bit. </comment>
    </bits>

    <bits access="rw" name="soft flow ctrl enable" pos="6" rst="0">
      <comment> Controls whether enable or disable soft flow ctrl function. <br />0 = disable flow ctrl function 
      <br />1 = enable flow ctrl function </comment>
    </bits>

    <bits access="rw" name="auto_enable" pos="8" rst="0">
      <comment> Controls whether enable or disable auto baud rate function. <br />0 = disable auto baud rate function 
      <br />1 = enable auto baud rate function </comment>
    </bits>

    <bits access="rw" name="Data Bits_56" pos="12" rst="0">
        <comment>Number of data bits per character (least significant bit first), 
          if {Data_Bits_56, Data_Bits} is 00, the number of data bits is 7;
          if {Data_Bits_56, Data_Bits} is 01, the number of data bits is 8;
          if {Data_Bits_56, Data_Bits} is 10, the number of data bits is 5;
          if {Data_Bits_56, Data_Bits} is 11, the number of data bits is 6;
      </comment>
    </bits>

    <bits access="rw" name="Divisor Mode" pos="20:19" rst="2'h1">
      <comment>Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.<br />0 =
      (BCLK = SCLK / 16)<br />1 = (BCLK = SCLK / 4) <br />2 = (BCLK = SCLK / 3) </comment>
    </bits>

    <bits access="rw" name="IrDA Enable" pos="21" rst="0">
      <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details). </comment>
    </bits>

    <bits access="rw" name="DMA Mode" pos="22" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC. </comment>
    </bits>
    
    <bits access="rw" name="Auto Flow Control" pos="23" rst="0">
      <options>
        <option name="ENABLE" value="1" />
        
        <option name="DISABLE" value="0" />
        
        <default />
      </options>
      <comment>Enables the auto flow control. Uart_RTS is controlled by the Rx
      RTS bit and the UART Auto Control Flow System. If Uart_CTS
      become inactive high, the Tx data flow is stopped. </comment>
    </bits>

    <bits access="rw" name="Loop Back Mode" pos="24" rst="0">
      <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support). </comment>
    </bits>

    <bits access="rw" name="Rx Lock Err" pos="25" rst="0">
      <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept. </comment>
    </bits>

    <bits access="rw" name="Rx Break Length" pos="31:28" rst="0xF">
      <comment>Length of a break, in number of bits. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Rx Fifo Level" pos="NB_RX_FIFO_BITS:0" rst="0">
       <options>
            <mask/>
            <shift/>
        </options>
        <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read. </comment>
    </bits>

    <bits access="r" name="Tx Fifo space" pos="NB_TX_FIFO_BITS+8:8" rst="5'h10">
        <options>
            <mask/>
            <shift/>
        </options>
        <comment>Those bits indicate the number of space available in the Tx
      Fifo. </comment>
    </bits>

    <bits access="r" name="at_match_flag" pos="13" rst="0">
      <comment> at_match flag
            <br/> '0' = AT is detected successfully. 
            <br/> '1' = at is detected successfully. 
            When auto_enable is 0,this bit is cleared to 0.
       </comment>
    </bits>
    <bits access="r" name="Tx Active" pos="14" rst="0">
      <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface. </comment>
    </bits>

    <bits access="r" name="Rx Active" pos="15" rst="0">
      <comment>This bit indicates that the UART is receiving a byte.
      </comment>
    </bits>

    <bits access="r" name="Rx Overflow Err" pos="16" rst="0">
      <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Tx Overflow Err" pos="17" rst="0">
      <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when 
          the UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Parity Err" pos="18" rst="0">
      <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Framing Err" pos="19" rst="0">
      <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Break Int" pos="20" rst="0">
      <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value. </comment>
    </bits>

    <bits access="r" name="character_miscompare" pos="21" rst="0">
      <comment> character miscompare flag
            <br/> '0' = AT or at compare failed. 
            <br/> '1' = AT or at compare successfully. 
            When auto_enable is 0,this bit is cleared to 0.
       </comment>
    </bits>

    <bits access="r" name="auto_baud_locked" pos="22" rst="0">
      <comment> auto baud locked flag
            <br/> '0' = baud rate is detected failed. 
            <br/> '1' = baud rate is detected successfully. 
            When auto_enable is 0,this bit is cleared to 0.
       </comment>
    </bits>

    <bits access="r" name="DCTS" pos="24" rst="1">
      <comment>This bit is set when the Uart_CTS line changed since the last
      time this register has been written. This bit is cleared when the
      UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="CTS" pos="25" rst="0">
        <comment>current value of the Uart_CTS line. 
            <br/> '1' = Tx not allowed. 
            <br/> '0' = Tx allowed. 
      </comment>
    </bits>

    <bits access="r" name="Auto ratio flag" pos="26" rst="0">
      <comment>Auto mode ratio flag.
      </comment>
    </bits>
    
    <bits access="r" name="Mask tx enable flag" pos="27" rst="0">
      <comment>Mask tx enable flag.
      </comment>
    </bits>
    
    <bits access="r" name="DTR" pos="28" rst="0">
      <comment>Current value of the DTR line.
      </comment>
    </bits>
    
    <bits access="r" name="Clk Enabled" pos="31" rst="0">
      <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      RTS too early.</comment>
    </bits>
  </reg>

  <reg protect="--" name="rxtx_buffer">
    <bits access="r" name="Rx Data" pos="7:0" rst="no">
      <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. </comment>
    </bits>

    <bits access="w" name="Tx Data" pos="7:0" rst="no">
      <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="irq_mask">
    <bits access="rw" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal change detected. </comment>
    </bits>

    <bits access="rw" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. </comment>
    </bits>

    <bits access="rw" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>Pulse detected on Uart_Dma_Tx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>Pulse detected on Uart_Dma_Rx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.
        </comment>
    </bits>

    <bits access="rw" name="DTR RISE" pos="8" rst="0">
      <comment>Rising edge detected on the UART_DTR signal. 
      </comment>
    </bits>

    <bits access="rw" name="DTR FALL" pos="9" rst="0">
      <comment>Falling edge detected on the UART_DTR signal. 
      </comment>
    </bits>
  
    <bits access="rw" name="Auto Fail" pos="10" rst="0">
      <comment>Auto function fail. 
      </comment>
    </bits>
  
    <bits access="rw" name="Uart dma rx adone" pos="11" rst="0">
      <comment>When rx transfer num equals to transfer threshold, there is a interrupt flag. 
      </comment>
    </bits>
  
    <bits access="rw" name="Uart dma tx adone" pos="12" rst="0">
      <comment>When tx transfer num equals to transfer threshold, there is a interrupt flag. 
      </comment>
    </bits>
  
    <bits access="rw" name="xoff_trig" pos="13" rst="0">
      <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xoff.
      </comment>
    </bits>
  
    <bits access="rw" name="xon_trig" pos="14" rst="0">
      <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xon.
      </comment>
    </bits>
  
    <bits access="rw" name="start_det" pos="15" rst="0">
      <comment>This interrupt is generated when start bit is detected.
      </comment>
    </bits>
  
  </reg>

  <reg protect="rw" name="irq_cause">
    <bits access="r" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level. </comment>
    </bits>

    <bits access="r" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.
      </comment>
    </bits>

    <bits access="r" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.
            Reset control: Write one in this register.
        </comment>    
    </bits>

    <bits access="rw" name="DTR RISE" pos="8" rst="0">
      <comment>This interrupt is generated when a rising edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="DTR FALL" pos="9" rst="0">
      <comment>This interrupt is generated when a falling edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.
      </comment>
    </bits>
    
    <bits access="rw" name="Auto Fail" pos="10" rst="0">
      <comment>This interrupt is generated when auto function fail.
      Reset control: Write  0 in auto_enable.
      </comment>
    </bits>
    
    <bits access="rw" name="Uart dma rx adone" pos="11" rst="0">
      <comment>This interrupt is generated when rx transfer num is not less than transfer threshold.
      Reset control: Write  1 in this register.
      </comment>
    </bits>
    
    <bits access="rw" name="Uart dma tx adone" pos="12" rst="0">
      <comment>This interrupt is generated when tx transfer num is not less than transfer threshold.
      Reset control: Write  1 in this register.
      </comment>
    </bits>
    
    <bits access="rw" name="xoff_trig" pos="13" rst="0">
      <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xoff.
      Reset control: Write  1 in this register.
      </comment>
    </bits>
    
    <bits access="rw" name="xon_trig" pos="14" rst="0">
      <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xon.
      Reset control: Write  1 in this register.
      </comment>
    </bits>
    
    <bits access="rw" name="start_det" pos="15" rst="0">
      <comment>This interrupt is generated when start is detected.
      Reset control: Write  1 in this register.
      </comment>
    </bits>
    
    <bits access="r" name="Tx Modem Status U" pos="16" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Data Available U" pos="17" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed U" pos="18" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Timeout U" pos="19" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Line Err U" pos="20" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Dma Done U" pos="21" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Done U" pos="22" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Timeout U" pos="23" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="DTR RISE U" pos="24" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="DTR FALL U" pos="25" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Auto fail U" pos="26" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
    <bits access="rw" name="Uart dma rx adone U" pos="27" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
    <bits access="rw" name="Uart dma tx adone U" pos="28" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
    <bits access="rw" name="xoff_trig U" pos="29" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
    <bits access="rw" name="xon_trig U" pos="30" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
    <bits access="rw" name="start_det U" pos="31" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
  </reg>

  <reg protect="rw" name="triggers">
    <bits access="rw" name="Rx Trigger" pos="NB_RX_FIFO_BITS-1:0" rst="0">
      <comment>Defines the empty threshold level at which the Data Available
      Interrupt will be generated. <br />The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.</comment>
    </bits>

    <bits access="rw" name="Tx Trigger" pos="NB_TX_FIFO_BITS-1+8:8" rst="0">
      <comment>Defines the empty threshold level at which the Data Needed
      Interrupt will be generated.<br />The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.</comment>
    </bits>

    <bits access="rw" name="AFC Level" pos="NB_RX_FIFO_BITS-1+16:16" rst="0">
      <comment>Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).<br />The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="CMD_Set">
    <bits access="rs" name="RI" pos="0" rst="0">
        <comment>Ring indicator. When write '1', set RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>
    
    <bits access="rs" name="DCD" pos="1" rst="0">
        <comment>Data carrier detect. When write '1', set DCD bit. When read, get DCD
            bit value.
        </comment>
    </bits>
    
    <bits access="rs" name="DSR" pos="2" rst="0">
        <comment>Data set ready. When write '1', set RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>
    
    <bits access="rs" name="Tx Break Control" pos="3" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared. </comment>
    </bits>
    
    <bits access="rs" name="Tx Finish n Wait" pos="4" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>  

    <bits access="rs" name="RTS" pos="5" rst="0">
        <comment>Controls the Uart_RTS output.
            <br />0 = the Uart_RTS will be inactive high (Rx not allowed).
            <br />1 = the Uart_RTS will be active low (Rx allowed).
        </comment>
    </bits>
    
    <bits access="r" name="Rx Fifo Reset" pos="6" rst="0">
      <comment> Writing a 1 to this bit resets and flushes the Receive Fifo.
      This bit does not need to be cleared. </comment>
    </bits>
    
    <bits access="r" name="Tx Fifo Reset" pos="7" rst="0">
      <comment> Writing a 1 to this bit resets and flushes the Transmit Fifo.
      This bit does not need to be cleared. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="CMD_Clr">
    <bits access="rc" name="RI" pos="0" rst="0">
        <comment>Ring indicator. When write '1', clear RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>

    <bits access="rc" name="DCD" pos="1" rst="0">
        <comment>Data carrier detect. When write '1', clear DCD bit. When read, get DCD
            bit value.
        </comment>
    </bits>

    <bits access="rc" name="DSR" pos="2" rst="0">
        <comment>Data set ready. When write '1', clear RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>

    <bits access="rc" name="Tx Break Control" pos="3" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared. </comment>
    </bits>
    
    <bits access="rc" name="Tx Finish n Wait" pos="4" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>  

    <bits access="rc" name="RTS" pos="5" rst="0">
        <comment>Controls the Uart_RTS output.
            <br />0 = the Uart_RTS will be inactive high.
            <br />1 = the Uart_RTS will be active low.
        </comment>
    </bits>
    
  </reg>
  
  <reg protect="r" name="Auto ratio">
    <bits access="r" name="Auto ratio" pos="15:0" rst="0">
        <comment>Auto mode ratio.
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="XON">
    <bits access="rw" name="XON" pos="7:0" rst="8'h11">
        <comment>XON character value. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="XOFF">
    <bits access="rw" name="XOFF" pos="7:0" rst="8'h13">
        <comment>XOFF character value. </comment>
    </bits>
  </reg>

</module>


</archive>
<archive relative = "wdt.xml">

<module name="wdt" category="System">

  <reg name="wdt_cvr0" protect="rw">
    <bits access="rw" name="count_value_0" pos="23:0" rst="0xffffff">
      <comment>Count Value for 1st TimeOut
      </comment>
    </bits>
  </reg>

  <reg name="wdt_cvr1" protect="rw">
    <bits access="rw" name="count_value_1" pos="23:0" rst="0xffffff">
      <comment>Count Value for 2nd TimeOut
      </comment>
    </bits>
  </reg>

  <reg name="wdt_cr" protect="rw">
    <bits access="rw" name="mode" pos="4:4" rst="0x1">
      <comment>Watchdog response mode.
          <br/>0 = Generate a system reset.
          <br/>1 = First generate an interrupt and if it is not cleared by the time a second timeout occurs then generate a system reset.
      </comment>
    </bits>
    <bits access="rw" name="reset_length" pos="2:0" rst="0x0">
      <comment>Reset pulse length in number of wdt clock cycles. The range of values available is 1 to 8 clk cycles.
          <br/>3'b000 - 1 clk cycle
          <br/>3'b001 - 2 clk cycles
          <br/>3'b010 - 3 clk cycles
          <br/>...
          <br/>3'b111 - 8 clk cycles
      </comment>
    </bits>
  </reg>

  <reg name="wdt_cmd" protect="rw">
    <bits access="rw" name="cmd" pos="7:0" rst="0x0">
      <comment>This register is used to restart/stop the WDT counter. As a safety feature to prevent accidental restarts/stops, write 8'h76 to restart and 8'h34 to stop.
          <br/>When written is done, this register is self-cleared on the next clock cycle. Reading this register always returns zero.
      </comment>
      <options>
             <option name="RESTART" value ="0x76"></option>
             <option name="STOP" value ="0x34"></option>
             <mask/><shift/><default/>
      </options>
    </bits>
  </reg>

  <reg name="wdt_icr" protect="rw">
    <bits access="rw" name="int_clr" pos="0:0" rst="0x0">
      <comment>A pulse to clear interrupt.
          <br/>When written is done, this register is self-cleared on the next clock cycle. Reading this register always returns zero.
      </comment>
    </bits>
  </reg>

  <reg name="wdt_sr" protect="r">
    <bits access="r" name="wdt_active" pos="1:1" rst="0x0">
      <comment>This register shows the word status of the WDT.
          <br/>0 = The watchdog counter is idle/stopped.
          <br/>1 = The watchdog counter runs.
      </comment>
    </bits>
    <bits access="r" name="int_assert" pos="0:0" rst="0x0">
      <comment>This register shows the interrupt status of the WDT.
          <br/>0 = Interrupt is inactive.
          <br/>1 = Interrupt asserts.
      </comment>
    </bits>
  </reg>

</module>
</archive>


<archive relative = "config.xml">
<include file="globals.xml"/>
  
  
  <var name="SYS_ROM_BASE" value="0x00000000"><comment>ROM base FOR ARM</comment></var>
  <var name="SYS_RAM_BASE" value="0x21c00000"><comment>SYS RAM base FOR ARM</comment></var>
  <var name="NB_RAM_BASE" value="0x21d80000"><comment>NB RAM base FOR ARM</comment></var>
  <var name="EXT_RAM_BASE" value="0x08000000"><comment>FLASH base FOR ARM</comment></var>
  <var name="PSRAM8_BASE" value="0x62000000"><comment>PSRAM8 base FOR ARM</comment></var>
  <var name="REG_SYS_APB1_BASE" value="0x41800000"><comment>System APB1 base FOR ARM</comment></var>
  <var name="REG_SYS_APB2_BASE" value="0x41a00000"><comment>System APB2 base FOR ARM</comment></var>
  <var name="REG_BB_APB_BASE" value="0x41900000"><comment>Baseband APB base FOR ARM</comment></var>
  <var name="SYS_MED_BASE" value="0xC000000"><comment>MED base FOR ARM</comment></var>

  
  
  <instance address="0x00000000" type="debug_host_internal_registers" name="INT_REG_DBG_HOST" />
  

  
  
  <instance address="SYS_ROM_BASE" type="sys_drom" name="SYS_ROM" />
  <instance address="SYS_ROM_BASE + 0x10000" type="sys_irom" name="NB_ROM" />
  <instance address="SYS_RAM_BASE" type="sys_ram1" name="SYS_RAM0" />
  <instance address="SYS_RAM_BASE + 0x40000" type="sys_ram1" name="SYS_RAM1" />
  <instance address="SYS_RAM_BASE + 0x80000" type="sys_ram1" name="SYS_RAM2" />
  <instance address="SYS_RAM_BASE + 0xc0000" type="sys_ram0" name="SYS_RAM3" />
  <instance address="NB_RAM_BASE"  type="nb_ram" name="NB_RAM" />
  <instance address="PSRAM8_BASE" type="psram" name="PSRAM8_MEM" />
  <instance address="EXT_RAM_BASE" type="flash" name="FLASH_MEM" />
  <instance address="EXT_RAM_BASE + 0x2000000" type="flash" name="FLASH_EXT_MEM" />

  
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_UART1" type="uart" name="UART1" />
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_UART2" type="uart" name="UART2" />
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_GPIO1" type="gpio1" name="GPIO1" />
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_GPT1" type="gpt_lite" name="GPT1" />
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_PWR_CTRL" type="pmuc" name="PWR_CTRL" />
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_NB_LPS" type="lps" name="NB_LPS" />
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_TIMER1" type="timer" name="TIMER1" />
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_IOMUX1" type="iomux1" name="IOMUX1" />
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_IOMUX2" type="iomux2" name="IOMUX2" />
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_SYS_WDT" type="wdt" name="SYS_WDT" />
  <instance address="REG_SYS_APB1_BASE + SYS_APB1_STEP * SYS_ID1_SYS_IFC1" type="sys_ifc1" name="SYS_IFC1" />

  
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SCI2" type="sci" name="SCI2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SPI1" type="spi" name="SPI1" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SPI2" type="spi" name="SPI2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_DEBUG_UART" type="debug_uart" name="DEBUG_UART" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_UART3" type="uart" name="UART3" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_UART4" type="uart" name="UART4" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_UART5" type="uart" name="UART5" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SDMMC2" type="sdmmc2" name="SDMMC2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_I2S" type="i2s" name="I2S" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SYS_IFC2" type="sys_ifc2" name="SYS_IFC2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_DEBUG_HOST" type="debug_host" name="DEBUG_HOST" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_GPIO2" type="gpio" name="GPIO2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_GPT2" type="gpt" name="GPT2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_GPT2 + 0x400" type="gpt" name="GPT3" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_GPT2 + 0x800" type="gpt" name="GPT4" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_KEYPAD" type="keypad" name="KEYPAD" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SEG_LCD" type="seg_lcd" name="SEG_LCD" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_I2C1" type="i2c_master" name="I2C1" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_I2C2" type="i2c_master" name="I2C2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_I2C3" type="i2c_master" name="I2C3" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_TIMER2" type="timer" name="TIMER2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_DMA" type="dma" name="SYS_DMA" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_CTRL" type="sys_ctrl" name="SYS_CTRL" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_ROM_PATCH" type="rom_patch" name="ROM_PATCH" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_PSRAM8_CTRL" type="psram8_ctrl" name="PSRAM8_CTRL" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_MED" type="med" name="MED" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_CE_SEC" type="ce_sec_top" name="CE_SEC" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_CE_PUB" type="ce_pub_top" name="CE_PUB" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_EFUSE" type="efuse" name="EFUSE" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SPIFLASH" type="spi_flash" name="SPI_FLASH" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SPIFLASH_EXT" type="spi_flash" name="SPIFLASH_EXT" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_ADI_IF" type="adi_mst" name="ADI_IF" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_MC" type="master_ctrl_top_rf" name="MC" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SFW1" type="slv_fw_sysifc1_apb_rf" name="SFW1" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SFW2" type="slv_fw_sysifc2_apb_rf" name="SFW2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SFW3" type="slv_fw_sysifc2_ahb_rf" name="SFW3" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SFW4" type="slv_fw_bbifc_ahb_rf" name="SFW4" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_SFW5" type="slv_fw_bbifc_apb_rf" name="SFW5" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_MFW_NBRAM" type="mem_fw_bb_nbiot_top_rf" name="MFW_NBRAM" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_MFW_SRAM0" type="mem_fw_sys_ram0_rf" name="MFW_SRAM0" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_MFW_SRAM1" type="mem_fw_sys_ram1_rf" name="MFW_SRAM1" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_MFW_SRAM2" type="mem_fw_sys_ram2_rf" name="MFW_SRAM2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_MFW_SRAM3" type="mem_fw_sys_ram3_rf" name="MFW_SRAM3" />
  
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_MFW_FLASH" type="mem_fw_flash1_rf" name="MFW_FLASH" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB2_STEP * SYS_ID2_MFW_FLASH_EXT" type="mem_fw_flash2_rf" name="MFW_FLASH_EXT" />

  
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_SCI1" type="sci" name="SCI1" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_NB_RF_SPI" type="rf_spi" name="NB_RF_SPI" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_NB_TCU" type="tcu" name="NB_TCU" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_RF_IF" type="rf_if" name="RF_IF" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_RF_INTERFACE" type="rf_dig" name="RF_INTERFACE"/>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_DFE" type="dfe" name="DFE"/>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_RFFE" type="rffe_reg" name="RFFE"/>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BB_IFC" type="bb_ifc" name="BB_IFC" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BB_CTRL" type="bb_ctrl" name="BB_CTRL" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_NB_CTRL" type="nb_ctrl" name="NB_CTRL" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_COMMON" type="nb_common" name="NB_COMMON" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_INTC" type="nb_intc" name="NB_INTC" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_CS" type="nb_cell_search" name="NB_CS" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_FFT" type="nb_fft_rsrp" name="NB_FFT_RSRP" />
  
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_FFT + 0x200" type="nb_ca_rx_dump" name="NB_CA_RX_DUMP" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_FFT + 0x400" type="nb_acc" name="NB_ACC" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_VITERBI" type="nb_viterbi" name="NB_VITERBI" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_MEAS" type="nb_meas" name="NB_MEAS" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_MEAS + 0x400" type="nb_locseq_gen" name="NB_LOCSEQ_GEN" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_DS_BSEL" type="nb_ds_bsel" name="NB_DS_BSEL" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_DS_BSEL + 0x100" type="SP" name="NB_SP" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_TX_PUSCH" type="nb_tx_pusch_encoder" name="NB_TX_PUSCH" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_TX_CHSC" type="nb_tx_chsc" name="NB_TX_CHSC" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_TX_CHSC + 0x100" type="nb_tx_mdd" name="NB_TX_MDD" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_TX_FE" type="nb_tx_frontend" name="NB_TX_FRONTEND" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_TX_FE + 0x200" type="nb_ca_tx_dump" name="NB_CA_TX_DUMP" />
  
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_F8" type="cipher_f8" name="CIPHER_F8" />

  <instance address="0xe000e000" type="SCnSCB" name="SCnSCB" />
  <instance address="0xe000ed00" type="SCB" name="SCB" />
  <instance address="0xe000e010" type="SysTick" name="SysTick" />
  <instance address="0xe000e100" type="NVIC" name="NVIC" />
  <instance address="0xe000ed90" type="MPU" name="MPU" />
  <instance address="0xe000edd0" type="SAU" name="SAU" />
  <instance address="0xe000ef30" type="FPU" name="FPU" />
  <instance address="0xe002e000" type="SCnSCB" name="SCnSCB_NS" />
  <instance address="0xe002ed00" type="SCB" name="SCB_NS" />
  <instance address="0xe002e010" type="SysTick" name="SysTick_NS" />
  <instance address="0xe002e100" type="NVIC" name="NVIC_NS" />
  <instance address="0xe002ed90" type="MPU" name="MPU_NS" />
  <instance address="0xe002ef30" type="FPU" name="FPU_NS" />

</archive>

</bigarchive>
